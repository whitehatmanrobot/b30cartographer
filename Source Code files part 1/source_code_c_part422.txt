               // Wait for the app to complete (3 minutes max)
                //

                WaitForSingleObject(ProcessInformation.hProcess, 180000);


                DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Finished waiting for <%s>."),
                         szFullPath));


                //
                // Close our handles to the process and thread
                //

                CloseHandle(ProcessInformation.hProcess);
                CloseHandle(ProcessInformation.hThread);

            } else {
                DebugMsg((DM_WARNING, TEXT("ProcessPrograms:  Failed to execute <%s>, error = %d"),
                          szFullPath, GetLastError()));
            }
        }

LoopAgain:

        //
        // Close the registry key
        //

        RegCloseKey(hKeyEntry);


        //
        // Enumerate again
        //

        Index++;

        StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%s\\%s\\Execute\\%d"), USERDIFF, lpItem->szBuildNumber, Index);
        lResult = RegOpenKeyEx (HKEY_USERS, szSubKey, 0, KEY_READ, &hKeyEntry);

    } while (lResult == ERROR_SUCCESS);

Exit:

    if (bTokenCreated) {
        CloseHandle(hPrimaryToken);
    }

    DebugMsg((DM_VERBOSE, TEXT("ProcessPrograms:  Leaving.")));

    return TRUE;
}

//*************************************************************
//
//  OkToProcessItem()
//
//  Purpose:    Determines if the platform currently running
//              on should have the change in userdiff.ini applied.
//
//  Parameters: dwProductType - ProductType for a specific entry
//                              in userdiff.ini
//
//  Return:     TRUE if change should be applied
//              FALSE if not
//
//  Comments:   dwProductType can be one of these values:
//
//              0 = All platforms
//              1 = All server platforms
//              2 = Workstation
//              3 = Server
//              4 = Domain Controller
//
//  History:    Date        Author     Comment
//              4/08/96     ericflo    Created
//
//*************************************************************

BOOL OkToProcessItem(DWORD dwProductType)
{
    BOOL bRetVal = FALSE;


    switch (g_ProductType) {

        case PT_WORKSTATION:

            if ( (dwProductType == 0) ||
                 (dwProductType == 2) ) {

                bRetVal = TRUE;
            }

            break;

        case PT_SERVER:

            if ( (dwProductType == 0) ||
                 (dwProductType == 1) ||
                 (dwProductType == 3) ) {

                bRetVal = TRUE;
            }

            break;

        case PT_DC:
            if ( (dwProductType == 0) ||
                 (dwProductType == 1) ||
                 (dwProductType == 4) ) {

                bRetVal = TRUE;
            }

            break;

    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\profile\stubs.c ===
//*************************************************************
//
//  Contains the A/W api stubs
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "strsafe.h"

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI LoadUserProfileA (HANDLE hToken, LPPROFILEINFOA lpProfileInfoA)
{
     PROFILEINFOW ProfileInfoW;
     BOOL bResult;

    //
    //  Check Parameters
    //

    if (!lpProfileInfoA) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileA: NULL lpProfileInfo")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (lpProfileInfoA->dwSize != sizeof(PROFILEINFO)) {
        DebugMsg((DM_WARNING, TEXT("LoadUserProfileA: lpProfileInfo->dwSize != sizeof(PROFILEINFO)")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


     //
     // Thunk ProfileInfoA to ProfileInfoW
     //

     memset(&ProfileInfoW, 0, sizeof(PROFILEINFOW));
     ProfileInfoW.dwSize = sizeof(PROFILEINFOW);
     ProfileInfoW.dwFlags = lpProfileInfoA->dwFlags;
     ProfileInfoW.lpUserName = ProduceWFromA (lpProfileInfoA->lpUserName);
     ProfileInfoW.lpProfilePath = ProduceWFromA (lpProfileInfoA->lpProfilePath);
     ProfileInfoW.lpDefaultPath = ProduceWFromA (lpProfileInfoA->lpDefaultPath);
     ProfileInfoW.lpServerName = ProduceWFromA (lpProfileInfoA->lpServerName);
     if (ProfileInfoW.dwFlags & PI_APPLYPOLICY) {
         ProfileInfoW.lpPolicyPath = ProduceWFromA (lpProfileInfoA->lpPolicyPath);
     }


     //
     // Now call the real LoadUserProfile function.
     //

     bResult = LoadUserProfileW (hToken, &ProfileInfoW);


     //
     // Free memory allocated above and save the return
     // values.
     //

     FreeProducedString (ProfileInfoW.lpUserName);
     FreeProducedString (ProfileInfoW.lpProfilePath);
     FreeProducedString (ProfileInfoW.lpDefaultPath);
     FreeProducedString (ProfileInfoW.lpServerName);
     if (ProfileInfoW.dwFlags & PI_APPLYPOLICY) {
         FreeProducedString (ProfileInfoW.lpPolicyPath);
     }

     lpProfileInfoA->hProfile = ProfileInfoW.hProfile;

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI LoadUserProfileW (HANDLE hToken, LPPROFILEINFOW lpProfileInfoW)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateGroupA (LPCSTR lpGroupName, BOOL bCommonGroup)
{
     LPWSTR lpGroupNameW;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpGroupNameW = ProduceWFromA (lpGroupName))) {
        return FALSE;
     }

     bResult = CreateGroupW (lpGroupNameW, bCommonGroup);

     FreeProducedString (lpGroupNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateGroupW (LPCWSTR lpGroupName, BOOL bCommonGroup)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateGroupExA(LPCSTR lpGroupName, BOOL bCommonGroup,
                           LPCSTR lpResourceModuleName, UINT iResourceID)
{
     LPWSTR lpGroupNameW;
     LPWSTR lpResourceModuleNameW;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpGroupNameW = ProduceWFromA (lpGroupName))) {
        return FALSE;
     }
     if (!(lpResourceModuleNameW = ProduceWFromA (lpResourceModuleName))) {
        return FALSE;
     }

     bResult = CreateGroupExW (lpGroupNameW, bCommonGroup,
                               lpResourceModuleNameW, iResourceID);

     FreeProducedString (lpGroupNameW);
     FreeProducedString (lpResourceModuleNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateGroupExW(LPCWSTR lpGroupName, BOOL bCommonGroup,
                           LPCWSTR lpResourceModuleName, UINT iResourceID)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************


#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI DeleteGroupA (LPCSTR lpGroupName, BOOL bCommonGroup)
{
     LPWSTR lpGroupNameW;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpGroupNameW = ProduceWFromA (lpGroupName))) {
        return FALSE;
     }

     bResult = DeleteGroupW (lpGroupNameW, bCommonGroup);

     FreeProducedString (lpGroupNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI DeleteGroupW (LPCWSTR lpGroupName, BOOL bCommonGroup)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************


BOOL WINAPI AddItemA (LPCSTR lpGroupName,        BOOL bCommonGroup,
                      LPCSTR lpFileName,         LPCSTR lpCommandLine,
                      LPCSTR lpIconPath,         INT iIconIndex,
                      LPCSTR lpWorkingDirectory, WORD wHotKey,
                      INT    iShowCmd)
{

    return CreateLinkFileA (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}

BOOL WINAPI AddItemW (LPCWSTR lpGroupName,        BOOL bCommonGroup,
                      LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                      LPCWSTR lpIconPath,         int iIconIndex,
                      LPCWSTR lpWorkingDirectory, WORD wHotKey,
                      int     iShowCmd)
{

    return CreateLinkFileW (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}


//*************************************************************

BOOL WINAPI DeleteItemA (LPCSTR lpGroupName, BOOL bCommonGroup,
                         LPCSTR lpFileName, BOOL bDeleteGroup)
{

    return DeleteLinkFileA (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, bDeleteGroup);
}

BOOL WINAPI DeleteItemW (LPCWSTR lpGroupName, BOOL bCommonGroup,
                         LPCWSTR lpFileName, BOOL bDeleteGroup)
{
    return DeleteLinkFileW (bCommonGroup ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS,
                            lpGroupName, lpFileName, bDeleteGroup);
}


//*************************************************************

BOOL WINAPI AddDesktopItemA (BOOL bCommonItem,
                             LPCSTR lpFileName,         LPCSTR lpCommandLine,
                             LPCSTR lpIconPath,         INT iIconIndex,
                             LPCSTR lpWorkingDirectory, WORD wHotKey,
                             INT    iShowCmd)

{

    return CreateLinkFileA (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}

BOOL WINAPI AddDesktopItemW (BOOL bCommonItem,
                             LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                             LPCWSTR lpIconPath,         int iIconIndex,
                             LPCWSTR lpWorkingDirectory, WORD wHotKey,
                             int     iShowCmd)

{

    return CreateLinkFileW (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, lpCommandLine,
                            lpIconPath, iIconIndex, lpWorkingDirectory,
                            wHotKey, iShowCmd, NULL);
}

//*************************************************************

BOOL WINAPI DeleteDesktopItemA (BOOL bCommonItem, LPCSTR lpFileName)
{
    return DeleteLinkFileA (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, FALSE);
}


BOOL WINAPI DeleteDesktopItemW (BOOL bCommonItem, LPCWSTR lpFileName)
{
    return DeleteLinkFileW (bCommonItem ? CSIDL_COMMON_DESKTOPDIRECTORY : CSIDL_DESKTOPDIRECTORY,
                            NULL, lpFileName, FALSE);
}

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateLinkFileA (INT    csidl,              LPCSTR lpSubDirectory,
                             LPCSTR lpFileName,         LPCSTR lpCommandLine,
                             LPCSTR lpIconPath,         INT iIconIndex,
                             LPCSTR lpWorkingDirectory, WORD wHotKey,
                             INT    iShowCmd,           LPCSTR lpDescription)
{
     LPWSTR lpSubDirectoryW, lpFileNameW, lpCommandLineW;
     LPWSTR lpIconPathW, lpWorkingDirectoryW, lpDescriptionW;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     lpSubDirectoryW = ProduceWFromA(lpSubDirectory);

     if (!(lpFileNameW = ProduceWFromA(lpFileName))) {
        FreeProducedString(lpSubDirectoryW);
        return FALSE;
     }

     if (!(lpCommandLineW = ProduceWFromA(lpCommandLine))) {
        FreeProducedString(lpSubDirectoryW);
        FreeProducedString(lpFileNameW);
        return FALSE;
     }

     lpIconPathW = ProduceWFromA(lpIconPath);

     lpWorkingDirectoryW = ProduceWFromA(lpWorkingDirectory);

     lpDescriptionW = ProduceWFromA(lpDescription);

     bResult = CreateLinkFileW(csidl, lpSubDirectoryW, lpFileNameW,
                               lpCommandLineW, lpIconPathW, iIconIndex,
                               lpWorkingDirectoryW, wHotKey, iShowCmd,
                               lpDescriptionW);


     FreeProducedString(lpSubDirectoryW);
     FreeProducedString(lpFileNameW);
     FreeProducedString(lpCommandLineW);
     FreeProducedString(lpIconPathW);
     FreeProducedString(lpWorkingDirectoryW);
     FreeProducedString(lpDescriptionW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateLinkFileW (INT     csidl,              LPCWSTR lpSubDirectory,
                             LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                             LPCWSTR lpIconPath,         INT iIconIndex,
                             LPCWSTR lpWorkingDirectory, WORD wHotKey,
                             INT     iShowCmd,           LPCWSTR lpDescription)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateLinkFileExA (INT    csidl,              LPCSTR lpSubDirectory,
                               LPCSTR lpFileName,         LPCSTR lpCommandLine,
                               LPCSTR lpIconPath,         INT iIconIndex,
                               LPCSTR lpWorkingDirectory, WORD wHotKey,
                               INT    iShowCmd,           LPCSTR lpDescription,
                               LPCSTR lpResourceModuleName, UINT iResourceID)
{
     LPWSTR lpSubDirectoryW, lpFileNameW, lpCommandLineW;
     LPWSTR lpIconPathW, lpWorkingDirectoryW, lpDescriptionW;
     LPWSTR lpResourceModuleNameW;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     lpSubDirectoryW = ProduceWFromA(lpSubDirectory);

     if (!(lpFileNameW = ProduceWFromA(lpFileName))) {
        FreeProducedString(lpSubDirectoryW);
        return FALSE;
     }

     if (!(lpCommandLineW = ProduceWFromA(lpCommandLine))) {
        FreeProducedString(lpSubDirectoryW);
        FreeProducedString(lpFileNameW);
        return FALSE;
     }

     lpIconPathW = ProduceWFromA(lpIconPath);

     lpWorkingDirectoryW = ProduceWFromA(lpWorkingDirectory);

     lpDescriptionW = ProduceWFromA(lpDescription);

     lpResourceModuleNameW = ProduceWFromA(lpResourceModuleName);

     bResult = CreateLinkFileExW(csidl, lpSubDirectoryW, lpFileNameW,
                               lpCommandLineW, lpIconPathW, iIconIndex,
                               lpWorkingDirectoryW, wHotKey, iShowCmd,
                               lpDescriptionW, lpResourceModuleNameW, iResourceID);


     FreeProducedString(lpResourceModuleNameW);
     FreeProducedString(lpSubDirectoryW);
     FreeProducedString(lpFileNameW);
     FreeProducedString(lpCommandLineW);
     FreeProducedString(lpIconPathW);
     FreeProducedString(lpWorkingDirectoryW);
     FreeProducedString(lpDescriptionW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateLinkFileExW (INT     csidl,              LPCWSTR lpSubDirectory,
                               LPCWSTR lpFileName,         LPCWSTR lpCommandLine,
                               LPCWSTR lpIconPath,         INT iIconIndex,
                               LPCWSTR lpWorkingDirectory, WORD wHotKey,
                               INT     iShowCmd,           LPCWSTR lpDescription,
                               LPCSTR lpResourceModuleName, UINT iResourceID)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI DeleteLinkFileA (INT csidl, LPCSTR lpSubDirectory,
                             LPCSTR lpFileName, BOOL bDeleteSubDirectory)
{
     LPWSTR lpSubDirectoryW, lpFileNameW;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     lpSubDirectoryW = ProduceWFromA(lpSubDirectory);

     if (!(lpFileNameW = ProduceWFromA(lpFileName))) {
        FreeProducedString(lpSubDirectoryW);
        return FALSE;
     }

     bResult = DeleteLinkFileW(csidl, lpSubDirectoryW, lpFileNameW, bDeleteSubDirectory);


     FreeProducedString(lpSubDirectoryW);
     FreeProducedString(lpFileNameW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI DeleteLinkFileW (INT csidl, LPCWSTR lpSubDirectory,
                             LPCWSTR lpFileName, BOOL bDeleteSubDirectory)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateUserProfileA (PSID pSid, LPCSTR lpUserNameA, LPCSTR lpUserHiveA,
                                LPSTR lpProfileDirA, DWORD dwDirSize)
{
     LPWSTR lpUserNameW, lpUserHiveW, lpProfileDirW = NULL;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpUserNameW = ProduceWFromA(lpUserNameA))) {
        return FALSE;
     }

     if (lpProfileDirA) {
         lpProfileDirW = (LPWSTR) LocalAlloc (LPTR, dwDirSize * sizeof(WCHAR));

         if (!lpProfileDirW) {
            FreeProducedString(lpUserNameW);
            return FALSE;
         }
     }

     lpUserHiveW = ProduceWFromA(lpUserHiveA);

     bResult = CreateUserProfileW(pSid, lpUserNameW, lpUserHiveW,
                                  lpProfileDirW, dwDirSize);

     FreeProducedString(lpUserNameW);
     FreeProducedString(lpUserHiveW);

     if (lpProfileDirW) {

        if (bResult) {

            WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                dwDirSize, NULL, NULL);
        }

        LocalFree (lpProfileDirW);
     }

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateUserProfileW (PSID pSid, LPCWSTR lpUserNameW, LPCWSTR lpUserHiveW,
                                LPWSTR lpProfileDirW, DWORD dwDirSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CreateUserProfileExA (PSID pSid, LPCSTR lpUserNameA, LPCSTR lpUserHiveA,
                                  LPSTR lpProfileDirA, DWORD dwDirSize, BOOL bWin9xUpg)
{
     LPWSTR lpUserNameW, lpUserHiveW, lpProfileDirW = NULL;
     BOOL bResult;

     //
     // Convert the ANSI string to Unicode and call
     // the real function.
     //

     if (!(lpUserNameW = ProduceWFromA(lpUserNameA))) {
        return FALSE;
     }

     if (lpProfileDirA) {
         lpProfileDirW = (LPWSTR) LocalAlloc (LPTR, dwDirSize * sizeof(WCHAR));

         if (!lpProfileDirW) {
            FreeProducedString(lpUserNameW);
            return FALSE;
         }
     }

     lpUserHiveW = ProduceWFromA(lpUserHiveA);

     bResult = CreateUserProfileExW(pSid, lpUserNameW, lpUserHiveW,
                                  lpProfileDirW, dwDirSize, bWin9xUpg);

     FreeProducedString(lpUserNameW);
     FreeProducedString(lpUserHiveW);

     if (lpProfileDirW) {

        if (bResult) {

            WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                dwDirSize, NULL, NULL);
        }

        LocalFree (lpProfileDirW);
     }

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CreateUserProfileExW (PSID pSid, LPCWSTR lpUserNameW, LPCWSTR lpUserHiveW,
                                  LPSTR lpProfileDirW, DWORD dwDirSize, BOOL bWin9xUpg)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

//
// Stubs for CopyProfileDirectoryA/W
//

BOOL WINAPI CopyProfileDirectoryA (LPCSTR lpSrcDir, LPCSTR lpDstDir, DWORD dwFlags)
{
     return CopyProfileDirectoryExA (lpSrcDir, lpDstDir, dwFlags, NULL, NULL);
}

BOOL WINAPI CopyProfileDirectoryW (LPCWSTR lpSrcDir, LPCWSTR lpDstDir, DWORD dwFlags)
{
    return CopyProfileDirectoryExW (lpSrcDir, lpDstDir, dwFlags, NULL, NULL);
}


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI CopyProfileDirectoryExA (LPCSTR lpSrcDirA, LPCSTR lpDstDirA,
                                     DWORD dwFlags, LPFILETIME ftDelRefTime,
                                     LPCSTR lpExclusionListA)
{
     LPWSTR lpSrcDirW, lpDstDirW, lpExclusionListW = NULL;
     BOOL bResult;

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     if (!(lpSrcDirW = ProduceWFromA(lpSrcDirA))) {
        return FALSE;
     }

     if (!(lpDstDirW = ProduceWFromA(lpDstDirA))) {
        FreeProducedString(lpSrcDirW);
        return FALSE;
     }

     if (dwFlags & CPD_USEEXCLUSIONLIST) {
         lpExclusionListW = ProduceWFromA(lpExclusionListA);
     }

     bResult = CopyProfileDirectoryExW(lpSrcDirW, lpDstDirW, dwFlags, ftDelRefTime,
                                       lpExclusionListW);


     FreeProducedString(lpSrcDirW);
     FreeProducedString(lpDstDirW);
     FreeProducedString(lpExclusionListW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI CopyProfileDirectoryExW (LPCWSTR lpSrcDirW, LPCWSTR lpDstDirW,
                                     DWORD dwFlags, LPFILETIME ftDelRefTime,
                                     LPCWSTR lpExclusionListW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetProfilesDirectoryA (LPSTR lpProfilesDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfilesDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

    if (!lpProfilesDirA) {
        DebugMsg((DM_WARNING, TEXT("GetProfilesDirectoryA : lpProfilesDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!lpcchSize) {
        DebugMsg((DM_WARNING, TEXT("GetProfilesDirectoryA : lpcchSize is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfilesDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetProfilesDirectoryW(lpProfilesDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfilesDirW, -1, lpProfilesDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfilesDirW, -1, lpProfilesDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfilesDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetProfilesDirectoryW (LPWSTR lpProfilesDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetDefaultUserProfileDirectoryA (LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;


    if (!lpProfileDirA) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectoryA : lpProfileDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!lpcchSize) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectoryA : lpcchSize is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetDefaultUserProfileDirectoryW(lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetDefaultUserProfileDirectoryW (LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetAllUsersProfileDirectoryA (LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

     if (!lpProfileDirA) {
         DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryA : lpProfileDirA is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetAllUsersProfileDirectoryW(lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetAllUsersProfileDirectoryW (LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE



//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetUserProfileDirectoryA (HANDLE hToken, LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

    if (!lpProfileDirA) {
        DebugMsg((DM_WARNING, TEXT("GetUserProfileDirectoryA : lpProfileDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetUserProfileDirectoryA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetUserProfileDirectoryW(hToken, lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetUserProfileDirectoryW (HANDLE hToken, LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetUserProfileDirFromSidA (PSID pSid, LPSTR lpProfileDirA, LPDWORD lpcchSize)
{
     LPWSTR lpProfileDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

    if (!lpProfileDirA) {
        DebugMsg((DM_WARNING, TEXT("GetUserProfileDirFromSidA : lpProfileDirA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetUserProfileDirFromSidA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpProfileDirW = GlobalAlloc(GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetUserProfileDirFromSidW(pSid, lpProfileDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             bResult = WideCharToMultiByte(CP_ACP, 0, lpProfileDirW, -1, lpProfileDirA,
                                           *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree(lpProfileDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetUserProfileDirFromSidW (PSID pSid, LPWSTR lpProfileDirW, LPDWORD lpcchSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE

//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI ExpandEnvironmentStringsForUserA (HANDLE hToken, LPCSTR lpSrcA, LPSTR lpDestA, DWORD dwSize)
{
     LPWSTR lpSrcW, lpDestW;
     BOOL bResult;

    if (!lpDestA) {
        DebugMsg((DM_WARNING, TEXT("ExpandEnvironmentStringsForUserA : lpDestA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

     //
     // Convert the ANSI strings to Unicode and call
     // the real function.
     //

     if (!(lpSrcW = ProduceWFromA(lpSrcA))) {
         DebugMsg((DM_WARNING, TEXT("ExpandEnvircallonmentStringsForUserA : lpSrcA is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpDestW = GlobalAlloc(GPTR, dwSize * sizeof(TCHAR)))) {
         FreeProducedString(lpSrcW);
         return FALSE;
     }

     bResult = ExpandEnvironmentStringsForUserW(hToken, lpSrcW, lpDestW, dwSize);


     if (bResult) {
         bResult = WideCharToMultiByte(CP_ACP, 0, lpDestW, -1, lpDestA,
                             dwSize, NULL, NULL);
     }


     GlobalFree(lpDestW);
     FreeProducedString(lpSrcW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI ExpandEnvironmentStringsForUserW (HANDLE hToken, LPCWSTR lpSrcW, LPWSTR lpDestW, DWORD dwSize)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI GetSystemTempDirectoryA (LPSTR lpDirA, LPDWORD lpcchSize)
{
     LPWSTR lpDirW;
     BOOL bResult;
     DWORD cchOrgSize, cchReq;

     if (!lpcchSize) {
         DebugMsg((DM_WARNING, TEXT("GetSystemTempDirectoryA : lpcchSize is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }

     //
     // Allocate a buffer to match the ANSI buffer
     //

     if (!(lpDirW = GlobalAlloc (GPTR, (*lpcchSize) * sizeof(TCHAR)))) {
        return FALSE;
     }

     cchOrgSize = *lpcchSize;  // Store the original size passed to the function
     bResult = GetSystemTempDirectoryW (lpDirW, lpcchSize);


     if (bResult) {
         cchReq = WideCharToMultiByte(CP_ACP, 0, lpDirW, -1, lpDirA,
                                      0, NULL, NULL);
         *lpcchSize = cchReq;
         if (cchReq > cchOrgSize) {
             bResult = FALSE;
         }
         else {
             WideCharToMultiByte (CP_ACP, 0, lpDirW, -1, lpDirA,
                                  *lpcchSize, NULL, NULL);
         }
     }


     GlobalFree (lpDirW);

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetSystemTempDirectoryW (LPWSTR lpDirW, LPDWORD lpcchSize)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI ConvertGPOListWToA( PGROUP_POLICY_OBJECTW  pGPOListW,
                                PGROUP_POLICY_OBJECTA *pGPOListA )
{
    LPSTR lpDSPathA, lpFileSysPathA, lpDisplayNameA, lpExtensionsA, lpLinkA;
    DWORD dwSize;
    PGROUP_POLICY_OBJECTA pGPOTempA = NULL, pNew, pTemp;
    PGROUP_POLICY_OBJECTW pGPO = pGPOListW;

    while (pGPO) {

        //
        // Build an ANSI structure for this entry
        //

        lpDSPathA = ProduceAFromW(pGPO->lpDSPath);
        lpFileSysPathA = ProduceAFromW(pGPO->lpFileSysPath);
        lpDisplayNameA = ProduceAFromW(pGPO->lpDisplayName);
        lpExtensionsA = ProduceAFromW( pGPO->lpExtensions );
        lpLinkA = ProduceAFromW( pGPO->lpLink );

        //
        // Calculate the size of the new GPO item
        //

        dwSize = sizeof (GROUP_POLICY_OBJECTA);

        if (lpDSPathA) {
            dwSize += (lstrlenA(lpDSPathA) + 1);
        }

        if (lpFileSysPathA) {
            dwSize += (lstrlenA(lpFileSysPathA) + 1);
        }

        if (lpDisplayNameA) {
            dwSize += (lstrlenA(lpDisplayNameA) + 1);
        }

        if (lpExtensionsA) {
            dwSize += (lstrlenA(lpExtensionsA) + 1);
        }

        if (lpLinkA) {
            dwSize += (lstrlenA(lpLinkA) + 1);
        }

        //
        // Allocate space for it
        //

        pNew = (PGROUP_POLICY_OBJECTA) LocalAlloc (LPTR, dwSize);

        if (!pNew) {
            DebugMsg((DM_WARNING, TEXT("ConvertGPOListWToA: Failed to allocate memory with %d"),
                     GetLastError()));
            FreeProducedString(lpDSPathA);
            FreeProducedString(lpFileSysPathA);
            FreeProducedString(lpDisplayNameA);
            FreeProducedString(lpExtensionsA);
            FreeProducedString(lpLinkA);
            FreeGPOListW (pGPOListW);
            return FALSE;
        }


        //
        // Fill in item
        //

        pNew->dwOptions = pGPO->dwOptions;
        pNew->dwVersion = pGPO->dwVersion;

        if (lpDSPathA) {
            pNew->lpDSPath = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
            (void) StringCchCopyA(pNew->lpDSPath, lstrlenA(lpDSPathA)+1, lpDSPathA);
        }

        if (lpFileSysPathA) {
            if (lpDSPathA) {
                pNew->lpFileSysPath = pNew->lpDSPath + lstrlenA (pNew->lpDSPath) + 1;
            } else {
                pNew->lpFileSysPath = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
            }

            (void) StringCchCopyA(pNew->lpFileSysPath, lstrlenA(lpFileSysPathA)+1, lpFileSysPathA);
        }


        if (lpDisplayNameA) {
            if (lpFileSysPathA) {
                pNew->lpDisplayName = pNew->lpFileSysPath + lstrlenA (pNew->lpFileSysPath) + 1;
            } else {

                if (lpDSPathA)
                {
                    pNew->lpDisplayName = pNew->lpDSPath + lstrlenA (pNew->lpDSPath) + 1;
                }
                else
                {
                    pNew->lpDisplayName = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
                }
            }

            (void) StringCchCopyA(pNew->lpDisplayName, lstrlenA(lpDisplayNameA)+1, lpDisplayNameA);
        }

        if (lpExtensionsA) {
            if (lpDisplayNameA) {
                pNew->lpExtensions = pNew->lpDisplayName + lstrlenA(pNew->lpDisplayName) + 1;
            } else {

                if (lpFileSysPathA) {
                    pNew->lpExtensions = pNew->lpFileSysPath + lstrlenA(pNew->lpFileSysPath) + 1;
                } else {

                    if (lpDSPathA) {
                        pNew->lpExtensions = pNew->lpDSPath + lstrlenA(pNew->lpDSPath) + 1;
                    } else {
                        pNew->lpExtensions = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
                    }

                }
            }

            (void)StringCchCopyA( pNew->lpExtensions, lstrlenA(lpExtensionsA)+1, lpExtensionsA );
        }

        if (lpLinkA) {

            if (lpExtensionsA) {
                pNew->lpLink = pNew->lpExtensions + lstrlenA(pNew->lpExtensions) + 1;
            } else {

                if (lpDisplayNameA) {
                    pNew->lpLink = pNew->lpDisplayName + lstrlenA(pNew->lpDisplayName) + 1;
                } else {

                    if (lpFileSysPathA) {
                        pNew->lpLink = pNew->lpFileSysPath + lstrlenA(pNew->lpFileSysPath) + 1;
                    } else {

                        if (lpDSPathA) {
                            pNew->lpLink = pNew->lpDSPath + lstrlenA(pNew->lpDSPath) + 1;
                        } else {
                            pNew->lpLink = (LPSTR)(((LPBYTE)pNew) + sizeof(GROUP_POLICY_OBJECTA));
                        }
                    }
                }
            }

            (void) StringCchCopyA( pNew->lpLink, lstrlenA(lpLinkA)+1, lpLinkA );
        }


        WideCharToMultiByte(CP_ACP, 0, pGPO->szGPOName, -1, pNew->szGPOName, 50, NULL, NULL);

        pNew->GPOLink = pGPO->GPOLink;
        pNew->lParam = pGPO->lParam;


        //
        // Add it to the ANSI link list
        //

        if (pGPOTempA) {

            pTemp = pGPOTempA;

            while (pTemp->pNext != NULL) {
                pTemp = pTemp->pNext;
            }

            pTemp->pNext = pNew;
            pNew->pPrev = pTemp;

        } else {

            pGPOTempA = pNew;
        }

        FreeProducedString(lpDSPathA);
        FreeProducedString(lpFileSysPathA);
        FreeProducedString(lpDisplayNameA);
        FreeProducedString(lpExtensionsA);
        FreeProducedString(lpLinkA);

        pGPO = pGPO->pNext;
    }

    *pGPOListA = pGPOTempA;

    FreeGPOListW (pGPOListW);

    return TRUE;
}

BOOL WINAPI GetGPOListA (HANDLE hToken, LPCSTR lpNameA, LPCSTR lpHostNameA,
                         LPCSTR lpComputerNameA, DWORD dwFlags,
                         PGROUP_POLICY_OBJECTA *pGPOListA)
{
     LPWSTR lpNameW, lpHostNameW, lpComputerNameW;
     PGROUP_POLICY_OBJECTW pGPOListW;
     BOOL bResult;


     if (!pGPOListA) {
         DebugMsg((DM_WARNING, TEXT("GetGPOListA: pGPOList is null")));
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }


     lpNameW = ProduceWFromA(lpNameA);
     lpHostNameW = ProduceWFromA(lpHostNameA);
     lpComputerNameW = ProduceWFromA(lpComputerNameA);

     bResult = GetGPOListW (hToken, lpNameW, lpHostNameW, lpComputerNameW,
                            dwFlags, &pGPOListW);


     FreeProducedString(lpNameW);
     FreeProducedString(lpHostNameW);
     FreeProducedString(lpComputerNameW);

     if (bResult) {
         bResult = ConvertGPOListWToA( pGPOListW, pGPOListA );
     }

     return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetGPOListW (HANDLE hToken, LPCWSTR lpNameW, LPCWSTR lpHostNameW,
                         LPCWSTR lpComputerNameW, DWORD dwFlags,
                         PGROUP_POLICY_OBJECTW *pGPOListW)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI FreeGPOListA (PGROUP_POLICY_OBJECTA pGPOListA)
{
    PGROUP_POLICY_OBJECTA pGPOTemp;

    while (pGPOListA) {
        pGPOTemp = pGPOListA->pNext;
        LocalFree (pGPOListA);
        pGPOListA = pGPOTemp;
    }

    return TRUE;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI FreeGPOListW (PGROUP_POLICY_OBJECTW pGPOListW)
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI ApplySystemPolicyA (DWORD dwFlags, HANDLE hToken, HKEY hKeyCurrentUser,
                                LPCSTR lpUserNameA, LPCSTR lpPolicyPathA,
                                LPCSTR lpServerNameA)
{
    LPWSTR lpUserNameW, lpPolicyPathW, lpServerNameW;
    BOOL bResult;


    //
    // Convert the ANSI strings to Unicode and call
    // the real function.
    //

    if (!(lpUserNameW = ProduceWFromA(lpUserNameA))) {
       return FALSE;
    }

    lpPolicyPathW = ProduceWFromA(lpPolicyPathA);
    lpServerNameW = ProduceWFromA(lpServerNameA);


    bResult = ApplySystemPolicyW(dwFlags, hToken, hKeyCurrentUser, lpUserNameW,
                                 lpPolicyPathW, lpServerNameW);


    FreeProducedString(lpServerNameW);
    FreeProducedString(lpPolicyPathW);
    FreeProducedString(lpUserNameW);

    return bResult;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI ApplySystemPolicyW (DWORD dwFlags, HANDLE hToken, HKEY hKeyCurrentUser,
                                LPCWSTR lpUserNameW, LPCWSTR lpPolicyPathW,
                                LPCWSTR lpServerNameW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // UNICODE



//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

DWORD WINAPI GetAppliedGPOListA ( DWORD dwFlags,
                                  LPCSTR pMachineNameA,
                                  PSID pSidUser,
                                  GUID *pGuidExtension,
                                  PGROUP_POLICY_OBJECTA *pGPOListA)
{
    PGROUP_POLICY_OBJECTW pGPOListW;
    DWORD dwRet;
    LPWSTR pMachineNameW;

    if (!pGPOListA || !pGuidExtension) {
        DebugMsg((DM_WARNING, TEXT("GetAppliedGPOListA: pGPOList or pGuidExtension is null")));
        return ERROR_INVALID_PARAMETER;
    }

    pMachineNameW = ProduceWFromA(pMachineNameA);

    dwRet = GetAppliedGPOListW ( dwFlags, pMachineNameW, pSidUser, pGuidExtension, &pGPOListW);

    FreeProducedString(pMachineNameW);

    if ( dwRet == ERROR_SUCCESS ) {
        BOOL bResult = ConvertGPOListWToA( pGPOListW, pGPOListA );
        dwRet = bResult ? ERROR_SUCCESS : E_FAIL;
    }

    return dwRet;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

DWORD WINAPI GetAppliedGPOListW ( DWORD dwFlags,
                                  GUID *pGuidExtension,
                                  PGROUP_POLICY_OBJECTW *pGPOListW)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

#endif // UNICODE


//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

BOOL WINAPI DeleteProfileA ( LPCSTR lpSidStringA,
                                 LPCSTR lpProfilePathA,
                                 LPCSTR lpComputerNameA)
{
    LPWSTR pSidStringW;
    LPWSTR pProfilePathW;
    LPWSTR pComputerNameW;
    BOOL dwRet;

    if (!lpSidStringA) {
        DebugMsg((DM_WARNING, TEXT("DeleteProfileA: lpSidString is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!(pSidStringW = ProduceWFromA(lpSidStringA))) {
        return FALSE;
    }

    if (lpProfilePathA) {
        if (!(pProfilePathW = ProduceWFromA(lpProfilePathA))) {
            FreeProducedString(pSidStringW);
            return FALSE;
        }
    }
    else {
        pProfilePathW = NULL;
    }

    if (lpComputerNameA) {
        if (!(pComputerNameW = ProduceWFromA(lpComputerNameA))) {
            FreeProducedString(pSidStringW);
            FreeProducedString(pProfilePathW);
            return FALSE;
        }
    }
    else {
        pComputerNameW = NULL;
    }


    dwRet = DeleteProfileW ( pSidStringW, pProfilePathW, pComputerNameW);

    FreeProducedString(pSidStringW);

    if (pProfilePathW)
        FreeProducedString(pProfilePathW);

    if (pComputerNameW)
        FreeProducedString(pComputerNameW);

    return dwRet;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI DeleteProfileW ( LPWSTR lpSidStringW,
                                 LPWSTR lpProfilePathW,
                                 HKEY   hKeyLM)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

#endif // UNICODE
//*************************************************************

#ifdef UNICODE

//
// ANSI entry point when this module is compiled Unicode.
//

DWORD WINAPI GetUserAppDataPathA (HANDLE hToken, BOOL fLocalAppData, LPSTR lpFolderPathA)
{
    LPWSTR lpFolderPathW;
    BOOL bResult;
    DWORD dwError = ERROR_SUCCESS, cchReq;


    if (!lpFolderPathA) {
        DebugMsg((DM_WARNING, TEXT("GetUserAppDataPathA : lpFolderPathA is null")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }
    else {
        *lpFolderPathA = TEXT('\0');
    }

    //
    // Allocate a buffer to match the ANSI buffer
    //

    if (!(lpFolderPathW = GlobalAlloc(GPTR, (MAX_PATH) * sizeof(TCHAR)))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return ERROR_OUTOFMEMORY;
    }

    dwError = GetUserAppDataPathW(hToken, fLocalAppData, lpFolderPathW);


    if (dwError == ERROR_SUCCESS) {
        cchReq = WideCharToMultiByte(CP_ACP, 0, lpFolderPathW, -1, lpFolderPathA,
                                     0, NULL, NULL);
        if (cchReq > MAX_PATH) {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
            bResult = WideCharToMultiByte(CP_ACP, 0, lpFolderPathW, -1, lpFolderPathA,
                                          MAX_PATH, NULL, NULL);
        }
    }


    GlobalFree(lpFolderPathW);

    SetLastError(dwError);
    return dwError;
}

#else

//
// Unicode entry point when this module is compiled ANSI.
//

BOOL WINAPI GetUserAppDataPathW (HANDLE hToken, BOOL fLocalAppData, LPWSTR lpFolderPathW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return ERROR_CALL_NOT_IMPLEMENTED;
}

#endif // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\chkacc.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:           ChkAcc.h
//
// Description:    RSOP Security functions
//
// History:    31-Jul-99   leonardm    Created
//
//******************************************************************************

#ifndef CHKACC_H__85EE6A51_C327_4453_ACBE_FEC6F0010740__INCLUDED_
#define CHKACC_H__85EE6A51_C327_4453_ACBE_FEC6F0010740__INCLUDED_


#include <windows.h>
#include <accctrl.h>
#include <aclapi.h>
#include <sddl.h>
#include <lm.h>
#include <oaidl.h>
#include <authz.h>

//******************************************************************************
//
// Structure:   CRsopToken
//
// Description: This reprents a pseudo-token containing an arbitrary
//              combination of SIDs which
//              can be used to check access to objects protected with security descriptors.
//
// History:     7/30/99 leonardm Created.
//
//******************************************************************************

#if defined(__cplusplus)
extern "C"{
#endif

typedef void* PRSOPTOKEN;

//******************************************************************************
//
// Function:    RsopCreateToken
//
// Description: Creates a pseudo-token using an exisitng user or machine account plus
//              the accounts of which that user is currently a member of.
//              The returned pseudo-token can be used subsequently in call
//              to other RSOP security functions to check access to
//              objects protected by security descriptors.
//
// Parameters:  - accountName: Pointer to a user or machine account name.
//              - psaSecurity: Pointer ta SAFEARRAY of BSTRs representing
//                             security groups.
//                             If NULL, then all the current security groups for the
//                             szaccountName are added to the RsopToken.
//                             If not NULL but pointing to an empty array,
//                             only the szaccountName is added to the RsopToken.
//              - ppRsopToken:  Address of a PRSOPTOKEN that receives the newly
//                              created pseudo-token
//
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99          leonardm        Created.
//
//******************************************************************************
HRESULT RsopCreateToken( WCHAR* szAccountName,
                         SAFEARRAY *psaUserSecurityGroups,
                         PRSOPTOKEN* ppRsopToken );

//******************************************************************************
//
// Function:    RsopDeleteToken
//
// Description: Destroys a pseudo-token previously created by any of the overloaded
//                      forms of RSOPCreateRsopToken
//
// Parameters:  - pRsopToken: Pointer to a valid PRSOPTOKEN
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     7/30/99         leonardm        Created.
//
//******************************************************************************
HRESULT RsopDeleteToken(PRSOPTOKEN pRsopToken);


#if defined(__cplusplus)
}
#endif

#endif // #ifndef CHKACC_H__85EE6A51_C327_4453_ACBE_FEC6F0010740__INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\chkacc.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        ChkAcc.cpp
//
// Description: RSOP Security functions
//
// History:     31-Jul-99   leonardm    Created
//
//******************************************************************************

#include "uenv.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <Windows.h>
#include <DsGetDC.h>
#include <authzi.h>
#include "ChkAcc.h"
#include "smartptr.h"
#include "RsopUtil.h"
#include "RsopDbg.h"


CDebug dbgAccessCheck( L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                       L"ChkAccDebugLevel",
                       L"ChkAcc.log",
                       L"ChkAcc.bak",
                       TRUE );

#undef dbg
#define dbg dbgAccessCheck


//******************************************************************************
//
// Class:       CSid
//
// Description: Objects of this class encapsulate and simplify manipulation of
//              SIDs for the purposes of access control checks.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
class CSid
{
private:
    bool m_bState;                          // Flag to indicate whether the object is currently
                                            // associated with a valid SID.

    PSID m_pSid;                            // Pointer to the SID encapsulated by thi class.

    CWString m_sUser;                 // User name
    CWString m_sDomain;               // Domain where the user account resides.
    CWString m_sComputer;             // Computer in the domain where the user account exists

    CWString m_sSidString;            // String representation of the encapsulated SID.

    SID_NAME_USE m_eUse;                    // SID type.

public:

    //
    // Overloaded constructors
    //

    CSid() : m_bState(false), m_pSid(NULL), m_eUse(SidTypeUnknown){}

    CSid(const PSID pSid, const WCHAR* szComputer = NULL ) :
    m_bState(false),
    m_pSid(NULL),
    m_eUse(SidTypeUnknown)
    {
        Initialize(pSid, szComputer);
    }

    CSid(const WCHAR* szUser, const WCHAR* szComputer = NULL ) :
    m_bState(false),
    m_pSid(NULL),
    m_eUse(SidTypeUnknown)
    {
        Initialize(szUser, szComputer);
    }

    CSid(const CSid& otherSid) :
    m_bState(false),
    m_pSid(NULL),
    m_eUse(SidTypeUnknown)
    {
        Initialize(otherSid.User(), otherSid.Computer());
    }

    ~CSid()
    {
        Reset();
    }


    //
    // Attempts to initialize an object of this class by associating it with
    // an existing user represented in the SID pointed to by pSid.
    //

    bool Initialize(PSID pSid, const WCHAR* szComputer = NULL);


    //
    // Attempts to initialize an object of this class by associating it with
    // an existing user represented by szUser.
    //

    bool Initialize(const WCHAR* szUser, const WCHAR* szComputer = NULL);


    //
    // Indicates whether this object is currently associated with a valid user.
    //

    bool IsValid() const{ return m_bState; }


    //
    // Overload of assignment operator. Copies one CSid to another.
    // After a this call two objects encapsulate the same SID.
    // However, each owns its own memory. So the destructor of
    // one object can be called without invalidating resources used by the other.
    //

    CSid& operator = (CSid otherSid);


    //
    // Overload of assignment operator. Initializes
    //  the current object with an existing SID.
    //

    CSid& operator = (PSID pSid);


    //
    // Returns a pointer to the SID encapsulated by this object.
    //

    PSID GetSidPtr() const{ return m_pSid; }


    //
    // Returns the name of the user associated with this object.
    //

    const WCHAR* User() const{ return m_sUser; }


    //
    // Returns the name of the computer used to Initialize this object with a user.
    //

    const WCHAR* Computer() const{ return m_sComputer; }


    //
    // Returns the name of the domain of which the user is a member.
    //

    const WCHAR* Domain() const{ return m_sDomain; }


    //
    // Returns a the SID associated with object in
    // a string format suitable for display
    //

    const WCHAR* SidString() const{ return m_sSidString; }


    //
    // Returns the type as it was found in the SID associated
    // with this object during processing of Initialize.
    //

    SID_NAME_USE SidType() const{ return m_eUse; }


    //
    // Breaks the association of this object with an exisitng SID. Releases
    // memory allocate during Initialize and set the internal state to Invalid.
    // This call is safe even if the object is not initialized.
    //

    void Reset();
};

//******************************************************************************
//
// Function:    CSid::Initialize
//
// Description: Attempts to initialize an object of this class by associating it with
//              an existing user represented in the SID pointed to by pSid.
//
// Parameters:  - pSid:         Pointer to an exisitng SID. The memory pointed to
//                              by this parameter may be released after a call to
//                              this function since objects of this class allocate
//                              and release their own memory for the associated SID.
//              - szComputer:   Pointer to a string naming the computer where the
//                              lookup of the account is to take place. If NULL, the
//                              curent computer is used.
//
// Return:      true on success. false otherwise.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
bool CSid::Initialize(const PSID pSid, const WCHAR* szComputer/* = NULL */)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CSid::Initialize - Entering...");

    Reset();

    if(!IsValidSid(pSid))
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - IsValidSid returned false!");
        return m_bState;
    }

    m_pSid = new BYTE[GetLengthSid(pSid)];

    if(!m_pSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to new failed!");
        return m_bState;
    }

    BOOL bRes = CopySid(GetLengthSid(pSid), m_pSid, pSid);
    if(!bRes)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - Call to CopySid returned FALSE!");
        Reset();
        return m_bState;
    }


    DWORD cbUser = 0;
    DWORD cbDomain = 0;

    LookupAccountSid(szComputer, m_pSid, NULL, &cbUser, NULL, &cbDomain, &m_eUse);
    if(cbUser && cbDomain)
    {
        XPtrST<WCHAR>xpszUser = new WCHAR[cbUser];

        if(!xpszUser)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to new failed!");
            Reset();
            return m_bState;
        }

        XPtrST<WCHAR>xpszDomain = new WCHAR[cbDomain];

        if(!xpszDomain)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to new failed!");
            Reset();
            return m_bState;
        }

        bRes = LookupAccountSid(szComputer, m_pSid, xpszUser, &cbUser, xpszDomain, &cbDomain, &m_eUse);

        if(!bRes)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to LookupAccountSid returned FALSE!");
            Reset();
            return m_bState;
        }

        m_sUser = xpszUser;
        if(!m_sUser.ValidString())
        {
            Reset();
            return m_bState;
        }

        m_sDomain = xpszDomain;
        if(!m_sDomain.ValidString())
        {
            Reset();
            return m_bState;
        }

        XPtrLF<WCHAR>szSidString = NULL;
        bRes = ConvertSidToStringSid(m_pSid, &szSidString);
        if(!bRes)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"CSid::Initialize - call to ConvertSidToStringSid returned false!");
            Reset();
            return m_bState;
        }

        m_sSidString = szSidString;
        if(!m_sSidString.ValidString())
        {
            Reset();
            return m_bState;
        }

        m_bState = true;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CSid::Initialize - Leaving successfully.");
    return m_bState;
}


//******************************************************************************
//
// Function:    CSid::Initialize
//
// Description: Attempts to initialize an object of this class by associating it with
//              an existing user represented by szUser.
//
// Parameters:  - szUser:       Name of an existing user.
//              - szComputer:   Pointer to a string naming the computer where the
//                              lookup of the account is to take place. If NULL, the
//                              curent computer is used.
//
// Return:      true on success. false otherwise.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
bool CSid::Initialize(const WCHAR* szUser, const WCHAR* szComputer/* = NULL */)
{
    Reset();

    if(!szUser)
    {
        return m_bState;
    }

    m_sUser = szUser;
    if(!m_sUser.ValidString())
    {
        Reset();
        return m_bState;
    }

    m_sComputer = szComputer ? szComputer : L"";
    if(!m_sComputer.ValidString())
    {
        Reset();
        return m_bState;
    }

    DWORD cSid = 0;

    DWORD cDomain = 0;

    LookupAccountName(szComputer, szUser, NULL, &cSid, NULL, &cDomain, &m_eUse);

    if(cSid && cDomain)
    {
        m_pSid = new BYTE[cSid];
        if(!m_pSid)
        {
            Reset();
            return m_bState;
        }

        XPtrST<WCHAR>xpszDomain = new WCHAR[cDomain];

        if(!xpszDomain)
        {
            Reset();
            return m_bState;
        }

        BOOL bRes = LookupAccountName(szComputer, szUser, m_pSid, &cSid, xpszDomain, &cDomain, &m_eUse);

        if(!bRes)
        {
            Reset();
            return m_bState;
        }

        m_sDomain = xpszDomain;
        if(!m_sDomain.ValidString())
        {
            Reset();
            return m_bState;
        }

        XPtrLF<WCHAR>szSidString = NULL;
        bRes = ConvertSidToStringSid(m_pSid, &szSidString);
        if(!bRes)
        {
            Reset();
            return m_bState;
        }

        m_sSidString = szSidString;
        if(!m_sSidString.ValidString())
        {
            Reset();
            return m_bState;
        }

        m_bState = true;
    }

    return m_bState;
}

//******************************************************************************
//
// Function:    Reset
//
// Description: Breaks the association of this object with an exisitng SID. Releases
//              memory allocate during Initialize and set the internal state to Invalid.
//              This call is safe even if the object is not initialized.
//
// Parameters:  None.
//
// Return:
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
void CSid::Reset()
{
    delete[] (BYTE*)m_pSid;

    m_pSid = NULL;

    m_sUser = m_sDomain = m_sComputer = m_sSidString = L"";

    m_eUse = SidTypeUnknown;

    m_bState = false;
}

//******************************************************************************
//
// Function:    operator =
//
// Description: Overload of assignment operator. Copies one CSid to another.
//              After a this call two objects encapsulate the same SID.
//              However, each owns its own memory. So the destructor of
//              one object can be called without invalidating resources used by the other.
//
// Parameters:  - otherSid: The CSid whose value is to be copied.
//
// Return:      A reference to the object on which the call is invoked.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
CSid& CSid::operator = (CSid otherSid)
{
    if(this == &otherSid)
    {
        return *this;
    }

    Reset();

    if(!IsValidSid(otherSid.GetSidPtr()))
    {
        return *this;
    }

    Initialize(otherSid.User(), otherSid.Computer());

    return *this;
}

//******************************************************************************
//
// Function:    operator =
//
// Description: Overload of assignment operator. Initializes the current object with
//              an existing SID.
//
// Parameters:  - otherSid: The CSid whose value is to be copied.
//
// Return:      A reference to the object on which the call is invoked.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
CSid& CSid::operator = (PSID pSid)
{
    Reset();

    if(!IsValidSid(pSid))
    {
        return *this;
    }

    Initialize(pSid);

    return *this;
}

//******************************************************************************
//
// Structure:   CTLink
//
// Description:
//
// History:     8/02/99         leonardm        Created.
//
//******************************************************************************
template<typename T> struct CTLink
{
    T* m_pData;
    CTLink* m_pNext;
    CTLink* m_pPrev;
    CTLink(T* pData) : m_pData(pData), m_pNext(NULL), m_pPrev(NULL){}
    ~CTLink()
    {
        delete m_pData;
    }
};

//******************************************************************************
//
// Structure:   CRsopToken
//
// Description: This reprents a pseudo-token containing an arbitrary
//              combination of SIDs which
//              can be used to check access to objects protected with security descriptors.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
struct CRsopToken
{
    CTLink<CSid>* m_pSidsHead;
    CTLink<CSid>* m_pSidsTail;


    //
    // Default constructor. Constructs an object with no sids. Access checks
    // against an CRsopToken with no SIDs will always fail; even on objects
    // with no DACL.
    //

    CRsopToken() : m_pSidsHead(NULL), m_pSidsTail(NULL) {}


    //
    // Destructor. Releases the memory pointed
    //  to by each of the elements of m_pSidsHead.
    //

    ~CRsopToken();


    //
    // Adds a CSid to this object. The client of this class allocates the memory
    // for the CSid and this class releases the memory in the destructor.
    //

    HRESULT AddSid(CSid* pSid);
};

//******************************************************************************
//
// Function:    CRsopToken::~CRsopToken
//
// Description: Destructor. Releases the memory pointed to by each of the elements of
//              m_pSidsHead.
//
// Parameters:  None.
//
// Return:      N/A
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
CRsopToken::~CRsopToken()
{
    CTLink<CSid>* pLinkIterator = m_pSidsHead;
    while(pLinkIterator)
    {
        CTLink<CSid>* pLinkToDelete = pLinkIterator;
        pLinkIterator = pLinkIterator->m_pNext;
        delete pLinkToDelete;
    }
}


//******************************************************************************
//
// Function:    CRsopToken::AddSid
//
// Description: Adds a CSid to this object. The client of this class allocates the
//              memory for the CSid and this class releases the memory in the destructor.
//
// Parameters:  - pSid: A pointer to a CSid. The memory pointed to by pSid will be released by
//              in the destructor.
//
// Return:      On success it returns S_OK.
//              On failure it returns E_OUTOFMEMORY.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
HRESULT CRsopToken::AddSid(CSid* pSid)
{

    //
    // first check if the Sid is already in there
    //
    for(CTLink<CSid>* pTraverseLink = m_pSidsHead; pTraverseLink; pTraverseLink = pTraverseLink->m_pNext)
    {
        //
        // If one of the SIDs in the RsopToken matches
        // this Sid, return
        //

        if (EqualSid(pSid->GetSidPtr(), pTraverseLink->m_pData->GetSidPtr())) 
            return S_OK;
    }


    //
    // Allocate a new link using the pSid passed in.
    //

    CTLink<CSid>* pLink = new CTLink<CSid>(pSid);
    if(!pLink)
    {
        return E_OUTOFMEMORY;
    }

    if(!m_pSidsHead)
    {
        m_pSidsHead = pLink;
    }
    else
    {
        m_pSidsTail->m_pNext = pLink;
    }

    m_pSidsTail = pLink;

    return S_OK;
}
//******************************************************************************
//
// Function:    GetUserInfo
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT GetUserInfo(const CWString& sUser,
                    CWString& sUserName,
                    CWString& sUserDomain,
                    CWString& sUserDC)
{
    if(!sUser.ValidString())
    {
        return E_FAIL;
    }

    NET_API_STATUS status;

    XPtrST<WCHAR>xpUserName = NULL;
    XPtrST<WCHAR>xpUserDomain = NULL;

    size_t len = sUser.length();

    WCHAR* backslashPos = wcschr(sUser, L'\\');
    if(backslashPos)
    {
        size_t index = backslashPos - sUser;
        xpUserDomain = new WCHAR[index + 1];
        if(!xpUserDomain )
        {
            return E_OUTOFMEMORY;
        }
        wcsncpy(xpUserDomain, sUser, index);
        xpUserDomain[index] = L'\0';

        xpUserName = new WCHAR[len - index];
        if(!xpUserName)
        {
            return E_OUTOFMEMORY;
        }
        wcsncpy(xpUserName, backslashPos + 1, len - index - 1);
        xpUserName[len - index - 1] = L'\0';
    }

    sUserName = xpUserName ? CWString(xpUserName) : sUser;
    if(!sUserName.ValidString())
    {
        return E_FAIL;
    }

    if(xpUserDomain)
    {
        // Use supplied domain.
        sUserDomain = xpUserDomain;
    }
    else
    {
        // Use current domain
        WKSTA_INFO_100* pWkstaInfo = NULL;
        status = NetWkstaGetInfo(NULL,100,(LPBYTE*)&pWkstaInfo);
        if(status != NERR_Success)
        {
            return E_FAIL;
        }
        sUserDomain = pWkstaInfo->wki100_langroup;
        NetApiBufferFree(pWkstaInfo);
    }

    if(!sUserDomain.ValidString())
    {
        return E_FAIL;
    }

    PDOMAIN_CONTROLLER_INFO pDCInfo = 0;
    
    DWORD dwError = DsGetDcName(0,
                                sUserDomain,
                                0,
                                0,
                                0,
                                &pDCInfo );
    if ( dwError != NO_ERROR )
    {
        return HRESULT_FROM_WIN32( dwError );
    }
    
    sUserDC = pDCInfo->DomainControllerName;

    NetApiBufferFree(pDCInfo);

    if ( !sUserDC.ValidString() )
    {
        return E_FAIL;
    }

    return S_OK;
}

//******************************************************************************
//
// Function:    AddSpecialGroup
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT AddSpecialGroup(PRSOPTOKEN pRsopToken, PSID pSid)
{
    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);

    XPtrST<CSid> xpCSid = new CSid(pSid);

    if(!xpCSid)
    {
        return E_OUTOFMEMORY;
    }

    if(!xpCSid->IsValid())
    {
        return E_FAIL;
    }

    HRESULT hr = pToken->AddSid(xpCSid);

    if(FAILED(hr))
    {
        return hr;
    }

    xpCSid.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:    AddSpecialGroups
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT AddSpecialGroups(PRSOPTOKEN pRsopToken )
{
    BOOL bRes;
    PSID pSid;
    HRESULT hr;

    //
    // Everyone
    //

    SID_IDENTIFIER_AUTHORITY IdentifierAuthority_World = SECURITY_WORLD_SID_AUTHORITY;

    bRes = AllocateAndInitializeSid(&IdentifierAuthority_World, 1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid);

    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        return E_FAIL;
    }

    hr = AddSpecialGroup(pRsopToken, pSid);

    FreeSid(pSid);

    if(FAILED(hr))
    {
        return hr;
    }

    //
    // Authenticated users
    //

    SID_IDENTIFIER_AUTHORITY IdentifierAuthority_NT = SECURITY_NT_AUTHORITY;

    bRes = AllocateAndInitializeSid(&IdentifierAuthority_NT, 1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid);

    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        return E_FAIL;
    }

    hr = AddSpecialGroup(pRsopToken, pSid);

    FreeSid(pSid);

    if(FAILED(hr))
    {
        return hr;
    }


    return S_OK;
}


//******************************************************************************
//
// Function:    AddGlobalGroups
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT AddGlobalGroups(const CWString& sUserName,
                        const CWString& sUserDC,
                        PRSOPTOKEN pRsopToken)
{
    if(!sUserName.ValidString())
    {
        return E_FAIL;
    }

    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);

    BYTE* pBuffer = NULL;
    DWORD dwEntriesread;
    DWORD dwTotalentries;

    NET_API_STATUS result = NetUserGetGroups(   sUserDC,
                                                sUserName,
                                                0,
                                                &pBuffer,
                                                MAX_PREFERRED_LENGTH,
                                                &dwEntriesread,
                                                &dwTotalentries);

    if(result != NERR_Success)
    {
        return HRESULT_FROM_WIN32(result);
    }

    HRESULT hr = S_OK;

    GROUP_USERS_INFO_0* pGui = (GROUP_USERS_INFO_0*)pBuffer;

    XPtrST<CSid> xpCSid;

    for(DWORD dwi = 0; dwi < dwEntriesread; dwi++)
    {
        xpCSid = new CSid((pGui[dwi]).grui0_name);

        if(!xpCSid)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if(!xpCSid->IsValid())
        {
            hr = E_FAIL;
            break;
        }

        hr = pToken->AddSid(xpCSid);
        if(FAILED(hr))
        {
            break;
        }

        xpCSid.Acquire();
    }

    NetApiBufferFree(pBuffer);

    return hr;
}


//******************************************************************************
//
// Function:    AddLocalGroups
//
// Description:
//
// Parameters:
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
//
//******************************************************************************
HRESULT AddLocalGroups(const CWString& sUserName,
                        const CWString& sUserDC,
                        PRSOPTOKEN pRsopToken)
{
    if(!sUserName.ValidString())
    {
        return E_FAIL;
    }

    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);

    BYTE* pBuffer = NULL;
    DWORD dwEntriesread;
    DWORD dwTotalentries;

    NET_API_STATUS result = NetUserGetLocalGroups(   
                                                sUserDC, 
                                                sUserName,
                                                0,
                                                LG_INCLUDE_INDIRECT,
                                                &pBuffer,
                                                MAX_PREFERRED_LENGTH,
                                                &dwEntriesread,
                                                &dwTotalentries);

    if(result != NERR_Success)
    {
        HRESULT_FROM_WIN32(result);
    }

    HRESULT hr = S_OK;

    LPLOCALGROUP_USERS_INFO_0 pLui = (LPLOCALGROUP_USERS_INFO_0)pBuffer;

    XPtrST<CSid> xpCSid;

    for(DWORD dwi = 0; dwi < dwEntriesread; dwi++)
    {
        xpCSid = new CSid((pLui[dwi]).lgrui0_name);

        if(!xpCSid)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if(!xpCSid->IsValid())
        {
            hr = E_FAIL;
            break;
        }

        hr = pToken->AddSid(xpCSid);
        if(FAILED(hr))
        {
            break;
        }

        xpCSid.Acquire();
    }

    NetApiBufferFree(pBuffer);

    return hr;
}

//******************************************************************************
//
// Function:    ExpandGroup
//
// Description: Expands a given group by expanding to include all the member subgroups etc..
//
// Parameters:  - pRsopToken:               Rsop token
//                hAuthz:                   A pointer to the Authz resource manager 
//                                          (that we are using to expand the grps)
//                pCSid:                    Sid of the group 
//
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
//******************************************************************************

HRESULT ExpandGroup(CRsopToken *pRsopToken, AUTHZ_RESOURCE_MANAGER_HANDLE hAuthz, 
                  CSid *pCSid )
{
    AUTHZ_CLIENT_CONTEXT_HANDLE   hAuthzContext=0;
    LUID                          luid = {0};
    HRESULT                       hrRet = S_OK;
    DWORD                         dwSize=0;
    XPtrLF<TOKEN_GROUPS>          xGrps;
    XPtrST<CSid>                  xpCSid;


    if (!AuthziInitializeContextFromSid(0,
                                       pCSid->GetSidPtr(), 
                                       hAuthz,
                                       NULL,
                                       luid, // we are not using it
                                       NULL,
                                      &hAuthzContext)) {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ExpandGroup - AuthziInitializeContextFromSid failed. Error - %d", GetLastError());
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Now get the list of expanded sids
    // find the size first
    //

    if (!AuthzGetInformationFromContext(hAuthzContext, 
                               AuthzContextInfoGroupsSids, 
                               NULL,
                               &dwSize,
                               0)) {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"ExpandGroup - AuthzGetInformationFromContext failed. Error - %d", GetLastError());
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    xGrps = (PTOKEN_GROUPS)LocalAlloc(LPTR, dwSize);
    
    if (!xGrps) {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ExpandGroup - Couldn't allocate memory for the token grps. Error - %d", GetLastError());
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    if (!AuthzGetInformationFromContext(hAuthzContext, 
                                AuthzContextInfoGroupsSids, 
                                dwSize,
                                &dwSize,
                                xGrps)) {

        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzGetInformationFromContext(2) failed. Error - %d", GetLastError());
        hrRet = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    for (DWORD i = 0; i < xGrps->GroupCount; i++) {
        xpCSid = new CSid(xGrps->Groups[i].Sid, NULL);

        if (!xpCSid) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - couldn't allocate memory(2). Error - %d", GetLastError());
            hrRet = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hrRet = pRsopToken->AddSid(xpCSid);
        if(FAILED(hrRet)) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AddSid failed. Error - 0x%x", hrRet);
            goto Exit;
        }

        xpCSid.Acquire();
    }
                
    hrRet = S_OK;

Exit:
    if (hAuthzContext)
        AuthzFreeContext(hAuthzContext);

    return hrRet;
}


//******************************************************************************
//
// Function:    RsopCreateToken
//
// Description: Creates a pseudo-token using an exisitng user or machine account plus
//              the accounts of which that user is currently a member of.
//              The returned pseudo-token can be used subsequently in call
//              to other RSOP security functions to check access to
//              objects protected by security descriptors.
//
// Parameters:  - szaccountName:            Pointer to a user or machine account name.
//              - psaUserSecurityGroups:    Pointer ta SAFEARRAY of BSTRs representing
//                                          security groups.
//                                          If NULL, then all the current security groups for the
//                                          szaccountName are added to the RsopToken.
//                                          If not NULL but pointing to an empty array,
//                                          only the szaccountName is added to the RsopToken.
//              - ppRsopToken:              Address of a PRSOPTOKEN that receives the newly
//                                          created pseudo-token
//
//
// Return:      S_OK if successful. An HRESULT error code on failure.
//
// History:     8/7/99      leonardm        Created.
//
//******************************************************************************
HRESULT RsopCreateToken(WCHAR* szAccountName,
                        SAFEARRAY* psaUserSecurityGroups,
                        PRSOPTOKEN* ppRsopToken )
{


    dbg.Initialize( L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                    L"ChkAccDebugLevel",
                    L"ChkAcc.log",
                    L"ChkAcc.bak");

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopCreateToken - Entering...");

    HRESULT hr = E_FAIL;


    //
    // Instantiate a new CRsopToken
    //

    *ppRsopToken = NULL;

    XPtrST<CRsopToken>xpRsopToken = new CRsopToken();

    if(!xpRsopToken)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Operator new returned NULL. Creation of a CRsopToken failed.");
        return E_OUTOFMEMORY;
    }

    //
    // Add to the new CRsopToken a CSid corresponding to the
    // principal represented by parameter szAccountName. For
    // dummy target the szAccountName will be null.
    //

    XPtrST<CSid>xpCSid;

    if ( szAccountName )
    {
        xpCSid = new CSid(szAccountName);

        if(!xpCSid)
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Operator new returned NULL. Creation of a CSid failed.");
            return E_OUTOFMEMORY;
        }

        if(!xpCSid->IsValid())
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - Call to CSid::IsValid failed.");
            return E_FAIL;
        }

        hr = xpRsopToken->AddSid(xpCSid);
        if(FAILED(hr))
        {
            return hr;
        }

        xpCSid.Acquire();
    }

    //
    // If the parameter is NULL, that means we are to add the security
    // groups to which the user currently belongs.
    //

    if(!psaUserSecurityGroups)
    {
        if (szAccountName) {
            CWString sUser = szAccountName;
            CWString sUserName;
            CWString sUserDomain;
            CWString sUserDC;

            hr = GetUserInfo(sUser, sUserName, sUserDomain, sUserDC);
            if(FAILED(hr))
            {
                return hr;
            }

/*          for cross domain cases this fails

            //
            // Get Global group membership
            //
            hr = AddGlobalGroups(sUserName, sUserDC, xpRsopToken);
            if(FAILED(hr))
            {
                return hr;
            }
*/

            hr = AddLocalGroups(sUserName, sUserDC, xpRsopToken);
            if(FAILED(hr))
            {
                return hr;
            }

            //
            // Universal groups across domains cannot be retrieved by 
            // NetUserGetGroups but can be fetched by authz functions.
            //

            xpCSid = new CSid(szAccountName);

            AUTHZ_RESOURCE_MANAGER_HANDLE hAuthz;

            if (!AuthzInitializeResourceManager(NULL, 
                                           NULL, 
                                           NULL, 
                                           NULL, 
                                           0,    
                                          &hAuthz)) {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzInitializeResourceManager failed. Error - %d", GetLastError());
                return HRESULT_FROM_WIN32(GetLastError());
            }

            hr = ExpandGroup(xpRsopToken, hAuthz, xpCSid);
            if (FAILED(hr)) {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - ExpandGrp failed for user. Error - 0x%x", hr);
                AuthzFreeResourceManager(hAuthz);
                return hr;
            }
                            
            AuthzFreeResourceManager(hAuthz);
            // xpCSid will be freed automatically.
        }
    }


    //
    // Otherwise, we add only those groups named in the SAFERARRAY.
    //

    else
    {
        BSTR* pbstr;
        AUTHZ_RESOURCE_MANAGER_HANDLE hAuthz;

        if (!AuthzInitializeResourceManager(NULL, 
                                       NULL, 
                                       NULL, 
                                       NULL, 
                                       0,    
                                      &hAuthz)) {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - AuthzInitializeResourceManager failed. Error - %d", GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }


        // Get a pointer to the elements of the array.
        hr = SafeArrayAccessData(psaUserSecurityGroups, (void**)&pbstr);
        if(FAILED(hr))
        {
            AuthzFreeResourceManager(hAuthz);
            return hr;
        }

        int count = psaUserSecurityGroups->rgsabound[0].cElements;
        for (int i = 0; i < count; i++)
        {
            xpCSid = new CSid(pbstr[i]);

            if(!xpCSid)
            {
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return E_OUTOFMEMORY;
            }

            if(!xpCSid->IsValid())
            {
                dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - %s is invalid", pbstr[i]);
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME);
            }

            // WellKnownGroups cannot be expanded ...
            if ( xpCSid->SidType() != SidTypeWellKnownGroup )
            {
                hr = ExpandGroup(xpRsopToken, hAuthz, xpCSid);
                if (FAILED(hr)) {
                    dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopCreateToken - ExpandGrp failed. Error - 0x%x", hr);
                    AuthzFreeResourceManager(hAuthz);
                    SafeArrayUnaccessData(psaUserSecurityGroups);
                    return hr;
                }
            }
                            
            hr = xpRsopToken->AddSid(xpCSid);
            if(FAILED(hr))
            {
                AuthzFreeResourceManager(hAuthz);
                SafeArrayUnaccessData(psaUserSecurityGroups);
                return hr;
            }

            xpCSid.Acquire();

        }

        AuthzFreeResourceManager(hAuthz);
        SafeArrayUnaccessData(psaUserSecurityGroups);
        
        
    }

    hr = AddSpecialGroups(xpRsopToken);
    if(FAILED(hr))
    {
        return hr;
    }
    
    *ppRsopToken = xpRsopToken;

    xpRsopToken.Acquire();

    return S_OK;
}

//******************************************************************************
//
// Function:    RsopDeleteToken
//
// Description: Destroys a pseudo-token previously created by any of the overloaded
//              forms of RSOPCreateRsopToken
//
// Parameters:  - pRsopToken: Pointer to a valid PRSOPTOKEN
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     7/30/99     leonardm        Created.
//
//******************************************************************************
HRESULT RsopDeleteToken(PRSOPTOKEN pRsopToken)
{
    CRsopToken* pToken = static_cast<CRsopToken*>(pRsopToken);
    delete pToken;
    return S_OK;
}

//******************************************************************************
//
// Function:    GetAceSid
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             10/19/99          leonardm        Created.
//
//******************************************************************************
PISID GetAceSid(PACE_HEADER pAceHeader)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - Entering.");


    //
    // Check for invalid argument
    //

    if(!pAceHeader)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"GetAceSid - Invalid parameter: pAceHeader is NULL");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - Leaving.");
        return NULL;
    }

    PISID pSid = NULL;

    PACCESS_ALLOWED_ACE pACCESS_ALLOWED_ACE;
    PACCESS_ALLOWED_OBJECT_ACE pACCESS_ALLOWED_OBJECT_ACE;
    PACCESS_DENIED_ACE pACCESS_DENIED_ACE;
    PACCESS_DENIED_OBJECT_ACE pACCESS_DENIED_OBJECT_ACE;

    //
    // Cast the ACE header to the appropriate ACE type based on the 'Acetype' member of the
    // ACE header.
    //

    switch(pAceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_ALLOWED_ACE_TYPE");
        pACCESS_ALLOWED_ACE = reinterpret_cast<PACCESS_ALLOWED_ACE>(pAceHeader);
        pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_ACE->SidStart));
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_ALLOWED_OBJECT_ACE_TYPE");
        pACCESS_ALLOWED_OBJECT_ACE = reinterpret_cast<PACCESS_ALLOWED_OBJECT_ACE>(pAceHeader);

        if( (pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) &&
            (pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If both ACE_OBJECT_TYPE_PRESENT and ACE_INHERITED_OBJECT_TYPE_PRESENT are set in
            // the ACE flags, the SID starts at the offset specified by 'SidStart'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_OBJECT_ACE->SidStart));
        }
        else if((pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) ||
                (pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If either ACE_OBJECT_TYPE_PRESENT or ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'InheritedObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_OBJECT_ACE->InheritedObjectType));
        }
        else
        {
            //
            // If neither ACE_OBJECT_TYPE_PRESENT nor ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'ObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_ALLOWED_OBJECT_ACE->ObjectType));
        }
        break;

    case ACCESS_DENIED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_DENIED_ACE_TYPE");
        pACCESS_DENIED_ACE = reinterpret_cast<PACCESS_DENIED_ACE>(pAceHeader);
        pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_ACE->SidStart));
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - ACE type: ACCESS_DENIED_OBJECT_ACE_TYPE");
        pACCESS_DENIED_OBJECT_ACE = reinterpret_cast<PACCESS_DENIED_OBJECT_ACE>(pAceHeader);
        if( (pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) &&
            (pACCESS_DENIED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If both ACE_OBJECT_TYPE_PRESENT and ACE_INHERITED_OBJECT_TYPE_PRESENT are set in
            // the ACE flags, the SID starts at the offset specified by 'SidStart'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_OBJECT_ACE->SidStart));
        }
        else if((pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT) ||
                (pACCESS_DENIED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT))
        {
            //
            // If either ACE_OBJECT_TYPE_PRESENT or ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'InheritedObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_OBJECT_ACE->InheritedObjectType));
        }
        else
        {
            //
            // If neither ACE_OBJECT_TYPE_PRESENT nor ACE_INHERITED_OBJECT_TYPE_PRESENT is set in
            // the ACE flags, the SID starts at the offset specified by 'ObjectType'.
            //

            pSid = reinterpret_cast<PISID>(&(pACCESS_DENIED_OBJECT_ACE->ObjectType));
        }
        break;

    default:
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"GetAceSid - Unexpected ACE type found. Type: 0x%08X", pAceHeader->AceType);
        break;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"GetAceSid - Leaving.");

    return pSid;
}

//******************************************************************************
//
// Function:    CheckAceApplies
//
// Description:
//
// Parameters:
//
// Return:              S_OK on success. An HRESULT error code on failure.
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
HRESULT CheckAceApplies(PACE_HEADER pAceHeader, PRSOPTOKEN pRsopToken, bool* pbAceApplies)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Entering.");

    //
    // Get the SID from the ACE associated with this Ace Header.
    //

    PISID pSid = GetAceSid(pAceHeader);
    if(!pSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"CheckAceApplies - GetAceSid failed.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Leaving.");
        return E_FAIL;
    }

    *pbAceApplies = false;

    //
    // Compare the SID from the ACE with all the SIDs in the RsopToken.
    //

    CRsopToken* pToken  = static_cast<CRsopToken*>(pRsopToken);
    for(CTLink<CSid>* pLink = pToken->m_pSidsHead; pLink; pLink = pLink->m_pNext)
    {
        //
        // If one of the SIDs in the RsopToken matches
        // the SID in the ACE, this ACE applies.
        //

        if(EqualSid(pSid, pLink->m_pData->GetSidPtr()))
        {
            *pbAceApplies = true;
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - One of the SIDs in the RsopToken matches the SID in the ACE. The ACE applies.");
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Leaving.");
            return S_OK;
        }
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - None of the SIDs in the RsopToken matches the SID in the ACE. The ACE does not apply.");
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"CheckAceApplies - Leaving.");

    return S_OK;
}

//******************************************************************************
const DWORD MAX_PERM_BITS=25;

//******************************************************************************
enum EPermission{ PERMISSION_DENIED, PERMISSION_ALLOWED, PERMISSION_NOT_SET};


//******************************************************************************
//
// Class:       CSubObjectPerm
//
// Description:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
class CSubObjectPerm
{
private:

    CTLink<GUID>* m_pGuidsHead;
    CTLink<GUID>* m_pGuidsTail;

    EPermission permissionBits[MAX_PERM_BITS];

public:

    CSubObjectPerm();
    ~CSubObjectPerm();

    HRESULT AddGuid(GUID* pGuid);

    void ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid);
    DWORD GetAccumulatedPermissions();
    bool  AnyDenied();
};

//******************************************************************************
//
// Function:    CSubObjectPerm::CSubObjectPerm
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
CSubObjectPerm::CSubObjectPerm() : m_pGuidsHead(NULL), m_pGuidsTail(NULL)
{
    for (int i = 0; i < MAX_PERM_BITS; i++)
    {
        permissionBits[i] = PERMISSION_NOT_SET;
    }
}

//******************************************************************************
//
// Function:    CSubObjectPerm::~CSubObjectPerm
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
CSubObjectPerm::~CSubObjectPerm()
{
    CTLink<GUID>* pLinkIterator = m_pGuidsHead;
    while(pLinkIterator)
    {
        CTLink<GUID>* pLinkToDelete = pLinkIterator;
        pLinkIterator = pLinkIterator->m_pNext;
        delete pLinkToDelete;
    }
}

//******************************************************************************
//
// Function:    CSubObjectPerm::AddGuid
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
HRESULT CSubObjectPerm::AddGuid(GUID* pGuid)
{
    CTLink<GUID>* pLink = new CTLink<GUID>(pGuid);
    if(!pLink)
    {
        return E_OUTOFMEMORY;
    }

    if(!m_pGuidsHead)
    {
        m_pGuidsHead = pLink;
    }
    else
    {
        m_pGuidsTail->m_pNext = pLink;
    }

    m_pGuidsTail = pLink;

    return S_OK;
}

//******************************************************************************
//
// Function:    CSubObjectPerm::ProcessAceMask
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
void CSubObjectPerm::ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid)
{
    bool bAceApplies = false;

    if(!pGuid)
    {
        bAceApplies = true;
    }

    else if(pGuid && m_pGuidsHead)
    {
        CTLink<GUID>* pLinkIterator = m_pGuidsHead;

        while(pLinkIterator)
        {
            if(*(pLinkIterator->m_pData) == *pGuid)
            {
                bAceApplies = true;
                break;
            }

            pLinkIterator = pLinkIterator->m_pNext;
        }
    }

    if(bAceApplies)
    {
        DWORD dwTemp = 0x00000001;

        for(int i = 0; i < MAX_PERM_BITS; i++)
        {
            if((dwMask & dwTemp) && (permissionBits[i] == PERMISSION_NOT_SET))
            {
                permissionBits[i] = permission;
            }

            dwTemp <<= 1;
        }
    }
}

//******************************************************************************
//
// Function:    CSubObjectPerm::AccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
DWORD CSubObjectPerm::GetAccumulatedPermissions()
{
    DWORD dwAccumulatedPermissions = 0;

    for(int i = MAX_PERM_BITS - 1; i >= 0; i--)
    {
        dwAccumulatedPermissions <<= 1;
        if(permissionBits[i] == PERMISSION_ALLOWED)
        {
            dwAccumulatedPermissions |= 0x00000001;
        }
    }

    return dwAccumulatedPermissions;
}

//******************************************************************************
//
// Function:    CSubObjectPerm::AnyDenied
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     11/09/99     leonardm        Created.
//
//******************************************************************************
bool CSubObjectPerm::AnyDenied()
{
    for(int i = 0; i < MAX_PERM_BITS; i++)
    {
        if(permissionBits[i] == PERMISSION_DENIED)
        {
            return true;
        }
    }

    return false;
}

//******************************************************************************
//
// Struct:    CDSObject
//
// Description:
//
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
struct CDSObject
{
    DWORD m_dwLevel;
    GUID* m_pGuid;

    CDSObject() : m_pGuid(NULL){}
    ~CDSObject()
    {
        delete m_pGuid;
    }
};

//******************************************************************************
//
// Class:    CAccumulatedPermissions
//
// Description:
//
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
class CAccumulatedPermissions
{
    CTLink<CSubObjectPerm>* m_pSubObjectsHead;
    CTLink<CSubObjectPerm>* m_pSubObjectsTail;

    CTLink<CDSObject>* m_pDSObjectsHead;
    CTLink<CDSObject>* m_pDSObjectsTail;

    bool m_bInitialized;

public:
    CAccumulatedPermissions(POBJECT_TYPE_LIST pObjectTypeList,
                            DWORD ObjectTypeListLength);
    ~CAccumulatedPermissions();
    void ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid);
    DWORD GetAccumulatedPermissions();
    bool AnyDenied();

    bool Initialized(){return m_bInitialized;}
};

//******************************************************************************
//
// Function:    CAccumulatedPermissions::CAccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
CAccumulatedPermissions::CAccumulatedPermissions(   POBJECT_TYPE_LIST pObjectTypeList,
                                                    DWORD ObjectTypeListLength) :
                                                    m_pSubObjectsHead(NULL),
                                                    m_pSubObjectsTail(NULL),
                                                    m_bInitialized(false),
                                                    m_pDSObjectsHead(NULL),
                                                    m_pDSObjectsTail(NULL)
{

    if(!pObjectTypeList || ObjectTypeListLength == 0)
    {
        XPtrST<CSubObjectPerm>xpSubObjectPerm = new CSubObjectPerm;
        if(!xpSubObjectPerm)
        {
            return;
        }

        m_pSubObjectsHead = new CTLink<CSubObjectPerm>(xpSubObjectPerm);
        if(!m_pSubObjectsHead)
        {
            return;
        }
        xpSubObjectPerm.Acquire();

        m_pSubObjectsTail = m_pSubObjectsHead;

        m_bInitialized = true;

        return;
    }


        DWORD dwCurrentLevel;

    for(DWORD i = 0; i < ObjectTypeListLength; i++)
    {
        if( i==0 )
        {
            //
            // This assumes that the first element in the list of
            // OBJECT_TYPEs pointed to by pObjectTypeList is at
            // level ACCESS_OBJECT_GUID.
            //

            dwCurrentLevel = pObjectTypeList[i].Level;

            XPtrST<CDSObject>xpDSObject = new CDSObject;
            if(!xpDSObject)
            {
                return;
            }

            XPtrST<GUID>xpGuid = new GUID(*(pObjectTypeList[i].ObjectType));
            if(!xpGuid)
            {
                return;
            }

            m_pDSObjectsHead = new CTLink<CDSObject>(xpDSObject);
            if(!m_pDSObjectsHead)
            {
                return;
            }

            xpDSObject.Acquire();

            m_pDSObjectsHead->m_pData->m_pGuid = xpGuid.Acquire();

            m_pDSObjectsHead->m_pData->m_dwLevel = pObjectTypeList[i].Level;

            m_pDSObjectsTail = m_pDSObjectsHead;

            continue;
        }

        else if(pObjectTypeList[i].Level > dwCurrentLevel)
        {
            dwCurrentLevel = pObjectTypeList[i].Level;

            XPtrST<CDSObject> xpDSObject = new CDSObject;
            if(!xpDSObject)
            {
                return;
            }

            XPtrST<GUID>xpGuid = new GUID(*(pObjectTypeList[i].ObjectType));
            if(!xpGuid)
            {
                return;
            }

            CTLink<CDSObject>* pDSObjectLink = new CTLink<CDSObject>(xpDSObject);
            if(!pDSObjectLink)
            {
                return;
            }

            xpDSObject.Acquire();

            pDSObjectLink->m_pData->m_pGuid = xpGuid.Acquire();
            pDSObjectLink->m_pData->m_dwLevel = pObjectTypeList[i].Level;

            pDSObjectLink->m_pPrev = m_pDSObjectsTail;
            m_pDSObjectsTail->m_pNext = pDSObjectLink;
            m_pDSObjectsTail = pDSObjectLink;
        }

        else
        {
            XPtrST<CSubObjectPerm>xpSubObjectPerm = new CSubObjectPerm;
            if(!xpSubObjectPerm)
            {
                return;
            }

            CTLink<CSubObjectPerm>* pSubObjectLink = new CTLink<CSubObjectPerm>(xpSubObjectPerm);
            if(!pSubObjectLink)
            {
                return;
            }

            xpSubObjectPerm.Acquire();


            CTLink<CDSObject>* pLinkIterator = m_pDSObjectsHead;
            while(pLinkIterator)
            {
                XPtrST<GUID>xpGuid = new GUID(*(pLinkIterator->m_pData->m_pGuid));
                if(!xpGuid)
                {
                    delete pSubObjectLink;
                    return;
                }

                if(FAILED(pSubObjectLink->m_pData->AddGuid(xpGuid)))
                {
                    delete pSubObjectLink;
                    return;
                }

                xpGuid.Acquire();

                pLinkIterator = pLinkIterator->m_pNext;
            }

            if(!m_pSubObjectsHead)
            {
                m_pSubObjectsHead = pSubObjectLink;
            }
            else
            {
                m_pSubObjectsTail->m_pNext = pSubObjectLink;
            }
            m_pSubObjectsTail = pSubObjectLink;


            pLinkIterator = m_pDSObjectsTail;

            if(pLinkIterator)
            {
                while(pLinkIterator->m_pData->m_dwLevel >= pObjectTypeList[i].Level)
                {
                    CTLink<CDSObject>* pLinkToDelete = pLinkIterator;
                    pLinkIterator = pLinkIterator->m_pPrev;
                    delete pLinkToDelete;
                    m_pDSObjectsTail = pLinkIterator;
                    if(m_pDSObjectsTail)
                    {
                        m_pDSObjectsTail->m_pNext = NULL;
                    }
                }
            }

            XPtrST<CDSObject>xpDSObject = new CDSObject;
            if(!xpDSObject)
            {
                return;
            }

            XPtrST<GUID>xpGuid = new GUID(*(pObjectTypeList[i].ObjectType));
            if(!xpGuid)
            {
                return;
            }

            CTLink<CDSObject>* pLink = new CTLink<CDSObject>(xpDSObject);
            if(!pLink)
            {
                return;
            }

            xpDSObject.Acquire();

            pLink->m_pData->m_pGuid = xpGuid.Acquire();
            pLink->m_pData->m_dwLevel = pObjectTypeList[i].Level;

            pLink->m_pPrev = m_pDSObjectsTail;
            m_pDSObjectsTail->m_pNext = pLink;
            m_pDSObjectsTail = pLink;
        }
    }

    CTLink<CDSObject>* pLinkIterator = m_pDSObjectsHead;

    if(pLinkIterator)
    {
        XPtrST<CSubObjectPerm>xpSubObject = new CSubObjectPerm;
        if(!xpSubObject)
        {
            return;
        }

        CTLink<CSubObjectPerm>* pSubObjectLink = new CTLink<CSubObjectPerm>(xpSubObject);
        if(!pSubObjectLink)
        {
            return;
        }

        xpSubObject.Acquire();

        while(pLinkIterator)
        {
            XPtrST<GUID>xpGuid = new GUID(*(pLinkIterator->m_pData->m_pGuid));
            if(!xpGuid)
            {
                delete pSubObjectLink;
                return;
            }

            if(FAILED(pSubObjectLink->m_pData->AddGuid(xpGuid)))
            {
                delete pSubObjectLink;
                return;
            }

            xpGuid.Acquire();

            pLinkIterator = pLinkIterator->m_pNext;
        }

        if(!m_pSubObjectsHead)
        {
            m_pSubObjectsHead = pSubObjectLink;
        }
        else
        {
            m_pSubObjectsTail->m_pNext = pSubObjectLink;
        }
        m_pSubObjectsTail = pSubObjectLink;
    }

    pLinkIterator = m_pDSObjectsHead;

    while(pLinkIterator)
    {
        CTLink<CDSObject>* pLinkToDelete = pLinkIterator;
        pLinkIterator = pLinkIterator->m_pNext;
        delete pLinkToDelete;
    }

    m_pDSObjectsHead = m_pDSObjectsTail = NULL;

    m_bInitialized = true;
}

//******************************************************************************
//
// Function:    CAccumulatedPermissions::~CAccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             10/25/99          leonardm        Created.
//
//******************************************************************************
CAccumulatedPermissions::~CAccumulatedPermissions()
{
    CTLink<CSubObjectPerm>* pSubObjectLinkIterator = m_pSubObjectsHead;
    while(pSubObjectLinkIterator)
    {
        CTLink<CSubObjectPerm>* pSubObjectLinkToDelete = pSubObjectLinkIterator;
        pSubObjectLinkIterator = pSubObjectLinkIterator->m_pNext;
        delete pSubObjectLinkToDelete;
    }

    CTLink<CDSObject>* pDSObjectLinkIterator = m_pDSObjectsHead;

    while(pDSObjectLinkIterator)
    {
        CTLink<CDSObject>* pDSObjectLinkToDelete = pDSObjectLinkIterator;
        pDSObjectLinkIterator = pDSObjectLinkIterator->m_pNext;
        delete pDSObjectLinkToDelete;
    }
}

//******************************************************************************
//
// Function:    CAccumulatedPermissions::ProcessAceMask
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
void CAccumulatedPermissions::ProcessAceMask(DWORD dwMask, EPermission permission, GUID* pGuid)
{
    CTLink<CSubObjectPerm>* pLinkIterator = m_pSubObjectsHead;
    while(pLinkIterator)
    {
        pLinkIterator->m_pData->ProcessAceMask(dwMask, permission, pGuid);
        pLinkIterator = pLinkIterator->m_pNext;
    }
}

//******************************************************************************
//
// Function:    CAccumulatedPermissions::AccumulatedPermissions
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
DWORD CAccumulatedPermissions::GetAccumulatedPermissions()
{

    DWORD dwAccumulatedPermissions = 0x01FFFFFF;

    CTLink<CSubObjectPerm>* pLinkIterator = m_pSubObjectsHead;
    while(pLinkIterator)
    {
        dwAccumulatedPermissions &= pLinkIterator->m_pData->GetAccumulatedPermissions();
        pLinkIterator = pLinkIterator->m_pNext;
    }

    return dwAccumulatedPermissions;
}


//******************************************************************************
//
// Function:    CAccumulatedPermissions::AnyDenied
//
// Description:
//
// Parameters:
//
// Return:
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
bool CAccumulatedPermissions::AnyDenied()
{
    CTLink<CSubObjectPerm>* pLinkIterator = m_pSubObjectsHead;
    while(pLinkIterator)
    {
        if(pLinkIterator->m_pData->AnyDenied())
        {
            return true;
        }

        pLinkIterator = pLinkIterator->m_pNext;
    }

    return false;
}


//******************************************************************************
//
// Function:    LogGuid
//
// Description:
//
// Parameters:
//
// Return:      void
//
// History:     10/26/99      leonardm        Created.
//
//******************************************************************************
void LogGuid(GUID& guid)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - Entering.");

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - {0x%08x 0x%04x 0x%04x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x}",
                                                    guid.Data1,
                                                    guid.Data2,
                                                    guid.Data3,
                                                    guid.Data4[0],
                                                    guid.Data4[1],
                                                    guid.Data4[2],
                                                    guid.Data4[3],
                                                    guid.Data4[4],
                                                    guid.Data4[5],
                                                    guid.Data4[6],
                                                    guid.Data4[7]);

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - (%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x)",
                                                    guid.Data1,
                                                    guid.Data2,
                                                    guid.Data3,
                                                    guid.Data4[0],
                                                    guid.Data4[1],
                                                    guid.Data4[2],
                                                    guid.Data4[3],
                                                    guid.Data4[4],
                                                    guid.Data4[5],
                                                    guid.Data4[6],
                                                    guid.Data4[7]);

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogGuid - Leaving.");
}


//******************************************************************************
//
// Function:    LogSid
//
// Description:
//
// Parameters:
//
// Return:      void
//
// History:     10/26/99      leonardm        Created.
//
//******************************************************************************
void LogSid(PSID pSid)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Entering.");

    XPtrST<CSid>xpCSid = new CSid(pSid);

    if(!xpCSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogSid - Call to operator new failed.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Leaving.");
        return;
    }

    if(!(xpCSid->IsValid()))
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogSid - call to CSid::IsValid returned false.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Leaving.");
        return;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid string: %s.", xpCSid->SidString());

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid User: %s.", xpCSid->User());

    if(xpCSid->SidType() == SidTypeUser)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeUser.");
    }
    else if(xpCSid->SidType() == SidTypeGroup)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeGroup.");
    }
    else if(xpCSid->SidType() == SidTypeDomain)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeDomain.");
    }
    else if(xpCSid->SidType() == SidTypeAlias)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeAlias.");
    }
    else if(xpCSid->SidType() == SidTypeWellKnownGroup)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeWellKnownGroup.");
    }
    else if(xpCSid->SidType() == SidTypeDeletedAccount)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeDeletedAccount.");
    }
    else if(xpCSid->SidType() == SidTypeInvalid)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeInvalid.");
    }
    else if(xpCSid->SidType() == SidTypeUnknown)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeUnknown.");
    }
    else if(xpCSid->SidType() == SidTypeComputer)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid type: SidTypeComputer.");
    }
    else
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogSid - Sid type: UNKNOWN SID type.");
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid Domain: %s.", xpCSid->Domain());
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Sid Computer: %s.", xpCSid->Computer());

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogSid - Leaving.");
}


//******************************************************************************
//
// Function:    LogAce
//
// Description:
//
// Parameters:
//
// Return:      void
//
// History:     10/26/99      leonardm        Created.
//
//******************************************************************************
void LogAce(PACE_HEADER pAceHeader)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Entering.");

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - AceType = 0x%08X.", pAceHeader->AceType);


    PACCESS_ALLOWED_ACE pACCESS_ALLOWED_ACE = NULL;
    PACCESS_ALLOWED_OBJECT_ACE pACCESS_ALLOWED_OBJECT_ACE = NULL;

    PACCESS_DENIED_ACE pACCESS_DENIED_ACE = NULL;
    PACCESS_DENIED_OBJECT_ACE pACCESS_DENIED_OBJECT_ACE = NULL;

    PSYSTEM_AUDIT_ACE pSYSTEM_AUDIT_ACE = NULL;
    PSYSTEM_AUDIT_OBJECT_ACE pSYSTEM_AUDIT_OBJECT_ACE = NULL;

    PSYSTEM_ALARM_ACE pSYSTEM_ALARM_ACE = NULL;
    PSYSTEM_ALARM_OBJECT_ACE pSYSTEM_ALARM_OBJECT_ACE = NULL;

    switch(pAceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_ALLOWED_ACE_TYPE");
        pACCESS_ALLOWED_ACE = reinterpret_cast<PACCESS_ALLOWED_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_ALLOWED_ACE->Mask);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_ALLOWED_OBJECT_ACE_TYPE");
        pACCESS_ALLOWED_OBJECT_ACE = reinterpret_cast<PACCESS_ALLOWED_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_ALLOWED_OBJECT_ACE->Mask);

        if(pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_ALLOWED_OBJECT_ACE->ObjectType);
        }

        if(pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_ALLOWED_OBJECT_ACE->InheritedObjectType);
        }
        break;

    case ACCESS_DENIED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_DENIED_ACE_TYPE");
        pACCESS_DENIED_ACE = reinterpret_cast<PACCESS_DENIED_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_DENIED_ACE->Mask);
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: ACCESS_DENIED_OBJECT_ACE_TYPE");
        pACCESS_DENIED_OBJECT_ACE = reinterpret_cast<PACCESS_DENIED_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pACCESS_DENIED_OBJECT_ACE->Mask);

        if(pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_DENIED_OBJECT_ACE->ObjectType);
        }

        if(pACCESS_DENIED_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pACCESS_DENIED_OBJECT_ACE->InheritedObjectType);
        }
        break;

    case SYSTEM_AUDIT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_AUDIT_ACE_TYPE");
        pSYSTEM_AUDIT_ACE = reinterpret_cast<PSYSTEM_AUDIT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_AUDIT_ACE->Mask);
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_AUDIT_OBJECT_ACE_TYPE");
        pSYSTEM_AUDIT_OBJECT_ACE = reinterpret_cast<PSYSTEM_AUDIT_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_AUDIT_OBJECT_ACE->Mask);

        if(pSYSTEM_AUDIT_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_AUDIT_OBJECT_ACE->ObjectType);
        }

        if(pSYSTEM_AUDIT_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_AUDIT_OBJECT_ACE->InheritedObjectType);
        }
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_ALARM_ACE_TYPE");
        pSYSTEM_ALARM_ACE = reinterpret_cast<PSYSTEM_ALARM_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_ALARM_ACE->Mask);
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE type: SYSTEM_ALARM_OBJECT_ACE_TYPE");
        pSYSTEM_ALARM_OBJECT_ACE = reinterpret_cast<PSYSTEM_ALARM_OBJECT_ACE>(pAceHeader);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - ACE Mask: 0x%08X", pSYSTEM_ALARM_OBJECT_ACE->Mask);

        if(pSYSTEM_ALARM_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_ALARM_OBJECT_ACE->ObjectType);
        }

        if(pSYSTEM_ALARM_OBJECT_ACE->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Flag is on: ACE_INHERITED_OBJECT_TYPE_PRESENT.");
            LogGuid(pSYSTEM_ALARM_OBJECT_ACE->InheritedObjectType);
        }
        break;

    default:
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogAce - ACE type: UNKNOWN ACE type.");
        break;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - AceFlags = 0x%08X.", pAceHeader->AceFlags);

    if(pAceHeader->AceFlags & OBJECT_INHERIT_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: OBJECT_INHERIT_ACE.");
    }

    if(pAceHeader->AceFlags & CONTAINER_INHERIT_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: CONTAINER_INHERIT_ACE.");
    }

    if(pAceHeader->AceFlags & NO_PROPAGATE_INHERIT_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: NO_PROPAGATE_INHERIT_ACE.");
    }

    if(pAceHeader->AceFlags & INHERIT_ONLY_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: INHERIT_ONLY_ACE.");
    }

    if(pAceHeader->AceFlags & INHERITED_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: INHERITED_ACE.");
    }

    if(pAceHeader->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: SUCCESSFUL_ACCESS_ACE_FLAG.");
    }

    if(pAceHeader->AceFlags & FAILED_ACCESS_ACE_FLAG)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - The Following ACE header flag is on: FAILED_ACCESS_ACE_FLAG.");
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - AceSize = 0x%08X.", pAceHeader->AceSize);


    PISID pSid = GetAceSid(pAceHeader);
    if(!pSid)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"LogAce - Call to GetAceSid failed.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Leaving.");
        return;
    }

    LogSid(pSid);

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"LogAce - Leaving.");
}

//******************************************************************************
//
// Function:    ProcessAce
//
// Description:
//
// Parameters:
//
// Return:              S_OK on success. An HRESULT error code on failure.
//
// History:             8/8/99          leonardm        Created.
//
//******************************************************************************
HRESULT ProcessAce( PACE_HEADER pAceHeader,
                    PRSOPTOKEN pRsopToken,
                    POBJECT_TYPE_LIST pObjectTypeList,
                    DWORD ObjectTypeListLength,
                    DWORD dwDesiredAccessMask,
                    CAccumulatedPermissions& accumulatedPermissions,
                    bool* pbAccessExplicitlyDenied)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Entering.");

    //
    // Check parameters.
    //

    if( !pAceHeader || !pRsopToken ||
        (ObjectTypeListLength && !pObjectTypeList) ||
        !pbAccessExplicitlyDenied)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ProcessAce - Invalid argument(s).");
        return E_FAIL;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Desired Access Mask: 0x%08X.", dwDesiredAccessMask);
    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Desired Access Mask == MAXIMUM_ALLOWED.");
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Accumulated Permissions BEFORE Processing Ace: 0x%08X.", accumulatedPermissions.GetAccumulatedPermissions());


    //
    // Log ACE information
    //

    LogAce(pAceHeader);

    *pbAccessExplicitlyDenied = false;

    //
    // ACEs with INHERIT_ONLY_ACE flag do no control access to the current object.
    // Therefore, we ignore them.
    //

    if(pAceHeader->AceFlags & INHERIT_ONLY_ACE)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Found ACE with INHERIT_ONLY_ACE flag. Ace does not apply.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return S_OK;
    }

    //
    // If this ACE does not reference any of the SIDs contained in the RsopToken,
    // we ignore it.
    //

    bool bAceApplies;
    HRESULT hr = CheckAceApplies(pAceHeader, pRsopToken, &bAceApplies);
    if(FAILED(hr))
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ProcessAce - CheckAceApplies failed. Return code: 0x%08X", hr);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return hr;
    }

    if(!bAceApplies)
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE does not apply.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return S_OK;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE aplies.");

    PACCESS_ALLOWED_ACE pACCESS_ALLOWED_ACE;
    PACCESS_ALLOWED_OBJECT_ACE pACCESS_ALLOWED_OBJECT_ACE;
    PACCESS_DENIED_ACE pACCESS_DENIED_ACE;
    PACCESS_DENIED_OBJECT_ACE pACCESS_DENIED_OBJECT_ACE;

    DWORD i;
    DWORD dwMask;
    switch(pAceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_ALLOWED_ACE_TYPE");
        pACCESS_ALLOWED_ACE = reinterpret_cast<PACCESS_ALLOWED_ACE>(pAceHeader);

        //
        // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
        // controlled by this ACE.
        // Otherwise, consider only those bits that are also specified in the
        // desired access mask.
        //

        if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
        {
            dwMask = pACCESS_ALLOWED_ACE->Mask;
        }
        else
        {
            dwMask = dwDesiredAccessMask & pACCESS_ALLOWED_ACE->Mask;
        }

        accumulatedPermissions.ProcessAceMask(  dwMask,
                                                PERMISSION_ALLOWED,
                                                NULL);

        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_ALLOWED_OBJECT_ACE_TYPE");
        pACCESS_ALLOWED_OBJECT_ACE = reinterpret_cast<PACCESS_ALLOWED_OBJECT_ACE>(pAceHeader);


        //
        // We have chosen to process only those object ACEs that have
        // the flag ACE_OBJECT_TYPE_PRESENT set.
        //

        if(pACCESS_ALLOWED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {


            //
            // Notice that if this function is invoked with no
            // ObjectTypeList, object ACEs are disregarded.
            //

            for(i = 0; i < ObjectTypeListLength; i++)
            {
                POBJECT_TYPE_LIST pObjectType = &(pObjectTypeList[i]);
                if(*(pObjectType->ObjectType) == pACCESS_ALLOWED_OBJECT_ACE->ObjectType)
                {
                    //
                    // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
                    // controlled by this ACE.
                    // Otherwise, consider only those bits that are also specified in the
                    // desired access mask.
                    //

                    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
                    {
                        dwMask = pACCESS_ALLOWED_OBJECT_ACE->Mask;
                    }
                    else
                    {
                        dwMask = dwDesiredAccessMask & pACCESS_ALLOWED_OBJECT_ACE->Mask;
                    }

                    accumulatedPermissions.ProcessAceMask(  dwMask,
                                                            PERMISSION_ALLOWED,
                                                            &(pACCESS_ALLOWED_OBJECT_ACE->ObjectType));

                    break;
                }
            }
        }

        break;

    case ACCESS_DENIED_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_DENIED_ACE_TYPE");
        pACCESS_DENIED_ACE = reinterpret_cast<PACCESS_DENIED_ACE>(pAceHeader);


        //
        // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
        // controlled by this ACE.
        // Otherwise, consider only those bits that are also specified in the
        // desired access mask.
        //

        if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
        {
            dwMask = pACCESS_DENIED_ACE->Mask;
        }
        else
        {
            dwMask = dwDesiredAccessMask & pACCESS_DENIED_ACE->Mask;
        }

        accumulatedPermissions.ProcessAceMask(  dwMask,
                                                PERMISSION_DENIED,
                                                NULL);

        if(dwDesiredAccessMask != MAXIMUM_ALLOWED)
        {
            if(accumulatedPermissions.AnyDenied())
            {
                *pbAccessExplicitlyDenied = true;
            }
        }

        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - ACE type: ACCESS_DENIED_OBJECT_ACE_TYPE");
        pACCESS_DENIED_OBJECT_ACE = reinterpret_cast<PACCESS_DENIED_OBJECT_ACE>(pAceHeader);


        //
        // We have chosen to process only those object ACEs that have
        // the flag ACE_OBJECT_TYPE_PRESENT set.
        //

        if(pACCESS_DENIED_OBJECT_ACE->Flags & ACE_OBJECT_TYPE_PRESENT)
        {


            //
            // Notice that if this function is invoked with no
            // ObjectTypeList, object ACEs are disregarded.
            //

            for(i = 0; i < ObjectTypeListLength; i++)
            {
                POBJECT_TYPE_LIST pObjectType = &(pObjectTypeList[i]);
                if(*(pObjectType->ObjectType) == pACCESS_DENIED_OBJECT_ACE->ObjectType)
                {
                    //
                    // If the requested access is MAXIMUM_ALLOWED, consider all bits in the Mask
                    // controlled by this ACE.
                    // Otherwise, consider only those bits that are also specified in the
                    // desired access mask.
                    //

                    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
                    {
                        dwMask = pACCESS_DENIED_OBJECT_ACE->Mask;
                    }
                    else
                    {
                        dwMask = dwDesiredAccessMask & pACCESS_DENIED_OBJECT_ACE->Mask;
                    }

                    accumulatedPermissions.ProcessAceMask(  dwMask,
                                                            PERMISSION_DENIED,
                                                            &(pACCESS_DENIED_OBJECT_ACE->ObjectType));

                    if(dwDesiredAccessMask != MAXIMUM_ALLOWED)
                    {
                        if(accumulatedPermissions.AnyDenied())
                        {
                            *pbAccessExplicitlyDenied = true;
                        }
                    }

                    break;
                }
            }
        }

        break;

    default:
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"ProcessAce - Unexpected ACE type found in ACE header. Type: 0x%08x", pAceHeader->AceType);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");
        return E_FAIL;
        break;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Accumulated Permissions AFTER Processing Ace: 0x%08X.", accumulatedPermissions.GetAccumulatedPermissions());

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"ProcessAce - Leaving.");

    return S_OK;
}

//******************************************************************************
//
// Function:    RsopAccessCheckByType
//
// Description:
//
// Parameters:          - pSecurityDescriptor,
//                      - pPrincipalSelfSid:
//                      - pRsopToken:
//                      - dwDesiredAccessMask:
//                      - pObjectTypeList:
//                      - ObjectTypeListLength:
//                      - pGenericMapping:
//                      - pPrivilegeSet:
//                      - pdwPrivilegeSetLength:
//                      - pdwGrantedAccessMask:
//                      - pbAccessStatus:
//
// Return:              S_OK on success. An HRESULT error code on failure.
//
// History:             7/30/99         leonardm        Created.
//
//******************************************************************************
HRESULT RsopAccessCheckByType(  PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                PSID pPrincipalSelfSid,
                                PRSOPTOKEN pRsopToken,
                                DWORD dwDesiredAccessMask,
                                POBJECT_TYPE_LIST pObjectTypeList,
                                DWORD ObjectTypeListLength,
                                PGENERIC_MAPPING pGenericMapping,
                                PPRIVILEGE_SET pPrivilegeSet,
                                LPDWORD pdwPrivilegeSetLength,
                                LPDWORD pdwGrantedAccessMask,
                                LPBOOL pbAccessStatus)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Entering.");


    //
    // Check arguments.
    //

    if( !pSecurityDescriptor |
        !IsValidSecurityDescriptor(pSecurityDescriptor) |
        !pRsopToken |
        !pGenericMapping |
        !pdwGrantedAccessMask |
        !pbAccessStatus)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - Function invoked with invalid arguments.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return E_INVALIDARG;
    }


    //
    // Get the DACL from the Security Descriptor
    //

    BOOL bDaclPresent;
    PACL pDacl;
    BOOL bDaclDefaulted;
    if(!GetSecurityDescriptorDacl(pSecurityDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted))
    {
        DWORD dwLastError = GetLastError();
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - GetSecurityDescriptorDacl failed. GetLastError=0x%08X", dwLastError);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return E_FAIL;
    }


    //
    // Map generic rights specified in dwDesiredAccessMask to standard
    // and specific rights.
    // This is necessary because the ACEs in the DACL specify standard
    // and specific rights only.
    //

    if(dwDesiredAccessMask != MAXIMUM_ALLOWED)
    {
        MapGenericMask(&dwDesiredAccessMask, pGenericMapping);
    }


    //
    // If no DACL is present (as indicated by bDaclPresent) in the security descriptor,
    // or if it present (as indicated by bDaclPresent) but it is a NULL DACL
    // the object implicitly grants all access.
    //

    if(!bDaclPresent || pDacl == NULL)
    {
        if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
        {
            *pdwGrantedAccessMask = pGenericMapping->GenericAll |
                                    pGenericMapping->GenericExecute |
                                    pGenericMapping->GenericRead |
                                    pGenericMapping->GenericWrite;
        }
        else
        {
            *pdwGrantedAccessMask = dwDesiredAccessMask;
        }
        *pbAccessStatus = TRUE;
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - No DACL present. All access is granted.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return S_OK;
    }

    DWORD dwAceCount = pDacl->AceCount;


    //
    // If the DACL is present but it is empty,
    // the object implicitly denies access to everyone.
    //

    if(!dwAceCount)
    {
        *pdwGrantedAccessMask = 0;
        *pbAccessStatus = FALSE;
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - The DACL is present but it is empty. All access is denied.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return S_OK;
    }


    //
    // At this point we have an array of ACES structures
    //
    // If the desired access is different from MAXIMUM_ALLOWED,
    // inspect them until one of the following happens:
    //
    //      1. An ACE is found which explicitly denies one of the requested
    //      access rights. In this case checking stops immediately and
    //      access is (explicitly) denied.
    //
    //      2. All the requested accesses are explicitly granted by one or
    //      more ACEs. In this case checking stops immediately and
    //      access is (explicitly) allowed.
    //
    //
    //      3. All the ACEs have been inspected inspected and there is at least
    //      one requested access right that has not been explicitly allowed.
    //      In this case, access is (implicitly) denied.
    //
    // If the desired access is MAXIMUM_ALLOWED, inspect all the ACEs.
    //

    PISID pSid;
    BYTE* pByte;

    CAccumulatedPermissions accumulatedPermissions( pObjectTypeList, ObjectTypeListLength);

    if(!accumulatedPermissions.Initialized())
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - CAccumulatedPermissions failed to initialize.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
        return E_FAIL;
    }



    *pdwGrantedAccessMask = 0;
    *pbAccessStatus = FALSE;


    //
    // Log SID information contained in the RsopToken.
    //

    CRsopToken* pToken  = static_cast<CRsopToken*>(pRsopToken);
    for(CTLink<CSid>* pLink = pToken->m_pSidsHead; pLink; pLink = pLink->m_pNext)
    {
        LogSid(pLink->m_pData->GetSidPtr());
    }


    //
    // The first ACE immediately follows the DACL structure. We don't know up front
    // the type of ACE so we get the ACE header which has a format common to all
    // ACE types.
    //

    PACE_HEADER pAceHeader = reinterpret_cast<PACE_HEADER>(pDacl+1);

    for(DWORD i=0; i<dwAceCount; i++)
    {
        bool bAccessExplicitlyDenied;
        HRESULT hr = ProcessAce(pAceHeader,
                                pRsopToken,
                                pObjectTypeList,
                                ObjectTypeListLength,
                                dwDesiredAccessMask,
                                accumulatedPermissions,
                                &bAccessExplicitlyDenied);

        if(FAILED(hr))
        {
            dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopAccessCheckByType - ProcessAce failed. Return code: 0x%08X", hr);
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
            return hr;
        }


        //
        // If, this ACE explicitly denies any of the requested access rights,
        // stop immediately. Access is denied.
        // ProcessAce will never set this variable to true when dwDesiredAccessMask
        // is MAXIMUM_ALLOWED.
        //

        if(bAccessExplicitlyDenied)
        {
            *pdwGrantedAccessMask = 0;
            *pbAccessStatus = FALSE;
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - An ACE explicitly denies any of the requested access rights. Access is denied.");
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
            return S_OK;
        }


        //
        // If, after processing this ACE all requested access rights have been granted,
        // stop immediately. Access is granted.
        //

        DWORD dwAccumulatedPermissions = accumulatedPermissions.GetAccumulatedPermissions();
        if((dwDesiredAccessMask != MAXIMUM_ALLOWED) && (dwAccumulatedPermissions == dwDesiredAccessMask))
        {
            *pdwGrantedAccessMask = dwDesiredAccessMask;
            *pbAccessStatus = TRUE;
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - dwDesiredAccessMask != MAXIMUM_ALLOWED && dwAccumulatedPermissions == dwDesiredAccessMask. Access is granted.");
            dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");
            return S_OK;
        }


        //
        // Otherwise, point to the next ACE.
        //

        pAceHeader = reinterpret_cast<PACE_HEADER>(reinterpret_cast<BYTE*>(pAceHeader) + pAceHeader->AceSize);
    }

    if(dwDesiredAccessMask == MAXIMUM_ALLOWED)
    {
        *pdwGrantedAccessMask = accumulatedPermissions.GetAccumulatedPermissions();
        *pbAccessStatus = *pdwGrantedAccessMask ? TRUE : FALSE;
    }

    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopAccessCheckByType - Leaving.");

    return S_OK;
}

//******************************************************************************
//
// Function:    RsopFileAccessCheck
//
// Description: Determines whether the security descriptor pointed to by pSecurityDescriptor
//              grants the set of file access rights specified in dwDesiredAccessMask
//              to the client identified by the RSOPTOKEN pointed to by pRsopToken.
//
// Parameters:  - pszFileName:          Pointer to an existing filename.
//              - pRsopToken:           Pointer to a valid RSOPTOKEN against which access
//                                      is to be checked.
//              - dwDesiredAccessMask:  Mask of requested generic and/or standard and/or specific access rights,
//              - pdwGrantedAccessMask: On success, if pbAccessStatus is true, it contains
//                                      the mask of standard and specific rights granted.
//                                      If pbAccessStatus is false, it is set to 0.
//                                      On failure, it is not modified.
//              - pbAccessStatus:       On success, indicates wether the requested set
//                                      of access rights was granted.
//                                      On failure, it is not modified
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     7/30/99         leonardm        Created.
//
//******************************************************************************
HRESULT RsopFileAccessCheck(LPTSTR pszFileName,
                            PRSOPTOKEN pRsopToken,
                            DWORD dwDesiredAccessMask,
                            LPDWORD pdwGrantedAccessMask,
                            LPBOOL pbAccessStatus)
{
    dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Entering.");


    //
    // Check for invalid arguments.
    //

    if( !pszFileName |!pRsopToken | !pdwGrantedAccessMask | !pbAccessStatus)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Function called with invalid parameters.");
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
        return E_INVALIDARG;
    }


    //
    // Attempt to get a handle with READ_CONTROL access right that can be used to
    // read the security descriptor.
    //

    XHandle hFile = CreateFile( pszFileName,
                                READ_CONTROL,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);


    if(hFile == INVALID_HANDLE_VALUE)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Call to CreateFile failed. Filename: %s. Last error: 0x%08X", pszFileName, GetLastError());
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
        return E_FAIL;
    }


    //
    // Use the handle to get the security descriptor with only the DACL in it.
    //

    PACL pDacl;
    XPtrLF<SECURITY_DESCRIPTOR>xpSecurityDescriptor = NULL;
    DWORD status = GetSecurityInfo( hFile,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pDacl,
                                    NULL,
                                    reinterpret_cast<void**>(&xpSecurityDescriptor));

    if(status != ERROR_SUCCESS)
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Call to GetSecurityInfo failed. Return: 0x%08X", status);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
        return E_FAIL;
    }


    //
    // This will be used by RSOPAccessCheckByType to map generic rights specified in
    // dwDesiredAccessMask to standard and specific rights.
    //

    GENERIC_MAPPING FileGenericMapping;
    FileGenericMapping.GenericRead = FILE_GENERIC_READ;
    FileGenericMapping.GenericWrite = FILE_GENERIC_WRITE;
    FileGenericMapping.GenericExecute = FILE_GENERIC_EXECUTE;
    FileGenericMapping.GenericAll = FILE_ALL_ACCESS;


    //
    // Call RsopAccessCheckByType to do the actual checking.
    //

    HRESULT hr = RsopAccessCheckByType( xpSecurityDescriptor,
                                        NULL,
                                        pRsopToken,
                                        dwDesiredAccessMask,
                                        NULL,
                                        0,
                                        &FileGenericMapping,
                                        NULL,
                                        0,
                                        pdwGrantedAccessMask,
                                        pbAccessStatus);

    if(SUCCEEDED(hr))
    {
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving successfully.");
    }
    else
    {
        dbg.Msg(DEBUG_MESSAGE_WARNING, L"RsopFileAccessCheck - Call to RsopAccessCheckByType failed. Return: 0x%08X", hr);
        dbg.Msg(DEBUG_MESSAGE_VERBOSE, L"RsopFileAccessCheck - Leaving.");
    }

    return hr;
}

//******************************************************************************
//
// Function:    RsopSidsFromToken
//
// Description:  Returns all the sids in the token
//
// Parameters: pRsopToken -- an rsop token from which to obtain sids
//             ppGroups -- a pointer to the address of a TOKEN_GROUPS structure
//                 that will be allocated by this function and will contain
//                 references to the sids.  The caller should free this
//                 pointer with LocalFree -- this will also free all memory
//                 referenced by the structure.
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
//
//******************************************************************************
HRESULT RsopSidsFromToken(PRSOPTOKEN     pRsopToken,
                          PTOKEN_GROUPS* ppGroups)
{
    HRESULT     hr;
    CRsopToken* pToken;

    //
    // Initializations
    //
    hr = S_OK;
    *ppGroups = NULL;

    pToken = (CRsopToken*) pRsopToken;

    //
    // First, determine the number of groups and the size
    // needed for each sid
    //
    CTLink<CSid>* pCurrent;
    DWORD         cbSize;
    DWORD         cGroups;

    cbSize = 0;
    cGroups = 0;

    //
    // Iterate through each sid, adding its size to the total
    // needed to store the sids
    //
    for ( pCurrent = pToken->m_pSidsHead;
          pCurrent;
          pCurrent = pCurrent->m_pNext)
    {
        cbSize += RtlLengthSid(pCurrent->m_pData->GetSidPtr());
        cGroups++;
    }

    //
    // Add in the size of the fixed portion of the return structure.
    // Note that the fixed portion of the structure already has
    // space for one group, so we exclude that group from the amount
    // neeeded to allocate if we are allocating at least one group
    //
    cbSize += sizeof(TOKEN_GROUPS) + (sizeof(SID_AND_ATTRIBUTES) *
                                      (cGroups - (cGroups ? 1 : 0)));

    //
    // Now allocate space for the groups
    //
    *ppGroups = (PTOKEN_GROUPS) LocalAlloc( LPTR, cbSize );

    if ( !*ppGroups )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Set the count member of the structure
    //
    (*ppGroups)->GroupCount = cGroups;

    //
    // If there are groups, copy the sids
    //
    if ( 0 != cGroups )
    {
        PSID                pCurrentSid;
        PSID_AND_ATTRIBUTES pCurrentGroup;

        //
        // Set the current sid to an offset past the
        // array of SID_AND_ATTRIBUTE structures that
        // represents each group
        //
        pCurrentSid = &((*ppGroups)->Groups[cGroups]);

        //
        // Set the current group to the first SID_AND_ATTRIBUTE structure
        //
        pCurrentGroup = (PSID_AND_ATTRIBUTES) &((*ppGroups)->Groups);

        //
        // We have no information in the rsop token regarding
        // the attributes, so we clear this member
        //
        pCurrentGroup->Attributes = 0;

        //
        // Iterate through each group and copy it
        //
        for (pCurrent = pToken->m_pSidsHead;
             pCurrent;
             pCurrent = pCurrent->m_pNext)
        {
            DWORD    cbSid;
            NTSTATUS Status;

            //
            // Determine the length of the source sid
            //
            cbSid = RtlLengthSid(pCurrent->m_pData->GetSidPtr());

            //
            // Copy the source sid to the current sid
            //
            Status = RtlCopySid(
                cbSid,
                pCurrentSid,
                pCurrent->m_pData->GetSidPtr());

            //
            // Check for errors
            //
            if (STATUS_SUCCESS != Status)
            {
                hr = HRESULT_FROM_WIN32(Status);

                break;
            }

            //
            // Set the current group's sid reference to the
            // current sid
            //
            pCurrentGroup->Sid = pCurrentSid;

            //
            // Move our current sid offset forward by the length of
            // the current sid.  Move our group reference forward as well.
            //
            pCurrentSid = (PSID) (((BYTE*) pCurrentSid) + cbSid);
            pCurrentGroup++;
        }
    }

    //
    // Free any memory on failure and remove
    // any reference to it
    //
    if (FAILED(hr))
    {
        LocalFree(*ppGroups);
        *ppGroups = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\collect.h ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        Collect.h
//
// Description: Support for Namespace Garbage Collection
//
// History:     12-01-99   leonardm    Created
//
//******************************************************************************


#ifdef __cplusplus
extern "C"{
#endif 

//******************************************************************************
//
// Function:    GarbageCollectNamespaces
//
// Description: Iterates through namespaces under root\rsop and for each of those
//              that are determined to be garbage-collectable, it connects to
//              sub-namespaces 'User' and 'Computer'.
//
//              Any of the sub-namespaces that is older than TTLMinutes will be deleted.
//              If no sub-namespaces are left, then the parent namespace is deleted as well.
//
//              Garbage-collectable are those namespaces which satisfy a set of 
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//              Sub-namespaces 'User' and 'Computer' are expected to have an instance of class
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted.
//
//
// Parameters:  TTLMinutes -    The maximum number of minutes that may have 
//                              elapsed since the creation of a sub-namespace
//
// Return:      
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GarbageCollectNamespaces(ULONG TTLMinutes);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\collect.cpp ===
//******************************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        Collect.cpp
//
// Description: Support for Namespace Garbage Collection
//
// History:     12-01-99   leonardm    Created
//
//******************************************************************************


#include "uenv.h"
#include "collect.h"
#include "..\rsoputil\smartptr.h"
#include "..\rsoputil\rsoputil.h"
#include "..\rsoputil\wbemtime.h"


//******************************************************************************
//
// Function:    GetMinutesElapsed
//
// Description: Returns the number of minutes elapsed between a time represented
//              in a BSTR in WBEM format and the present time.
//              It expects a string in WBEM datetime format: "yyyymmddhhmmss.000000+000"
//              where yyyy=year, mm=month, dd=day, hh=hour, mm=minutes, ss=seconds
//
//
// Parameters:  xbstrOldTime -      Reference to XBStr representing the time from which
//                                  calculate the time span.
//
//              pMinutesElapsed -   Pointer to a ULONG that receives the minutes elapsed
//                                  between xbstrOldTime and the present time.
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GetMinutesElapsed(XBStr& xbstrOldTime, ULONG* pMinutesElapsed)
{

    //
    // Convert the WbemTime value to a SYSTEMTIME value.
    //

    SYSTEMTIME systemTime_Old;

    HRESULT hr = WbemTimeToSystemTime(xbstrOldTime, systemTime_Old);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetMinutesElapsed: WbemTimeToSystemTime failed. hr=0x%08X."), hr));
        return hr;
    }

    //
    // Convert the SYSTEMTIME value to a FILETIME value.
    //

    BOOL bRes;
    FILETIME fileTime_Old;

    bRes = SystemTimeToFileTime(&systemTime_Old, &fileTime_Old);
    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetMinutesElapsed: SystemTimeToFileTime failed. LastError=0x%08X."), dwLastError));
        return E_FAIL;
    }

    unsigned __int64 old = fileTime_Old.dwHighDateTime;
    old <<= 32;
    old |= fileTime_Old.dwLowDateTime;


    //
    // Get the current time in SYSTEMTIME format
    //

    SYSTEMTIME systemTime_Current;
    GetSystemTime(&systemTime_Current);

    //
    // Convert the current time from a SYSTEMTIME to a FILETIME value
    //

    FILETIME fileTime_Current;
    bRes = SystemTimeToFileTime(&systemTime_Current, &fileTime_Current);
    if(!bRes)
    {
        DWORD dwLastError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("GetMinutesElapsed: SystemTimeToFileTime failed. LastError=0x%08X."), dwLastError));
        return E_FAIL;
    }

    //
    // The time passed in as a parameter must precede the current time
    //

    unsigned __int64 current = fileTime_Current.dwHighDateTime;
    current <<= 32;
    current |= fileTime_Current.dwLowDateTime;

    if(old > current)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // We have converted SYSTEMTIMEs to FILETIMEs.
    // "The FILETIME structure is a 64-bit value representing the number
    // of 100-nanosecond intervals since January 1, 1601."
    // Therefore we need to divide by ten million to obtain seconds
    // and by sixty to obtain minutes.
    //

    *pMinutesElapsed = (ULONG) (( current - old ) / (60 * 10 * 1000 * 1000));

    return S_OK;
}


//******************************************************************************
//
// Function:    IsNamespaceStale
//
// Description: Check if namespace is stale Sub-namespaces 'User' and 'Computer' are expected to have
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted. For some failures treat the
//              namespace as garbage-collectable because we don't clean up properly when an error is
//              encountered during the creation of the namespace, and setting up security etc.
//
//
// Parameters:  pChildNamespace -   Pointer to IWbemServices associated with child namespace
//              TTLMinutes -        ULONG variable that represents the maximum number of
//                                  minutes that may have elapsed before a sub-namespace is
//                                  deleted.
//
// Return:      True if namespace is stale, false otherwise
//
//******************************************************************************

BOOL IsNamespaceStale( IWbemServices *pChildNamespace, ULONG TTLMinutes )
{
    //
    // compute TTL
    // To do so compare the "creationTime" data member of class RSOP_Session with
    // the current time. If the time span exceeds the threshold (as found in the
    // registry), the namespace is to be deleted.
    //

    XBStr xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
        return FALSE;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    HRESULT hr = pChildNamespace->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);

    if(FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: GetObject failed. hr=0x%08X"), hr));
        return TRUE;
    }

    XBStr xbstrPropertyName = L"creationTime";
    if(!xbstrPropertyName)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
        return TRUE;
    }

    VARIANT var;
    VariantInit(&var);
    XVariant xVar(&var);

    hr = xpInstance->Get(xbstrPropertyName, 0, &var, NULL, NULL);

    if(FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: Get failed. hr=0x%08X."), hr));
        return TRUE;
    }

    if ( var.vt == VT_NULL )
        return TRUE;

    XBStr xbstrPropertyValue = var.bstrVal;

    if(!xbstrPropertyValue)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
        return FALSE;
    }

    ULONG minutesElapsed = 10;

    hr = GetMinutesElapsed(xbstrPropertyValue, &minutesElapsed);
    if(FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: GetMinutesElapsed failed. hr=0x%08X."), hr));
        return TRUE;
    }

    if(minutesElapsed > TTLMinutes)
        return TRUE;
    else
        return FALSE;
}



//******************************************************************************
//
// Function:    GarbageCollectNamespace
//
// Description: Garabage-collects the namespace passed in as a parameter.
//              If no sub-namespaces are found or if all sub-namespaces
//              are deleted, it deletes the parent namespace as well.
//              It deletes sub-namespaces whose TTL has expired.
//              It computes the TTL from the 'creationTime' data member of the only
//              instance of class RSOP_Session as defined in rsop.mof.
//
//              Any of the sub-namespaces that is older than TTLMinutes will be deleted.
//              If no sub-namespaces are left, then the parent namespace is deleted as well.
//
//              Garbage-collectable are those namespaces which satisfy a set of
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//              Sub-namespaces 'User' and 'Computer' are expected to have an instance of class
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted.
//
//
// Parameters:  bstrNamespace -     Name of the namesapce to garbage collect.
//              pWbemServices -     Pointer to IWbemServices associated with
//                                  the parent of bstrNamespace (root\rsop)
//              TTLMinutes -        ULONG variable that represents the maximum number of
//                                  minutes that may have elapsed before a sub-namespace is
//                                  deleted.
//
// Return:      S_OK on success. An HRESULT error code on failure.
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GarbageCollectNamespace(BSTR bstrNamespace, IWbemServices* pWbemServices, ULONG TTLMinutes)
{
    if(!bstrNamespace || !pWbemServices)
    {
        return E_FAIL;
    }

    //
    // Connect to that namespace and enumerate instances of __namespace.
    // It's assumed that there will be at most 2 namespaces:
    // "User" and "Computer".
    //

    XInterface<IWbemServices> xpParentNamespace;
    HRESULT hr = pWbemServices->OpenNamespace(  bstrNamespace,
                                                0,
                                                NULL,
                                                &xpParentNamespace,
                                                NULL);

    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: OpenNamespace failed. hr=0x%08X"), hr));
        return hr;
    }

    //
    //  Enumerate all instances of __namespace.
    //

    XInterface<IEnumWbemClassObject> xpEnum;
    XBStr xbstrClass = L"__namespace";
    if(!xbstrClass)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory")));
        return E_OUTOFMEMORY;
    }

    hr = xpParentNamespace->CreateInstanceEnum( xbstrClass,
                                                WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                                NULL,
                                                &xpEnum);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: CreateInstanceEnum failed. hr=0x%08X" ), hr ));
        return hr;
    }

    //
    // We re interested in data member "Name" of class __namespace.
    //

    XBStr xbstrProperty = L"Name";
    if(!xbstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory")));
        return E_FAIL;
    }

    //
    // This pointer will be used to iterate through every instance
    // in the enumeration.
    //

    XInterface<IWbemClassObject>xpInstance = NULL;

    ULONG ulReturned = 0;
    long namespacesFound = 0;
    long namespacesDeleted = 0;

    while(1)
    {
        //
        // Retrieve the next instance in the enumeration.
        //

        hr = xpEnum->Next( WBEM_NO_WAIT, 1, &xpInstance, &ulReturned);
        if (hr != WBEM_S_NO_ERROR || !ulReturned)
        {
            //
            // Either the end of the enumeration has been reached or an error
            // ocurred. We will find out outside the loop.
            //

            break;
        }

        namespacesFound++;

        //
        // Get the namespace name.
        //

        VARIANT var;
        VariantInit(&var);

        hr = xpInstance->Get(xbstrProperty, 0L, &var, NULL, NULL);

        //
        // Release the pointer to the current element of the enumeration..
        //

        xpInstance = NULL;

        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Get failed. hr=0x%x" ), hr ));
            return E_FAIL;
        }

        //
        // Use the name of the namespace to connect to it.
        //

        XBStr xbstrChildNamespace = var.bstrVal;
        VariantClear( &var );

        if(!xbstrChildNamespace)
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory" )));
            return E_FAIL;
        }

        XInterface<IWbemServices> xpChildNamespace = NULL;
        hr = xpParentNamespace->OpenNamespace(  xbstrChildNamespace,
                                                0,
                                                NULL,
                                                &xpChildNamespace,
                                                NULL);

        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: OpenNamespace returned 0x%x"), hr));
            return hr;
        }

        BOOL bStale = IsNamespaceStale( xpChildNamespace, TTLMinutes );
        xpChildNamespace = NULL;

        if ( bStale )
        {
            //
            // DeleteInstance
            //

            CWString sNamespaceToDelete = L"__namespace.name=\"";
            sNamespaceToDelete += (WCHAR*)xbstrChildNamespace;
            sNamespaceToDelete += L"\"";

            if(!sNamespaceToDelete.ValidString())
            {
                DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
                return E_OUTOFMEMORY;
            }

            XBStr xbstrInstancePath = sNamespaceToDelete;
            if(!xbstrInstancePath)
            {
                DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
                return E_OUTOFMEMORY;
            }

            hr = xpParentNamespace->DeleteInstance(xbstrInstancePath, 0, NULL, NULL);
            if(FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: DeleteInstance returned 0x%x"), hr));
                return hr;
            }

            DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: Deleted namespace:%ws\\%ws\n"),
                      (WCHAR*)bstrNamespace, (WCHAR*)xbstrChildNamespace ));

            namespacesDeleted++;
        }

    }

    //
    // Check to find out whther the loop was exited because the end of the
    // enumeration was reached or because an error ocurred.
    //

    if(hr != (HRESULT) WBEM_S_FALSE || ulReturned)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Get failed. hr=0x%x" ), hr ));
        return E_FAIL;
    }

    //
    // If no namespaces are found or if namespaces in enumeration
    // equal deleted namespaces delete the parent namespace as well.
    //

    if((!namespacesFound) || (namespacesDeleted == namespacesFound))
    {
        xpParentNamespace = NULL;

        CWString sNamespaceToDelete = L"__namespace.name=\"";
        sNamespaceToDelete += (WCHAR*)bstrNamespace;
        sNamespaceToDelete += L"\"";

        if(!sNamespaceToDelete.ValidString())
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
            return E_OUTOFMEMORY;
        }

        XBStr xbstrInstancePath = sNamespaceToDelete;
        if(!xbstrInstancePath)
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: Failed to allocate memory.")));
            return E_OUTOFMEMORY;
        }

        hr = pWbemServices->DeleteInstance(xbstrInstancePath, 0, NULL, NULL);
        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespace: DeleteInstance returned 0x%x"), hr));
            return hr;
        }

        DebugMsg((DM_VERBOSE, TEXT("GarbageCollectNamespace: Deleted namespace %ws\n"),
                  (WCHAR*)bstrNamespace ));
    }

    return S_OK;
}

//******************************************************************************
//
// Function:    IsGarbageCollectable
//
// Description: Determines whether a namespace is garbage-collectable.
//              Garbage-collectable are those namespaces which satisfy a set of
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//
// Parameters:  bstrNamespace -     BSTR that represents the namespace name.
//
// Return:      'true'  or 'false'.
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

bool IsGarbageCollectable(BSTR bstrNamespace)
{
    if(bstrNamespace && wcslen(bstrNamespace) > 1 &&  _wcsnicmp(bstrNamespace, L"NS", 2) == 0)
    {
        return true;
    }

    return false;
}


//******************************************************************************
//
// Function:    GarbageCollectNamespaces
//
// Description: Iterates through namespaces under root\rsop and for each of those
//              that are determined to be garbage-collectable, it connects to
//              sub-namespaces 'User' and 'Computer'.
//
//              Any of the sub-namespaces that is older than TTLMinutes will be deleted.
//              If no sub-namespaces are left, then the parent namespace is deleted as well.
//
//              Garbage-collectable are those namespaces which satisfy a set of
//              criteria which at the present time is based solely on the naming convention
//              as follows: namespaces under root\rsop whose name starts with "NS"
//
//              Sub-namespaces 'User' and 'Computer' are expected to have an instance of class
//              RSOP_Session. The data member 'creationTime' of that instance is examined when
//              evaluating whether the sub-namespace should be deleted.
//
//
// Parameters:  TTLMinutes -    The maximum number of minutes that may have
//                              elapsed since the creation of a sub-namespace
//
// Return:
//
// History:     12/01/99     leonardm        Created.
//
//******************************************************************************

HRESULT GarbageCollectNamespaces(ULONG TTLMinutes)
{
    XInterface<IWbemLocator> xpWbemLocator = NULL;

    //
    // Connect to namespace ROOT\RSOP
    //

    HRESULT hr = CoCreateInstance(  CLSID_WbemLocator,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IWbemLocator,
                                    (LPVOID*) &xpWbemLocator);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: CoCreateInstance returned 0x%x"), hr));
        return hr;
    }

    XInterface<IWbemServices> xpWbemServices = NULL;

    XBStr xbstrNamespace = L"root\\rsop";

    if(!xbstrNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = xpWbemLocator->ConnectServer(xbstrNamespace,
                                      NULL,
                                      NULL,
                                      0L,
                                      0L,
                                      NULL,
                                      NULL,
                                      &xpWbemServices);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: ConnectServer failed. hr=0x%x" ), hr ));
        return hr;
    }

    //
    //  Enumerate all instances of __namespace at the root\rsop level.
    //

    XInterface<IEnumWbemClassObject> xpEnum;
    XBStr xbstrClass = L"__namespace";
    if(!xbstrClass)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = xpWbemServices->CreateInstanceEnum( xbstrClass,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                            NULL,
                                            &xpEnum);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: CreateInstanceEnum failed. hr=0x%x" ), hr ));
        return hr;
    }

    XBStr xbstrProperty = L"Name";
    if(!xbstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory")));
        return E_FAIL;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    ULONG ulReturned = 1;

    while(1)
    {
        hr = xpEnum->Next( WBEM_NO_WAIT, 1, &xpInstance, &ulReturned);
        if (hr != WBEM_S_NO_ERROR || !ulReturned)
        {
            break;
        }

        VARIANT var;
        VariantInit(&var);

        hr = xpInstance->Get(xbstrProperty, 0L, &var, NULL, NULL);
        xpInstance = NULL;
        if(FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Get failed. hr=0x%x" ), hr ));
            return E_FAIL;
        }

        XBStr xbstrGCNamespace = var.bstrVal;

        VariantClear( &var );

        if(!xbstrGCNamespace)
        {
            DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Failed to allocate memory.")));
            return E_OUTOFMEMORY;
        }

        //
        // For every instance of __namespace under ROOT\RSOP
        // find out whether it is garbage-collectable.
        //

        if(IsGarbageCollectable(xbstrGCNamespace))
        {
            //
            // If it is garbage-collectable, delete it if it
            // was created more than 'TTLMinutes' minutes ago.
            // In case of failure, continue with next namespace
            // in the enumeration.
            //

            GarbageCollectNamespace(xbstrGCNamespace, xpWbemServices, TTLMinutes);
        }
    }

    if(hr != (HRESULT) WBEM_S_FALSE || ulReturned)
    {
        DebugMsg((DM_WARNING, TEXT("GarbageCollectNamespaces: Get failed. hr=0x%x" ), hr ));
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\diagprov.h ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        diagProv.h
//
// Description: Diagnostic mode snapshot provider
//
// History:     8-20-99   leonardm    Created
//
//*************************************************************

#ifndef _SNAPPROV_H__CE49F9FF_5775_4575_9052_C76FBD20AD79__INCLUDED
#define _SNAPPROV_H__CE49F9FF_5775_4575_9052_C76FBD20AD79__INCLUDED

#include <wbemidl.h>
#include "smartptr.h"

#define DENY_RSOP_FROM_INTERACTIVE_USER     L"DenyRsopToInteractiveUser"

extern long g_cObj;
extern long g_cLock;


//*************************************************************
//
// Class:      CNotImplSnapProv
//
// Description:
//
//*************************************************************

class CNotImplSnapProv : public IWbemServices
{
public:

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace(
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall(
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink(
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE GetObject(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutClass(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutClassAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteClass(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync(
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutInstance(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync(
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteInstance(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync(
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync(
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) { return WBEM_E_NOT_SUPPORTED;}

        virtual HRESULT STDMETHODCALLTYPE ExecMethod(
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) { return WBEM_E_NOT_SUPPORTED;}
};


//*************************************************************
//
// Class:       CSnapProv
//
// Description: Actual snapshot provider class
//
//*************************************************************

class CSnapProv : public CNotImplSnapProv, public IWbemProviderInit
{

private:
        long               m_cRef;
        bool               m_bInitialized;
        IWbemServices*     m_pNamespace;

        XBStr              m_xbstrNameSpace;
        XBStr              m_xbstrResult;
        XBStr              m_xbstrExtendedInfo;
        XBStr              m_xbstrClass;
        XBStr              m_xbstrUserSid;
        XBStr              m_xbstrUserSids;
        XBStr              m_xbstrFlags;
        
public:

        CSnapProv();
        ~CSnapProv();

        // From IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // From IWbemProviderInit
        STDMETHOD(Initialize)(LPWSTR pszUser,LONG lFlags,LPWSTR pszNamespace,LPWSTR pszLocale,IWbemServices __RPC_FAR *pNamespace,IWbemContext __RPC_FAR *pCtx,IWbemProviderInitSink __RPC_FAR *pInitSink);

        // From IWbemServices
        STDMETHOD(ExecMethodAsync)( const BSTR strObjectPath,
                                    const BSTR strMethodName,
                                    long lFlags,
                                    IWbemContext __RPC_FAR *pCtx,
                                    IWbemClassObject __RPC_FAR *pInParams,
                                    IWbemObjectSink __RPC_FAR *pResponseHandler);

};

#endif // _SNAPPROV_H__CE49F9FF_5775_4575_9052_C76FBD20AD79__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\diagprov.cpp ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:        diagprov.cpp
//
// Description: Rsop diagnostic mode provider
//
// History:     8-20-99   leonardm    Created
//
//*************************************************************

#include "uenv.h"
#include "diagprov.h"
#include "rsopinc.h"
#include "Indicate.h"
#include "rsopdbg.h"
#include "rsopsec.h"
#include <strsafe.h>

HRESULT EnumerateUserNameSpace( IWbemLocator *pWbemLocator, HANDLE hToken, SAFEARRAY **psaUserSids );

HRESULT UpdateGPCoreStatus(IWbemLocator *pWbemLocator,
                           LPWSTR szSid, LPWSTR szNameSpace);

//*************************************************************
// TranslateNameXForest

DWORD DsNameErrorMap[] = {  ERROR_SUCCESS,
                            ERROR_NO_SUCH_USER,
                            ERROR_NO_SUCH_USER,
                            ERROR_NONE_MAPPED,
                            ERROR_NONE_MAPPED,
                            ERROR_SOME_NOT_MAPPED,
                            ERROR_SOME_NOT_MAPPED
                            };

#define MapDsNameError( x )    ((x < sizeof( DsNameErrorMap ) / sizeof( DWORD ) ) ? \
                                     DsNameErrorMap[ x ] : ERROR_GEN_FAILURE )


extern "C" BOOLEAN TranslateNameXForest (
                  LPTSTR                szDomain,                       // Domain where the name should be resolved
                  LPCTSTR               lpAccountName,                  // object name
                  DS_NAME_FORMAT        AccountNameFormat,              // name format
                  DS_NAME_FORMAT        DesiredNameFormat,              // new name format
                  LPTSTR               *lpTranslatedName                // returned name buffer
                );


//*************************************************************
//
//  GetMachAccountName()
//
//  Purpose:    Gets Machine account name
//
//  Return:     Machine Account
//
//*************************************************************

LPTSTR GetMachAccountName()
{
    return MyGetComputerName(NameSamCompatible);
}


BOOLEAN 
TranslateNameXForest (
                  LPTSTR                szDomain,                       // Domain where the name should be resolved
                  LPCTSTR               lpAccountName,                  // object name
                  DS_NAME_FORMAT        AccountNameFormat,              // name format
                  DS_NAME_FORMAT        DesiredNameFormat,              // new name format
                  LPTSTR               *lpTranslatedName                // returned name buffer
                )
{
    BOOL                        bRetry          = FALSE;
    DWORD                       dwErr;
    PDOMAIN_CONTROLLER_INFO     pDCInfo         = NULL;
    HANDLE                      hDS             = NULL;
    XLastError                  xe;
    PDS_NAME_RESULT             pResult         = NULL;
    BOOLEAN                     bRet            = FALSE;
    XPtrLF<WCHAR>               xszTransName;


    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"MyTranslateName: Resolving name <%s> at Domain <%s>", lpAccountName, szDomain ? szDomain : L"");


    //
    // get a DC and bind to it. Make sure to force rediscover a DC if the bind fails
    //


    for (;;) {
        
        dwErr = DsGetDcName( NULL,
                             szDomain ? szDomain : L"",
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED           |
                                 DS_RETURN_DNS_NAME                  | 
                                 (bRetry ? DS_FORCE_REDISCOVERY : 0) |
                             0,
                             &pDCInfo );

        if (dwErr == NO_ERROR) {
            dwErr = DsBind( pDCInfo->DomainControllerName,
                            NULL,
                            &hDS );

            if (dwErr == NO_ERROR) {
                break;
            }
            else {
                dbg.Msg( DEBUG_MESSAGE_WARNING, L"MyTranslateName: Failed to bind to DC <%s> with error %d", 
                         pDCInfo->DomainControllerName, dwErr );
                NetApiBufferFree(pDCInfo);
                pDCInfo = NULL;
            }

        }
        else {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"MyTranslateName: Failed to get DC for domain <%s> with error %d", 
                     szDomain ? szDomain : L"", dwErr );
        }                                                 



        //
        // Failed to bind to a DC. bail
        //

        if (bRetry) {
            xe = dwErr;
            goto Exit;
        }

        bRetry = TRUE;                          
    }

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"MyTranslateName: DC selected is <%s>", pDCInfo->DomainControllerName);


    //
    // Now crack names with the DC that is bound
    //

    dwErr = DsCrackNames( hDS,
                          DS_NAME_NO_FLAGS,
                          AccountNameFormat,
                          DesiredNameFormat,
                          1,
                          &lpAccountName,
                          &pResult);

    if (dwErr != DS_NAME_NO_ERROR) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MyTranslateName: Failed to crack names with error %d", dwErr );
        xe = dwErr;
        goto Exit;
    }

    if ( pResult->cItems == 0 ) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MyTranslateName: Failed to return enough result items" );
        xe = dwErr = ERROR_INVALID_DATA;
        goto Exit;
    }


    if ( pResult->rItems[0].status == DS_NAME_NO_ERROR ) {
        
        //
        // In case of no error, return the resolved name
        //
        DWORD   dwTransNameLength = 1 + lstrlen(pResult->rItems[0].pName);
        xszTransName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwTransNameLength ));

        if (!xszTransName) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"MyTranslateName: Failed to allocate memory for domain" );
            xe = dwErr = GetLastError();
            goto Exit;
        }

        HRESULT hr = StringCchCopy(xszTransName, dwTransNameLength, pResult->rItems[0].pName);

        if(FAILED(hr)) {
            xe = dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

        *lpTranslatedName = xszTransName.Acquire();
    }
    else {
        
        //
        // remap the error code to win32 error
        //

        xe = dwErr = MapDsNameError(pResult->rItems[0].status);
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"MyTranslateName: DsCrackNames failed with error %d", pResult->rItems[0].status );
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if ( pDCInfo ) {
        NetApiBufferFree(pDCInfo);
    }
    
    if (hDS) {
        DsUnBind( &hDS );
    }

    if (pResult) {
        DsFreeNameResult(pResult);
    }

    return bRet;
}



 
//*************************************************************
//
//  GetSOMFromSID()
//
//  Purpose:    Finds out the FQDN of a given user/computer given the SID
//              It reads from the cache that we have already maintained
//
//  Parameters: szSID       -  User Sid or NULL for machine account
//
//  Return:     SOM, NULL otherwise. GetLastError() for details
//              This just returns the DN of the user
//
//*************************************************************

LPWSTR GetSOMFromSID(LPWSTR szSID)
{
    BOOL                bMachine                    = FALSE;
    HRESULT             hr                          = S_OK;
    XLastError          xe;
    XPtrLF<WCHAR>       xszName;
    XPtrLF<WCHAR>       xszFinalName;
    DWORD               dwError, dwType, dwSize;
    XKey                xhKeyState;
    XPtrLF<WCHAR>       xszKeyState;
    XPtrLF<WCHAR>       xszMachAccount;
    XPtrLF<WCHAR>       xszDomain;
    DWORD               dwKeyStateLength            = lstrlen(GP_STATE_KEY) + lstrlen(szSID ? szSID : L"Machine") + 1;

    xszKeyState = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwKeyStateLength ));

    if (!xszKeyState) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Failed to allocate memory. Error - %d", GetLastError() );
        xe = GetLastError();
        return NULL;
    }

    if ( !szSID )
    {
        bMachine = TRUE;
        hr = StringCchPrintf( xszKeyState, dwKeyStateLength, GP_STATE_KEY, L"Machine" );
    }
    else
    {
        hr = StringCchPrintf( xszKeyState, dwKeyStateLength, GP_STATE_KEY, szSID );
    }

    if (FAILED(hr)) {
        xe = HRESULT_CODE(hr);
        return NULL;
    }

    dwSize = 0;
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            xszKeyState,
                            0,
                            KEY_READ,
                            &xhKeyState );

    if ( dwError != ERROR_SUCCESS )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Failed to open state key for %s. Error - %d", (LPWSTR)xszKeyState, dwError );
        xe = dwError;
        return NULL;
    }

    dwError = RegQueryValueEx(xhKeyState,
                              DN,
                              0,
                              &dwType,
                              NULL,
                              &dwSize );

    if ( dwError != ERROR_SUCCESS )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Failed to get the size of DN value. Error - %d", dwError );
        xe = dwError;
        return NULL;
    }


    xszName = (LPWSTR)LocalAlloc(LPTR, dwSize+2);

    if ( !xszName ) {
        xe = GetLastError();
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Failed to get the size of DN value. Error - %d", GetLastError() );
        return NULL;
    }

    dwError = RegQueryValueEx(xhKeyState,
                              DN,
                              0,
                              &dwType,
                              (LPBYTE)(LPWSTR)xszName,
                              &dwSize );

    if ( dwError != ERROR_SUCCESS )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Failed to get the size of DN value. Error - %d", dwError );
        xe = dwError;
        return NULL;
    }

    if (xszName[0] == L'\0') {
        xe = ERROR_NON_DOMAIN_SID;
        return NULL;
    }
    
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, L"GetSOMFromSID: Som for SID <%s> in registry is %s.", szSID ? szSID : L"Machine", (LPWSTR)xszName );

    
    //
    // Confirming that the SOMs haven't changed since the last time the user was logged on
    // get the domain and requery for the som
    //

    dwError = GetDomain(xszName, &xszDomain);
    if (dwError != ERROR_SUCCESS) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Cannot get the domain from the som path. Error - %d", dwError );
        xe = dwError;
        return NULL;
    }


    if (bMachine) {
        xszMachAccount = GetMachAccountName();

        if (!xszMachAccount) {
            xe = GetLastError();
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Couldn't get the machine account. Error - %d", GetLastError() );
            return NULL;
        }


        if (!TranslateNameXForest( xszDomain, xszMachAccount, DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME, &xszFinalName)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Translate name failed for machine account. Error - %d", GetLastError() );
        }
        else {
            xszName = xszFinalName.Acquire();
        }

    }
    else {
        if (!TranslateNameXForest( xszDomain, szSID, DS_SID_OR_SID_HISTORY_NAME, DS_FQDN_1779_NAME, &xszFinalName)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, L"GetSOMFromSID: Translate name failed for user account. Error - %d", GetLastError() );
        }
        else {
            xszName = xszFinalName.Acquire();
        }
    }

    return xszName.Acquire();
}



//*************************************************************
//
//  CheckRsopDiagPolicyInteractive()
//
//  Purpose: Can this user get the rsop data even if the user is logged 
//           on interactively
//
//  Parameters: 
//
//  Return:     CheckRsopDiagPolicyInteractive
//
//*************************************************************

BOOL CheckRsopDiagPolicyInteractive()
{
    HKEY    hKeyUser = NULL;
    HKEY    hKey;
    DWORD   dwSize = 0, dwType = 0;
    BOOL    bDeny = FALSE;

    HRESULT hr = CoImpersonateClient();
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CheckRsopDiagPolicyInteractive::CoImpersonateClient failed with 0x%x"), hr );
    }
    else if (!RegOpenCurrentUser(KEY_READ, &hKeyUser) == ERROR_SUCCESS)
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CheckRsopDiagPolicyInteractive:: couldn't access registry of interactive user."));
        hKeyUser = NULL;
    }
    CoRevertToSelf();


    //
    // First, check for a user preference
    //

    if (hKeyUser) {
        if (RegOpenKeyEx (hKeyUser, WINLOGON_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bDeny);
            RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                             (LPBYTE) &bDeny, &dwSize);

            RegCloseKey (hKey);
        }
    }


    //
    // Check for a machine preference
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0,
                            KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bDeny);
        RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                         (LPBYTE) &bDeny, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a user policy
    //

    if (hKeyUser) {
        if (RegOpenKeyEx (hKeyUser, SYSTEM_POLICIES_KEY, 0,
                                KEY_READ, &hKey) == ERROR_SUCCESS) {
    
            dwSize = sizeof(bDeny);
            RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                             (LPBYTE) &bDeny, &dwSize);
    
            RegCloseKey (hKey);
        }
    }

    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0,
                            KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bDeny);
        RegQueryValueEx (hKey, DENY_RSOP_FROM_INTERACTIVE_USER, NULL, &dwType,
                         (LPBYTE) &bDeny, &dwSize);

        RegCloseKey (hKey);
    }

    if (hKeyUser) {
        RegCloseKey(hKeyUser);
    }

    return (!bDeny);
}

//*************************************************************
//
// Functions:  Constructor, Destructor, QueryInterface, AddRef, Release
//
//*************************************************************

CSnapProv::CSnapProv()
   :  m_cRef(1),
      m_bInitialized(false),
      m_pNamespace(NULL)
{
    InterlockedIncrement(&g_cObj);

    m_xbstrUserSid = L"userSid";
    if ( !m_xbstrUserSid )
         return;

    m_xbstrUserSids = L"userSids";
    if ( !m_xbstrUserSids )
         return;

    m_xbstrNameSpace = L"nameSpace";
    if ( !m_xbstrNameSpace )
       return;

    m_xbstrResult = L"hResult";
    if ( !m_xbstrResult )
        return;

    m_xbstrFlags = L"flags";
    if ( !m_xbstrFlags )
        return;

    m_xbstrExtendedInfo = L"ExtendedInfo";
    if ( !m_xbstrExtendedInfo )
         return;

    m_xbstrClass = L"RsopLoggingModeProvider";
    if ( !m_xbstrClass )
       return;

    m_bInitialized = TRUE;
}


CSnapProv::~CSnapProv()
{
    if(m_pNamespace != NULL)
    {
        m_pNamespace->Release();
    }

    InterlockedDecrement(&g_cObj);
}

STDMETHODIMP CSnapProv::QueryInterface (REFIID riid, LPVOID* ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemServices)
    {
            *ppv = static_cast<IWbemServices*>(this);
    }
    else if(riid == IID_IWbemProviderInit)
    {
            *ppv = static_cast<IWbemProviderInit*>(this);
    }
    else
    {
            *ppv=NULL;
            return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSnapProv::AddRef()
{
        return InterlockedIncrement( &m_cRef );
}


STDMETHODIMP_(ULONG) CSnapProv::Release()
{
        if (!InterlockedDecrement(&m_cRef))
        {
                delete this;
                return 0;
        }
        return m_cRef;
}

//*************************************************************
//
//  Initialize()
//
//  Purpose:    WbemProvider's initialize method
//
//  Parameters: See IWbemProivderInit::Initialize
//
//  Return:     hresult
//
//*************************************************************

STDMETHODIMP CSnapProv::Initialize( LPWSTR pszUser,
                                    LONG lFlags,
                                    LPWSTR pszNamespace,
                                    LPWSTR pszLocale,
                                    IWbemServices __RPC_FAR *pNamespace,
                                    IWbemContext __RPC_FAR *pCtx,
                                    IWbemProviderInitSink __RPC_FAR *pInitSink)
{
    HRESULT hr;

    if ( !m_bInitialized ) {
        hr = pInitSink->SetStatus(E_FAIL, 0);
        return hr;
    }

    //
    // No need to authenticate user. The ACLs on Rsop namespace will
    // deny access to users that cannot snapshot diagnostic mode data.
    //

    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    hr = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);

    return hr;
}


#if _MSC_FULL_VER <= 13008827 && defined(_M_IX86)
#pragma optimize("", off)
#endif


//*************************************************************
//
//  ExecMethodAsync()
//
//  Purpose:    Execute method
//
//  Parameters: See IWbemServices::ExecMethodAsync
//
//  Return:     hresult
//
//*************************************************************

STDMETHODIMP CSnapProv::ExecMethodAsync( const BSTR bstrObject,
                                         const BSTR bstrMethod,
                                         long lFlags,
                                         IWbemContext __RPC_FAR *pCtx,
                                         IWbemClassObject __RPC_FAR *pInParams,
                                         IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    HRESULT hr;

    CFailRetStatus retStatus( pResponseHandler );
    IUnknown      *pOldSecContext;

    //
    // Make sure the provider is properly initialized
    //

    //
    // Allow for debugging level to be dynamically changed during queries
    //


    dbgRsop.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                     L"RsopDebugLevel",
                     L"userenv.log",
                     L"userenv.bak",
                     FALSE );

    InitDebugSupport(0);

    if ( !m_bInitialized )
    {
        hr = E_OUTOFMEMORY;
        retStatus.SetError( hr );
        return hr;
    }

    //
    // Initialize the return status object to fail status
    //

    IWbemLocator *pWbemLocator = NULL;
    hr = CoCreateInstance( CLSID_WbemAuthenticatedLocator,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemLocator,
                           (LPVOID *) &pWbemLocator );
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync: CoCreateInstance returned 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemLocator> xLocator( pWbemLocator );

    IWbemClassObject* pProvClass = NULL;
    IWbemClassObject* pOutClass = NULL;
    IWbemClassObject* pOutParams = NULL;

    hr = m_pNamespace->GetObject( m_xbstrClass, 0, pCtx, &pProvClass, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetObject failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xProvClass( pProvClass );

    hr = pProvClass->GetMethod( bstrMethod, 0, NULL, &pOutClass);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetMethod failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    XInterface<IWbemClassObject> xOutClass( pOutClass );

    hr = pOutClass->SpawnInstance(0, &pOutParams);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SpawnInstance failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }


    //
    // Get the tokens and Sids upfront
    //
    
    XPtrLF <WCHAR> xszSidString;
    XPtrLF <SID>   xSid;
    XHandle        xUserToken;

    hr = CoImpersonateClient();
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    if (OpenThreadToken (GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &xUserToken)) {
        

        LPWSTR szSid = GetSidString(xUserToken);
        if (!szSid) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetSidString failed with %d"), GetLastError() );
            CoRevertToSelf();
            retStatus.SetError( hr );
            return hr;
        }
        else {
            DWORD szSidStrLength = lstrlen(szSid) + 1;
            xszSidString = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( szSidStrLength ));

            if (!xszSidString) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::LocalAlloc failed with %d"), GetLastError() );
                hr = HRESULT_FROM_WIN32(GetLastError());
                DeleteSidString(szSid);
                CoRevertToSelf();
                retStatus.SetError( hr );
                return hr;
            }

            hr = StringCchCopy(xszSidString, szSidStrLength, szSid);

            if(FAILED(hr)){
                DeleteSidString(szSid);
                CoRevertToSelf();
                retStatus.SetError( hr );
                return hr;
            }

            DeleteSidString(szSid);
        }


        xSid = (SID *)GetUserSid(xUserToken);
        if (!xSid) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::GetUserSid failed with %d"), GetLastError() );
            CoRevertToSelf();
            retStatus.SetError( hr );
            return hr;
        }
    } else {
        hr = HRESULT_FROM_WIN32(GetLastError());
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Openthreadtoken failed with 0x%x"), hr );
        CoRevertToSelf();
        retStatus.SetError( hr );
        return hr;
    }

    CoRevertToSelf();

    
    XInterface<IWbemClassObject> xOutParams( pOutParams );

    if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopDeleteSession" ) == 0 ) {

        //
        // rsopdeletesession
        //

        VARIANT vNameSpace;
        hr = pInParams->Get( m_xbstrNameSpace, 0, &vNameSpace, NULL, NULL);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get machine name failed with 0x%x."), hr );
            retStatus.SetError( hr );
            return hr;
        }
        XVariant xvNameSpace( &vNameSpace );


        if  (vNameSpace.vt != VT_NULL ) {
                
            //
            // We want to run as LS
            //

            hr = CoSwitchCallContext(NULL, &pOldSecContext);

            if (FAILED(hr)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                retStatus.SetError( hr );
                return hr;
            }
            
            hr = ProviderDeleteRsopNameSpace( pWbemLocator, 
                                              vNameSpace.bstrVal,
                                              xUserToken, 
                                              xszSidString, 
                                              SETUP_NS_SM);

            
            IUnknown  *pNewObject;
            HRESULT hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

            if (FAILED(hr2)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
            }
        }
        else {
            hr = E_INVALIDARG;
        }


        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        return hr;
    }
    else if ( _wcsicmp( (WCHAR *) bstrMethod, L"RsopEnumerateUsers" ) == 0 ) 
    {

        //
        // RsopenumerateUsers
        //

        SAFEARRAY    *pArray;

        hr = EnumerateUserNameSpace( pWbemLocator, xUserToken, &pArray );
        
        XSafeArray    xsaUserSids(pArray);        
        
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::EnumerateUserNameSpace failed") );
        }

        VARIANT var;
        var.vt = VT_I4;
        var.lVal = hr;

        hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        var.vt = VT_ARRAY | VT_BSTR;
        var.parray = xsaUserSids;

        hr = pOutParams->Put( m_xbstrUserSids, 0, &var, 0 );
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put sids failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        hr = pResponseHandler->Indicate(1, &pOutParams);
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        return hr;
    }


    //
    // progress indicator.
    // 25% done when we enter the first critical section.
    // 50% done when we enter the second critical section.
    // 100% complete when we copy the namespace.
    //

    CProgressIndicator  Indicator(  pResponseHandler,
                                    (lFlags & WBEM_FLAG_SEND_STATUS) != 0 );

    //
    // 5% done. Hack for UI.
    //

    hr = Indicator.IncrementBy( 5 );

    VARIANT vUserSid;
    hr = pInParams->Get( m_xbstrUserSid, 0, &vUserSid, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get RemoteComputer failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }
    XVariant xvUserSid ( &vUserSid );
    

    VARIANT vFlags;
    VariantInit( &vFlags );
    hr = pInParams->Get( m_xbstrFlags, 0, &vFlags, NULL, NULL);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Get dwFlags failed with 0x%x."), hr );
        retStatus.SetError( hr );
        return hr;
    }

    DWORD dwFlags = vFlags.vt == VT_EMPTY || vFlags.vt == VT_NULL ? 0 : vFlags.ulVal;
    
    //
    // Flags specific to Diagnostic mode provider
    //

    if ((dwFlags & FLAG_NO_USER) && (dwFlags & FLAG_NO_COMPUTER)) {
        hr = WBEM_E_INVALID_PARAMETER;
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Both user and computer are null."));
        retStatus.SetError( hr );
        return hr;
    }


    //
    // We can dump out all the input parameters here later on.
    //

    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::UserSid = <%s>"), vUserSid.vt == VT_NULL ? L"NULL" : vUserSid.bstrVal);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::flags = <%d>"), dwFlags);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::---------------RsopCreateSession::Input Parameters--------------------"));


    //
    // Code for RsopCreateSession method
    //



    XPtrLF<TCHAR> xszMachSOM;
    XPtrLF<TCHAR> xszUserSOM;
    BOOL          bDelegated = FALSE;
    BOOL          bCheckAccess = TRUE;
    DWORD         dwExtendedInfo = 0;


    //
    // Get the machine SOM
    //

    if ( !(dwFlags & FLAG_NO_COMPUTER) ) {

        dwExtendedInfo |= RSOP_COMPUTER_ACCESS_DENIED;

        xszMachSOM = GetSOMFromSID(NULL);

        if (xszMachSOM) {
            dwExtendedInfo &= ~RSOP_COMPUTER_ACCESS_DENIED;
        }
        else {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::No machine SOM. error %d"), GetLastError() );
        }
    }

    //
    // Get the User SOM
    //

    if ( !(dwFlags & FLAG_NO_USER) )  {

        dwExtendedInfo |= RSOP_USER_ACCESS_DENIED;

        xszUserSOM = GetSOMFromSID(vUserSid.vt == VT_NULL ? xszSidString : vUserSid.bstrVal);

        if (xszUserSOM) {
            dwExtendedInfo &= ~RSOP_USER_ACCESS_DENIED;
        }
        else {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::No User SOM. error %d"), GetLastError() );
        }
    }

    // at this point we already know whether to treat the user as delegated or not...
    if (!xszMachSOM && !xszUserSOM)
    {
        bCheckAccess = FALSE;
    }

    //
    // Check access now
    //

    if (bCheckAccess) {
        hr = AuthenticateUser(xUserToken, xszMachSOM, xszUserSOM, TRUE, &dwExtendedInfo);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User is not a delegated admin. Error 0x%x"), hr );
            hr = S_OK;
        }
        else {
            dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User is a delegated admin. Error 0x%x"), hr );
        }
    }

    if ((!(dwExtendedInfo & RSOP_USER_ACCESS_DENIED)) &&
        (!(dwExtendedInfo & RSOP_COMPUTER_ACCESS_DENIED)))
    {
        bDelegated = TRUE;
    }


    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecMethodAsync::Getting policy critical sections"));

    XCriticalPolicySection criticalPolicySectionMACHINE( EnterCriticalPolicySectionEx(TRUE, 40000, ECP_FAIL_ON_WAIT_TIMEOUT) );

    if ( !criticalPolicySectionMACHINE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    //
    // 25% done when we enter the first critical section.
    //

    hr = Indicator.IncrementBy( 20 );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::IncrementBy() failed with 0x%x"), hr );
    }

    
    XCriticalPolicySection criticalPolicySectionUSER( EnterCriticalPolicySectionEx(FALSE, 40000, ECP_FAIL_ON_WAIT_TIMEOUT) );

    if ( !criticalPolicySectionUSER )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::EnterCriticalPolicySection failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }


    //
    // 50% done when we enter the second critical section.
    //
    hr = Indicator.IncrementBy( 25 );
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::IncrementBy() failed with 0x%x"), hr );
    }


    LPWSTR wszNameSpace = 0;

      
    //
    // Impersonate if not delegated
    //

    if (!bDelegated) {
        hr = CoImpersonateClient();
        
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }
    }
    else {

        //
        // We want to run as LS
        //

        hr = CoSwitchCallContext(NULL, &pOldSecContext);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }
    }
    

    XPtrLF<WCHAR> xwszNameSpace;

    DWORD dwNewNameSpaceFlags = SETUP_NS_SM;
    
    dwNewNameSpaceFlags |= (dwFlags & FLAG_NO_USER) ? SETUP_NS_SM_NO_USER : 0;
    dwNewNameSpaceFlags |= (dwFlags & FLAG_NO_COMPUTER) ? SETUP_NS_SM_NO_COMPUTER : 0;



    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::UserSid = <%s>"), vUserSid.vt == VT_NULL ? L"NULL" : vUserSid.bstrVal);
    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User who is running the tool = <%s>"), (LPWSTR)xszSidString);

    hr = SetupNewNameSpace( &xwszNameSpace,
                             0, // namespace on this machine
                             (vUserSid.vt == VT_NULL) ? ((LPWSTR)xszSidString) : vUserSid.bstrVal,
                             xSid,
                             pWbemLocator, 
                             dwNewNameSpaceFlags,
                             &dwExtendedInfo); 

    if (!bDelegated) {
        CoRevertToSelf();
    }
    else {

        //
        // restore call context
        //

        IUnknown  *pNewObject;
        HRESULT hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

        if (FAILED(hr2)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
        }
    }



    if ( FAILED(hr) && !bDelegated)
    {
        dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::SetupNewNameSpace failed with 0x%x"), hr );

        if (IsUserAnInteractiveUser(xUserToken) && CheckRsopDiagPolicyInteractive()) {

            // if the user had permissions on the computer or if the user didn't ask for computer
            // continue

            // clear out the user access denied right in any case.
            dwExtendedInfo &= ~RSOP_USER_ACCESS_DENIED;

            if ( (!(dwExtendedInfo & RSOP_COMPUTER_ACCESS_DENIED)) ||
                   (dwFlags & FLAG_NO_COMPUTER) ) {

                // if the user asked for their own rsop data
                if ( (vUserSid.vt == VT_NULL) || (_wcsicmp(vUserSid.bstrVal, xszSidString) == 0 )) {
    
                    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::SetupNewNameSpace failed. retrying in interactive mode"), hr );
    
    
                    //
                    // We want to run as LS
                    //
    
                    hr = CoSwitchCallContext(NULL, &pOldSecContext);
    
                    if (FAILED(hr)) {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                        retStatus.SetError( hr );
                        return hr;
                    }
                    
                    //
                    // if the namespace is null, get the name of the interactive namespace
                    //
        
                    XPtrLF<WCHAR> xszInteractiveNS;
                      
                    hr = GetInteractiveNameSpace(xszSidString, &xszInteractiveNS);
        
                    if (FAILED(hr)) {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                        retStatus.SetError( hr );
                        return hr;
                    }
    
                    BOOL bContinue=TRUE;
    
                    if (dwFlags & FLAG_FORCE_CREATENAMESPACE) {
                        hr = DeleteRsopNameSpace( xszInteractiveNS, pWbemLocator );
                        // ignore error
                    }
                    else {
                        XInterface<IWbemServices> xWbemServices;
    
                        hr = pWbemLocator->ConnectServer( xszInteractiveNS,
                                                          NULL,
                                                          NULL,
                                                          0L,
                                                          0L,
                                                          NULL,
                                                          NULL,
                                                          &xWbemServices );
    
                        if (SUCCEEDED(hr)) {
                            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Namespace already exists. Failing call"));
                            hr = WBEM_E_ALREADY_EXISTS;
                            dwExtendedInfo = RSOP_TEMPNAMESPACE_EXISTS;
                            bContinue = FALSE;
                        }
                    }
                    
                    if (bContinue) {
                        dwNewNameSpaceFlags |= SETUP_NS_SM_INTERACTIVE;
    
                        hr = SetupNewNameSpace( &xwszNameSpace,
                                                 0, // namespace on this machine
                                                 xszSidString,
                                                 xSid,
                                                 pWbemLocator, 
                                                 dwNewNameSpaceFlags,
                                                 &dwExtendedInfo); 
    
                    }
                    
                    //
                    // restore call context
                    //
    
                    IUnknown  *pNewObject;
                    HRESULT hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);
    
                    if (FAILED(hr2)) {
                        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
                    }
                }
            }
        }
    }


    if (FAILED(hr)) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::SetupNewNameSpace failed with 0x%x"), hr );
    }
    else
    {
        HRESULT hr2;
        VARIANT var;
        //
        // if we managed to get a snapshot, then ignore the extended access denied info
        //

        dwExtendedInfo = 0;


        //
        // We want to run as LS
        //

        hr = CoSwitchCallContext(NULL, &pOldSecContext);

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        if ( !(dwFlags & FLAG_NO_COMPUTER) ) {

            hr = UpdateGPCoreStatus(pWbemLocator, NULL, xwszNameSpace); 
        }

        if ( (SUCCEEDED(hr)) && (!(dwFlags & FLAG_NO_USER)) ) {
            hr = UpdateGPCoreStatus(pWbemLocator, 
                                    vUserSid.vt == VT_NULL ? xszSidString : vUserSid.bstrVal,
                                    xwszNameSpace); 
            
        }

        //
        // restore call context
        //

        IUnknown  *pNewObject;
        hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

        if (FAILED(hr2)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
        }


        //
        // Return the error code if the status cannot be updated..
        //

        if (FAILED(hr)) {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::UpdateGPCoreStatus failed with 0x%x"), hr );
            retStatus.SetError( hr );
            return hr;
        }

        XBStr xbstrNS( xwszNameSpace );
        if ( !xbstrNS )
        {
            hr2 = HRESULT_FROM_WIN32( E_OUTOFMEMORY );
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Memory allocate failed") );
            retStatus.SetError( hr2 );
            return hr2;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xbstrNS;
        hr2 = pOutParams->Put( m_xbstrNameSpace, 0, &var, 0);
        if ( FAILED(hr2) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put namespace failed with 0x%x"), hr );
            retStatus.SetError( hr2 );
            return hr2;
        }
    }


    VARIANT var;
    var.vt = VT_I4;
    var.lVal = hr;

    hr = pOutParams->Put( m_xbstrResult, 0, &var, 0);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    var.lVal = dwExtendedInfo;
    hr = pOutParams->Put( m_xbstrExtendedInfo, 0, &var, 0);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::Put result failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    //
    // 100% complete when we copy the namespace.
    //
    hr = Indicator.SetComplete();
    if ( FAILED( hr ) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecMethodAsync::IncrementBy() failed with 0x%x"), hr );
    }

    hr = pResponseHandler->Indicate(1, &pOutParams);
    if ( FAILED(hr) )
    {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod:: Indicate failed with 0x%x"), hr );
        retStatus.SetError( hr );
        return hr;
    }

    return hr;
}

#if _MSC_FULL_VER <= 13008827 && defined(_M_IX86)
#pragma optimize("", on)
#endif



//*************************************************************
//
//  EnumerateUserNameSpace()
//
//  Purpose:    EnumerateUserNameSpace
//
//  Parameters: 
//          pWbemLocator - Pointer to a locator
//    [out] psaUserSids  - Pointer to User Sids
//
//  Return:     hresult
//
//*************************************************************

typedef struct _UserSidList {
    LPWSTR                  szUserSid; 
     struct _UserSidList   *pNext;
} USERSIDLIST, *PUSERSIDLIST;

HRESULT EnumerateUserNameSpace( IWbemLocator *pWbemLocator, HANDLE hToken, SAFEARRAY **psaUserSids )
{
    USERSIDLIST     SidList = {0,0};
    DWORD           dwNum = 0;
    PUSERSIDLIST    pElem = NULL;
    HRESULT         hr = S_OK;
    DWORD           dwExtendedInfo;
    IUnknown       *pOldSecContext;
    
    //
    // Connect to namespace ROOT\RSOP\User
    //

    *psaUserSids = NULL;
    
    XInterface<IWbemServices>xpWbemServices = NULL;

    XBStr xbstrNamespace = RSOP_NS_DIAG_USERROOT;

    if(!xbstrNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                      NULL,
                                      NULL,
                                      0L,
                                      0L,
                                      NULL,
                                      NULL,
                                      &xpWbemServices);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: ConnectServer failed. hr=0x%x" ), hr ));
        return hr;
    }


    //
    //  Enumerate all instances of __namespace at the root\rsop\user level.
    //

    XInterface<IEnumWbemClassObject> xpEnum;
    XBStr xbstrClass = L"__namespace";
    if(!xbstrClass)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    hr = xpWbemServices->CreateInstanceEnum( xbstrClass,
                                            WBEM_FLAG_SHALLOW | WBEM_FLAG_FORWARD_ONLY,
                                            NULL,
                                            &xpEnum);
    if(FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: CreateInstanceEnum failed. hr=0x%x" ), hr ));
        return hr;
    }

    XBStr xbstrProperty = L"Name";
    if(!xbstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory")));
        return E_FAIL;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    ULONG ulReturned = 1;

    while(1)
    {
        hr = xpEnum->Next( WBEM_NO_WAIT, 1, &xpInstance, &ulReturned);
        if (hr != WBEM_S_NO_ERROR || !ulReturned)
        {
            break;
        }

        VARIANT var;
        VariantInit(&var);

        hr = xpInstance->Get(xbstrProperty, 0L, &var, NULL, NULL);
        xpInstance = NULL;
        if(FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: Get failed. hr=0x%x" ), hr ));
            goto Exit;  // continue
        }


        //
        // Check to see whether user is delegated admin for the user account
        //

        XPtrLF<WCHAR> xszUserSid = (LPWSTR)LocalAlloc(LPTR, (1+lstrlen(var.bstrVal))*sizeof(WCHAR));

        if (!xszUserSid) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: AllocMem failed. hr=0x%x" ), hr ));
            goto Exit;  
        }

        ConvertWMINameToSid(var.bstrVal, xszUserSid);

        //
        // See whether it is a valid Sid
        //

        PSID    pSid = NULL;

        if (AllocateAndInitSidFromString(xszUserSid, &pSid) != STATUS_SUCCESS ) {
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: AllocateAndInitSidFromString - %s is not a valid Sid" ), xszUserSid));
            continue;
        }


        if (!IsValidSid(pSid)) {
            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: %s is not a valid Sid" ), xszUserSid));
            LocalFree(pSid);
            continue;
        }

        LocalFree(pSid);
        

        //
        // First try to connect to the NameSpace
        //

        hr = CoImpersonateClient();
    
        if ( FAILED(hr) )
        {
            dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoImpersonateClient failed with 0x%x"), hr );
            goto Exit;
        }

        XInterface<IWbemServices> xpChildNamespace = NULL;
        hr = xpWbemServices->OpenNamespace(  var.bstrVal,
                                             0,
                                             NULL,
                                             &xpChildNamespace,
                                             NULL);
        
        CoRevertToSelf();

        if(FAILED(hr))
        {
            IUnknown  *pNewObject;
            HRESULT hr2=S_OK;
            BOOL    bDelegated = TRUE;


            DebugMsg((DM_VERBOSE, TEXT("EnumerateUserNameSpace: OpenNamespace returned 0x%x"), hr));

            //
            // Check whether user has access as LS
            // 

            //
            // We want to run as LS
            //

            hr = CoSwitchCallContext(NULL, &pOldSecContext);

            if (FAILED(hr)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr );
                goto Exit;
            }


            XPtrLF<TCHAR> xszUserSOM;
            
            if (bDelegated) {
                xszUserSOM = GetSOMFromSID(xszUserSid);
                if (!xszUserSOM) {
                    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::No User SOM. Probably local account. error %d"), GetLastError() );
                    bDelegated = FALSE;
                }
            }

            //
            // Check access now
            //

            if (bDelegated) {
                hr = AuthenticateUser(hToken, NULL, xszUserSOM, TRUE, &dwExtendedInfo);

                if (FAILED(hr)) {
                    dbg.Msg( DEBUG_MESSAGE_VERBOSE, TEXT("ExecAsyncMethod::User is not a delegated admin. Error 0x%x"), hr );
                    bDelegated = FALSE;
                }
            }
            
            //
            // restore call context
            //

            hr2 = CoSwitchCallContext(pOldSecContext, &pNewObject);

            if (FAILED(hr2)) {
                dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("ExecAsyncMethod::CoSwitchCallContext failed with 0x%x"), hr2 );
            }

            if (!bDelegated) {
                continue;
            }

        }


        //
        // For every instance of __namespace under ROOT\RSOP\user
        // convert it to Sid and return
        //
        
        pElem = (PUSERSIDLIST)LocalAlloc(LPTR, sizeof(USERSIDLIST));        

        if (!pElem) {
            DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Couldn't allocate memory Error = GetLastError()" ), GetLastError()));
            goto Exit;
        }

        
        pElem->szUserSid = xszUserSid.Acquire();

        //
        // Attach to the beginning of the list
        //
        
        pElem->pNext = SidList.pNext;
        SidList.pNext = pElem;
        dwNum++;
        
        VariantClear( &var );

    }


    if(hr != (HRESULT) WBEM_S_FALSE || ulReturned)
    {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Get failed. hr=0x%x" ), hr ));
        hr = E_FAIL;
        goto Exit;
    }

    //
    // Now make the safe array from the list that we got
    //
    
    SAFEARRAYBOUND arrayBound[1];
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwNum;

    *psaUserSids = SafeArrayCreate( VT_BSTR, 1, arrayBound );
    
    if ( *psaUserSids == NULL ) {
        DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: Failed to allocate memory. Error = %d" ), GetLastError() ));
        hr = E_FAIL;
        goto Exit;
    }

    //
    // traverse the list
    //

    DWORD i;
    for (i=0, pElem = SidList.pNext; (i < dwNum); i++, pElem = pElem->pNext) {
        XBStr xbstrUserSid(pElem->szUserSid);

        hr = SafeArrayPutElement( *psaUserSids, (LONG *)&i, xbstrUserSid);

        if(FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("EnumerateUserNameSpace: SafeArrayPutElement failed. Error = 0x%x" ), hr ));
            goto Exit; // free up the SidList
        }
    }
        
    hr = S_OK;

Exit:

    // free
    for (i=0, pElem = SidList.pNext; (i < dwNum); i++ ) {
        if (pElem->szUserSid)
            LocalFree(pElem->szUserSid);

        PUSERSIDLIST pTemp = pElem;

        pElem = pElem->pNext;
        LocalFree(pTemp);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\logger.cpp ===
//*************************************************************
//
//  Resultant set of policy, Logger classes
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "stdio.h"
#include "uenv.h"
#include <wbemcli.h>
#include "reghash.h"
#include "logger.h"
#include "..\rsoputil\wbemtime.h"
#include "SmartPtr.h"
#include "rsopinc.h"
#include <ntdsapi.h>
#include <strsafe.h>

BOOL PrintToString( XPtrST<WCHAR>& xwszValue, WCHAR *wszString,
                    WCHAR *pwszParam1, WCHAR *pwszParam2, DWORD dwParam3 );
BOOL LogTimeProperty( IWbemClassObject *pInstance, BSTR bstrPropName, SYSTEMTIME *pSysTime );
HRESULT LogSecurityGroups( IWbemClassObject *pInstance, BSTR bstrPropName, PTOKEN_GROUPS pTokenGroups );
LPWSTR DsUnquoteDN( LPCWSTR szQDN);

const MAX_LENGTH = 100; // Length of stringized guid

//*************************************************************
//
//  EscapeDNForWMI()
//
//  Purpose:    Convert a quoted/escaped DN to a DN that is escaped per WMI instructions
//              ie. quotes and '\' will be escaped.
//
//*************************************************************

LPWSTR
EscapeDNForWMI( LPCWSTR szQDN )
{
    DWORD   dwError = ERROR_SUCCESS;
    LPCWSTR  lpTmp;
    DWORD   dwUDNLength;


    if (NULL == szQDN)
    {
        return NULL;
    }

    // calculate the size needed for escaping
    dwUDNLength = 1;    // for the terminating null

    lpTmp = szQDN;

    while (*lpTmp)
    {
        if ((*lpTmp == L'\\') || (*lpTmp == L'"'))
        {
            dwUDNLength += 1;
        }

        dwUDNLength += 1;
        lpTmp++;
    }

    XPtrLF<WCHAR>   xszUDN = LocalAlloc( LPTR, ( dwUDNLength ) * sizeof( WCHAR ) );

    if ( !xszUDN )
    {
        return 0;
    }
    
    LPWSTR szEnd = xszUDN;

    while (*szQDN)
    {
        if ((*szQDN == L'\\') || (*szQDN == L'"'))
        {
            *szEnd++ = L'\\';
        }

        *szEnd++ = *szQDN++;
    }

    *szEnd = L'\0';

    return xszUDN.Acquire();
}


//*************************************************************
//
//  CSessionLogger::CSessionLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CSessionLogger::CSessionLogger( IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrTargetName = L"targetName";
    if ( !m_xbstrTargetName )
        return;

    m_xbstrSOM = L"SOM";
    if ( !m_xbstrSOM )
        return;

    m_xbstrSecurityGroups = L"SecurityGroups";
    if ( !m_xbstrSecurityGroups )
        return;

    m_xbstrSite = L"Site";
    if ( !m_xbstrSite )
        return;

    m_xbstrCreationTime = L"creationTime";
    if ( !m_xbstrCreationTime )
        return;

    m_xbstrIsSlowLink = L"slowLink";
    if ( !m_xbstrIsSlowLink )
        return;

    m_xbstrVersion = L"version";
    if ( !m_xbstrVersion )
        return;

    m_xbstrFlags = L"flags";
    if ( !m_xbstrFlags )
        return;

    m_xbstrClass = L"RSOP_Session";
    if ( !m_xbstrClass )
        return;


    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::CSessionLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CSessionLogger::Log()
//
//  Purpose:    Logs an instance of session object
//
//*************************************************************

BOOL CSessionLogger::Log(LPRSOPSESSIONDATA lprsopSessionData )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }


    //
    // First get the creation time
    //

    XBStr xbstrCreationTimeValue; // initialised to null
    XSafeArray xsaSecurityGrps;

    XBStr xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory.")));
        return FALSE;
    }

    XInterface<IWbemClassObject>xpInstance = NULL;
    HRESULT hr = m_pWbemServices->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);

    if(SUCCEEDED(hr))
    {
        VARIANT var;
        VariantInit(&var);
        XVariant xVar(&var);

        hr = xpInstance->Get(m_xbstrCreationTime, 0, &var, NULL, NULL);

        if((SUCCEEDED(hr)) && ( var.vt != VT_NULL ))
        {
            xbstrCreationTimeValue = var.bstrVal;

            if(!xbstrCreationTimeValue)
                return FALSE;
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed. hr=0x%08X."), hr));
        }

        VariantClear(&var);

        hr = xpInstance->Get(m_xbstrSecurityGroups, 0, &var, NULL, NULL);

        if((SUCCEEDED(hr)) && ( var.vt != VT_NULL ))
        {
             hr = SafeArrayCopy(var.parray, &xsaSecurityGrps);
             if (FAILED(hr)) 
             {
                 DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: SafeArrayCopy failed. hr=0x%08X."), hr));
                 xsaSecurityGrps = NULL;
             }
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed. hr=0x%08X."), hr));
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: GetObject failed. hr=0x%08X"), hr));
    }

    IWbemClassObject *pInstance = NULL;

    hr = m_xClass->SpawnInstance( 0, &pInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );

    XBStr xId( L"Session1" );
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = xId;
    hr = pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // Version
    //

    var.vt = VT_I4;
    var.lVal = RSOP_MOF_SCHEMA_VERSION;
    hr = pInstance->Put( m_xbstrVersion, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // flags
    //

    var.vt = VT_I4;
    var.lVal = lprsopSessionData->dwFlags;
    hr = pInstance->Put( m_xbstrFlags, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // IsSlowLink
    //

    var.vt = VT_BOOL;
    var.boolVal = lprsopSessionData->bSlowLink ? VARIANT_TRUE : VARIANT_FALSE;
    hr = pInstance->Put( m_xbstrIsSlowLink, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // Target Name, can be null for dummy user in planning mode
    //

    XBStr xTarget( lprsopSessionData->pwszTargetName );
    if ( lprsopSessionData->pwszTargetName ) {

        if ( !xTarget ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
            return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xTarget;
        hr = pInstance->Put( m_xbstrTargetName, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }

    }

    //
    // SOM, if Applicable (non NULL)
    //

    XBStr xSOM( lprsopSessionData->pwszSOM );

    if (lprsopSessionData->pwszSOM) {

        if ( !xSOM ) {
             DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
            return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xSOM;
        hr = pInstance->Put( m_xbstrSOM, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }
    else {
         DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: new SOM is NULL")));
    }


    //
    // Security Group, if Applicable (non NULL)
    //


    if (lprsopSessionData->bLogSecurityGroup) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: logging new security grps" )));

        hr = LogSecurityGroups(pInstance, m_xbstrSecurityGroups, lprsopSessionData->pSecurityGroups);
    }
    else {

        if ( lprsopSessionData->pSecurityGroups && !xsaSecurityGrps ) {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: logging new security grps because it wasn't defined before" )));
            hr = LogSecurityGroups(pInstance, m_xbstrSecurityGroups, lprsopSessionData->pSecurityGroups);
        }
        else {
            
            //
            // reset the old value
            //
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: restoring old security grps" )));

            var.vt = VT_ARRAY | VT_BSTR;
            var.parray = (SAFEARRAY *)xsaSecurityGrps;
            hr = pInstance->Put( m_xbstrSecurityGroups, 0, &var, 0 );
        }
    }

    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    //
    // Site, if Applicable (non NULL)
    //

    XBStr xSite( lprsopSessionData->pwszSite );

    if (lprsopSessionData->pwszSite) {

        if ( !xSite ) {
             DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Failed to allocate memory" )));
            return FALSE;
        }

        var.vt = VT_BSTR;
        var.bstrVal = xSite;
        hr = pInstance->Put( m_xbstrSite, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }
    else {
         DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: new Site is NULL")));
    }


    //
    // Update or set the creation Time
    //

    SYSTEMTIME sysTime;

    if (xbstrCreationTimeValue) {
        var.vt = VT_BSTR;
        var.bstrVal = xbstrCreationTimeValue;

        hr = pInstance->Put( m_xbstrCreationTime, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: Put failed for creationtime with 0x%x" ), hr ));
            return FALSE;
        }
    }
    else {

        // if it doesn't exist already create it as current time..
        GetSystemTime(&sysTime);
        if ( !LogTimeProperty( pInstance, m_xbstrCreationTime, &sysTime ))
        {
            DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: LogTimeProperty failed with 0x%x" )));
            return FALSE;
        }
    }


    //
    // Instantiate...
    //

    hr = m_pWbemServices->PutInstance( pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}




//*************************************************************
//
//  CSomLogger::CSOMLogger()
//
//  Purpose:    Constructor
//
//  Parameters: dwFlags       - Flags
//              pWbemServices - Wbem services
//
//*************************************************************

CSOMLogger::CSOMLogger( DWORD dwFlags, IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_dwFlags(dwFlags),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrType = L"type";
    if ( !m_xbstrType )
        return;

    m_xbstrOrder = L"SOMOrder";
    if ( !m_xbstrOrder )
        return;

    m_xbstrBlocking = L"blocking";
    if ( !m_xbstrBlocking )
        return;


    m_xbstrBlocked = L"blocked";
    if ( !m_xbstrBlocked )
        return;

    
    m_xbstrReason = L"reason";
    if ( !m_xbstrReason )
        return;

    m_xbstrClass = L"RSOP_SOM";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::CSOMLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    hr = m_xClass->SpawnInstance( 0, &m_pInstance );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::CSOMLogger: SpawnInstance failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CSomLogger::Log()
//
//  Purpose:    Logs an instance of scope of management
//
//  Parameters: pSOM  - SOM to log
//
//*************************************************************

BOOL CSOMLogger::Log( SCOPEOFMGMT *pSOM, DWORD dwOrder, BOOL bLoopback )
{
    if ( !m_bInitialized )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    HRESULT hr;
    VARIANT var;

    var.vt = VT_I4;
    var.lVal = pSOM->dwType;
    hr = m_pInstance->Put( m_xbstrType, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.lVal = dwOrder;
    hr = m_pInstance->Put( m_xbstrOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_BOOL;
    var.boolVal = pSOM->bBlocking ? VARIANT_TRUE : VARIANT_FALSE;

    hr = m_pInstance->Put( m_xbstrBlocking, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_BOOL;
    var.boolVal = pSOM->bBlocked ? VARIANT_TRUE : VARIANT_FALSE;

    hr = m_pInstance->Put( m_xbstrBlocked, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = bLoopback ? 2 : 1;

    hr = m_pInstance->Put( m_xbstrReason, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XPtrLF<WCHAR> xDSPath = EscapeDNForWMI( pSOM->pwszSOMId );
    XBStr xId;

    if ( !xDSPath )
    {
        xId = pSOM->pwszSOMId;
    }
    else
    {
        xId = xDSPath;
    }
    
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xId;
    hr = m_pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CSOMLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CGpoLogger::CGpoLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CGpoLogger::CGpoLogger( DWORD dwFlags, IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_dwFlags(dwFlags),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrGuidName = L"guidName";
    if ( !m_xbstrGuidName )
        return;

    m_xbstrDisplayName = L"name";
    if ( !m_xbstrDisplayName )
        return;

    m_xbstrFileSysPath = L"fileSystemPath";
    if ( !m_xbstrFileSysPath )
        return;

    m_xbstrVer = L"version";
    if ( !m_xbstrVer )
        return;

    m_xbstrAccessDenied = L"accessDenied";
    if ( !m_xbstrAccessDenied )
        return;

    m_xbstrEnabled = L"enabled";
    if ( !m_xbstrEnabled )
        return;

    m_xbstrSD = L"securityDescriptor";
    if ( !m_xbstrSD )
        return;

    m_xbstrFilterAllowed = L"filterAllowed";
    if ( !m_xbstrFilterAllowed )
        return;

    m_xbstrFilterId = L"filterId";
    if ( !m_xbstrFilterId )
        return;

    m_xbstrClass = L"RSOP_GPO";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::CGpoLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    hr = m_xClass->SpawnInstance( 0, &m_pInstance );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::CGpoLogger: SpawnInstance failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}


//*************************************************************
//
//  CGpoLogger::Log()
//
//  Purpose:    Logs an instance of scope of management
//
//  Parameters: pGpContainer  - Gp container
//
//*************************************************************

BOOL CGpoLogger::Log( GPCONTAINER *pGpContainer )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    HRESULT hr;
    VARIANT var;

    var.vt = VT_I4;
    if ( m_dwFlags & GP_MACHINE )
        var.lVal = pGpContainer->dwMachVersion;
    else
        var.lVal = pGpContainer->dwUserVersion;

    hr = m_pInstance->Put( m_xbstrVer, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    //
    // Note the change from disabled <--> enabled
    //

    var.vt = VT_BOOL;
    if ( m_dwFlags & GP_MACHINE )
        var.boolVal = pGpContainer->bMachDisabled ? VARIANT_FALSE : VARIANT_TRUE;
    else
        var.boolVal = pGpContainer->bUserDisabled ? VARIANT_FALSE : VARIANT_TRUE;

    hr = m_pInstance->Put( m_xbstrEnabled, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.boolVal = pGpContainer->bAccessDenied ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrAccessDenied, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.boolVal = pGpContainer->bFilterAllowed ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrFilterAllowed, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xFilterId( pGpContainer->pwszFilterId != NULL ? pGpContainer->pwszFilterId : L"");
    if ( !xFilterId ) {
         DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xFilterId;
    hr = m_pInstance->Put( m_xbstrFilterId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xId = pGpContainer->pwszDSPath;
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xId;
    hr = m_pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xGuid( pGpContainer->pwszGPOName );
    if ( !xGuid ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xGuid;
    hr = m_pInstance->Put( m_xbstrGuidName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xDisplay( pGpContainer->pwszDisplayName );
    if ( !xDisplay ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xDisplay;
    hr = m_pInstance->Put( m_xbstrDisplayName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xFile( pGpContainer->pwszFileSysPath );
    if ( !xFile ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xFile;
    hr = m_pInstance->Put( m_xbstrFileSysPath, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( !LogBlobProperty( m_pInstance, m_xbstrSD,
                           (BYTE *) pGpContainer->pSD, pGpContainer->cbSDLen ) ) {
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpoLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CGpLinkLogger::CGpLinkLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CGpLinkLogger::CGpLinkLogger( IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_pWbemServices(pWbemServices)
{
    m_xbstrSOM = L"SOM";
    if ( !m_xbstrSOM )
        return;

    m_xbstrGPO = L"GPO";
    if ( !m_xbstrGPO )
        return;

    m_xbstrOrder = L"somOrder";
    if ( !m_xbstrOrder )
        return;

    m_xbstrLinkOrder = L"linkOrder";
    if ( !m_xbstrLinkOrder )
        return;

    m_xbstrAppliedOrder = L"appliedOrder";
    if ( !m_xbstrAppliedOrder )
        return;

    m_xbstrEnabled = L"Enabled";
    if ( !m_xbstrEnabled )
        return;

    m_xbstrEnforced = L"noOverride";
    if ( !m_xbstrEnforced )
        return;

    m_xbstrClass = L"RSOP_GPLink";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::CGpLinkLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    hr = m_xClass->SpawnInstance( 0, &m_pInstance );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::CGpLinkLogger: SpawnInstance failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CGpLinkLogger::Log()
//
//  Purpose:    Logs an instance of scope of management
//
//  Parameters: pwszSOMID   - SOM that the Gpos are linked to
//              pGpLink     - Gpo
//              dwOrder     - Order of Gpo in SOM
//
//*************************************************************

BOOL CGpLinkLogger::Log( WCHAR *pwszSOMId, BOOL bLoopback, GPLINK *pGpLink, DWORD dwSomOrder,
                         DWORD dwLinkOrder, DWORD dwAppliedOrder )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    VARIANT var;
    HRESULT hr;

    var.vt = VT_I4;
    var.lVal = dwSomOrder;
    hr = m_pInstance->Put( m_xbstrOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = dwLinkOrder;
    hr = m_pInstance->Put( m_xbstrLinkOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = dwAppliedOrder;
    hr = m_pInstance->Put( m_xbstrAppliedOrder, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.vt = VT_BOOL;
    var.boolVal = pGpLink->bEnabled ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrEnabled, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    var.boolVal = pGpLink->bNoOverride ? VARIANT_TRUE : VARIANT_FALSE;
    hr = m_pInstance->Put( m_xbstrEnforced, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XPtrLF<WCHAR> szUnquote = EscapeDNForWMI( pwszSOMId );
    XPtrLF<WCHAR> szUqEsc = EscapeDNForWMI( szUnquote);
    WCHAR wszSOMRef[] = L"RSOP_SOM.id=\"%ws\",reason=%s";
    XPtrST<WCHAR> xwszSOMValue;

    if (szUqEsc)
    {
        if ( !PrintToString( xwszSOMValue, wszSOMRef, szUqEsc, bLoopback ? L"2" : L"1", 0 ) )
            return FALSE;
    }
    else
    {
        if ( !PrintToString( xwszSOMValue, wszSOMRef, pwszSOMId, bLoopback ? L"2" : L"1", 0 ) )
            return FALSE;
    }

    XBStr xbstrSOMValue( xwszSOMValue );
    if ( !xbstrSOMValue ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xbstrSOMValue;
    hr = m_pInstance->Put( m_xbstrSOM, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR wszGPORef[] = L"RSOP_GPO.id=\"%ws\"";
    XPtrST<WCHAR> xwszGPOValue;
    
    if ( !PrintToString( xwszGPOValue, wszGPORef, pGpLink->pwszGPO, 0, 0 ) )
        return FALSE;

    XBStr xbstrGPOValue( xwszGPOValue );
    if ( !xbstrGPOValue ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Failed to allocate memory" )));
        return FALSE;
    }

    var.bstrVal = xbstrGPOValue;

    hr = m_pInstance->Put( m_xbstrGPO, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( m_pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  StripPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to Gpo
//
//  Parameters: lpGPOInfo     - Gpo Info
//              pWbemServices - Wbem services
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripPrefix( WCHAR *pwszPath )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Gpo
    //

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iUserPrefixLen;
    } else if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iMachPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}


//*************************************************************
//
//  StripLinkPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to DS
//              object
//
//  Parameters: pwszPath - path to strip
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripLinkPrefix( WCHAR *pwszPath )
{
    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}



//*************************************************************
//
//  CRegistryLogger::CRegistryLogger()
//
//  Purpose:    Constructor
//
//  Parameters: dwFlags       - Flags
//              pWbemServices - Wbem services
//
//*************************************************************

CRegistryLogger::CRegistryLogger( DWORD dwFlags, IWbemServices *pWbemServices )
     : m_bInitialized(FALSE),
       m_dwFlags(dwFlags),
       m_pWbemServices(pWbemServices)
{
    m_xbstrId = L"id";
    if ( !m_xbstrId )
        return;

    m_xbstrName = L"name";
    if ( !m_xbstrName )
        return;

    m_xbstrGPO = L"GPOID";
    if ( !m_xbstrGPO )
        return;

    m_xbstrSOM = L"SOMID";
    if ( !m_xbstrSOM )
        return;

    m_xbstrPrecedence = L"precedence";
    if ( !m_xbstrPrecedence )
        return;

    m_xbstrKey = L"registryKey";
    if ( !m_xbstrKey )
        return;

    m_xbstrValueName = L"valueName";
    if ( !m_xbstrValueName )
        return;

    m_xbstrDeleted = L"deleted";
    if ( !m_xbstrDeleted )
        return;

    m_xbstrValueType = L"valueType";
    if ( !m_xbstrValueType )
        return;

    m_xbstrValue = L"value";
    if ( !m_xbstrValue )
        return;

    m_xbstrCommand = L"command";
    if ( !m_xbstrCommand )
        return;

    m_xbstrClass = L"RSOP_RegistryPolicySetting";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CGpLinkListLogger::CGpLinkListLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CRegistryLogger::Log()
//
//  Purpose:    Logs an instance of registry policy object
//
//  Parameters: pwszKeyName   - Registry key name
//              pwszValueName - Value name
//              pDataEntry    - Data entry
//              dwOrder       - Precedence order
//
//*************************************************************

BOOL CRegistryLogger::Log( WCHAR *pwszKeyName, WCHAR *pwszValueName,
                           REGDATAENTRY *pDataEntry, DWORD dwOrder )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    IWbemClassObject *pInstance = NULL;

    HRESULT hr = m_xClass->SpawnInstance( 0, &pInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = dwOrder;
    hr = pInstance->Put( m_xbstrPrecedence, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( pDataEntry->bDeleted ) {
        var.vt = VT_BOOL;
        var.boolVal = VARIANT_TRUE;
        hr = pInstance->Put( m_xbstrDeleted, 0, &var, 0 );
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
            return FALSE;
        }
    }

    XBStr xName( pwszValueName );
    if ( !xName ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.vt = VT_BSTR;
    var.bstrVal = xName;
    hr = pInstance->Put( m_xbstrName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = pInstance->Put( m_xbstrValueName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xKey( pwszKeyName );
    if ( !xKey ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xKey;
    hr = pInstance->Put( m_xbstrKey, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR *pwszPath = StripPrefix( pDataEntry->pwszGPO );

    XBStr xGPO( pwszPath );
    if ( !xGPO ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xGPO;
    hr = pInstance->Put( m_xbstrGPO, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR *pwszSomPath = StripLinkPrefix( pDataEntry->pwszSOM );

    XBStr xSOM( pwszSomPath );
    if ( !xSOM ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xSOM;
    hr = pInstance->Put( m_xbstrSOM, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    XBStr xCommand( pDataEntry->pwszCommand );
    if ( !xCommand ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xCommand;
    hr = pInstance->Put( m_xbstrCommand, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR wszId[MAX_LENGTH];
    GUID guid;

    OLE32_API *pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL )
        return FALSE;

    hr = pOle32Api->pfnCoCreateGuid( &guid );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to obtain guid" )));
        return FALSE;
    }

    GuidToString( &guid, wszId );

    XBStr xId( wszId );
    if ( !xId ) {
         DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xId;
    hr = pInstance->Put( m_xbstrId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    if ( !LogBlobProperty( pInstance, m_xbstrValue,
                           pDataEntry->pData, pDataEntry->dwDataLen ) ) {
        return FALSE;
    }

    var.vt = VT_I4;
    var.lVal = pDataEntry->dwValueType;
    hr = pInstance->Put( m_xbstrValueType, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CRegistryLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  LogSecurityGroups
//
//  Purpose:    Logs token_groups as an array of strings
//
//*************************************************************

HRESULT LogSecurityGroups( IWbemClassObject *pInstance, BSTR bstrPropName, PTOKEN_GROUPS pTokenGroups )
{
    SAFEARRAYBOUND arrayBound[1];
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = pTokenGroups->GroupCount;
    HRESULT hr;
    NTSTATUS ntStatus;
    UNICODE_STRING unicodeStr;

    XSafeArray xSafeArray = SafeArrayCreate( VT_BSTR, 1, arrayBound );
    if ( xSafeArray == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: Failed to allocate memory" )));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    for ( DWORD i = 0 ; i < (pTokenGroups->GroupCount) ; i++ )
    {
        //
        // Convert user SID to a string.
        //

        ntStatus = RtlConvertSidToUnicodeString( &unicodeStr,
                                                 pTokenGroups->Groups[i].Sid,
                                                 (BOOLEAN)TRUE ); // Allocate
        if ( !NT_SUCCESS(ntStatus) ) {
            DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                      ntStatus));
            return HRESULT_FROM_NT(ntStatus);
        }

        XBStr xbstrSid(unicodeStr.Buffer);

        RtlFreeUnicodeString( &unicodeStr );

        hr = SafeArrayPutElement( xSafeArray, (long *)&i, xbstrSid );
        if ( FAILED( hr ) ) 
        {
            DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: Failed to SafeArrayPutElement with 0x%x" ), hr ));
            return hr;
        }
    }
    
    VARIANT var;
    var.vt = VT_ARRAY | VT_BSTR;
    var.parray = xSafeArray;

    hr = pInstance->Put( bstrPropName, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("LogSecurityGroups: PutInstance failed with 0x%x" ), hr ));
        return hr;
    }

    return S_OK;

}

//*************************************************************
//
//  CRegistryLogger::LogBlobProperty()
//
//  Purpose:    Logs an instance of registry policy object
//
//  Parameters: pwszKeyName   - Registry key name
//              pwszValueName - Value name
//              pDataEntry    - Data entry
//              dwOrder       - Precedence order
//
//*************************************************************

BOOL LogBlobProperty( IWbemClassObject *pInstance, BSTR bstrPropName, BYTE *pbBlob, DWORD dwLen )
{
    SAFEARRAYBOUND arrayBound[1];
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwLen;
    HRESULT hr;

    XSafeArray xSafeArray = SafeArrayCreate( VT_UI1, 1, arrayBound );
    if ( xSafeArray == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("LogBlobProperty: Failed to allocate memory" )));
        return FALSE;
    }

    for ( DWORD i = 0 ; i < dwLen ; i++ )
    {
        hr = SafeArrayPutElement( xSafeArray, (long *)&i, &pbBlob[i] );
        if ( FAILED( hr ) ) 
        {
            DebugMsg((DM_WARNING, TEXT("LogBlobProperty: Failed to SafeArrayPutElement with 0x%x" ), hr ));
            return FALSE;
        }
    }
    
    VARIANT var;
    var.vt = VT_ARRAY | VT_UI1;
    var.parray = xSafeArray;

    hr = pInstance->Put( bstrPropName, 0, &var, 0 );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("LogBlobProperty: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  CAdmFileLogger::CAdmFileLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CAdmFileLogger::CAdmFileLogger( IWbemServices *pWbemServices )
    : m_bInitialized(FALSE),
      m_pWbemServices(pWbemServices)
{
    m_xbstrName = L"name";
    if ( !m_xbstrName )
        return;

    m_xbstrGpoId = L"GPOID";
    if ( !m_xbstrGpoId )
        return;

    m_xbstrWriteTime = L"lastWriteTime";
    if ( !m_xbstrWriteTime )
        return;

    m_xbstrData = L"data";
    if ( !m_xbstrData )
        return;

    m_xbstrClass = L"RSOP_AdministrativeTemplateFile";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::CAdmFileLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CAdmFileLogger::Log()
//
//  Purpose:    Logs an instance of Adm file object
//
//  Parameters: pAdmInfo  -  Adm file info object
//
//*************************************************************

BOOL CAdmFileLogger::Log( ADMFILEINFO *pAdmInfo )
{
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("CAdmFileLogger::Log: Logging %s" ), pAdmInfo->pwszFile));
    IWbemClassObject *pInstance = NULL;

    HRESULT hr = m_xClass->SpawnInstance( 0, &pInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IWbemClassObject> xInstance( pInstance );

    XBStr xName( pAdmInfo->pwszFile );
    if ( !xName ) {
         DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }



    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xName;
    hr = pInstance->Put( m_xbstrName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    WCHAR *pwszPath = StripPrefix( pAdmInfo->pwszGPO );

    XBStr xGPO( pwszPath );
    if ( !xGPO ) {
         DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    var.bstrVal = xGPO;
    hr = pInstance->Put( m_xbstrGpoId, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmFileLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    SYSTEMTIME sysTime;
    if ( !FileTimeToSystemTime( &pAdmInfo->ftWrite, &sysTime ) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmPolicyLogger::Log: FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
        return FALSE;
    }

    if ( !LogTimeProperty( pInstance, m_xbstrWriteTime, &sysTime ) ) {
        return FALSE;
    }

    hr = m_pWbemServices->PutInstance( pInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CAdmPolicyLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  LogTimeProperty()
//
//  Purpose:    Logs an instance of a datetime property
//
//  Parameters: pInstance     - Instance pointer
//              pwszPropName  - Property name
//              pSysTime      - System time
//
//*************************************************************

BOOL LogTimeProperty( IWbemClassObject *pInstance, BSTR bstrPropName, SYSTEMTIME *pSysTime )
{
    if(!pInstance || !bstrPropName || !pSysTime)
    {
        DebugMsg((DM_WARNING, TEXT("LogTimeProperty: Function called with invalid parameters.")));
        return FALSE;
    }

    XBStr xbstrTime;

    HRESULT hr = SystemTimeToWbemTime(*pSysTime, xbstrTime);

    if(FAILED(hr) || !xbstrTime)
    {
        DebugMsg((DM_WARNING, TEXT("LogTimeProperty: Call to SystemTimeToWbemTime failed. hr=0x%08X"),hr));
        return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xbstrTime;
    hr = pInstance->Put( bstrPropName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("LogTimeProperty: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}



//*************************************************************
//
//  CExtSessionLogger::CExtSessionLogger()
//
//  Purpose:    Constructor
//
//  Parameters: pWbemServices - Wbem services
//
//*************************************************************

CExtSessionLogger::CExtSessionLogger( IWbemServices *pWbemServices )
    : m_bInitialized(FALSE),
      m_pWbemServices(pWbemServices)
{
    m_xbstrExtGuid = L"extensionGuid";
    if ( !m_xbstrExtGuid )
        return;

    m_xbstrDisplayName = L"displayName";
    if ( !m_xbstrDisplayName )
        return;

    m_xbstrPolicyBeginTime = L"beginTime";
    if ( !m_xbstrPolicyBeginTime )
        return;

    m_xbstrPolicyEndTime = L"endTime";
    if ( !m_xbstrPolicyEndTime )
        return;

    m_xbstrStatus = L"loggingStatus";
    if ( !m_xbstrStatus )
        return;

    m_xbstrError = L"error";
    if ( !m_xbstrError )
        return;

    m_xbstrClass = L"RSOP_ExtensionStatus";
    if ( !m_xbstrClass )
        return;

    HRESULT hr = m_pWbemServices->GetObject( m_xbstrClass,
                                             0L,
                                             NULL,
                                             &m_xClass,
                                             NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::CExtSessionLogger: GetObject failed with 0x%x" ), hr ));
        return;
    }

    if ( 0 == LoadString (g_hDllInstance, IDS_GPCORE_NAME, m_szGPCoreNameBuf, ARRAYSIZE(m_szGPCoreNameBuf) - 1) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::CExtSessionLogger: LoadString for GP Core Name failed with 0x%x" ), GetLastError() ));
        return;
    }

    m_bInitialized = TRUE;
}



//*************************************************************
//
//  CExtSessionLogger::Log()
//
//  Purpose:    Logs an instance of ExtensionSessionStatus
//
//*************************************************************

#define EXT_INSTPATH_FMT L"RSOP_ExtensionStatus.extensionGuid=\"%s\""

BOOL CExtSessionLogger::Log( LPGPEXT lpExt, BOOL bSupported )
{
    LPTSTR lpGuid=NULL, lpName=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpExt ? lpExt->lpKeyName : GPCORE_GUID;
    lpName = lpExt ? lpExt->lpDisplayName : m_szGPCoreNameBuf;

    XInterface<IWbemClassObject>xInstance = NULL;
    XBStr xDisplayName;

    hr = m_xClass->SpawnInstance( 0, &xInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    xDisplayName = lpName;
    if ( !xDisplayName ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    XBStr xGuid ( lpGuid );
    if ( !xGuid ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xGuid;
    hr = xInstance->Put( m_xbstrExtGuid, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.bstrVal = xDisplayName;
    hr = xInstance->Put( m_xbstrDisplayName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    if ( !LogTimeProperty( xInstance, m_xbstrPolicyBeginTime, &sysTime ) )
    {
        return FALSE;
    }
    
    var.vt = VT_I4;
    var.lVal = bSupported ? 2 : 3;

    hr = xInstance->Put( m_xbstrStatus, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.vt = VT_I4;
    var.lVal = 0;

    hr = xInstance->Put( m_xbstrError, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  CExtSessionLogger::Update()
//
//  Purpose:    Logs an instance of ExtensionSessionStatus
//
//*************************************************************

BOOL CExtSessionLogger::Update( LPTSTR lpKeyName, BOOL bLoggingIncomplete, DWORD dwErr )
{
    LPTSTR lpGuid=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpKeyName ? lpKeyName : GPCORE_GUID;

    XInterface<IWbemClassObject>xInstance = NULL;
    
    //
    // We should have an instance
    //

    DWORD         dwInstPathLength = lstrlen(EXT_INSTPATH_FMT) + lstrlen(lpGuid) + 10;
    XPtrLF<TCHAR> xszInstPath = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR) * ( dwInstPathLength ));

    if (!xszInstPath) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Not enough memory." )));
        return FALSE;
    }

    hr = StringCchPrintf(xszInstPath, dwInstPathLength, EXT_INSTPATH_FMT, lpGuid);
    
    if(FAILED(hr))
        return FALSE;

    XBStr xbstrInstancePath = xszInstPath;
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory.")));
        return FALSE;
    }

    hr = m_pWbemServices->GetObject(xbstrInstancePath, 0, NULL, &xInstance, NULL);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Didn't find an instance of the extension object when trying to set the dirty flag.")));
        return FALSE;
    }

    VARIANT var;
    VariantInit(&var);
    XVariant xVar(&var);

    //
    // Display name
    //

    hr = xInstance->Get(m_xbstrDisplayName, 0, &var, NULL, NULL);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }

    hr = xInstance->Put(m_xbstrDisplayName, 0, &var, NULL);

    VariantClear(&var);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Put failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }


    //
    // Start time
    //

    VariantInit(&var);

    hr = xInstance->Get(m_xbstrPolicyBeginTime, 0, &var, NULL, NULL);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }

    hr = xInstance->Put(m_xbstrPolicyBeginTime, 0, &var, NULL);

    VariantClear(&var);

    if(FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Put failed for displayname. hr=0x%08X."), hr));
        return FALSE;
    }


    //
    // end time
    //


    SYSTEMTIME sysTime;
    GetSystemTime(&sysTime);

    if (!LogTimeProperty( xInstance, m_xbstrPolicyEndTime, &sysTime) ) {
        DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for dispayname. hr=0x%08X."), hr));
        return FALSE;
    }


    //
    // Dirty flag
    //

    VariantInit(&var);

    if (bLoggingIncomplete) {

        hr = xInstance->Get(m_xbstrStatus, 0, &var, NULL, NULL);

        if(FAILED(hr)) {
            DebugMsg((DM_VERBOSE, TEXT("CSessionLogger::Log: Get failed for loggingstatus. hr=0x%08X."), hr));
            return FALSE;
        }
    }
    else {
        var.vt = VT_I4;
        var.lVal = 1;    // logging completed successfully
    }


    hr = xInstance->Put( m_xbstrStatus, 0, &var, 0 );

    VariantClear(&var);

    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    //
    // Error code
    //

    VariantInit(&var);

    var.vt = VT_I4;
    var.lVal = dwErr;

    hr = xInstance->Put( m_xbstrError, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_UPDATE_ONLY, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }


    return TRUE;
}

//*************************************************************
//
//  CExtSessionLogger::Update()
//
//  Purpose:    Logs an instance of ExtensionSessionStatus
//
//*************************************************************


BOOL CExtSessionLogger::Set( LPGPEXT lpExt, BOOL bSupported, LPRSOPEXTSTATUS lpRsopExtStatus )
{
    LPTSTR lpGuid=NULL, lpName=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpExt ? lpExt->lpKeyName : GPCORE_GUID;
    lpName = lpExt ? lpExt->lpDisplayName : m_szGPCoreNameBuf;

    XInterface<IWbemClassObject>xInstance = NULL;
    XBStr xDisplayName;

    hr = m_xClass->SpawnInstance( 0, &xInstance );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: SpawnInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    xDisplayName = lpName;
    if ( !xDisplayName ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    XBStr xGuid ( lpGuid );
    if ( !xGuid ) {
         DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Failed to allocate memory" )));
         return FALSE;
    }

    VARIANT var;
    var.vt = VT_BSTR;

    var.bstrVal = xGuid;
    hr = xInstance->Put( m_xbstrExtGuid, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.bstrVal = xDisplayName;
    hr = xInstance->Put( m_xbstrDisplayName, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }

    SYSTEMTIME sysTime;

    if (!FileTimeToSystemTime(&(lpRsopExtStatus->ftStartTime), &sysTime)) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
        return FALSE;
    }

    if ( !LogTimeProperty( xInstance, m_xbstrPolicyBeginTime, &sysTime ) )
    {
        return FALSE;
    }
    
    if (!FileTimeToSystemTime(&(lpRsopExtStatus->ftEndTime), &sysTime)) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: FileTimeToSystemTime failed with 0x%x" ), GetLastError() ));
        return FALSE;
    }

    if ( !LogTimeProperty( xInstance, m_xbstrPolicyEndTime, &sysTime ) )
    {
        return FALSE;
    }
    
    var.vt = VT_I4;
    var.lVal = (!bSupported) ? 3 : (FAILED(lpRsopExtStatus->dwLoggingStatus) ? 2 : 1  );

    hr = xInstance->Put( m_xbstrStatus, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    var.vt = VT_I4;
    var.lVal = lpRsopExtStatus->dwStatus;

    hr = xInstance->Put( m_xbstrError, 0, &var, 0 );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Put failed with 0x%x" ), hr ));
        return FALSE;
    }


    hr = m_pWbemServices->PutInstance( xInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: PutInstance failed with 0x%x" ), hr ));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  CExtSessionLogger::Delete()
//
//  Purpose:    Deletes an instance of ExtensionSessionStatus
//
//*************************************************************

BOOL CExtSessionLogger::Delete( LPTSTR lpKeyName)
{
    LPTSTR lpGuid=NULL;
    HRESULT hr;
    
    if ( !m_bInitialized ) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Delete: Failed to initialize." )));
        return FALSE;
    }

    lpGuid = lpKeyName ? lpKeyName : GPCORE_GUID;

    XInterface<IWbemClassObject>xInstance = NULL;
    
    //
    // We should have an instance
    //

    DWORD         dwInstPathLength = lstrlen(EXT_INSTPATH_FMT) + lstrlen(lpGuid) + 10;
    XPtrLF<TCHAR> xszInstPath = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR) * ( dwInstPathLength ));

    if (!xszInstPath) {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Delete: Not enough memory." )));
        return FALSE;
    }

    hr = StringCchPrintf(xszInstPath, dwInstPathLength, EXT_INSTPATH_FMT, lpGuid);
    
    if(FAILED(hr))
        return FALSE;

    XBStr xbstrInstancePath = xszInstPath;
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Delete: Failed to allocate memory.")));
        return FALSE;
    }

    hr = m_pWbemServices->DeleteInstance( xbstrInstancePath,
                                        0L,
                                        NULL,
                                        NULL );

    if ( FAILED(hr) )
    {
        DebugMsg((DM_VERBOSE, TEXT("CExtSessionLogger::Delete: Failed to DeleteInstance with 0x%x"), hr ));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  GetRsopSchemaVersionNumber
//
//  Purpose:    Gets the Rsop schema version number from the namespace that we are
//              connected to
//
// returns S_OK on success, failur code o/w
//*************************************************************


HRESULT GetRsopSchemaVersionNumber(IWbemServices *pWbemServices, DWORD *dwVersionNumber)
{
    XInterface<IWbemClassObject>xpInstance = NULL;
    
    VARIANT                     var;
    XBStr                       xbstrInstancePath;
    XBStr                       xbstrVersion;
    HRESULT                     hr;

    *dwVersionNumber = 0;

    xbstrVersion = L"version";
    if ( !xbstrVersion ) {
        DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to allocate memory.")));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    xbstrInstancePath = L"RSOP_Session.id=\"Session1\"";
    if(!xbstrInstancePath)
    {
        DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to allocate memory.")));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = pWbemServices->GetObject(xbstrInstancePath, 0, NULL, &xpInstance, NULL);

    if(SUCCEEDED(hr)) {

        VariantInit(&var);
        XVariant xVar(&var);

        hr = xpInstance->Get(xbstrVersion, 0, &var, NULL, NULL);

        if((SUCCEEDED(hr)) && ( var.vt != VT_NULL )) 
            *dwVersionNumber = var.lVal;
    }


    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\factory.h ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:			Factory.h
//
// Description:		
//
// History:    8-20-99   leonardm    Created
//
///////////////////////////////////////////////////////////////////////////////////

#ifndef _FACTORY_H__CB339D7F_83AC_4dd4_9DD3_C7737D698CD3__INCLUDED
#define _FACTORY_H__CB339D7F_83AC_4dd4_9DD3_C7737D698CD3__INCLUDED

///////////////////////////////////////////////////////////////////////////////////
//
// Class:	
//
// Description:	
//
// History:		8/20/99		leonardm	Created.
//
///////////////////////////////////////////////////////////////////////////////////
class CProvFactory : public IClassFactory
{
private:
	long m_cRef;

public:
  CProvFactory();
  ~CProvFactory();

  // From IUnknown
  STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
  STDMETHOD_(ULONG, AddRef)();
  STDMETHOD_(ULONG, Release)();

  // From IClassFactory
  STDMETHOD(CreateInstance)(LPUNKNOWN punk, REFIID riid, LPVOID* ppv);
  STDMETHOD(LockServer)(BOOL bLock);
};

#endif // _FACTORY_H__CB339D7F_83AC_4dd4_9DD3_C7737D698CD3__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\factory.cpp ===
///////////////////////////////////////////////////////////////////////////////////
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999. All rights reserved
//
// File:                        Factory.cpp
//
// Description:         
//
// History:    8-20-99   leonardm    Created
//
///////////////////////////////////////////////////////////////////////////////////

#include "uenv.h"
#include "Factory.h"
#include "diagprov.h"

extern long g_cLock;

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
CProvFactory::CProvFactory() : m_cRef(1)
{
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
CProvFactory::~CProvFactory()
{
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::QueryInterface(REFIID riid, LPVOID* ppv)
{
        if ( riid == IID_IUnknown || riid == IID_IClassFactory )
        {
                *ppv = this;
                AddRef();
                return S_OK;
        }
        else
        {
                *ppv = NULL;
                return E_NOINTERFACE;
        }
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) CProvFactory::AddRef()
{
        return InterlockedIncrement(&m_cRef);
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CProvFactory::Release()
{
        if (!InterlockedDecrement(&m_cRef))
        {
                delete this;
                return 0;
        }
        return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::CreateInstance(LPUNKNOWN punk, REFIID riid, LPVOID* ppv)
{
        *ppv = NULL;

        if(punk != NULL)
        {
                return CLASS_E_NOAGGREGATION;
        }

        CSnapProv* pProvider = new CSnapProv();
        if (pProvider == NULL)
        {
                return E_OUTOFMEMORY;
        }

        HRESULT hr = pProvider->QueryInterface(riid, ppv);

        pProvider->Release();

        return hr;

        return S_OK;
}

///////////////////////////////////////////////////////////////////////////////////
//
// Function:    
//
// Description: 
//
// Parameters:  
//
// Return:              
//
// History:             8/20/99         leonardm        Created.
//
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CProvFactory::LockServer(BOOL bLock)
{
        if (bLock)
        {
                InterlockedIncrement( &g_cLock );
        }
        else
        {
                InterlockedDecrement( &g_cLock );
        }

        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\polset.cpp ===
//*************************************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    15-July-2000   NishadM    Created
//
//*************************************************************

#include "uenv.h"
#include <wbemcli.h>
#include "SmartPtr.h"
#include "WbemTime.h"
#include <strsafe.h>

//*************************************************************
//
//  RsopSetPolicySettingStatus
//
//  Purpose:  Creates create instances of RSOP_PolicySettingStatus and
//              links them to RSOP_PolicySetting
//
//  Parameters: 
//              dwFlags             - flags
//              pServices           - namespace
//              pSettingInstance    - instance of RSOP_PolicySetting
//              nLinks              - number of setting statuses
//              pStatus             - setting status information
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT
RsopSetPolicySettingStatus( DWORD,
                        IWbemServices*              pServices,
                        IWbemClassObject*           pSettingInstance,
                        DWORD                       nLinks,
                        POLICYSETTINGSTATUSINFO*    pStatus )
{
    HRESULT hr;

    //
    //  validate arguments
    //
    if ( !pServices || !pSettingInstance || !nLinks || !pStatus )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: invalid arguments" ) );
        return E_INVALIDARG;
    }

    //
    //  get the RSoP_PolicySettingStatus class
    //
    XBStr bstr = L"RSoP_PolicySettingStatus";
    XInterface<IWbemClassObject> xClassStatus;
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassStatus,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSoP_PolicySettingStatus instance
    //
    XInterface<IWbemClassObject> xInstStatus;
    hr = xClassStatus->SpawnInstance( 0, &xInstStatus );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  get the RSoP_PolicySettingLink class
    //
    XInterface<IWbemClassObject> xClassLink;

    bstr = L"RSoP_PolicySettingLink";
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassLink,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSoP_PolicySettingLink class
    //
    XInterface<IWbemClassObject> xInstLink;
    hr = xClassLink->SpawnInstance( 0, &xInstLink );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  get the class name of the instance
    //
    VARIANT varClass;
    VariantInit( &varClass );
    XVariant xVarClass(&varClass);

    bstr = L"__CLASS";
    hr = pSettingInstance->Get( bstr,
                                0,
                                xVarClass,
                                0,
                                0 );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Get __CLASS failed, 0x%x", hr ) );
        return hr;
    }

    if ( varClass.vt == VT_NULL || varClass.vt == VT_EMPTY )
    {
        return E_UNEXPECTED;
    }

    //
    //  get the [key] of the RSoP_PolicySetting instance
    //
    VARIANT varId;
    VariantInit( &varId );
    XVariant xVarId(&varId);
    XBStr    bstrid = L"id";
    XBStr    bstrPath = L"__RELPATH";

    hr = pSettingInstance->Get( bstrPath,
                                0,
                                xVarId,
                                0,
                                0 );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Get id failed, 0x%x", hr ) );
        return hr;
    }

    LPWSTR szSetting = varId.bstrVal;

    //
    //  set the setting value
    //
    VARIANT var;
    XBStr   bstrVal;
    XBStr   bstrsetting = L"setting";
    XBStr   bstreventSource = L"eventSource";
    XBStr   bstreventLogName = L"eventLogName";
    XBStr   bstreventID = L"eventID";
    XBStr   bstreventTime = L"eventTime";
    XBStr   bstrstatus = L"status";
    XBStr   bstrerrorCode = L"errorCode";

    //
    //  for each info.
    //
    for ( DWORD i = 0 ; i < nLinks ; i++ )
    {
        //
        // RSoP_PolicySettingStatus
        //
        
        const DWORD   dwGuidLength = 64;
        WCHAR   szGuid[dwGuidLength];
        LPWSTR  szPolicyStatusKey; 

        if ( !pStatus[i].szKey )
        {
            //
            // caller did not specify a key. generate it.
            //
            GUID guid;

            //
            // create the [key]
            //
            hr = CoCreateGuid( &guid );
            if ( FAILED(hr) )
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: CoCreateGuid failed, 0x%x", hr ) );
                return hr;
            }

            hr = StringCchPrintf( szGuid,
                                  dwGuidLength,
                                  L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                                  guid.Data1,
                                  guid.Data2,
                                  guid.Data3,
                                  guid.Data4[0], guid.Data4[1],
                                  guid.Data4[2], guid.Data4[3],
                                  guid.Data4[4], guid.Data4[5],
                                  guid.Data4[6], guid.Data4[7] );

            if(FAILED(hr))
                return hr;

            bstrVal = szPolicyStatusKey = szGuid;
            if (!bstrVal) 
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Could not allocate memory") );
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            //
            // caller specified a key. use it.
            //
            bstrVal = szPolicyStatusKey = pStatus[i].szKey;
            if (!bstrVal) 
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Could not allocate memory") );
                return E_OUTOFMEMORY;
            }

        }

        var.vt = VT_BSTR;
        var.bstrVal = bstrVal;
        //
        //  set the id
        //
        hr = xInstStatus->Put(  bstrid,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put id failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the eventSource
        //
        if ( pStatus[i].szEventSource )
        {
            var.vt = VT_BSTR;
            bstrVal = pStatus[i].szEventSource;
            var.bstrVal = bstrVal;

            hr = xInstStatus->Put(  bstreventSource,
                                    0,
                                    &var,
                                    0 );
            if ( FAILED (hr) )
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventSource failed, 0x%x", hr ) );
                return hr;
            }
        }

        //
        //  set the eventLogName
        //
        if ( pStatus[i].szEventLogName )
        {
            var.vt = VT_BSTR;
            bstrVal = pStatus[i].szEventLogName;
            var.bstrVal = bstrVal;

            hr = xInstStatus->Put(  bstreventLogName,
                                    0,
                                    &var,
                                    0 );
            if ( FAILED (hr) )
            {
                DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventLogName failed, 0x%x", hr ) );
                return hr;
            }
        }

        //
        //  set the eventID
        //
        var.vt = VT_I4;
        var.lVal = pStatus[i].dwEventID;

        hr = xInstStatus->Put(  bstreventID,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventID failed, 0x%x", hr ) );
            return hr;
        }

        XBStr xTimeLogged;

        //
        //  convert SYSTEMTIME to WBEM time
        //
        hr = SystemTimeToWbemTime( pStatus[i].timeLogged, xTimeLogged );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: SystemTimeToWbemTime failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the eventTime
        //
        var.vt = VT_BSTR;
        var.bstrVal = xTimeLogged;

        hr = xInstStatus->Put(  bstreventTime,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put eventTime failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the errorCode
        //
        var.vt = VT_I4;
        var.lVal = pStatus[i].dwErrorCode;
        
        hr = xInstStatus->Put(  bstrerrorCode,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put errorCode failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the status
        //
        var.vt = VT_I4;
        var.lVal = pStatus[i].status;
        
        hr = xInstStatus->Put(  bstrstatus,
                                0,
                                &var,
                                0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put status failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  commit the RSOP_PolicySettingStatus
        //
        hr = pServices->PutInstance(xInstStatus,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: PutInstance RSOP_PolicySettingStatus failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  RSoP_PolicySettingLink
        //

        var.vt = VT_BSTR;
        bstrVal = szSetting;
        if (!bstrVal) 
        {
            DebugMsg(( DM_WARNING, L"SetPolicySettingStatus: Could not allocate memory"));
            return E_OUTOFMEMORY;
        }

        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstrsetting,
                            0,
                            &var,
                            0);
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put setting failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  create the second key
        //
        const DWORD dwStatusLength = 96;
        WCHAR szStatus[dwStatusLength];

        //
        // e.g. RSoP_PolicySettingStatus.id="{00000000-0000-0000-000000000000}"
        //
        hr = StringCchPrintf( szStatus, dwStatusLength, L"RSoP_PolicySettingStatus.id=\"%s\"", szPolicyStatusKey );

        if( FAILED(hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: StringCchPrintf failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  set the status
        //
        bstrVal = szStatus;
        if (!bstrVal) 
        {
            DebugMsg(( DM_WARNING, L"SetPolicySettingStatus: Could not allocate memory"));
            return E_OUTOFMEMORY;
        }

        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstrstatus,
                            0,
                            &var,
                            0);
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: Put status failed, 0x%x", hr ) );
            return hr;
        }

        //
        //  commit the RSOP_PolicySettingLink
        //
        hr = pServices->PutInstance(xInstLink,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED (hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: PutInstance RSOP_PolicySettingLink failed, 0x%x", hr ) );
            return hr;
        }
    }

    return hr;
}

//*************************************************************
//
//  RsopResetPolicySettingStatus
//
//  Purpose:  Creates create instances of RSOP_PolicySettingStatus and
//              links them to RSOP_PolicySetting
//
//  Parameters: 
//              dwFlags             - flags
//              pServices           - namespace
//              pSettingInstance    - instance of RSOP_PolicySetting
//
//  Returns:    S_OK if successful
//
//*************************************************************

#define RESET_QUERY_TEMPLATE L"REFERENCES OF {%s} WHERE ResultClass = RSOP_PolicySettingLink"

HRESULT
RsopResetPolicySettingStatus(   DWORD,
                            IWbemServices*      pServices,
                            IWbemClassObject*   pSettingInstance )
{
    // query for the RSOP_PolicySettingLink
    // for every RSOP_PolicySettingLink query for the RSoP_PolicySettingLink.status
        // delete the RSoP_PolicySettingStatus
        // delete the RSOP_PolicySettingLink

    if ( !pServices || !pSettingInstance )
    {
        return E_INVALIDARG;
    }

    //
    //  get the [key] of the RSoP_PolicySetting instance
    //
    VARIANT varId;
    VariantInit( &varId );
    XVariant  xVarId(&varId);
    XBStr    bstrRelPath = L"__RELPATH";

    HRESULT hr;

    hr = pSettingInstance->Get( bstrRelPath,
                                0,
                                xVarId,
                                0,
                                0 );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"RsopResetPolicySettingStatus: Get __RELPATH failed, 0x%x", hr ) );
        return hr;
    }

    if ( varId.vt == VT_NULL || varId.vt == VT_EMPTY )
    {
        return E_UNEXPECTED;
    }

    DWORD dwIdSize = wcslen(varId.bstrVal);

    //
    //  Create a query for all references of the object
    //

    //
    //  Query template
    //

    DWORD           dwQryLength = dwIdSize + lstrlen(RESET_QUERY_TEMPLATE) + 1;
    XPtrLF<WCHAR>   szQuery = LocalAlloc( LPTR, sizeof(WCHAR) * (dwQryLength) );

    if ( !szQuery )
    {
        DebugMsg( ( DM_WARNING, L"RsopResetPolicySettingStatus: LocalAlloc failed, 0x%x", GetLastError() ) );
        return E_OUTOFMEMORY;
    }

    hr = StringCchPrintf( szQuery, dwQryLength, RESET_QUERY_TEMPLATE, varId.bstrVal );

    if(FAILED(hr))
        return hr;

    XBStr bstrLanguage = L"WQL";
    XBStr bstrQuery = szQuery;
    XInterface<IEnumWbemClassObject> pEnum;
    XBStr bstrPath = L"__PATH";
    XBStr bstrStatus = L"status";

    //
    // search for RSOP_ExtensionEventSourceLink
    //
    hr = pServices->ExecQuery(  bstrLanguage,
                                bstrQuery,
                                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_ENSURE_LOCATABLE | WBEM_FLAG_RETURN_IMMEDIATELY,
                                0,
                                &pEnum );
    if ( SUCCEEDED( hr ) )
    {
        DWORD dwReturned;

        do 
        {
            XInterface<IWbemClassObject> xInst;

            dwReturned = 0;

            hr = pEnum->Next(   WBEM_INFINITE,
                                1,
                                &xInst,
                                &dwReturned );
            if ( SUCCEEDED( hr ) && dwReturned == 1 )
            {
                //
                // delete RSoP_PolicySettingStatus
                //
                VARIANT varStatus;
                VariantInit( &varStatus );
                XVariant xVarStatus( &varStatus );

                hr = xInst->Get(bstrStatus,
                                0,
                                &varStatus,
                                0,
                                0 );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pServices->DeleteInstance( varStatus.bstrVal,
                                                    0L,
                                                    0,
                                                    0 );
                    if ( SUCCEEDED( hr ) )
                    {
                        //
                        // delete RSoP_PolicySettingLink
                        //

                        VARIANT varLink;
                        VariantInit( &varLink );
                        hr = xInst->Get(bstrPath,
                                        0L,
                                        &varLink,
                                        0,
                                        0 );
                        if ( SUCCEEDED(hr) )
                        {
                            XVariant xVarLink( &varLink );

                            hr = pServices->DeleteInstance( varLink.bstrVal,
                                                            0L,
                                                            0,
                                                            0 );
                            if ( FAILED( hr ) )
                            {
                                return hr;
                            }
                        }
                    }
                }
            }

        } while ( SUCCEEDED( hr ) && dwReturned == 1 );
    }

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\reghash.h ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#define HASH_TABLE_SIZE 97                  // # buckets in hash table
#define STARCOMMAND     TEXT("**Command")   // A special valuename created to keep the commands
//
// List of data values for key registry value in precedence order,
// entries at the beginning of list have higher precedence.
//

typedef struct _REGDATAENTRY {
    BOOL                      bDeleted;        // Is this a deleted value ?
    BOOL                      bAdmPolicy;      // Is this generated by an Adm policy ?
    DWORD                     dwValueType;
    DWORD                     dwDataLen;
    BYTE  *                   pData;
    WCHAR *                   pwszGPO;         // Gpo that set this data
    WCHAR *                   pwszSOM;         // SDOU that the above Gpo is linked to
    WCHAR *                   pwszCommand;     // The actual command that caused the change in data value
    struct _REGDATAENTRY *    pNext;
} REGDATAENTRY, *LPREGDATAENTRY;


//
// List of registry value names under a common registry key
//

typedef struct _REGVALUEENTRY {
    WCHAR *                   pwszValueName;    // Registry value name
    REGDATAENTRY *            pDataList;
    struct _REGVALUEENTRY *   pNext;

} REGVALUEENTRY, *LPREGVALUEENTRY;



//
// List of registry keys that map to same hash bucket
//

typedef struct _REGKEYENTRY {
    WCHAR *                 pwszKeyName;        // Registry key name
    REGVALUEENTRY *         pValueList;
    struct _REGKEYENTRY *   pNext;
} REGKEYENTRY, *LPREGKEYENTRY;


//
// Hash table for looking up registry keys
//

typedef struct _REGHASHTABLE {
    REGKEYENTRY *   aHashTable[HASH_TABLE_SIZE];
    HRESULT         hrError;
} REGHASHTABLE, *LPREGHASHTABLE;


//
// Registry operation types for deleting and
// adding values.
//

typedef enum _REGOPERATION {
    REG_DELETEVALUE = 0,
    REG_DELETEALLVALUES,
    REG_DELETEKEY,
    REG_ADDVALUE,
    REG_SOFTADDVALUE,
    REG_INTERNAL_DELETESINGLEKEY
} REGOPERATION;

//
// Public methods of hash table: alloc, free and addentry
//

#ifdef __cplusplus
extern "C" {
#endif

REGHASHTABLE * AllocHashTable();

void FreeHashTable( REGHASHTABLE *pHashTable );

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand, 
                      BOOL bCreateCommand);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\maindll.cpp ===
//*************************************************************
//
// Microsoft Confidential. Copyright (c) Microsoft Corporation 1999.
//
// File:        MainDll.cpp
//
// Description: Dll registry, get class object functions
//
// History:     8-20-99   leonardm    Created
//              1-15-00   NishadM
//
//*************************************************************

#include "uenv.h"
#include "Factory.h"
#include "rsopdbg.h"
#include "initguid.h"
#include <wbemcli.h>
#define SECURITY_WIN32
#include <security.h>
#include <aclapi.h>
#include "smartptr.h"
#include "rsopinc.h"
#include "rsopsec.h"
#include <strsafe.h>

HRESULT GetRsopSchemaVersionNumber(IWbemServices *pWbemServices, DWORD *dwVersionNumber);

// {B3FF88A4-96EC-4cc1-983F-72BE0EBB368B}
DEFINE_GUID(CLSID_CSnapProv, 0xb3ff88a4, 0x96ec, 0x4cc1, 0x98, 0x3f, 0x72, 0xbe, 0xe, 0xbb, 0x36, 0x8b);

// Count of objects and locks.

long g_cObj = 0;
long g_cLock = 0;

CDebug dbgRsop;

extern "C"
{
STDMETHODIMP RSoPMakeAbsoluteSD(SECURITY_DESCRIPTOR* pSelfRelativeSD, SECURITY_DESCRIPTOR** ppAbsoluteSD);
STDMETHODIMP GetNamespaceSD(IWbemServices* pWbemServices, SECURITY_DESCRIPTOR** ppSD);
STDMETHODIMP SetNamespaceSD(SECURITY_DESCRIPTOR* pSD, IWbemServices* pWbemServices);
STDMETHODIMP FreeAbsoluteSD(SECURITY_DESCRIPTOR* pAbsoluteSD);
STDMETHODIMP GetWbemServicesPtr( LPCWSTR, IWbemLocator**, IWbemServices** );
};

  
void
InitializeSnapProv( void )
{
    dbgRsop.Initialize(  L"Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon",
                     L"RsopDebugLevel",
                     L"userenv.log",
                     L"userenv.bak",
                     FALSE );                     
}

extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        if (rclsid != CLSID_CSnapProv)
        {
                return CLASS_E_CLASSNOTAVAILABLE;
        }

        CProvFactory* pFactory = new CProvFactory();

        if (pFactory == NULL)
        {
                return E_OUTOFMEMORY;
        }

        HRESULT hRes = pFactory->QueryInterface(riid, ppv);

        pFactory->Release();

        return hRes;
}

extern "C"
STDAPI DllCanUnloadNow()
{
    // It is OK to unload if there are no objects or locks on the class factory.
    if( g_cObj == 0L && g_cLock == 0L )
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

extern "C"
STDAPI DllRegisterServer(void)
{
    wchar_t         szID[128];
    wchar_t         szCLSID[128];
    wchar_t         szModule[MAX_PATH];
    wchar_t*        pName           = L"Rsop Logging Mode Provider";
    wchar_t*        pModel          = L"Both";
    HRESULT         hr              = S_OK;
    HKEY            hKey1, hKey2;
    DWORD           dwError = ERROR_SUCCESS;

    // Create the path.
    GuidToString( &CLSID_CSnapProv, szID );

    hr = StringCchCopy(szCLSID, ARRAYSIZE(szCLSID), TEXT("CLSID\\"));

    if(FAILED(hr))
        return hr;

    hr = StringCchCat(szCLSID, ARRAYSIZE(szCLSID), szID);

    if(FAILED(hr))
        return hr;

    // Create entries under CLSID

    dwError = RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1); // Fixing bug 571328, i.e, checking return values
    if  (dwError != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(dwError);
    }

    dwError = RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE*)pName, (wcslen(pName) + 1) * sizeof(wchar_t));
    if  (dwError != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return HRESULT_FROM_WIN32(dwError);
    }

    dwError = RegCreateKey(hKey1, L"InprocServer32", &hKey2);
    if  (dwError != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return HRESULT_FROM_WIN32(dwError);
    }

    GetModuleFileName(g_hDllInstance, szModule,  MAX_PATH);
    
    dwError = RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE*)szModule, (wcslen(szModule) + 1) * sizeof(wchar_t));
    if  (dwError != ERROR_SUCCESS)
    {
        RegCloseKey(hKey2);
        RegCloseKey(hKey1);
        return HRESULT_FROM_WIN32(dwError);
    }
    
    dwError = RegSetValueEx(hKey2, L"ThreadingModel", 0, REG_SZ, (BYTE*)pModel, (wcslen(pModel) + 1) * sizeof(wchar_t));
    if  (dwError != ERROR_SUCCESS)
    {
        RegCloseKey(hKey2);
        RegCloseKey(hKey1);
        return HRESULT_FROM_WIN32(dwError);
    }

    RegCloseKey(hKey2);
    RegCloseKey(hKey1);

    return S_OK;
}

extern "C"
STDAPI DllUnregisterServer(void)
{
    wchar_t     szID[128];
    const DWORD dwCLSIDLength = 128;
    wchar_t     szCLSID[dwCLSIDLength];
    HKEY        hKey;
    HRESULT     hr            = S_OK;

    // Create the path using the CLSID

    GuidToString( &CLSID_CSnapProv, szID );

    hr = StringCchCopy(szCLSID, dwCLSIDLength, TEXT("CLSID\\"));

    if(FAILED(hr))
        return hr;

    hr = StringCchCat(szCLSID, dwCLSIDLength, szID);

    if(FAILED(hr))
        return hr;

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hKey);
    if(dwRet == ERROR_SUCCESS)
    {
        RegDeleteKey(hKey, L"InProcServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKey(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if(dwRet == ERROR_SUCCESS)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }

    return S_OK;
}
                    

BOOL RunningOnWow64()
{
#if defined(_WIN64) 
    // 64bit builds don't run in Wow64
    return false;
#else

    // OS version
    OSVERSIONINFO osviVersion;
    osviVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osviVersion)) {
        DebugMsg((DM_WARNING, TEXT("RunningOnWow64: Couldn't detect Version with error %d"), GetLastError()));
        return FALSE;
    }


    // on NT5 or later 32bit build. Check for 64 bit OS
    if ((osviVersion.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
         (osviVersion.dwMajorVersion >= 5))
    {
        // QueryInformation for ProcessWow64Information returns a pointer to the Wow Info.
        // if running native, it returns NULL.

        PVOID pWow64Info = 0;
        if (NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, &pWow64Info, sizeof(pWow64Info), NULL))
            && pWow64Info != NULL)
        {
            // running 32bit on Wow64.
            return TRUE;
        }
    }
    return FALSE;
#endif
}

HRESULT
CompileMOF( LPCWSTR szMOFFile, LPCWSTR szMFLFile )
{
    WCHAR                       szNamespace[MAX_PATH];
    BOOL                        bUpgrade = FALSE;
    HRESULT                     hr;

    XInterface<IWbemLocator>    xWbemLocator;
    XInterface<IWbemServices>   xWbemServicesOld;
    DWORD                       dwCurrentVersion= 0;
    DWORD                       dwNewVersion = RSOP_MOF_SCHEMA_VERSION; 


    //
    // On wow64 do nothing
    //

    if (RunningOnWow64()) {
        DebugMsg((DM_VERBOSE, TEXT("CompileMof: Running on Wow64. returning without doing anything")));
        return S_OK;
    }


    if ( !szMOFFile )
    {
        return E_POINTER;
    }

    hr = StringCchCopy(szNamespace, MAX_PATH, RSOP_NS_ROOT);

    if(FAILED(hr))
        return hr;
 
    //
    // Get the wbem services pointer to the machine namespace
    //

    hr = GetWbemServicesPtr(RSOP_NS_MACHINE,
                            &xWbemLocator,
                            &xWbemServicesOld );


    if (!xWbemLocator) {
        DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to get IWbemLocator pointer.Error 0x%x"), hr));
        return hr;
    }

    if ( (SUCCEEDED(hr)) && (xWbemServicesOld)) {
        hr = GetRsopSchemaVersionNumber(xWbemServicesOld, &dwCurrentVersion);        
        if (FAILED(hr)) {
            return hr;
        }
    }

    if (HIWORD(dwCurrentVersion) != HIWORD(dwNewVersion)) {

        //
        // We should cleanout the schema and recreate below
        //

        DebugMsg((DM_VERBOSE, TEXT("CompileMof: Major version schema upgrade detected. Deleting rsop namespace and rebuilding")));
        
        xWbemServicesOld = NULL;
        hr = DeleteRsopNameSpace(szNamespace, xWbemLocator);
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to get delete the rsop namespace. Error 0x%x. Continuing.."), hr));
        }
        
        //
        // Delete the state info on the machine
        //


        if (RegDelnode(HKEY_LOCAL_MACHINE, GP_STATE_ROOT_KEY) != ERROR_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("CompileMof: Failed to delete the state key. Continuing..")));
        }

        bUpgrade = FALSE;
    }
    else {
        bUpgrade = TRUE;
    }

    XInterface<IMofCompiler> xpMofCompiler;
    
    //
    // get a handle to IMofCompiler
    //

    hr = CoCreateInstance(  CLSID_MofCompiler,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IMofCompiler,
                            (LPVOID*) &xpMofCompiler );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, L"CompileMOF: CoCreateInstance() failed, 0x%X.", hr));
        return hr;
    }

    WBEM_COMPILE_STATUS_INFO Info;

    hr = xpMofCompiler->CompileFile((LPWSTR)szMOFFile,
                                    0,  // no server & namespace
                                    0,  // no user
                                    0,  // no authority
                                    0,  // no password
                                    0,  // no options
                                    0,  // no class flags
                                    0,  // no instance flags
                                    &Info );
    if ( FAILED( hr ) )
    {
        DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() failed, 0x%X.", hr));
    }
    else 
    {
        if (hr != S_OK ) 
        {
            DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() returned with 0x%X.", hr));
            DebugMsg((DM_WARNING, L"CompileMOF: Details - lPhaseError - %d, hRes = 0x%x, ObjectNum - %d, firstline - %d, LastLine - %d", 
                      Info.lPhaseError, Info.hRes, Info.ObjectNum, Info.FirstLine, Info.LastLine ));
        }
        else
        {
            hr = xpMofCompiler->CompileFile((LPWSTR)szMFLFile,
                                            0,  // no server & namespace
                                            0,  // no user
                                            0,  // no authority
                                            0,  // no password
                                            0,  // no options
                                            0,  // no class flags
                                            0,  // no instance flags
                                            &Info );
            if ( FAILED( hr ) )
            {
                DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() failed, 0x%X.", hr));
            }
            else 
            {
                if (hr != S_OK ) 
                {
                    DebugMsg((DM_WARNING, L"CompileMOF: IMofCompiler::CompileFile() returned with 0x%X.", hr));
                    DebugMsg((DM_WARNING, L"CompileMOF: Details - lPhaseError - %d, hRes = 0x%x, ObjectNum - %d, firstline - %d, LastLine - %d", 
                              Info.lPhaseError, Info.hRes, Info.ObjectNum, Info.FirstLine, Info.LastLine ));
                }
            }
        }
    }

    //
    // There are 2 reasons we are doing this always.
    //  1. We had put AUthUsers:R permission in XP and we want to 
    //      get rid of those permissions
    //  2. Seems like it is better to secure it to OS level permissions
    //      on each upgrade.
    // 


    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;

    Csd.AddLocalSystem(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministrators(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddNetworkService(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministratorsAsOwner();
    Csd.AddAdministratorsAsGroup();

    
    DebugMsg((DM_VERBOSE, L"CompileMOF: Setting permissions on RSoP namespaces"));

    xsd = Csd.MakeSelfRelativeSD();
    if (!xsd) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CompileMOF::MakeSelfSD failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CompileMOF::SetSecurityDescriptorControl failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = SetNameSpaceSecurity(RSOP_NS_USER, xsd, xWbemLocator);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, L"CompileMOF: SetNamespaceSecurity() failed, 0x%X.", hr));
        return hr;
    }


    hr = SetNameSpaceSecurity(RSOP_NS_MACHINE, xsd, xWbemLocator);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, L"CompileMOF: SetNamespaceSecurity() failed, 0x%X.", hr));
        return hr;
    }

    //
    // AUthenticated users need to make method calls at the root.
    // Give them the ability to do that below.
    //

    Csd.AddAuthUsers(WBEM_ENABLE |                                                         
                     WBEM_METHOD_EXECUTE | 
                     WBEM_REMOTE_ACCESS);          // no inheritance

    xsd = NULL; // free up the structure already allocated

    xsd = Csd.MakeSelfRelativeSD();
    if (!xsd) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CompileMOF::MakeSelfSD failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
        dbg.Msg( DEBUG_MESSAGE_WARNING, TEXT("CompileMOF::SetSecurityDescriptorControl failed with %d"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = SetNameSpaceSecurity(RSOP_NS_ROOT, xsd, xWbemLocator);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, L"CompileMOF: SetNamespaceSecurity() failed, 0x%X.", hr));
        return hr;
    }

    return hr;
}

//
// currently this code is intended to be called by regsvr32.
// setup does not call this code.
// "regsvr32 /n /i userenv.dll"
// waiting for WMI gives us a mechanism to install our MOF at setup time.
//

extern "C"
STDAPI DllInstall( BOOL, LPCWSTR )
{
    HRESULT hr = S_OK;
    WCHAR   szMofFile[MAX_PATH];
    WCHAR   szMflFile[MAX_PATH];

    if ( GetSystemDirectory( szMofFile, MAX_PATH ) )
    {
        hr = StringCchCopy( szMflFile, MAX_PATH, szMofFile );

        if(FAILED(hr))
            return hr;

        LPWSTR szMOF = CheckSlash(szMofFile);
        LPWSTR szMFL = CheckSlash(szMflFile);
        
        hr = StringCchCat( szMOF, MAX_PATH - (szMOF - szMofFile), L"Wbem\\RSoP.mof" );

        if(FAILED(hr))
            return hr;

        hr = StringCchCat( szMFL, MAX_PATH - (szMFL - szMflFile), L"Wbem\\RSoP.mfl" );

        if(FAILED(hr))
            return hr;

        hr = CompileMOF( szMofFile, szMflFile );
    }
    else
    {
        hr = GetLastError();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\logger.h ===
//***********************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "..\rsoputil\smartptr.h"
#include <initguid.h>

class CSessionLogger
{
public:
    CSessionLogger( IWbemServices *pWbemServices );
    BOOL Log(LPRSOPSESSIONDATA lprsopSessionData );

private:
    BOOL                           m_bInitialized;
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrVersion;
    XBStr                          m_xbstrFlags;
    XBStr                          m_xbstrTargetName;
    XBStr                          m_xbstrSOM;
    XBStr                          m_xbstrSecurityGroups;
    XBStr                          m_xbstrSite;
    XBStr                          m_xbstrCreationTime;
    XBStr                          m_xbstrIsSlowLink;

    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;

    IWbemServices *                m_pWbemServices;
};


class CSOMLogger
{
public:
    CSOMLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( SCOPEOFMGMT *pSOM, DWORD dwOrder, BOOL bLoopback );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrType;
    XBStr                          m_xbstrOrder;
    XBStr                          m_xbstrBlocking;
    XBStr                          m_xbstrBlocked;
    XBStr                          m_xbstrReason;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};


class CGpoLogger
{
public:
    CGpoLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( GPCONTAINER *pGpContainer );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrGuidName;
    XBStr                          m_xbstrDisplayName;
    XBStr                          m_xbstrFileSysPath;
    XBStr                          m_xbstrVer;
    XBStr                          m_xbstrAccessDenied;
    XBStr                          m_xbstrEnabled;
    XBStr                          m_xbstrSD;
    XBStr                          m_xbstrFilterAllowed;
    XBStr                          m_xbstrFilterId;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};



class CGpLinkLogger
{
public:
    CGpLinkLogger( IWbemServices *pWbemServices );
    BOOL Log( WCHAR *pwszSOMId, BOOL bLoopback, GPLINK *pGpLink, DWORD dwSomOrder,
              DWORD dwLinkOrder, DWORD dwAppliedOrder );

private:
    BOOL                           m_bInitialized;
    XBStr                          m_xbstrSOM;
    XBStr                          m_xbstrGPO;
    XBStr                          m_xbstrOrder;
    XBStr                          m_xbstrLinkOrder;
    XBStr                          m_xbstrAppliedOrder;
    XBStr                          m_xbstrEnabled;
    XBStr                          m_xbstrEnforced;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    XInterface<IWbemClassObject>   m_pInstance;
    IWbemServices *                m_pWbemServices;
};


WCHAR *StripPrefix( WCHAR *pwszPath );
WCHAR *StripLinkPrefix( WCHAR *pwszPath );


class CRegistryLogger
{
public:
    CRegistryLogger( DWORD dwFlags, IWbemServices *pWbemServices );
    BOOL Log( WCHAR *pwszKeyName, WCHAR *pwszValueName,
              REGDATAENTRY *pDataEntry, DWORD dwOrder );

private:
    BOOL                           m_bInitialized;
    DWORD                          m_dwFlags;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
    IWbemServices *                m_pWbemServices;

    //
    // Strings for parent policy object
    //
    XBStr                          m_xbstrId;
    XBStr                          m_xbstrName;
    XBStr                          m_xbstrGPO;
    XBStr                          m_xbstrSOM;
    XBStr                          m_xbstrPrecedence;

    //
    // Strings for registry policy object
    //
    XBStr                          m_xbstrKey;
    XBStr                          m_xbstrValueName;
    XBStr                          m_xbstrDeleted;
    XBStr                          m_xbstrValueType;
    XBStr                          m_xbstrValue;
    XBStr                          m_xbstrCommand;
};


BOOL LogBlobProperty( IWbemClassObject *pInstance, BSTR bstrPropName, BYTE *pbBlob,
                      DWORD dwLen );


class CAdmFileLogger
{

public:
    CAdmFileLogger( IWbemServices *pWbemServices );
    BOOL Log( ADMFILEINFO *pAdmInfo );

private:
    BOOL                           m_bInitialized;
    IWbemServices *                m_pWbemServices;

    //
    // Strings for Adm policy object
    //
    XBStr                          m_xbstrName;
    XBStr                          m_xbstrGpoId;
    XBStr                          m_xbstrWriteTime;
    XBStr                          m_xbstrData;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;
};



class CExtSessionLogger
{

public:
    CExtSessionLogger( IWbemServices *pWbemServices );
    BOOL Log( LPGPEXT lpExt, BOOL bSupported );
    BOOL Update( LPTSTR lpExtKeyName, BOOL bLoggingIncomplete, DWORD dwErr );
    BOOL Set( LPGPEXT lpExt, BOOL bSupported, LPRSOPEXTSTATUS lpRsopExtStatus );
    BOOL Delete( LPTSTR lpKeyName);

private:
    BOOL                           m_bInitialized;
    IWbemServices *                m_pWbemServices;

    //
    // Strings for ExtSession Status policy object
    //
    
    XBStr                          m_xbstrExtGuid;
    XBStr                          m_xbstrDisplayName;
    XBStr                          m_xbstrPolicyBeginTime;
    XBStr                          m_xbstrPolicyEndTime;
    XBStr                          m_xbstrStatus;
    XBStr                          m_xbstrError;
    XBStr                          m_xbstrClass;
    XInterface<IWbemClassObject>   m_xClass;

    WCHAR                          m_szGPCoreNameBuf[100];
};


extern BOOL DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\reghash.cpp ===
//*************************************************************
//
//  Hash table for registry Rsop data
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "uenv.h"
#include "reghash.h"
#include "rsop.h"
#include <strsafe.h>

REGKEYENTRY * AllocRegKeyEntry( WCHAR *pwszKeyName );
void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry );
REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName );
void FreeValueEntry( REGVALUEENTRY *pValueEntry );
REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand);
                               
void FreeDataEntry( REGDATAENTRY *pDataEntry );
BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand);
REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable,
                               WCHAR *pwszKeyName,
                               BOOL bCreate );
REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate );
BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand);


////////////////////////////////////////////////////////////////////////
// Hash Table for registry policies
// ----------------------------------
//
// This hash table is used to log rsop data for registry policies. 
// A hash table entry is created for each registry entry. The registry entry
// name itself is used to calculate the hash table.
//
// Each Registry entry has a link to each of the values modified by policy.
// These values are in a link list and sorted by the valueNames.
//
// Each Value has the list of Data that are being set on the Values. This 
// sorted by the order of execution. The topmost value will contain the final value.
// The Data entries have fields that mark the value as deleted and the Command 
// associated with the action. To look for the possible commands look in the
// ParseRegistryFile.
// 
// Additionally, in the hash table 2 special case values exist.
//  a.   **Command Value. The Data under this value will contain all the commands 
//                     that are executed under this key.
//
//  b.  An ""(Empty ValueName) This valuename represents the modifications happening
//      to the key itself. For example a key can deleted or added..
//
// Note:
//      The szCommand that is passed in has to be non NULL but can be an empty string.
// There is a dependency on it in AddDataEntry and in logger.cpp. There is an Assert 
// for this in AddRegHashEntry
// 
////////////////////////////////////////////////////////////////////////



//*************************************************************
//
//  AllocHashTable
//
//  Purpose:    Allocates a new hash table
//
//  Returns:    Pointer to hash table
//
//*************************************************************

REGHASHTABLE * AllocHashTable()
{
    DWORD i;

    REGHASHTABLE *pHashTable = (REGHASHTABLE *) LocalAlloc (LPTR, sizeof(REGHASHTABLE));

    if ( pHashTable == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocHashTable: Failed to alloc hashtable.")));
        return NULL;
    }

    for ( i=0; i<HASH_TABLE_SIZE; i++) {
        pHashTable->aHashTable[i] = 0;
    }

    pHashTable->hrError = S_OK;

    return pHashTable;
}



//*************************************************************
//
//  FreeHashTable
//
//  Purpose:    Deletes a hash table
//
//  Parameters: pHashTable   -  Hash table to delete
//
//*************************************************************

void FreeHashTable( REGHASHTABLE *pHashTable )
{
    DWORD i;

    if ( pHashTable == NULL )
        return;

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {
        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];

        while ( pKeyEntry ) {
            REGKEYENTRY *pNext = pKeyEntry->pNext;
            FreeRegKeyEntry( pKeyEntry );
            pKeyEntry = pNext;
        }
    }
}


//*************************************************************
//
//  AllocRegKey
//
//  Purpose:    Allocates a new registry key entry
//
//  Returns:    Pointer to registr key entry
//
//*************************************************************

REGKEYENTRY * AllocRegKeyEntry( WCHAR *pwszKeyName )
{
    REGKEYENTRY *pKeyEntry = (REGKEYENTRY *) LocalAlloc (LPTR, sizeof(REGKEYENTRY));
    if ( pKeyEntry == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocRegKeyEntry: Failed to alloc key entry.")));
        return NULL;
    }

    DWORD dwKeyNameLength = lstrlen(pwszKeyName) + 1;
    pKeyEntry->pwszKeyName = (WCHAR *) LocalAlloc (LPTR, ( dwKeyNameLength ) * sizeof(WCHAR));

    if ( pKeyEntry->pwszKeyName == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocRegKeyEntry: Failed to alloc key name.")));
        LocalFree( pKeyEntry );
        return NULL;
    }

    HRESULT hr = StringCchCopy( pKeyEntry->pwszKeyName, dwKeyNameLength, pwszKeyName );

    if(FAILED(hr)){
        LocalFree( pKeyEntry->pwszKeyName );
        LocalFree( pKeyEntry );
        return NULL;
    }

    return pKeyEntry;
}


//*************************************************************
//
//  FreeRegKeyEntry
//
//  Purpose:    Deletes a registry key entry
//
//  Parameters: pKeyEntry   -  Entry to delete
//
//*************************************************************

void FreeRegKeyEntry( REGKEYENTRY *pKeyEntry )
{
    REGVALUEENTRY *pValueEntry = NULL;

    if ( pKeyEntry == NULL )
        return;

    LocalFree( pKeyEntry->pwszKeyName );

    pValueEntry = pKeyEntry->pValueList;
    while ( pValueEntry ) {
        REGVALUEENTRY *pNext = pValueEntry->pNext;
        FreeValueEntry( pValueEntry );
        pValueEntry = pNext;
    }

    LocalFree( pKeyEntry );
}


//*************************************************************
//
//  AllocValueEntry
//
//  Purpose:    Allocates a new value entry
//
//  Returns:    Pointer to value entry
//
//*************************************************************

REGVALUEENTRY *AllocValueEntry( WCHAR *pwszValueName )
{
    REGVALUEENTRY *pValueEntry = (REGVALUEENTRY *) LocalAlloc (LPTR, sizeof(REGVALUEENTRY));
    if ( pValueEntry == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocValueEntry: Failed to alloc value entry.")));
        return NULL;
    }

    DWORD dwValNameLength = lstrlen(pwszValueName) + 1;
    pValueEntry->pwszValueName = (WCHAR *) LocalAlloc (LPTR, ( dwValNameLength ) * sizeof(WCHAR));

    if ( pValueEntry->pwszValueName == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocValueEntry: Failed to alloc key name.")));
        LocalFree( pValueEntry );
        return NULL;
    }

    HRESULT hr = StringCchCopy( pValueEntry->pwszValueName, dwValNameLength, pwszValueName );

    if(FAILED(hr)){
        LocalFree( pValueEntry->pwszValueName );
        LocalFree( pValueEntry );
        return NULL;
    }

    return pValueEntry;
}


//*************************************************************
//
//  FreeValueEntry
//
//  Purpose:    Deletes a value entry
//
//  Parameters: pValueEntry   -  Entry to delete
//
//*************************************************************

void FreeValueEntry( REGVALUEENTRY *pValueEntry )
{
    REGDATAENTRY *pDataEntry = NULL;

    if ( pValueEntry == NULL )
        return;

    LocalFree( pValueEntry->pwszValueName );

    pDataEntry = pValueEntry->pDataList;
    while ( pDataEntry ) {
        REGDATAENTRY *pNext = pDataEntry->pNext;
        FreeDataEntry( pDataEntry );
        pDataEntry = pNext;
    }

    LocalFree( pValueEntry );
}



//*************************************************************
//
//  AllocDataEntry
//
//  Purpose:    Allocates a new data entry
//
//  Returns:    Pointer to data entry
//
//*************************************************************

REGDATAENTRY * AllocDataEntry( REGOPERATION opnType,
                               DWORD dwType,
                               DWORD dwLen,
                               BYTE *pData,
                               WCHAR *pwszGPO,
                               WCHAR *pwszSOM,
                               WCHAR *pwszCommand)
{
    BOOL bResult = FALSE;
    
    REGDATAENTRY *pDataEntry = (REGDATAENTRY *) LocalAlloc (LPTR, sizeof(REGDATAENTRY));
    if ( pDataEntry == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc data entry.")));
        return NULL;
    }

    if ( opnType == REG_ADDVALUE )
        pDataEntry->bDeleted = FALSE;
    else
        pDataEntry->bDeleted = TRUE;

    pDataEntry->bAdmPolicy = FALSE;
    pDataEntry->dwValueType = dwType;
    pDataEntry->dwDataLen = dwLen;

    if ( pData ) {
        pDataEntry->pData = (BYTE *) LocalAlloc (LPTR, dwLen);
        if ( pDataEntry->pData == NULL ) {
            DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc data.")));
            goto Exit;
        }

        CopyMemory( pDataEntry->pData, pData, dwLen );
    }

    DmAssert( pwszGPO != NULL && pwszSOM != NULL );
    
    DWORD dwGPOLength = lstrlen(pwszGPO) + 1;
    pDataEntry->pwszGPO = (WCHAR *) LocalAlloc (LPTR, ( dwGPOLength ) * sizeof(WCHAR));

    if ( pDataEntry->pwszGPO == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc Gpo name.")));
        goto Exit;
    }

    HRESULT hr = StringCchCopy( pDataEntry->pwszGPO, dwGPOLength, pwszGPO );

    if(FAILED(hr))
        goto Exit;

    DWORD dwSOMLength = lstrlen(pwszSOM) + 1;
    pDataEntry->pwszSOM = (WCHAR *) LocalAlloc (LPTR, ( dwSOMLength ) * sizeof(WCHAR));

    if ( pDataEntry->pwszSOM == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    hr = StringCchCopy( pDataEntry->pwszSOM, dwSOMLength, pwszSOM );

    if(FAILED(hr))
        goto Exit;

    DWORD dwCmdLength = lstrlen(pwszCommand) + 1;
    pDataEntry->pwszCommand = (WCHAR *) LocalAlloc (LPTR, ( dwCmdLength ) * sizeof(WCHAR));

    if ( pDataEntry->pwszCommand == NULL ) {
        DebugMsg((DM_WARNING, TEXT("AllocDataEntry: Failed to alloc Sdou name.")));
        goto Exit;
    }

    hr = StringCchCopy( pDataEntry->pwszCommand, dwCmdLength, pwszCommand );

    if(FAILED(hr))
        goto Exit;

    bResult = TRUE;

Exit:

    if ( !bResult ) {
        LocalFree( pDataEntry->pData );
        LocalFree( pDataEntry->pwszGPO );
        LocalFree( pDataEntry->pwszSOM );
        if (pDataEntry->pwszCommand)
            LocalFree(pDataEntry->pwszCommand);
        LocalFree( pDataEntry);
        return NULL;
    }

    return pDataEntry;

}


//*************************************************************
//
//  FreeDataEntry
//
//  Purpose:    Deletes a data entry
//
//  Parameters: pDataEntry   -  Entry to delete
//
//*************************************************************

void FreeDataEntry( REGDATAENTRY *pDataEntry )
{
    if ( pDataEntry ) {
        LocalFree( pDataEntry->pData );
        LocalFree( pDataEntry->pwszGPO );
        LocalFree( pDataEntry->pwszSOM );
        LocalFree( pDataEntry);
    }
}



//*************************************************************
//
//  Hash
//
//  Purpose:    Maps a key name to a hash bucket
//
//  Parameters: pwszName   -  Key name
//
//  Returns:    Hash bucket
//
//*************************************************************

DWORD Hash( WCHAR *pwszName )
{
    DWORD dwLen = lstrlen( pwszName );
    DWORD dwHashValue = 0;

    for ( ; dwLen>0; pwszName++ ) {
        dwHashValue = toupper(*pwszName) + 31 * dwHashValue;
        dwLen--;
    }

    return dwHashValue % HASH_TABLE_SIZE;
}


//*************************************************************
//
//  AddRegHashEntry
//
//  Purpose:    Adds a registry key to the hash table
//
//  Parameters: pwszName   -  Key name
//
//*************************************************************

BOOL AddRegHashEntry( REGHASHTABLE *pHashTable,
                      REGOPERATION opnType,
                      WCHAR *pwszKeyName,
                      WCHAR *pwszValueName,
                      DWORD dwType,
                      DWORD dwDataLen,
                      BYTE *pData,
                      WCHAR *pwszGPO,
                      WCHAR *pwszSOM,
                      WCHAR *szCommand,
                      BOOL   bCreateCommand)
{
    REGVALUEENTRY *pValueEntry = NULL;
    BOOL bResult = FALSE;
    REGKEYENTRY *pKeyEntry=NULL;
    
    
    switch (opnType) {

    case REG_DELETEKEY:
        bResult = DeleteRegTree( pHashTable, pwszKeyName, pwszGPO, pwszSOM, szCommand );
        break;
        
    case REG_INTERNAL_DELETESINGLEKEY:
    case REG_DELETEALLVALUES:
    
        pKeyEntry = FindRegKeyEntry( pHashTable,
                                     pwszKeyName,
                                     FALSE );
        if ( pKeyEntry == NULL ) {

            //
            // Delete all values is similar to policy being disabled and
            // so do nothing. 
            //

            if (opnType == REG_DELETEALLVALUES) {
                bResult = TRUE;
                break;
            }
            else
                // no command entry in this case.
                return TRUE;
        }

        pValueEntry = pKeyEntry->pValueList;
        while ( pValueEntry ) {

            if (lstrcmp(pValueEntry->pwszValueName, TEXT("")) != 0) {

                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, pValueEntry->pwszValueName, -1, STARCOMMAND, -1) != CSTR_EQUAL) {
                

                    //
                    // Mark the value as deleted
                    //
                    
                    bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
                                            pwszGPO, pwszSOM, szCommand );
                    if ( !bResult )
                        return FALSE;
                }
            }
            else {

                //
                // Mark the key as deleted
                //
                
                if (opnType == REG_INTERNAL_DELETESINGLEKEY) {
                    bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
                                            pwszGPO, pwszSOM, szCommand );
                    if ( !bResult )
                        return FALSE;
                }                        
            }
            
            pValueEntry = pValueEntry->pNext;
        }

        bResult = TRUE;

        break;
        
    case REG_ADDVALUE:
    case REG_SOFTADDVALUE:

        //
        // We have to make a value with no name to represent the creation of key itself..
        //
    
        pValueEntry = FindValueEntry( pHashTable, pwszKeyName,
                                      TEXT(""), TRUE );
        if ( pValueEntry == NULL )
            return FALSE;

        bResult = AddDataEntry( pValueEntry, opnType, 0, 0, NULL,
                                pwszGPO, pwszSOM, szCommand );


        if (!bResult)
            return FALSE;
            
        if ((!pwszValueName) || (!(*pwszValueName)) || 
                (dwDataLen == 0) || (dwType == REG_NONE)) 
            break;                                

    // fall through
    
    case REG_DELETEVALUE:
        pValueEntry = FindValueEntry( pHashTable, pwszKeyName,
                                      pwszValueName, TRUE );
        if ( pValueEntry == NULL )
            return FALSE;


        //
        // In case of SOFTADDVALUE the final decision to add the value is made in
        // AddDataEntry
        //
        
        bResult = AddDataEntry( pValueEntry, opnType, dwType, dwDataLen, pData,
                                pwszGPO, pwszSOM, szCommand );

        break;
    default:
        DmAssert(FALSE && "Unknown Case Selector for AddRegHashEntry");
    }


    DmAssert(szCommand);

    //
    // If everything succeeded, then log the command if
    // bCreateCommand is true. This is done creating or adding
    // to a value called **Command. This means that this value is not
    // Settable by adm file..
    //
    
    if ((bResult) && (bCreateCommand) && (opnType != REG_INTERNAL_DELETESINGLEKEY) && (*szCommand != TEXT('\0'))) {
        pValueEntry = FindValueEntry( pHashTable, pwszKeyName,
                                      STARCOMMAND, TRUE );
                                      
        if ( pValueEntry == NULL )
            return FALSE;

        bResult = AddDataEntry( pValueEntry, REG_ADDVALUE, 0, 
                                sizeof(TCHAR)*(lstrlen(szCommand)+1), (BYTE *)szCommand,
                                pwszGPO, pwszSOM, szCommand);    
    }


    return bResult;
}


//*************************************************************
//
//  DeleteRegTree
//
//  Purpose:    Deletes a key and all its subkeys
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to delete
//              pwszGPO      -   Gpo
//              pwszSOM      -   Sdou that the Gpo is linked to
//
//*************************************************************

BOOL DeleteRegTree( REGHASHTABLE *pHashTable,
                    WCHAR *pwszKeyName,
                    WCHAR *pwszGPO,
                    WCHAR *pwszSOM,
                    WCHAR *szCommand)
{
    DWORD i=0;
    DWORD dwKeyLen = lstrlen( pwszKeyName );

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {

        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
        while ( pKeyEntry ) {

            BOOL bAdd = FALSE;
            DWORD dwKeyLen2  = lstrlen(pKeyEntry->pwszKeyName);

            if ( dwKeyLen2 >= dwKeyLen
                 && CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                   pKeyEntry->pwszKeyName, dwKeyLen,
                                   pwszKeyName, dwKeyLen ) == CSTR_EQUAL) {

                //
                // It's a prefix if length and strings match, or if one
                // string is bigger and there is a '\' at the right place.
                //

                if ( dwKeyLen2 > dwKeyLen ) {

                    if ( pKeyEntry->pwszKeyName[dwKeyLen] == L'\\' ) 
                        bAdd = TRUE;
                } else
                    bAdd = TRUE;

                if ( bAdd ) {
                    BOOL bResult = AddRegHashEntry( pHashTable,
                                                    REG_INTERNAL_DELETESINGLEKEY,
                                                    pKeyEntry->pwszKeyName,
                                                    NULL, 0, 0, NULL,
                                                    pwszGPO, pwszSOM, szCommand, FALSE );
                    if ( !bResult )
                        return FALSE;
                }

            }   // if dwKeyLen2 >= dwKeyLen

            pKeyEntry = pKeyEntry->pNext;

        }   // while

    }   // for

    return TRUE;
}


//*************************************************************
//
//  FindRegKeyEntry
//
//  Purpose:    Looks up a reg key entry in hash table
//
//  Parameters: pHashTable   -   Hash table
//              pwszKeyName  -   Key name to find
//              bCreate      -   Should key be created if not found ?
//
//*************************************************************

REGKEYENTRY * FindRegKeyEntry( REGHASHTABLE *pHashTable,
                               WCHAR *pwszKeyName,
                               BOOL bCreate )
{
    DWORD dwHashValue = Hash( pwszKeyName );
    REGKEYENTRY *pCurPtr = pHashTable->aHashTable[dwHashValue];
    REGKEYENTRY *pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszKeyName, -1,
                                     pCurPtr->pwszKeyName, -1 );

        if ( iResult  == CSTR_EQUAL ) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( pwszKeyName );
                if ( pKeyEntry == NULL )
                    return 0;

                pKeyEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pHashTable->aHashTable[dwHashValue] = pKeyEntry;
                else
                    pTrailPtr->pNext = pKeyEntry;

                return pKeyEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {
        REGKEYENTRY *pKeyEntry = AllocRegKeyEntry( pwszKeyName );
        if ( pKeyEntry == NULL )
            return 0;

        pKeyEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pHashTable->aHashTable[dwHashValue] = pKeyEntry;
        else
            pTrailPtr->pNext = pKeyEntry;

        return pKeyEntry;
    }

    return NULL;
}


//*************************************************************
//
//  FindValueEntry
//
//  Purpose:    Looks up a value entry in hash table
//
//  Parameters: pHashTable    -   Hash table
//              pwszKeyName   -   Key name to find
//              pwszValueName -   Value name to find
//              bCreate       -   Should key be created if not found ?
//
//*************************************************************

REGVALUEENTRY * FindValueEntry( REGHASHTABLE *pHashTable,
                                WCHAR *pwszKeyName,
                                WCHAR *pwszValueName,
                                BOOL bCreate )
{
    REGVALUEENTRY *pCurPtr = NULL;
    REGVALUEENTRY *pTrailPtr = NULL;

    REGKEYENTRY *pKeyEntry = FindRegKeyEntry( pHashTable, pwszKeyName, bCreate );
    if ( pKeyEntry == NULL )
        return NULL;

    pCurPtr = pKeyEntry->pValueList;
    pTrailPtr = NULL;

    while ( pCurPtr != NULL ) {

        INT iResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                     pwszValueName, -1,
                                     pCurPtr->pwszValueName, -1 );

        if ( iResult  == CSTR_EQUAL ) {
            return pCurPtr;
        } else if ( iResult == CSTR_LESS_THAN ) {

            //
            // Keys are in ascending order, so insert if bCreate
            //

            if ( bCreate ) {

                REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
                if ( pValueEntry == NULL )
                    return 0;

                pValueEntry->pNext = pCurPtr;
                if ( pTrailPtr == NULL )
                    pKeyEntry->pValueList = pValueEntry;
                else
                    pTrailPtr->pNext = pValueEntry;

                return pValueEntry;

            } else
                return NULL;

        } else {

            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;

        }

    }

    //
    // End of list or null list case
    //

    if ( bCreate ) {

        REGVALUEENTRY *pValueEntry = AllocValueEntry( pwszValueName );
        if ( pValueEntry == NULL )
            return 0;

        pValueEntry->pNext = 0;
        if ( pTrailPtr == NULL )
            pKeyEntry->pValueList = pValueEntry;
        else
            pTrailPtr->pNext = pValueEntry;

        return pValueEntry;
    }

    return NULL;
}



//*************************************************************
//
//  AddDataEntry
//
//  Purpose:    Adds a data entry to a value entry struct
//
//  Parameters: pValueEntry   - Value entry
//              opnType       - Operation type
//              dwType        - Type of registry data
//              dwLen         - Length of registry data
//              pData         - Data
//              pwszGPO       - Gpo that set this value
//              pwszSOM       - Sdou that the Gpo is linked to
//
//*************************************************************

BOOL AddDataEntry( REGVALUEENTRY *pValueEntry,
                   REGOPERATION opnType,
                   DWORD dwType,
                   DWORD dwLen,
                   BYTE *pData,
                   WCHAR *pwszGPO,
                   WCHAR *pwszSOM,
                   WCHAR *pwszCommand)
{
    REGDATAENTRY *pDataEntry = NULL; 

    if (opnType == REG_SOFTADDVALUE) {

        //
        // if the data list is null or if the first value (highest precedence value is deleted)
        // then add it to the list
        //
        
        if ((pValueEntry->pDataList == NULL) || (pValueEntry->pDataList->pNext->bDeleted))         
            opnType = REG_ADDVALUE;
        else
            return TRUE;
            // return without adding the value.
    }


    pDataEntry = AllocDataEntry( opnType, dwType, dwLen, pData,
                                               pwszGPO, pwszSOM, pwszCommand );
    if ( pDataEntry == NULL )
        return FALSE;
    
    //
    // Prepend to data list because entries at beginning of list have higher precedence
    //

    pDataEntry->pNext = pValueEntry->pDataList;
    pValueEntry->pDataList = pDataEntry;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\applygp\test.c ===
#include <windows.h>
#include <userenv.h>
#include <userenvp.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    HANDLE hEvent;


    OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

    hEvent = CreateEvent (NULL, TRUE, FALSE, TEXT("some event"));

    ApplyGroupPolicy (GP_APPLY_DS_POLICY | GP_BACKGROUND_REFRESH, hToken, hEvent, HKEY_CURRENT_USER, NULL);

    for (;;) ;

    CloseHandle (hEvent);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\rsop.cpp ===
//*************************************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#include "uenv.h"
#include "wbemcli.h"
#include "reghash.h"
#include "rsop.h"
#include "logger.h"
#include "RsopInc.h"
#include "rsopsec.h"
#include "locator.h"
#include <strsafe.h>

BOOL DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices );
BOOL ConnectToNameSpace(LPGPOINFO lpGPOInfo, WCHAR *pwszRootNameSpace,
                        BOOL bPlanningMode, IWbemLocator *pWbemLocator, 
                        IWbemServices **ppWbemServices, BOOL *pbCreated);
HRESULT
CreateCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid,
                            LPWSTR          szEventLogSources );

HRESULT
DeleteCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid );

//*************************************************************
//
//  GetWbemServices()
//
//  Purpose:    Returns IWbemServices ptr to namespace
//
//  Parameters: lpGPOInfo     - Gpo info
//              pwszNameSpace - namespace
//              bPlanningMode - Is this called during planning mode ?
//
//  Return:     True if successful
//
//*************************************************************

BOOL GetWbemServices( LPGPOINFO lpGPOInfo,
                      WCHAR *pwszRootNameSpace,
                      BOOL bPlanningMode,
                      BOOL *bCreated,
                      IWbemServices **ppWbemServices)
{
    HRESULT hr;

    OLE32_API *pOle32Api = LoadOle32Api();
    if ( pOle32Api == NULL )
        return FALSE;


    IWbemLocator *pWbemLocator = NULL;
    hr = pOle32Api->pfnCoCreateInstance( CLSID_WbemLocator,
                                         NULL,
                                         CLSCTX_INPROC_SERVER,
                                         IID_IWbemLocator,
                                         (LPVOID *) &pWbemLocator );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("GetWbemServices: CoCreateInstance returned 0x%x"), hr));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetWbemServices: CoCreateInstance succeeded")));

    XInterface<IWbemLocator> xLocator( pWbemLocator );

    //
    // get the appropriate name space and connect
    //

    
    if (!ConnectToNameSpace( lpGPOInfo, pwszRootNameSpace, bPlanningMode, pWbemLocator, ppWbemServices, bCreated)) {
        DebugMsg((DM_WARNING, TEXT("GetWbemServices: ConnectToNameSpace failed with 0x%x" ), GetLastError()));
        return FALSE;
    }

    
    return TRUE;
}



//*************************************************************
//
//  ReleaseWbemServices()
//
//  Purpose:    Releases wbem service pointer
//
//  Parameters: lpGPOInfo - Gpo info
//
//*************************************************************

void ReleaseWbemServices( LPGPOINFO lpGPOInfo )
{
    if ( lpGPOInfo->pWbemServices ) {
        lpGPOInfo->pWbemServices->Release();
        lpGPOInfo->pWbemServices = NULL;
    }
}



//*************************************************************
//
//  LogRsopData()
//
//  Purpose:    Logs Rsop data to Cimom database
//
//  Parameters: lpGPOInfo  - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************
BOOL LogRsopData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData )
{
    HRESULT hr;

    if ( lpGPOInfo->pWbemServices  == NULL ) {
         DebugMsg((DM_WARNING, TEXT("LogRsopData: Null wbem services pointer, so cannot log Rsop data" )));
         return FALSE;
    }

    if ( !LogSessionData( lpGPOInfo, lprsopSessionData ) )
        return FALSE;

    if ( !LogSOMData( lpGPOInfo ) )
        return FALSE;

    if ( !LogGpoData( lpGPOInfo ) )
        return FALSE;

    if ( !LogGpLinkData( lpGPOInfo ) )
        return FALSE;

    DebugMsg((DM_VERBOSE, TEXT("LogRsopData: Successfully logged Rsop data" )));

    return TRUE;
}

//*************************************************************
//
//  LogSessionData()
//
//  Purpose:    Logs scopes of management data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogSessionData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData )
{
    CSessionLogger sessionLogger( lpGPOInfo->pWbemServices );
    if ( !sessionLogger.Log(lprsopSessionData) )
        return FALSE;

    return TRUE;
}


//*************************************************************
//
//  LogSOMData()
//
//  Purpose:    Logs scopes of management data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogSOMData( LPGPOINFO lpGPOInfo )
{
    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;

    if ( !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ) {

        //
        // Clean up SOM data at foreground refresh only. Otherwise extensions that run in
        // foreground only may have policy data that have dangling references to SOM that
        // existed at foreground refresh time.
        //

        if ( !DeleteInstances( L"RSOP_SOM", pWbemServices ) )
            return FALSE;
    }

    DWORD dwOrder = 1;
    CSOMLogger somLogger( lpGPOInfo->dwFlags, pWbemServices );

    LPSCOPEOFMGMT pSOMList = lpGPOInfo->lpSOMList;
    while ( pSOMList ) {

        if ( !somLogger.Log( pSOMList, dwOrder, FALSE ) )
             return FALSE;

        dwOrder++;
        pSOMList = pSOMList->pNext;
    }

    pSOMList = lpGPOInfo->lpLoopbackSOMList;
    while ( pSOMList ) {

        if ( !somLogger.Log( pSOMList, dwOrder, TRUE ) )
             return FALSE;

        dwOrder++;
        pSOMList = pSOMList->pNext;
    }

    return TRUE;
}

//*************************************************************
//
//  LogGpoData()
//
//  Purpose:    Logs GPO data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogGpoData( LPGPOINFO lpGPOInfo )
{
    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;

    if ( !(lpGPOInfo->dwFlags & GP_BACKGROUND_THREAD) ) {

        //
        // Clean up SOM data at foreground refresh only. Otherwise extensions that run in
        // foreground only may have policy data that have dangling references to SOM that
        // existed at foreground refresh time.
        //

        if ( !DeleteInstances( L"RSOP_GPO", pWbemServices ) )
            return FALSE;
    }

    CGpoLogger gpoLogger( lpGPOInfo->dwFlags, pWbemServices );

    GPCONTAINER *pGpContainer = lpGPOInfo->lpGpContainerList;
    while ( pGpContainer ) {
        if ( !gpoLogger.Log( pGpContainer ) )
            return FALSE;

        pGpContainer = pGpContainer->pNext;
    }

    pGpContainer = lpGPOInfo->lpLoopbackGpContainerList;
    while ( pGpContainer ) {
        if ( !gpoLogger.Log( pGpContainer ) )
            return FALSE;

        pGpContainer = pGpContainer->pNext;
    }

    return TRUE;
}


//*************************************************************
//
//  FindGPO()
//
//  Purpose:    Finds order of GPO in SOM
//
//  Parameters: pSOM  - SOM
//              pGPO  - GPO
//
//  Return:     Order #
//
//*************************************************************

DWORD FindGPO( LPEXTFILTERLIST pGPOFilterList, LPSCOPEOFMGMT pSOM, GPLINK *pGpLink )
{
    DWORD dwOrder = 1;
    WCHAR *pwszLinkGPOPath = StripLinkPrefix( pGpLink->pwszGPO );
    WCHAR *pwszLinkSOMPath = StripLinkPrefix( pSOM->pwszSOMId );
    
    //
    // If the SOM is blocked then the GPO is linked here
    // only if the GPO is forced
    //

    if ( pSOM->bBlocked && !pGpLink->bNoOverride ) 
        return 0;

    while ( pGPOFilterList )
    {
        WCHAR *pwszAppliedGPOPath = StripPrefix( pGPOFilterList->lpGPO->lpDSPath );
        WCHAR *pwszAppliedGPOSomPath = StripLinkPrefix( pGPOFilterList->lpGPO->lpLink );

        if ( !pGPOFilterList->bLogged && 
             (CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, pwszLinkGPOPath, -1,
                             pwszAppliedGPOPath, -1 ) == CSTR_EQUAL) && 
             (CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, pwszLinkSOMPath, -1,
                             pwszAppliedGPOSomPath, -1 ) == CSTR_EQUAL))
        {
            pGPOFilterList->bLogged = TRUE;
            return dwOrder;
        }

        pGPOFilterList = pGPOFilterList->pNext;
        dwOrder++;
    }

    return 0;
}

void
ClearLoggedFlag( LPEXTFILTERLIST pGPOFilterList )
{
    while ( pGPOFilterList )
    {
        pGPOFilterList->bLogged = FALSE;
        pGPOFilterList = pGPOFilterList->pNext;
    }
}


//*************************************************************
//
//  LogGpLinkData()
//
//  Purpose:    Logs GPLINK data
//
//  Parameters: lpGPOInfo     - Gpo Info
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogGpLinkData( LPGPOINFO lpGPOInfo )
{
    IWbemServices *pWbemServices = lpGPOInfo->pWbemServices;
    DWORD          dwListOrder = 1;
    DWORD          dwAppliedOrder = 1;

    if ( !DeleteInstances( L"RSOP_GPLink", pWbemServices ) )
         return FALSE;

    CGpLinkLogger gpLinkLogger( pWbemServices );

    // The GPO application order
    LPEXTFILTERLIST pFilterList = lpGPOInfo->lpExtFilterList;
    
    ClearLoggedFlag( pFilterList );
    // the function takes care of Null list.


    //
    // Normal case
    //

    SCOPEOFMGMT *pSOMList = lpGPOInfo->lpSOMList;
    while ( pSOMList ) {

        GPLINK *pGpLinkList = pSOMList->pGpLinkList;
        DWORD dwSomOrder = 1;

        while ( pGpLinkList ) {

            dwAppliedOrder = FindGPO( pFilterList, pSOMList, pGpLinkList );
           
            if ( !gpLinkLogger.Log( pSOMList->pwszSOMId, FALSE, pGpLinkList, dwSomOrder, dwListOrder, dwAppliedOrder ) )
                 return FALSE;

            pGpLinkList = pGpLinkList->pNext;
            dwSomOrder++;
            dwListOrder++;
        }

        pSOMList = pSOMList->pNext;
    }


    //
    // Loopback case
    //

    pSOMList = lpGPOInfo->lpLoopbackSOMList;
    while ( pSOMList ) {

        GPLINK *pGpLinkList = pSOMList->pGpLinkList;
        DWORD dwSomOrder = 1;

        while ( pGpLinkList ) {

            //
            // If the SOM is blocked then the GPO is linked here
            // only if the GPO is forced
            //

            dwAppliedOrder = FindGPO( pFilterList, pSOMList, pGpLinkList );
           
            if ( !gpLinkLogger.Log( pSOMList->pwszSOMId, TRUE, pGpLinkList, dwSomOrder, dwListOrder, dwAppliedOrder ) )
                 return FALSE;

            pGpLinkList = pGpLinkList->pNext;
            dwSomOrder++;
            dwListOrder++;
        }

        pSOMList = pSOMList->pNext;
    }

    return TRUE;
}


//*************************************************************
//
//  DeleteInstaces()
//
//  Purpose:    Deletes all instances of a specified class
//
//  Parameters: pwszClass     - Class name
//              pWbemServices - Wbem services
//
//  Return:     True if successful
//
//*************************************************************

BOOL DeleteInstances( WCHAR *pwszClass, IWbemServices *pWbemServices )
{
    IEnumWbemClassObject *pEnum = NULL;

    XBStr xbstrClass( pwszClass );
    if ( !xbstrClass ) {
        DebugMsg((DM_WARNING, TEXT("DeleteInstances: Failed to allocate memory" )));
        return FALSE;
    }

    HRESULT hr = pWbemServices->CreateInstanceEnum( xbstrClass,
                                                    WBEM_FLAG_SHALLOW,
                                                    NULL,
                                                    &pEnum );
    if ( FAILED(hr) ) {
        DebugMsg((DM_WARNING, TEXT("DeleteInstances: DeleteInstances failed with 0x%x" ), hr ));
        return FALSE;
    }

    XInterface<IEnumWbemClassObject> xEnum( pEnum );

    XBStr xbstrPath( L"__PATH" );
    if ( !xbstrPath ) {
        DebugMsg((DM_WARNING, TEXT("DeleteInstances: Failed to allocate memory" )));
        return FALSE;
    }

    IWbemClassObject *pInstance = NULL;
    ULONG ulReturned = 1;
    LONG TIMEOUT = -1;

    while ( ulReturned == 1 ) {

        hr = pEnum->Next( TIMEOUT,
                          1,
                          &pInstance,
                          &ulReturned );
        if ( hr == S_OK && ulReturned == 1 ) {

            XInterface<IWbemClassObject> xInstance( pInstance );

            VARIANT var;
            VariantInit( &var );

            hr = pInstance->Get( xbstrPath,
                                 0L,
                                 &var,
                                 NULL,
                                 NULL );
            if ( FAILED(hr) ) {
                 DebugMsg((DM_WARNING, TEXT("DeleteInstances: Get failed with 0x%x" ), hr ));
                 return FALSE;
            }

            hr = pWbemServices->DeleteInstance( var.bstrVal,
                                                0L,
                                                NULL,
                                                NULL );
            VariantClear( &var );

            if ( FAILED(hr) ) {
                 DebugMsg((DM_WARNING, TEXT("DeleteInstances: DeleteInstance failed with 0x%x" ), hr ));
                 return FALSE;
            }

        }
    }

    return TRUE;

}




//*************************************************************
//
//  LogRegistryRsopData()
//
//  Purpose:    Logs registry Rsop data to Cimom database
//
//  Parameters: dwFlags       - Gpo Info flags
//              pHashTable    - Hash table with registry policy data
//              pWbemServices - Namespace pointer for logging
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogRegistryRsopData( DWORD dwFlags, REGHASHTABLE *pHashTable, IWbemServices *pWbemServices )
{
    HRESULT hr;
    DWORD i;

    if ( !DeleteInstances( L"RSOP_RegistryPolicySetting", pWbemServices ) )
         return FALSE;

    CRegistryLogger regLogger( dwFlags, pWbemServices );

    for ( i=0; i<HASH_TABLE_SIZE; i++ ) {

        REGKEYENTRY *pKeyEntry = pHashTable->aHashTable[i];
        while ( pKeyEntry ) {

            WCHAR *pwszKeyName = pKeyEntry->pwszKeyName;
            REGVALUEENTRY *pValueEntry = pKeyEntry->pValueList;

            while ( pValueEntry ) {

                DWORD dwOrder = 1;
                WCHAR *pwszValueName = pValueEntry->pwszValueName;
                REGDATAENTRY *pDataEntry = pValueEntry->pDataList;

                while ( pDataEntry ) {
                    if ( !regLogger.Log( pwszKeyName,
                                         pwszValueName,
                                         pDataEntry,
                                         dwOrder ) )
                        return FALSE;

                    pDataEntry = pDataEntry->pNext;
                    dwOrder++;
                }

                pValueEntry = pValueEntry->pNext;

            }   // while pValueEntry

            pKeyEntry = pKeyEntry->pNext;

        }   // while pKeyEntry

    }   // for

    DebugMsg((DM_VERBOSE, TEXT("LogRegistry RsopData: Successfully logged registry Rsop data" )));

    return TRUE;
}



//*************************************************************
//
//  LogAdmRsopData()
//
//  Purpose:    Logs Rsop ADM template data to Cimom database
//
//  Parameters: pAdmFileCache - List of adm file to log
//              pWbemServices - Namespace pointer
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogAdmRsopData( ADMFILEINFO *pAdmFileCache, IWbemServices *pWbemServices )
{
    if ( !DeleteInstances( L"RSOP_AdministrativeTemplateFile", pWbemServices ) )
         return FALSE;

    CAdmFileLogger admLogger( pWbemServices );

    while ( pAdmFileCache ) {
        if ( !admLogger.Log( pAdmFileCache ) )
             return FALSE;

        pAdmFileCache = pAdmFileCache->pNext;
    }

    DebugMsg((DM_VERBOSE, TEXT("LogAdmRsopData: Successfully logged Adm data" )));

    return TRUE;
}



//*************************************************************
//
//  LogExtSessionStatus()
//
//  Purpose:    Logs ExtensionSessionStatus at the beginning of processing
//
//  Parameters: pWbemServices - Namespace pointer
//              lpExt         - Extension description
//              bSupported    - Rsop Logging Supported
//
//  Return:     True if successful
//
//*************************************************************

BOOL LogExtSessionStatus(IWbemServices *pWbemServices, LPGPEXT lpExt, BOOL bSupported, BOOL bLogEventSrc )
{
    CExtSessionLogger extLogger( pWbemServices );

    if (!extLogger.Log(lpExt, bSupported))
        return FALSE;

    if ( !bLogEventSrc )
    {
        return TRUE;
    }

    HRESULT hr;

    if ( lpExt )
    {
        hr = DeleteCSE_EventSourceAssoc(pWbemServices,
                                        lpExt->lpKeyName );
        if ( FAILED( hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: DeleteCSE_EventSourceAssoc failed with 0x%x" ), hr ));
            return FALSE;
        }

        if ( lpExt->szEventLogSources )
        {
            if ( lpExt->lpKeyName )
            {
                //
                // good CSE
                //
                hr = CreateCSE_EventSourceAssoc(pWbemServices,
                                                lpExt->lpKeyName,
                                                lpExt->szEventLogSources );
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: CreateCSEEventSourceNameAssoc failed with 0x%x" ), hr ));
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            //
            // most likely the Registry CSE
            //
            if ( !lpExt->lpDllName || !lpExt->lpKeyName )
            {
                return FALSE;
            }
            else
            {
                WCHAR *szEventLogSources;
                ULONG ulNoChars;

                ulNoChars = lstrlen(L"(") + lstrlen(lpExt->lpDllName) + 
                            lstrlen(L",Application)") + 2;   
                // 2 nulls are added at the end of the strings

                szEventLogSources = (WCHAR *) LocalAlloc(LPTR, ulNoChars * sizeof(WCHAR));

                if (NULL == szEventLogSources) 
                {
                    DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: Could not allocate memory" )));
                    return FALSE;
                }

                hr = StringCchCopy( szEventLogSources, ulNoChars, L"(" );
                ASSERT(SUCCEEDED(hr));

                hr = StringCchCat( szEventLogSources, ulNoChars, lpExt->lpDllName );
                ASSERT(SUCCEEDED(hr));

                LPWSTR szTemp = wcsrchr( szEventLogSources, L'.' );

                if ( szTemp )
                {
                    *szTemp = 0;
                }

                // double null terminate it
               
                hr = StringCchCat( szEventLogSources, ulNoChars, L",Application)");
                ASSERT(SUCCEEDED(hr));

                szEventLogSources[lstrlen(szEventLogSources) + 1] = L'\0';

                hr = CreateCSE_EventSourceAssoc(pWbemServices,
                                                lpExt->lpKeyName,
                                                szEventLogSources );
                LocalFree(szEventLogSources);
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: CreateCSEEventSourceNameAssoc failed with 0x%x" ), hr ));
                    return FALSE;
                }
            }
        }
    }
    else
    {
        hr = DeleteCSE_EventSourceAssoc(pWbemServices,
                                        GPCORE_GUID );
        if ( FAILED( hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: DeleteCSE_EventSourceAssoc failed with 0x%x" ), hr ));
            return FALSE;
        }

        //
        // gp engine
        //
        WCHAR   szEventLogSources[] = L"(userenv,Application)\0";

        hr = CreateCSE_EventSourceAssoc(pWbemServices,
                                        GPCORE_GUID,
                                        szEventLogSources );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CExtSessionLogger::Log: CreateCSEEventSourceNameAssoc failed with 0x%x" ), hr ));
            return FALSE;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("LogExtSessionStatus: Successfully logged Extension Session data" )));

    return TRUE;
}


//*************************************************************
//
//  UpdateExtSessionStatus()
//
//  Purpose:    Updates ExtensionSessionStatus at the end of processing
//
//  Parameters: pWbemServices - Namespace pointer
//              lpKeyName     - Extension Guid Can be NULL in which case it means GPEngine
//              bDirty        - Logging was done successfully..
//              dwErr         - Error in processing
//
//  Return:     True if successful
//
//*************************************************************

BOOL UpdateExtSessionStatus(IWbemServices *pWbemServices, LPTSTR lpKeyName, BOOL bIncomplete, DWORD dwErr )
{
    CExtSessionLogger extLogger( pWbemServices );

    if (!extLogger.Update(lpKeyName, bIncomplete, dwErr))
        return FALSE;

    return TRUE;
}


//*************************************************************
//
//  DeleteExtSessionStatus()
//
//  Purpose:    Updates ExtensionSessionStatus at the end of processing
//
//  Parameters: pWbemServices - Namespace pointer
//              lpKeyName     - Extension Guid Can be NULL in which case it means GPEngine
//              bDirty        - Logging was done successfully..
//              dwErr         - Error in processing
//
//  Return:     True if successful
//
//*************************************************************

BOOL DeleteExtSessionStatus(IWbemServices *pWbemServices, LPTSTR lpKeyName)
{
    CExtSessionLogger extLogger( pWbemServices );

    if (!extLogger.Delete(lpKeyName))
        return FALSE;

    return TRUE;
}




//*************************************************************
//
//  RsopDeleteAllValues ()
//
//  Purpose:    Deletes all values under specified key
//
//  Parameters: hKey    -   Key to delete values from
//
//  Return:
//
//  Comments: Same as util.c!DeleteAllValues except that it logs
//            Data into the rsop hash table
//
//*************************************************************

BOOL RsopDeleteAllValues(HKEY hKey, REGHASHTABLE *pHashTable,
                         WCHAR *lpKeyName, WCHAR *pwszGPO, WCHAR *pwszSOM, WCHAR *szCommand, BOOL *bLoggingOk)
{
    TCHAR ValueName[2 * MAX_PATH]; 
    DWORD dwSize = 2 * MAX_PATH;
    LONG lResult;
    BOOL bFirst=TRUE;

    while (RegEnumValue(hKey, 0, ValueName, &dwSize,
            NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            lResult = RegDeleteValue(hKey, ValueName);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("RsopDeleteAllValues:  Failed to delete value <%s> with %d."), ValueName, lResult));
                return FALSE;
            } else {
                DebugMsg((DM_VERBOSE, TEXT("RsopDeleteAllValues:  Deleted <%s>"), ValueName));
            }


            *bLoggingOk = AddRegHashEntry( pHashTable, REG_DELETEVALUE, lpKeyName,
                                          ValueName, 0, 0, NULL,
                                          pwszGPO, pwszSOM, szCommand, bFirst );

            bFirst = FALSE;
            dwSize = 2 * MAX_PATH;
    }
    return TRUE;
}


//*************************************************************
//
//  SetRsopTargetName()
//
//  Purpose:    Allocates and returns the target name under which Rsop data will be logged.
//
//  Parameters: lpGPOInfo       -  GPOInfo structure
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL SetRsopTargetName(LPGPOINFO lpGPOInfo)
{
    XPtrLF<TCHAR>   xszFullName;
    XPtrLF<TCHAR>   xszTargetName;          // return value
    HANDLE          hOldToken;
    HRESULT         hr          =       S_OK;

    if ( lpGPOInfo->szName && lpGPOInfo->szTargetName )
    {
        return TRUE;
    }

    if ( lpGPOInfo->szName )
    {
        LocalFree( lpGPOInfo->szName ), lpGPOInfo->szName = NULL;
    }

    if ( lpGPOInfo->szTargetName )
    {
        LocalFree( lpGPOInfo->szTargetName ), lpGPOInfo->szTargetName = 0;
    }

    //
    // fill up the right target name
    //

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {
        if ( lpGPOInfo->dwFlags & GP_APPLY_DS_POLICY ) {
            xszFullName = MyGetComputerName (NameSamCompatible);
        }
        else {
            DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
            xszFullName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(MAX_COMPUTERNAME_LENGTH + 1));

            if (xszFullName) {
                 if (!GetComputerName(xszFullName, &dwSize)) {
                     xszFullName = NULL;
                 }
            }
        }
    }
    else {

        if (!ImpersonateUser(lpGPOInfo->hToken, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("RsopTargetName: Failed to impersonate user")));
            return FALSE;
        }

        xszFullName = MyGetUserName (NameSamCompatible);

        RevertToUser(&hOldToken);
    }


    if (!xszFullName) {
        DebugMsg((DM_WARNING, TEXT("RsopTargetName: Failed to get the %s name, error = %d"),
                    (lpGPOInfo->dwFlags & GP_MACHINE ? TEXT("Computer"): TEXT("User")), GetLastError()));
        return FALSE;
    }

    DWORD dwTgtNameLength = lstrlen(xszFullName) + 1;
    xszTargetName = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR) * ( dwTgtNameLength ));
    if (!xszTargetName)
        return FALSE;


    //
    // Format the TargetName appropriately.
    //
    // We are just going to look for the first slash if present and treat the rest of
    // it as username.
    //


    LPTSTR lpTemp = xszFullName;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;

    if ((*lpTemp) == TEXT('\\'))
        hr = StringCchCopy(xszTargetName, dwTgtNameLength, lpTemp+1);
    else
        hr = StringCchCopy(xszTargetName, dwTgtNameLength, xszFullName);

    if(FAILED(hr))
        return FALSE;
    //
    // To be consistent we will also remove the final $ in the machine name
    //

    lpTemp = xszTargetName;

    if ( lpGPOInfo->dwFlags & GP_MACHINE ) {
        if ((*lpTemp) && (lpTemp[lstrlen(lpTemp)-1] == TEXT('$')))
            lpTemp[lstrlen(lpTemp)-1] = TEXT('\0');

    }
    
    // let the structure own it
    lpGPOInfo->szTargetName = xszTargetName.Acquire();
    lpGPOInfo->szName = xszFullName.Acquire();
    
    return TRUE;
}


//*************************************************************
//
//  ConnectToNameSpace()
//
//  Purpose:    Creates (if necessary) and connects to the appropriate name space
//
//  Parameters: lpGPOInfo           -  GPOInfo structure
//              pwszRootNameSpace   -  Root name space
//              bPlanningMode       -  Is this planning mode
//              pWbemLocator        -  locator pointer
//       [out]  ppWbemServices      -  pointer to WbemServices to a connected pointer
//       [out]  pbCreated           -  Is the name space created. Optional Can be null
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL ConnectToNameSpace(LPGPOINFO lpGPOInfo, WCHAR *pwszRootNameSpace,
                        BOOL bPlanningMode, IWbemLocator *pWbemLocator, 
                        IWbemServices **ppWbemServices, BOOL *pbCreated)
{
    XPtrLF<WCHAR>               xwszNameSpace = NULL;
    XInterface<IWbemServices>   xWbemServices;
    LPTSTR                      lpEnd = NULL;
    XPtrLF<WCHAR>               xszWmiNameFromUserSid;                      
    DWORD                       dwCurrentVersion;
    HRESULT                     hr            = S_OK;

    *ppWbemServices = NULL;
    if (pbCreated)
        *pbCreated = FALSE;
    
    if (!bPlanningMode) {


        //
        // Diagnostic mode
        //
        
        if (lpGPOInfo->dwFlags & GP_MACHINE) {

            DWORD dwNSLength = lstrlen(pwszRootNameSpace) + lstrlen(RSOP_NS_DIAG_MACHINE_OFFSET) + 5;
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, ( dwNSLength )*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;

            hr = StringCchCopy(xwszNameSpace, dwNSLength, pwszRootNameSpace);

            if(FAILED(hr))
                return FALSE;

            lpEnd = CheckSlash(xwszNameSpace);

            hr = StringCchCopy(lpEnd, dwNSLength - (lpEnd - xwszNameSpace), RSOP_NS_DIAG_MACHINE_OFFSET);

            if(FAILED(hr))
                return FALSE;
        }
        else {

            xszWmiNameFromUserSid = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpGPOInfo->lpwszSidUser)+1));
            if (!xszWmiNameFromUserSid)
            {
                DebugMsg(( DM_WARNING, TEXT("ConnectToNameSpace::CreateNameSpace couldn't allocate memory with error %d"), GetLastError() ));
                return FALSE;
            }

            ConvertSidToWMIName(lpGPOInfo->lpwszSidUser, xszWmiNameFromUserSid);

            DWORD dwNSLength = lstrlen(pwszRootNameSpace) + lstrlen(RSOP_NS_DIAG_USER_OFFSET_FMT) + lstrlen(xszWmiNameFromUserSid) + 5;
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, ( dwNSLength )*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;

            hr = StringCchCopy(xwszNameSpace, dwNSLength, pwszRootNameSpace);

            if(FAILED(hr))
                return FALSE;

            lpEnd = CheckSlash(xwszNameSpace);
            
            hr = StringCchPrintf(lpEnd, dwNSLength - (lpEnd - xwszNameSpace), RSOP_NS_DIAG_USER_OFFSET_FMT, (LPWSTR) xszWmiNameFromUserSid);

            if(FAILED(hr))
                return FALSE;
        }
    }
    else {

        //
        // Planning Mode
        //
        
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
        
            //
            // Machine
            //
            
            DWORD dwNSLength = lstrlen(pwszRootNameSpace) + lstrlen(RSOP_NS_PM_MACHINE_OFFSET) + 5;
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, ( dwNSLength )*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;

            hr = StringCchCopy(xwszNameSpace, dwNSLength, pwszRootNameSpace);

            if(FAILED(hr))
                return FALSE;

            lpEnd = CheckSlash(xwszNameSpace);

            hr = StringCchCopy(lpEnd, dwNSLength - (lpEnd - xwszNameSpace), RSOP_NS_PM_MACHINE_OFFSET);

            if(FAILED(hr))
                return FALSE;
        }
        else {

            //
            // User
            //
            
            DWORD dwNSLength = lstrlen(pwszRootNameSpace) + lstrlen(RSOP_NS_PM_USER_OFFSET) + 5;
            xwszNameSpace = (LPTSTR)LocalAlloc(LPTR, ( dwNSLength )*sizeof(TCHAR));
            if (!xwszNameSpace) 
                return FALSE;

            hr = StringCchCopy(xwszNameSpace, dwNSLength, pwszRootNameSpace);

            if(FAILED(hr))
                return FALSE;

            lpEnd = CheckSlash(xwszNameSpace);

            hr = StringCchCopy(lpEnd, dwNSLength - (lpEnd - xwszNameSpace), RSOP_NS_PM_USER_OFFSET);

            if(FAILED(hr))
                return FALSE;
        }
    }


    XBStr xNameSpace( xwszNameSpace );

    hr = pWbemLocator->ConnectServer( xNameSpace,
                                    NULL,
                                    NULL,
                                    0L,
                                    0L,
                                    NULL,
                                    NULL,
                                    &xWbemServices );

    DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: ConnectServer returned 0x%x"), hr));

    if (bPlanningMode) {       
        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace: ConnectServer failed with 0x%x" ), hr ));
        }
        *ppWbemServices = xWbemServices.Acquire();
        return (SUCCEEDED(hr));
    }

    //
    // only diagnostic mode logging should reach here
    //

    if (FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: ConnectServer failed with 0x%x, trying to recreate the name space" ), hr ));

        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            return FALSE;
        }
    }


    if (SUCCEEDED(hr)) {
        
        //
        // Now check whether there is an RSOP_Session instance under this namespace
        // to set the *pbCreated flag
        //


        hr = GetRsopSchemaVersionNumber(xWbemServices, &dwCurrentVersion);


        //
        // We don't have an Rsop schema version number
        //

        if (FAILED(hr)) {
            return FALSE;
        }

        if (dwCurrentVersion == 0) {
            DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: Rsop data has not been logged before or a major schema upg happened. relogging.." )));
            if (pbCreated)
                *pbCreated = TRUE;
        }
            
        if (lpGPOInfo->dwFlags & GP_MACHINE) {
            *ppWbemServices = xWbemServices.Acquire();
            return TRUE;
        }


        if (dwCurrentVersion != RSOP_MOF_SCHEMA_VERSION) {
            BOOL bAbort = FALSE;

            DebugMsg((DM_VERBOSE, TEXT("ConnectToNameSpace: Minor schema upg happened. copying classes. " )));
            hr = CopyNameSpace(RSOP_NS_USER, xNameSpace, FALSE, &bAbort, pWbemLocator );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace: CopyNameSpace failed with 0x%x" ), hr ));
                return FALSE;
            }
        }

        *ppWbemServices = xWbemServices.Acquire();
        return TRUE;

    }    


    // Only user mode in diagnostic mode should reach here 
    // when it couldn't find the namespace
    //
    //

    DWORD          dwRootNSLength = lstrlen(pwszRootNameSpace) + lstrlen(RSOP_NS_DIAG_ROOTUSER_OFFSET) + 20;
    XPtrLF<TCHAR>  xRootNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * ( dwRootNSLength ));
    if (!xRootNameSpace) {
        // there is nothing more we can do
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace: Failed to allocate memory.3")));
        return FALSE;
    }

    hr = StringCchCopy(xRootNameSpace, dwRootNSLength, pwszRootNameSpace);

    if(FAILED(hr))
        return FALSE;

    lpEnd = CheckSlash(xRootNameSpace);
    
    hr = StringCchCopy(lpEnd, dwRootNSLength - (lpEnd - xRootNameSpace), RSOP_NS_DIAG_ROOTUSER_OFFSET);
    
    if(FAILED(hr))
        return FALSE;

    //
    // The security descriptor
    //

    XPtrLF<SID> xSid = GetUserSid(lpGPOInfo->hToken);

    if (!xSid) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace::GetUserSid failed with %d"), GetLastError()));
        return FALSE;
    }


    XPtrLF<SECURITY_DESCRIPTOR> xsd;
    SECURITY_ATTRIBUTES sa;
    CSecDesc Csd;

    Csd.AddLocalSystem(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministrators(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddNetworkService(RSOP_ALL_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddSid(xSid, RSOP_READ_PERMS, CONTAINER_INHERIT_ACE);
    Csd.AddAdministratorsAsOwner();
    Csd.AddAdministratorsAsGroup();

    xsd = Csd.MakeSelfRelativeSD();
    if (!xsd) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace::MakeselfRelativeSD failed with %d"), GetLastError()));
        return FALSE;
    }

    if (!SetSecurityDescriptorControl( (SECURITY_DESCRIPTOR *)xsd, SE_DACL_PROTECTED, SE_DACL_PROTECTED )) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace::SetSecurityDescriptorControl failed with %d"), GetLastError()));
        return FALSE;
    }

    
    hr = CreateAndCopyNameSpace(pWbemLocator,
                                xRootNameSpace,
                                xRootNameSpace, 
                                xszWmiNameFromUserSid,
                                NEW_NS_FLAGS_COPY_CLASSES,
                                xsd,
                                0);
    if ( FAILED( hr ) )
    {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace:: CreateAndCopyNameSpace failed. Error=0x%08X."), hr));
        return FALSE;                                
    }                                

    hr = pWbemLocator->ConnectServer( xNameSpace,
                                    NULL,
                                    NULL,
                                    0L,
                                    0L,
                                    NULL,
                                    NULL,
                                    &xWbemServices );


    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("ConnectToNameSpace:: ConnectServer failed. hr=0x%08X."), hr));
        return FALSE;                                
    }                                

    *ppWbemServices = xWbemServices.Acquire();
    if (pbCreated)
        *pbCreated = TRUE;
    return TRUE;    
}


//*************************************************************
//
//  RsopDeleteUserNameSpace()
//
//  Purpose:    Deletes the name space for the user.
//              This should be used with cae because it calls
//              CoInitializeEx and can have other effects
//
//  Parameters: 
//              szComputer          -  Computer name
//              lpSid               -  Name of the User Name Space
//
//  Return:     TRUE if successful
//              FALSE otherwise
//
//*************************************************************

BOOL RsopDeleteUserNameSpace(LPTSTR szComputer, LPTSTR lpSid)
{
    IWbemLocator    *pLocalWbemLocator=NULL;
    BOOL             bStatus = TRUE;
    XCoInitialize    xCoInit;
    HRESULT          hr     =  S_OK;

    if (FAILED(xCoInit.Status())) {
        DebugMsg((DM_VERBOSE, TEXT("ApplyGroupPolicy: CoInitializeEx failed with 0x%x."), xCoInit.Status() ));
    }

    {
        CLocator         locator;
        LPTSTR           szLocComputer;

        szLocComputer = szComputer ? szComputer : TEXT(".");

        DWORD         dwParentNSLength = lstrlen(RSOP_NS_DIAG_REMOTE_USERROOT_FMT) + lstrlen(szLocComputer) + 5;
        XPtrLF<WCHAR> xszParentNameSpace = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * ( dwParentNSLength ));

        if (!xszParentNameSpace) {
            DebugMsg(( DM_WARNING, TEXT("RsopDeleteUserNameSpace: Unable to allocate memory 0" )));
            return FALSE;
        }

        XPtrLF<WCHAR> xszWmiName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(lpSid)+1));
        if (!xszWmiName)
        {
            DebugMsg(( DM_WARNING, TEXT("RsopDeleteUserNameSpace::couldn't allocate memory with error %d"), GetLastError()));
            return FALSE;
        }

        ConvertSidToWMIName(lpSid, xszWmiName);
    
        pLocalWbemLocator = locator.GetWbemLocator();

        if (!pLocalWbemLocator) {
            return FALSE;
        }
        
        if ( (szLocComputer[0] == TEXT('\\')) && (szLocComputer[1] == TEXT('\\')) )
            szLocComputer += 2;
        
        hr = StringCchPrintf(xszParentNameSpace, dwParentNSLength, RSOP_NS_DIAG_REMOTE_USERROOT_FMT, szLocComputer);

        if(FAILED(hr))
            return FALSE;

        hr = DeleteNameSpace( xszWmiName, xszParentNameSpace, pLocalWbemLocator  );

        return SUCCEEDED( hr );
    }
}

HRESULT
CreateCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid,
                            LPWSTR          szEventLogSources )
{
    HRESULT hr;

    if ( !pServices || !szCSEGuid || !szEventLogSources )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: invalid arguments" ) );
        return E_INVALIDARG;
    }
    
    //
    //  get the RSOP_ExtensionEventSource class
    //
    XBStr bstr = L"RSOP_ExtensionEventSource";
    XInterface<IWbemClassObject> xClassSrc;
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassSrc,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSOP_ExtensionEventSource instance
    //
    XInterface<IWbemClassObject> xInstSrc;
    hr = xClassSrc->SpawnInstance( 0, &xInstSrc );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  get the RSOP_ExtensionEventSourceLink class
    //
    XInterface<IWbemClassObject> xClassLink;

    bstr = L"RSOP_ExtensionEventSourceLink";
    hr = pServices->GetObject(  bstr,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xClassLink,
                                0 );
    if ( FAILED( hr ) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: GetObject failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  spawn the RSOP_ExtensionEventSourceLink class
    //
    XInterface<IWbemClassObject> xInstLink;
    hr = xClassLink->SpawnInstance( 0, &xInstLink );
    if ( FAILED (hr) )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: SpawnInstance failed, 0x%x", hr ) );
        return hr;
    }

    //
    //  RSOP_ExtensionEventSourceLink
    //

    //
    //  create the first key
    //
    const           LPCWSTR   szFormat = L"RSOP_ExtensionStatus.extensionGuid=\"%s\"";
    DWORD           dwCSELength = 48 + wcslen(szCSEGuid);
    XPtrLF<WCHAR>   szCSE = LocalAlloc( LPTR, sizeof(WCHAR) * ( dwCSELength ) );

    if ( !szCSE )
    {
        DebugMsg( ( DM_WARNING, L"CreateCSEEventSourceNameAssoc: LocalAlloc failed, 0x%x", GetLastError() ) );
        return E_OUTOFMEMORY;
    }

    //
    // e.g. RSOP_ExtensionStatus.extensionGuid="{00000000-0000-0000-0000-000000000000}"
    //
    hr = StringCchPrintf( szCSE, dwCSELength, szFormat, szCSEGuid );

    if(FAILED(hr))
        return hr;

    VARIANT var;
    XBStr bstrVal;

    XBStr   bstreventLogSource = L"eventLogSource";
    XBStr   bstreventLogName = L"eventLogName";
    XBStr   bstrextensionStatus = L"extensionStatus";
    XBStr   bstreventSource = L"eventSource";
    XBStr   bstrid = L"id";

    var.vt = VT_BSTR;

    //
    //  szEventLogSources is in the format,
    //  "(source, name)"
    //  "(source, name)"
    //  ...
    //

    LPWSTR szStart = szEventLogSources;

    while ( *szStart )
    {
        //
        // extensionStatus
        //
        bstrVal = szCSE;
        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstrextensionStatus,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        GUID guid;

        //
        // create the [key]
        //
        hr = CoCreateGuid( &guid );
        if ( FAILED(hr) )
        {
            DebugMsg( ( DM_WARNING, L"SetPolicySettingStatus: CoCreateGuid failed, 0x%x", hr ) );
            return hr;
        }

        const DWORD dwGuidLength = 64; 
        WCHAR   szGuid[dwGuidLength];

        hr = StringCchPrintf( szGuid,
                              dwGuidLength,
                              L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                              guid.Data1,
                              guid.Data2,
                              guid.Data3,
                              guid.Data4[0], guid.Data4[1],
                              guid.Data4[2], guid.Data4[3],
                              guid.Data4[4], guid.Data4[5],
                              guid.Data4[6], guid.Data4[7] );

        if(FAILED(hr))
            return hr;

        LPWSTR szRsopExtFormat = L"RSOP_ExtensionEventSource.id=\"%s\"";
        DWORD  dwSrcLen = wcslen(szGuid) + wcslen(szRsopExtFormat) + 1;

        XPtrLF<WCHAR> szKey = LocalAlloc( LPTR, sizeof(WCHAR) * (dwSrcLen));
        if ( !szKey )
        {
            return E_OUTOFMEMORY;
        }

        hr = StringCchPrintf( szKey, dwSrcLen, szRsopExtFormat, szGuid );

        if(FAILED(hr))
            return hr;

        //
        // eventSource
        //

        bstrVal = szKey;
        var.bstrVal = bstrVal;

        hr = xInstLink->Put(bstreventSource,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // RSOP_ExtensionEventSourceLink
        //
        hr = pServices->PutInstance(xInstLink,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // id
        //
        bstrVal = szGuid;
        var.bstrVal = bstrVal;

        hr = xInstSrc->Put( bstrid,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // search for '('
        //
        szStart = wcschr( szStart, L'(' );

        if ( !szStart )
        {
             break;
        }
        szStart++;

        //
        // search for ,
        //
        LPWSTR  szEnd = wcschr( szStart, L',' );

        if ( szEnd )
        {
            if ( szStart == szEnd )
            {
                return E_INVALIDARG;
            }
            *szEnd = 0;
        }
        else
        {
            return E_INVALIDARG;
        }

        //
        // eventLogSource
        //
        bstrVal = szStart;
        var.bstrVal = bstrVal;

        hr = xInstSrc->Put( bstreventLogSource,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        *szEnd = L',';
        szStart = szEnd + 1;

        //
        // search for )
        //
        szEnd = wcschr( szStart, L')' );

        if ( szEnd )
        {
            if ( szStart == szEnd )
            {
                return E_INVALIDARG;
            }
            *szEnd = 0;
        }
        else
        {
            return E_INVALIDARG;
        }

        //
        // eventLogName
        //
        bstrVal = szStart;
        var.bstrVal = bstrVal;

        hr = xInstSrc->Put( bstreventLogName,
                            0,
                            &var,
                            0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // RSOP_ExtensionEventSource
        //
        hr = pServices->PutInstance(xInstSrc,
                                    WBEM_FLAG_CREATE_OR_UPDATE,
                                    0,
                                    0 );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // next
        //
        *szEnd = L')';
        szStart = wcschr( szEnd, 0 );
        szStart++;
    }

    return hr;
}


HRESULT
DeleteCSE_EventSourceAssoc( IWbemServices*  pServices,
                            LPWSTR          szCSEGuid )
{
    HRESULT hr = S_OK;

    if ( !pServices || !szCSEGuid )
    {
        DebugMsg( ( DM_WARNING, L"DeleteCSE_EventSourceAssoc: invalid arguments" ) );
        return E_INVALIDARG;
    }

    if(!ValidateGuid(szCSEGuid)) // Fixing bug 570492
    {
        DebugMsg( ( DM_WARNING, L"DeleteCSE_EventSourceAssoc: invalid Guid string szCSEGuid" ) );
        return E_INVALIDARG;
    }
    //
    // construct the query
    //
     
    LPWSTR          szFormat = L"SELECT * FROM RSOP_ExtensionEventSourceLink WHERE extensionStatus=\"RSOP_ExtensionStatus.extensionGuid=\\\"%s\\\"\"";
    DWORD           dwQryLength = lstrlen(szFormat) + lstrlen(szCSEGuid) + 1;
    XPtrLF<WCHAR>   szQuery = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR) * (dwQryLength));

    if(!szQuery)
        return E_OUTOFMEMORY;
    
    hr = StringCchPrintf( szQuery, dwQryLength, szFormat, szCSEGuid );

    if(FAILED(hr))
        return hr;

    XBStr bstrLanguage = L"WQL";
    XBStr bstrQuery = szQuery;
    XInterface<IEnumWbemClassObject> pEnum;
    XBStr bstrPath = L"__PATH";
    XBStr bstrEventSource = L"eventSource";

    //
    // search for RSOP_ExtensionEventSourceLink
    //
    hr = pServices->ExecQuery(  bstrLanguage,
                                bstrQuery,
                                WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_ENSURE_LOCATABLE,
                                0,
                                &pEnum );
    if ( SUCCEEDED( hr ) )
    {
        DWORD dwReturned = 0;
        do 
        {
            XInterface<IWbemClassObject> xInst;

            hr = pEnum->Next(   WBEM_INFINITE,
                                1,
                                &xInst,
                                &dwReturned );
            if ( SUCCEEDED( hr ) && dwReturned == 1 )
            {
                //
                // delete RSOP_ExtensionEventSource
                //
                VARIANT varSource;
                VariantInit( &varSource );
                XVariant xVarSource( &varSource );

                hr = xInst->Get(bstrEventSource,
                                0,
                                &varSource,
                                0,
                                0 );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pServices->DeleteInstance( varSource.bstrVal,
                                                    0L,
                                                    0,
                                                    0 );
                    if ( SUCCEEDED( hr ) )
                    {
                        //
                        // delete RSOP_ExtensionEventSourceLink
                        //

                        VARIANT varLink;
                        VariantInit( &varLink );
                        hr = xInst->Get(bstrPath,
                                        0L,
                                        &varLink,
                                        0,
                                        0 );
                        if ( SUCCEEDED(hr) )
                        {
                            XVariant xVarLink( &varLink );

                            hr = pServices->DeleteInstance( varLink.bstrVal,
                                                            0L,
                                                            0,
                                                            0 );
                            if ( FAILED( hr ) )
                            {
                                return hr;
                            }
                        }
                    }
                }
            }
        } while ( SUCCEEDED( hr ) && dwReturned == 1 );
    }

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT UpdateGPCoreStatus(IWbemLocator *pWbemLocator,
                           LPWSTR szSid, LPWSTR szNameSpace)
{
    RSOPEXTSTATUS  GPCoreRsopExtStatus;
    BOOL           bMachine = (szSid == NULL);
    XPtrLF<WCHAR>  xszFullNameSpace;
    HRESULT        hr = S_OK;
    LPWSTR         lpEnd = NULL;
    DWORD          dwError = ERROR_SUCCESS;
    DWORD          dwFullNSLength = wcslen(szNameSpace) + 5 + (MAX(lstrlen(RSOP_NS_USER_OFFSET), lstrlen(RSOP_NS_MACHINE_OFFSET)));

    xszFullNameSpace = (LPWSTR) LocalAlloc(LPTR, sizeof(WCHAR)* (dwFullNSLength));

    if (!xszFullNameSpace) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg( ( DM_WARNING, L"UpdateGPCoreStatus: failed to allocate memory, 0x%x", hr ) );
        return hr;
    }

    //
    // Construct the namespace
    //

    hr = StringCchCopy(xszFullNameSpace, dwFullNSLength, szNameSpace);

    if(FAILED(hr))
        return hr;

    lpEnd = CheckSlash(xszFullNameSpace);

    hr = StringCchCopy(lpEnd, dwFullNSLength - (lpEnd - xszFullNameSpace), bMachine ? RSOP_NS_MACHINE_OFFSET : RSOP_NS_USER_OFFSET);

    if(FAILED(hr))
        return hr;

    DebugMsg( ( DM_VERBOSE, L"UpdateGPCoreStatus: updating status from <%s> registry for gp core", 
                    bMachine ? RSOP_NS_MACHINE_OFFSET : RSOP_NS_USER_OFFSET) );
    //
    // read the GP Core extension status
    //

    dwError = ReadLoggingStatus(szSid, NULL, &GPCoreRsopExtStatus);

    if (dwError != ERROR_SUCCESS) {
        return HRESULT_FROM_WIN32(dwError);
    }


    //
    // Get th wbem interface pointer to the namespace constructed
    //

    XInterface<IWbemServices>   xWbemServices;

    hr = GetWbemServicesPtr( xszFullNameSpace, &pWbemLocator, &xWbemServices );

    if (FAILED(hr)) {
        DebugMsg( ( DM_WARNING, L"UpdateGPCoreStatus: GetWbemServicesPtr failed, hr = 0x%x", hr ) );
        return hr;
    }

    GPTEXT_API* pGpText = LoadGpTextApi();

    if ( pGpText )
    {
        hr = pGpText->pfnScrRegGPOListToWbem( szSid, xWbemServices );
        if ( FAILED( hr ) )
        {
            DebugMsg( ( DM_WARNING, L"UpdateGPCoreStatus: ScrRegGPOListToWbem failed, hr = 0x%x", hr ) );
            return hr;
        }
    }

    //
    // Log the data actually
    //

    CExtSessionLogger extLogger( xWbemServices );

    if (!extLogger.Set(NULL, TRUE, &GPCoreRsopExtStatus))
        return E_FAIL;

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\rsop\rsop.h ===
//*************************************************************
//
//  Resultant set of policy
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//  History:    7-Jun-99   SitaramR    Created
//
//*************************************************************

#if defined(__cplusplus)
extern "C"{
#endif

BOOL GetWbemServices( LPGPOINFO lpGPOInfo,
                      WCHAR *pwszRootNameSpace,
                      BOOL bPlanningMode,
                      BOOL *bCreated,
                      IWbemServices **ppWbemServices);

void ReleaseWbemServices( LPGPOINFO lpGPOInfo );

BOOL LogRsopData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData );
BOOL LogSessionData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData );

BOOL LogRegistryRsopData( DWORD dwFlags, REGHASHTABLE *pHashTable, IWbemServices *pWbemServices );

BOOL LogAdmRsopData( ADMFILEINFO *pAdmFileInfo, IWbemServices *pWbemServices );

BOOL LogExtSessionStatus( IWbemServices *pWbemServices, LPGPEXT lpExt, BOOL bSupported, BOOL bLogEventSrc = TRUE );

BOOL UpdateExtSessionStatus( IWbemServices *pWbemServices, LPTSTR lpKeyName, BOOL bIncomplete, DWORD dwErr );

BOOL DeleteExtSessionStatus(IWbemServices *pWbemServices, LPTSTR lpKeyName);

BOOL LogSessionData( LPGPOINFO lpGPOInfo, LPRSOPSESSIONDATA lprsopSessionData );
BOOL LogSOMData( LPGPOINFO lpGPOInfo );
BOOL LogGpoData( LPGPOINFO lpGPOInfo );
BOOL LogGpLinkData( LPGPOINFO lpGPOInfo );

#if defined(__cplusplus)
}
#endif


BOOL SetRsopTargetName(LPGPOINFO lpGPOInfo);
BOOL RsopDeleteAllValues(HKEY hKey, REGHASHTABLE *pHashTable,
                         WCHAR *lpKeyName, WCHAR *pwszGPO, WCHAR *pwszSOM, WCHAR *szCommand, BOOL *bLoggingOk);

HRESULT GetRsopSchemaVersionNumber(IWbemServices *pWbemServices, DWORD *dwVersionNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\copydir\generic.h ===
#define IDM_CPD              100
#define IDM_EXIT             101
#define IDM_ABOUT            102
#define IDM_LUP              103
#define IDM_ULUP             104
#define IDM_LOGON            105
#define IDM_LOGOFF           106
#define IDM_PFTYPE           107

#define IDD_PROFILEPATH      601
#define IDD_KEYNAMEBOX       602
#define IDD_KEYNAME          603
#define IDD_TIME             605
#define IDD_PROFILE          606
#define IDD_TIME_TEXT        607
#define IDD_PROFILE_TEXT     608
#define IDD_DEFAULTPATH      609
#define IDD_RETVAL           610
#define IDD_NOUI             611
#define IDD_APPLYPOLICY      612
#define IDD_LITELOAD         613

#define IDD_USERNAME         700
#define IDD_DOMAIN           701
#define IDD_PASSWORD         702
#define IDD_ICON             703

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK About  (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK LUPDlgProc  (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK LogonDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\debug\debug.c ===
//*************************************************************
//
//  Debug.c     -   Debugging utility for User Environments
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntexapi.h>
#include "debug.h"


int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{

    DialogBox (hInstance, TEXT("DEBUG"), NULL, DebugDlgProc);

    return 0;

}

BOOL CALLBACK DebugDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg) {

        case WM_INITDIALOG:
            {
            HKEY hKey;
            LONG lResult;
            DWORD dwButton = IDD_NORMAL;
            DWORD dwType, dwSize, dwValue;

            lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   WINLOGON_KEY,
                                   0,
                                   KEY_READ,
                                   &hKey);

            if (lResult == ERROR_SUCCESS) {

                dwSize = sizeof(dwValue);
                lResult = RegQueryValueEx(hKey,
                                          USERENV_DEBUG_LEVEL,
                                          NULL,
                                          &dwType,
                                          (LPBYTE)&dwValue,
                                          &dwSize);

                if (lResult == ERROR_SUCCESS) {

                    if (LOWORD(dwValue) == DL_NONE) {
                        dwButton = IDD_NONE;
                    } else if (LOWORD(dwValue) == DL_VERBOSE) {
                        dwButton = IDD_VERBOSE;
                    }

                }

                RegCloseKey(hKey);
            }

            CheckRadioButton (hDlg, IDD_NONE, IDD_VERBOSE, dwButton);

            if (dwValue & DL_LOGFILE) {
                CheckDlgButton (hDlg, IDD_LOGFILE, 1);
            }


            //
            // Now check for winlogon
            //

            dwButton = 0;
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                   EXEC_OPTIONS_KEY,
                                   0,
                                   KEY_READ,
                                   &hKey) == ERROR_SUCCESS) {

                dwButton = 1;
                RegCloseKey(hKey);
            }

            CheckDlgButton (hDlg, IDD_WINLOGON, dwButton);

            }
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    {
                    HKEY hKey;
                    LONG lResult;
                    DWORD dwType, dwValue = DL_NORMAL;
                    DWORD dwButton, dwSize, dwDisp;

                    if (IsDlgButtonChecked(hDlg, IDD_NONE)) {
                        dwValue = DL_NONE;
                    } else if (IsDlgButtonChecked(hDlg, IDD_VERBOSE)) {
                        dwValue = (DL_VERBOSE | DL_DEBUGGER);
                    }

                    if (IsDlgButtonChecked(hDlg, IDD_LOGFILE)) {
                        dwValue |= DL_LOGFILE;
                    }

                    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                           WINLOGON_KEY,
                                           0,
                                           KEY_WRITE,
                                           &hKey);

                    if (lResult == ERROR_SUCCESS) {

                        lResult = RegSetValueEx(hKey,
                                                USERENV_DEBUG_LEVEL,
                                                0,
                                                REG_DWORD,
                                                (LPBYTE)&dwValue,
                                                sizeof(dwValue));

                        if (lResult != ERROR_SUCCESS) {
                            MessageBox(hDlg, TEXT("Failed to save settings."), NULL, MB_OK);
                        }

                        RegCloseKey(hKey);
                    }


                    //
                    // Debug output for winlogon / msgina
                    //

                    if (dwValue & DL_VERBOSE) {

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("DebugFlags"),
                                            TEXT("Error,Warning,Trace,Init,Timeout,Sas,State,CoolSwitch,Profile,Notify,Job"));

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("EnableDesktopSwitching"),
                                            TEXT("1"));

                        WriteProfileString (TEXT("MSGina"),
                                            TEXT("DebugFlags"),
                                            TEXT("Error,Warning,Trace,Domain,Cache"));

                    } else {

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("DebugFlags"),
                                            NULL);

                        WriteProfileString (TEXT("Winlogon"),
                                            TEXT("EnableDesktopSwitching"),
                                            NULL);

                        WriteProfileString (TEXT("MSGina"),
                                            TEXT("DebugFlags"),
                                            NULL);
                    }



                    //
                    // Now check for winlogon
                    //

                    if (IsDlgButtonChecked(hDlg, IDD_WINLOGON)) {

                        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                           EXEC_OPTIONS_KEY,
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hKey,
                                           &dwDisp) == ERROR_SUCCESS) {

                            RegSetValueEx (hKey,
                                           TEXT("Debugger"),
                                           0, REG_SZ,
                                           (LPBYTE) TEXT("ntsd -d -G"),
                                           16);

                            RegCloseKey (hKey);
                        }

                    } else {
                        RegDeleteKey (HKEY_LOCAL_MACHINE,
                                      EXEC_OPTIONS_KEY);
                    }

                    EndDialog(hDlg, FALSE);
                    return TRUE;
                    }

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;

            }
            break;

        default:
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\createadt\createadt.c ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

TCHAR szADT[MAX_PATH];

BOOL ParseCommandLine (int argc, char *argv[]);
UINT CreateNestedDirectory(LPCTSTR lpDirectory);
LPTSTR CheckSlash (LPTSTR lpDir);


int __cdecl main( int argc, char *argv[])
{
    LPTSTR lpEnd, lpRoot;
    HANDLE hFile;
    INT i;

    if (!ParseCommandLine (argc, argv)) {
        return 1;
    }

    if (!CreateNestedDirectory (szADT)) {
        return 1;
    }


    lpRoot = CheckSlash (szADT);

    lstrcpy (lpRoot, TEXT("GPT.ini"));
    if (!WritePrivateProfileString (TEXT("General"),
                                    TEXT("GUID"),
                                    TEXT("<GUID goes here>"),
                                    szADT)) {
        return 1;
    }

    if (!WritePrivateProfileString (TEXT("General"),
                                    TEXT("Class Store"),
                                    TEXT(" <Path to a Class Store goes here>"),
                                    szADT)) {
        return 1;
    }

    *(lpRoot - 1) = TEXT('\0');

    for (i=0; i < 2; i++ ) {

        lpRoot = CheckSlash (szADT);

        if (i == 0) {
            lstrcpy (lpRoot, TEXT("User"));
        } else {
            lstrcpy (lpRoot, TEXT("Machine"));
        }

        lpEnd = CheckSlash (szADT);

        lstrcpy (lpEnd, TEXT("Applications\\Assigned\\Alpha"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Assigned\\x86\\WinNT"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Assigned\\x86\\Win95"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }


        lstrcpy (lpEnd, TEXT("Applications\\Published\\Alpha"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Published\\x86\\WinNT"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Applications\\Published\\x86\\Win95"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }


        if (i > 0) {
            lstrcpy (lpEnd, TEXT("OS Upgrades"));
            if (!CreateNestedDirectory (szADT)) {
                return 1;
            }
        }

        lstrcpy (lpEnd, TEXT("Profile"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Power Schemes"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }


        lstrcpy (lpEnd, TEXT("Scripts"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Registry.txt"));
        hFile = CreateFile (szADT, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle (hFile);
        }


        lstrcpy (lpEnd, TEXT("Profile"));
        lpEnd = CheckSlash (szADT);

        lstrcpy (lpEnd, TEXT("Application Data"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Desktop\\My Documents"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Favorites"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("NetHood"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("PrintHood"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Recent"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("SendTo"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Templates"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        lstrcpy (lpEnd, TEXT("Start Menu\\Programs\\Startup"));
        if (!CreateNestedDirectory (szADT)) {
            return 1;
        }

        if (i == 0) {
            lstrcpy (lpRoot, TEXT("User\\Scripts\\Scripts.ini"));
         } else {
            lstrcpy (lpRoot, TEXT("Machine\\Scripts\\Scripts.ini"));
         }

        if (i == 0) {
            if (!WritePrivateProfileString (TEXT("Logon"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }

            if (!WritePrivateProfileString (TEXT("Logoff"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }
        } else {
            if (!WritePrivateProfileString (TEXT("Boot"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }

            if (!WritePrivateProfileString (TEXT("Shutdown"),
                                            TEXT("CommandLine"),
                                            TEXT(" <Command line goes here>"),
                                            szADT)) {
                return 1;
            }
        }


        *(lpRoot - 1) = TEXT('\0');
    }

    _tprintf (TEXT("\r\nThe %s Group Policy Template (GPT) was successfully created.\r\n\r\n"), szADT);
    _tprintf (TEXT("Add this directory to the %%SystemRoot%%\\DS.INI file on each client machine.\r\n"));
    _tprintf (TEXT("The Path entry can have multiple ADT paths each separated by a semi-colon.\r\n"));
    _tprintf (TEXT("The file format is:\r\n\r\n"));
    _tprintf (TEXT("[User ADT]\r\nPath=%s\r\n\r\n"), szADT);

    return 0;
}


BOOL ParseCommandLine (int argc, char *argv[])
{

    if (argc != 2) {
        goto usage;
    }

    if (!lstrcmpi(argv[1], TEXT("/?"))) {
        goto usage;
    }

    if (!lstrcmpi(argv[1], TEXT("-?"))) {
        goto usage;
    }

    lstrcpy (szADT, argv[1]);

    return TRUE;

usage:
    _tprintf (TEXT("\r\nusage:  creategpt <gptpath>\r\n\r\n"));

    return FALSE;
}


UINT CreateNestedDirectory(LPCTSTR lpDirectory)
{
    TCHAR szDirectory[MAX_PATH];
    LPTSTR lpEnd;


    if (CreateDirectory (lpDirectory, NULL)) {
        return 1;
    }


    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    lstrcpy (szDirectory, lpDirectory);


    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {
        lpEnd += 2;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    return 0;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    if (CreateDirectory (szDirectory, NULL)) {
        return 1;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    return 0;

}

LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\debug\debug.h ===
//
// Debug levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

//
// Winlogon location
//

#define WINLOGON_KEY        TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define EXEC_OPTIONS_KEY    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Winlogon.exe")

#define USERENV_DEBUG_LEVEL TEXT("UserEnvDebugLevel")
#define GLOBAL_FLAG         TEXT("GlobalFlag")

#define IDD_NONE           401
#define IDD_NORMAL         402
#define IDD_VERBOSE        403
#define IDD_LOGFILE        404
#define IDD_WINLOGON       405

BOOL CALLBACK DebugDlgProc (HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\copydir\generic.c ===
/****************************************************************************

        PROGRAM: Generic.c

        PURPOSE: Generic template for Windows applications

****************************************************************************/

#include <windows.h>
#include <userenv.h>
#include <userenvp.h>
#include "generic.h"


HINSTANCE hInst;
HWND      hwndMain;
HANDLE    hProfile, hUserToken;

TCHAR szAppName[] = TEXT("Generic");
#ifdef UNICODE
TCHAR szTitle[]   = TEXT("UserEnv Profile Test App - UNICODE");
#else
TCHAR szTitle[]   = TEXT("UserEnv Profile Test App - ANSI");
#endif


TCHAR szSrcDir[MAX_PATH];
TCHAR szDestDir[MAX_PATH];
TCHAR szProfilePath[MAX_PATH];
TCHAR szDefaultPath[MAX_PATH];
TCHAR szUserName[MAX_PATH];
TCHAR szDomainName[MAX_PATH];

void ChangeMenuState (BOOL bLoggedOn);
BOOL GetProfileType(DWORD *flags);

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

        PURPOSE: calls initialization function, processes message loop

****************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
        MSG msg;
        HANDLE hAccelTable;

        if (!hPrevInstance)
           {
           if (!InitApplication(hInstance))
              {
              return (FALSE);
              }
           }


        // Perform initializations that apply to a specific instance
        if (!InitInstance(hInstance, nCmdShow))
           {
           return (FALSE);
           }

        hAccelTable = LoadAccelerators (hInstance, szAppName);

        while (GetMessage(&msg, NULL, 0, 0))
           {
           if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg))
              {
              TranslateMessage(&msg);
              DispatchMessage(&msg);
              }
           }


        return (msg.wParam);

        lpCmdLine;
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)

        PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
        WNDCLASS  wc;

        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon (hInstance, szAppName);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = szAppName;
        wc.lpszClassName = szAppName;

        return (RegisterClass(&wc));
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

        PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
        HWND  hWnd;

        hInst = hInstance;
        hProfile = NULL;

        szSrcDir[0] = TEXT('\0');
        szDestDir[0] = TEXT('\0');
        szProfilePath[0] = TEXT('\0');
        szDefaultPath[0] = TEXT('\0');
        szUserName[0] = TEXT('\0');
        szDomainName[0] = TEXT('\0');

        hWnd = CreateWindow(szAppName,
                            szTitle,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
                            NULL,
                            NULL,
                            hInstance,
                            NULL);

        if (!hWnd)
           {
           return (FALSE);
           }
        else
          {
          hwndMain = hWnd;
          }

        ChangeMenuState(FALSE);
        PostMessage (hWnd, WM_COMMAND, IDM_LOGON, 0);

        ShowWindow(hWnd, SW_SHOWDEFAULT);
        UpdateWindow(hWnd);

        return (TRUE);

}

/****************************************************************************

        FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages

****************************************************************************/

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
        DWORD dwFlags;
        TCHAR szBuffer[MAX_PATH];

        switch (message)
           {
           case WM_COMMAND:
              {
              switch (LOWORD(wParam))
                 {
                 case IDM_LOGON:
                    if (DialogBox (hInst, TEXT("LOGONDLG"), hWnd, LogonDlgProc)) {
                        ChangeMenuState(TRUE);
                    }
                    break;

                 case IDM_LOGOFF:
                    CloseHandle(hUserToken);
                    ChangeMenuState(FALSE);
                    break;

                 case IDM_LUP:
                    DialogBox (hInst, TEXT("LUPDLG"), hWnd, LUPDlgProc);
                    break;

                 case IDM_ULUP:
                    if (hProfile) {
                        if (UnloadUserProfile(hUserToken, hProfile)) {
                            hProfile = NULL;
                        }
                    }
                    break;

                 case IDM_PFTYPE:
                    if (hUserToken) {
                        if (!ImpersonateLoggedOnUser(hUserToken)) {
                            wsprintf(szBuffer, TEXT("Impersonate Failed with Error %d"), GetLastError());
                            MessageBox (hWnd, szBuffer, TEXT("Impersonate"), MB_OK | MB_ICONEXCLAMATION);
                            return TRUE;
                        }

                        if (GetProfileType(&dwFlags)) {
                        }

                        RevertToSelf();
                    }
                    break;

                 case IDM_ABOUT:
                    DialogBox (hInst, TEXT("AboutBox"), hWnd, About);
                    break;

                 case IDM_EXIT:
                    DestroyWindow (hwndMain);
                    break;


                 default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));
                 }
              }
              break;

           case WM_DESTROY:
              if (hProfile) {
                  if (UnloadUserProfile(hUserToken, hProfile)) {
                      hProfile = NULL;
                  }
              }

              PostQuitMessage(0);
              break;

           default:
              return (DefWindowProc(hWnd, message, wParam, lParam));
           }

        return FALSE;
}

/****************************************************************************

        FUNCTION: About(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages for "About" dialog box

****************************************************************************/

LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

        switch (message)
           {
           case WM_COMMAND:
              if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, TRUE);
                 return (TRUE);
                 }
              break;
           }

        return (FALSE);

        lParam;
}


/****************************************************************************

        FUNCTION: LUPDlgProc(HWND, UINT, WPARAM, LPARAM)

****************************************************************************/

LRESULT CALLBACK LUPDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

        switch (message)
           {
           case WM_INITDIALOG:
              SetDlgItemText(hDlg, IDD_PROFILEPATH, szProfilePath);
              SetDlgItemText(hDlg, IDD_DEFAULTPATH, szDefaultPath);
              SetFocus (GetDlgItem (hDlg, IDD_PROFILEPATH));

              return FALSE;

           case WM_COMMAND:
              if (LOWORD(wParam) == IDOK)
                  {
                  PROFILEINFO pi;
                  DWORD dwStart, dwEnd, dwFlags = 0;
                  TCHAR szBuffer[200];
                  HCURSOR hCursor;
                  BOOL bResult;

                  SetDlgItemText(hDlg, IDD_RETVAL, NULL);
                  SetDlgItemText(hDlg, IDD_TIME, NULL);
                  SetDlgItemText(hDlg, IDD_PROFILE, NULL);


                  GetDlgItemText(hDlg, IDD_PROFILEPATH, szProfilePath, MAX_PATH);
                  GetDlgItemText(hDlg, IDD_DEFAULTPATH, szDefaultPath, MAX_PATH);

                  if (IsDlgButtonChecked(hDlg, IDD_NOUI)) {
                    dwFlags |= PI_NOUI;
                  }

                  if (IsDlgButtonChecked(hDlg, IDD_APPLYPOLICY)) {
                    dwFlags |= PI_APPLYPOLICY;
                    pi.lpPolicyPath = TEXT("ntconfig.pol");
                  }

                  if (IsDlgButtonChecked(hDlg, IDD_LITELOAD)) {
                    dwFlags |= PI_LITELOAD;
                  }

                  pi.dwSize = sizeof(PROFILEINFO);
                  pi.dwFlags = dwFlags;
                  pi.lpUserName = szUserName;
                  pi.lpProfilePath = szProfilePath;
                  pi.lpDefaultPath = szDefaultPath;
                  pi.lpServerName = NULL;

                  hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

                  dwStart = GetTickCount();
                  bResult = LoadUserProfile(hUserToken, &pi);
                  dwEnd = GetTickCount();

                  SetCursor(hCursor);

                  SetDlgItemInt(hDlg, IDD_TIME, dwEnd - dwStart, FALSE);
                  SetDlgItemInt(hDlg, IDD_RETVAL, bResult, FALSE);

                  if (bResult) {
                      hProfile = pi.hProfile;

                      wsprintf (szBuffer, TEXT("0x%x"), pi.hProfile);
                      SetDlgItemText(hDlg, IDD_PROFILE, szBuffer);
                  }

                  }

              if (LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, TRUE);
                 return (TRUE);
                 }

              break;
           }

        return (FALSE);
}


void ChangeMenuState (BOOL bLoggedOn)
{
    HMENU hMenu;


    hMenu = GetMenu(hwndMain);

    if (bLoggedOn) {

        EnableMenuItem (hMenu, IDM_LOGON, MF_BYCOMMAND | MF_GRAYED);


        EnableMenuItem (hMenu, IDM_LOGOFF, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem (hMenu, IDM_LUP, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem (hMenu, IDM_ULUP, MF_BYCOMMAND | MF_ENABLED);

    } else {

        EnableMenuItem (hMenu, IDM_LOGOFF, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hMenu, IDM_LUP, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem (hMenu, IDM_ULUP, MF_BYCOMMAND | MF_GRAYED);

        EnableMenuItem (hMenu, IDM_LOGON, MF_BYCOMMAND | MF_ENABLED);
    }

}

/****************************************************************************

        FUNCTION: LogonDlgProc(HWND, UINT, WPARAM, LPARAM)

****************************************************************************/

LRESULT CALLBACK LogonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

        switch (message)
           {
           case WM_INITDIALOG:
              {
              HBITMAP hBmp;

              hBmp = LoadBitmap (hInst, TEXT("Logo"));

              if (hBmp) {
                 SendDlgItemMessage (hDlg, IDD_ICON, STM_SETIMAGE,
                                     IMAGE_BITMAP, (LPARAM) hBmp);
              }
              SetDlgItemText(hDlg, IDD_USERNAME, szUserName);
              SetDlgItemText(hDlg, IDD_DOMAIN, szDomainName);
              }
              return TRUE;

           case WM_COMMAND:
              if (LOWORD(wParam) == IDOK)
                  {
                  TCHAR szPassword[MAX_PATH];

                  GetDlgItemText(hDlg, IDD_USERNAME, szUserName, MAX_PATH);
                  GetDlgItemText(hDlg, IDD_DOMAIN,   szDomainName, MAX_PATH);
                  GetDlgItemText(hDlg, IDD_PASSWORD, szPassword, MAX_PATH);

                  if (LogonUser(szUserName, szDomainName, szPassword,
                                LOGON32_LOGON_INTERACTIVE,
                                LOGON32_PROVIDER_DEFAULT,
                                &hUserToken)) {
                      EndDialog(hDlg, TRUE);
                      return TRUE;

                  } else {
                      TCHAR szBuffer[200];

                      wsprintf(szBuffer, TEXT("Logon Failed with Error %d"),
                               GetLastError());
                      MessageBox (hDlg, szBuffer, TEXT("Logon"), MB_OK | MB_ICONEXCLAMATION);
                      return TRUE;
                  }

                  }

              if (LOWORD(wParam) == IDCANCEL)
                 {
                 EndDialog(hDlg, FALSE);
                 return TRUE;
                 }

              break;
           }

        return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\poltest\gpcheck.cpp ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <tchar.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <prsht.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <mmc.h>
#include <initguid.h>
#include <gpedit.h>
#define _USERENV_NO_LINK_APIS_ 1
#include <userenv.h>
#include <userenvp.h>


#include "poltest.h"


typedef struct _GPOINFO {
    TCHAR szGPOName[50];
    DWORD dwFlags;
} GPOINFO, *LPGPOINFO;

#define GPO_FLAG_VERSION   1
#define GPO_FLAG_REGISTRY  2

LPTSTR CheckSlash (LPTSTR lpDir);

//*************************************************************
//
//  GetDCList()
//
//  Purpose:    Reads the DC list from the registry
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

LPTSTR GetDCList (BOOL bZero)
{
    HKEY hKey;
    LPTSTR lpList = NULL;
    LPTSTR lpTemp;
    DWORD dwType, dwSize;


    lpList = (LPTSTR) LocalAlloc (LPTR, 256 * sizeof(TCHAR));

    if (!lpList)
        return NULL;


    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = 256 * sizeof(TCHAR);
        RegQueryValueEx (hKey, TEXT("DCList"), NULL, &dwType,
                         (LPBYTE) lpList, &dwSize);

        RegCloseKey (hKey);
    }

    if (bZero) {
        lpTemp = lpList;

        while (*lpTemp) {
            if (*lpTemp == TEXT(';')) {
                *lpTemp = TEXT('\0');
            }

            lpTemp++;
        }
    }

    if (*lpList == TEXT('\0')) {
        LocalFree (lpList);
        return NULL;
    }

    return lpList;
}

//*************************************************************
//
//  GetDomainName()
//
//  Purpose:    Reads the domain name from the registry
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

LPTSTR GetDomainName (BOOL bZero)
{
    HKEY hKey;
    LPTSTR lpList = NULL;
    LPTSTR lpTemp;
    DWORD dwType, dwSize;


    lpList = (LPTSTR) LocalAlloc (LPTR, 256 * sizeof(TCHAR));

    if (!lpList)
        return NULL;


    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = 256 * sizeof(TCHAR);
        RegQueryValueEx (hKey, TEXT("DomainName"), NULL, &dwType,
                         (LPBYTE) lpList, &dwSize);

        RegCloseKey (hKey);
    }

    if (bZero) {
        lpTemp = lpList;

        while (*lpTemp) {
            if (*lpTemp == TEXT('.')) {
                *lpTemp = TEXT('\0');
            }

            lpTemp++;
        }
    }


    if (*lpList == TEXT('\0')) {
        LocalFree (lpList);
        return NULL;
    }

    return lpList;
}

//*************************************************************
//
//  CheckSpecificGPO()
//
//  Purpose:    Checks a specific GPO's for the requested
//              attributes
//
//  Parameters: lpGPOName  - gpo name
//              dwFlags    - GPO_FLAG_*
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL CheckSpecificGPO (LPTSTR lpGPOName, DWORD dwFlags)
{
    LPTSTR lpList;
    LPTSTR lpDomainName;
    LPTSTR lpDomainName2;
    LPTSTR lpDC, lpTemp;
    TCHAR szPath[MAX_PATH];
    TCHAR szLDAPPath[MAX_PATH];
    TCHAR szMsg[512];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DWORD dwFileSysVersion;
    LPTSTR lpEnd;
    FILETIME filetime;
    SYSTEMTIME systime;
    TCHAR szDate[50];
    TCHAR szTime[50];
    IADs *pADs;
    VARIANT var;
    BSTR bstrProperty;
    HRESULT hr;



    lpList = GetDCList (TRUE);

    if (!lpList) {
        AddString (TEXT("You need to enter the list of DC names"));
        return TRUE;
    }

    lpDomainName = GetDomainName (FALSE);

    if (!lpDomainName) {
        AddString (TEXT("You need to enter a domain name"));
        LocalFree (lpList);
        return TRUE;
    }

    CoInitialize(NULL);

    AddString (TEXT("============================================"));
    wsprintf (szMsg, TEXT("Listing GPO %s's information from all DCs"), lpGPOName);
    AddString (szMsg);


    lpDC = lpList;

    while (*lpDC) {

        AddString (TEXT("------------"));

        wsprintf (szMsg, TEXT("Checking DC:  %s"), lpDC);
        AddString (szMsg);

        wsprintf (szPath, TEXT("\\\\%s\\SysVol\\%s\\policies\\%s"),
                  lpDC, lpDomainName, lpGPOName);

        if (!GetFileAttributesEx (szPath, GetFileExInfoStandard, &fad)) {
            wsprintf (szMsg, TEXT("Failed to find %s with %d"), szPath, GetLastError());
            AddString (szMsg);
            goto LoopAgain;
        }

        lpEnd = CheckSlash (szPath);

        if (dwFlags & GPO_FLAG_VERSION) {
            lstrcpy (lpEnd, TEXT("gpt.ini"));

            dwFileSysVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szPath);


            lpDomainName2 = GetDomainName (TRUE);

            lstrcpy (szLDAPPath, TEXT("LDAP://"));
            lstrcat (szLDAPPath, lpDC);
            lstrcat (szLDAPPath, TEXT("/CN="));
            lstrcat (szLDAPPath, lpGPOName);
            lstrcat (szLDAPPath, TEXT(",CN=Policies,CN=System"));

            lpTemp = lpDomainName2;

            while (*lpTemp) {

                lstrcat (szLDAPPath, TEXT(",DC="));
                lstrcat (szLDAPPath, lpTemp);
                lpTemp += lstrlen(lpTemp) + 1;
            }

            hr = ADsGetObject(szLDAPPath, IID_IADs, (void **)&pADs);

            if (FAILED(hr)) {
                wsprintf (szMsg, TEXT("ADsGetObject failed with 0x%x"), hr);
                AddString (szMsg);
                goto LoopAgain;
            }


            VariantInit(&var);
            bstrProperty = SysAllocString (L"versionNumber");

            hr = pADs->Get(bstrProperty, &var);

            if (FAILED(hr)) {
                wsprintf (szMsg, TEXT("pADs->Get failed with 0x%x"), hr);
                AddString (szMsg);
                SysFreeString (bstrProperty);
                VariantClear (&var);
                goto LoopAgain;
            }

            wsprintf (szMsg, TEXT("DS Version:  %d"), var.lVal);
            AddString (szMsg);

            SysFreeString (bstrProperty);
            VariantClear (&var);
            pADs->Release();

            wsprintf (szMsg, TEXT("SysVol Version:  %d"), dwFileSysVersion);
            AddString (szMsg);
        }

        if (dwFlags & GPO_FLAG_REGISTRY) {

            lstrcpy (lpEnd, TEXT("machine\\registry.pol"));

            if (GetFileAttributesEx (szPath, GetFileExInfoStandard, &fad)) {

                FileTimeToLocalFileTime (&fad.ftLastWriteTime, &filetime);
                FileTimeToSystemTime (&filetime, &systime);

                GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                               NULL, szDate, 50);

                GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                               NULL, szTime, 50);

                wsprintf (szMsg, TEXT("Last Registry Update (machine):  %s %s"), szDate, szTime);
                AddString (szMsg);
            }

            lstrcpy (lpEnd, TEXT("user\\registry.pol"));

            if (GetFileAttributesEx (szPath, GetFileExInfoStandard, &fad)) {

                FileTimeToLocalFileTime (&fad.ftLastWriteTime, &filetime);
                FileTimeToSystemTime (&filetime, &systime);

                GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                               NULL, szDate, 50);

                GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                               NULL, szTime, 50);

                wsprintf (szMsg, TEXT("Last Registry Update (user):        %s %s"), szDate, szTime);
                AddString (szMsg);
            }
        }

LoopAgain:

        lpDC += lstrlen(lpDC) + 1;
    }

    CoUninitialize();

    LocalFree (lpList);
    LocalFree (lpDomainName);

    return TRUE;
}


BOOL CALLBACK DomainInfo (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            LPTSTR lpTemp;

            lpTemp = GetDomainName (FALSE);

            if (lpTemp) {
                SetDlgItemText (hDlg, IDC_NAME, lpTemp);
                LocalFree (lpTemp);
            }

            lpTemp = GetDCList (FALSE);

            if (lpTemp) {
                SetDlgItemText (hDlg, IDC_DCLIST, lpTemp);
                LocalFree (lpTemp);
            }
            }
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {
                HKEY hKey;
                DWORD dwDisp;
                TCHAR szBuffer[512];


                if (RegCreateKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                                    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

                    GetDlgItemText (hDlg, IDC_NAME, szBuffer, 512);
                    RegSetValueEx (hKey, TEXT("DomainName"), NULL, REG_SZ,
                                   (LPBYTE) szBuffer, (lstrlen(szBuffer) + 1) *sizeof(TCHAR));

                    GetDlgItemText (hDlg, IDC_DCLIST, szBuffer, 512);
                    RegSetValueEx (hKey, TEXT("DCList"), NULL, REG_SZ,
                                   (LPBYTE) szBuffer, (lstrlen(szBuffer) + 1) *sizeof(TCHAR));

                    RegCloseKey (hKey);
                }


                EndDialog(hDlg, TRUE);
                return (TRUE);
            }


            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return (TRUE);
            }
            break;
    }

    return (FALSE);
}


BOOL ManageDomainInfo(HWND hWnd)
{

    DialogBox (GetModuleHandle(NULL), TEXT("DOMAIN_INFO"), hWnd, DomainInfo);

    return TRUE;
}

DWORD WINAPI CheckGPOThread (LPGPOINFO lpInfo)
{
    CheckSpecificGPO (lpInfo->szGPOName, lpInfo->dwFlags);
    
    LocalFree (lpInfo);

    return 0;
}

BOOL CALLBACK GPONameDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
            {
            HKEY hKey;
            DWORD dwType, dwSize, dwTemp;
            TCHAR szGPOName[50];

            szGPOName[0] = TEXT('\0');
            if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = 50 * sizeof(TCHAR);
                RegQueryValueEx (hKey, TEXT("GPOName"), NULL, &dwType,
                                 (LPBYTE) szGPOName, &dwSize);

                dwSize = sizeof(dwTemp);
                dwTemp = 0;
                RegQueryValueEx (hKey, TEXT("GPONameOptions"), NULL, &dwType,
                                 (LPBYTE) &dwTemp, &dwSize);


                RegCloseKey (hKey);
            }


            SetDlgItemText (hDlg, IDC_NAME, szGPOName);

            if (dwTemp & GPO_FLAG_VERSION) {
                CheckDlgButton (hDlg, IDC_VERSION, BST_CHECKED);
            }

            if (dwTemp & GPO_FLAG_REGISTRY) {
                CheckDlgButton (hDlg, IDC_REGISTRY, BST_CHECKED);
            }


            }
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK) {

                HKEY hKey;
                DWORD dwDisp, dwTemp;
                TCHAR szGPOName[50];
                LPGPOINFO lpInfo;
                HANDLE hThread;
                DWORD dwID;

                dwTemp = 0;

                if (IsDlgButtonChecked (hDlg, IDC_VERSION)) {
                    dwTemp |= GPO_FLAG_VERSION;
                }

                if (IsDlgButtonChecked (hDlg, IDC_REGISTRY)) {
                    dwTemp |= GPO_FLAG_REGISTRY;
                }


                if (RegCreateKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Poltest"),
                                    0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {

                    GetDlgItemText (hDlg, IDC_NAME, szGPOName, 50);
                    RegSetValueEx (hKey, TEXT("GPOName"), NULL, REG_SZ,
                                   (LPBYTE) szGPOName, (lstrlen(szGPOName) + 1) *sizeof(TCHAR));
                    RegSetValueEx (hKey, TEXT("GPONameOptions"), NULL, REG_SZ,
                                   (LPBYTE) &dwTemp, sizeof(dwTemp));

                    RegCloseKey (hKey);
                }

                lpInfo = (LPGPOINFO) LocalAlloc (LPTR, sizeof(GPOINFO));

                if (lpInfo) {
                    lstrcpy (lpInfo->szGPOName, szGPOName);
                    lpInfo->dwFlags = dwTemp;

                    hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)CheckGPOThread,
                                            lpInfo, 0, &dwID);

                    if (hThread) {
                        CloseHandle (hThread);
                    }

                }
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }


            if (LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, FALSE);
                return (TRUE);
            }

            if (LOWORD(wParam) == IDC_BROWSE) {
                GPOBROWSEINFO info;
                TCHAR szName[500];
                TCHAR szPath[512];
                LPGROUPPOLICYOBJECT pGPO;

                szName[0] = TEXT('\0');
                ZeroMemory (&info, sizeof(info));
                info.dwSize = sizeof(info);
                info.dwFlags = GPO_BROWSE_NOCOMPUTERS;
                info.hwndOwner = hDlg;
                info.lpDSPath = szPath;
                info.dwDSPathSize = 512;
                info.lpName = szName;
                info.dwNameSize = 500;

                if (SUCCEEDED(BrowseForGPO (&info))) {

                    if (SUCCEEDED(CoCreateInstance (CLSID_GroupPolicyObject, NULL,
                                  CLSCTX_SERVER, IID_IGroupPolicyObject,
                                  (void**)&pGPO))) {


                        if (SUCCEEDED(pGPO->OpenDSGPO (szPath, GPO_OPEN_READ_ONLY))){
                            pGPO->GetName (szName, 500);
                            SetDlgItemText (hDlg, IDC_NAME, szName);
                        }
                        pGPO->Release();
                    }
                }
            }
            break;
    }

    return (FALSE);
}


BOOL CheckGPO(HWND hWnd)
{

    DialogBox (GetModuleHandle(NULL), TEXT("GPO_NAME"), hWnd, GPONameDlgProc);

    return TRUE;
}

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    DWORD dwStrLen;
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\gpolist\test.c ===
#include <windows.h>
#include <userenv.h>
#include <tchar.h>
#include <stdio.h>
#include <dsgetdc.h>
#include <lm.h>
#define SECURITY_WIN32
#include <security.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    DWORD dwStart, dwDelta;
    PGROUP_POLICY_OBJECT pGPOList, pTemp;
    TCHAR szName[200];
    TCHAR szDCName[200];
    ULONG ulSize;
    DWORD dwResult;
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;


    OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

    dwStart = GetTickCount();

    if (GetGPOList (hToken, NULL, NULL, NULL, 0, &pGPOList)) {

        dwDelta = GetTickCount() - dwStart;

        _tprintf (TEXT("\r\nTick count:  %d\r\n\r\n"), dwDelta);

        pTemp = pGPOList;

        while (pTemp) {

            _tprintf (TEXT("%s\t%s\r\n"), pTemp->szGPOName, pTemp->lpDisplayName);

            pTemp = pTemp->pNext;
        }

        FreeGPOList (pGPOList);
    }

    CloseHandle (hToken);


    //
    // Second time without the hToken
    //

    _tprintf (TEXT("\r\n\r\nRound 2 without token\r\n\r\n"));

    ulSize = 200;
    if (!GetUserNameEx (NameFullyQualifiedDN, szName, &ulSize)) {
        return 0;
    }


    //
    // Check this domain for a DC
    //

    dwResult = DsGetDcName (NULL, NULL, NULL, NULL,
                            DS_DIRECTORY_SERVICE_PREFERRED, &pDCI);

    if (dwResult != ERROR_SUCCESS) {
        return 0;
    }


    //
    // Found a DC, does it have a DS ?
    //

    if (!(pDCI->Flags & DS_DS_FLAG)) {
        NetApiBufferFree(pDCI);
        return 0;
    }


    dwStart = GetTickCount();

    if (GetGPOList (NULL, szName, pDCI->DomainControllerName, NULL, 0, &pGPOList)) {

        dwDelta = GetTickCount() - dwStart;

        _tprintf (TEXT("\r\nTick count:  %d\r\n\r\n"), dwDelta);

        pTemp = pGPOList;

        while (pTemp) {

            _tprintf (TEXT("%s\t%s\r\n"), pTemp->szGPOName, pTemp->lpDisplayName);

            pTemp = pTemp->pNext;
        }

        FreeGPOList (pGPOList);
    }

    NetApiBufferFree(pDCI);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\poltest\poltest.h ===
#ifdef __cplusplus
extern "C" {
#endif


#define IDM_UPDATE_MACHINE  1
#define IDM_UPDATE_USER     2
#define IDM_PAUSE_MACHINE   3
#define IDM_RESUME_MACHINE  4
#define IDM_PAUSE_USER      5
#define IDM_RESUME_USER     6
#define IDM_EXIT            7
#define IDM_VERBOSE         8
#define IDM_EVENTVWR        9
#define IDM_USERNAME       10
#define IDM_COMPUTERNAME   11
#define IDM_SITENAME       12
#define IDM_SYNCPOLICY     13
#define IDM_DCLIST         14
#define IDM_CHECKGPO       15
#define IDM_CLEARWINDOW    16
#define IDM_SAVEAS         17
#define IDM_PDCNAME        18


#define IDC_NAME           100
#define IDC_DCLIST         101
#define IDC_BROWSE         102
#define IDC_VERSION        103
#define IDC_REGISTRY       104

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
VOID AddString (LPTSTR lpString);
DWORD NotifyThread (DWORD dwDummy);



BOOL ManageDomainInfo(HWND hWnd);
BOOL CheckGPO(HWND hWnd);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\inc\rcmd.h ===
/****************************** Module Header ******************************\
* Module Name: rcmd.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell common header module
*
* History:
* 05-2-94 DaveTh	Created.
\***************************************************************************/

#define MAX_CMD_LENGTH 500

typedef struct {
    DWORD   Signature;			// Identifies Remote Command Service
    DWORD   RequestedLevel;		// Level of functionality desired
    ULONG   CommandLength;		// Length of command.
} COMMAND_FIXED_HEADER, *PCOMMAND_FIXED_HEADER;

typedef struct {
    COMMAND_FIXED_HEADER CommandFixedHeader;
    UCHAR   Command[MAX_CMD_LENGTH+1];	// Present if CommandLength non-zero
					// Not zero terminated, but +1 allows
					// for local use with string
} COMMAND_HEADER, *PCOMMAND_HEADER;


typedef struct {
    DWORD   Signature;
    DWORD   SupportedLevel;		// Level or Error Response
} RESPONSE_HEADER, *PRESPONSE_HEADER;

#define RCMD_SIGNATURE 'RC94'

//
// SupportedLevel is Error response if RC_ERROR_RESPONSE
//

#define RC_ERROR_RESPONSE	      0x80000000L

//
// SupportedLevel is Level response if RC_LEVEL_RESPONSE
//

#define RC_LEVEL_RESPONSE    0x40000000L
#define RC_LEVEL_REQUEST     0x40000000L

#define RC_LEVEL_BASIC	     0x00000001L  // Basic functionality - stdin/out only

void print_help();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\poltest\poltest.c ===
#include <windows.h>
#include <ole2.h>
#include <userenv.h>
#define SECURITY_WIN32
#include <security.h>
#include <dsgetdc.h>
#include <lm.h>
#include <shellapi.h>
#include <commdlg.h>
#include "poltest.h"


HINSTANCE hInst;
HWND      hwndMain;
HWND      hwndListBox;
HMENU     hMenu;
HANDLE    hMachineSection;
HANDLE    hUserSection;
HANDLE    hMachineEvent;
HANDLE    hUserEvent;
HANDLE    hExit;
HANDLE    hThread;
BOOL      bVerbose = FALSE;
BOOL      bSync = FALSE;


TCHAR szAppName[] = TEXT("PolTest");
TCHAR szTitle[]   = TEXT("Group Policy Tester");

/****************************************************************************

        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

        PURPOSE: calls initialization function, processes message loop

****************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, INT nCmdShow)
{
        MSG msg;
        HANDLE hAccelTable;

        if (!hPrevInstance)
           {
           if (!InitApplication(hInstance))
              {
              return (FALSE);
              }
           }

        // Perform initializations that apply to a specific instance
        if (!InitInstance(hInstance, nCmdShow))
           {
           return (FALSE);
           }

        hAccelTable = LoadAccelerators (hInstance, szAppName);

        while (GetMessage(&msg, NULL, 0, 0))
           {
           if (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg))
              {
              TranslateMessage(&msg);
              DispatchMessage(&msg);
              }
           }


        SetEvent (hExit);
        WaitForSingleObject (hThread, INFINITE);
        CloseHandle (hExit);
        CloseHandle (hMachineEvent);
        CloseHandle (hUserEvent);
        CloseHandle (hThread);

        return (msg.wParam);

        lpCmdLine;
}


/****************************************************************************

        FUNCTION: InitApplication(HINSTANCE)

        PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL InitApplication(HINSTANCE hInstance)
{
        WNDCLASS  wc;


        hExit = CreateEvent (NULL, FALSE, FALSE, TEXT("poltest:  exit event"));

        if (!hExit) {
            AddString (TEXT("failed to create exit event"));
        }


        hMachineEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("poltest:  machine policy event"));

        if (!hMachineEvent) {
            AddString (TEXT("failed to create machine notify event"));
        }


        hUserEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("poltest:  user policy event"));

        if (!hUserEvent) {
            AddString (TEXT("failed to create user notify event"));
        }


        wc.style         = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc   = WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = hInstance;
        wc.hIcon         = LoadIcon (hInstance, szAppName);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = szAppName;
        wc.lpszClassName = szAppName;

        return (RegisterClass(&wc));
}


/****************************************************************************

        FUNCTION:  InitInstance(HINSTANCE, int)

        PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
        HWND  hWnd;
        HKEY hKey;
        DWORD dwSize,dwType;

        hInst = hInstance;

        hWnd = CreateWindow(szAppName,
                            szTitle,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT, 0, 500, 500,
                            NULL,
                            NULL,
                            hInstance,
                            NULL);

        if (!hWnd)
           {
           return (FALSE);
           }
        else
          {
          hwndMain = hWnd;
          }


        ShowWindow(hWnd, SW_SHOWDEFAULT);
        UpdateWindow(hWnd);

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics"),
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bVerbose);
            RegQueryValueEx (hKey, TEXT("RunDiagnosticLoggingGroupPolicy"),
                             NULL, &dwType, (LPBYTE) &bVerbose, &dwSize);

            RegCloseKey (hKey);
        }

        CheckMenuItem (GetMenu(hWnd), IDM_VERBOSE, MF_BYCOMMAND |
                       (bVerbose ? MF_CHECKED : MF_UNCHECKED));

        if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                          0, KEY_READ, &hKey) == ERROR_SUCCESS) {

            dwSize = sizeof(bSync);
            RegQueryValueEx (hKey, TEXT("SynchronousGroupPolicy"),
                             NULL, &dwType, (LPBYTE) &bSync, &dwSize);

            RegCloseKey (hKey);
        }

        CheckMenuItem (GetMenu(hWnd), IDM_SYNCPOLICY, MF_BYCOMMAND |
                       (bSync ? MF_CHECKED : MF_UNCHECKED));

        return (TRUE);

}

/****************************************************************************

        FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)

        PURPOSE:  Processes messages

****************************************************************************/

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD dwID;

        switch (message)
           {
           case WM_CREATE:
                {
                RECT rc;

                GetClientRect (hWnd, &rc);

                hMenu = GetMenu(hWnd);

                EnableMenuItem (hMenu, IDM_RESUME_MACHINE, MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem (hMenu, IDM_RESUME_USER, MF_BYCOMMAND | MF_GRAYED);

                hwndListBox = CreateWindow(TEXT("LISTBOX"),
                                    NULL,
                                    WS_CHILDWINDOW | WS_VSCROLL | WS_VISIBLE | LBS_NOINTEGRALHEIGHT,
                                    0, 0, rc.right, rc.bottom,
                                    hWnd,
                                    NULL,
                                    hInst,
                                    NULL);

                SendMessage (hwndListBox, WM_SETFONT, (WPARAM) GetStockObject(ANSI_VAR_FONT), 0);


                hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE) NotifyThread,
                                        0, 0, &dwID);


                }
                break;

           case WM_COMMAND:
              {
              switch (LOWORD(wParam))
                 {
                 case IDM_UPDATE_MACHINE:
                    RefreshPolicy (TRUE);
                    break;

                 case IDM_UPDATE_USER:
                    RefreshPolicy (FALSE);
                    break;

                 case IDM_PAUSE_MACHINE:
                    hMachineSection = EnterCriticalPolicySection (TRUE);

                    if (hMachineSection) {
                        EnableMenuItem (hMenu, IDM_RESUME_MACHINE, MF_BYCOMMAND | MF_ENABLED);
                        EnableMenuItem (hMenu, IDM_PAUSE_MACHINE, MF_BYCOMMAND | MF_GRAYED);
                    } else {
                        AddString (TEXT("Failed to claim critical section."));
                    }
                    break;

                 case IDM_RESUME_MACHINE:
                    LeaveCriticalPolicySection (hMachineSection);
                    hMachineSection = NULL;
                    EnableMenuItem (hMenu, IDM_RESUME_MACHINE, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem (hMenu, IDM_PAUSE_MACHINE, MF_BYCOMMAND | MF_ENABLED);
                    break;

                 case IDM_PAUSE_USER:
                    hUserSection = EnterCriticalPolicySection (FALSE);

                    if (hUserSection) {
                        EnableMenuItem (hMenu, IDM_RESUME_USER, MF_BYCOMMAND | MF_ENABLED);
                        EnableMenuItem (hMenu, IDM_PAUSE_USER, MF_BYCOMMAND | MF_GRAYED);
                    } else {
                        AddString (TEXT("Failed to claim critical section."));
                    }
                    break;

                 case IDM_RESUME_USER:
                    LeaveCriticalPolicySection (hUserSection);
                    hUserSection = NULL;
                    EnableMenuItem (hMenu, IDM_RESUME_USER, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem (hMenu, IDM_PAUSE_USER, MF_BYCOMMAND | MF_ENABLED);
                    break;

                 case IDM_EXIT:
                    DestroyWindow (hwndMain);
                    break;


                 case IDM_VERBOSE:
                    {
                    HKEY hKey;
                    DWORD dwDisp, dwTemp;
                    TCHAR szMsg[MAX_PATH];
                    LONG lResult;

                    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Diagnostics"),
                                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                              NULL, &hKey, &dwDisp);

                    if (lResult == ERROR_SUCCESS) {

                        bVerbose = !bVerbose;

                        RegSetValueEx (hKey, TEXT("RunDiagnosticLoggingGroupPolicy"),
                                       0, REG_DWORD, (LPBYTE) &bVerbose, sizeof(bVerbose));

                        RegCloseKey (hKey);

                        CheckMenuItem (GetMenu(hWnd), IDM_VERBOSE, MF_BYCOMMAND |
                                       (bVerbose ? MF_CHECKED : MF_UNCHECKED));
                    } else {

                        szMsg[0] = TEXT('\0');

                        FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                                      NULL, lResult,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                      szMsg, MAX_PATH, NULL);

                        MessageBox (hWnd, szMsg, TEXT("Error setting registry value"),
                                    MB_OK | MB_ICONERROR);
                    }

                    }
                    break;

                 case IDM_EVENTVWR:
                    ShellExecute (NULL, TEXT("open"), TEXT("eventvwr.msc"), NULL,
                                  NULL, SW_SHOWNORMAL);
                    break;

                 case IDM_USERNAME:
                    {
                    TCHAR szName[512];
                    DWORD dwSize = 512;

                    if (GetUserNameEx(NameFullyQualifiedDN, szName, &dwSize)) {
                        AddString (szName);
                    } else {
                        TCHAR szError[100];

                        wsprintf (szError, TEXT("Failed to get user name with %d"), GetLastError());
                        AddString (szError);
                    }
                    }
                    break;

                 case IDM_COMPUTERNAME:
                    {
                    TCHAR szName[512];
                    DWORD dwSize = 512;

                    if (GetComputerObjectName(NameFullyQualifiedDN, szName, &dwSize)) {
                        AddString (szName);
                    } else {
                        TCHAR szError[100];

                        wsprintf (szError, TEXT("Failed to get computer name with %d"), GetLastError());
                        AddString (szError);
                    }
                    }
                    break;

                 case IDM_SITENAME:
                    {
                    LPTSTR lpName;
                    ULONG ulResult;

                    ulResult = DsGetSiteName (NULL, &lpName);

                    if (ulResult == ERROR_SUCCESS) {
                        AddString (lpName);
                        NetApiBufferFree (lpName);
                    } else {
                        TCHAR szError[100];

                        wsprintf (szError, TEXT("Failed to get site name with %d"), ulResult);
                        AddString (szError);
                    }
                    }
                    break;

                 case IDM_PDCNAME:
                    {
                    DWORD dwResult;
                    PDOMAIN_CONTROLLER_INFO pDCI;


                    dwResult = DsGetDcName (NULL, NULL, NULL, NULL,
                                            DS_DIRECTORY_SERVICE_REQUIRED | DS_PDC_REQUIRED,
                                            &pDCI);

                    if (dwResult == ERROR_SUCCESS) {
                        AddString (pDCI->DomainControllerName);
                        NetApiBufferFree(pDCI);

                    } else {
                        TCHAR szBuffer[100];

                        wsprintf (szBuffer, TEXT("Failed to get the PDC name with %d"), dwResult);
                        AddString (szBuffer);
                    }
                    }
                    break;

                 case IDM_SYNCPOLICY:
                    {
                    HKEY hKey;
                    DWORD dwDisp, dwTemp;
                    TCHAR szMsg[MAX_PATH];
                    LONG lResult;

                    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                              0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                              NULL, &hKey, &dwDisp);

                    if (lResult == ERROR_SUCCESS) {

                        bSync = !bSync;

                        RegSetValueEx (hKey, TEXT("SynchronousGroupPolicy"),
                                       0, REG_DWORD, (LPBYTE) &bSync, sizeof(bSync));

                        RegCloseKey (hKey);

                        CheckMenuItem (GetMenu(hWnd), IDM_SYNCPOLICY, MF_BYCOMMAND |
                                       (bSync ? MF_CHECKED : MF_UNCHECKED));

                        AddString (TEXT("You need to reboot for this change to take effect."));

                    } else {

                        szMsg[0] = TEXT('\0');

                        FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                                      NULL, lResult,
                                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                      szMsg, MAX_PATH, NULL);

                        MessageBox (hWnd, szMsg, TEXT("Error setting registry value"),
                                    MB_OK | MB_ICONERROR);
                    }

                    }
                    break;

                 case IDM_DCLIST:
                    ManageDomainInfo(hWnd);
                    break;

                 case IDM_CHECKGPO:
                    CheckGPO(hWnd);
                    break;

                 case IDM_CLEARWINDOW:
                    SendMessage (hwndListBox, LB_RESETCONTENT, 0, 0);
                    break;

                 case IDM_SAVEAS:
                    {
                    HANDLE hFile;
                    INT iCount, i;
                    DWORD dwWrite;
                    TCHAR szFilter[100];
                    TCHAR szFileName[MAX_PATH];
                    CHAR szString[MAX_PATH];
                    TCHAR szError[100];
                    CHAR szLF[] = "\r\n";
                    OPENFILENAME ofn;

                    iCount = SendMessage (hwndListBox, LB_GETCOUNT, 0, 0);

                    if (iCount == LB_ERR) {
                        break;
                    }

                    lstrcpy (szFileName, TEXT("Poltest Results.txt"));

                    ZeroMemory (szFilter, sizeof(szFilter));

                    lstrcpy (szFilter, TEXT("Text Files#*.txt"));
                    szFilter[10] = TEXT('\0');

                    ZeroMemory (&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hWnd;
                    ofn.hInstance = hInst;
                    ofn.lpstrFile = szFileName;
                    ofn.nMaxFile =  MAX_PATH;
                    ofn.lpstrFilter = szFilter;
                    ofn.lpstrDefExt = TEXT("txt");
                    ofn.Flags = OFN_CREATEPROMPT | OFN_ENABLESIZING | OFN_HIDEREADONLY |
                                OFN_OVERWRITEPROMPT;

                    if (!GetSaveFileName (&ofn)) {
                        break;
                    }

                    hFile = CreateFile (szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL, NULL);

                    if (hFile == INVALID_HANDLE_VALUE) {
                        wsprintf (szError, TEXT("Failed to open file with %d"), GetLastError());
                        AddString (szError);
                        break;
                    }

                    for (i = 0; i < iCount; i++) {
                        szString[0] = '\0';
                        SendMessageA (hwndListBox, LB_GETTEXT, i, (LPARAM)szString);
                        WriteFile (hFile, szString, lstrlenA(szString),
                                   &dwWrite, NULL);
                        WriteFile (hFile, szLF, lstrlenA(szLF),
                                   &dwWrite, NULL);
                    }

                    CloseHandle (hFile);
                    }
                    break;

                 default:
                    return (DefWindowProc(hWnd, message, wParam, lParam));
                 }
              }
              break;

           case WM_WININICHANGE:

              if (!lstrcmpi ((LPTSTR)lParam, TEXT("Policy"))) {

                   if (wParam) {
                       AddString (TEXT("Received WM_WININICHANGE:  machine policy applied."));
                   } else {
                       AddString (TEXT("Received WM_WININICHANGE:  user policy applied."));
                   }
              }
              break;

           case WM_SIZE:
                SetWindowPos (hwndListBox, HWND_TOP, 0, 0,
                              LOWORD(lParam), HIWORD(lParam),
                              SWP_NOMOVE | SWP_NOZORDER);
                break;

           case WM_DESTROY:
              PostQuitMessage(0);
              break;

           default:
              return (DefWindowProc(hWnd, message, wParam, lParam));
           }

        return FALSE;
}

VOID AddString (LPTSTR lpString)
{
    SYSTEMTIME systime;
    TCHAR  szString[300];

    GetLocalTime (&systime);
    wsprintf (szString, TEXT("%02d:%02d:%02d:%03d   %s"),
              systime.wHour, systime.wMinute, systime.wSecond,
              systime.wMilliseconds, lpString);


    SendMessage (hwndListBox, LB_INSERTSTRING, -1,
                 (LPARAM) szString);

}

DWORD NotifyThread (DWORD dwDummy)
{
    HANDLE hHandles[3];
    DWORD dwResult;


    RegisterGPNotification(hMachineEvent, TRUE);
    RegisterGPNotification(hUserEvent, FALSE);

    hHandles[0] = hExit;
    hHandles[1] = hMachineEvent;
    hHandles[2] = hUserEvent;

    while (TRUE) {

        dwResult = WaitForMultipleObjects (3, hHandles, FALSE, INFINITE);

        if ((dwResult == WAIT_FAILED) || ((dwResult - WAIT_OBJECT_0) == 0)) {
            if (dwResult == WAIT_FAILED) {
                AddString (TEXT("WaitForMultipleObjects failed."));
            }
            break;
        }

        if ((dwResult - WAIT_OBJECT_0) == 1) {
            AddString (TEXT("Machine notify event signaled."));
        } else {
            AddString (TEXT("User notify event signaled."));
        }
    }

    UnregisterGPNotification(hMachineEvent);
    UnregisterGPNotification(hUserEvent);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\ntclient\rcmd.c ===
/****************************** Module Header ******************************\
* Module Name: rcmd.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell NT client main module
*
* History:
* 05-20-92 Davidc       Created.
* 05-01-94 DaveTh       Modified for remote command service (single cmd mode)
\***************************************************************************/

// #define UNICODE	// BUGBUG - Unicode support not complete

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <assert.h>
#include <conio.h>

#include <rcmd.h>

#define PIPE_NAME   TEXT("%hs\\pipe\\rcmdsvc")
#define BUFFER_SIZE 1000
#define MAX_SERVER_NAME_LENGTH	15

//
// Globals
//

HANDLE PipeHandle = NULL;	    // These are used by Ctrl-C handler
BOOLEAN SessionConnected = FALSE;
BOOLEAN MultiServerMode = FALSE;
HANDLE ReadThreadHandle;
HANDLE WriteThreadHandle;

BOOLEAN RcDbgPrintEnable = FALSE;   // If TRUE, enables DbgPrint

LPTSTR    ServerName = NULL;	    // Name of remote server, for messages


//
// Private prototypes
//

DWORD
ReadThreadProc(
    LPVOID Parameter
    );

DWORD
WriteThreadProc(
    LPVOID Parameter
    );

BOOL
CtrlHandler(
    DWORD CtrlType
    );

int RcPrintf (
    const char *format,
    ...
    );

int RcDbgPrint (
    const char *format,
    ...
    );

void Usage(
    void
    );

long ParseCommandLine(
    LPTSTR lpszServer,
    COMMAND_HEADER *chCommandHeader,
    LPTSTR *aszArgv,
    int iArgc
    );


void
Usage(
    void
    )
/*++

Routine Description:

    Prints a usage message and exits the program

Arguments:

    None

Return Value:

    void

--*/
{
	RcPrintf("\nUsage: rcmd [server_name [command] ]\n\n");
	RcPrintf("Prompts for server_name if  not supplied.   Session is\n");
	RcPrintf("interactive and is terminated by ctrl-Break or Exit of\n");
	RcPrintf("remote shell.   Program is terminated by ctrl-Break or\n");
	RcPrintf("ctrl-C when no session is in progress.\n\n");
	RcPrintf("If no command supplied,  session is interactive and is\n");
	RcPrintf("terminated by ctrl-Break  or Exit  of remote cmd shell\n\n");
	RcPrintf("If command is supplied,  remote shell executes  single\n");
	RcPrintf("command on specified server and exits.\n\n");
	RcPrintf("Note : Command line server_name requires leading '\\\\'s\n");

    exit(0);
}



LONG ParseCommandLine(
    LPTSTR lpszServer,
    COMMAND_HEADER *chCommandHeader,
    LPTSTR *aszArgv,
    int iArgc
    )
/*++

Routine Description:

    Parses command line of the form:
    rcmd [server_name [[command] | ["command"]]

Arguments:

    lpszServer      - on exit gets the name of the server from the command line
    chCommandHeader - information to pass to rcmdsvc on exit
    aszArgv         - array of zero terminated strings (passed in from command line)
    iArgc           - number of strings in argv (passed in from command line)

Return Value:

    LONG

--*/
{

    LPTSTR buf = NULL;
    LONG nChars = 0;
    int i;

    //
    // get the first argument (either the server name or a [-/][?hH])
    //
    if (iArgc > 1)
    {
        //
        // convert argument to lower case
        //
        CharLowerBuff(aszArgv[1], lstrlen(aszArgv[1]));

        //
        // check for switch (only ?Hh are valid)
        //
        if ((*aszArgv[1] == TEXT('-')) ||
            (*aszArgv[1] == TEXT('/'))) {
            //
            // check the switch
            //
            if ( (aszArgv[1][1] == TEXT('h')) ||
                 (aszArgv[1][1] == TEXT('?')) ) {
                Usage();
            }
            else {
                RcPrintf(TEXT("Unknown switch %s\n"), aszArgv[1]);
                Usage();
            }
        }
        else if ( (*aszArgv[1] == TEXT('\\'))  && (aszArgv[1][1] == TEXT('\\'))) {
            //
            // first argument is a server name
            //
            lstrcpy(lpszServer, aszArgv[1]);
        }
        else {
            //
            // usage error
            //
            Usage();
        }

    }
    else {
        //
        // user failed to enter a server name
        // default to local machine
        //
        lstrcpy(lpszServer, "\\\\.");
    }

    //
    // If user entered anything beyond the server name, save it for passing to
    // to rcmdsvc.
    //

    // init
    chCommandHeader->CommandFixedHeader.CommandLength = 0;
    buf = chCommandHeader->Command;
    buf[0] = TEXT('\0');
    for (i = 2; i < iArgc; i++) {
        //
        // append each argument to saved command line
        //
        if (NULL != strchr(aszArgv[i], ' '))
        {
            nChars = wsprintf(buf, "\"%s\" ", aszArgv[i]);
        }
        else
        {
            nChars = wsprintf(buf, "%s ", aszArgv[i]);
        }
        buf += nChars;
        chCommandHeader->CommandFixedHeader.CommandLength += nChars;
    }
    //
    // in case we went too far, truncate the string
    //
    chCommandHeader->Command[MAX_CMD_LENGTH] = TEXT('\0');

    return (long)iArgc;
}



/***************************************************************************\
* FUNCTION: Main
*
* PURPOSE:  Main entry point.
*
* RETURNS:  0 on success, 1 on failure
*
* HISTORY:
*
*   07-10-92 Davidc       Created.
*
\***************************************************************************/

int
__cdecl main(
    int argc,
    char **argv
    )
{

    SECURITY_ATTRIBUTES SecurityAttributes;
    HANDLE StdInputHandle;
    HANDLE StdOutputHandle;
    HANDLE StdErrorHandle;
    CHAR  PipeName[MAX_PATH];
    //WCHAR  PipeName[MAX_PATH];
    DWORD ThreadId;
    HANDLE HandleArray[2];
    COMMAND_HEADER CommandHeader;
    RESPONSE_HEADER ResponseHeader;
    DWORD BytesWritten, BytesRead;
    DWORD Result;
    CHAR ServerNameBuffer[MAX_SERVER_NAME_LENGTH+3];  // +3 for gets counts, null
    CHAR FullServerNameBuffer[MAX_SERVER_NAME_LENGTH+3];  // +3 for "\\", null
    LONG nArgs = 0;
    BOOLEAN bBadServerName = TRUE;

    //
    // Install a handler for Ctrl-C
    //

    if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE) &CtrlHandler, TRUE)) {
    	RcPrintf("Error:1 - Internal error = %d\n", GetLastError());
    	return(1);
    }

    //
    // Command line parsing
    //
    nArgs = ParseCommandLine(FullServerNameBuffer, &CommandHeader, argv, argc);
    ServerName = FullServerNameBuffer;

    if (nArgs == 1)  {
    	MultiServerMode = TRUE;
        ServerNameBuffer[0] = MAX_SERVER_NAME_LENGTH;
       	FullServerNameBuffer[0] = '\\';
        FullServerNameBuffer[1] = '\\';
        }

    //
    //  Loop for MultServerMode case (will return appropriately if not)
    //

    while (TRUE) {

        //
        //	If MultiServerMode, prompt for server name until it's right (enough)
        //
        while (MultiServerMode) {

            //
            //  BUGBUG - call netapi to validate server name
            //

            RcPrintf("\nEnter Server Name : ");
            FullServerNameBuffer[2] = '\0';  // re-terminate "\\" string
            ServerNameBuffer[0] = MAX_SERVER_NAME_LENGTH;
            ServerName = strcat(FullServerNameBuffer, _cgets(ServerNameBuffer));

            if (strlen(ServerName) < 3) {
                RcPrintf("\nError - Invalid Server Name\n");
            } else {
                break;	// valid name, go on
            }
        }


        //
        // Construct server pipe name
        //

        wsprintf(PipeName, PIPE_NAME, ServerName);


        //
        // Store away our normal i/o handles
        //

        if (((StdInputHandle = GetStdHandle(STD_INPUT_HANDLE)) == INVALID_HANDLE_VALUE) ||
            ((StdOutputHandle = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE) ||
            ((StdErrorHandle = GetStdHandle(STD_ERROR_HANDLE)) == INVALID_HANDLE_VALUE))  {

            RcPrintf("Error:2 - Internal error = %d\n", GetLastError());
            return(1);  // catastrophic error - exit
        }


        //
        // Open the named pipe - need security flags to pass all privileges, not
        // just effective during impersonation
        //

        SecurityAttributes.nLength = sizeof(SecurityAttributes);
        SecurityAttributes.lpSecurityDescriptor = NULL; // Use default SD
        SecurityAttributes.bInheritHandle = FALSE;

        PipeHandle = CreateFile(PipeName,                     // pipe to server
                         GENERIC_READ | GENERIC_WRITE, // read/write
                         0,                            // No sharing
                         &SecurityAttributes,          // default Security Descriptor
                         OPEN_EXISTING,                // open existing pipe if it exists
                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED |
                         SECURITY_SQOS_PRESENT |
                         SECURITY_IMPERSONATION | SECURITY_CONTEXT_TRACKING,
                         NULL                       // Template file
                         );

        if (PipeHandle == INVALID_HANDLE_VALUE ) {
    	    Result = GetLastError();
    	    RcDbgPrint("Failed to open named pipe, error = %d\n", Result);

        	switch (Result) {

        	case ERROR_FILE_NOT_FOUND:
        	    RcPrintf("Error - Failed to connect to <%s>, system not found or service not active\n", ServerName);
        	    break;

        	case ERROR_PIPE_BUSY:
        	    RcPrintf("Error - Failed to connect to <%s>, remote command server busy\n", ServerName);
        	    break;

        	default:
        	    RcPrintf("Error - Failed to connect to <%s>, Error = %d\n", ServerName, GetLastError());

    	    }
            goto ServerError;
        }

        //
        //  Send command header - if single command mode, send command for
        //  excecute and return.  else 0 length indicates no command present
        //  Specify BASIC level support desired.
        //

        CommandHeader.CommandFixedHeader.Signature = RCMD_SIGNATURE;
        CommandHeader.CommandFixedHeader.RequestedLevel =
            RC_LEVEL_REQUEST | RC_LEVEL_BASIC;

        if (!WriteFile(
             PipeHandle,
    	     &CommandHeader,
    	     sizeof(CommandHeader.CommandFixedHeader) +
    		 CommandHeader.CommandFixedHeader.CommandLength,
    	     &BytesWritten,
    	     NULL ))  {
    	RcPrintf("Error - Failed to send to remote command server, Error = %ld\n", GetLastError());
    	goto ServerError;
        }

        //
        //  Get response header.  Will specify reported level or any error.
        //

        if ((!ReadFile(
    	    PipeHandle,
    	    &ResponseHeader,
    	    sizeof(ResponseHeader),
    	    &BytesRead,
    	    NULL)) || (BytesRead != sizeof(ResponseHeader)))  {

    	RcPrintf("Error - Remote command server failed to respond, Error = %ld\n", GetLastError());
    	goto ServerError;
        }

        if (ResponseHeader.Signature != RCMD_SIGNATURE)  {
    	RcPrintf("Error - Incompatible remote command server\n");
    	goto ServerError;
        }

        //
        //  Check for returned errors or supported level
        //

        if (!(ResponseHeader.SupportedLevel ==
    	    (RC_LEVEL_RESPONSE | RC_LEVEL_BASIC)))  {

    	if (ResponseHeader.SupportedLevel & RC_ERROR_RESPONSE)  {

    	    //
    	    //  Error returned
    	    //

    	    switch  (ResponseHeader.SupportedLevel & ~RC_ERROR_RESPONSE)	 {

    	    case ERROR_ACCESS_DENIED:
    		RcPrintf("Error - You have insufficient access on the remote system\n");
    		break;

    	    default:
    		RcPrintf("Error - Failed to establish remote session, Error = %d\n",
    		    (ResponseHeader.SupportedLevel & ~RC_ERROR_RESPONSE));
    		break;

    	    } //switch

    	    goto ServerError;

    	} else if (ResponseHeader.SupportedLevel & RC_LEVEL_RESPONSE)  {

    	    //
    	    //  Supported level returned - but not a valid value (not BASIC)
    	    //

    	    RcPrintf("Error - Invalid support level returned\n");
    	    goto ServerError;

    	}  else  {

    	    //
    	    //  Neither error nor supported level returned
    	    //

    	    RcPrintf("Error - Invalid response from remote server\n");
    	    goto ServerError;

    	}
        }

        //
        // All is well - Session is connected
        //

        SessionConnected = TRUE;

        if (CommandHeader.CommandFixedHeader.CommandLength == 0) {
            RcPrintf("Connected to %s\n\n", ServerName);
        } else {
            RcPrintf("Executing on %s: %s\n\n", ServerName, CommandHeader.Command);
        }

        //
        // Exec 2 threads - 1 copies data from stdin to pipe, the other
        // copies data from the pipe to stdout.
        //

        ReadThreadHandle = CreateThread(
    			NULL,                       // Default security
    			0,                          // Default Stack size
    			(LPTHREAD_START_ROUTINE) ReadThreadProc,
    			(PVOID)PipeHandle,
    			0,
    			&ThreadId);

        if (ReadThreadHandle == NULL) {
    	RcPrintf("Error:3 - Internal error = %ld\n", GetLastError());
    	return(1);  // catastrophic error - exit
        }


        //
        // Create the write thread
        //

        WriteThreadHandle = CreateThread(
    			NULL,                       // Default security
    			0,                          // Default Stack size
    			(LPTHREAD_START_ROUTINE) WriteThreadProc,
    			(PVOID)PipeHandle,
    			0,
    			&ThreadId);

        if (WriteThreadHandle == NULL) {
    	RcPrintf("Error:4 - Internal error = %ld\n", GetLastError());
    	TerminateThread(ReadThreadHandle, 0);
    	CloseHandle(ReadThreadHandle);
    	return(1);  // catastrophic error, exit
        }



        //
        // Wait for either thread to finish
        //

        HandleArray[0] = ReadThreadHandle;
        HandleArray[1] = WriteThreadHandle;

        Result = WaitForMultipleObjects(
    			    2,
    			    HandleArray,
    			    FALSE,              // Wait for either to finish
    			    0xffffffff
    			   );			// Wait forever

        //
        //	Finished - terminate other thread and close pipe handle
        //


        if (Result == (WAIT_OBJECT_0 + 0))	{    // Read thread finished - terminate write
    	TerminateThread(WriteThreadHandle, 0);
        }

        if (Result == (WAIT_OBJECT_0 + 1))	{    // Write thread finished - terminate read
    	TerminateThread(ReadThreadHandle, 0);
        }

        RcDbgPrint("Read or write thread terminated\n");


        //
        // Close our pipe handle
        //

        CloseHandle(PipeHandle);
        PipeHandle = NULL;


        //
        //	Re-enable normal ctrl-C processing
        //

        SessionConnected = FALSE;

        //
        //	Normal completion - return if not MultServerMode
        //

        if (!MultiServerMode)  {
            //
            // return - process exit will terminate threads and close thread handles
            //
            return(1);
        }

ServerError:

        if (PipeHandle != NULL) {
            CloseHandle(PipeHandle);
        }

        if (!MultiServerMode) {
            //
            //  return false on error - process exit terminates threads/closes handles
            //
            return(0);
        }

        //
        //	Multi-service mode exits occurs with ctrl-C/break only
        //
    }

}


/***************************************************************************\
* FUNCTION: ReadPipe
*
* PURPOSE:  Implements an overlapped read such that read and write operations
*           to the same pipe handle don't deadlock.
*
* RETURNS:  TRUE on success, FALSE on failure (GetLastError() has error)
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
ReadPipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
			      NULL,         // no security
			      TRUE,         // Manual reset
			      FALSE,        // Initial state
			      NULL          // Name
			     );
    if (EventHandle == NULL) {
	RcDbgPrint("ReadPipe: CreateEvent failed, error = %d\n", GetLastError());
	return(FALSE);
    }

    Overlapped.hEvent = EventHandle;
    Overlapped.Internal = 0;
    Overlapped.InternalHigh = 0;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;


    Result = ReadFile(
		      PipeHandle,
		      lpBuffer,
		      nNumberOfBytesToRead,
		      lpNumberOfBytesRead,
		      &Overlapped
		     );
    if (Result) {

	//
	// Success without waiting - it's too easy !
	//

	CloseHandle(EventHandle);

    } else {

	//
	// Read failed, if it's overlapped io, go wait for it
	// If failure due to server, print appropriate message.
	//

	Error = GetLastError();

	switch (Error)  {

	case ERROR_IO_PENDING:
	    break;

	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_BROKEN_PIPE:
	    RcPrintf("\nRemote server %s disconnected\n", ServerName);
	    CloseHandle(EventHandle);
	    return(FALSE);

	default:
	    RcPrintf("Error:5 - Internal error = %d\n", Error);
	    RcDbgPrint("ReadPipe: ReadFile failed, error = %d\n", Error);
	    CloseHandle(EventHandle);
	    return(FALSE);

	}

	//
	// Wait for the I/O to complete
	//

	Result = WaitForSingleObject(EventHandle, (DWORD)-1);
	if (Result != 0) {
	    RcDbgPrint("ReadPipe: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    CloseHandle(EventHandle);
	    return(FALSE);
	}

	//
	// Go get the I/O result
	//

	Result = GetOverlappedResult( PipeHandle,
				      &Overlapped,
				      lpNumberOfBytesRead,
				      FALSE
				    );
	//
	// We're finished with the event handle
	//

	CloseHandle(EventHandle);

	//
	// Check result of GetOverlappedResult
	//

	if (!Result) {
	    Error = GetLastError();

	    switch (Error)  {

	    case ERROR_PIPE_NOT_CONNECTED:
	    case ERROR_BROKEN_PIPE:
		RcPrintf("\nRemote server %s disconnected\n", ServerName);
		return(FALSE);

	    default:
		RcPrintf("Error:9 - Internal error = %d\n", Error);
		RcDbgPrint("ReadPipe: GetOverLappedRsult failed, error = %d\n", Error);
		return(FALSE);
	    }

	}
    }

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: WritePipe
*
* PURPOSE:  Implements an overlapped write such that read and write operations
*           to the same pipe handle don't deadlock.
*
* RETURNS:  TRUE on success, FALSE on failure (GetLastError() has error)
*
* HISTORY:
*
*   05-27-92 Davidc       Created.
*
\***************************************************************************/

BOOL
WritePipe(
    HANDLE PipeHandle,
    CONST VOID *lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
			      NULL,         // no security
			      TRUE,         // Manual reset
			      FALSE,        // Initial state
			      NULL          // Name
			     );
    if (EventHandle == NULL) {
	RcDbgPrint("WritePipe: CreateEvent failed, error = %d\n", GetLastError());
	return(FALSE);
    }

    Overlapped.hEvent = EventHandle;
    Overlapped.Internal = 0;
    Overlapped.InternalHigh = 0;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;

    Result = WriteFile(
		      PipeHandle,
		      lpBuffer,
		      nNumberOfBytesToWrite,
		      lpNumberOfBytesWritten,
		      &Overlapped
		     );
    if (Result) {

	//
	// Success without waiting - it's too easy !
	//

	CloseHandle(EventHandle);

    } else {

	//
	// Write failed, if it's overlapped io, go wait for it
	// If failure due to server, print appropriate message.
	//

	Error = GetLastError();

	switch (Error)  {

	case ERROR_IO_PENDING:
	    break;

	case ERROR_PIPE_NOT_CONNECTED:
	case ERROR_BROKEN_PIPE:
	    RcPrintf("\nRemote server %s disconnected\n", ServerName);
	    CloseHandle(EventHandle);
	    return(FALSE);

	default:
	    RcPrintf("Error:6 - Internal error = %d\n", Error);
	    RcDbgPrint("WritePipe: WriteFile failed, error = %d\n", Error);
	    CloseHandle(EventHandle);
	    return(FALSE);

	}

	//
	// Wait for the I/O to complete
	//

	Result = WaitForSingleObject(EventHandle, (DWORD)-1);
	if (Result != 0) {
	    RcDbgPrint("WritePipe: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    CloseHandle(EventHandle);
	    return(FALSE);
	}

	//
	// Go get the I/O result
	//

	Result = GetOverlappedResult( PipeHandle,
				      &Overlapped,
				      lpNumberOfBytesWritten,
				      FALSE
				    );
	//
	// We're finished with the event handle
	//

	CloseHandle(EventHandle);

	//
	// Check result of GetOverlappedResult
	//

	if (!Result) {
	    Error = GetLastError();

	    switch (Error)  {

	    case ERROR_PIPE_NOT_CONNECTED:
	    case ERROR_BROKEN_PIPE:
		RcPrintf("\nRemote server %s disconnected\n", ServerName);
		return(FALSE);

	    default:
		RcPrintf("Error:10 - Internal error = %d\n", Error);
		RcDbgPrint("WritePipe: GetOverLappedRsult failed, error = %d\n", Error);
		return(FALSE);
	    }
	}
    }

    return(TRUE);
}


/***************************************************************************\
* FUNCTION: ReadThreadProc
*
* PURPOSE:  The read thread procedure. Reads from pipe and writes to STD_OUT
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   05-21-92 Davidc       Created.
*
\***************************************************************************/

DWORD
ReadThreadProc(
    LPVOID Parameter
    )
{
    HANDLE  PipeHandle = Parameter;
    BYTE    Buffer[BUFFER_SIZE];
    DWORD   BytesRead;
    DWORD   BytesWritten;

    while (ReadPipe(PipeHandle, Buffer, sizeof(Buffer), &BytesRead)) {
		if (!WriteFile(
			    GetStdHandle(STD_OUTPUT_HANDLE),
			    Buffer,
			    BytesRead,
			    &BytesWritten,
			    NULL
			    )) {

		    RcPrintf("Error:7 - Internal error = %d\n", GetLastError());
		    RcDbgPrint("ReadThreadProc exitting, WriteFile error = %d\n",
		       GetLastError());
		    ExitThread((DWORD)0);
		    assert(FALSE);  // Should never get here
		    break;
		}
    }

    //
    //	ReadPipe issues more error information to user, debugger
    //	falls through here on read error
    //

    RcDbgPrint("WriteThreadProc exitting, ReadPipe failed\n");

    ExitThread((DWORD)0);

    return(0);
}


/***************************************************************************\
* FUNCTION: WriteThreadProc
*
* PURPOSE:  The write thread procedure. Reads from STD_INPUT and writes to pipe
*
* RETURNS:  Nothing
*
* HISTORY:
*
*   05-21-92 Davidc       Created.
*
\***************************************************************************/

DWORD
WriteThreadProc(
    LPVOID Parameter
    )
{
    HANDLE PipeHandle = Parameter;
    BYTE    Buffer[BUFFER_SIZE];
    DWORD   BytesRead;
    DWORD   BytesWritten;
    DWORD   Result;

    while (ReadFile(
		    GetStdHandle(STD_INPUT_HANDLE),
		    Buffer,
		    sizeof(Buffer),
		    &BytesRead,
		    NULL
		   )) {

	if ((DWORD)Buffer[0] == 0x0A0D0A0D)  {
	    RcPrintf("\nDouble crlf sent\n");
	    }

	if (!WritePipe(
		    PipeHandle,
		    Buffer,
		    BytesRead,
		    &BytesWritten
		 )) {

		//
		//  WritePipe issues more error information to user, debugger
		//

		RcDbgPrint("WriteThreadProc exitted due to WritePipe\n");
		ExitThread((DWORD)0);
		break;

	}
    }

    //
    //	Falls out if read fails
    //

    RcDbgPrint("WriteThreadProc, ReadFile error = %d\n", GetLastError());

    RcPrintf("Error:8 - Internal error = %d\n", GetLastError());
    ExitThread((DWORD)0);

    return(0);
}


/***************************************************************************\
* FUNCTION: CtrlHandler
*
* PURPOSE:  Handles console event notifications.
*
* RETURNS:  TRUE if the event has been handled, otherwise FALSE.
*
* HISTORY:
*
*   05-21-92 Davidc       Created.
*
\***************************************************************************/

BOOL
CtrlHandler(
    DWORD CtrlType
    )
{
    //
    // We'll handle Ctrl-C, Ctl-Break events if session is connected
    //

    if (SessionConnected)  {

	if (CtrlType == CTRL_C_EVENT)  {

	    //
	    //	Session established - pass ctl-C to remote server
	    //

	    if (PipeHandle != NULL) {

		//
		// Send a Ctrl-C to the server, don't care if it fails
		//

		CHAR	CtrlC = '\003';
		DWORD	BytesWritten;

		WriteFile(PipeHandle,
		      &CtrlC,
		      sizeof(CtrlC),
		      &BytesWritten,
		      NULL
		     );

		return(TRUE);  // we handled it
	    }

	    return(FALSE);  // no pipe - not handled (when in doubt, bail out)

	}  else if (CtrlType == CTRL_BREAK_EVENT)  {

	    if (MultiServerMode)  {

		//
		//   If ctl-Break in session w/MultiServerMode, break session
		//   BUGBUG - eliminate terminate thread
		//

		TerminateThread(ReadThreadHandle, 0);
		CloseHandle(ReadThreadHandle);
		TerminateThread(WriteThreadHandle, 0);
		CloseHandle(WriteThreadHandle);

		return(TRUE);  // we handled it

	    }  else  {

		//
		//  Not MultiServer mode - handle normally
		//

		return(FALSE);
	    }

	}  else {

	    return(FALSE);  // not ctl-c or break - we didn't handle it

	}

    }

    //
    // Not connected - we didn't handle it
    //

    return(FALSE);
}


/***************************************************************************\
* FUNCTION: RcPrintf
*
* PURPOSE:  Printf that uses low-level io.
*
* HISTORY:
*
*   07-15-92 Davidc       Created.
*
\***************************************************************************/

int RcPrintf (
    const char *format,
    ...
    )
{
    CHAR Buffer[MAX_PATH];
    va_list argpointer;
    int Result;
    DWORD BytesWritten;

    va_start(argpointer, format);

    Result = vsprintf(Buffer, format, argpointer);

    if (!WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), Buffer, Result, &BytesWritten, NULL)) {
	RcDbgPrint("RcPrintf : Write file to stdout failed, error = %d\n", GetLastError());
	Result = 0;
    }

    va_end(argpointer);

    return(Result);
}

/***************************************************************************\
* FUNCTION: RcDbgPrint
*
* PURPOSE:  DbgPrint enabled at runtime by setting RcDbgPrintEnable
*
* HISTORY:
*
*   05-22-92 DaveTh   Created.
*
\***************************************************************************/

int RcDbgPrint (
    const char *format,
    ...
    )
{
    CHAR Buffer[MAX_PATH];
    va_list argpointer;
    int iRetval = 0;

    if (RcDbgPrintEnable)  {

        va_start(argpointer, format);
        iRetval = vsprintf(Buffer, format, argpointer);
        assert (iRetval >= 0);
        va_end(argpointer);
        OutputDebugString(Buffer);

    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\async.c ===
/****************************** Module Header ******************************\
* Module Name: async.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* This module implements asynchronous I/O on file handles in a more
* useful way than provided for by Win32 apis.
*
* This module provides 2 main apis : ReadFileAsync, WriteFileAsync.
* These apis take a handle to an async object and always return
* immediately without waiting for the I/O to complete. An event
* can be queried from the async object and used to wait for completion.
* When this event is signalled, the I/O result can be queried from
* the async object.
*
* History:
* 06-29-92 Davidc       Created.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>
#include "rcmdsrv.h"

//
// Define RCOVERLAPPED structure
//

typedef struct {

    OVERLAPPED  Overlapped;

    HANDLE      FileHandle; // Non-null when I/O operation in progress.

    DWORD       CompletionCode;
    DWORD       BytesTransferred;
    BOOL        CompletedSynchronously;

} RCOVERLAPPED, *PRCOVERLAPPED;





/////////////////////////////////////////////////////////////////////////////
//
// CreateAsync
//
// Creates an async object.
// The async event is created with the initial state specified. If this
// is TRUE the async object created simulates a successfully completed
// transfer of 0 bytes.
//
// Returns handle on success, NULL on failure. GetLastError() for details.
//
// The object should be deleted by calling DeleteAsync.
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
CreateAsync(
    BOOL    InitialState
    )
{
    SECURITY_ATTRIBUTES SecurityAttributes;
    PRCOVERLAPPED   RcOverlapped;

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL; // Use default ACL
    SecurityAttributes.bInheritHandle = FALSE; // No inheritance

    //
    // Allocate space for the async structure
    //


    RcOverlapped = (PRCOVERLAPPED)Alloc(sizeof(RCOVERLAPPED));
    if (RcOverlapped == NULL) {
	RcDbgPrint("CreateAsync : Failed to allocate space for async object\n");
	return(NULL);
    }

    //
    // Create the synchronisation event
    //

    RcOverlapped->Overlapped.hEvent = CreateEvent( &SecurityAttributes,
						   TRUE,        // Manual-reset
						   InitialState,
						   NULL);       // Name
    if (RcOverlapped->Overlapped.hEvent == NULL) {
	RcDbgPrint("CreateAsync failed to create event, error = %d\n", GetLastError());
	Free(RcOverlapped);
	return(NULL);
    }

    //
    // Initialize other fields.
    // (Set FileHandle non-NULL to keep GetAsyncResult happy)
    //

    RcOverlapped->FileHandle = InitialState ? (HANDLE)1 : NULL;
    RcOverlapped->BytesTransferred = 0;
    RcOverlapped->CompletionCode = ERROR_SUCCESS;
    RcOverlapped->CompletedSynchronously = TRUE;


    return((HANDLE)RcOverlapped);
}




/////////////////////////////////////////////////////////////////////////////
//
// DeleteAsync
//
// Deletes resources used by async object
//
// Returns nothing
//
/////////////////////////////////////////////////////////////////////////////

VOID
DeleteAsync(
    HANDLE AsyncHandle
    )
{
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;
    DWORD   BytesTransferred;

    //
    // Wait for operation if in progress
    //


    if (GetAsyncResult(AsyncHandle, &BytesTransferred) == ERROR_IO_INCOMPLETE)  {
	if (WaitForSingleObject(
		GetAsyncCompletionHandle(AsyncHandle),
		5000) != WAIT_OBJECT_0 ) {
	    RcDbgPrint("Async object rundown wait failed, error %d\n",
		GetLastError());
	    }
	}


    RcCloseHandle(RcOverlapped->Overlapped.hEvent, "async overlapped event");
    Free(RcOverlapped);

    return;
}




/////////////////////////////////////////////////////////////////////////////
//
// ReadFileAsync
//
// Reads from file asynchronously.
//
// Returns TRUE on success, FALSE on failure (GetLastError() for detail)
//
// Caller should wait on async event for operation to complete, then call
// GetAsyncResult to retrieve information on transfer.
//
/////////////////////////////////////////////////////////////////////////////

BOOL
ReadFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToRead,
    HANDLE  AsyncHandle
    )
{
    BOOL Result;
    DWORD Error;
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;

    //
    // Check an IO operation is not in progress
    //

    if (RcOverlapped->FileHandle != NULL) {
	RcDbgPrint("ReadFileAsync : Operation already in progress!\n");
	SetLastError(ERROR_IO_PENDING);
	return(FALSE);
    }

    //
    // Reset the event
    //

    Result = ResetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("ReadFileAsync : Failed to reset async event, error = %d\n", GetLastError());
	return(FALSE);
    }


    //
    // Store the file handle in our structure.
    // This also functions as a signal that an operation is in progress.
    //

    RcOverlapped->FileHandle = hFile;
    RcOverlapped->CompletedSynchronously = FALSE;

    Result = ReadFile(hFile,
		      lpBuffer,
		      nBytesToRead,
		      &RcOverlapped->BytesTransferred,
		      &RcOverlapped->Overlapped);

    if (!Result) {

	Error = GetLastError();

	if (Error == ERROR_IO_PENDING) {

	    //
	    // The I/O has been started synchronously, we're done
	    //

	    return(TRUE);
	}

	//
	// The read really did fail, reset our flag and get out
	//

	RcDbgPrint("ReadFileAsync : ReadFile failed, error = %d\n", Error);
	RcOverlapped->FileHandle = NULL;
	return(FALSE);
    }


    //
    // The operation completed synchronously. Store the paramaters in our
    // structure ready for GetAsyncResult and signal the event
    //

    RcOverlapped->CompletionCode = ERROR_SUCCESS;
    RcOverlapped->CompletedSynchronously = TRUE;

    //
    // Set the event
    //

    Result = SetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("ReadFileAsync : Failed to set async event, error = %d\n", GetLastError());
    }

    return(TRUE);
}



/////////////////////////////////////////////////////////////////////////////
//
// WriteFileAsync
//
// Writes to file asynchronously.
//
// Returns TRUE on success, FALSE on failure (GetLastError() for detail)
//
// Caller should wait on async event for operation to complete, then call
// GetAsyncResult to retrieve information on transfer.
//
/////////////////////////////////////////////////////////////////////////////

BOOL
WriteFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToWrite,
    HANDLE  AsyncHandle
    )
{
    BOOL Result;
    DWORD Error;
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;

    //
    // Check an IO operation is not in progress
    //

    if (RcOverlapped->FileHandle != NULL) {
	RcDbgPrint("ReadFileAsync : Operation already in progress!\n");
	SetLastError(ERROR_IO_PENDING);
	return(FALSE);
    }


    //
    // Reset the event
    //

    Result = ResetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("WriteFileAsync : Failed to reset async event, error = %d\n", GetLastError());
	return(FALSE);
    }

    //
    // Store the file handle in our structure.
    // This also functions as a signal that an operation is in progress.
    //

    RcOverlapped->FileHandle = hFile;
    RcOverlapped->CompletedSynchronously = FALSE;

    Result = WriteFile(hFile,
		      lpBuffer,
		      nBytesToWrite,
		      &RcOverlapped->BytesTransferred,
		      &RcOverlapped->Overlapped);

    if (!Result) {

	Error = GetLastError();

	if (Error == ERROR_IO_PENDING) {

	    //
	    // The I/O has been started synchronously, we're done
	    //

	    return(TRUE);
	}

	//
	// The read really did fail, reset our flag and get out
	//

	RcDbgPrint("WriteFileAsync : WriteFile failed, error = %d\n", Error);
	RcOverlapped->FileHandle = NULL;
	return(FALSE);
    }


    //
    // The operation completed synchronously. Store the paramaters in our
    // structure ready for GetAsyncResult and signal the event
    //

    RcOverlapped->CompletionCode = ERROR_SUCCESS;
    RcOverlapped->CompletedSynchronously = TRUE;

    //
    // Set the event
    //

    Result = SetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("WriteFileAsync : Failed to set async event, error = %d\n", GetLastError());
    }

    return(TRUE);
}




/////////////////////////////////////////////////////////////////////////////
//
// GetCompletionHandle
//
// Returns a handle that can be used to wait for completion of the
// operation associated with this async object
//
// Returns an event handle or NULL on failure
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
GetAsyncCompletionHandle(
    HANDLE  AsyncHandle
    )
{
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;

    return(RcOverlapped->Overlapped.hEvent);
}




/////////////////////////////////////////////////////////////////////////////
//
// GetAsyncResult
//
// Returns the result of the last completed operation involving the
// passed async object handle.
//
// Returns the completion code of the last operation OR
// ERROR_IO_INCOMPLETE if the operation has not completed.
// ERROR_NO_DATA if there is no operation in progress.
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetAsyncResult(
    HANDLE  AsyncHandle,
    LPDWORD BytesTransferred
    )
{
    BOOL Result;
    DWORD WaitResult;
    PRCOVERLAPPED RcOverlapped = (PRCOVERLAPPED)AsyncHandle;
    DWORD AsyncResult;

    //
    // Check an IO operation is (was) in progress
    //

    if (RcOverlapped->FileHandle == NULL) {
	RcDbgPrint("GetAsyncResult : No operation in progress !\n");
	return(ERROR_NO_DATA);
    }


    //
    // Check the event is set - i.e that an IO operation has completed
    //

    WaitResult = WaitForSingleObject(RcOverlapped->Overlapped.hEvent, 0);
    if (WaitResult != 0) {
	RcDbgPrint("GetAsyncResult : Event was not set, wait result = %d\n", WaitResult);
	return(ERROR_IO_INCOMPLETE);
    }


    //
    // If the call completed synchronously, copy the data out of
    // our structure
    //

    if (RcOverlapped->CompletedSynchronously) {

	AsyncResult = RcOverlapped->CompletionCode;
	*BytesTransferred = RcOverlapped->BytesTransferred;

    } else {

	//
	// Go get the asynchronous result info from the system
	//

	AsyncResult = ERROR_SUCCESS;

	Result = GetOverlappedResult(RcOverlapped->FileHandle,
				     &RcOverlapped->Overlapped,
				     BytesTransferred,
				     FALSE);
	if (!Result) {
	    AsyncResult = GetLastError();
	    RcDbgPrint("GetAsyncResult : GetOverlappedResult failed, error = %d\n", AsyncResult);
	}
    }


    //
    // Reset the event so it doesn't trigger the caller again
    //

    Result = ResetEvent(RcOverlapped->Overlapped.hEvent);
    if (!Result) {
	RcDbgPrint("GetAsyncResult : Failed to reset async event\n");
    }


    //
    // Result the file handle so we know there is no pending operation
    //

    RcOverlapped->FileHandle = NULL;


    return(AsyncResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\pipe.c ===
/****************************** Module Header ******************************\
* Module Name: pipe.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* This module implements:
*   1. a version of CreatePipe that allows control over the file
*      flags. e.g. FILE_FLAG_OVERLAPPED
*   2. Timed-out pipe read and write
*
* History:
* 06-29-92 Davidc	Created.
* 05-17-94 DaveTh	Added ReadPipe, WritePipe.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>
#include "rcmdsrv.h"


ULONG PipeSerialNumber = 0;

#define PIPE_FORMAT_STRING  "\\\\.\\pipe\\rshsrv\\%08x.%08x"



/////////////////////////////////////////////////////////////////////////////
//
// RcCreatePipe
//
// Creates a uni-directional pipe with the specified security attributes,
// size and timeout. The handles are opened with the specified file-flags
// so FILE_FLAG_OVERLAPPED etc. can be specified.
//
// Returns handles to both end of pipe in passed parameters.
//
// Returns TRUE on success, FALSE on failure. (GetLastError() for details)
//
/////////////////////////////////////////////////////////////////////////////

BOOL
RcCreatePipe(
    LPHANDLE ReadHandle,
    LPHANDLE WriteHandle,
    LPSECURITY_ATTRIBUTES SecurityAttributes,
    DWORD Size,
    DWORD Timeout,
    DWORD ReadHandleFlags,
    DWORD WriteHandleFlags
    )
{
    CHAR PipeName[MAX_PATH];

    //
    // Make up a random pipe name
    //

    sprintf(PipeName, PIPE_FORMAT_STRING, GetCurrentProcessId(), PipeSerialNumber++);


    //
    // Create the pipe
    //

    *ReadHandle = CreateNamedPipeA(
			PipeName,
			PIPE_ACCESS_INBOUND | ReadHandleFlags,
			PIPE_TYPE_BYTE | PIPE_WAIT,
			1,             // Number of pipes
			Size,          // Out buffer size
			Size,          // In buffer size
			Timeout,       // Timeout in ms
			SecurityAttributes
		      );

    if (*ReadHandle == NULL) {
	RcDbgPrint("RcCreatePipe: failed to created pipe <%s>, error = %d\n", PipeName, GetLastError());
	return(FALSE);
    }

    //
    // Open the client end of the pipe
    //


    *WriteHandle = CreateFileA(
			PipeName,
			GENERIC_WRITE,
			0,                         // No sharing
			SecurityAttributes,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | WriteHandleFlags,
			NULL                       // Template file
		      );

    if (*WriteHandle == INVALID_HANDLE_VALUE ) {
	RcDbgPrint("Failed to open client end of pipe <%s>, error = %d\n", PipeName, GetLastError());
	RcCloseHandle(*ReadHandle, "async pipe (server(read) side)");
	return(FALSE);
    }


    //
    // Everything succeeded
    //

    return(TRUE);
}



/***************************************************************************\
* FUNCTION: ReadPipe
*
* PURPOSE:  Implements a timed-out (ms) read on a pipe.
*
* RETURNS:  ERROR_SUCCESS on success
*	    WAIT_TIMEOUT if timed out before completing read
*	    or respective error code on other failures
*
* HISTORY:
*
*   05-17-94 DaveTh	 Created from DavidC read pipe.
*
\***************************************************************************/

DWORD
ReadPipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD Timeout
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
                              NULL,         // no security
                              TRUE,         // Manual reset
                              FALSE,        // Initial state
                              NULL          // Name
                             );
    if (EventHandle == NULL) {
	RcDbgPrint("Internal error = %d\n", GetLastError());
	return(GetLastError());
    }

    Overlapped.hEvent = EventHandle;

    Result = ReadFile(
                      PipeHandle,
                      lpBuffer,
                      nNumberOfBytesToRead,
                      lpNumberOfBytesRead,
                      &Overlapped
                     );
    if (Result) {

        //
        // Success without waiting - it's too easy !
        //

        CloseHandle(EventHandle);

    } else {

        //
        // Read failed, if it's overlapped io, go wait for it
        //

        Error = GetLastError();

        if (Error != ERROR_IO_PENDING) {
	    RcDbgPrint("ReadPipe: ReadFile failed, error = %d\n", Error);
            CloseHandle(EventHandle);
	    return(Error);
        }

        //
        // Wait for the I/O to complete
        //

	Result = WaitForSingleObject(EventHandle, Timeout);
	if (Result != WAIT_OBJECT_0) {
	    if (Result == WAIT_TIMEOUT)  {
		return(Result);
	    }  else  {
		RcDbgPrint("ReadPipe: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    }
	    CloseHandle(EventHandle);
	}

        //
        // Go get the I/O result
        //

        Result = GetOverlappedResult( PipeHandle,
                                      &Overlapped,
                                      lpNumberOfBytesRead,
                                      FALSE
                                    );
        //
        // We're finished with the event handle
        //

        CloseHandle(EventHandle);

        //
        // Check result of GetOverlappedResult
        //

        if (!Result) {
	    RcDbgPrint("ReadPipe: GetOverlappedResult failed, error = %d\n", GetLastError());
	    return(GetLastError());
        }
    }

    return(ERROR_SUCCESS);
}

/***************************************************************************\
* FUNCTION: WritePipe
*
* PURPOSE:  Implements a timed-out (ms) write on a pipe.
*
* RETURNS:  ERROR_SUCCESS on success
*	    WAIT_TIMEOUT if timed out before completing write
*	    or respective error code on other failures
*
* HISTORY:
*
*   05-22-94 DaveTh	 Created.
*
\***************************************************************************/

DWORD
WritePipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD Timeout
    )
{
    DWORD Result;
    OVERLAPPED Overlapped;
    HANDLE  EventHandle;
    DWORD Error;

    //
    // Create an event for the overlapped operation
    //

    EventHandle = CreateEvent(
                              NULL,         // no security
                              TRUE,         // Manual reset
                              FALSE,        // Initial state
                              NULL          // Name
                             );
    if (EventHandle == NULL) {
	RcDbgPrint("Internal error = %d\n", GetLastError());
	return(GetLastError());
    }

    Overlapped.hEvent = EventHandle;

    Result = WriteFile(
                      PipeHandle,
                      lpBuffer,
		      nNumberOfBytesToWrite,
		      lpNumberOfBytesWritten,
                      &Overlapped
                     );
    if (Result) {

        //
        // Success without waiting - it's too easy !
        //

        CloseHandle(EventHandle);

    } else {

        //
	// Write failed, if it's overlapped io, go wait for it
        //

        Error = GetLastError();

        if (Error != ERROR_IO_PENDING) {
	    RcDbgPrint("WritePipe: WriteFile failed, error = %d\n", Error);
            CloseHandle(EventHandle);
	    return(Error);
        }

        //
        // Wait for the I/O to complete
        //

	Result = WaitForSingleObject(EventHandle, Timeout);
	if (Result != WAIT_OBJECT_0) {
	    if (Result == WAIT_TIMEOUT)  {
		return(Result);
	    }  else  {
		RcDbgPrint("Write: event wait failed, result = %d, last error = %d\n", Result, GetLastError());
	    }
	    CloseHandle(EventHandle);
	}

        //
        // Go get the I/O result
        //

        Result = GetOverlappedResult( PipeHandle,
                                      &Overlapped,
				      lpNumberOfBytesWritten,
                                      FALSE
                                    );
        //
        // We're finished with the event handle
        //

        CloseHandle(EventHandle);

        //
        // Check result of GetOverlappedResult
        //

        if (!Result) {
	    RcDbgPrint("WritePipe: GetOverlappedResult failed, error = %d\n", GetLastError());
	    return(GetLastError());
        }
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\lsautil.h ===
/****************************** Module Header ******************************\
* Module Name: lsautil.h
*
* Copyright (c) 1994, Microsoft Corporation
*
* Defines functions exported by pipe.c
*
* History:
* 05-20-94 DaveTh	 Created.
\***************************************************************************/

#include <ntlsa.h>

//
// Function prototypes
//

DWORD
CheckUserSystemAccess(
    HANDLE TokenHandle,
    ULONG DesiredSystemAccess,
    PBOOLEAN UserHasAccess
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\lsautil.c ===
/****************************** Module Header ******************************\
* Module Name: lsautil.c
*
* Copyright (c) 1994, Microsoft Corporation
*
* Remote shell server main module
*
* History:
* 05-19-94 DaveTh	Created.
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>

#include "rcmdsrv.h"

#define INITIAL_SIZE_REQUIRED 600

DWORD
CheckUserSystemAccess(
    HANDLE TokenHandle,
    ULONG DesiredSystemAccess,
    PBOOLEAN UserHasAccess
    )

/*++

Routine Description:

    This function determines whether or not the user whose token is passed
    has the interactive accesses desired on this machine.

Arguments:

    TokenHandle - Handle of user's token.

    DesiredSystemAccess - Specifies desired access type(s).

    UserHasAccess - pointer to boolean returned - TRUE means that user
	has interactive access.

Return Value:

    ERROR_SUCCESS in absence of errors.  UserHasAccess is TRUE if all
    requested access types are permitted, otherwise FALSE.  WIN32 errors
    are returned in error cases.

--*/
{


    DWORD Result;
    LPVOID LpTokenUserInformation = NULL;
    LPVOID LpTokenGroupInformation = NULL;
    DWORD SizeRequired, SizeProvided;
    LSA_HANDLE PolicyHandle = NULL;
    LSA_HANDLE AccountHandle = NULL;
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    POBJECT_ATTRIBUTES LpObjectAttributes;
    ULONG GrantedSystemAccess, SidSystemAccess;
    DWORD i;


    //
    //	Access LSA policy database
    //

    LpObjectAttributes = &ObjectAttributes;

    InitializeObjectAttributes(
	      LpObjectAttributes,
	      NULL,
	      0,
	      NULL,
	      NULL);

    if (!NT_SUCCESS(NtStatus = LsaOpenPolicy(
				   NULL,		   // Local system
				   LpObjectAttributes,
				   GENERIC_READ,
				   &PolicyHandle)))  {

	RcDbgPrint("Error opening policy database, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
	goto Failure;
    }

    //
    //	Check groups, user - For each SID, open the account (if it exists).
    //	If it doesn't exist, no failure, but no access (FALSE).	If it
    //	does exist, accumulate granted accesses in and compare to
    //	requested mask.	If all the bits of the mask have been set at any
    //	point, UserHasAccess is set TRUE.  Otherise, it is left FALSE.
    //

    *UserHasAccess = FALSE;
    GrantedSystemAccess = 0;

    //
    //	Get list of SIDs of groups of which user is a member
    //

    if ((LpTokenGroupInformation = Alloc(INITIAL_SIZE_REQUIRED)) == NULL)  {
	Result = GetLastError();
	goto Failure;
    }

    if (!GetTokenInformation (
			TokenHandle,
			TokenGroups,
			LpTokenGroupInformation,
			INITIAL_SIZE_REQUIRED,
			&SizeRequired))  {

	Result = GetLastError();
	if ( (Result == ERROR_MORE_DATA) || (Result == ERROR_INSUFFICIENT_BUFFER) )	{

	    Free(LpTokenGroupInformation);

	    if ((LpTokenGroupInformation = Alloc(SizeRequired)) == NULL)  {
		Result = GetLastError();
		goto Failure;
	    }

	    SizeProvided = SizeRequired;

	    if (!GetTokenInformation (
			TokenHandle,
			TokenGroups,
			LpTokenGroupInformation,
			SizeProvided,
			&SizeRequired))  {

		Result=GetLastError();
		RcDbgPrint("Error accessing group SIDs, error = %d\n", Result);
		goto Failure;
	    }

	}  else {
	    RcDbgPrint("Error accessing group SIDs, error = %d\n", Result);
	    goto Failure;

	}

    }

    //
    //	Check for each group that user is a member of since groups
    //	are most likely source of permitted access.  Permitted access types
    //	are cumulative.
    //


    for (i=0; i< ((PTOKEN_GROUPS)LpTokenGroupInformation)->GroupCount; i++)  {

	if (NT_SUCCESS(NtStatus = LsaOpenAccount(
		    PolicyHandle,
		    ((PTOKEN_GROUPS)LpTokenGroupInformation)->Groups[i].Sid,
		    GENERIC_READ,
		    &AccountHandle)))  {

	    //
	    //	found account - accumulate and check accesses
	    //

	    if (!NT_SUCCESS(NtStatus = LsaGetSystemAccessAccount (
					    AccountHandle,
					    &SidSystemAccess)))	{

		RcDbgPrint("Error getting group account access, error = %x\n", NtStatus);
		Result = RtlNtStatusToDosError(NtStatus);
		goto Failure;

	    }  else  {

		//
		// Got system access - don't need account handle anymore
		//

		if (NT_SUCCESS(NtStatus = LsaClose(AccountHandle)))  {

		    AccountHandle = NULL;

		}  else  {

		    RcDbgPrint("Error closing account handle, error = %x\n", NtStatus);
		    Result = RtlNtStatusToDosError(NtStatus);
		    goto Failure;
		}


		GrantedSystemAccess |= SidSystemAccess;;

		if ((GrantedSystemAccess & DesiredSystemAccess) == DesiredSystemAccess)	{
		    *UserHasAccess = TRUE;
		    goto Success;
		}
	    }

	}  else if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND)  {
	    RcDbgPrint("Error opening group account, error = %x\n", NtStatus);
	    Result = RtlNtStatusToDosError(NtStatus);
	    goto Failure;
	}

    }

    //
    //	Get user SID
    //

    if ((LpTokenUserInformation = Alloc(INITIAL_SIZE_REQUIRED)) == NULL)  {
	Result = GetLastError();
	goto Failure;
    }

    if (!GetTokenInformation (
			TokenHandle,
			TokenUser,
			LpTokenUserInformation,
			INITIAL_SIZE_REQUIRED,
			&SizeRequired))  {

	Result = GetLastError();
	if (Result == ERROR_MORE_DATA)	{   // Not enough - alloc and redo

	    Free(LpTokenUserInformation);

	    if ((LpTokenUserInformation = Alloc(SizeRequired)) == NULL)  {
		Result = GetLastError();
		goto Failure;
	    }

	    SizeProvided = SizeRequired;

	    if (!GetTokenInformation (
			TokenHandle,
			TokenUser,
			LpTokenUserInformation,
			SizeProvided,
			&SizeRequired))  {

		RcDbgPrint("Error accessing user SID, error = %d\n", Result);
		Result=GetLastError();
		goto Failure;
	    }

	}  else {
	    RcDbgPrint("Error accessing user SID, error = %d\n", Result);
	    goto Failure;

	}
    }

    //
    //	Now, check user account.  If present, check access and return
    //	if requested access is allowed.  If not allowed, go on to check groups.
    //	If account doesn't exist, go on to check groups.
    //

    if (NT_SUCCESS(NtStatus = LsaOpenAccount(
				  PolicyHandle,
				  ((PTOKEN_USER)LpTokenUserInformation)->User.Sid,
				  GENERIC_READ,
				  &AccountHandle)))  {

	//
	//  found account - check accesses
	//

	if (!NT_SUCCESS(NtStatus = LsaGetSystemAccessAccount (
					AccountHandle,
					&GrantedSystemAccess)))	{

	    RcDbgPrint("Error getting group account access, error = %x\n", NtStatus);
	    Result = RtlNtStatusToDosError(NtStatus);
	    goto Failure;

	}  else  {

	    GrantedSystemAccess |= SidSystemAccess;;

	    if ((GrantedSystemAccess & DesiredSystemAccess) == DesiredSystemAccess)	{
		*UserHasAccess = TRUE;
		goto Success;
	    }
	}

    }  else if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND)  {
	RcDbgPrint("Error opening user account, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
	goto Failure;
    }

    //
    //	Success - Jump here if access granted, fall through here on no error
    //

Success:

    Result = ERROR_SUCCESS;


    //
    //	General failure  and success exit - frees memory, closes handles
    //

Failure:

    if (LpTokenGroupInformation != NULL)  {
	Free(LpTokenGroupInformation);
    }

    if (LpTokenUserInformation != NULL)  {
	Free(LpTokenGroupInformation);
    }

    if ((PolicyHandle != NULL) &&
	    (!NT_SUCCESS(NtStatus = LsaClose(PolicyHandle))))  {
	RcDbgPrint("Error closing policy handle at exit, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
    }

    if ((AccountHandle != NULL) &&
	    (!NT_SUCCESS(NtStatus = LsaClose(AccountHandle))))	{
	RcDbgPrint("Error closing account handle at exit, error = %x\n", NtStatus);
	Result = RtlNtStatusToDosError(NtStatus);
    }

    return(Result);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\pipe.h ===
/****************************** Module Header ******************************\
* Module Name: pipe.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines functions exported by pipe.c
*
* History:
* 06-29-92 Davidc       Created.
\***************************************************************************/


//
// Function prototypes
//

BOOL
RcCreatePipe(
    LPHANDLE ReadHandle,
    LPHANDLE WriteHandle,
    LPSECURITY_ATTRIBUTES SecurityAttributes,
    DWORD Size,
    DWORD Timeout,
    DWORD ReadHandleFlags,
    DWORD WriteHandleFlags
    );

DWORD
ReadPipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD Timeout
    );

DWORD
WritePipe(
    HANDLE PipeHandle,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD Timeout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\rcmdsrv.h ===
/****************************** Module Header ******************************\
* Module Name: rcmdsrv.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main include file for remote shell server
*
* History:
* 06-28-92 Davidc       Created.
\***************************************************************************/

// #define UNICODE	// BUGBUG - Not completely unicode yet

#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <rcmd.h>
#include <lsautil.h>
//
// Macros
//

#define RcCloseHandle(Handle, handle_name) \
        if (CloseHandle(Handle) == FALSE) { \
	    RcDbgPrint("Close Handle failed for <%s>, error = %d\n", handle_name, GetLastError()); \
            assert(FALSE); \
        }

#define Alloc(Bytes)            LocalAlloc(LPTR, Bytes)
#define Free(p)                 LocalFree(p)

//
//  Maximum number of connected clients
//

#define MAX_SESSIONS	10

//
// main server routine if built as service
//

int Rcmd ( );

//
// service stop routine
//

DWORD RcmdStop ( );

//
//  Runtime-enabled DbgPrint
//

int RcDbgPrint (
    const char *format,
    ...
    );


extern HANDLE RcmdStopEvent;
extern HANDLE RcmdStopCompleteEvent;
extern HANDLE SessionThreadHandles[MAX_SESSIONS+1];
// extern BOOLEAN RcDbgPrintEnable;

//
// Module header files
//

#include "session.h"
#include "async.h"
#include "pipe.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\async.h ===
/****************************** Module Header ******************************\
* Module Name: async.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Defines types and functions used by async module.
*
* History:
* 06-29-92 Davidc       Created.
\***************************************************************************/


//
// Function prototypes
//

HANDLE
CreateAsync(
    BOOL    InitialState
    );

VOID
DeleteAsync(
    HANDLE AsyncHandle
    );

BOOL
ReadFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToRead,
    HANDLE  AsyncHandle
    );

BOOL
WriteFileAsync(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   nBytesToWrite,
    HANDLE  AsyncHandle
    );

HANDLE
GetAsyncCompletionHandle(
    HANDLE  AsyncHandle
    );

DWORD
GetAsyncResult(
    HANDLE  AsyncHandle,
    LPDWORD BytesTransferred
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\rcmdsvc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rcmdsvc.c

Abstract:

    This is the remote command service.  It serves multiple remote clients
    running standard i/o character based programs.

Author:

    Dave Thompson, basically incorporating the remote command shell written
    by David Chalmers.

Environment:

    User Mode -Win32

Revision History:

    5/1/94  DaveTh  Created.
    7/30/96 MarkHar Fixed bug 40834 - "doesn't work on NT4.0"
                    Removed function calls within asserts.
    1/31/99 MarkHar bug about install not working
    6/22/99 MarkHar added usage message
--*/

//
// Includes
//

#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>

#include <winsvc.h>

#include "rcmdsrv.h"

//
// Defines
//

#define INFINITE_WAIT_TIME  0xFFFFFFFF

#define NULL_STRING     TEXT("");


//
// Globals
//


SERVICE_STATUS   RcmdStatus;

SERVICE_STATUS_HANDLE   RcmdStatusHandle;

//
// Events for syncrhonizing service shutdown
//

HANDLE    RcmdStopEvent = NULL;

HANDLE    RcmdStopCompleteEvent = NULL;

HANDLE    SessionThreadHandles[MAX_SESSIONS+1] = {NULL,};


//
//  Flag to enable debug print
//

// BOOLEAN   RcDbgPrintEnable = FALSE;


//
// Function Prototypes
//

VOID
RcmdStart (
    DWORD   argc,
    LPTSTR  *argv
    );


VOID
RcmdCtrlHandler (
    IN  DWORD   opcode
    );

DWORD
RcmdInitialization(
    DWORD   argc,
    LPTSTR  *argv,
    DWORD   *specificError
    );

void CmdInstallService(void);
void CmdRemoveService();
void Usage(void);
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


/****************************************************************************/
VOID __cdecl
main(int argc, char ** argv)

/*++

Routine Description:

    This is the main routine for the service RCMD process.

    This thread calls StartServiceCtrlDispatcher which connects to the
    service controller and then waits in a loop for control requests.
    When all the services in the service process have terminated, the
    service controller will send a control request to the dispatcher
    telling it to shut down.  This thread with then return from the
    StartServiceCtrlDispatcher call so that the process can terminate.

Arguments:



Return Value:



--*/
{

    DWORD      status;
    char      *szArgument = NULL;

    SERVICE_TABLE_ENTRY   DispatchTable[] = {
	{ TEXT("Remote Command"), RcmdStart },
	{ NULL, NULL  }
    };

    if (argc > 1)
    {
        if ((*argv[1] == '-') || (*argv[1] == '/')) 
        {
            szArgument = argv[1]+1;
            if (_stricmp("install", szArgument) == 0)
            {
                CmdInstallService();
            }
            else if (_stricmp("uninstall", szArgument) == 0)
            {
                CmdRemoveService();
            }
            else
            {
                Usage();
            }
        }
    }
    else
    {
        status = StartServiceCtrlDispatcher( DispatchTable);
    }

    ExitProcess(0);

}


void Usage(void)
{
    char *szUsage = "usage: rcmdsvc\n"
                    "rcmdsvc [[-/] [install | uninstall | H]]\n"
                    "\tinstall - registers the service with the service controller\n"
                    "\tuninstall - unregisters the service with the service controller\n"
                    "\tHh?       - prints this usage message\n";
    fprintf(stdout, szUsage);
}


void CmdInstallService()
/*++
  
Routine Description:


Arguments:

    None

Return Value:

    None

--*/
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    TCHAR szErr[256];
    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        printf(TEXT("Unable to install %s - %s\n"), 
               TEXT("Remote Command"), 
               GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT("rcmdsvc"),        // name of service
            TEXT("Remote Command Service"), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            NULL,                       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            printf(TEXT("%s installed.\n"), TEXT("Remote Command Service") );
            CloseServiceHandle(schService);
        }
        else
        {
            printf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        printf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}


void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    TCHAR       szErr[256];


    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, 
                                 TEXT("rcmdsvc"), 
                                 SERVICE_ALL_ACCESS);
        
        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, 
                                 SERVICE_CONTROL_STOP, 
                                 &RcmdStatus ) )
            {
                printf(TEXT("Stopping %s."), TEXT("Remote Command Service"));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &RcmdStatus ) )
                {
                    if ( RcmdStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                        printf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else {
                        break;
                    }
                }

                if ( RcmdStatus.dwCurrentState == SERVICE_STOPPED ) {
                    printf(TEXT("\n%s stopped.\n"), 
                           TEXT("Remote Command Service") );
                }
                else {
                    printf(TEXT("\n%s failed to stop.\n"), 
                                TEXT("Remote Command Service") );
                }

            }

            // now remove the service
            if( DeleteService(schService) ) {
                printf(TEXT("%s removed.\n"), 
                       TEXT("Remote Command Service") );
            }
            else {
                printf(TEXT("DeleteService failed - %s\n"), 
                       GetLastErrorText(szErr,256));
            }
            CloseServiceHandle(schService);
        }
        else {
            printf(TEXT("OpenService failed -\n%s\n"), 
                        GetLastErrorText(szErr,256));
            printf(TEXT("The service must be installed before removing it."));
        }

        CloseServiceHandle(schSCManager);
    }
    else {
        printf(TEXT("OpenSCManager failed - %s\n"), 
               GetLastErrorText(szErr,256));
    }
}



/****************************************************************************/
void
RcmdStart (
    DWORD   argc,
    LPTSTR  *argv
    )
/*++

Routine Description:

    This is the entry point for the service.  When the control dispatcher
    is told to start a service, it creates a thread that will begin
    executing at this point.  The function has access to command line
    arguments in the same manner as a main() routine.

    Rather than return from this function, it is more appropriate to
    call ExitThread().

Arguments:



Return Value:



--*/
{
    DWORD   status;
    DWORD   specificError;

    //
    // Initialize the services status structure
    //

    RcmdStatus.dwServiceType        = SERVICE_WIN32;
    RcmdStatus.dwCurrentState       = SERVICE_START_PENDING;
    RcmdStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP;   // stop only
    RcmdStatus.dwWin32ExitCode      = 0;
    RcmdStatus.dwServiceSpecificExitCode = 0;
    RcmdStatus.dwCheckPoint         = 0;
    RcmdStatus.dwWaitHint           = 0;

    //
    // Register the Control Handler routine.
    //

    RcmdStatusHandle = RegisterServiceCtrlHandler(
                          TEXT("Remote Command"),
                          RcmdCtrlHandler);

    if (RcmdStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        RcDbgPrint(" [Rcmd] RegisterServiceCtrlHandler failed %d\n",
        GetLastError());
    }

    //
    // Initialize service global structures
    //

    status = RcmdInitialization(argc,argv, &specificError);

    if (status != NO_ERROR) {
        RcmdStatus.dwCurrentState       = SERVICE_RUNNING;
        RcmdStatus.dwCheckPoint         = 0;
        RcmdStatus.dwWaitHint           = 0;
        RcmdStatus.dwWin32ExitCode      = status;
        RcmdStatus.dwServiceSpecificExitCode = specificError;

        SetServiceStatus (RcmdStatusHandle, &RcmdStatus);
        ExitThread(NO_ERROR);
	    return;
    }

    //
    // Return the status to indicate we are done with intialization.
    //

    RcmdStatus.dwCurrentState       = SERVICE_RUNNING;
    RcmdStatus.dwCheckPoint         = 0;
    RcmdStatus.dwWaitHint           = 0;

    if (!SetServiceStatus (RcmdStatusHandle, &RcmdStatus)) {
    	status = GetLastError();
    	RcDbgPrint(" [Rcmd] SetServiceStatus error %ld\n",status);
    }

    //
    //  Run remote command processor - return when shutdown
    //

    if (0 != (status = Rcmd()))
    {
        RcDbgPrint(" [Rcmd]: problem occurred in Rcmd()\n");
        RcmdStatus.dwCurrentState       = SERVICE_STOPPED;
        RcmdStatus.dwCheckPoint         = 0;
        RcmdStatus.dwWaitHint           = 0;
        RcmdStatus.dwWin32ExitCode      = status;

        SetServiceStatus(RcmdStatusHandle, &RcmdStatus);
        ExitThread(status);
    }
    else
    {

        RcDbgPrint(" [Rcmd] Leaving My Service \n");
        ExitThread(NO_ERROR);
    }
}


/****************************************************************************/
VOID
RcmdCtrlHandler (
    IN  DWORD   Opcode
    )

/*++

Routine Description:

    This function executes in the context of the Control Dispatcher's
    thread.  Therefore, it it not desirable to perform time-consuming
    operations in this function.

    If an operation such as a stop is going to take a long time, then
    this routine should send the STOP_PENDING status, and then
    signal the other service thread(s) that a shut-down is in progress.
    Then it should return so that the Control Dispatcher can service
    more requests.  One of the other service threads is then responsible
    for sending further wait hints, and the final SERVICE_STOPPED.


Arguments:



Return Value:



--*/
{

    DWORD   status;

    //
    // Find and operate on the request.
    //

    switch(Opcode) {

    case SERVICE_CONTROL_PAUSE:

        RcDbgPrint(" [Rcmd] Pause - Unsupported opcode\n");
        break;

    case SERVICE_CONTROL_CONTINUE:

        RcDbgPrint(" [Rcmd] Continue - Unsupported opcode\n");
        break;

    case SERVICE_CONTROL_STOP:

        RcmdStatus.dwCurrentState = SERVICE_STOPPED;
        RcmdStatus.dwWin32ExitCode = RcmdStop();
        break;

    case SERVICE_CONTROL_INTERROGATE:
	
        //
        // All that needs to be done in this case is to send the
        // current status.
        //

        break;

    default:
        RcDbgPrint(" [Rcmd] Unrecognized opcode %ld\n", Opcode);
    }

    //
    // Send a status response.
    //

    if (!SetServiceStatus (RcmdStatusHandle,  &RcmdStatus)) {
        status = GetLastError();
        RcDbgPrint(" [Rcmd] SetServiceStatus error %ld\n",status);
    }

}

DWORD
RcmdInitialization(
    DWORD   argc,
    LPTSTR  *argv,
    DWORD   *specificError)
{

    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(argc);

    //
    // Initialize global stop event (signals running threads) and session
    // thread handle array (for threads to signal back on exit).
    //

    if (!(RcmdStopEvent = CreateEvent ( NULL, TRUE, FALSE, NULL )))  {
        *specificError = GetLastError();
        return(*specificError);
    }

    if (!(RcmdStopCompleteEvent = CreateEvent ( NULL, TRUE, FALSE, NULL )))  {
        *specificError = GetLastError();
        return(*specificError);
    }

    return(NO_ERROR);
}


LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_FROM_SYSTEM 
                           | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        sprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\session.c ===
/****************************** Module Header ******************************\
* Module Name: session.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell session module
*
* History:
* 06-28-92 Davidc       Created.
* 05-05-94 DaveTh       Modifed for RCMD service
* 02-04-99 MarkHar      Fixed NTBug #287923
\***************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <nturtl.h>
#include <winbase.h>

#include "rcmdsrv.h"
#include <io.h>
#include <stdlib.h>

//
// Define shell command line
//

#define SHELL_COMMAND_LINE  TEXT("cmd /q")
#define SHELL_COMMAND_PREFIX TEXT("cmd /c ")
#define SHELL_REMOTE_CMD_TITLE TEXT("Remote Command")
#define SHELL_CMD_PREFIX_LEN 7

//
// Define buffer size for reads/writes to/from shell
//

#define SHELL_BUFFER_SIZE   1000

//
//  Home directory constants
//

#define MAX_DIRECTORY_LENGTH 255
#define ROOT_OF_C TEXT("C:\\")

//
// Define multiple wait handle table size - extra handle for service stop
//

#define NUM_WAIT_HANDLES  5

//
// Define the structure used to describe each session
//

typedef struct {

    //
    // These fields are filled in at session creation time
    //

    HANDLE  ShellReadPipeHandle;        // Handle to shell stdout pipe
    HANDLE  ShellWritePipeHandle;        // Handle to shell stdin pipe
    HANDLE  ShellProcessHandle;     // Handle to shell process
    DWORD   ShellProcessGroupId;        // Process group ID of shell process
    PCHAR  DefaultDirectory;            // Default directory

    //
    // These fields maintain the state of asynchronouse reads/writes
    // to the shell process across client disconnections. They
    // are initialized at session creation.
    //

    BYTE    ShellReadBuffer[SHELL_BUFFER_SIZE]; // Data for shell reads goes here
    HANDLE  ShellReadAsyncHandle;   // Object used for async reads from shell

    BYTE    ShellWriteBuffer[SHELL_BUFFER_SIZE]; // Data for shell writes goes here
    HANDLE  ShellWriteAsyncHandle; // Object used for async writes to shell

    //
    // These fields are filled in at session connect time and are only
    // valid when the session is connected
    //

    HANDLE  ClientPipeHandle;       // Handle to client pipe
    HANDLE  SessionThreadHandle;    // Handle to session thread


} SESSION_DATA, *PSESSION_DATA;




//
// Private prototypes
//

HANDLE
StartShell(
    HANDLE StdinPipeHandle,
    HANDLE StdoutPipeHandle,
    PSESSION_DATA Session,
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    );

DWORD
SessionThreadFn(
    LPVOID Parameter
    );

CHAR *
GetDefaultDirectory(
    void
    );
//
// Useful macros
//

#define SESSION_CONNECTED(Session) ((Session)->ClientPipeHandle != NULL)




/////////////////////////////////////////////////////////////////////////////
//
// CreateSession
//
// Creates a new session. Involves creating the shell process and establishing
// pipes for communication with it.
//
// Returns a handle to the session or NULL on failure.
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
CreateSession(
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    )
{
    PSESSION_DATA Session = NULL;
    BOOL Result;
    SECURITY_ATTRIBUTES SecurityAttributes;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    HANDLE ShellStdinPipe = NULL;
    HANDLE ShellStdoutPipe = NULL;

    //
    // Allocate space for the session data
    //

    Session = (PSESSION_DATA)Alloc(sizeof(SESSION_DATA));
    if (Session == NULL) {
	return(NULL);
    }

    //
    // Reset fields in preparation for failure
    //

    Session->ShellReadPipeHandle  = NULL;
    Session->ShellWritePipeHandle = NULL;
    Session->ShellReadAsyncHandle = NULL;
    Session->ShellWriteAsyncHandle = NULL;


    //
    // Create the I/O pipes for the shell - give world access so that spawned
    // command process can access them in client's contex
    //

    Result = InitializeSecurityDescriptor (
		    &SecurityDescriptor,
		    SECURITY_DESCRIPTOR_REVISION);

    if (!Result) {
	RcDbgPrint("Failed to initialize shell pipe security descriptor, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    Result = SetSecurityDescriptorDacl (
		    &SecurityDescriptor,
		    TRUE,
		    NULL,
		    FALSE);

    if (!Result) {
	RcDbgPrint("Failed to set shell pipe DACL, error = %d\n", GetLastError());
	goto Failure;
    }

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor; // Use world-ACL
    SecurityAttributes.bInheritHandle = TRUE; // Shell will inherit handles

    Result = RcCreatePipe(&Session->ShellReadPipeHandle,
			  &ShellStdoutPipe,
			  &SecurityAttributes,
			  0,            // Default pipe size
			  0,            // Default timeout
			  FILE_FLAG_OVERLAPPED, // shell read flags
			  0              // shell stdout flags
			  );
    if (!Result) {
	RcDbgPrint("Failed to create shell stdout pipe, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    Result = RcCreatePipe(&ShellStdinPipe,
			  &Session->ShellWritePipeHandle,
			  &SecurityAttributes,
			  0,            // Default pipe size
			  0,            // Default timeout
			  0,            // shell stdin flags
			  FILE_FLAG_OVERLAPPED // shell write flags
			  );
    if (!Result) {
	RcDbgPrint("Failed to create shell stdin pipe, error = %d\n", 
                   GetLastError());
	goto Failure;
    }


    //
    // Initialize async objects
    //

    Session->ShellReadAsyncHandle = CreateAsync(FALSE);
    if (Session->ShellReadAsyncHandle == NULL) {
	RcDbgPrint("Failed to create shell read async object, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    Session->ShellWriteAsyncHandle = CreateAsync(FALSE);
    if (Session->ShellWriteAsyncHandle == NULL) {
	RcDbgPrint("Failed to create shell write async object, error = %d\n", 
                   GetLastError());
	goto Failure;
    }



    Session->DefaultDirectory = GetDefaultDirectory();

    //
    //  Start command shell with pipes connection to stdin/out/err
    //

    Session->ShellProcessHandle = StartShell(ShellStdinPipe, 
                                             ShellStdoutPipe, 
                                             Session, TokenToUse, 
                                             LpCommandHeader);

    //
    //  Close local handles
    //

    if (!(CloseHandle(ShellStdinPipe) &&
	  CloseHandle(ShellStdoutPipe)))  
    {
	ShellStdinPipe = NULL;
	ShellStdoutPipe = NULL;
	RcDbgPrint("Failed to close local pipe handles, error = %d\n", 
                   GetLastError());
	goto Failure;
    }

    //
    // Check result of shell start
    //

    if (Session->ShellProcessHandle == NULL) 
    {
	RcDbgPrint("Failed to execute shell\n");
	goto Failure;
    }

    //
    // The session is not yet connected, initialize variables to indicate that
    //

    Session->ClientPipeHandle = NULL;

    //
    // Success, return the session pointer as a handle
    //

    return((HANDLE)Session);



Failure:

    //
    // We get here for any failure case.
    // Free up any resources and exit
    //


    //
    // Cleanup shell pipe handles
    //

    if (ShellStdinPipe != NULL) {
	RcCloseHandle(ShellStdinPipe, "shell stdin pipe (shell side)");
    }

    if (ShellStdoutPipe != NULL) {
	RcCloseHandle(ShellStdoutPipe, "shell stdout pipe (shell side)");
    }

    if (Session->ShellReadPipeHandle != NULL) {
	RcCloseHandle(Session->ShellReadPipeHandle, "shell read pipe (session side)");
    }

    if (Session->ShellWritePipeHandle != NULL) {
	RcCloseHandle(Session->ShellWritePipeHandle, "shell write pipe (session side)");
    }


    //
    // Cleanup async data
    //

    if (Session->ShellReadAsyncHandle != NULL) {
	DeleteAsync(Session->ShellReadAsyncHandle);
    }

    if (Session->ShellWriteAsyncHandle != NULL) {
	DeleteAsync(Session->ShellWriteAsyncHandle);
    }


    //
    // Free up our session data
    //

    Free(Session);

    return(NULL);
}


CHAR *
GetDefaultDirectory(
    void
    )
{
    CHAR *HomeDirectory = (CHAR *)malloc(MAX_PATH * sizeof(CHAR));
    WIN32_FIND_DATA FileFindData;


    // Local system doesn't have many env. vars.  
    // One that it does have is USERPROFILE.  We'll try that first
    if (!GetEnvironmentVariable("USERPROFILE", HomeDirectory, MAX_PATH))
    {
        if (!GetEnvironmentVariable("TEMP", HomeDirectory, MAX_PATH))
        {
            if (!GetEnvironmentVariable("TMP", HomeDirectory, MAX_PATH))
            {
                RcDbgPrint("Can't find USERPROFILE, TEMP, TMP: defaulting to NULL");
                free(HomeDirectory);
                return NULL;
            }
        }
    }  


    if (strlen((const char *)HomeDirectory) < MAX_DIRECTORY_LENGTH)
    {
        RcDbgPrint("Trying to use home directory %s\n", HomeDirectory);

        // Now verify that indeed the USERPROFILE directory is actually a directory
        // If not, then go for NULL
        if (INVALID_HANDLE_VALUE == FindFirstFile(HomeDirectory, &FileFindData))
        {
            free(HomeDirectory);
            return NULL;
        }
        else
        {
            if (!(FileFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                free(HomeDirectory);
                return NULL;
            }
        }
        
        RcDbgPrint("HomeDirectory = %s\n", HomeDirectory);
        
        return HomeDirectory;
    }
    else
    {
        RcDbgPrint("Using NULL default directory\n");
        free(HomeDirectory);
        return NULL;
    }


}

/////////////////////////////////////////////////////////////////////////////
//
// DeleteSession
//
// Deletes the session specified by SessionHandle.
//
// Returns nothing
//
/////////////////////////////////////////////////////////////////////////////

VOID
DeleteSession(
    HANDLE  SessionHandle
    )
{
    PSESSION_DATA   Session = (PSESSION_DATA)SessionHandle;
    BOOL Result;


    //
    // Kill off the shell process
    //

    Result = TerminateProcess(Session->ShellProcessHandle, 1);
    if (!Result) {
	RcDbgPrint("May have failed to terminate shell, error = %d\n", GetLastError());
    }

    RcCloseHandle(Session->ShellProcessHandle, "shell process");


    //
    // Close the shell pipe handles
    //

    RcCloseHandle(Session->ShellReadPipeHandle, "shell read pipe (session side)");
    RcCloseHandle(Session->ShellWritePipeHandle, "shell write pipe (session side)");


    //
    // Cleanup async data
    //

    DeleteAsync(Session->ShellReadAsyncHandle);
    DeleteAsync(Session->ShellWriteAsyncHandle);


    //
    // Free up the session structure
    //

    Free(Session);

    //
    // We're done
    //

    return;
}




/////////////////////////////////////////////////////////////////////////////
//
// ConnectSession
//
// Connects the session specified by SessionHandle to a client
// on the other end of the pipe specified by PipeHandle
//
// Returns a session disconnect notification handle or NULL on failure.
// The returned handle will be signalled if the client disconnects or the
// shell terminates.
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
ConnectSession(
    HANDLE  SessionHandle,
    HANDLE  ClientPipeHandle
    )
{
    PSESSION_DATA   Session = (PSESSION_DATA)SessionHandle;
    DWORD ThreadId;

    assert(ClientPipeHandle != NULL);

    //
    // Fail if the session is already connected
    //

    if (SESSION_CONNECTED(Session)) {
        RcDbgPrint("Attempted to connect session already connected\n");
        return(NULL);
    }


    //
    // Store the client pipe handle in the session structure so the thread
    // can get at it. This also signals that the session is connected.
    //

    Session->ClientPipeHandle = ClientPipeHandle;


    //
    // Create the session thread
    //

    Session->SessionThreadHandle = CreateThread(
                     NULL,
                     0,                 // Default stack size
                     (LPTHREAD_START_ROUTINE)SessionThreadFn,   // Start address
                     (LPVOID)Session,           // Parameter
                     0,                 // Creation flags
                     &ThreadId          // Thread id
				     );
    if (Session->SessionThreadHandle == NULL) {

        RcDbgPrint("Failed to create session thread, error = %d\n", GetLastError());

        //
        // Reset the client pipe handle to indicate this session is disconnected
        //

        Session->ClientPipeHandle = NULL;
    }

    return(Session->SessionThreadHandle);
}





/////////////////////////////////////////////////////////////////////////////
//
// StartShell
//
// Execs the shell with the specified handle as stdin, stdout/err
//
// Returns process handle or NULL on failure
//
/////////////////////////////////////////////////////////////////////////////

HANDLE
StartShell(
    HANDLE StdinPipeHandle,
    HANDLE StdoutPipeHandle,
    PSESSION_DATA Session,
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    )
{

    PROCESS_INFORMATION ProcessInformation;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    STARTUPINFO si;
    HANDLE ProcessHandle = NULL;
    PROCESS_ACCESS_TOKEN ProcessTokenInfo;
    DWORD Result;
    UCHAR ShellCommandLine[MAX_CMD_LENGTH+SHELL_CMD_PREFIX_LEN+1];

    //
    // Detached process has no console - create new process with stdin,
    // stdout set to the passed-in handles
    //


    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = SHELL_REMOTE_CMD_TITLE;
    si.lpDesktop = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput =  StdinPipeHandle;
    si.hStdOutput = StdoutPipeHandle;
    si.hStdError =  StdoutPipeHandle;
    si.wShowWindow = SW_SHOW;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    //
    //  Set command string for single command or interactive mode
    //

    if (LpCommandHeader->CommandFixedHeader.CommandLength == 0) 
    {
        strcpy ((char *)ShellCommandLine, SHELL_COMMAND_LINE);
    }
    else 
    {

        //
        // Construct command string for execute and exit
        //

        strcpy ((char *)ShellCommandLine, SHELL_COMMAND_PREFIX);
        strncat ((char *)ShellCommandLine,
                 (const char *)LpCommandHeader->Command,
                 LpCommandHeader->CommandFixedHeader.CommandLength);
    }

    //
    // Create process with stdin/out/err connected to session pipes.
    // Create suspended then set the process token to the token of the
    // connected client (primary version of impersonate token).
    //

    // What if I use CreateProcessAsUser here?

    if (CreateProcess(NULL,
		      (char *)ShellCommandLine,
		      NULL,
		      NULL,
		      TRUE, // Inherit handles
		      CREATE_NEW_PROCESS_GROUP | CREATE_SUSPENDED , // | CREATE_NEW_CONSOLE
		      NULL,
		      Session->DefaultDirectory,
		      &si,
		      &ProcessInformation)) 
    {

        ProcessHandle = ProcessInformation.hProcess;
        Session->ShellProcessGroupId = ProcessInformation.dwProcessId;

    }
    else 
    {
	    RcDbgPrint("Failed to execute shell, error = %d\n", GetLastError());
	    return(NULL);
    }

    //
    //  Set process token for client and local system context access
    //  BUGBUG - actually, world, for now
    //

    Result = InitializeSecurityDescriptor (
        &SecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION);
    if (!Result)  
    {
        RcDbgPrint(
            "Failed to initialize shell process security descriptor, error = %d\n", 
            GetLastError()
            );
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    Result = SetSecurityDescriptorDacl (
		    &SecurityDescriptor,
		    TRUE,
		    NULL,
		    FALSE);
    if (0 == Result)  {
        RcDbgPrint("Failed to initialize shell process DACL, error = %d\n", GetLastError());
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    Result = SetKernelObjectSecurity(
	    ProcessHandle,
	    DACL_SECURITY_INFORMATION,
	    &SecurityDescriptor );
    if (0 == Result) {

        RcDbgPrint("Failed to set DACL on client token, error = %d\n", GetLastError());
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    //
    //  Now set the process token and resume execution
    //

    ProcessTokenInfo.Token = TokenToUse;
    ProcessTokenInfo.Thread = ProcessInformation.hThread;

    if (!NT_SUCCESS( NtSetInformationProcess(
            ProcessInformation.hProcess,
            ProcessAccessToken,
            &ProcessTokenInfo,
            sizeof(ProcessTokenInfo)))) {

        RcDbgPrint("Failed to set token");
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return (NULL);
    }


    Result = ResumeThread (ProcessInformation.hThread);

    if (Result != 1)  {
        RcDbgPrint("Failed to resume shell, suspend = %d, error = %d\n", Result, GetLastError());
        RcCloseHandle(ProcessInformation.hThread, "process thread");
        return(NULL);
    }

    RcCloseHandle(ProcessInformation.hThread, "process thread");

    return(ProcessHandle);
}








/////////////////////////////////////////////////////////////////////////////
//
// SessionThreadFn
//
// This is the code executed by the session thread
//
// Waits for read or write from/to shell or client pipe and termination
// event. Handles reads or writes by passing data to either client or
// shell as appropriate. Any error or termination event being signalled
// causes the thread to exit with an appropriate exit code.
//
/////////////////////////////////////////////////////////////////////////////

DWORD
SessionThreadFn(
    LPVOID Parameter
    )
{
    PSESSION_DATA   Session = (PSESSION_DATA)Parameter;
    HANDLE  ClientReadAsyncHandle;
    HANDLE  ClientWriteAsyncHandle;
    DWORD   BytesTransferred;
    DWORD   CompletionCode;
    BOOL    Result;
    DWORD   WaitResult;
    DWORD   ExitCode;
    HANDLE  WaitHandles[NUM_WAIT_HANDLES];
    BOOL    Done;
    DWORD   i;


    //
    // Initialize the client async structures
    //

    ClientReadAsyncHandle = CreateAsync(TRUE);
    if (ClientReadAsyncHandle == NULL) {
    	RcDbgPrint("Failed to create client read async object, error = %d\n", GetLastError());
    	return((DWORD)ConnectError);
    }

    ClientWriteAsyncHandle = CreateAsync(TRUE);
    if (ClientWriteAsyncHandle == NULL) {
    	RcDbgPrint("Failed to create client write async object, error = %d\n", GetLastError());
    	DeleteAsync(ClientReadAsyncHandle);
    	return((DWORD)ConnectError);
    }



    //
    // Initialize the handle array we'll wait on
    //

    WaitHandles[0] = RcmdStopEvent;
    WaitHandles[1] = GetAsyncCompletionHandle(Session->ShellReadAsyncHandle);
    WaitHandles[2] = GetAsyncCompletionHandle(Session->ShellWriteAsyncHandle);
    WaitHandles[3] = GetAsyncCompletionHandle(ClientReadAsyncHandle);
    WaitHandles[4] = GetAsyncCompletionHandle(ClientWriteAsyncHandle);

    //
    // Wait on our handle array in a loop until an error occurs or
    // we're signalled to exit.
    //

    Done = FALSE;

    while (!Done) {

        //
        // Wait for one of our objects to be signalled.
        //

        WaitResult = WaitForMultipleObjects(NUM_WAIT_HANDLES, WaitHandles, FALSE, INFINITE);

        if (WaitResult == WAIT_FAILED) {
            RcDbgPrint("Session thread wait failed, error = %d\n", GetLastError());
            ExitCode = (DWORD)ConnectError;
            break; // out of while
        }


        switch (WaitResult-WAIT_OBJECT_0) {
        case 0:

            //
            //  Service being stopped
            //

            RcDbgPrint("Service Shutdown\n");
            ExitCode = (DWORD)ServiceStopped;
            Done = TRUE;
            break;  // out of switch

        case 1:

            //
            // Shell read completed
            //

            CompletionCode = GetAsyncResult(Session->ShellReadAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
                RcDbgPrint("Async read from shell returned error, completion code = %d\n", CompletionCode);
                ExitCode = (DWORD)ShellEnded;
                Done = TRUE;
                break; // out of switch
            }

            //
            // Start an async write to client pipe
            //

            Result = WriteFileAsync(Session->ClientPipeHandle,
                        Session->ShellReadBuffer,
                        BytesTransferred,
                        ClientWriteAsyncHandle);
            if (!Result) {
                RcDbgPrint("Async write to client pipe failed, error = %d\n", GetLastError());
                ExitCode = (DWORD)ClientDisconnected;
                Done = TRUE;
            }

            break; // out of switch


        case 4:

            //
            // Client write completed
            //

            CompletionCode = GetAsyncResult(ClientWriteAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
                RcDbgPrint("Async write to client returned error, completion code = %d\n", CompletionCode);
                ExitCode = (DWORD)ClientDisconnected;
                Done = TRUE;
                break; // out of switch
            }

            //
            // Start an async read from shell
            //

            Result = ReadFileAsync(Session->ShellReadPipeHandle,
                       Session->ShellReadBuffer,
                       sizeof(Session->ShellReadBuffer),
                       Session->ShellReadAsyncHandle);
            if (!Result) {
                RcDbgPrint("Async read from shell failed, error = %d\n", GetLastError());
                ExitCode = (DWORD)ShellEnded;
                Done = TRUE;
            }

            break; // out of switch


        case 3:

            //
            // Client read completed
            //

            CompletionCode = GetAsyncResult(ClientReadAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
                RcDbgPrint("Async read from client returned error, completion code = %d\n", CompletionCode);
                ExitCode = (DWORD)ClientDisconnected;
                Done = TRUE;
                break; // out of switch
            }

            //
            // Check for Ctrl-C from the client
            //

            for (i=0; i < BytesTransferred; i++) {
                if (Session->ShellWriteBuffer[i] == '\003') {

                    //
                    // Generate control-C:  use Ctrl-Break because ctrl-c is
                    // disabled for process group
                    //

                    if (!(GenerateConsoleCtrlEvent (
                        CTRL_BREAK_EVENT,
                        Session->ShellProcessGroupId)))  {
                        RcDbgPrint("Ctrl-break event failure, error = %d\n", GetLastError());
                    }

                    //
                    // Remove the Ctrl-C from the buffer
                    //

                    BytesTransferred --;

                    for (; i < BytesTransferred; i++) {
                        Session->ShellWriteBuffer[i] = Session->ShellWriteBuffer[i+1];
                    }
                }
            }

            //
            // Start an async write to shell
            //

            Result = WriteFileAsync(Session->ShellWritePipeHandle,
                        Session->ShellWriteBuffer,
                        BytesTransferred,
                        Session->ShellWriteAsyncHandle);
            if (!Result) {
            RcDbgPrint("Async write to shell failed, error = %d\n", GetLastError());
            ExitCode = (DWORD)ShellEnded;
            Done = TRUE;
            }

            break; // out of switch



        case 2:

            //
            // Shell write completed
            //

            CompletionCode = GetAsyncResult(Session->ShellWriteAsyncHandle,
                            &BytesTransferred);

            if (CompletionCode != ERROR_SUCCESS) {
            RcDbgPrint("Async write to shell returned error, completion code = %d\n", CompletionCode);
            ExitCode = (DWORD)ShellEnded;
            Done = TRUE;
            break; // out of switch
            }

            //
            // Start an async read from client
            //

            Result = ReadFileAsync(Session->ClientPipeHandle,
                       Session->ShellWriteBuffer,
                       sizeof(Session->ShellWriteBuffer),
                       ClientReadAsyncHandle);
            if (!Result) {
            RcDbgPrint("Async read from client failed, error = %d\n", GetLastError());
            ExitCode = (DWORD)ClientDisconnected;
            Done = TRUE;
            }

            break; // out of switch


        default:

            RcDbgPrint("Session thread, unexpected result from wait, result = %d\n", WaitResult);
            ExitCode = (DWORD)ConnectError;
            Done = TRUE;
            break;

        } // switch

    } // while(!done)



    //
    // Cleanup and exit
    //

    //
    // Closing the client pipe should interrupt any pending I/O so
    // we should then be safe to close the event handles in the client
    // overlapped structs
    //

    Result = DisconnectNamedPipe(Session->ClientPipeHandle);
    if (!Result) {
        RcDbgPrint("Session thread: disconnect client named pipe failed, error = %d\n", GetLastError());
    }

    RcCloseHandle(Session->ClientPipeHandle, "client pipe");
    Session->ClientPipeHandle = NULL;

    //
    //  Delete client async objects
    //

    DeleteAsync(ClientReadAsyncHandle);
    DeleteAsync(ClientWriteAsyncHandle);

    //
    //  Terminate shell process, close shell pipe handles, and free session
    //  structure
    //

    DeleteSession (Session);


    //
    // Return the appropriate exit code
    //

    ExitThread(ExitCode);

    assert(FALSE);
    return(ExitCode); // keep compiler happy
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\regview\regview.c ===
#include <windows.h>
#include <tchar.h>
#include <stdio.h>


#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512

//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1


//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


BOOL DisplayRegistryData (LPTSTR lpRegistry);


int __cdecl main( int argc, char *argv[])
{
    WCHAR szPath[MAX_PATH * 2];

    if (argc != 2) {
        _tprintf(TEXT("usage:  regview <pathname>\registry.pol"));
        _tprintf(TEXT("example:  regview d:\registry.pol"));
        return 1;
    }


    if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, argv[1], -1, szPath,
                            (MAX_PATH * 2))) {
        _tprintf(TEXT("Failed to convert path to unicode"));
        return 1;
    }

    DisplayRegistryData(szPath);

    return 0;
}


//*************************************************************
//
//  DisplayRegistryData()
//
//  Purpose:    Displays the registry data
//
//  Parameters: lpRegistry  -   Path to registry.pol
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL DisplayRegistryData (LPTSTR lpRegistry)
{
    HANDLE hFile;
    BOOL bResult = FALSE;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength, dwIndex, dwCount;
    LPWSTR lpKeyName, lpValueName, lpTemp;
    LPBYTE lpData = NULL, lpIndex;
    WCHAR  chTemp;
    INT i;
    CHAR szString[20];


    //
    // Open the registry file
    //

    hFile = CreateFile (lpRegistry, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);


    if (hFile == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            return TRUE;
        }
        else
        {
            _tprintf(TEXT("DisplayRegistryData: CreateFile failed with %d"),
                     GetLastError());
            return FALSE;
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to allocate memory with %d"),
                 GetLastError());
        return FALSE;
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to allocate memory with %d"),
                 GetLastError());
        LocalFree (lpKeyName);
        return FALSE;
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to read signature with %d"),
                 GetLastError());
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        _tprintf(TEXT("DisplayRegistryData: Invalid file signature"));
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        _tprintf(TEXT("DisplayRegistryData: Failed to read version number with %d"),
                 GetLastError());
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        _tprintf(TEXT("DisplayRegistryData: Invalid file version"));
        goto Exit;
    }


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read first character with %d"),
                         GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            break;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read keyname character with %d"),
                         GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read first character with %d"),
                         GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;

        while (TRUE)
        {

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read valuename character with %d"),
                         GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                _tprintf(TEXT("DisplayRegistryData: Failed to read first character with %d"),
                         GetLastError());
                goto Exit;
            }
            break;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            break;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to read type with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to skip semicolon with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to data length with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to skip semicolon with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to allocate memory for data with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to read data with %d"),
                     GetLastError());
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            _tprintf(TEXT("DisplayRegistryData: Failed to skip closing bracket with %d"),
                     GetLastError());
            goto Exit;
        }

        if (chTemp != L']')
        {
            _tprintf(TEXT("DisplayRegistryData: Expected to find ], but found %c"),
                     chTemp);
            goto Exit;
        }

        //
        // Print out the entry
        //

        _tprintf (TEXT("\nKeyName:\t%s\n"), lpKeyName);
        _tprintf (TEXT("ValueName:\t%s\n"), lpValueName);


        switch (dwType) {

            case REG_DWORD:
                _tprintf (TEXT("ValueType:\tREG_DWORD\n"));
                _tprintf (TEXT("Value:\t\t0x%08x\n"), *((LPDWORD)lpData));
                break;

            case REG_SZ:
                _tprintf (TEXT("ValueType:\tREG_SZ\n"));
                _tprintf (TEXT("Value:\t%s\n"), (LPTSTR)lpData);
                break;

            case REG_EXPAND_SZ:
                _tprintf (TEXT("ValueType:\tREG_EXPAND_SZ\n"));
                _tprintf (TEXT("Value:\t%s\n"), (LPTSTR)lpData);
                break;

            case REG_MULTI_SZ:
                _tprintf (TEXT("ValueType:\tREG_MULTI_SZ\n"));
                _tprintf (TEXT("Value:\n\t\t"));
                lpTemp = (LPWSTR) lpData;

                while (*lpTemp) {
                    _tprintf (TEXT("%s\n\t\t"), lpTemp);
                    lpTemp += lstrlen(lpTemp) + 1;
                }
                break;

            case REG_BINARY:
                _tprintf (TEXT("ValueType:\tREG_BINARY\n"));
                _tprintf (TEXT("Value:\n\t"));

                dwIndex = 0;
                dwCount = 0;
                lpIndex = lpData;
                ZeroMemory(szString, sizeof(szString));

                while (dwIndex <= dwDataLength) {
                    _tprintf (TEXT("%02x "), *lpIndex);

                    if ((*lpIndex > 32) && (*lpIndex < 127)) {
                        szString[dwCount] = *lpIndex;
                    } else {
                        szString[dwCount] = '.';
                    }

                    if (dwCount < 15) {
                        dwCount++;
                    } else {
                        printf (" %s", szString);
                        _tprintf (TEXT("\n\t"));
                        ZeroMemory(szString, sizeof(szString));
                        dwCount = 0;
                    }

                    dwIndex++;
                    lpIndex++;
                }

                if (dwCount > 0) {
                    while (dwCount < 16) {
                        _tprintf (TEXT("   "));
                        dwCount++;
                    }
                    printf (" %s\n", szString);
                }

                _tprintf (TEXT("\n"));

                break;

            case REG_NONE:
                _tprintf (TEXT("ValueType:\tREG_NONE\n"));
                _tprintf (TEXT("Value:\t\tThis key contains no values\n"), *lpData);
                break;


            default:
                _tprintf (TEXT("ValueType:\tUnknown\n"));
                _tprintf (TEXT("ValueSize:\t%d\n"), dwDataLength);
                break;
        }

        LocalFree (lpData);
        lpData = NULL;

    }

    bResult = TRUE;

Exit:

    //
    // Finished
    //

    if (lpData) {
        LocalFree (lpData);
    }
    CloseHandle (hFile);
    LocalFree (lpKeyName);
    LocalFree (lpValueName);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\sidname\sidname.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>
#include <sddl.h>



DWORD __cdecl main (int argc, char *argv[])
{
    WCHAR   szPath[4*MAX_PATH];
    WCHAR   szName[MAX_PATH];
    DWORD   dwType;
    LPTSTR  szOldPath;
    WCHAR   szOutPath[4*MAX_PATH];
    BOOL bResult;

    if (argc != 3) {
        printf("Usage: %s </s|/u> <user name or Sid>\n", argv[0]);
        return 0;
    }

    if (strcmp(argv[1],"/s") == 0) {
        WCHAR *szSid, szUserName[MAX_PATH+1], szDomainName[MAX_PATH+1];
        PSID   pSid;
        DWORD cUserName = MAX_PATH, cDomainName = MAX_PATH;
        SID_NAME_USE    SidUse;


        szSid = (WCHAR *)LocalAlloc(LPTR, sizeof(WCHAR)*(1+strlen(argv[2])));

        wsprintf(szSid, L"%S", argv[2]);
        ConvertStringSidToSid (szSid, &pSid);

        if (!LookupAccountSid(NULL, pSid, szUserName, &cUserName, szDomainName, &cDomainName, &SidUse)) {
            printf("LookupAccountSid failed with error %d\n", GetLastError());
            return 0;
        }

        printf("UserName = %S, DomainName = %S, SidUse = %d\n", szUserName, szDomainName, SidUse);
        return;

    }
    else {
        WCHAR *szSid, szUserName[MAX_PATH+1], szDomainName[MAX_PATH+1];
        PSID   pSid;
        DWORD cUserName = 1024, cDomainName = MAX_PATH;
        SID_NAME_USE    SidUse;

        wsprintf(szUserName, L"%S", argv[2]);

        pSid = (SID *)LocalAlloc(LPTR, 1024);

        if (!LookupAccountName(NULL, szUserName, pSid, &cUserName, szDomainName, &cDomainName, &SidUse)) {
            printf("LookupAccountName failed with error %d\n", GetLastError());
            return 0;
        }

        ConvertSidToStringSid(pSid, &szSid);

        printf("SId = %S, Domain = %S, SidUse = %d\n", szSid, szDomainName, SidUse);
        return;

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\testnotify\test.c ===
#include <windows.h>
#include <stdio.h>
#include <userenv.h>
#include <userenvp.h>

int __cdecl main( int argc, char *argv[])
{
    HANDLE hToken;
    HANDLE hEventMach, hEventUser, hEvents[2];
    DWORD dwRet;


    OpenProcessToken (GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);

    hEvents[0] = hEventMach = CreateEvent (NULL, FALSE, FALSE, TEXT("some event mach"));
    hEvents[1] = hEventUser = CreateEvent (NULL, FALSE, FALSE, TEXT("some event user"));

    if (!RegisterGPNotification(hEventMach, TRUE)) {
        printf("RegisterGPNotification for machine failed with error - %d\n", GetLastError());
        return FALSE;
    }

    if (!RegisterGPNotification(hEventUser, FALSE)) {
        printf("RegisterGPNotification for user failed with error - %d\n", GetLastError());
        return FALSE;
    }


    printf("Going into the loop\n");
    
    for (;;) {

        dwRet = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);


        switch (dwRet - WAIT_OBJECT_0) {
        case 0:
            printf("Machine event got notified\n");
            break;

        case 1:
            printf("User event got notified\n");
            break;


        default:
            printf("WaitForMultipleObjects returned error - %d\n", GetLastError());
            break;
        }

        printf("Rewaiting..\n");
    }

    CloseHandle (hEventMach);
    CloseHandle (hEventUser);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\samples\rcmd\server\session.h ===
/****************************** Module Header ******************************\
* Module Name: session.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Remote shell session module header file
*
* History:
* 06-28-92 Davidc       Created.
\***************************************************************************/


//
// Define session thread notification values
//

typedef enum {
    ConnectError,
    DisconnectError,
    ClientDisconnected,
    ShellEnded,
    ServiceStopped
} SESSION_DISCONNECT_CODE, *PSESSION_NOTIFICATION_CODE;


//
// Function protoypes
//

HANDLE
CreateSession(
    HANDLE TokenToUse,
    PCOMMAND_HEADER LpCommandHeader
    );

VOID
DeleteSession(
    HANDLE  SessionHandle
    );

HANDLE
ConnectSession(
    HANDLE  SessionHandle,
    HANDLE  ClientPipeHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "rsopdbg.h"
#include "strsafe.h"

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;
DWORD   dwRsopLoggingLevel = 1;  // Rsop logging setting

//
// Debug strings
//

const TCHAR c_szUserEnv[] = TEXT("USERENV(%x.%x) %02d:%02d:%02d:%03d ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon")
#define DEBUG_KEY_NAME      TEXT("UserEnvDebugLevel")
#define RSOP_KEY_NAME       TEXT("RsopLogging")

//
// Log files
//


TCHAR szLogFileName[] = L"%SystemRoot%\\Debug\\UserMode\\userenv.log";       // Current log
TCHAR szBackupLogFileName[] = L"%SystemRoot%\\Debug\\UserMode\\userenv.bak"; // Backup/previous log

CDebug dbgCommon;


//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: dwLoadFlags - If this is being loaded by winlogon
//                            or setup.exe
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//              04/10/2002  mingzhu    Changed the default level to none 
//
//*************************************************************

void InitDebugSupport( DWORD dwLoadFlags )
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize, dwRet;
    WIN32_FILE_ATTRIBUTE_DATA   FileData;

    //
    // Initialize the debug level to normal for checked builds, and none for retail builds. 
    //

#if DBG
    dwDebugLevel = DL_NORMAL | DL_LOGFILE | DL_DEBUGGER;
#else
    dwDebugLevel = DL_NONE;
#endif

    dwRsopLoggingLevel = 1;

    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        dwSize = sizeof(dwRsopLoggingLevel);
        RegQueryValueEx(hKey, RSOP_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwRsopLoggingLevel, &dwSize);

        RegCloseKey(hKey);
    }

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        dwSize = sizeof(dwRsopLoggingLevel);
        RegQueryValueEx(hKey, RSOP_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwRsopLoggingLevel, &dwSize);

        RegCloseKey(hKey);
    }


    //
    // To avoid a huge log file, copy current log file to backup
    // file if the log file is over 300K
    //
    if ( dwLoadFlags == WINLOGON_LOAD ) {

        TCHAR szExpLogFileName[MAX_PATH];
        TCHAR szExpBackupLogFileName[MAX_PATH];

        dwRet = ExpandEnvironmentStrings ( szLogFileName, szExpLogFileName, MAX_PATH);

        if ( dwRet == 0 || dwRet > MAX_PATH)
            return;

        if (!GetFileAttributesEx(szExpLogFileName, GetFileExInfoStandard, &FileData)) {
            return;
        }

        if ( FileData.nFileSizeLow < (300 * 1024) ) {
            return;
        }

        dwRet = ExpandEnvironmentStrings ( szBackupLogFileName, szExpBackupLogFileName, MAX_PATH);

        if ( dwRet == 0 || dwRet > MAX_PATH)
            return;

        dwRet = MoveFileEx( szExpLogFileName, szExpBackupLogFileName, MOVEFILE_REPLACE_EXISTING);

        if ( dwRet == 0 ) {
            DebugMsg((DM_VERBOSE, TEXT("Moving log file to backup failed with 0x%x"), GetLastError()));
            return;
        }
    }

    
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[60];
    LPTSTR lpDebugBuffer;
    va_list marker;
    DWORD dwErrCode;
    SYSTEMTIME systime;
    BOOL bDebugOutput = FALSE;
    BOOL bLogfileOutput = FALSE;

    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Determine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    bDebugOutput = dwDebugLevel & DL_DEBUGGER;
    bLogfileOutput = dwDebugLevel & DL_LOGFILE;

    if (bOutput) {

        lpDebugBuffer = (LPTSTR) LocalAlloc (LPTR, 2048 * sizeof(TCHAR));

        if (lpDebugBuffer) {

            GetLocalTime (&systime);
            StringCchPrintf(szDebugTitle, ARRAYSIZE(szDebugTitle), c_szUserEnv,
                      GetCurrentProcessId(), GetCurrentThreadId(),
                      systime.wHour, systime.wMinute, systime.wSecond,
                      systime.wMilliseconds);

            if ( bDebugOutput)
                OutputDebugString(szDebugTitle);

            va_start(marker, pszMsg);

            StringCchVPrintf (lpDebugBuffer, 2048, pszMsg, marker);

            if ( bDebugOutput) {
                OutputDebugString(lpDebugBuffer);
                OutputDebugString(c_szCRLF);
            }

            va_end(marker);

            if ( bLogfileOutput ) {

                HANDLE hFile;
                DWORD dwBytesWritten;
                LPTSTR szExpLogFileName;

                szExpLogFileName = (LPTSTR) LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

                if (szExpLogFileName)
                {

                    DWORD dwRet = ExpandEnvironmentStrings ( szLogFileName, szExpLogFileName, MAX_PATH);

                    if ( dwRet != 0 && dwRet <= MAX_PATH) {

                        hFile = CreateFile( szExpLogFileName,
                                           FILE_WRITE_DATA | FILE_APPEND_DATA,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_ALWAYS,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL);

                        if (hFile != INVALID_HANDLE_VALUE) {

                            if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                                WriteFile (hFile, (LPCVOID) szDebugTitle,
                                           lstrlen (szDebugTitle) * sizeof(TCHAR),
                                           &dwBytesWritten,
                                           NULL);

                                WriteFile (hFile, (LPCVOID) lpDebugBuffer,
                                           lstrlen (lpDebugBuffer) * sizeof(TCHAR),
                                           &dwBytesWritten,
                                           NULL);

                                WriteFile (hFile, (LPCVOID) c_szCRLF,
                                           lstrlen (c_szCRLF) * sizeof(TCHAR),
                                           &dwBytesWritten,
                                           NULL);
                            }

                            CloseHandle (hFile);
                        }
                    }

                    LocalFree(szExpLogFileName);
                }

            }

            LocalFree (lpDebugBuffer);
        }
    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

#if DBG
    if (mask == DM_ASSERT) {
        DebugBreak();
    }
#endif
}



//*************************************************************
//
//  RsopLoggingEnabled()
//
//  Purpose:    Checks if Rsop logging is enabled.
//
//*************************************************************

extern "C"
BOOL RsopLoggingEnabled()
{
    return dwRsopLoggingLevel != 0;
}

//*************************************************************
//
//  DeletePreviousLogFiles()
//
//  Purpose:    Try to delete the previous userenv log file during 
//              setup if the debug level is NONE
//
//  Parameters: 
//
//  Return:     S_OK on success, else for failure
//
//  Comments:   Called by DetermineProfileLocation(), which is the first
//              function call during setup. 
//
//  History:    Date        Author     Comment
//              04/10/2002  mingzhu    Created
//
//*************************************************************

HRESULT DeletePreviousLogFiles()
{
    HRESULT hr = E_FAIL;
    TCHAR szExpLogFileName[MAX_PATH];
    
    //
    //  First check the debug level, if it is not NONE, do nothing
    //
    if (LOWORD(dwDebugLevel) != DL_NONE)
    {
        hr = S_OK;
        goto Exit;
    }

    //
    //  Delete the log file
    //
    
    hr = SafeExpandEnvironmentStrings(szLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));
    if (FAILED(hr))
    {
        goto Exit;
    }

    if (!DeleteFile (szExpLogFileName))
    {
        DWORD dwErr = GetLastError();

        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Exit;
        }
    }

    //
    //  Delete the backup log file
    //

    hr = SafeExpandEnvironmentStrings(szBackupLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    if (!DeleteFile (szExpLogFileName))
    {
        DWORD dwErr = GetLastError();

        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Exit;
        }
    }

    hr = S_OK;
    
Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\dllload.cpp ===
//*************************************************************
//
//  DLL loading functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

//
// file global variables containing pointers to APIs and
// loaded modules
//

NETAPI32_API    g_NetApi32Api;
SECUR32_API     g_Secur32Api;
LDAP_API        g_LdapApi;
ICMP_API        g_IcmpApi;
WSOCK32_API     g_WSock32Api;
DS_API          g_DsApi;
SHELL32_API     g_Shell32Api;
SHLWAPI_API     g_ShlwapiApi;
OLE32_API       g_Ole32Api;
GPTEXT_API      g_GpTextApi;
IPHLPAPI_API    g_IpHlpApi;
WS2_32_API      g_ws2_32Api;

CRITICAL_SECTION *g_ApiDLLCritSec = NULL;

//*************************************************************
//
//  InitializeAPIs()
//
//  Purpose:    initializes API structures for delay loaded
//              modules
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void InitializeAPIs( void )
{
    ZeroMemory( &g_NetApi32Api, sizeof( NETAPI32_API ) );
    ZeroMemory( &g_Secur32Api,  sizeof( SECUR32_API ) );
    ZeroMemory( &g_LdapApi,     sizeof( LDAP_API ) );
    ZeroMemory( &g_IcmpApi,     sizeof( ICMP_API ) );
    ZeroMemory( &g_WSock32Api,  sizeof( WSOCK32_API ) );
    ZeroMemory( &g_DsApi,       sizeof( DS_API ) );
    ZeroMemory( &g_Shell32Api,  sizeof( SHELL32_API ) );
    ZeroMemory( &g_ShlwapiApi,  sizeof( SHLWAPI_API ) );
    ZeroMemory( &g_Ole32Api,    sizeof( OLE32_API ) );
    ZeroMemory( &g_GpTextApi,   sizeof( GPTEXT_API ) );
}

//*************************************************************
//
//  InitializeApiDLLsCritSec()
//
//  Purpose:    initializes a CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     ERROR_SUCCESS if successful
//              An error if it fails.
//
//*************************************************************

DWORD InitializeApiDLLsCritSec( void )
{
    CRITICAL_SECTION *pCritSec     = NULL;
    DWORD             result       = ERROR_SUCCESS;
    BOOL              fInitialized = FALSE;
    CRITICAL_SECTION *pInitial;

    // If the critical section already exists, return.
    if (g_ApiDLLCritSec != NULL)
        return ERROR_SUCCESS;

    // Allocate memory for the critial section.
    pCritSec = (CRITICAL_SECTION *) LocalAlloc( LMEM_FIXED,
                                                sizeof(CRITICAL_SECTION) );
    if (pCritSec == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Initialize the critical section.  Using the flag 0x80000000
    // preallocates the event so that EnterCriticalSection can only
    // throw timeout exceptions.
    __try
    {
        if (!InitializeCriticalSectionAndSpinCount( pCritSec, 0x80000000 ))
            result = GetLastError();
        else
            fInitialized = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        result = GetExceptionCode();
    }
    if (result != ERROR_SUCCESS)
        goto Exit;

    // Save the critical section.
    pInitial = (CRITICAL_SECTION *) InterlockedCompareExchangePointer(
        (void **) &g_ApiDLLCritSec, (void *) pCritSec, NULL );

    // If the InterlockedCompareExchange succeeded, don't free the
    // critical section just allocated.
    if (pInitial == NULL)
        pCritSec = NULL;

Exit:
    if (pCritSec != NULL)
    {
        if (fInitialized)
            DeleteCriticalSection( pCritSec );
        LocalFree( pCritSec );
    }
    return result;
}

//*************************************************************
//
//  CloseApiDLLsCritSec()
//
//  Purpose:    clean up CRITICAL_SECTION for synch'ing
//              DLL loads
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void CloseApiDLLsCritSec( void )
{
    if (g_ApiDLLCritSec != NULL)
    {
        DeleteCriticalSection( g_ApiDLLCritSec );
        LocalFree( g_ApiDLLCritSec );
        g_ApiDLLCritSec = NULL;
    }
}

//*************************************************************
//
//  LoadNetAPI32()
//
//  Purpose:    Loads netapi32.dll
//
//  Parameters: pNETAPI32 - pointer to a NETAPI32_API structure to
//                         initialize
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PNETAPI32_API LoadNetAPI32 ()
{
    BOOL bResult = FALSE;
    PNETAPI32_API pNetAPI32 = &g_NetApi32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pNetAPI32->hInstance ) {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pNetAPI32;
    }

    pNetAPI32->hInstance = LoadLibrary (TEXT("netapi32.dll"));

    if (!pNetAPI32->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to load netapi32 with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsGetDcName = (PFNDSGETDCNAME) GetProcAddress (pNetAPI32->hInstance,
#ifdef UNICODE
                                                                 "DsGetDcNameW");
#else
                                                                 "DsGetDcNameA");
#endif

    if (!pNetAPI32->pfnDsGetDcName) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find DsGetDcName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsGetSiteName = (PFNDSGETSITENAME) GetProcAddress (pNetAPI32->hInstance,
#ifdef UNICODE
                                                                     "DsGetSiteNameW");
#else
                                                                     "DsGetSiteNameA");
#endif

    if (!pNetAPI32->pfnDsGetSiteName) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find DsGetSiteName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsRoleGetPrimaryDomainInformation = (PFNDSROLEGETPRIMARYDOMAININFORMATION)GetProcAddress (pNetAPI32->hInstance,
                                                       "DsRoleGetPrimaryDomainInformation");

    if (!pNetAPI32->pfnDsRoleGetPrimaryDomainInformation) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find pfnDsRoleGetPrimaryDomainInformation with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnDsRoleFreeMemory = (PFNDSROLEFREEMEMORY)GetProcAddress (pNetAPI32->hInstance,
                                                                          "DsRoleFreeMemory");

    if (!pNetAPI32->pfnDsRoleFreeMemory) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find pfnDsRoleFreeMemory with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnNetApiBufferFree = (PFNNETAPIBUFFERFREE) GetProcAddress (pNetAPI32->hInstance,
                                                                           "NetApiBufferFree");

    if (!pNetAPI32->pfnNetApiBufferFree) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find NetApiBufferFree with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnNetUserGetGroups = (PFNNETUSERGETGROUPS) GetProcAddress (pNetAPI32->hInstance,
                                                                           "NetUserGetGroups");

    if (!pNetAPI32->pfnNetUserGetGroups) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find NetUserGetGroups with %d."),
                 GetLastError()));
        goto Exit;
    }


    pNetAPI32->pfnNetUserGetInfo = (PFNNETUSERGETINFO) GetProcAddress (pNetAPI32->hInstance,
                                                                      "NetUserGetInfo");

    if (!pNetAPI32->pfnNetUserGetInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadNetAPI32:  Failed to find NetUserGetInfo with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("netapi32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pNetAPI32->hInstance ) {
            FreeLibrary( pNetAPI32->hInstance );
        }
        ZeroMemory( pNetAPI32, sizeof( NETAPI32_API ) );
        pNetAPI32 = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pNetAPI32;
}


//*************************************************************
//
//  LoadSecur32()
//
//  Purpose:    Loads secur32.dll
//
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PSECUR32_API LoadSecur32 ()
{
    BOOL bResult = FALSE;
    PSECUR32_API pSecur32 = &g_Secur32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pSecur32->hInstance ) {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pSecur32;
    }

    //
    // Load secur32.dll
    //

    pSecur32->hInstance = LoadLibrary (TEXT("secur32.dll"));

    if (!pSecur32->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to load secur32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    pSecur32->pfnGetUserNameEx = (PFNGETUSERNAMEEX)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "GetUserNameExW");
#else
                                        "GetUserNameExA");
#endif


    if (!pSecur32->pfnGetUserNameEx) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find GetUserNameEx with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnGetComputerObjectName = (PFNGETCOMPUTEROBJECTNAME)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "GetComputerObjectNameW");
#else
                                        "GetComputerObjectNameA");
#endif


    if (!pSecur32->pfnGetComputerObjectName) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find GetComputerObjectName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnTranslateName = (PFNTRANSLATENAME)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "TranslateNameW");
#else
                                        "TranslateNameA");
#endif


    if (!pSecur32->pfnTranslateName) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find TranslateName with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnAcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN)GetProcAddress (pSecur32->hInstance,
                                        "AcceptSecurityContext");

    if (!pSecur32->pfnAcceptSecurityContext) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find AcceptSecurityContext with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnAcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "AcquireCredentialsHandleW");
#else
                                        "AcquireCredentialsHandleA");
#endif


    if (!pSecur32->pfnAcquireCredentialsHandle) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find AcquireCredentialsHandle with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnDeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN)GetProcAddress (pSecur32->hInstance,
                                        "DeleteSecurityContext");

    if (!pSecur32->pfnDeleteSecurityContext) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find DeleteSecurityContext with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)GetProcAddress (pSecur32->hInstance,
                                        "FreeContextBuffer");

    if (!pSecur32->pfnFreeContextBuffer) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find FreeContextBuffer with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnFreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)GetProcAddress (pSecur32->hInstance,
                                        "FreeCredentialsHandle");

    if (!pSecur32->pfnFreeCredentialsHandle) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find FreeCredentialsHandle with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnInitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "InitializeSecurityContextW");
#else
                                        "InitializeSecurityContextA");
#endif


    if (!pSecur32->pfnInitializeSecurityContext) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find InitializeSecurityContext with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnQuerySecurityContextToken = (QUERY_SECURITY_CONTEXT_TOKEN_FN)GetProcAddress (pSecur32->hInstance,
                                        "QuerySecurityContextToken");

    if (!pSecur32->pfnQuerySecurityContextToken) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find QuerySecurityContextToken with %d."),
                 GetLastError()));
        goto Exit;
    }


    pSecur32->pfnQuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)GetProcAddress (pSecur32->hInstance,
#ifdef UNICODE
                                        "QuerySecurityPackageInfoW");
#else
                                        "QuerySecurityPackageInfoA");
#endif


    if (!pSecur32->pfnQuerySecurityPackageInfo) {
        DebugMsg((DM_WARNING, TEXT("LoadSecur32:  Failed to find QuerySecurityPackageInfo with %d."),
                 GetLastError()));
        goto Exit;
    }



    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("secur32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pSecur32->hInstance ) {
            FreeLibrary( pSecur32->hInstance );
        }
        ZeroMemory( pSecur32, sizeof( SECUR32_API ) );
        pSecur32 = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pSecur32;
}


//*************************************************************
//
//  LoadLDAP()
//
//  Purpose:    Loads wldap32.dll
//
//  Parameters: pLDAP - pointer to a  LDAP_API structure to
//                      initialize
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PLDAP_API LoadLDAP ()
{
    BOOL bResult = FALSE;
    PLDAP_API pLDAP = &g_LdapApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pLDAP->hInstance ) {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pLDAP;
    }

    //
    // Load wldap32.dll
    //

    pLDAP->hInstance = LoadLibrary (TEXT("wldap32.dll"));

    if (!pLDAP->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to load wldap32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_open = (PFNLDAP_OPEN) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_openW");
#else
                                        "ldap_openA");
#endif

    if (!pLDAP->pfnldap_open) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_open with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_init = (PFNLDAP_INIT) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_initW");
#else
                                        "ldap_initA");
#endif

    if (!pLDAP->pfnldap_init) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_init with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_connect = (PFNLDAP_CONNECT) GetProcAddress (pLDAP->hInstance,
                                        "ldap_connect");

    if (!pLDAP->pfnldap_connect) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_connect with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_bind_s = (PFNLDAP_BIND_S) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_bind_sW");
#else
                                        "ldap_bind_sA");
#endif

    if (!pLDAP->pfnldap_bind_s) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_bind_s with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_search_s = (PFNLDAP_SEARCH_S) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_search_sW");
#else
                                        "ldap_search_sA");
#endif

    if (!pLDAP->pfnldap_search_s) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_search_s with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_search_ext_s = (PFNLDAP_SEARCH_EXT_S) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_search_ext_sW");
#else
                                        "ldap_search_ext_sA");
#endif

    if (!pLDAP->pfnldap_search_ext_s) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_search_ext_s with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_get_values = (PFNLDAP_GET_VALUES) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_get_valuesW");
#else
                                        "ldap_get_valuesA");
#endif

    if (!pLDAP->pfnldap_get_values) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_get_values with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_value_free = (PFNLDAP_VALUE_FREE) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_value_freeW");
#else
                                        "ldap_value_freeA");
#endif

    if (!pLDAP->pfnldap_value_free) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_value_free with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_get_values_len = (PFNLDAP_GET_VALUES_LEN) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_get_values_lenW");
#else
                                        "ldap_get_values_lenA");
#endif

    if (!pLDAP->pfnldap_get_values_len) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_get_values_len with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_value_free_len = (PFNLDAP_VALUE_FREE_LEN) GetProcAddress (pLDAP->hInstance,
                                        "ldap_value_free_len");

    if (!pLDAP->pfnldap_value_free_len) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_value_free_len with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_msgfree = (PFNLDAP_MSGFREE) GetProcAddress (pLDAP->hInstance,
                                        "ldap_msgfree");

    if (!pLDAP->pfnldap_msgfree) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_msgfree with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_unbind = (PFNLDAP_UNBIND) GetProcAddress (pLDAP->hInstance,
                                        "ldap_unbind");

    if (!pLDAP->pfnldap_unbind) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_unbind with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnLdapGetLastError = (PFNLDAPGETLASTERROR) GetProcAddress (pLDAP->hInstance,
                                        "LdapGetLastError");

    if (!pLDAP->pfnLdapGetLastError) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find pfnLdapGetLastError with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_first_entry = (PFNLDAP_FIRST_ENTRY) GetProcAddress (pLDAP->hInstance,
                                        "ldap_first_entry");

    if (!pLDAP->pfnldap_first_entry) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_first_entry with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_next_entry = (PFNLDAP_NEXT_ENTRY) GetProcAddress (pLDAP->hInstance,
                                        "ldap_next_entry");

    if (!pLDAP->pfnldap_next_entry) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_next_entry with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_get_dn = (PFNLDAP_GET_DN) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_get_dnW");
#else
                                        "ldap_get_dnA");
#endif

    if (!pLDAP->pfnldap_get_dn) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_get_dn with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_set_option = (PFNLDAP_SET_OPTION) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_set_optionW");
#else
                                        "ldap_set_option");
#endif

    if (!pLDAP->pfnldap_set_option) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_set_option with %d."),
                 GetLastError()));
        goto Exit;
    }


    pLDAP->pfnldap_memfree = (PFNLDAP_MEMFREE) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_memfreeW");
#else
                                        "ldap_memfreeA");
#endif

    if (!pLDAP->pfnldap_memfree) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_memfree with %d."),
                 GetLastError()));
        goto Exit;
    }

    
    pLDAP->pfnLdapMapErrorToWin32 = (PFNLDAPMAPERRORTOWIN32) GetProcAddress (pLDAP->hInstance,
                                        "LdapMapErrorToWin32");

    if (!pLDAP->pfnLdapMapErrorToWin32) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find LdapMapErrorToWin32 with %d."),
                 GetLastError()));
        goto Exit;
    }

    pLDAP->pfnldap_err2string = (PFNLDAP_ERR2STRING) GetProcAddress (pLDAP->hInstance,
#ifdef UNICODE
                                        "ldap_err2stringW");
#else
                                        "ldap_err2stringA");
#endif

    if (!pLDAP->pfnldap_err2string) {
        DebugMsg((DM_WARNING, TEXT("LoadLDAP:  Failed to find ldap_err2string with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("wldap32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pLDAP->hInstance ) {
            FreeLibrary( pLDAP->hInstance );
        }
        ZeroMemory( pLDAP, sizeof( LDAP_API ) );

        pLDAP = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pLDAP;
}


//*************************************************************
//
//  LoadIcmp()
//
//  Purpose:    Loads cmp.dll
//
//  Parameters: pIcmp - pointer to a ICMP_API structure to
//                         initialize
//
//
//  Return:     ERROR_SUCCESS if successful
//              result if an error occurs
//
//*************************************************************

DWORD LoadIcmp ( PICMP_API *pIcmpOut )
{
    DWORD     dwResult = ERROR_SUCCESS;
    PICMP_API pIcmp    = &g_IcmpApi;

    *pIcmpOut = NULL;
    dwResult = InitializeApiDLLsCritSec();
    if (dwResult != ERROR_SUCCESS)
        return dwResult;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pIcmp->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        *pIcmpOut = pIcmp;
        return ERROR_SUCCESS;
    }

    pIcmp->hInstance = LoadLibrary (TEXT("icmp.dll"));

    if (!pIcmp->hInstance) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to load icmp with %d."),
                 GetLastError()));
        goto Exit;
    }


    pIcmp->pfnIcmpCreateFile = (PFNICMPCREATEFILE) GetProcAddress (pIcmp->hInstance,
                                                                   "IcmpCreateFile");

    if (!pIcmp->pfnIcmpCreateFile) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to find IcmpCreateFile with %d."),
                 GetLastError()));
        goto Exit;
    }


    pIcmp->pfnIcmpCloseHandle = (PFNICMPCLOSEHANDLE) GetProcAddress (pIcmp->hInstance,
                                                                   "IcmpCloseHandle");

    if (!pIcmp->pfnIcmpCloseHandle) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to find IcmpCloseHandle with %d."),
                 GetLastError()));
        goto Exit;
    }


    pIcmp->pfnIcmpSendEcho = (PFNICMPSENDECHO) GetProcAddress (pIcmp->hInstance,
                                                                   "IcmpSendEcho");

    if (!pIcmp->pfnIcmpSendEcho) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadIcmp:  Failed to find IcmpSendEcho with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

Exit:

    if (dwResult != ERROR_SUCCESS) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("icmp.dll")); ev.AddArgWin32Error(dwResult); ev.Report();

        if ( pIcmp->hInstance ) {
            FreeLibrary( pIcmp->hInstance );
        }
        ZeroMemory( pIcmp, sizeof( ICMP_API ) );

        pIcmp = 0;
    }
    else
        *pIcmpOut = pIcmp;

    LeaveCriticalSection( g_ApiDLLCritSec );

    return dwResult;
}


//*************************************************************
//
//  LoadWSock()
//
//  Purpose:    Loads WINSOCK DLL and store entry point to global 
//              structure. Also calls initialize funtion for WINSOCK.
//
//  Parameters: pWSock32 - pointer to a WSOCK32_API structure to
//                         initialize
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PWSOCK32_API LoadWSock32 ()
{
    BOOL bResult = FALSE;
    PWSOCK32_API pWSock32 = &g_WSock32Api;
    WORD wVersionRequested;
    int err;
    LPFN_WSASTARTUP pfnwsastartup;
    WSADATA wsaData;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pWSock32->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pWSock32;
    }

    pWSock32->hInstance = LoadLibrary (TEXT("wsock32.dll"));

    if (!pWSock32->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to load wsock32 with %d."),
                 GetLastError()));
        goto Exit;
    }


    pWSock32->pfninet_addr = (LPFN_INET_ADDR) GetProcAddress (pWSock32->hInstance,
                                                                   "inet_addr");

    if (!pWSock32->pfninet_addr) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to find inet_addr with %d."),
                 GetLastError()));
        goto Exit;
    }


    pWSock32->pfngethostbyname = (LPFN_GETHOSTBYNAME) GetProcAddress (pWSock32->hInstance,
                                                                   "gethostbyname");

    if (!pWSock32->pfngethostbyname) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to find gethostbyname with %d."),
                 GetLastError()));
        goto Exit;
    }

    pfnwsastartup = (LPFN_WSASTARTUP) GetProcAddress (pWSock32->hInstance,"WSAStartup");

    if (!pfnwsastartup) {
        DebugMsg((DM_WARNING, TEXT("LoadWSock32:  Failed to find WSAStartup with %d."),
                 GetLastError()));
        goto Exit;
    }

    wVersionRequested = WINSOCK_VERSION;
    err = pfnwsastartup(wVersionRequested, &wsaData);
    if (err)
    {
        SetLastError(err);
        DebugMsg((DM_WARNING, TEXT("LoadWSock32: WSAStartup returned 0x%08x"), err));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("wsock32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pWSock32->hInstance ) {
            FreeLibrary( pWSock32->hInstance );
        }
        ZeroMemory( pWSock32, sizeof( WSOCK32_API ) );

        pWSock32 = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pWSock32;
}

//*************************************************************
//
//  LoadDSAPI()
//
//  Purpose:    Loads ntdsapi.dll
//
//  Parameters: pDSApi - pointer to a DS_API structure to initialize
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

PDS_API LoadDSApi()
{
    BOOL bResult = FALSE;
    PDS_API pDSApi = &g_DsApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pDSApi->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pDSApi;
    }

    pDSApi->hInstance = LoadLibrary (TEXT("ntdsapi.dll"));

    if (!pDSApi->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadDSApi:  Failed to load ntdsapi with %d."),
                 GetLastError()));
        goto Exit;
    }


    pDSApi->pfnDsCrackNames = (PFN_DSCRACKNAMES) GetProcAddress (pDSApi->hInstance,
#ifdef UNICODE
                                                                 "DsCrackNamesW");
#else
                                                                 "DsCrackNamesA");
#endif

    if (!pDSApi->pfnDsCrackNames) {
        DebugMsg((DM_WARNING, TEXT("LoadDSApi:  Failed to find DsCrackNames with %d."),
                 GetLastError()));
        goto Exit;
    }


    pDSApi->pfnDsFreeNameResult = (PFN_DSFREENAMERESULT) GetProcAddress (pDSApi->hInstance,
#ifdef UNICODE
                                                                 "DsFreeNameResultW");
#else
                                                                 "DsFreeNameResultA");
#endif

    if (!pDSApi->pfnDsFreeNameResult) {
        DebugMsg((DM_WARNING, TEXT("LoadDSApi:  Failed to find DsFreeNameResult with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("ntdsapi.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pDSApi->hInstance ) {
            FreeLibrary( pDSApi->hInstance );
        }
        ZeroMemory( pDSApi, sizeof( DS_API ) );

        pDSApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pDSApi;
}

//*************************************************************
//
//  LoadShell32Api()
//
//  Purpose:    Loads shell32.dll
//
//  Parameters: pointer to hold SHELL32_API
//
//  Return:     ERROR_SUCCESS if successful
//              error code if not successful
//
//*************************************************************

DWORD LoadShell32Api( PSHELL32_API *ppShell32Api )
{
    DWORD        dwErr;
    PSHELL32_API pShell32Api = &g_Shell32Api;

    dwErr = InitializeApiDLLsCritSec();
    if (dwErr != ERROR_SUCCESS)
        return dwErr;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pShell32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        *ppShell32Api = pShell32Api;

        return ERROR_SUCCESS;
    }

    pShell32Api->hInstance = LoadLibrary (TEXT("shell32.dll"));

    if (!pShell32Api->hInstance) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to load ntdsapi with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShell32Api->pfnShChangeNotify = (PFNSHCHANGENOTIFY) GetProcAddress (pShell32Api->hInstance, "SHChangeNotify");

    if (!pShell32Api->pfnShChangeNotify) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHChangeNotify with %d."),
                 GetLastError()));
        goto Exit;
    }

    pShell32Api->pfnShGetSpecialFolderPath = (PFNSHGETSPECIALFOLDERPATH) GetProcAddress (pShell32Api->hInstance,
#ifdef UNICODE
                                                                 "SHGetSpecialFolderPathW");
#else
                                                                 "SHGetSpecialFolderPathA");
#endif

    if (!pShell32Api->pfnShGetSpecialFolderPath) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHGetSpecialFolderPath with %d."),
                 GetLastError()));
        goto Exit;
    }

    pShell32Api->pfnShGetFolderPath = (PFNSHGETFOLDERPATH) GetProcAddress (pShell32Api->hInstance,
#ifdef UNICODE
                                                                 "SHGetFolderPathW");
#else
                                                                 "SHGetFolderPathA");
#endif


    if (!pShell32Api->pfnShGetFolderPath) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHGetFolderPath with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShell32Api->pfnShSetFolderPath = (PFNSHSETFOLDERPATH) GetProcAddress (pShell32Api->hInstance,
#ifdef UNICODE
                                                                 (LPCSTR)SHSetFolderW_Ord);
#else
                                                                 (LPCSTR)SHSetFolderA_Ord);
#endif

    if (!pShell32Api->pfnShSetFolderPath) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHSetFolderPath with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShell32Api->pfnShSetLocalizedName = (PFNSHSETLOCALIZEDNAME)
      GetProcAddress (pShell32Api->hInstance, "SHSetLocalizedName");

    if (!pShell32Api->pfnShSetLocalizedName) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find SHSetLocalizedName with %d."),
                 GetLastError()));
        goto Exit;
    }


    //
    // Success
    //

    dwErr = ERROR_SUCCESS;

Exit:

    if (dwErr != ERROR_SUCCESS) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("shell32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pShell32Api->hInstance ) {
            FreeLibrary( pShell32Api->hInstance );
        }
        ZeroMemory( pShell32Api, sizeof( SHELL32_API ) );

        pShell32Api = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );
    *ppShell32Api = pShell32Api;

    return dwErr;
}


//*************************************************************
//
//  LoadShwapiAPI()
//
//  Purpose:    Loads shlwapi.dll
//
//  Parameters: none
//
//  Return:     pointer to SHLWAPI_API
//
//*************************************************************

PSHLWAPI_API LoadShlwapiApi()
{
    BOOL bResult = FALSE;
    PSHLWAPI_API pShlwapiApi = &g_ShlwapiApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pShlwapiApi->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pShlwapiApi;
    }

    pShlwapiApi->hInstance = LoadLibrary (TEXT("shlwapi.dll"));

    if (!pShlwapiApi->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to load ntdsapi with %d."),
                 GetLastError()));
        goto Exit;
    }


    pShlwapiApi->pfnPathGetArgs = (PFNPATHGETARGS) GetProcAddress (pShlwapiApi->hInstance,
#ifdef UNICODE
                                                                 "PathGetArgsW");
#else
                                                                 "PathGetArgsA");
#endif

    if (!pShlwapiApi->pfnPathGetArgs) {
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find PathGetArgs with %d."),
                 GetLastError()));
        goto Exit;
    }

    pShlwapiApi->pfnPathUnquoteSpaces = (PFNPATHUNQUOTESPACES) GetProcAddress (pShlwapiApi->hInstance,
#ifdef UNICODE
                                                                 "PathUnquoteSpacesW");
#else
                                                                 "PathUnquoteSpacesA");
#endif

    if (!pShlwapiApi->pfnPathUnquoteSpaces) {
        DebugMsg((DM_WARNING, TEXT("LoadShlwapiApi:  Failed to find PathUnquoteSpaces with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("shlwapi.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pShlwapiApi->hInstance ) {
            FreeLibrary( pShlwapiApi->hInstance );
        }
        ZeroMemory( pShlwapiApi, sizeof( SHLWAPI_API ) );

        pShlwapiApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pShlwapiApi;
}


//*************************************************************
//
//  LoadOle32Api()
//
//  Purpose:    Loads ole32.dll
//
//  Parameters: none
//
//  Return:     pointer to OLE32_API
//
//*************************************************************

POLE32_API LoadOle32Api()
{
    BOOL bResult = FALSE;
    OLE32_API *pOle32Api = &g_Ole32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pOle32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        return pOle32Api;
    }

    pOle32Api->hInstance = LoadLibrary (TEXT("ole32.dll"));

    if (!pOle32Api->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to load ole32.dll with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoCreateInstance = (PFNCOCREATEINSTANCE) GetProcAddress (pOle32Api->hInstance,
                                                                           "CoCreateInstance");
    if (!pOle32Api->pfnCoCreateInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoCreateInstance with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress (pOle32Api->hInstance,
                                                                       "CoInitializeEx");
    if (!pOle32Api->pfnCoInitializeEx) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoInitializeEx with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoUnInitialize = (PFNCOUNINITIALIZE) GetProcAddress (pOle32Api->hInstance,
                                                                        "CoUninitialize");
    if (!pOle32Api->pfnCoUnInitialize) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoUnInitialize with %d."),
                 GetLastError()));
        goto Exit;
    }

    pOle32Api->pfnCoCreateGuid = (PFNCOCREATEGUID) GetProcAddress (pOle32Api->hInstance,
                                                                   "CoCreateGuid");
    if (!pOle32Api->pfnCoCreateGuid) {
        DebugMsg((DM_WARNING, TEXT("LoadOle32Api:  Failed to find CoCreateGuid with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("ole32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pOle32Api->hInstance ) {
            FreeLibrary( pOle32Api->hInstance );
        }

        ZeroMemory( pOle32Api, sizeof( OLE32_API ) );
        pOle32Api = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pOle32Api;
}



//*************************************************************
//
//  LoadGpTextApi()
//
//  Purpose:    Loads gptext.dll
//
//  Parameters: none
//
//  Return:     pointer to GPTEXT_API
//
//*************************************************************

GPTEXT_API * LoadGpTextApi()
{
    BOOL bResult = FALSE;
    GPTEXT_API *pGpTextApi = &g_GpTextApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pGpTextApi->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        return pGpTextApi;
    }

    pGpTextApi->hInstance = LoadLibrary (TEXT("gptext.dll"));

    if (!pGpTextApi->hInstance) {
        DebugMsg((DM_WARNING, TEXT("LoadGpTextApi:  Failed to load gptext.dll with %d."),
                 GetLastError()));
        goto Exit;
    }

    pGpTextApi->pfnScrRegGPOListToWbem = (PFNSCRREGGPOLISTTOWBEM) GetProcAddress (pGpTextApi->hInstance,
                                                                  "ScrRegGPOListToWbem");
    if (!pGpTextApi->pfnScrRegGPOListToWbem) {
        DebugMsg((DM_WARNING, TEXT("LoadGpTextApi:  Failed to find ScrRegGPOListToWbem with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("gptext.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pGpTextApi->hInstance ) {
            FreeLibrary( pGpTextApi->hInstance );
        }

        ZeroMemory( pGpTextApi, sizeof( GPTEXT_API ) );
        pGpTextApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pGpTextApi;
}

PIPHLPAPI_API LoadIpHlpApi()
{
    bool bResult = false;
    PIPHLPAPI_API pIpHlpApi = &g_IpHlpApi;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pIpHlpApi->hInstance )
    {
        //
        // module is already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );

        return pIpHlpApi;
    }

    pIpHlpApi->hInstance = LoadLibrary( L"iphlpapi.dll" );

    if ( !pIpHlpApi->hInstance )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to load iphlpapi with %d.", GetLastError()));
        goto Exit;
    }

    pIpHlpApi->pfnGetBestInterface = (PFNGETBESTINTERFACE) GetProcAddress( pIpHlpApi->hInstance, "GetBestInterface" );

    if ( !pIpHlpApi->pfnGetBestInterface )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to find GetBestInterface with %d.", GetLastError()));
        goto Exit;
    }

    pIpHlpApi->pfnGetIfEntry = (PFNGETIFENTRY) GetProcAddress (pIpHlpApi->hInstance, "GetIfEntry" );

    if ( !pIpHlpApi->pfnGetIfEntry )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to find GetIfEntry with %d.", GetLastError()));
        goto Exit;
    }

    pIpHlpApi->pfnGetAdapterIndex = (PFNGETADAPTERINDEX) GetProcAddress (pIpHlpApi->hInstance, "GetAdapterIndex" );

    if ( !pIpHlpApi->pfnGetAdapterIndex )
    {
        DebugMsg((DM_WARNING, L"LoadIpHlpApi:  Failed to find GetAdapterIndex with %d.", GetLastError()));
        goto Exit;
    }

    bResult = true;
Exit:

    if ( !bResult )
    {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);

        ev.AddArg( L"iphlpapi.dll" );
        ev.AddArgWin32Error( GetLastError() );
        ev.Report();

        if ( pIpHlpApi->hInstance )
        {
            FreeLibrary( pIpHlpApi->hInstance );
        }
        ZeroMemory( pIpHlpApi, sizeof( IPHLPAPI_API ) );
        pIpHlpApi = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pIpHlpApi;
}

//*************************************************************
//
//  Loadws2_32Api()
//
//  Purpose:    Loads ws2_32.dll
//
//  Parameters: none
//
//  Return:     pointer to WS2_32_API
//
//*************************************************************

WS2_32_API * Loadws2_32Api()
{
    BOOL bResult = FALSE;
    WS2_32_API *pws2_32Api = &g_ws2_32Api;

    if (InitializeApiDLLsCritSec() != ERROR_SUCCESS)
        return NULL;
    EnterCriticalSection( g_ApiDLLCritSec );

    if ( pws2_32Api->hInstance ) {
        //
        // module already loaded and initialized
        //
        LeaveCriticalSection( g_ApiDLLCritSec );
        return pws2_32Api;
    }

    pws2_32Api->hInstance = LoadLibrary (TEXT("ws2_32.dll"));

    if (!pws2_32Api->hInstance) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to load ws2_32.dll with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSALookupServiceBegin = (PFNWSALOOKUPSERVICEBEGIN) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSALookupServiceBeginW");
    if (!pws2_32Api->pfnWSALookupServiceBegin) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSALookupServiceBegin with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSALookupServiceNext = (PFNWSALOOKUPSERVICENEXT) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSALookupServiceNextW");
    if (!pws2_32Api->pfnWSALookupServiceNext) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSALookupServiceNext with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSALookupServiceEnd = (PFNWSALOOKUPSERVICEEND) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSALookupServiceEnd");
    if (!pws2_32Api->pfnWSALookupServiceEnd) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSALookupServiceEnd with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSAStartup = (PFNWSASTARTUP) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSAStartup");
    if (!pws2_32Api->pfnWSAStartup) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSAStartup with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSACleanup = (PFNWSACLEANUP) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSACleanup");
    if (!pws2_32Api->pfnWSACleanup) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSACleanup with %d."),
                 GetLastError()));
        goto Exit;
    }

    pws2_32Api->pfnWSAGetLastError = (PFNWSAGETLASTERROR) GetProcAddress (pws2_32Api->hInstance,
                                                                  "WSAGetLastError");
    if (!pws2_32Api->pfnWSAGetLastError) {
        DebugMsg((DM_WARNING, TEXT("Loadws2_32Api:  Failed to find WSAGetLastError with %d."),
                 GetLastError()));
        goto Exit;
    }

    //
    // Success
    //

    bResult = TRUE;

Exit:

    if (!bResult) {
        CEvents ev(TRUE, EVENT_LOAD_DLL_FAILED);
        ev.AddArg(TEXT("ws2_32.dll")); ev.AddArgWin32Error(GetLastError()); ev.Report();

        if ( pws2_32Api->hInstance ) {
            FreeLibrary( pws2_32Api->hInstance );
        }

        ZeroMemory( pws2_32Api, sizeof( WS2_32_API ) );
        pws2_32Api = 0;
    }

    LeaveCriticalSection( g_ApiDLLCritSec );

    return pws2_32Api;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\dllload.h ===
//*************************************************************
//  File name: dllload.h
//
//  Description:   DLL loading function proto-types
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999
//  All rights reserved
//
//*************************************************************

void InitializeAPIs( void );
void CloseApiDLLsCritSec( void );

//
// NETAPI32 functions
//

typedef DWORD  (WINAPI * PFNDSGETDCNAMEA)(LPCSTR ComputerName,
                                  LPCSTR DomainName,
                                  GUID *DomainGuid,
                                  LPCSTR SiteName,
                                  ULONG Flags,
                                  PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo);

typedef DWORD (WINAPI * PFNDSGETDCNAMEW) (LPCWSTR ComputerName,
                                  LPCWSTR DomainName,
                                  GUID *DomainGuid,
                                  LPCWSTR SiteName,
                                  ULONG Flags,
                                  PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo);

typedef DWORD (WINAPI * PFNDSGETSITENAMEA)(IN LPCSTR ComputerName OPTIONAL,
                                           OUT LPSTR *SiteName);

typedef DWORD (WINAPI * PFNDSGETSITENAMEW)(IN LPCWSTR ComputerName OPTIONAL,
                                           OUT LPWSTR *SiteName);

typedef DWORD (WINAPI * PFNDSROLEGETPRIMARYDOMAININFORMATION)(
                                  IN LPCWSTR lpServer OPTIONAL,
                                  IN DSROLE_PRIMARY_DOMAIN_INFO_LEVEL InfoLevel,
                                  OUT PBYTE *Buffer );

typedef VOID (WINAPI * PFNDSROLEFREEMEMORY)(IN PVOID Buffer);

typedef DWORD (*PFNNETAPIBUFFERFREE)(LPVOID Buffer);

typedef DWORD (*PFNNETUSERGETGROUPS)(
    LPCWSTR    servername,
    LPCWSTR    username,
    DWORD     level,
    LPBYTE    *bufptr,
    DWORD     prefmaxlen,
    LPDWORD   entriesread,
    LPDWORD   totalentries
    );

typedef DWORD (*PFNNETUSERGETINFO) (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );


#ifdef UNICODE
#define PFNDSGETDCNAME            PFNDSGETDCNAMEW
#define PFNDSGETSITENAME          PFNDSGETSITENAMEW
#else
#define PFNDSGETDCNAME            PFNDSGETDCNAMEA
#define PFNDSGETSITENAME          PFNDSGETSITENAMEA
#endif

typedef struct _NETAPI32_API {
    HINSTANCE                hInstance;
    PFNDSGETDCNAME           pfnDsGetDcName;
    PFNDSGETSITENAME         pfnDsGetSiteName;
    PFNDSROLEGETPRIMARYDOMAININFORMATION pfnDsRoleGetPrimaryDomainInformation;
    PFNDSROLEFREEMEMORY      pfnDsRoleFreeMemory;
    PFNNETAPIBUFFERFREE      pfnNetApiBufferFree;
    PFNNETUSERGETGROUPS      pfnNetUserGetGroups;
    PFNNETUSERGETINFO        pfnNetUserGetInfo;
} NETAPI32_API, *PNETAPI32_API;


PNETAPI32_API LoadNetAPI32 ();



//
// SECUR32 functions
//


typedef BOOLEAN (*PFNGETUSERNAMEEXA)(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNGETUSERNAMEEXW)(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNGETCOMPUTEROBJECTNAMEA)(
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNGETCOMPUTEROBJECTNAMEW)(
    EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer,
    PULONG nSize
    );

typedef BOOLEAN (*PFNTRANSLATENAMEA)(
    IN LPCSTR                lpAccountName,
    IN EXTENDED_NAME_FORMAT  AccountNameFormat,
    IN EXTENDED_NAME_FORMAT  DesiredNameFormat,
    IN LPSTR                 lpTranslatedName,
    IN PULONG                nSize
    );

typedef BOOLEAN (*PFNTRANSLATENAMEW)(
    IN LPCWSTR              lpAccountName,
    IN EXTENDED_NAME_FORMAT AccountNameFormat,
    IN EXTENDED_NAME_FORMAT DesiredNameFormat,
    IN LPWSTR               lpTranslatedName,
    IN PULONG               nSize
    );


#ifdef UNICODE
#define PFNGETUSERNAMEEX          PFNGETUSERNAMEEXW
#define PFNGETCOMPUTEROBJECTNAME  PFNGETCOMPUTEROBJECTNAMEW
#define PFNTRANSLATENAME          PFNTRANSLATENAMEW
#else
#define PFNGETUSERNAMEEX          PFNGETUSERNAMEEXA
#define PFNGETCOMPUTEROBJECTNAME  PFNGETCOMPUTEROBJECTNAMEA
#define PFNTRANSLATENAME          PFNTRANSLATENAMEA
#endif


typedef struct _SECUR32_API {
    HINSTANCE                       hInstance;
    PFNGETUSERNAMEEX                pfnGetUserNameEx;
    PFNGETCOMPUTEROBJECTNAME        pfnGetComputerObjectName;
    PFNTRANSLATENAME                pfnTranslateName;
    ACCEPT_SECURITY_CONTEXT_FN      pfnAcceptSecurityContext;
    ACQUIRE_CREDENTIALS_HANDLE_FN   pfnAcquireCredentialsHandle;
    DELETE_SECURITY_CONTEXT_FN      pfnDeleteSecurityContext;
    FREE_CONTEXT_BUFFER_FN          pfnFreeContextBuffer;
    FREE_CREDENTIALS_HANDLE_FN      pfnFreeCredentialsHandle;
    INITIALIZE_SECURITY_CONTEXT_FN  pfnInitializeSecurityContext;
    QUERY_SECURITY_CONTEXT_TOKEN_FN pfnQuerySecurityContextToken;
    QUERY_SECURITY_PACKAGE_INFO_FN  pfnQuerySecurityPackageInfo;

} SECUR32_API, *PSECUR32_API;


PSECUR32_API LoadSecur32 ();



//
// WLDAP32 functions
//

typedef LDAP * (LDAPAPI * PFNLDAP_OPENW)( PWCHAR HostName, ULONG PortNumber );
typedef LDAP * (LDAPAPI * PFNLDAP_OPENA)( PCHAR HostName, ULONG PortNumber );

typedef LDAP * (LDAPAPI * PFNLDAP_INITW)( PWCHAR HostName, ULONG PortNumber );
typedef LDAP * (LDAPAPI * PFNLDAP_INITA)( PCHAR HostName, ULONG PortNumber );

typedef ULONG (LDAPAPI * PFNLDAP_BIND_SW)( LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method );
typedef ULONG (LDAPAPI * PFNLDAP_BIND_SA)( LDAP *ld, PCHAR dn, PCHAR cred, ULONG method );

typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_SW)(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res
    );
typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_SA)(
        LDAP            *ld,
        PCHAR           base,
        ULONG           scope,
        PCHAR           filter,
        PCHAR           attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res
    );

typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_EXT_SW)(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );

typedef ULONG (LDAPAPI * PFNLDAP_SEARCH_EXT_SA)(
        LDAP            *ld,
        PCHAR           base,
        ULONG           scope,
        PCHAR           filter,
        PCHAR           attrs[],
        ULONG           attrsonly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );

typedef PWCHAR * (LDAPAPI * PFNLDAP_GET_VALUESW)(
        LDAP            *ld,
        LDAPMessage     *entry,
        PWCHAR          attr
        );
typedef PCHAR * (LDAPAPI * PFNLDAP_GET_VALUESA)(
        LDAP            *ld,
        LDAPMessage     *entry,
        PCHAR           attr
        );

typedef ULONG (LDAPAPI * PFNLDAP_VALUE_FREEW)( PWCHAR *vals );
typedef ULONG (LDAPAPI * PFNLDAP_VALUE_FREEA)( PCHAR *vals );


typedef struct berval ** (LDAPAPI * PFNLDAP_GET_VALUES_LENW)(
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PWCHAR          attr
    );
typedef struct berval ** (LDAPAPI * PFNLDAP_GET_VALUES_LENA) (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           attr
    );

typedef ULONG (LDAPAPI * PFNLDAP_VALUE_FREE_LEN)( struct berval **vals );

typedef ULONG (LDAPAPI * PFNLDAP_MSGFREE)( LDAPMessage *res );

typedef ULONG (LDAPAPI * PFNLDAP_UNBIND)( LDAP *ld );
typedef ULONG (LDAPAPI * PFNLDAPGETLASTERROR)( VOID );
typedef PWCHAR (LDAPAPI * PFNLDAP_ERR2STRINGW)( ULONG );
typedef PCHAR (LDAPAPI * PFNLDAP_ERR2STRINGA)( ULONG );

typedef LDAPMessage * (LDAPAPI * PFNLDAP_FIRST_ENTRY)( LDAP *ld, LDAPMessage *entry );
typedef LDAPMessage * (LDAPAPI * PFNLDAP_NEXT_ENTRY)( LDAP *ld, LDAPMessage *entry );

typedef PWCHAR (LDAPAPI * PFNLDAP_GET_DNW)( LDAP *ld, LDAPMessage *entry );
typedef PCHAR  (LDAPAPI * PFNLDAP_GET_DNA)( LDAP *ld, LDAPMessage *entry );

typedef ULONG (LDAPAPI *PFNLDAP_SET_OPTION)( LDAP *ld, int option, void *invalue );
typedef ULONG (LDAPAPI *PFNLDAP_SET_OPTIONW)( LDAP *ld, int option, void *invalue );

typedef VOID (LDAPAPI * PFNLDAP_MEMFREEW)( PWCHAR Block );
typedef VOID (LDAPAPI * PFNLDAP_MEMFREEA)( PCHAR Block );

typedef ULONG (LDAPAPI * PFNLDAP_CONNECT)( LDAP *ld, struct l_timeval  *timeout );

typedef ULONG (LDAPAPI * PFNLDAPMAPERRORTOWIN32)( ULONG LdapError );

//
// WNet functions
//

typedef DWORD (*PFNWNETGETCONNECTION)(LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength);
typedef DWORD (*PFNWNETGETRESOURCEINFORMATION)(LPNETRESOURCE lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPTSTR *lplpSystem);

//
// msi functions
//

typedef UINT (*PFNMSINOTIFYSIDCHANGE)(LPCTSTR pOldSid, LPCTSTR pNewSid);
typedef UINT (*PFNMSIDELETEUSERDATA)(LPCTSTR pSid, LPCTSTR szComputerName, LPVOID pReserved);


#ifdef UNICODE
#define PFNLDAP_OPEN              PFNLDAP_OPENW
#define PFNLDAP_INIT              PFNLDAP_INITW
#define PFNLDAP_BIND_S            PFNLDAP_BIND_SW
#define PFNLDAP_SEARCH_S          PFNLDAP_SEARCH_SW
#define PFNLDAP_SEARCH_EXT_S      PFNLDAP_SEARCH_EXT_SW
#define PFNLDAP_GET_VALUES        PFNLDAP_GET_VALUESW
#define PFNLDAP_VALUE_FREE        PFNLDAP_VALUE_FREEW
#define PFNLDAP_GET_VALUES_LEN    PFNLDAP_GET_VALUES_LENW
#define PFNLDAP_GET_DN            PFNLDAP_GET_DNW
#define PFNLDAP_MEMFREE           PFNLDAP_MEMFREEW
#define PFNLDAP_SET_OPTION        PFNLDAP_SET_OPTIONW
#define PFNLDAP_ERR2STRING        PFNLDAP_ERR2STRINGW
#else
#define PFNLDAP_OPEN              PFNLDAP_OPENA
#define PFNLDAP_INIT              PFNLDAP_INITA
#define PFNLDAP_BIND_S            PFNLDAP_BIND_SA
#define PFNLDAP_SEARCH_S          PFNLDAP_SEARCH_SA
#define PFNLDAP_SEARCH_EXT_S      PFNLDAP_SEARCH_EXT_SA
#define PFNLDAP_GET_VALUES        PFNLDAP_GET_VALUESA
#define PFNLDAP_VALUE_FREE        PFNLDAP_VALUE_FREEA
#define PFNLDAP_GET_VALUES_LEN    PFNLDAP_GET_VALUES_LENA
#define PFNLDAP_GET_DN            PFNLDAP_GET_DNA
#define PFNLDAP_MEMFREE           PFNLDAP_MEMFREEA
#define PFNLDAP_ERR2STRING        PFNLDAP_ERR2STRINGA
#endif

typedef struct _LDAP_API {
    HINSTANCE                hInstance;
    PFNLDAP_OPEN             pfnldap_open;
    PFNLDAP_INIT             pfnldap_init;
    PFNLDAP_CONNECT          pfnldap_connect;
    PFNLDAP_BIND_S           pfnldap_bind_s;
    PFNLDAP_SEARCH_S         pfnldap_search_s;
    PFNLDAP_SEARCH_EXT_S     pfnldap_search_ext_s;
    PFNLDAP_GET_VALUES       pfnldap_get_values;
    PFNLDAP_VALUE_FREE       pfnldap_value_free;
    PFNLDAP_GET_VALUES_LEN   pfnldap_get_values_len;
    PFNLDAP_VALUE_FREE_LEN   pfnldap_value_free_len;
    PFNLDAP_MSGFREE          pfnldap_msgfree;
    PFNLDAP_UNBIND           pfnldap_unbind;
    PFNLDAPGETLASTERROR      pfnLdapGetLastError;
    PFNLDAP_FIRST_ENTRY      pfnldap_first_entry;
    PFNLDAP_NEXT_ENTRY       pfnldap_next_entry;
    PFNLDAP_GET_DN           pfnldap_get_dn;
    PFNLDAP_SET_OPTION       pfnldap_set_option;
    PFNLDAP_MEMFREE          pfnldap_memfree;
    PFNLDAPMAPERRORTOWIN32   pfnLdapMapErrorToWin32;
    PFNLDAP_ERR2STRING       pfnldap_err2string;
} LDAP_API, *PLDAP_API;

PLDAP_API LoadLDAP();

//
// ICMP functions
//
typedef HANDLE (*PFNICMPCREATEFILE)(VOID);
typedef BOOL (*PFNICMPCLOSEHANDLE)(HANDLE IcmpHandle);
typedef DWORD (*PFNICMPSENDECHO)(
               HANDLE                   IcmpHandle,
               IPAddr                   DestinationAddress,
               LPVOID                   RequestData,
               WORD                     RequestSize,
               PIP_OPTION_INFORMATION   RequestOptions,
               LPVOID                   ReplyBuffer,
               DWORD                    ReplySize,
               DWORD                    Timeout
               );


typedef struct _ICMP_API {
    HINSTANCE                   hInstance;
    PFNICMPCREATEFILE           pfnIcmpCreateFile;
    PFNICMPCLOSEHANDLE          pfnIcmpCloseHandle;
    PFNICMPSENDECHO             pfnIcmpSendEcho;
} ICMP_API, *PICMP_API;


DWORD LoadIcmp (PICMP_API *);



//
// WSOCK32 functions
//


typedef struct _WSOCK32_API {
    HINSTANCE                   hInstance;
    LPFN_INET_ADDR              pfninet_addr;
    LPFN_GETHOSTBYNAME          pfngethostbyname;
} WSOCK32_API, *PWSOCK32_API;


PWSOCK32_API LoadWSock32 ();


//
// DSAPI functions
//

typedef DWORD (WINAPI *PFN_DSCRACKNAMESW)( HANDLE  hDS,
                                           DS_NAME_FLAGS flags,
                                           DS_NAME_FORMAT formatOffered,
                                           DS_NAME_FORMAT formatDesired,
                                           DWORD cNames,
                                           const LPCWSTR *rpNames,
                                           PDS_NAME_RESULTW *ppResult);

typedef DWORD (WINAPI *PFN_DSCRACKNAMESA)( HANDLE  hDS,
                                           DS_NAME_FLAGS flags,
                                           DS_NAME_FORMAT formatOffered,
                                           DS_NAME_FORMAT formatDesired,
                                           DWORD cNames,
                                           const LPCSTR *rpNames,
                                           PDS_NAME_RESULTA *ppResult);

typedef void (WINAPI *PFN_DSFREENAMERESULTW)( DS_NAME_RESULTW *pResult);

typedef void (WINAPI *PFN_DSFREENAMERESULTA)( DS_NAME_RESULTA *pResult);


#ifdef UNICODE
#define PFN_DSCRACKNAMES          PFN_DSCRACKNAMESW
#define PFN_DSFREENAMERESULT      PFN_DSFREENAMERESULTW
#else
#define PFN_DSCRACKNAMES          PFN_DSCRACKNAMESA
#define PFN_DSFREENAMERESULT      PFN_DSFREENAMERESULTA
#endif

typedef struct _DS_API {
    HINSTANCE                   hInstance;
    PFN_DSCRACKNAMES            pfnDsCrackNames;
    PFN_DSFREENAMERESULT        pfnDsFreeNameResult;
} DS_API, *PDS_API;


PDS_API LoadDSApi();

//
// Ole32 functions
//

typedef HRESULT (*PFNCOCREATEINSTANCE)(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                 DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

typedef HRESULT (*PFNCOINITIALIZE)(LPVOID pvReserved);
typedef HRESULT (*PFNCOINITIALIZEEX)(LPVOID pvReserved, DWORD dwCoInit);
typedef VOID    (*PFNCOUNINITIALIZE)(VOID);

typedef HRESULT (*PFNCOCREATEGUID)(GUID *pGuid );

typedef VOID (*PFNINITCOMMONCONTROLS)(VOID);

typedef struct _OLE32_API {
    HINSTANCE                   hInstance;
    PFNCOCREATEINSTANCE         pfnCoCreateInstance;
    PFNCOINITIALIZEEX           pfnCoInitializeEx;
    PFNCOUNINITIALIZE           pfnCoUnInitialize;
    PFNCOCREATEGUID             pfnCoCreateGuid;
} OLE32_API, *POLE32_API;

POLE32_API LoadOle32Api();

//
// Shell32 functions
//

typedef VOID (*PFNSHCHANGENOTIFY)(LONG wEventId, UINT uFlags,
                                  LPCVOID dwItem1, LPCVOID dwItem2);

typedef BOOL (*PFNSHGETSPECIALFOLDERPATHA)(HWND hwnd, LPSTR lpszPath,
                                           int csidl, BOOL fCreate);
typedef BOOL (*PFNSHGETSPECIALFOLDERPATHW)(HWND hwnd, LPWSTR lpszPath,
                                           int csidl, BOOL fCreate);

typedef HRESULT (*PFNSHGETFOLDERPATHA)(HWND hwnd, int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPSTR pszPath);

typedef HRESULT (*PFNSHGETFOLDERPATHW)(HWND hwnd, int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPWSTR pszPath);

typedef HRESULT (*PFNSHSETFOLDERPATHA)(int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPSTR pszPath);

typedef HRESULT (*PFNSHSETFOLDERPATHW)(int csidl, HANDLE hToken,
                                       DWORD dwFlags, LPWSTR pszPath);

typedef HRESULT (*PFNSHSETLOCALIZEDNAME)(LPWSTR pszPath,
                                         LPCWSTR pszResModule, int idsRes);

#ifdef UNICODE
#define PFNSHGETSPECIALFOLDERPATH PFNSHGETSPECIALFOLDERPATHW
#define PFNSHGETFOLDERPATH        PFNSHGETFOLDERPATHW
#define PFNSHSETFOLDERPATH        PFNSHSETFOLDERPATHW
#else
#define PFNSHGETSPECIALFOLDERPATH PFNSHGETSPECIALFOLDERPATHA
#define PFNSHGETFOLDERPATH        PFNSHGETFOLDERPATHA
#define PFNSHSETFOLDERPATH        PFNSHSETFOLDERPATHA
#endif

#define SHSetFolderA_Ord        231
#define SHSetFolderW_Ord        232

typedef struct _SHELL32_API {
    HINSTANCE                   hInstance;
    PFNSHGETSPECIALFOLDERPATH   pfnShGetSpecialFolderPath;
    PFNSHGETFOLDERPATH          pfnShGetFolderPath;
    PFNSHSETFOLDERPATH          pfnShSetFolderPath;
    PFNSHCHANGENOTIFY           pfnShChangeNotify;
    PFNSHSETLOCALIZEDNAME       pfnShSetLocalizedName;
} SHELL32_API, *PSHELL32_API;

DWORD LoadShell32Api( PSHELL32_API * );

//
// shlwapi functions
//

typedef LPSTR  (*PFNPATHGETARGSA)(LPCSTR pszPath);
typedef LPWSTR (*PFNPATHGETARGSW)(LPCWSTR pszPath);

typedef VOID   (*PFNPATHUNQUOTESPACESA)(LPSTR lpsz);
typedef VOID   (*PFNPATHUNQUOTESPACESW)(LPWSTR lpsz);

#ifdef UNICODE
#define PFNPATHGETARGS            PFNPATHGETARGSW
#define PFNPATHUNQUOTESPACES      PFNPATHUNQUOTESPACESW
#else
#define PFNPATHGETARGS            PFNPATHGETARGSA
#define PFNPATHUNQUOTESPACES      PFNPATHUNQUOTESPACESA
#endif

typedef struct _SHLWAPI_API {
    HINSTANCE                   hInstance;
    PFNPATHGETARGS              pfnPathGetArgs;
    PFNPATHUNQUOTESPACES        pfnPathUnquoteSpaces;
} SHLWAPI_API, *PSHLWAPI_API;

PSHLWAPI_API LoadShlwapiApi();

//
// Gptext.dll functions
//

typedef BOOL (*PFNPARSEADMFILE)( WCHAR *pwszAdmFile, BOOL bUser, void **ppAdmHandle );
typedef BOOL (*PFNFREEADMDATA)( void *pAdmHandle );
typedef DWORD (*PFNSCRREGGPOLISTTOWBEM)( LPWSTR szSID, IWbemServices*  pServices );

typedef struct _GPTEXT_API {
    HINSTANCE          hInstance;
    PFNSCRREGGPOLISTTOWBEM pfnScrRegGPOListToWbem;
} GPTEXT_API;

GPTEXT_API *LoadGpTextApi();


//
// iphlpapi.dll functions
//

typedef DWORD (WINAPI *PFNGETBESTINTERFACE)(IPAddr  dwDestAddr, PDWORD  pdwBestIfIndex);
typedef DWORD (WINAPI *PFNGETIFENTRY)(PMIB_IFROW   pIfRow);
typedef DWORD (WINAPI *PFNGETADAPTERINDEX)(LPWSTR, PULONG);

typedef struct _IPHLPAPI_API
{
    HINSTANCE           hInstance;
    PFNGETBESTINTERFACE pfnGetBestInterface;
    PFNGETIFENTRY       pfnGetIfEntry;
    PFNGETADAPTERINDEX  pfnGetAdapterIndex;
} IPHLPAPI_API, *PIPHLPAPI_API;

PIPHLPAPI_API LoadIpHlpApi();

//
// ws2_32.dll functions
//

typedef INT (WINAPI *PFNWSALOOKUPSERVICEBEGIN)( LPWSAQUERYSET, DWORD, LPHANDLE );
typedef INT (WINAPI *PFNWSALOOKUPSERVICENEXT)( HANDLE, DWORD, LPDWORD, LPWSAQUERYSET );
typedef INT (WINAPI *PFNWSALOOKUPSERVICEEND)( HANDLE );
typedef INT (WINAPI *PFNWSASTARTUP)( WORD, LPWSADATA );
typedef INT (WINAPI *PFNWSACLEANUP)();
typedef INT (WINAPI *PFNWSAGETLASTERROR)();

typedef struct _WS2_32_API
{
    HINSTANCE                   hInstance;
    PFNWSALOOKUPSERVICEBEGIN    pfnWSALookupServiceBegin;
    PFNWSALOOKUPSERVICENEXT     pfnWSALookupServiceNext;
    PFNWSALOOKUPSERVICEEND      pfnWSALookupServiceEnd;
    PFNWSASTARTUP               pfnWSAStartup;
    PFNWSACLEANUP               pfnWSACleanup;
    PFNWSAGETLASTERROR          pfnWSAGetLastError;
} WS2_32_API, *PWS2_32_API;

PWS2_32_API Loadws2_32Api();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************



//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

extern DWORD dwDebugLevel;
extern DWORD dwRsopLoggingLevel;  // Rsop logging setting


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
// To avoid certain unexpected problems DebugMsg is changed to this form.
// This will prevent compilation of the construct like "if (!test) DebugMsg(x); else ..."
// unless DebugMsg(x) is enclosed under curly braces.
//

#define DebugMsg(x) { if (dwDebugLevel != DL_NONE) { _DebugMsg x ; } }


//
// Debug function proto-types
//


void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);


#define SETUP_LOAD    1
#define WINLOGON_LOAD 2
void InitDebugSupport( DWORD dwLoadFlags );
HRESULT DeletePreviousLogFiles();


#if DBG

#define DmAssert(x) if (!(x)) \
                        _DebugMsg(DM_ASSERT,TEXT("Userenv.dll assertion ") TEXT(#x) TEXT(" failed\n"));

#else

#define DmAssert(x)

#endif // DBG

#if defined(__cplusplus)
extern "C"
#endif
BOOL RsopLoggingEnabled();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\locator.h ===
//***********************************************

//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  WMI interface class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include "windows.h"
#include "ole2.h"
#include "rsopdbg.h"
#include <initguid.h>
#include <wbemcli.h>

class CLocator
{

public:

    CLocator()    {}

    IWbemLocator  * GetWbemLocator();
    IWbemServices * GetPolicyConnection();
    IWbemServices * GetUserConnection();
    IWbemServices * GetMachConnection();

private:

    XInterface<IWbemLocator>   m_xpWbemLocator;
    XInterface<IWbemServices>  m_xpPolicyConnection;
    XInterface<IWbemServices>  m_xpUserConnection;
    XInterface<IWbemServices>  m_xpMachConnection;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\events.cpp ===
//*************************************************************
//
//  Events.c    -   Routines to handle the event log
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include "profmgr.hxx"
#include "strsafe.h"

extern CUserProfile cUserProfileManager;

HANDLE  hEventLog = NULL;
TCHAR   EventSourceName[] = TEXT("Userenv");
INT_PTR APIENTRY ErrorDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL GetShareName(LPTSTR lpDir, LPTSTR *lppShare);

//*************************************************************
//
//  InitializeEvents()
//
//  Purpose:    Opens the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL InitializeEvents (void)
{
    //
    // Open the event source
    //

    hEventLog = RegisterEventSource(NULL, EventSourceName);

    if (hEventLog) {
        return TRUE;
    }

    DebugMsg((DM_WARNING, TEXT("InitializeEvents:  Could not open event log.  Error = %d"), GetLastError()));
    return FALSE;
}



//*************************************************************
//
//  Implementation of CEvents
//
//*************************************************************



//*************************************************************
//  CEvents::CEvents
//  Purpose:    Constructor
//
//  Parameters:
//      dwFlags - Error, Warning or informational
//      dwId    - Id of the eventlog msg
//
//
//  allocates a default sized array for the messages
//*************************************************************

#define DEF_ARG_SIZE 10

CEvents::CEvents(DWORD dwFlags, DWORD dwId ) :
                          m_cStrings(0), m_cAllocated(0), m_bInitialised(FALSE),
                          m_dwEventType(dwFlags), m_dwId(dwId), m_bFailed(TRUE)
{
    XLastError xe;
    //
    // Allocate a default size for the message
    //

    m_xlpStrings = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*DEF_ARG_SIZE);
    m_cAllocated = DEF_ARG_SIZE;
    if (!m_xlpStrings) {
        DebugMsg((DM_WARNING, TEXT("CEvent::CEvent  Cannot log event, failed to allocate memory, error %d"), GetLastError()));
        return;
    }


    //
    // Initialise eventlog if it is not already initialised
    //

    if (!hEventLog) {
        if (!InitializeEvents()) {
            DebugMsg((DM_WARNING, TEXT("CEvent::CEvent  Cannot log event, no handle")));
            return;
        }
    }

    m_bInitialised = TRUE;
    m_bFailed = FALSE;
}



//*************************************************************
//  CEvents::~CEvents()
//
//  Purpose:    Destructor
//
//  Parameters: void
//
//  frees the memory
//*************************************************************

CEvents::~CEvents()
{
    XLastError xe;
    for (int i = 0; i < m_cStrings; i++)
        if (m_xlpStrings[i])
            LocalFree(m_xlpStrings[i]);
}

//*************************************************************
//
//  CEvents::ReallocArgStrings
//
//  Purpose: Reallocates the buffer for storing arguments in case
//           the buffer runs out
//
//  Parameters: void
//
//  reallocates
//*************************************************************

BOOL CEvents::ReallocArgStrings()
{
    XPtrLF<LPTSTR>  aStringsNew;
    XLastError xe;


    //
    // first allocate a larger buffer
    //

    aStringsNew = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*(m_cAllocated+DEF_ARG_SIZE));

    if (!aStringsNew) {
        DebugMsg((DM_WARNING, TEXT("CEvent::ReallocArgStrings  Cannot add memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    //
    // copy the arguments
    //

    for (int i = 0; i < (m_cAllocated); i++) {
        aStringsNew[i] = m_xlpStrings[i];
    }

    m_xlpStrings = aStringsNew.Acquire();
    m_cAllocated+= DEF_ARG_SIZE;

    return TRUE;
}



//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArg(LPTSTR szArg)
{
    XLastError xe;
    DWORD   cchString;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }

    cchString = lstrlen(szArg)+1;
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchString);

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    StringCchCopy(m_xlpStrings[m_cStrings], cchString, szArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately truncated
//
//  Parameters: szArgFormat - sprintf format, e.g. %.500s
//
//*************************************************************

BOOL CEvents::AddArg(LPTSTR szArgFormat, LPTSTR szArg)
{
    const DWORD cchString = 200;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }


    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchString);

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }

    StringCchPrintf(m_xlpStrings[m_cStrings], cchString, szArgFormat, szArg);
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CEvents::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArg(DWORD dwArg)
{
    XLastError xe;
    const DWORD cchString = 20;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg(dw):  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }

    // 2^32 < 10^10
    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchString);

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArg  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    StringCchPrintf(m_xlpStrings[m_cStrings], cchString, TEXT("%d"), dwArg);
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CEvents::AddArgHex
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArgHex(DWORD dwArg)
{
    XLastError xe;
    const DWORD cchString = 20;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgHex:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }


    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * cchString);

    if (!m_xlpStrings[m_cStrings]) {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgHex  Cannot allocate memory, error = %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }


    StringCchPrintf(m_xlpStrings[m_cStrings], cchString, TEXT("%#x"), dwArg);
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CEvents::AddArgWin32Error
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArgWin32Error(DWORD dwArg)
{
    XLastError xe;

    if ((!m_bInitialised) || (m_bFailed))
    {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgWin32Error:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    if (m_cStrings == m_cAllocated)
    {
        if (!ReallocArgStrings())
            return FALSE;
    }

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                         0,
                         dwArg,
                         0,
                         (LPTSTR) &m_xlpStrings[m_cStrings],
                         1,
                         0 ) == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("CEvent::AddArgWin32Error: Cannot log event, FormatMessage failed, %d"), GetLastError()));
        m_bFailed = TRUE;
        return FALSE;
    }
    
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CEvents::AddArgLdapError
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CEvents::AddArgLdapError(DWORD dwArg)
{
    XLastError xe;
    PLDAP_API pLdap = LoadLDAP();

    if ( pLdap )
    {
        return AddArg( pLdap->pfnldap_err2string( dwArg ) );
    }
    else
    {
        return FALSE;
    }
}

//*************************************************************
//
//  CEvents::Report
//
//  Purpose: Actually collectes all the arguments and reports it to
//           the eventlog
//
//  Parameters: void
//
//*************************************************************

BOOL CEvents::Report()
{
    XLastError xe;
    XHandle xhToken;
    PSID pSid = NULL;
    WORD wType=0;
    BOOL bResult = TRUE;

    if ((!m_bInitialised) || (m_bFailed))
    {
        DebugMsg((DM_WARNING, TEXT("CEvents::Report:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    //
    // Get the caller's token
    //
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                          TRUE, &xhToken))
    {
         OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_DUPLICATE,
                          &xhToken);
    }

    //
    // Get the caller's sid
    //
    if (xhToken)
    {
        pSid = GetUserSid(xhToken);

        if (!pSid)
        {
            DebugMsg((DM_WARNING, TEXT("CEvents::Report:  Failed to get the sid")));
        }
    }

    if (m_dwEventType & EVENT_INFO_TYPE)
    {
        wType = EVENTLOG_INFORMATION_TYPE;
    }
    else if (m_dwEventType & EVENT_WARNING_TYPE)
    {
        wType = EVENTLOG_WARNING_TYPE;
    }
    else
    {
        wType = EVENTLOG_ERROR_TYPE;
    }

    if ( !ReportEvent(  hEventLog,
                        wType,
                        0,
                        m_dwId,
                        pSid,
                        m_cStrings,
                        0,
                        (LPCTSTR *)((LPTSTR *)m_xlpStrings),
                        0 ) )
    {
        DebugMsg((DM_WARNING,  TEXT("CEvents::Report: ReportEvent failed.  Error = %d"), GetLastError()));
        bResult = FALSE;
    }

    if (pSid)
    {
        DeleteUserSid(pSid);
    }

    return bResult;
}



LPTSTR CEvents::FormatString()
{
    XLastError xe;
    BOOL bResult = TRUE;
    LPTSTR szMsg=NULL;

    if ((!m_bInitialised) || (m_bFailed)) {
        DebugMsg((DM_WARNING, TEXT("CEvents::Report:  Cannot log event, not initialised or failed before")));
        return FALSE;
    }

    
    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                       FORMAT_MESSAGE_FROM_HMODULE | 
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       g_hDllInstance,
                       m_dwId,
                       0,
                       (LPTSTR)&szMsg,
                       0, // min number of chars
                       (va_list *)(LPTSTR *)(m_xlpStrings))) {
        
        DebugMsg((DM_WARNING,  TEXT("CEvents::FormatString: ReportEvent failed.  Error = %d"), GetLastError()));
        return NULL;
    }

    
    return szMsg;
}



//*************************************************************
//
//  LogEvent()
//
//  Purpose:    Logs an event to the event log
//
//  Parameters: dwFlags     -   Error, Warning or informational
//              idMsg       -   Message id
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/5/98      ericflo    Created
//
//*************************************************************

int LogEvent (DWORD dwFlags, UINT idMsg, ...)
{
    XLastError xe;
    TCHAR szMsg[MAX_PATH];
    LPTSTR lpErrorMsg;
    va_list marker;
    CEvents ev(dwFlags, EVENT_ERROR);
    DWORD cchErrorMsg;

    //
    // Load the message
    //

    if (idMsg != 0) {
        if (!LoadString (g_hDllInstance, idMsg, szMsg, ARRAYSIZE(szMsg))) {
            DebugMsg((DM_WARNING, TEXT("LogEvent:  LoadString failed.  Error = %d"), GetLastError()));
            return -1;
        }

    } else {
        StringCchCopy (szMsg, ARRAYSIZE(szMsg), TEXT("%s"));
    }


    //
    // Allocate space for the error message
    //

    cchErrorMsg = 4 * MAX_PATH + 100;
    lpErrorMsg = (LPTSTR) LocalAlloc (LPTR, cchErrorMsg * sizeof(TCHAR));

    if (!lpErrorMsg) {
        DebugMsg((DM_WARNING, TEXT("LogEvent:  LocalAlloc failed.  Error = %d"), GetLastError()));
        return -1;
    }


    //
    // Plug in the arguments
    //

    va_start(marker, idMsg);

    StringCchVPrintf(lpErrorMsg, cchErrorMsg, szMsg, marker);

    va_end(marker);

    //
    // Now add this string to the arg list
    //

    ev.AddArg(lpErrorMsg);


    //
    // report
    //

    ev.Report();

    LocalFree (lpErrorMsg);

    return 0;
}

//*************************************************************
//
//  ShutdownEvents()
//
//  Purpose:    Stops the event log
//
//  Parameters: void
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/17/95     ericflo    Created
//
//*************************************************************

BOOL ShutdownEvents (void)
{
    BOOL bRetVal = TRUE;

    if (hEventLog) {
        bRetVal = DeregisterEventSource(hEventLog);
        hEventLog = NULL;
    }

    return bRetVal;
}


//*************************************************************
//
//  ReportError()
//
//  Purpose:    Displays an error message to the user and
//              records it in the event log
//
//  Parameters: dwFlags     -   Flags. Also indicates event type.
//                              Default is Error.                   
//              dwCount     -   Number of string arguments
//              idMsg       -   Error message id
//              ...         -   String arguments
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   For EVENT_COPYERROR message we have to get the share 
//              name for the mapped drive.
//              Be careful in future, if we add a new error message with 
//              dir name in it.
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//              9/03/00     santanuc   Modified to work for client 
//
//*************************************************************


int ReportError (HANDLE hTokenUser, DWORD dwFlags, DWORD dwCount, UINT idMsg, ...)
{
    TCHAR            szMsg[MAX_PATH];
    LPTSTR           lpErrorMsg=NULL, szArg;
    va_list          marker;
    INT              iChars;
    BOOL             bImpersonated = FALSE;
    HANDLE           hOldToken;
    LPTSTR           szSidUser = NULL;
    DWORD            dwErr = ERROR_SUCCESS;
    handle_t         hIfProfileDialog;         // rpc explicit binding handle for IProfileDialog interface
    LPTSTR           lpRPCEndPoint = NULL;     // RPCEndPoint for IProfileDialog interface registered in client side
    RPC_ASYNC_STATE  AsyncHnd;                 // Async handle for making async rpc interface calls
    RPC_STATUS       status = RPC_S_OK;
    LPTSTR           lpShare = NULL;
   

    if (hTokenUser) {
        if (!ImpersonateUser(hTokenUser, &hOldToken)) {
            DebugMsg((DM_WARNING, TEXT("ReportError: ImpersonateUser failed with error %d."), GetLastError()));
        }
        else {
            bImpersonated = TRUE;
            DebugMsg((DM_WARNING, TEXT("ReportError: Impersonating user.")));
        }
    }
    
    CEvents ev(dwFlags, idMsg);
   
    //
    // Plug in the arguments
    //

    va_start(marker, idMsg);

    for (DWORD i = 0; i < dwCount; i++) {
        szArg = va_arg(marker, LPTSTR);

        //
        // Only EVENT_COPYERROR has first two parameters as dir name. So try to replace 
        // the mapped drive with correct share name
        //

        if (idMsg == EVENT_COPYERROR && i < 2 && GetShareName(szArg, &lpShare)) {
            ev.AddArg(lpShare);
            LocalFree(lpShare);
        }
        else {
            ev.AddArg(szArg);
        }
    }

    va_end(marker);

    

    if (!(dwFlags & PI_NOUI)) {

        DWORD dwDlgTimeOut = PROFILE_DLG_TIMEOUT;
        DWORD dwSize, dwType;
        LONG lResult;
        HKEY hKey;

        //
        // Find the dialog box timeout
        //

        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               WINLOGON_KEY,
                               0,
                               KEY_READ,
                               &hKey);

        if (lResult == ERROR_SUCCESS) {

            dwSize = sizeof(DWORD);
            RegQueryValueEx (hKey,
                             TEXT("ProfileDlgTimeOut"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwDlgTimeOut,
                             &dwSize);


            RegCloseKey (hKey);
        }


        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               SYSTEM_POLICIES_KEY,
                               0,
                               KEY_READ,
                               &hKey);

        if (lResult == ERROR_SUCCESS) {

            dwSize = sizeof(DWORD);
            RegQueryValueEx (hKey,
                             TEXT("ProfileDlgTimeOut"),
                             NULL,
                             &dwType,
                             (LPBYTE) &dwDlgTimeOut,
                             &dwSize);


            RegCloseKey (hKey);
        }


        lpErrorMsg = ev.FormatString();

        if (lpErrorMsg) {
            
            DebugMsg((DM_VERBOSE, TEXT("ReportError: Logging Error <%s> \n"), lpErrorMsg));

            //
            // Display the message
            //

            szSidUser = GetSidString(hTokenUser);
            if (szSidUser) {

                BYTE*   pbCookie = NULL;
                DWORD   cbCookie = 0;

                //
                // Get the registered interface explicit binding handle using RPCEndPoint
                //

                if (cUserProfileManager.IsConsoleWinlogon()) {

                    cUserProfileManager.GetRPCEndPointAndCookie(szSidUser, &lpRPCEndPoint, &pbCookie, &cbCookie);

                }
                if (lpRPCEndPoint && GetInterface(&hIfProfileDialog, lpRPCEndPoint)) {
                    DebugMsg((DM_VERBOSE, TEXT("ReportError: RPC End point %s"), lpRPCEndPoint));

                    status = RpcAsyncInitializeHandle(&AsyncHnd, sizeof(RPC_ASYNC_STATE));
                    if (status != RPC_S_OK) {
                        dwErr = status;
                        DebugMsg((DM_WARNING, TEXT("ReportError: RpcAsyncInitializeHandle failed. err = %d"), dwErr));
                    }
                    else {
                        AsyncHnd.UserInfo = NULL;                                    // App specific info, not req
                        AsyncHnd.NotificationType = RpcNotificationTypeEvent;        // Init the notification event
                        AsyncHnd.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                    
                        if (AsyncHnd.u.hEvent) {
                            RpcTryExcept {
                                cliErrorDialog(&AsyncHnd, hIfProfileDialog, dwDlgTimeOut, lpErrorMsg, pbCookie, cbCookie);
                                dwErr = RPC_S_OK;
                            }
                            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
                                dwErr = RpcExceptionCode();
                                DebugMsg((DM_WARNING, TEXT("ReportError: Calling ErrorDialog took exception. err = %d"), dwErr));
                            }
                            RpcEndExcept;

                            // In case of exception, the runtime will do the cleanup.
                            if (dwErr == RPC_S_OK) {
                                DebugMsg((DM_VERBOSE, TEXT("ReportError: waiting on rpc async event")));
                                if (WaitForSingleObject(AsyncHnd.u.hEvent, (dwDlgTimeOut + 10)*1000) == WAIT_OBJECT_0) {
                                    status = RpcAsyncCompleteCall(&AsyncHnd, (PVOID)&dwErr);
                                }
                                else {
                                    DebugMsg((DM_WARNING, TEXT("ReportError: Timeout occurs. Client not responding")));
                                    // Abortive cancle, should always succeed
                                    status = RpcAsyncCancelCall(&AsyncHnd, TRUE);
                                    DmAssert(status == RPC_S_OK); 
                                    // Now wait for RPC to take notice of the force abort
                                    if (WaitForSingleObject(AsyncHnd.u.hEvent, INFINITE) != WAIT_OBJECT_0) {
                                        DmAssert(FALSE && "WaitForSingleObject : Rpc async handle not signaled");
                                    }
                                    // Complete the Rpc aborted call.
                                    status = RpcAsyncCompleteCall(&AsyncHnd, (PVOID)&dwErr);
                                }
                                DebugMsg((DM_VERBOSE, TEXT("RpcAsyncCompleteCall finished, status = %d"), status));
                            }

                            // Release the resource
                            CloseHandle(AsyncHnd.u.hEvent);
                        }
                        else {
                            dwErr = GetLastError();
                            DebugMsg((DM_VERBOSE, TEXT("ReportError: create event failed error %d"), dwErr));
                        }
                    }

                    if (dwErr != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("ReportError: fail to show message error %d"), GetLastError()));
                    }

                    ReleaseInterface(&hIfProfileDialog);  // Release the binding handle
                }
                DeleteSidString(szSidUser);
            }
            else {
                DebugMsg((DM_WARNING, TEXT("ReportError: Unable to get SID string from token.")));
            }

            if (!lpRPCEndPoint) {

                //
                // This can happen in two case :
                //     1. We are in console winlogon process.
                //     2. ReportError get called from some public api which we expose.
                //

                ErrorDialogEx(dwDlgTimeOut, lpErrorMsg);
            }
        }
    }


    //
    // Report the event to the eventlog
    //

    ev.Report();

    if (lpErrorMsg) 
        LocalFree (lpErrorMsg);

    if (bImpersonated)
        RevertToUser(&hOldToken);

    return 0;
}

//*************************************************************
//
//  ErrorDialogEx()
//
//  Purpose:    Call Dialog box procedure for displaying error message
//
//  Parameters: dwTimeOut - Timeout in secs
//              lpErrMsg  - Error Message
//
//  Return:     None
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/27/00    santanuc   Created
//
//*************************************************************
void ErrorDialogEx(DWORD dwTimeOut, LPTSTR lpErrMsg)
{
    ERRORSTRUCT es;

    es.dwTimeOut = dwTimeOut;
    es.lpErrorText = lpErrMsg;

    DebugMsg((DM_VERBOSE, TEXT("ErrorDialogEx: Calling DialogBoxParam")));
    DialogBoxParam (g_hDllInstance, MAKEINTRESOURCE(IDD_ERROR),
                    NULL, ErrorDlgProc, (LPARAM)&es);
}

//*************************************************************
//
//  ErrorDlgProc()
//
//  Purpose:    Dialog box procedure for the error dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              3/22/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY ErrorDlgProc (HWND hDlg, UINT uMsg,
                            WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuffer[10];
    static DWORD dwErrorTime;

    switch (uMsg) {

        case WM_INITDIALOG:
           {
           DebugMsg((DM_VERBOSE, TEXT("ErrorDlgProc:: DialogBoxParam")));
           LPERRORSTRUCT lpES = (LPERRORSTRUCT) lParam;

           SetForegroundWindow(hDlg);
           CenterWindow (hDlg);
           SetDlgItemText (hDlg, IDC_ERRORTEXT, lpES->lpErrorText);

           dwErrorTime = lpES->dwTimeOut;

           if (dwErrorTime > 0) {
               StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), dwErrorTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);
               SetTimer (hDlg, 1, 1000, NULL);
           }
           return TRUE;
           }

        case WM_TIMER:

           if (dwErrorTime >= 1) {

               dwErrorTime--;
               StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%d"), dwErrorTime);
               SetDlgItemText (hDlg, IDC_TIMEOUT, szBuffer);

           } else {

               //
               // Time's up.  Dismiss the dialog.
               //

               PostMessage (hDlg, WM_COMMAND, IDOK, 0);
           }
           break;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {

              case IDOK:
                  if (HIWORD(wParam) == BN_KILLFOCUS) {
                      KillTimer (hDlg, 1);
                      ShowWindow(GetDlgItem(hDlg, IDC_TIMEOUT), SW_HIDE);
                      ShowWindow(GetDlgItem(hDlg, IDC_TIMETITLE), SW_HIDE);

                  } else if (HIWORD(wParam) == BN_CLICKED) {
                      KillTimer (hDlg, 1);
                      EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDCANCEL:
                  KillTimer (hDlg, 1);
                  EndDialog(hDlg, FALSE);
                  break;

              default:
                  break;

          }
          break;

    }

    return FALSE;
}


//*************************************************************
//
//  GetShareName()
//
//  Purpose:    Returns the complete share name by unmapping the 
//              drive letter in lpDir
//
//  Parameters: lpDir    -  Dir name to be unmapped
//              lppShare -  Expanded dir name with share
//
//  Return:     TRUE  : if success
//              FALSE : otherwise
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/29/00    santanuc   Created
//
//*************************************************************
BOOL GetShareName(LPTSTR lpDir, LPTSTR *lppShare)
{
    PFNWNETGETCONNECTION  pfnWNetGetConnection;
    HMODULE               hWNetLib = NULL;
    TCHAR                 szDrive[3];
    DWORD                 dwSize = 0, dwErr;
    BOOL                  bRetVal = FALSE;
    DWORD                 cchShare;

    if (lpDir[1] != TEXT(':')) {
        goto Exit;
    }

    if (!(hWNetLib = LoadLibrary(TEXT("mpr.dll")))) {
        DebugMsg((DM_WARNING, TEXT("GetShareName: LoadLibrary failed with %d"), GetLastError()));
        goto Exit;
    }
    pfnWNetGetConnection = (PFNWNETGETCONNECTION)GetProcAddress(hWNetLib, "WNetGetConnectionW");
    if (!pfnWNetGetConnection) {
        DebugMsg((DM_WARNING, TEXT("GetShareName: GetProcAddress failed with %d"), GetLastError()));
        goto Exit;
    }
        
    szDrive[0] = lpDir[0];
    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');

    // First get the size required to hold the share name
    dwErr = (*pfnWNetGetConnection)(szDrive, NULL, &dwSize);

    if (dwErr == ERROR_MORE_DATA) {
        dwSize += lstrlen(lpDir);  // Add the size for rest of the path name
        cchShare = dwSize;
        *lppShare = (LPTSTR)LocalAlloc(LPTR, cchShare * sizeof(TCHAR));
        if (!*lppShare) {
            DebugMsg((DM_WARNING, TEXT("GetShareName: Failed to alloc memory with %d"), GetLastError()));
            goto Exit;
        }
        dwErr = (*pfnWNetGetConnection)(szDrive, *lppShare, &dwSize);
        if (dwErr == NO_ERROR) {
            StringCchCat(*lppShare, cchShare, lpDir+2); // Add the rest of the path name
            bRetVal = TRUE;
            goto Exit;
        }
        else {
            DebugMsg((DM_WARNING, TEXT("GetShareName: WNetGetConnection returned error %d"), dwErr));
        }

        LocalFree(*lppShare);
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("GetShareName: WNetGetConnection initially returned error %d"), dwErr));
    }

Exit:

    if (hWNetLib) {
        FreeLibrary(hWNetLib);
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\sid.h ===
//*************************************************************
//
//  Header file for Sid.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#ifdef __cplusplus
extern "C" {
#endif

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);

#ifdef __cplusplus
}
#endif

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\events.h ===
//*************************************************************
//
//  Events.h    -   header file for events.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#ifdef __cplusplus
extern "C" {
#endif

// Events type
#define EVENT_ERROR_TYPE      0x00010000
#define EVENT_WARNING_TYPE    0x00020000
#define EVENT_INFO_TYPE       0x00040000


BOOL InitializeEvents (void);
int LogEvent (DWORD dwFlags, UINT idMsg, ...);
BOOL ShutdownEvents (void);
int ReportError (HANDLE hTokenUser, DWORD dwFlags, DWORD dwArgCount, UINT idMsg, ... );


#ifdef __cplusplus
}
#endif


#ifdef __cplusplus

#include "smartptr.h"

class CEvents
{
    private:
        DWORD           m_dwEventType;  // the kind of error to log
        DWORD           m_dwId;         // id of the msg
        XPtrLF<LPTSTR>  m_xlpStrings;   // Array to store arguments
        WORD            m_cStrings;     // Number of elements already in the array
        WORD            m_cAllocated;   // Number of elements allocated
        BOOL            m_bInitialised; // Initialised ?
        BOOL            m_bFailed;      // Failed in processing ?

        // Not implemented.
        CEvents(const CEvents& x);
        CEvents& operator=(const CEvents& x);


        BOOL ReallocArgStrings();


    public:
        CEvents(DWORD bError, DWORD dwId );
        BOOL AddArg(LPTSTR szArg);
        BOOL AddArg(LPTSTR szArgFormat, LPTSTR szArg );
        BOOL AddArg(DWORD dwArg);
        BOOL AddArgHex(DWORD dwArg);
        BOOL AddArgWin32Error(DWORD dwArg);
        BOOL AddArgLdapError(DWORD dwArg);
        BOOL Report();
        LPTSTR FormatString();
        ~CEvents();
};

typedef struct _ERRORSTRUCT {
    DWORD   dwTimeOut;
    LPTSTR  lpErrorText;
} ERRORSTRUCT, *LPERRORSTRUCT;


void ErrorDialogEx(DWORD dwTimeOut, LPTSTR lpErrMsg);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\locator.cpp ===
//*************************************************************
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 2000
//  All rights reserved
//
//  WMI interfae class
//
//  History:    10-Mar-00   SitaramR    Created
//
//*************************************************************

#include "uenv.h"
#include "locator.h"


extern CDebug CDbgCommon;

//*************************************************************
//
//  CLocator::GetWbemLocator
//
//  Purpose:    Returns the WbemLocator pointer
//
//*************************************************************

IWbemLocator *CLocator::GetWbemLocator()
{
    XLastError  xe;

    if ( m_xpWbemLocator == NULL ) {

        OLE32_API *pOle32Api = LoadOle32Api();
        if ( pOle32Api == NULL ) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                           TEXT("CLocator::GetWbemLocator: Load of ole32.dll failed") );
            xe = GetLastError();
            return NULL;
        }

        HRESULT hr = pOle32Api->pfnCoCreateInstance(CLSID_WbemLocator,
                                                    0,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IWbemLocator,
                                                    (LPVOID *) &m_xpWbemLocator);
        if(FAILED(hr)) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetWbemLocator: CoCreateInstance failed with 0x%x"), hr );
            xe = hr;
            return NULL;
        }
    }

    return m_xpWbemLocator;
}


//*************************************************************
//
//  CLocator::GetPolicyConnection
//
//  Purpose:    Returns the WbemServices ptr to root\policy
//
//*************************************************************

IWbemServices *CLocator::GetPolicyConnection()
{
    XLastError  xe;

    if ( m_xpPolicyConnection == NULL ) {

        IWbemLocator *pWbemLocator = GetWbemLocator();
        if ( pWbemLocator == NULL ) {
            xe = GetLastError();
            return NULL;
        }
										
        XBStr xbstrNamespace = L"\\\\.\\Root\\policy";

        if(!xbstrNamespace) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetPolicyConnection: Failed to allocate memory") );
            xe = GetLastError();
            return NULL;
        }

        HRESULT hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                                 NULL,
                                                 NULL,
                                                 0L,
                                                 0L,
                                                 NULL,
                                                 NULL,
                                                 &m_xpPolicyConnection);
        if(FAILED(hr)) {
             dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetPolicyConnection: ConnectServer failed with 0x%x"), hr );
            xe = hr;
            return NULL;
        }


        hr = CoSetProxyBlanket((IUnknown *)m_xpPolicyConnection, RPC_C_AUTHN_DEFAULT,
                               RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL, RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 
                               EOAC_DYNAMIC_CLOAKING /* | EOAC_NO_CUSTOM_MARSHAL */);

        if (FAILED(hr)) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                        TEXT("CLocator::GetPolicyConnection: CoSetProxyBlanket failed with 0x%x"), hr );
           xe = hr;
           m_xpPolicyConnection = NULL;
           return NULL;
        }
    }

    return m_xpPolicyConnection;
}



//*************************************************************
//
//  CLocator::GetUserConnection
//
//  Purpose:    Returns the WbemServices ptr to root\User
//
//*************************************************************

IWbemServices *CLocator::GetUserConnection()
{
    if ( m_xpUserConnection == NULL ) {

        IWbemLocator *pWbemLocator = GetWbemLocator();
        if ( pWbemLocator == NULL )
            return NULL;

        XBStr xbstrNamespace = L"root\\User";

        if(!xbstrNamespace) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetUserConnection: Failed to allocate memory") );
            return NULL;
        }

        HRESULT hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                                 NULL,
                                                 NULL,
                                                 0L,
                                                 0L,
                                                 NULL,
                                                 NULL,
                                                 &m_xpUserConnection);
        if(FAILED(hr)) {
             dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetUserConnection: ConnectServer failed with 0x%x"), hr );
            return NULL;
        }
    }

    return m_xpUserConnection;
}



//*************************************************************
//
//  CLocator::GetMachConnection
//
//  Purpose:    Returns the WbemServices ptr to root\Mach
//
//*************************************************************

IWbemServices *CLocator::GetMachConnection()
{
    if ( m_xpMachConnection == NULL ) {

        IWbemLocator *pWbemLocator = GetWbemLocator();
        if ( pWbemLocator == NULL )
            return NULL;

        XBStr xbstrNamespace = L"root\\Computer";

        if(!xbstrNamespace) {
            dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetMachConnection: Failed to allocate memory") );
            return NULL;
        }

        HRESULT hr = pWbemLocator->ConnectServer(xbstrNamespace,
                                                 NULL,
                                                 NULL,
                                                 0L,
                                                 0L,
                                                 NULL,
                                                 NULL,
                                                 &m_xpMachConnection);
        if(FAILED(hr)) {
             dbgCommon.Msg( DEBUG_MESSAGE_WARNING,
                         TEXT("CLocator::GetMachConnection: ConnectServer failed with 0x%x"), hr );
            return NULL;
        }
    }

    return m_xpMachConnection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\sid.c ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: GetUserSid returned NULL")));
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlUnicodeStringToAnsiString failed, status = 0x%x"),
                 status));
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                      BytesRequired));
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to query user info from user token, status = 0x%x"),
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: RtlCopySid Failed. status = %d"),
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}


//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//              02/25/2002 mingzhu  using ConvertSidStringToSid()
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    if (ConvertStringSidToSid(lpszSidStr, ppSid))
        return STATUS_SUCCESS;
    else
        return GetLastError();
}

//*************************************************************
//
//  GetDomainSidFromRid()
//
//  Purpose:    Given one domain sid, constructs another domain sid
//              by replacing the tail by the passed in Rid
//
//  Parameters: pSid            -   Given Domain Sid
//              dwRid           -   Domain Rid
//              ppNewSid        -   Pointer to the New Sid
//
//  Return:     ERROR_SUCCESS on Success
//              FALSE if an error occurs
//
//  Comments:
//      Sid returned must be freed using FreeSid.
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//
//*************************************************************

NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid)
{
    
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    // pointer to identifier authority
    BYTE      nSubAuthorityCount, i;                   // count of subauthorities
    DWORD     dwSubAuthority[8]={0,0,0,0,0,0,0,0};     // subauthority 
    PUCHAR    pSubAuthCount;
    DWORD    *pdwSubAuth;
    NTSTATUS  Status=ERROR_SUCCESS;
    
    DmAssert(IsValidSid(pSid));
    
    //
    // Will fail only if passed in sid is invalid and in the case 
    // the returned value is undefined. 
    //
    
    pIdentifierAuthority = RtlIdentifierAuthoritySid(pSid);
    
    //
    // get the count of subauthorities
    //

    pSubAuthCount = RtlSubAuthorityCountSid (pSid);
    
    if (!pSubAuthCount) {
        Status = ERROR_INVALID_SID;
        goto Exit;
    }
    
    nSubAuthorityCount = *pSubAuthCount;
    
    //
    // get each of the subauthorities
    //

    for (i = 0; i < (nSubAuthorityCount-1); i++) {
        pdwSubAuth = RtlSubAuthoritySid(pSid, i);
        
        if (!pdwSubAuth) {
            Status = ERROR_INVALID_SID;
            goto Exit;
        }
        
        dwSubAuthority[i] = *pdwSubAuth;
    }
    
    dwSubAuthority[i] = dwRid;

    //
    // Allocate a sid with these..
    //

    Status = RtlAllocateAndInitializeSid(
                pIdentifierAuthority,
                nSubAuthorityCount,
                dwSubAuthority[0],
                dwSubAuthority[1],
                dwSubAuthority[2],
                dwSubAuthority[3],
                dwSubAuthority[4],
                dwSubAuthority[5],
                dwSubAuthority[6],
                dwSubAuthority[7],
                ppNewSid
                );
    
Exit:

    // Sid, All Done
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\util.h ===
//*************************************************************
//
//  Header file for Util.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************


#define FreeProducedString(psz) if((psz) != NULL) {LocalFree(psz);} else
#define CCH_MAX_DEC 12         // Number of chars needed to hold 2^32 for IntToString

LPWSTR ProduceWFromA(LPCSTR pszA);
LPSTR ProduceAFromW(LPCWSTR pszW);
LPTSTR CheckSlash (LPTSTR lpDir);
LPTSTR CheckSlashEx(LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemain );
LPTSTR CheckSemicolon (LPTSTR lpDir);
BOOL Delnode (LPTSTR lpDir);
UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
UINT CreateNestedDirectoryEx(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, BOOL bInheritEncryption);
BOOL GetProfilesDirectoryEx(LPTSTR lpProfilesDir, LPDWORD lpcchSize, BOOL bExpand);
BOOL GetDefaultUserProfileDirectoryEx (LPTSTR lpProfileDir, LPDWORD lpcchSize, BOOL bExpand);
BOOL GetAllUsersProfileDirectoryEx (LPTSTR lpProfileDir, LPDWORD lpcchSize, BOOL bExpand);
int StringToInt(LPTSTR lpNum);
BOOL DeleteAllValues(HKEY hKey);
BOOL MakeFileSecure (LPTSTR lpFile, DWORD dwOtherSids);
BOOL GetSpecialFolderPath (INT csidl, LPTSTR lpPath);
BOOL GetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath);
BOOL SetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath);
void CenterWindow (HWND hwnd);
BOOL UnExpandSysRoot(LPCTSTR lpFile, LPTSTR lpResult, DWORD cchResult);
LPTSTR AllocAndExpandEnvironmentStrings(LPCTSTR lpszSrc);
void IntToString( INT i, LPTSTR sz);
BOOL IsUserAGuest(HANDLE hToken);
BOOL IsUserAnAdminMember(HANDLE hToken);
BOOL IsUserALocalSystemMember(HANDLE hToken);
BOOL IsUserAnInteractiveUser(HANDLE hToken);
DWORD CheckUserInMachineForest(HANDLE hUserToken, BOOL* bInThisForest);
BOOL MakeRegKeySecure(HANDLE hToken, HKEY hKeyRoot, LPTSTR lpKeyName);
BOOL FlushSpecialFolderCache (void);
BOOL CheckForVerbosePolicy (void);
int ExtractCSIDL(LPCTSTR pcszPath, LPTSTR* ppszUsualPath);
LPTSTR MyGetDomainDNSName (VOID);
LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat);
LPTSTR MyGetUserNameEx (EXTENDED_NAME_FORMAT  NameFormat);
LPTSTR MyGetComputerName (EXTENDED_NAME_FORMAT  NameFormat);
void StringToGuid( TCHAR *szValue, GUID *pGuid );
void GuidToString( const GUID *pGuid, TCHAR * szValue);
void GuidToStringEx( const GUID *pGuid, TCHAR * szValue, UINT cchValue);
BOOL ValidateGuid( TCHAR *szValue );
BOOL ValidateGuidPrefix( TCHAR *szValue );
INT CompareGuid( GUID *pGuid1, GUID *pGuid2 );
BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser);
BOOL RevertToUser (HANDLE *hUser);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
BOOL CreateSecureAdminDirectory (LPTSTR lpDirectory, DWORD dwOtherSids);
BOOL AddPowerUserAce (LPTSTR lpFile);
void ClosePingCritSec(void);
LPTSTR GetUserGuid(HANDLE hToken);
LPTSTR GetOldSidString(HANDLE hToken, LPTSTR lpKeyName);
BOOL SetOldSidString(HANDLE hToken, LPTSTR lpSidString, LPTSTR lpKeyName);
LPTSTR GetErrString(DWORD dwErr, LPTSTR szErr);
LONG RegRenameKey(HKEY hKeyRoot, LPTSTR lpSrcKey, LPTSTR lpDestKey);
BOOL IsNullGUID (GUID *pguid);
BOOL GetMachineRole (LPINT piRole);
BOOL IsUNCPath(LPCTSTR lpPath);
LPTSTR MakePathUNC(LPTSTR pwszFile, LPTSTR szComputerName);
LPTSTR SupportLongFileName (LPTSTR lpDir, LPDWORD lpWrkDirSize);
BOOL SecureNestedDir (LPTSTR lpDir, PSECURITY_DESCRIPTOR pDirSd, PSECURITY_DESCRIPTOR pFileSd);
BOOL SetEnvironmentVariableInBlock(PVOID *pEnv, LPTSTR lpVariable,
                                   LPTSTR lpValue, BOOL bOverwrite);
DWORD ExpandUserEnvironmentStrings(PVOID pEnv, LPCTSTR lpSrc,
                                   LPTSTR lpDst, DWORD nSize);
LPTSTR ConvertToShareName(LPTSTR lpShare);
DWORD AbleToBypassCSC(HANDLE hTokenUser, LPCTSTR lpDir, LPTSTR *lppCscBypassedPath, TCHAR *cpDrive);
void CancelCSCBypassedConnection(HANDLE hTokenUser, TCHAR cDrive);
LPTSTR GetUserNameFromSid(LPTSTR lpSid);
int GetNetworkName( LPWSTR* pszName, DWORD dwAdapterIndex );

HRESULT GetProfileListKeyName(LPTSTR szKeyName, DWORD cchKeyName, LPTSTR szSidString);
HRESULT SafeExpandEnvironmentStrings(LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize);
HRESULT AppendName(LPTSTR lpBuffer, UINT cchBuffer, LPCTSTR lpParent, LPCTSTR lpChild, LPTSTR* lppEnd, UINT*  pcchEnd);
HRESULT TakeOwnership(LPTSTR lpFileName);
HRESULT AddAdminAccess(LPTSTR lpFileName);
HRESULT SetupPreferenceKey(LPCTSTR lpSidString);

BOOL    IsGuiSetupInProgress();

//
// Flags used to specify additional that needs to be present in ACEs
//
#define OTHERSIDS_EVERYONE             1
#define OTHERSIDS_POWERUSERS           2

#ifndef MAX
#define MAX(a,b) (((a)>(b))?(a):(b))
#endif

#ifndef MIN
#define MIN(a,b) (((a)<(b))?(a):(b))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userenv\utils\util.c ===
//*************************************************************
//
//  Utility functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "uenv.h"
#include <iphlpapi.h>
#include <winsock2.h>
#include <mswsock.h>
#include <Aclapi.h>
#include <windns.h>
#include "strsafe.h"
#define PCOMMON_IMPL
#include "pcommon.h"

#define NETWORK_PROVIDER L"System\\CurrentControlSet\\Services\\lanmanworkstation\\NetworkProvider" 
#define PROVIDER_NAME    L"Name"

INT g_iMachineRole = -1;
LPVOID g_lpTestData = NULL;
CRITICAL_SECTION *g_PingCritSec;
LPCTSTR c_szUNCFilePrefix = TEXT("\\\\?\\UNC\\");
LPCTSTR c_szLocalFilePrefix = TEXT("\\\\?\\");
const DWORD c_dwLocalFilePrefixLen = sizeof(c_szLocalFilePrefix) / sizeof(TCHAR); // Length of szLocalFilePrefix in unit of TCHAR.

//
// Local function proto-types
//

DWORD IsSlowLink (HKEY hKeyRoot, LPTSTR lpDCAddress, BOOL *bSlow, DWORD* pdwAdapterIndex );
DWORD GetNetworkProvider(NETRESOURCE *psNR);

#ifdef __cplusplus
extern "C" {
#endif

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    );

DWORD APIENTRY
NPCancelConnectionForCSCAgent (
    LPCTSTR         szName,
    BOOL            fForce 
    );

#ifdef __cplusplus
}
#endif

DWORD
GetGroupPolicyNetworkName( LPWSTR szNetworkName, LPDWORD pdwByteCount )
{
    HKEY    hKey;
    DWORD   dwError = ERROR_SUCCESS;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History",
                            0,
                            KEY_READ,
                            &hKey );
    if ( dwError == ERROR_SUCCESS )
    {
        DWORD dwType = REG_SZ;
        
        dwError = RegQueryValueEx(  hKey,
                                    L"NetworkName",
                                    0,
                                    &dwType,
                                    (LPBYTE) szNetworkName,
                                    pdwByteCount );
        RegCloseKey (hKey);
    }

    return dwError;
}

int
GetNetworkName( LPWSTR* pszName, DWORD dwAdapterIndex )
{
    int iError;
    WSAQUERYSET restrictions;
    GUID WsMobilityServiceClassGuid = NLA_SERVICE_CLASS_GUID;
    WSADATA wsaData;
    HANDLE hQuery;
    PWSAQUERYSET    pResult = 0;
    DWORD           length;
    BOOL            bFinish = FALSE;
    PWS2_32_API     pWS2_32 = Loadws2_32Api();
    PIPHLPAPI_API   pIpHlpApi = LoadIpHlpApi();

    if ( !pWS2_32 )
    {
        return GetLastError();
    }

    if ( !pIpHlpApi )
    {
        return GetLastError();
    }

    //
    // Initialize Winsock
    //
    iError = pWS2_32->pfnWSAStartup( MAKEWORD(2, 2), &wsaData );
    if ( iError )
    {
        return iError;
    }

    //
    // Initialize the query for network names
    //
    ZeroMemory(&restrictions, sizeof(restrictions));
    restrictions.dwSize = sizeof(restrictions);
    restrictions.lpServiceClassId = &WsMobilityServiceClassGuid;
    restrictions.dwNameSpace = NS_NLA;

    //
    // Make sure we do not ask for the blobs that take a long time to get
    //
    if ( pWS2_32->pfnWSALookupServiceBegin( &restrictions, LUP_NOCONTAINERS, &hQuery ) )
    {
        iError = pWS2_32->pfnWSAGetLastError();
        pWS2_32->pfnWSACleanup();
        return iError;
    }

    //
    // Start loop of getting network names
    //
    while ( !bFinish )
    {
        int error;
        length = 0;

        //
        // Do call twice, first to get size of buffer for second call
        //
        error = pWS2_32->pfnWSALookupServiceNext( hQuery, 0, &length, 0 );
        iError = pWS2_32->pfnWSAGetLastError();
        if ( iError != WSAEFAULT && iError != WSA_E_NO_MORE )
        {
            break;
        }

        pResult = (PWSAQUERYSET) LocalAlloc( LPTR, length );
        if ( !pResult )
        {
            iError = GetLastError();
            break;
        }

        //
        // Get a network name
        //
        if ( !pWS2_32->pfnWSALookupServiceNext( hQuery, 0, &length, pResult ) )
        {
            if ( pResult->lpBlob )
            {
                int next;
                NLA_BLOB *blob = (NLA_BLOB *)pResult->lpBlob->pBlobData;

                do {
                    //
                    // We are looking for the blob containing the network GUID
                    //
                    if ( blob->header.type == NLA_INTERFACE )
                    {
                        //
                        // "\\DEVICE\\TCPIP_" + "{GUID"
                        //
                        WCHAR szAdapter[64];
                        DWORD dwAdapter;
                        WCHAR* szEnd = NULL;
                        size_t cchRemain = 0;
                        HRESULT hr = E_FAIL;

                        //
                        // Convert guid to device name
                        //
                        StringCchCopyExW( szAdapter,
                                          ARRAYSIZE(szAdapter),
                                          L"\\DEVICE\\TCPIP_",
                                          &szEnd,
                                          &cchRemain,
                                          0);
                        if (MultiByteToWideChar(CP_ACP,
                                                0,
                                                (LPCSTR)blob->data.interfaceData.adapterName,
                                                -1,
                                                szEnd,
                                                cchRemain))
                        {
                            //
                            // Get the index for the network
                            //
                            if ( pIpHlpApi->pfnGetAdapterIndex( szAdapter, &dwAdapter ) == NO_ERROR )
                            {
                                //
                                // Is it the index we are after
                                //
                                if ( dwAdapterIndex == dwAdapter && pResult->lpszServiceInstanceName )
                                {
                                    //
                                    // Yes, copy the network name into the buffer
                                    //
                                    DWORD dwSize = sizeof( WCHAR ) * ( wcslen(pResult->lpszServiceInstanceName) + 1 );
                                    *pszName = (LPWSTR) LocalAlloc( LPTR, dwSize );
                                    if ( !*pszName )
                                    {
                                        iError = GetLastError();
                                    }
                                    else
                                    {
                                        StringCbCopyW( *pszName, dwSize, pResult->lpszServiceInstanceName );
                                        bFinish = TRUE;
                                        iError = 0;
                                    }
                                }
                            }
                        }
                        else
                        {
                            iError = GetLastError();
                        }
                    }

                    //
                    // There maybe multiple blobs for each interface so make sure we find them all
                    //
                    next = blob->header.nextOffset;
                    blob = (NLA_BLOB *)(((char *)blob) + next);

                } while ( next );
            }

            LocalFree( pResult );
        }
        else
        {
            iError = pWS2_32->pfnWSAGetLastError();
            if ( iError == WSA_E_NO_MORE )
            {
                iError = 0;
            }
            LocalFree( pResult );
            break;
        }
    }

    //
    // tidy up
    //
    pWS2_32->pfnWSALookupServiceEnd( hQuery );
    pWS2_32->pfnWSACleanup();
    return iError;
}

//*************************************************************
//
//  ProduceWFromA()
//
//  Purpose:    Creates a buffer for a Unicode string and copies
//              the ANSI text into it (converting in the process)
//
//  Parameters: pszA    -   ANSI string
//
//
//  Return:     Unicode pointer if successful
//              NULL if an error occurs
//
//  Comments:   The caller needs to free this pointer.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

LPWSTR ProduceWFromA(LPCSTR pszA)
{
    LPWSTR pszW;
    int cch;

    if (!pszA)
        return (LPWSTR)pszA;

    cch = MultiByteToWideChar(CP_ACP, 0, pszA, -1, NULL, 0);

    if (cch == 0)
        cch = 1;

    pszW = LocalAlloc(LPTR, cch * sizeof(WCHAR));

    if (pszW) {
        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszA, -1, pszW, cch)) {
            LocalFree(pszW);
            pszW = NULL;
        }
    }

    return pszW;
}

//*************************************************************
//
//  ProduceAFromW()
//
//  Purpose:    Creates a buffer for an ANSI string and copies
//              the Unicode text into it (converting in the process)
//
//  Parameters: pszW    -   Unicode string
//
//
//  Return:     ANSI pointer if successful
//              NULL if an error occurs
//
//  Comments:   The caller needs to free this pointer.
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

LPSTR ProduceAFromW(LPCWSTR pszW)
{
    LPSTR pszA;
    int cch;

    if (!pszW)
        return (LPSTR)pszW;

    cch = WideCharToMultiByte(CP_ACP, 0, pszW, -1, NULL, 0, NULL, NULL);

    if (cch == 0)
        cch = 1;

    pszA = LocalAlloc(LPTR, cch * sizeof(char));

    if (pszA) {
         if (!WideCharToMultiByte(CP_ACP, 0, pszW, -1, pszA, cch, NULL, NULL)) {
            LocalFree(pszA);
            pszA = NULL;
        }
    }

    return pszA;
}


//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  CheckSlashEx()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing. It will take the buffer size
//              to make it safe (not overflow the buffer).
//
//  Parameters: lpDir      -   directory
//              cchBuffer  -   buffer size
//              pcchRemain -   buffer remained after patch '\'
//                             can be NULL if not needed.
//
//  Return:     Pointer to the end of the string, NULL for 
//              overflowed buffer.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              06/19/95    ericflo    Created
//              02/11/02    mingzhu    Make it safe
//
//*************************************************************
LPTSTR CheckSlashEx(LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemain )
{
    LPTSTR lpEnd = NULL;
    UINT   cchLen = lstrlen(lpDir);

    if (cchLen >= cchBuffer - 1) // Overflowed or full buffer
    {
        DmAssert(cchLen == cchBuffer - 1); // Should never happen
        if (pcchRemain)
            *pcchRemain = 0;
        lpEnd = NULL;
    }
    else
    {
        lpEnd = lpDir + cchLen;
        if (pcchRemain)
            *pcchRemain = cchBuffer - 1 - cchLen;
        if (*(lpEnd - 1) != TEXT('\\'))
        {
            *lpEnd =  TEXT('\\');
            lpEnd++;
            *lpEnd =  TEXT('\0');
            if (pcchRemain)
                (*pcchRemain) --;
        }
    }
    return lpEnd;
}

//*************************************************************
//
//  CheckSemicolon()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericlfo    Created
//
//*************************************************************
LPTSTR CheckSemicolon (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT(';')) {
        *lpEnd =  TEXT(';');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}



//*************************************************************
//
//  Delnode_Recurse()
//
//  Purpose:    Recursive delete function for Delnode
//
//  Parameters: lpDir   -   Full Directory Path. 
//              dwSize  -   Allocated size of the working buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/10/95     ericflo    Created
//              04/08/2002  mingzhu    Added functionality to take ownership
//
// Notes:
//  This function modifies the working buffer. 
//  This doesn't maintain the right error code. It ignores all
//  errors and tries to delete as much as possible..
//
//*************************************************************

BOOL Delnode_Recurse (LPTSTR lpDir, DWORD dwSize)
{
    BOOL bOwn = FALSE, bRetVal = FALSE;
    LPTSTR lpEnd = NULL, lpWrkDir = NULL;
    WIN32_FIND_DATA* pfd = NULL;
    HANDLE hFile;
    DWORD dwWrkDirSize;
    DWORD cchEnd; // buffer size for lpEnd
    HRESULT hr;
    BOOL bDeleteSuccess;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Entering, lpDir = <%s>"), lpDir));


    //
    // Each filename or a directory has to be less than MAX_PATH in the worst case.
    // So make sure that we have at least MAX_PATH + 2 (for a slash and '\0'
    // space left in the working buffer case.
    //
    // In the normal case, when we have a path of length ~MAX_PATH it will do only 
    // 1 allocation
    //


    if ((DWORD)(lstrlen(lpDir) + MAX_PATH+2) > (dwSize)) {
        
        dwWrkDirSize = dwSize+2*MAX_PATH;
        lpWrkDir = (LPTSTR)LocalAlloc(LPTR, dwWrkDirSize*sizeof(TCHAR));
        if (!lpWrkDir) {
            DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Couldn't allocate memory for working buffer. Error - %d"), GetLastError()));
            goto Exit;
        }

        StringCchCopy(lpWrkDir, dwWrkDirSize, lpDir);
        bOwn = TRUE;

    }
    else {
        lpWrkDir = lpDir;
        dwWrkDirSize = dwSize;
    }


    //
    // append "*.*" to the directory name
    //

    lpEnd = CheckSlashEx(lpWrkDir, dwWrkDirSize, &cchEnd);
    StringCchCopy(lpEnd, cchEnd, c_szStarDotStar);


    //
    //  Allocate fd in the heap, reduce stack usage
    //
    
    pfd = (WIN32_FIND_DATA*) LocalAlloc(LPTR, sizeof(WIN32_FIND_DATA));
    if (!pfd)
    {
        DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Couldn't allocate memory for WIN32_FIND_DATA. Error - %d"), GetLastError()));
        goto Exit;
    }

    //
    // Find the first file
    //
    hFile = FindFirstFile(lpWrkDir, pfd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ((GetLastError() == ERROR_FILE_NOT_FOUND) || (GetLastError() == ERROR_PATH_NOT_FOUND))
        {
            bRetVal = TRUE;
            goto Exit;
        }
        else if ((GetLastError() == ERROR_ACCESS_DENIED))
        {
            //
            //  Now we got an access denied, we will try to take the ownership of the directory and 
            //  add admin full access to it so that we can recurse into it and delete it.This only
            //  works when the caller is an admin. 
            //

            *lpEnd = TEXT('\0'); // Restore the original name

            hr = TakeOwnership(lpWrkDir);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: TakeOwnership failed.  Error = 0x%08X"), hr));
                goto Exit;
            }

            hr = AddAdminAccess(lpWrkDir);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: AddAdminAccess failed.  Error = 0x%08X"), hr));
                goto Exit;
            }

            // Append "*.*" and try again
            StringCchCopy(lpEnd, cchEnd, c_szStarDotStar);
            hFile = FindFirstFile(lpWrkDir, pfd);
            if (hFile == INVALID_HANDLE_VALUE)
            {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d"), GetLastError()));
                goto Exit;
            }
        }
        else {
            DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d"), GetLastError()));
            goto Exit;
        }
    }


    do {

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(pfd->cFileName, c_szDot)) {
            continue;
        }

        if (!lstrcmpi(pfd->cFileName, c_szDotDot)) {
            continue;
        }

        //
        //  Verbose output
        //

        DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFile found:  <%s>"), pfd->cFileName));

        // Note that fd.cFileName will not exceed MAX_PATH, so the buffer is 
        // always large enough to hold it in this algorithm.
        
        StringCchCopy(lpEnd, cchEnd, pfd->cFileName); 

        if (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //
            if (pfd->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Found a reparse point <%s>,  Will not recurse into it!"), lpWrkDir));
            }
            else
            {
                Delnode_Recurse(lpWrkDir, dwWrkDirSize);
                // ignore errors and go ahead..
                StringCchCopy(lpEnd, cchEnd, pfd->cFileName); 
            }

            if (pfd->dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                pfd->dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (lpWrkDir, pfd->dwFileAttributes);
            }

            if (!RemoveDirectory (lpWrkDir))
            {
                bDeleteSuccess = FALSE;
                
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    if ( SUCCEEDED(TakeOwnership(lpWrkDir)) &&
                         SUCCEEDED(AddAdminAccess(lpWrkDir)) &&
                         RemoveDirectory(lpWrkDir) )
                    {
                        bDeleteSuccess = TRUE;
                    }
                }
                
                if (!bDeleteSuccess)
                {
                    DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete directory <%s>.  Error = %d"),
                            lpWrkDir, GetLastError()));
                }
            }

        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((pfd->dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (pfd->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (lpWrkDir, FILE_ATTRIBUTE_NORMAL);
            }

            if (!DeleteFile (lpWrkDir))
            {
                bDeleteSuccess = FALSE;
                
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    if ( SUCCEEDED(TakeOwnership(lpWrkDir)) &&
                         SUCCEEDED(AddAdminAccess(lpWrkDir)) &&
                         DeleteFile(lpWrkDir) )
                    {
                        bDeleteSuccess = TRUE;
                    }
                }
                
                if (!bDeleteSuccess)
                {
                    DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete <%s>.  Error = %d"),
                            pfd->cFileName, GetLastError()));
                }
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, pfd));


    //
    // Close the search handle
    //

    FindClose(hFile);

    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Leaving <%s>"), lpDir));

    bRetVal = TRUE;

Exit:
    if (bOwn) 
        LocalFree(lpWrkDir);

    if (pfd)
        LocalFree(pfd);
        
    return bRetVal;
}


//*************************************************************
//
//  Delnode()
//
//  Purpose:    Recursive function that deletes files and
//              directories.
//
//  Parameters: lpDir   -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//              6/27/00     santanuc   modified to allow deletion of file with path length > MAX_PATH
//
//*************************************************************

BOOL Delnode (LPTSTR lpDir)
{
    LPTSTR lpWrkDir = NULL;
    DWORD dwWrkDirSize;
    BOOL   bRetVal = FALSE;

    lpWrkDir = SupportLongFileName(lpDir, &dwWrkDirSize);

    if (!lpWrkDir) {
        DebugMsg((DM_WARNING, TEXT("Delnode: Failed to Allocate memory.  Error = %d"),
                GetLastError()));
        goto Exit;
    }

    if (!Delnode_Recurse (lpWrkDir, dwWrkDirSize)) {
        DebugMsg((DM_WARNING, TEXT("Delnode: Delnode recurse failed with error %d"),
                GetLastError()));
    }
        
    if (!RemoveDirectory (lpDir)) {
        DWORD dwError;

        dwError = GetLastError();

        if ((dwError != ERROR_FILE_NOT_FOUND) &&
            (dwError != ERROR_PATH_NOT_FOUND)) {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: Failed to delete directory <%s>.  Error = %d"),
                    lpDir, dwError));
        }

        goto Exit;
    }

    bRetVal = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("Delnode: Deleted directory <%s> successfully."), lpDir));

Exit:
    
    if (lpWrkDir) {
        LocalFree(lpWrkDir);
    }

    return bRetVal;
}



//*************************************************************
//
//  CreateSystemDirectory()
//
//  Purpose:    A directory with system bit turned on can be created using 
//              CreateSystemDirectory.
//
//              This API causes a system directory with the specified pathname to be
//              created.  If the underlying file system supports security on files
//              and directories, then the SecurityDescriptor argument is applied to
//              the new directory.
//
//              This call is similar to DOS (int 21h, function 39h) and OS/2's
//              DosCreateDir.
//
//
//  Parameters: lpPathName - Supplies the pathname of the system directory to be created.
//              lpSecurityAttributes - An optional parameter that, if present, and
//                         supported on the target file system supplies a security
//                         descriptor for the new directory.
//
//
//  Return:     TRUE - The operation was successful.
//              FALSE/NULL - The operation failed. Extended error status is available
//                           using GetLastError.
//
//  Comments:   This function is exactly same as CreateDirectory API with the exception 
//              that the directory is created using attribute FILE_ATTRIBUTE_SYSTEM.
//              This allows newly created directory to not inherit the encryption property 
//              from parent directory if the parent directory is encrypted.
//
//  History:    Date        Author     Comments 
//              07/18/00    santanuc   To avoid deadlock situation when Documents and Settings
//                                     directory is encrypted.
//
//*************************************************************

BOOL CreateSystemDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    ULONG dwErrorCode;

    // Note : ANSI version may cause error calling the following
    
    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U( lpPathName,
                                                              &FileName,
                                                              NULL,
                                                              &RelativeName);

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    //
    // dont create a directory unless there is room in the directory for
    // at least an 8.3 name. This way everyone will be able to delete all
    // files in the directory by using del *.* which expands to path+\*.*
    //

    if ( FileName.Length > ((MAX_PATH-12)<<1) ) {
        DWORD L;
        LPWSTR lp;

        if ( !(lpPathName[0] == TEXT('\\') && lpPathName[1] == TEXT('\\') &&
               lpPathName[2] == TEXT('?') && lpPathName[3] == TEXT('\\')) ) {
            L = GetFullPathNameW(lpPathName,0,NULL,&lp);
            if ( !L || L+12 > MAX_PATH ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0,FileName.Buffer);
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                return FALSE;
            }
        }
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
    }
    else {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
    }
 
    // Creating the directory with attribute FILE_ATTRIBUTE_SYSTEM to avoid inheriting encryption 
    // property from parent directory

    Status = NtCreateFile( &Handle,
                           FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_SYSTEM,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_CREATE,
                           FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,
                           0L );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( NT_SUCCESS(Status) ) {
        NtClose(Handle);
        return TRUE;
    }
    else {
        if ( RtlIsDosDeviceName_U((LPWSTR)lpPathName) ) {
            Status = STATUS_NOT_A_DIRECTORY;
        }

        // Since RtlNtStatusToDosError function can't convert STATUS_TIMEOUT, we have to 
        // do it explicitly

        if (Status == STATUS_TIMEOUT) {
            SetLastError(ERROR_TIMEOUT);
        }
        else {
            dwErrorCode = RtlNtStatusToDosError( Status );
            SetLastError( dwErrorCode );  
        }
        return FALSE;
    }
}


//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary using CreateNestedDirectoryEx. 
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/00     santanuc   Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    // Call CreateNestedDirectoryEx with inherit encryption property
    return CreateNestedDirectoryEx(lpDirectory, lpSecurityAttributes, TRUE);
}

//*************************************************************
//
//  CreateNestedDirectoryEx()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary. 
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//              bInheritEncryption - Flag indicating whether newly created directory should inherit
//                                   encryption property from parent directory.
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//              7/18/00     santanuc   added a new flag bInheritEncryption to avoid deadlock when 
//                                     Documents and Settings directory is encrypted.
//
//*************************************************************

UINT CreateNestedDirectoryEx(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, BOOL bInheritEncryption)
{
    TCHAR szDirectory[2*MAX_PATH];
    LPTSTR lpEnd;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Received a NULL pointer.")));
        return 0;
    }


    //
    // Test if the directory exists already
    //

    if (GetFileAttributesEx (lpDirectory, GetFileExInfoStandard, &fad)) {
        if (fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            return ERROR_ALREADY_EXISTS;
        } else {
            SetLastError(ERROR_ACCESS_DENIED);
            return 0;
        }
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if ( bInheritEncryption ) {
        if (CreateDirectory (lpDirectory, lpSecurityAttributes)) 
            return 1;
    }
    else {
        if (CreateSystemDirectory (lpDirectory, lpSecurityAttributes)) {
            SetFileAttributes(lpDirectory, FILE_ATTRIBUTE_NORMAL);  // turn off the system attribute
            return 1;
        }
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    StringCchCopy(szDirectory, ARRAYSIZE(szDirectory), lpDirectory);


    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            return 0;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!GetFileAttributesEx (szDirectory, GetFileExInfoStandard, &fad)) {

                if ( bInheritEncryption ) {
                    if (!CreateDirectory (szDirectory, lpSecurityAttributes)) {
                        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                        return 0;
                    }
                }

                else {
                    if (!CreateSystemDirectory (szDirectory, lpSecurityAttributes)) {
                        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed with %d."), GetLastError()));
                        return 0;
                    }
                    else
                        SetFileAttributes(szDirectory, FILE_ATTRIBUTE_NORMAL); // turn off the system attribute
                }

            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if ( bInheritEncryption ) {
        if (CreateDirectory (lpDirectory, lpSecurityAttributes)) 
            return 1;
    }
    else {
        if (CreateSystemDirectory (lpDirectory, lpSecurityAttributes)) {
            SetFileAttributes(lpDirectory, FILE_ATTRIBUTE_NORMAL); // turn off the system attribute
            return 1;
        }
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        return ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

    return 0;

}

//*************************************************************
//
//  GetProfilesDirectory()
//
//  Purpose:    Returns the location of the "profiles" directory
//
//  Parameters: lpProfilesDir   -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              9/18/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetProfilesDirectory(LPTSTR lpProfilesDir, LPDWORD lpcchSize)
{
    return GetProfilesDirectoryEx (lpProfilesDir, lpcchSize, TRUE);
}


//*************************************************************
//
//  GetProfilesDirectoryEx()
//
//  Purpose:    Returns the location of the "profiles" directory
//
//  Parameters: lpProfilesDir   -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//              bExpand         -   Expand directory name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/15/97    ericflo    Created
//
//*************************************************************

BOOL GetProfilesDirectoryEx(LPTSTR lpProfilesDir, LPDWORD lpcchSize, BOOL bExpand)
{
    TCHAR  szDirectory[MAX_PATH];
    TCHAR  szTemp[MAX_PATH];
    DWORD  dwLength;
    HKEY   hKey = INVALID_HANDLE_VALUE;
    LONG   lResult;
    DWORD  dwSize, dwType;
    BOOL   bRetVal = FALSE;


    //
    // Arg check
    //

    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    szDirectory[0] = TEXT('\0');
    szTemp[0] = TEXT('\0');

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH, 0, KEY_READ,
                            &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(szTemp);

        lResult = RegQueryValueEx (hKey, PROFILES_DIRECTORY, NULL, &dwType,
                                   (LPBYTE) szTemp, &dwSize);

        if (lResult == ERROR_SUCCESS) {

            if ((dwType == REG_EXPAND_SZ) || (dwType == REG_SZ)) {

                if (bExpand && (dwType == REG_EXPAND_SZ)) {
                    if((dwLength = ExpandEnvironmentStrings(szTemp, szDirectory, MAX_PATH)) == 0) {
                        goto Exit;
                    }
                    else if(dwLength > MAX_PATH) {
                        SetLastError(ERROR_BAD_PATHNAME);
                        goto Exit;
                    }
                } else {
                    StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), szTemp);
                }
            }
        }

        RegCloseKey (hKey);
        hKey = INVALID_HANDLE_VALUE;
    }


    if (szDirectory[0] == TEXT('\0')) {

        LoadString (g_hDllInstance, IDS_PROFILES_ROOT, szTemp, ARRAYSIZE(szTemp));

        if (bExpand) {
            if((dwLength = ExpandEnvironmentStrings(szTemp, szDirectory, MAX_PATH)) == 0) {
                goto Exit;
            }
            else if(dwLength > MAX_PATH) {
                SetLastError(ERROR_BAD_PATHNAME);
                goto Exit;
            }
        } else {
            StringCchCopy (szDirectory, ARRAYSIZE(szDirectory), szTemp);
        }
    }


    dwLength = lstrlen(szDirectory) + 1;

    if (lpProfilesDir) {

        if (*lpcchSize >= dwLength) {
            StringCchCopy (lpProfilesDir, *lpcchSize, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

Exit:

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    return bRetVal;
}

//*************************************************************
//
//  GetDefaultUserProfileDirectory()
//
//  Purpose:    Returns the location of the Default User's profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetDefaultUserProfileDirectory(LPTSTR lpProfileDir, LPDWORD lpcchSize)
{
    return  GetDefaultUserProfileDirectoryEx(lpProfileDir, lpcchSize, TRUE);
}

//*************************************************************
//
//  GetDefaultUserProfileDirectoryEx()
//
//  Purpose:    Returns the location of the Default User's profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//              bExpand         -   Expand the path or not
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetDefaultUserProfileDirectoryEx(LPTSTR lpProfileDir,
                                             LPDWORD lpcchSize, BOOL bExpand)
{
    TCHAR  szDirectory[MAX_PATH];
    TCHAR  szProfileName[MAX_PATH];
    LPTSTR lpEnd;
    int    cchEnd;
    DWORD  dwSize, dwLength, dwType;
    BOOL   bRetVal = FALSE;
    LONG   lResult;
    HKEY   hKey;


    //
    // Arg check
    //

    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Get the profiles root
    //

    szDirectory[0] = TEXT('\0');
    dwSize = ARRAYSIZE(szDirectory);

    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, bExpand)) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectory:  Failed to get profiles root.")));
        *lpcchSize = 0;
        return FALSE;
    }


    //
    // Query for the Default User profile name
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectoryEx:  Failed to open profile list key with %d."),
                 lResult));
        SetLastError(lResult);
        return FALSE;
    }

    dwSize = sizeof(szProfileName);
    lResult = RegQueryValueEx (hKey, DEFAULT_USER_PROFILE, NULL, &dwType,
                               (LPBYTE) szProfileName, &dwSize);

    if (lResult != ERROR_SUCCESS) {
        StringCchCopy (szProfileName, ARRAYSIZE(szProfileName), DEFAULT_USER);
    }

    RegCloseKey (hKey);


    //
    // Put them together
    //

    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (cchEnd < lstrlen(szProfileName) + 1)
    {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectory:  path > MAX_PATH.")));
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }
    StringCchCopy (lpEnd, cchEnd, szProfileName);


    //
    // Save the result if possible
    dwLength = lstrlen(szDirectory) + 1;

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            StringCchCopy (lpProfileDir, *lpcchSize, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }

    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

//*************************************************************
//
//  GetAllUsersProfileDirectory()
//
//  Purpose:    Returns the location of the All Users profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetAllUsersProfileDirectory(LPTSTR lpProfileDir, LPDWORD lpcchSize)
{
    return  GetAllUsersProfileDirectoryEx(lpProfileDir, lpcchSize, TRUE);
}

//*************************************************************
//
//  GetAllUsersProfileDirectoryEx()
//
//  Purpose:    Returns the location of the All Users profile
//
//  Parameters: lpProfileDir    -   Buffer to write result to
//              lpcchSize       -   Size of the buffer in chars.
//              bExpand         -   Expand the path or not
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              12/8/97     ericflo    Created
//
//*************************************************************

BOOL GetAllUsersProfileDirectoryEx (LPTSTR lpProfileDir,
                                    LPDWORD lpcchSize, BOOL bExpand)
{
    TCHAR  szDirectory[MAX_PATH];
    TCHAR  szProfileName[MAX_PATH];
    LPTSTR lpEnd;
    int    cchEnd;
    DWORD  dwSize, dwLength, dwType;
    BOOL   bRetVal = FALSE;
    LONG   lResult;
    HKEY   hKey;



    //
    // Arg check
    //

    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Get the profiles root
    //

    szDirectory[0] = TEXT('\0');
    dwSize = ARRAYSIZE(szDirectory);

    if (!GetProfilesDirectoryEx(szDirectory, &dwSize, bExpand)) {
        DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryEx:  Failed to get profiles root.")));
        *lpcchSize = 0;
        return FALSE;
    }


    //
    // Query for the All Users profile name
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetAllUsersProfileDirectoryEx:  Failed to open profile list key with %d."),
                 lResult));
        SetLastError(lResult);
        return FALSE;
    }

    dwSize = sizeof(szProfileName);
    lResult = RegQueryValueEx (hKey, ALL_USERS_PROFILE, NULL, &dwType,
                               (LPBYTE) szProfileName, &dwSize);

    if (lResult != ERROR_SUCCESS) {
        StringCchCopy(szProfileName, ARRAYSIZE(szProfileName), ALL_USERS);
    }

    RegCloseKey (hKey);


    //
    // Put them together
    //

    lpEnd = CheckSlashEx (szDirectory, ARRAYSIZE(szDirectory), &cchEnd);
    if (cchEnd < lstrlen(szProfileName) + 1)
    {
        DebugMsg((DM_WARNING, TEXT("GetDefaultUserProfileDirectory:  path > MAX_PATH.")));
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }
    StringCchCopy (lpEnd, cchEnd, szProfileName);


    //
    // Save the result if possible
    dwLength = lstrlen(szDirectory) + 1;

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            StringCchCopy (lpProfileDir, *lpcchSize, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    } else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}

//*************************************************************
//
//  GetProfileListKeyName()
//
//  Purpose:    Returns the key name for a specific user under ProfileList.
//              Using safe string functions
//
//  Parameters: szKeyName     -   Buffer of the returned name
//              cchKeyName    -   size of the buffer
//              szSidString   -   sid string for a specific user
//
//  Return:     S_OK if successful
//              Error Code if an error occurs
//
//  Comments:   If error code is returned, content of szKeyName may 
//              change. 
//
//  History:    Date        Author     Comment
//              02/21/2002  mingzhu    Created
//
//*************************************************************

HRESULT GetProfileListKeyName(LPTSTR szKeyName, DWORD cchKeyName, LPTSTR szSidString)
{
    HRESULT hr;

    hr = StringCchCopy(szKeyName, cchKeyName, PROFILE_LIST_PATH);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(szKeyName, cchKeyName, TEXT("\\"));
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(szKeyName, cchKeyName, szSidString);
        }
    }

    return hr;
}

//*************************************************************
//
//  GetKeyNameForUser()
//
//  Purpose:    Returns the user's key name in for specific user.
//              Using safe string functions
//
//  Parameters: szKeyName     -   Buffer of the returned name
//              cchKeyName    -   size of the buffer
//              szSidString   -   sid string for a specific user
//              szSubKey      -   subkey name under the key's hive
//
//  Return:     S_OK if successful
//              Error Code if an error occurs
//
//  Comments:   If error code is returned, content of szKeyName may 
//              change. 
//
//  History:    Date        Author     Comment
//              02/21/2002  mingzhu    Created
//
//*************************************************************

HRESULT GetKeyNameForUser(LPTSTR szKeyName, DWORD cchKeyName, LPTSTR szSidString, LPTSTR szSubKey)
{
    HRESULT hr;

    hr = StringCchCopy(szKeyName, cchKeyName, szSidString);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(szKeyName, cchKeyName, TEXT("\\"));
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(szKeyName, cchKeyName, szSubKey);
        }
    }

    return hr;
}

//*************************************************************
//
//  SafeExpandEnvironmentStrings()
//
//  Purpose:    a wrapper of ExpandEnvironmentStrings() to
//              handle small buffer errors more explictly.
//
//  Parameters: lpSrc    -   Src string contains the env var
//              lpDst    -   Output buffer
//              nSize    -   Size of output buffer
//
//  Return:     S_OK if successful
//              else if an error occurs
//
//  History:    Date        Author     Comment
//              02/21/2002  mingzhu    Created
//
//*************************************************************

HRESULT SafeExpandEnvironmentStrings(LPCTSTR lpSrc, LPTSTR lpDst, DWORD nSize)
{
    DWORD   dwErr;
    HRESULT hr;

    dwErr = ExpandEnvironmentStrings(lpSrc, lpDst, nSize);
    if (dwErr == 0)
        hr = HRESULT_FROM_WIN32(GetLastError());
    else if (dwErr > nSize)
        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    else
        hr = S_OK;

    return hr;
}

//*************************************************************
//
//  AppendName()
//
//  Purpose:    append a file name to a folder name, or append a subkey name
//              to a parent key name, add a slash if neccesory.
//
//  Parameters: lpBuffer  -  output buffer to hold the appended path
//              cchBuffer -  size of the output buffer
//              lpParent  -  path/parent key name to append to
//              lpChild   -  file/subkey name to append 
//              lppEnd    -  optional returned pointer to the end of the slash of lpParent,
//                           can be used to further append other children to the same parent
//              pcchEnd   -  optional returned pointer to the buffer size pointered by *lppEnd
//
//  Return:     S_OK if successful
//              else if an error occurs
//
//  History:    Date        Author     Comment
//              03/05/2002  mingzhu    Created
//
//*************************************************************

HRESULT AppendName(
    LPTSTR  lpBuffer,
    UINT   cchBuffer,
    LPCTSTR lpParent,
    LPCTSTR lpChild,
    LPTSTR* lppEnd,
    UINT*  pcchEnd)
{
    HRESULT hr;
    LPTSTR lpEnd;
    UINT cchEnd;

    hr = StringCchCopy(lpBuffer, cchBuffer, lpParent);
    if (SUCCEEDED(hr))
    {
        lpEnd = CheckSlashEx(lpBuffer, cchBuffer, &cchEnd);
        if (!lpEnd)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        else
        {
            hr = StringCchCopy(lpEnd, cchEnd, lpChild);
        }
    }

    if (SUCCEEDED(hr))
    {
        if (lppEnd)
            *lppEnd = lpEnd;
        if (pcchEnd)
            *pcchEnd = cchEnd;
    }

    return hr;
}

//*************************************************************
//
//  GetUserProfileDirectory()
//
//  Purpose:    Returns the root of the user's profile directory.
//
//  Parameters: hToken          -   User's token
//              lpProfileDir    -   Output buffer
//              lpcchSize       -   Size of output buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              9/18/95     ericflo    Created
//
//*************************************************************

BOOL WINAPI GetUserProfileDirectory(HANDLE hToken, LPTSTR lpProfileDir,
                                    LPDWORD lpcchSize)
{
    DWORD  dwLength = MAX_PATH * sizeof(TCHAR);
    DWORD  dwType;
    BOOL   bRetVal = FALSE;
    LPTSTR lpSidString;
    TCHAR  szBuffer[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    HKEY   hKey;
    LONG   lResult;
    HRESULT hr;


    //
    // Parameter check
    //

    if (!hToken) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Retrieve the user's sid string
    //

    lpSidString = GetSidString(hToken);

    if (!lpSidString) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    //
    // Check the registry
    //

    hr = GetProfileListKeyName(szBuffer, ARRAYSIZE(szBuffer), lpSidString);
    
    if (FAILED(hr))
    {
        DeleteSidString(lpSidString);
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        DeleteSidString(lpSidString);
        SetLastError(lResult);
        return FALSE;
    }

    lResult = RegQueryValueEx(hKey,
                              PROFILE_IMAGE_VALUE_NAME,
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwLength);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        DeleteSidString(lpSidString);
        SetLastError(lResult);
        return FALSE;
    }


    //
    // Clean up
    //

    RegCloseKey(hKey);
    DeleteSidString(lpSidString);



    //
    // Expand and get the length of string
    //

    hr = SafeExpandEnvironmentStrings(szBuffer, szDirectory, ARRAYSIZE(szDirectory));
    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

    dwLength = lstrlen(szDirectory) + 1;


    //
    // Save the string if appropriate
    //

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            StringCchCopy (lpProfileDir, *lpcchSize, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


//*************************************************************
//
//  GetUserProfileDirFromSid()
//
//  Purpose:    Returns the root of the user's profile directory.
//
//  Parameters: pSid            -   User's SID
//              lpProfileDir    -   Output buffer
//              lpcchSize       -   Size of output buffer
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:   If false is returned, lpcchSize holds the number of
//              characters needed.
//
//  History:    Date        Author     Comment
//              03/08/01    santanuc   Created
//
//*************************************************************

BOOL WINAPI GetUserProfileDirFromSid(PSID pSid, LPTSTR lpProfileDir,
                                     LPDWORD lpcchSize)
{
    DWORD  dwLength = MAX_PATH * sizeof(TCHAR);
    DWORD  dwType;
    BOOL   bRetVal = FALSE;
    UNICODE_STRING UnicodeString;
    TCHAR  szBuffer[MAX_PATH];
    TCHAR  szDirectory[MAX_PATH];
    HKEY   hKey;
    LONG   lResult;
    NTSTATUS NtStatus;
    HRESULT hr;


    //
    // Parameter check
    //

    if (!pSid) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    if (!lpcchSize) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Retrieve the user's sid string
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            pSid,
                            (BOOLEAN)TRUE  // Allocate memory
                            );
    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        SetLastError(RtlNtStatusToDosError(NtStatus));
        DebugMsg((DM_WARNING, TEXT("GetUserProfileDirFromSid: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return FALSE;
    }


    //
    // Check the registry
    //

    hr = GetProfileListKeyName(szBuffer, ARRAYSIZE(szBuffer), UnicodeString.Buffer);
    
    if (FAILED(hr))
    {
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                           &hKey);

    if (lResult != ERROR_SUCCESS) {
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(lResult);
        return FALSE;
    }

    lResult = RegQueryValueEx(hKey,
                              PROFILE_IMAGE_VALUE_NAME,
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwLength);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        RtlFreeUnicodeString(&UnicodeString);
        SetLastError(lResult);
        return FALSE;
    }


    //
    // Clean up
    //

    RegCloseKey(hKey);
    RtlFreeUnicodeString(&UnicodeString);



    //
    // Expand and get the length of string
    //

    hr = SafeExpandEnvironmentStrings(szBuffer, szDirectory, ARRAYSIZE(szDirectory));

    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }
    
    dwLength = lstrlen(szDirectory) + 1;


    //
    // Save the string if appropriate
    //

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            StringCchCopy (lpProfileDir, *lpcchSize, szDirectory);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


//*************************************************************
//
//  GetUserAppDataPath()
//
//  Purpose:    Returns the path for user's Appdata.
//
//  Parameters: hToken          -   User's token
//              lpFolderPath    -   Output buffer
//
//  Return:     ERROR_SUCCESS if successful
//              otherwise the error code
//
//  Comments:   If error occurs then lpFolderPath set to empty.
//              Used by Crypto guys to avoid calling SHGetFolderPath.
//
//  History:    Date        Author     Comment
//
//*************************************************************
DWORD WINAPI
GetUserAppDataPath(
    HANDLE       hToken,
    BOOL         fLocalAppData,
    LPTSTR       lpFolderPath
    )
{
    DWORD  dwSize, dwType;
    LPTSTR lpSidString = NULL;
    DWORD  dwError = ERROR_SUCCESS;
    HKEY   hKey = NULL;
    TCHAR  szBuffer[MAX_PATH];
    HRESULT hr;


    //
    // Parameter check
    //

    if (!hToken) {
        dwError = ERROR_INVALID_HANDLE;
        goto Exit;
    }


    if (!lpFolderPath) {
        dwError = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    else {
        *lpFolderPath = TEXT('\0');
    }


    //
    // Retrieve the user's sid string
    //

    lpSidString = GetSidString(hToken);

    if (!lpSidString) {
        dwError = ERROR_INVALID_HANDLE;
        goto Exit;
    }


    //
    // Check the registry
    //

    hr = GetKeyNameForUser(szBuffer, ARRAYSIZE(szBuffer), lpSidString, USER_SHELL_FOLDERS);

    if (FAILED(hr))
    {
        dwError = HRESULT_CODE(hr);
        goto Exit;
    }

    dwError = RegOpenKeyEx(HKEY_USERS, szBuffer, 0, KEY_READ, &hKey);
    if (dwError != ERROR_SUCCESS) {
        goto Exit;
    }

    dwSize = MAX_PATH * sizeof(TCHAR);
    dwError = RegQueryValueEx(hKey,
                              fLocalAppData ? TEXT("Local AppData") : TEXT("AppData"),
                              NULL,
                              &dwType,
                              (LPBYTE) szBuffer,
                              &dwSize);

    if (ERROR_SUCCESS == dwError) {

        dwSize = MAX_PATH;
        if (!ExpandEnvironmentStringsForUser(hToken, szBuffer, lpFolderPath, dwSize)) {
            dwError = GetLastError();
        }
    }
                    

Exit:

    //
    // Clean up
    //

    if (lpSidString) {
        DeleteSidString(lpSidString);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    SetLastError(dwError);
    return dwError;
}


//*************************************************************
//
//  StringToInt()
//
//  Purpose:    Converts a string to an integer
//
//  Parameters: lpNum   -   Number to convert
//
//  Return:     The number
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/3/95     ericflo    Created
//
//*************************************************************

int StringToInt(LPTSTR lpNum)
{
  int i = 0;
  BOOL bNeg = FALSE;

  if (*lpNum == TEXT('-')) {
      bNeg = TRUE;
      lpNum++;
  }

  while (*lpNum >= TEXT('0') && *lpNum <= TEXT('9')) {
      i *= 10;
      i += (int)(*lpNum-TEXT('0'));
      lpNum++;
  }

  if (bNeg) {
      i *= -1;
  }

  return(i);
}

//*************************************************************
//
//  HexStringToInt()
//
//  Purpose:    Converts a hex string to an integer, stops
//              on first invalid character
//
//  Parameters: lpNum   -   Number to convert
//
//  Return:     The number
//
//  Comments:   Originally for use in "ExtractCSIDL" tested
//              exclusively with 0x0000 numbers format
//
//  History:    Date        Author     Comment
//              6/9/98      stephstm   Created
//
//*************************************************************

unsigned int HexStringToUInt(LPCTSTR lpcNum)
{
  unsigned int i = 0;

  while (1)
  {
      if(*lpcNum != TEXT('x') && *lpcNum != TEXT('X') )
      {
          if(*lpcNum >= TEXT('0') && *lpcNum <= TEXT('9'))
          {
              i *= 16;
              i += (unsigned int)(*lpcNum-TEXT('0'));
          }
          else
          {
              if(*lpcNum >= TEXT('a') && *lpcNum <= TEXT('f'))
              {
                  i *= 16;
                  i += (unsigned int)(*lpcNum-TEXT('a')) + 10;
              }
              else
              {
                  if(*lpcNum >= TEXT('A') && *lpcNum <= TEXT('F'))
                  {
                      i *= 16;
                      i += (unsigned int)(*lpcNum-TEXT('A')) + 10;
                  }
                  else
                      break;
              }
          }
      }
      lpcNum++;
  }

  return(i);
}

//*************************************************************
//
//  RegRenameKey()
//
//  Purpose:    Renames a registry key
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey1    -   SubKey to rename from
//              lpSubKey2   -   SubKey to rename to
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              20/9/99     ushaji     created
//              05/02/2002  mingzhu    Make this function support subkeys (recursive)
//
//*************************************************************

LONG RegRenameKey(HKEY hKeyRoot, LPTSTR lpSrcKey, LPTSTR lpDestKey)
{
    HKEY   hSrcKey=NULL, hDestKey=NULL;
    LONG   lResult;
    DWORD  dwDisposition;
    DWORD  dwValues, dwMaxValueNameLen, dwMaxValueLen, dwType;
    DWORD  dwMaxValueNameLenLocal, dwMaxValueLenLocal, i, dwSDSize;
    DWORD  dwSrcSubkeyLen, dwDestSubkeyLen, dwSubkeyLen;
    DWORD  dwSubkeys, dwMaxSubkeyNameLen, dwMaxSubkeyNameLenLocal;
    LPTSTR lpSrcSubkey = NULL;
    LPTSTR lpDestSubkey = NULL;
    LPTSTR lpSubkey = NULL;
    LPTSTR lpValueName=NULL;
    LPBYTE lpData=NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    HRESULT hr;

    //
    //  Verbose Debug Message
    //
    DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: renaming %s to %s"), lpSrcKey, lpDestKey));
    

    if (!lpSrcKey || !lpDestKey)
        return ERROR_INVALID_PARAMETER;
        
    lResult = RegOpenKeyEx(hKeyRoot, lpSrcKey, 0, KEY_ALL_ACCESS, &hSrcKey);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot open src key %s with error %d"), lpSrcKey, lResult));
        goto Exit;
    }


    if (RegDelnode(hKeyRoot, lpDestKey) != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot delete dest key %s."), lpDestKey));
        goto Exit;
    }

    lResult = RegQueryInfoKey(hSrcKey, NULL, NULL, NULL, &dwSubkeys, &dwMaxSubkeyNameLen, NULL,
                              &dwValues, &dwMaxValueNameLen, &dwMaxValueLen,
                              &dwSDSize, NULL);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot query src key %s with error %d"), lpSrcKey, lResult));
        goto Exit;
    }

    pSD = LocalAlloc(LPTR, sizeof(BYTE)*dwSDSize);

    if (!pSD) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory error")));
        lResult = GetLastError();
        goto Exit;
    }


    lResult = RegGetKeySecurity(hSrcKey, DACL_SECURITY_INFORMATION, pSD, &dwSDSize);


    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot get sd with error %d"), lResult));
        goto Exit;
    }


    lResult = RegCreateKeyEx(hKeyRoot, lpDestKey, 0, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hDestKey,
                             &dwDisposition);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot open dest key %s with error %d"), lpDestKey, lResult));
        goto Exit;
    }


    lResult = RegSetKeySecurity(hDestKey, DACL_SECURITY_INFORMATION, pSD);

    if (lResult != ERROR_SUCCESS) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot get sd with error %d"), lResult));
        goto Exit;
    }



    lpValueName = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(dwMaxValueNameLen+1));

    if (!lpValueName) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for valuename")));
        lResult = GetLastError();
        goto Exit;
    }

    lpData = (LPBYTE) LocalAlloc(LPTR, sizeof(BYTE)*dwMaxValueLen);

    if (!lpData) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for lpData")));
        lResult = GetLastError();
        goto Exit;
    }


    for (i = 0; i < dwValues; i++) {

        dwMaxValueNameLenLocal = dwMaxValueNameLen+1;
        dwMaxValueLenLocal = dwMaxValueLen;


        lResult = RegEnumValue(hSrcKey, i, lpValueName, &dwMaxValueNameLenLocal, NULL, &dwType, lpData, &dwMaxValueLenLocal);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot enum src key value with error %d"), lResult));
            goto Exit;
        }


        lResult = RegSetValueEx(hDestKey, lpValueName, 0, dwType, lpData, dwMaxValueLenLocal);

        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot set dest value %s with error %d"), lpValueName, lResult));
            goto Exit;
        }
    }


    //
    //  Allocate buffer for local, src and dest subkeys
    //
    lpSubkey = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(dwMaxSubkeyNameLen + 1));
    if (!lpSubkey) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for subkey")));
        lResult = GetLastError();
        goto Exit;
    }

    
    dwSrcSubkeyLen = lstrlen(lpSrcKey) + dwMaxSubkeyNameLen + 2;
    lpSrcSubkey = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(dwSrcSubkeyLen));
    if (!lpSrcSubkey) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for src subkey")));
        lResult = GetLastError();
        goto Exit;
    }

    dwDestSubkeyLen = lstrlen(lpDestKey) + dwMaxSubkeyNameLen + 2;
    lpDestSubkey = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(dwDestSubkeyLen));
    if (!lpDestSubkey) {
        DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot allocate memory for dest subkey")));
        lResult = GetLastError();
        goto Exit;
    }

    //
    //  Enumerate subkeys and call this function recursively
    //
    for (i = 0; i < dwSubkeys; i++) {

        // Enumerate local subkey
        dwMaxSubkeyNameLenLocal = dwMaxSubkeyNameLen + 1;
        lResult = RegEnumKeyEx(hSrcKey, i, lpSubkey, &dwMaxSubkeyNameLenLocal, NULL, NULL, NULL, NULL);
        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: Couldnot enum sub key value with error %d"), lResult));
            goto Exit;
        }

        // Construct the src and dest subkey
        hr = StringCchPrintf(lpSrcSubkey, dwSrcSubkeyLen, TEXT("%s\\%s"), lpSrcKey, lpSubkey);
        if (FAILED(hr)) {
            lResult = HRESULT_CODE(hr);
            goto Exit;
        }

        hr = StringCchPrintf(lpDestSubkey, dwDestSubkeyLen, TEXT("%s\\%s"), lpDestKey, lpSubkey);
        if (FAILED(hr)) {
            lResult = HRESULT_CODE(hr);
            goto Exit;
        }

        // Call this function recursively
        lResult = RegRenameKey(hKeyRoot, lpSrcSubkey, lpDestSubkey);
        if (lResult != ERROR_SUCCESS) {
            DebugMsg((DM_VERBOSE, TEXT("RegRenameKey: failed to rename %s to %s, error = %d"), lpSrcSubkey, lpDestSubkey, lResult));
            goto Exit;
        }
    }
    
Exit:

    if (lpSubkey)
        LocalFree(lpSubkey);

    if (lpSrcSubkey)
        LocalFree(lpSrcSubkey);

    if (lpDestSubkey)
        LocalFree(lpDestSubkey);
        
    if (hSrcKey)
        RegCloseKey(hSrcKey);

    if (hDestKey)
        RegCloseKey(hDestKey);

    if (lpData)
        LocalFree(lpData);

    if (lpValueName)
        LocalFree(lpValueName);

    if (pSD)
        LocalFree(pSD);

    if (lResult == ERROR_SUCCESS)
        lResult = RegDelnode(hKeyRoot, lpSrcKey);
    else
        RegDelnode(hKeyRoot, lpDestKey);

    return lResult;
}



//*************************************************************
//
//  CreateSecureAdminDirectory()
//
//  Purpose:    Creates a secure directory that only the Administrator
//              and system have access to.
//
//  Parameters: lpDirectory -   Directory Name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/20/95     ericflo    Created
//
//*************************************************************

BOOL CreateSecureAdminDirectory (LPTSTR lpDirectory, DWORD dwOtherSids)
{

    //
    // Attempt to create the directory
    //

    if (!CreateNestedDirectory(lpDirectory, NULL)) {
        return FALSE;
    }


    //
    // Set the security
    //

    if (!MakeFileSecure (lpDirectory, dwOtherSids)) {
        RemoveDirectory(lpDirectory);
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  DeleteAllValues ()
//
//  Purpose:    Deletes all values under specified key
//
//  Parameters: hKey    -   Key to delete values from
//
//  Return:
//
//  Comments:
//
//  History:    Date        Author     Comment
//              9/14/95     ericflo    Ported
//
//*************************************************************

BOOL DeleteAllValues(HKEY hKey)
{
    TCHAR ValueName[MAX_PATH+1];
    DWORD dwSize = MAX_PATH+1;
    LONG lResult;

    while (RegEnumValue(hKey, 0, ValueName, &dwSize,
            NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            lResult = RegDeleteValue(hKey, ValueName);

            if (lResult != ERROR_SUCCESS) {
                DebugMsg((DM_WARNING, TEXT("DeleteAllValues:  Failed to delete value <%s> with %d."), ValueName, lResult));
                return FALSE;
            } else {
                DebugMsg((DM_VERBOSE, TEXT("DeleteAllValues:  Deleted <%s>"), ValueName));
            }


            dwSize = MAX_PATH+1;
    }
    return TRUE;
}

//*************************************************************
//
//  MakeFileSecure()
//
//  Purpose:    Sets the attributes on the file so only Administrators
//              and the OS can delete it.  Authenticated Users have read
//              permission only.
//
//  Parameters: lpFile  -   File to set security on
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/6/95     ericflo    Created
//              2/16/99     ushaji      Added everyone, pweruser
//
//*************************************************************

BOOL MakeFileSecure (LPTSTR lpFile, DWORD dwOtherSids)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidUsers = NULL, psidPowerUsers = NULL;
    PSID  psidEveryOne = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;
    BOOL bAddPowerUsersAce=TRUE;
    BOOL bAddEveryOneAce=FALSE;
    DWORD dwAccMask;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0, 0, 0, 0, 0, 0, &psidUsers)) {

         DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize authenticated users sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin))  +
            (2 * GetLengthSid (psidUsers))  +
            sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the power users sid, if required.
    // Don't fail if you don't get because it might not be available on DCs??
    //

    bAddPowerUsersAce = TRUE;
    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_POWER_USERS, 0, 0, 0, 0, 0, 0, &psidPowerUsers)) {

        DebugMsg((DM_WARNING, TEXT("AddPowerUserAce: Failed to initialize power users sid.  Error = %d"), GetLastError()));
        bAddPowerUsersAce = FALSE;
    }

    if (bAddPowerUsersAce)
        cbAcl += (2 * GetLengthSid (psidPowerUsers)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    //
    // Get the EveryOne sid, if required.
    //

    if (dwOtherSids & OTHERSIDS_EVERYONE) {
        bAddEveryOneAce = TRUE;
        if (!AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryOne)) {

            DebugMsg((DM_WARNING, TEXT("AddPowerUserAce: Failed to initialize everyone sid.  Error = %d"), GetLastError()));
            goto Exit;
        }
    }

    if (bAddEveryOneAce)
        cbAcl += (2 * GetLengthSid (psidEveryOne)) + (2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidUsers)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    if (bAddPowerUsersAce) {

        //
        // By default give read permissions, otherwise give modify permissions
        //

        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccMask, psidPowerUsers)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    if (bAddEveryOneAce) {
        aceIndex++;
        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidEveryOne)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }
    }

    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidUsers)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    if (bAddPowerUsersAce) {
        aceIndex++;
        dwAccMask = (dwOtherSids & OTHERSIDS_POWERUSERS) ? (FILE_ALL_ACCESS ^ (WRITE_DAC | WRITE_OWNER)):
                                                           (GENERIC_READ | GENERIC_EXECUTE);

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, dwAccMask, psidPowerUsers)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    if (bAddEveryOneAce) {
        aceIndex++;

        if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidEveryOne)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        if (!GetAce(pAcl, aceIndex, &lpAceHeader)) {
            DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
            goto Exit;
        }

        lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    }

    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Set the security
    //

    if (SetFileSecurity (lpFile, DACL_SECURITY_INFORMATION, &sd)) {
        bRetVal = TRUE;
    } else {
        DebugMsg((DM_WARNING, TEXT("MakeFileSecure: SetFileSecurity failed.  Error = %d"), GetLastError()));
    }



Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidUsers) {
        FreeSid(psidUsers);
    }

    if ((bAddPowerUsersAce) && (psidPowerUsers)) {
        FreeSid(psidPowerUsers);
    }

    if ((bAddEveryOneAce) && (psidEveryOne)) {
        FreeSid(psidEveryOne);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }

    return bRetVal;
}


//*************************************************************
//
//  GetSpecialFolderPath()
//
//  Purpose:    Gets the path to the requested special folder
//
//  Parameters: csid   - CSIDL of the special folder
//              lpPath - Path to place result in
//                       assumed to be MAX_PATH in size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetSpecialFolderPath (INT csidl, LPTSTR lpPath)
{
    BOOL            bResult = FALSE;
    PSHELL32_API    pShell32Api = NULL;
    HRESULT         hr = E_FAIL;

    if (SUCCEEDED(hr = HRESULT_FROM_WIN32(LoadShell32Api( &pShell32Api ))))
    {
        //
        // Ask the shell for the folder location
        //
        bResult = pShell32Api->pfnShGetSpecialFolderPath (NULL, lpPath, csidl, TRUE);
        if (!bResult)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("GetSpecialFolderPath : ShGetSpecialFolderPath failed, hr = %08X\n"), hr));
    }

    return bResult;
}


//*************************************************************
//
//  GetFolderPath()
//
//  Purpose:    Gets the path to the requested special folder
//
//  Parameters: csidl   - CSIDL of the special folder
//              lpPath - Path to place result in
//                       assumed to be MAX_PATH in size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL GetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath)
{
    BOOL            bResult = FALSE;
    PSHELL32_API    pShell32Api = NULL;
    HRESULT         hr = E_FAIL;

    if (SUCCEEDED(hr = HRESULT_FROM_WIN32(LoadShell32Api( &pShell32Api ))))
    {
        //
        // Ask the shell for the folder location
        //
        hr = pShell32Api->pfnShGetFolderPath (NULL,
                                 csidl | CSIDL_FLAG_CREATE,
                                 hToken,
                                 0,
                                 lpPath);
        bResult = SUCCEEDED ( hr );
    }
    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("GetFolderPath : ShGetFolderPath failed, hr = %08X\n"), hr));
    }

    return bResult;
}


//*************************************************************
//
//  SetFolderPath()
//
//  Purpose:    Sets the path to the requested special folder
//
//  Parameters: csidl   - CSIDL of the special folder
//              lpPath - Path
//                       assumed to be MAX_PATH in size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************
BOOL SetFolderPath (INT csidl, HANDLE hToken, LPTSTR lpPath)
{
    BOOL            bResult = FALSE;
    PSHELL32_API    pShell32Api = NULL;
    HRESULT         hr = E_FAIL;

    if (SUCCEEDED(hr = HRESULT_FROM_WIN32(LoadShell32Api( &pShell32Api ))))
    {
        //
        // Set the shell folder location
        //
        hr = pShell32Api->pfnShSetFolderPath (
                                 csidl | CSIDL_FLAG_DONT_UNEXPAND,
                                 hToken,
                                 0,
                                 lpPath);
        bResult = SUCCEEDED ( hr );
    }
    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("SetFolderPath : ShSetFolderPath failed, hr = %08X\n"), hr));
    }

    return bResult;
}


//*************************************************************
//
//  CenterWindow()
//
//  Purpose:    Centers a window on the screen
//
//  Parameters: hwnd    -   window handle to center
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/21/96     ericflo    Ported
//
//*************************************************************

void CenterWindow (HWND hwnd)
{
    RECT    rect;
    LONG    dx, dy;
    LONG    dxParent, dyParent;
    LONG    Style;

    // Get window rect
    GetWindowRect(hwnd, &rect);

    dx = rect.right - rect.left;
    dy = rect.bottom - rect.top;

    // Get parent rect
    Style = GetWindowLong(hwnd, GWL_STYLE);
    if ((Style & WS_CHILD) == 0) {

        // Return the desktop windows size (size of main screen)
        dxParent = GetSystemMetrics(SM_CXSCREEN);
        dyParent = GetSystemMetrics(SM_CYSCREEN);
    } else {
        HWND    hwndParent;
        RECT    rectParent;

        hwndParent = GetParent(hwnd);
        if (hwndParent == NULL) {
            hwndParent = GetDesktopWindow();
        }

        GetWindowRect(hwndParent, &rectParent);

        dxParent = rectParent.right - rectParent.left;
        dyParent = rectParent.bottom - rectParent.top;
    }

    // Centre the child in the parent
    rect.left = (dxParent - dx) / 2;
    rect.top  = (dyParent - dy) / 3;

    // Move the child into position
    SetWindowPos(hwnd, HWND_TOP, rect.left, rect.top, 0, 0, SWP_NOSIZE);
}

//*************************************************************
//
//  UnExpandSysRoot()
//
//  Purpose:    Unexpands the given path/filename to have %systemroot%
//              if appropriate
//
//  Parameters: lpFile    -  File to check
//              lpResult  -  Result buffer 
//              cchResult -  Result buffer size
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/23/96     ericflo    Created
//
//*************************************************************

BOOL UnExpandSysRoot(LPCTSTR lpFile, LPTSTR lpResult, DWORD cchResult)
{
    TCHAR szSysRoot[MAX_PATH];
    LPTSTR lpFileName;
    DWORD dwSysLen;
    HRESULT hr;


    //
    // Verbose Output
    //

    DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: Entering with <%s>"),
             lpFile ? lpFile : TEXT("NULL")));


    if (!lpFile || !*lpFile) {
        DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: lpFile is NULL, setting lpResult to a null string")));
        *lpResult = TEXT('\0');
        return TRUE;
    }


    //
    // If the first part of lpFile is the expanded value of %SystemRoot%
    // then we want to un-expand the environment variable.
    //

    hr = SafeExpandEnvironmentStrings (TEXT("%SystemRoot%"), szSysRoot, ARRAYSIZE(szSysRoot));
    
    if (FAILED(hr)) {
        DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: ExpandEnvironmentString failed with error %d, setting szSysRoot to %systemroot% "), GetLastError()));
        StringCchCopy(lpResult, cchResult, lpFile);
        return FALSE;
    }

    dwSysLen = lstrlen(szSysRoot);


    //
    // Make sure the source is long enough
    //

    if ((DWORD)lstrlen(lpFile) < dwSysLen) {
        StringCchCopy (lpResult, cchResult, lpFile);
        return TRUE;
    }


    if (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       szSysRoot, dwSysLen,
                       lpFile, dwSysLen) == CSTR_EQUAL) {

        //
        // The szReturn buffer starts with %systemroot%.
        // Actually insert %systemroot% in the result buffer.
        //

        StringCchCopy (lpResult, cchResult, TEXT("%SystemRoot%"));
        StringCchCat (lpResult, cchResult, (lpFile + dwSysLen));


    } else {

        //
        // The szReturn buffer does not start with %systemroot%
        // just copy in the original string.
        //

        StringCchCopy (lpResult, cchResult, lpFile);
    }


    DebugMsg((DM_VERBOSE, TEXT("UnExpandSysRoot: Leaving with <%s>"), lpResult));

    return TRUE;
}

//*************************************************************
//
//  AllocAndExpandEnvironmentStrings()
//
//  Purpose:    Allocates memory for and returns pointer to buffer containing
//              the passed string expanded.
//
//  Parameters: lpszSrc -   unexpanded string
//
//  Return:     Pointer to expanded string
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

LPTSTR AllocAndExpandEnvironmentStrings(LPCTSTR lpszSrc)
{
    LPTSTR String, Temp;
    LONG LengthAllocated;
    LONG LengthCopied;

    //
    // Pick a random buffer length, if it's not big enough reallocate
    // it and try again until it is.
    //

    LengthAllocated = lstrlen(lpszSrc) + 60;

    String = LocalAlloc(LPTR, LengthAllocated * sizeof(TCHAR));
    if (String == NULL) {
        DebugMsg((DM_WARNING, TEXT("AllocAndExpandEnvironmentStrings: Failed to allocate %d bytes for string"), LengthAllocated * sizeof(TCHAR)));
        return(NULL);
    }

    while (TRUE) {

        LengthCopied = ExpandEnvironmentStrings( lpszSrc,
                                                 String,
                                                 LengthAllocated
                                               );
        if (LengthCopied == 0) {
            DebugMsg((DM_WARNING, TEXT("AllocAndExpandEnvironmentStrings: ExpandEnvironmentStrings failed, error = %d"), GetLastError()));
            LocalFree(String);
            String = NULL;
            break;
        }

        //
        // If the buffer was too small, make it bigger and try again
        //

        if (LengthCopied > LengthAllocated) {

            Temp = LocalReAlloc(String, LengthCopied * sizeof(TCHAR), LMEM_MOVEABLE);

            if (Temp == NULL) {
                DebugMsg((DM_WARNING, TEXT("AllocAndExpandEnvironmentStrings: Failed to reallocate %d bytes for string"), LengthAllocated * sizeof(TCHAR)));
                LocalFree(String);
                String = NULL;
                break;
            }

            LengthAllocated = LengthCopied;
            String = Temp;

            //
            // Go back and try to expand the string again
            //

        } else {

            //
            // Success!
            //

            break;
        }

    }

    return(String);
}

//*************************************************************
//
//  IntToString
//
//  Purpose:    TCHAR version of itoa
//
//  Parameters: INT    i    - integer to convert
//              LPTSTR sz   - pointer where to put the result
//
//  Return:     void
//
//*************************************************************

void IntToString( INT i, LPTSTR sz) {
    TCHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = TEXT('\0');
}

//*************************************************************
//
//  IsUserAGuest()
//
//  Purpose:    Determines if the user is a member of the guest group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a guest
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              7/25/95     ericflo    Created
//
//*************************************************************

BOOL IsUserAGuest(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundGuests=FALSE;
    PSID pGuestSid=NULL, pDomainGuestSid=NULL, psidUser=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Guests sid.
    //

    Status = RtlAllocateAndInitializeSid(
               &authNT,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               DOMAIN_ALIAS_RID_GUESTS,
               0, 0, 0, 0, 0, 0,
               &pGuestSid
               );

    if (Status != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("IsUserAGuest: RtlAllocateAndInitializeSid failed with error 0x%x"), Status));
        goto Exit;
    }

    if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                      NULL, SecurityImpersonation, TokenImpersonation,
                      &hImpToken)) {
        DebugMsg((DM_WARNING, TEXT("IsUserAGuest: DuplicateTokenEx failed with error %d"), GetLastError()));
        hImpToken = NULL;
        goto Exit;
    }

    if (!CheckTokenMembership(hImpToken, pGuestSid, &FoundGuests)) {
        DebugMsg((DM_WARNING, TEXT("IsUserAGuest: CheckTokenMembership failed for GuestSid with error %d"), GetLastError()));
    }

    if (!FoundGuests) {
        //
        // Get the user's sid
        //

        psidUser = GetUserSid(hToken);

        if (!psidUser) {
            DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure:  Failed to get user sid")));
            goto Exit;
        }

        //
        // Create Domain Guests sid.
        //

        Status = GetDomainSidFromDomainRid(
                                           psidUser,
                                           DOMAIN_GROUP_RID_GUESTS,
                                           &pDomainGuestSid);

        if (Status != STATUS_SUCCESS) {
            DebugMsg((DM_WARNING, TEXT("IsUserAGuest: GetDomainSidFromDomainRid failed with error 0x%x"), Status));
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, pDomainGuestSid, &FoundGuests)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAGuest: CheckTokenMembership failed for DomainGuestSid with error %d"), GetLastError()));
        }
    }

    //
    // Tidy up
    //

Exit:

    if (pGuestSid)
        RtlFreeSid(pGuestSid);

    if (pDomainGuestSid)
        RtlFreeSid(pDomainGuestSid);

   if (psidUser)
       DeleteUserSid (psidUser);

    if (hImpToken)
        CloseHandle(hImpToken);

    return(FoundGuests);
}

//*************************************************************
//
//  IsUserAnAdminMember()
//
//  Purpose:    Determines if the user is a member of the administrators group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a admin
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              7/25/95     ericflo    Created
//
//*************************************************************

BOOL IsUserAnAdminMember(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundAdmins = FALSE;
    PSID AdminsDomainSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Admins domain sid.
    //


    Status = RtlAllocateAndInitializeSid(
               &authNT,
               2,
               SECURITY_BUILTIN_DOMAIN_RID,
               DOMAIN_ALIAS_RID_ADMINS,
               0, 0, 0, 0, 0, 0,
               &AdminsDomainSid
               );

    if (Status == STATUS_SUCCESS) {

        //
        // Test if user is in the Admins domain
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hImpToken)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnAdminMember: DuplicateTokenEx failed with error %d"), GetLastError()));
            FoundAdmins = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, AdminsDomainSid, &FoundAdmins)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnAdminmember: CheckTokenMembership failed for AdminsDomainSid with error %d"), GetLastError()));
            FoundAdmins = FALSE;
        }
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (AdminsDomainSid)
        RtlFreeSid(AdminsDomainSid);

    return(FoundAdmins);
}

//*************************************************************
//
//  IsUserALocalSystemMember()
//
//  Purpose:    Determines if the user is a member of the Local system group.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is a local system
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              9/22/00     santanuc   created
//
//*************************************************************

BOOL IsUserALocalSystemMember(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL FoundLocalSystem = FALSE;
    PSID LocalSystemSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Local system sid.
    //


    Status = RtlAllocateAndInitializeSid(
               &authNT,
               1,
               SECURITY_LOCAL_SYSTEM_RID,
               0, 0, 0, 0, 0, 0, 0,
               &LocalSystemSid
               );

    if (Status == STATUS_SUCCESS) {

        //
        // Test if user is in the Local system
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &hImpToken)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAGuest: DuplicateTokenEx failed with error %d"), GetLastError()));
            FoundLocalSystem = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, LocalSystemSid, &FoundLocalSystem)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnAdminmember: CheckTokenMembership failed for LocalSystemSid with error %d"), GetLastError()));
            FoundLocalSystem = FALSE;
        }
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (LocalSystemSid)
        RtlFreeSid(LocalSystemSid);

    return(FoundLocalSystem);
}

//*************************************************************
//
//  IsUserAnInteractiveUser()
//
//  Purpose:    Determines if the user is interactively logged on.
//
//  Parameters: hToken  -   User's token
//
//  Return:     TRUE if user is logged on interactively
//              FALSE if not
//  Comments:
//
//*************************************************************

BOOL IsUserAnInteractiveUser(HANDLE hToken)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    BOOL bInteractive = FALSE;
    PSID pInteractiveSid=NULL;
    HANDLE hImpToken = NULL;

    //
    // Create Admins domain sid.
    //

    if (AllocateAndInitializeSid(&authNT, 1, SECURITY_INTERACTIVE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &pInteractiveSid)) {

        //
        // Test if user is interactive 
        //

        if (!DuplicateTokenEx(hToken, TOKEN_IMPERSONATE | TOKEN_QUERY,
                          NULL, SecurityImpersonation, TokenImpersonation,
                          &hImpToken)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnInteractiveUser: DuplicateTokenEx failed with error %d"), GetLastError()));
            bInteractive = FALSE;
            hImpToken = NULL;
            goto Exit;
        }

        if (!CheckTokenMembership(hImpToken, pInteractiveSid, &bInteractive)) {
            DebugMsg((DM_WARNING, TEXT("IsUserAnInteractiveUser: CheckTokenMembership failed for InteractiveSid with error %d"), GetLastError()));
            bInteractive = FALSE;
        }
    }
    else {
        DebugMsg((DM_WARNING, TEXT("IsUserAnInteractiveUser: AllocateAndInitializeSid failed for InteractiveSid with error %d"), GetLastError()));
    }

    //
    // Tidy up
    //

Exit:

    if (hImpToken)
        CloseHandle(hImpToken);

    if (pInteractiveSid)
        FreeSid(pInteractiveSid);

    return(bInteractive);
}

//*************************************************************
//
//  CheckUserInMachineForest()
//
//  Purpose:    Determines if the user is from the same forest
//               as the computer this code is running on.
//
//  Parameters: hToken  -   User's token
//
//  Return:     ERROR_SUCCESS if successful
//              <error> code if not.
//  Comments:
//
//*************************************************************

DWORD CheckUserInMachineForest(HANDLE hToken, BOOL* pbInMachineForest)
{
    DWORD dwResult = ERROR_SUCCESS;
    HANDLE hOldToken = NULL;
    LPWSTR szUserDomainName = NULL;
    PDS_DOMAIN_TRUSTS pDomainTrusts = NULL;
    ULONG ulDomainCount = 0;
    ULONG ulCount = 0;

    if ( (hToken == NULL) || (pbInMachineForest == NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Default to this
    *pbInMachineForest = FALSE;

    // Query for the user's domain name
    if (!ImpersonateUser(hToken, &hOldToken))
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckUserInMachineForest: Failed to impersonate user with %d."), dwResult));
        goto Exit;
    }

    szUserDomainName = MyGetDomainDNSName ();

    RevertToUser(&hOldToken);

    if ( szUserDomainName == NULL )
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CheckUserInMachineForest: MyGetDomainName failed with %d."), dwResult));
        goto Exit;
    }

    // Now get the list of trusted domains for this machine
    dwResult = DsEnumerateDomainTrusts( NULL, DS_DOMAIN_IN_FOREST, &pDomainTrusts, &ulDomainCount );
    if ( dwResult != NO_ERROR )
    {
        pDomainTrusts = NULL;
        DebugMsg((DM_WARNING, TEXT("CheckUserInMachineForest: Failed to enumerate forest domains with %d."), dwResult));
        goto Exit;
    }

    dwResult = ERROR_SUCCESS;

    for ( ulCount = 0; ulCount < ulDomainCount; ulCount++ )
    {
        if ( DnsNameCompare_W(szUserDomainName, pDomainTrusts[ulCount].DnsDomainName) )
        {
            *pbInMachineForest = TRUE;
            goto Exit;
        }
    }

Exit:
    if ( szUserDomainName != NULL )
    {
        LocalFree( szUserDomainName );
    }

    if ( pDomainTrusts != NULL )
    {
        NetApiBufferFree( pDomainTrusts );
    }

    return dwResult;
}

//*************************************************************
//
//  MakeRegKeySecure()
//
//  Purpose:    Sets the security for the key give so that
//              the admin and os having full control with the
//              user having read / execute.
//
//  Parameters: hToken          -   User's token or null for "everyone"
//              hKeyRoot        -   Key to the root of the hive
//              lpKeyName       -   Key to secure
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/7/97      ericflo    Created
//
//*************************************************************

BOOL MakeRegKeySecure(HANDLE hToken, HKEY hKeyRoot, LPTSTR lpKeyName)
{
    DWORD Error, dwDisp;
    HKEY hSubKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;


    //
    // Create the security descriptor that will be applied to the key
    //

    if (hToken) {

        //
        // Get the user's sid
        //

        psidUser = GetUserSid(hToken);

        if (!psidUser) {
            DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure:  Failed to get user sid")));
            return FALSE;
        }

    } else {

        //
        // Get the authenticated users sid
        //

        if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                      0, 0, 0, 0, 0, 0, 0, &psidUser)) {

             DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure: Failed to initialize authenticated users sid.  Error = %d"), GetLastError()));
             return FALSE;
        }
    }


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ, psidUser)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for user.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for system.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to add ace for admin.  Error = %d"), GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, &lpAceHeader)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to get ace (%d).  Error = %d"), AceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_VERBOSE, TEXT("MakeRegKeySecure: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }


    //
    // Open the registry key
    //

    Error = RegCreateKeyEx(hKeyRoot,
                           lpKeyName,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           WRITE_DAC,
                           NULL,
                           &hSubKey,
                           &dwDisp);

    if (Error == ERROR_SUCCESS) {

        Error = RegSetKeySecurity (hSubKey, DACL_SECURITY_INFORMATION, &sd);

        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;
        } else {
            DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure: Failed to set security, error = %d"), Error));
        }

        RegCloseKey(hSubKey);

    } else {
        DebugMsg((DM_WARNING, TEXT("MakeRegKeySecure: Failed to open registry key, error = %d"), Error));
    }


Exit:

    //
    // Free the sids and acl
    //

    if (psidUser) {
            if (hToken) {
                DeleteUserSid (psidUser);
        } else {
                FreeSid (psidUser);
        }
    }

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    if (pAcl) {
        GlobalFree (pAcl);
    }


    return(bRetVal);
}

//*************************************************************
//
//  FlushSpecialFolderCache()
//
//  Purpose:    Flushes the special folder cache in the shell
//
//  Parameters: none
//
//  Comments:   Shell32.dll caches the special folder pidls
//              but since winlogon never goes away, it is possible
//              for one user's pidls to be used for another user
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

typedef VOID (*PFNSHFLUSHSFCACHE)(VOID);

BOOL FlushSpecialFolderCache (void)
{
    HINSTANCE hInstDLL;
    PFNSHFLUSHSFCACHE pfnSHFlushSFCache;
    BOOL bResult = FALSE;


    hInstDLL = LoadLibraryA ("shell32.dll");

    if (hInstDLL) {

        pfnSHFlushSFCache = (PFNSHFLUSHSFCACHE)GetProcAddress (hInstDLL,
                                       MAKEINTRESOURCEA(526));

        if (pfnSHFlushSFCache) {
            pfnSHFlushSFCache();
            bResult = TRUE;
        }

        FreeLibrary (hInstDLL);
    }

    return bResult;
}

//*************************************************************
//
//  CheckForVerbosePolicy()
//
//  Purpose:    Checks if the user has requested verbose
//              output of policy to the eventlog
//
//  Parameters: None
//
//  Return:     TRUE if we should be verbose
//              FALSE if not
//
//*************************************************************

BOOL CheckForVerbosePolicy (void)
{
    DWORD dwSize, dwType;
    BOOL bVerbose = FALSE;
    HKEY hKey;
    LONG lResult;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, DIAGNOSTICS_KEY,
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {

        dwSize = sizeof(bVerbose);
        if (RegQueryValueEx (hKey, DIAGNOSTICS_POLICY_VALUE, NULL,
                             &dwType, (LPBYTE) &bVerbose,
                             &dwSize) != ERROR_SUCCESS)
        {
            RegQueryValueEx (hKey, DIAGNOSTICS_GLOBAL_VALUE, NULL,
                             &dwType, (LPBYTE) &bVerbose, &dwSize);
        }

        RegCloseKey (hKey);
    }

    return bVerbose;
}


//*************************************************************
//
//  int ExtractCSIDL()
//
//  Purpose:    Extract the CSIDL from the given string which
//              should under the form ::0x0000::path1\path2\...\
//              pathn\file.ext, where 0x0000 is any valid CSIDL
//
//  Parameters: pcszPath  -     Path containing or not a CSIDL
//              ppszUsualPath - pointer to first characvter of
//                              usual path
//
//  Return:     CSIDL if successful
//              -1    if no CSIDL in path
//
//  Comments:   The ::0x0000:: must be at the beginning and not
//              preceded by any other character and not followed
//              by any either (other than the usual path)
//
//  History:    Date        Author     Comment
//              6/9/98      stephstm   Created
//
//*************************************************************
int ExtractCSIDL(LPCTSTR pcszPath, LPTSTR* ppszUsualPath)
{
    int nRV=-1;

    if (NULL != ppszUsualPath)
    {
        if (TEXT(':') == *pcszPath && TEXT(':') == *(pcszPath+1) &&
            TEXT(':') == *(pcszPath+8) && TEXT(':') == *(pcszPath+9))
        {//looks good
            //+4 to skip "::0x"
            nRV = HexStringToUInt(pcszPath+4);
            *ppszUsualPath = (LPTSTR)(pcszPath+10);
        }
        else
        {//no CSIDL in this path
            //the whole path is a usual path
            *ppszUsualPath = (LPTSTR)pcszPath;
        }
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("ExtractCSIDL:  ppszUsualPath ptr is NULL.")));
    }
    return nRV;
}

//*************************************************************
//
//  MyGetDomainDNSName()
//
//  Purpose:    Gets the user's domain dns name
//
//  Parameters: void
//
//  Return:     lpDomain if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetDomainDNSName (VOID)
{
    LPTSTR lpTemp, lpDomain;


    //
    // Get the username in DNS format. It will return it in
    // dnsdomainname\username
    //

    lpDomain = MyGetUserName (NameDnsDomain);

    if (!lpDomain) {
        DebugMsg((DM_WARNING, TEXT("MyGetDomainName:  MyGetUserName failed for dns domain name with %d"),
                 GetLastError()));
        return NULL;
    }


    //
    // Look for the \ between the domain and username and replace
    // it with a NULL
    //

    lpTemp = lpDomain;

    while (*lpTemp && ((*lpTemp) != TEXT('\\')))
        lpTemp++;


    if (*lpTemp != TEXT('\\')) {
        DebugMsg((DM_WARNING, TEXT("GetUserAndDomainNames:  Failed to find slash in dns style name:  <%s>"),
                 lpDomain));
        SetLastError(ERROR_INVALID_DATA);
        LocalFree (lpDomain);
        return NULL;
    }

    *lpTemp = TEXT('\0');


    return lpDomain;
}

//*************************************************************
//
//  MyGetUserName()
//
//  Purpose:    Gets the user name in the requested format
//
//  Parameters: NameFormat   - GetUserNameEx naming format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwCount = 0, dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;
    PSECUR32_API pSecur32;



    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to load Secur32.")));
        return NULL;
    }


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    while (TRUE) {

        if (pSecur32->pfnGetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {

            dwError = ERROR_SUCCESS;
            goto Exit;

        } else {

            //
            // Get the error code
            //

            dwError = GetLastError();


            //
            // If the call failed due to insufficient memory, realloc
            // the buffer and try again.  Otherwise, check the pass
            // count and retry if appropriate.
            //

            if ((dwError == ERROR_INSUFFICIENT_BUFFER) ||
                (dwError == ERROR_MORE_DATA)) {

                lpTemp = LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                                       LMEM_MOVEABLE);

                if (!lpTemp) {
                    dwError = GetLastError();
                    DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to realloc memory with %d"),
                             dwError));
                    LocalFree (lpUserName);
                    lpUserName = NULL;
                    goto Exit;
                }

                lpUserName = lpTemp;

            } else if ((dwError == ERROR_NONE_MAPPED) || (dwError == ERROR_NETWORK_UNREACHABLE)) {
                LocalFree (lpUserName);
                lpUserName = NULL;
                goto Exit;

            } else {

                DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserNameEx failed with %d."),
                         dwError));

                dwCount++;

                if (dwCount > 3) {
                    LocalFree (lpUserName);
                    lpUserName = NULL;
                    goto Exit;
                }

                DebugMsg((DM_VERBOSE, TEXT("MyGetUserName:  Retrying call to GetUserNameEx in 1/2 second.")));

                Sleep(500);
            }
        }
    }

Exit:

    SetLastError(dwError);

    return lpUserName;
}


//*************************************************************
//
//  MyGetUserNameEx()
//
//  Purpose:    Gets the user name in the requested format
//
//  Parameters: NameFormat   - GetUserNameEx naming format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetUserNameEx (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwCount = 0, dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;
    PSECUR32_API pSecur32;



    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        DebugMsg((DM_WARNING, TEXT("MyGetUserNameEx:  Failed to load Secur32.")));
        return NULL;
    }


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserNameEx:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    if (!pSecur32->pfnGetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

       if ((dwError != ERROR_INSUFFICIENT_BUFFER) && (dwError != ERROR_MORE_DATA)) {
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        } 


        lpTemp = LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                               LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserNameEx:  Failed to realloc memory with %d"),
                      dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        lpUserName = lpTemp;

        if (!pSecur32->pfnGetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {
            dwError = GetLastError();
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }

Exit:

    SetLastError(dwError);

    return lpUserName;
}


//*************************************************************
//
//  MyGetComputerName()
//
//  Purpose:    Gets the computer name in the requested format
//
//  Parameters: NameFormat  - GetComputerObjectName naming format
//
//  Return:     lpComputerName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetComputerName (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpComputerName = NULL, lpTemp;
    ULONG ulComputerNameSize;
    PSECUR32_API pSecur32;

    //
    // Load secur32.dll
    //

    pSecur32 = LoadSecur32();

    if (!pSecur32) {
        DebugMsg((DM_WARNING, TEXT("MyGetComputerName:  Failed to load Secur32.")));
        return NULL;
    }

    //
    // Allocate a buffer for the computer name
    //

    ulComputerNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulComputerNameSize = 200;
    }


    lpComputerName = LocalAlloc (LPTR, ulComputerNameSize * sizeof(TCHAR));

    if (!lpComputerName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetComputerName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the computer name in the requested format
    //

    if (!pSecur32->pfnGetComputerObjectName (NameFormat, lpComputerName, &ulComputerNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            LocalFree (lpComputerName);
            lpComputerName = NULL;
            goto Exit;
        }

        lpTemp = LocalReAlloc (lpComputerName, (ulComputerNameSize * sizeof(TCHAR)),
                               LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetComputerName:  Failed to realloc memory with %d"),
                     dwError));
            LocalFree (lpComputerName);
            lpComputerName = NULL;
            goto Exit;
        }


        lpComputerName = lpTemp;

        if (!pSecur32->pfnGetComputerObjectName (NameFormat, lpComputerName, &ulComputerNameSize)) {
            dwError = GetLastError();
            LocalFree (lpComputerName);
            lpComputerName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }


Exit:

    SetLastError(dwError);

    return lpComputerName;
}


//*************************************************************
//
//  ImpersonateUser()
//
//  Purpose:    Impersonates the specified user
//
//  Parameters: hToken - user to impersonate
//
//  Return:     hToken  if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser)
{
    DWORD dwErr;
    
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_READ, TRUE, hOldUser))
    {
        *hOldUser = NULL;
        dwErr = GetLastError();
        if (dwErr != ERROR_NO_TOKEN)
        {
            DebugMsg((DM_VERBOSE, TEXT("ImpersonateUser: Failed to open thread token with %d."), dwErr));
            return FALSE;
        }
    }

    if (!ImpersonateLoggedOnUser(hNewUser))
    {
        if ( *hOldUser )
        {
            CloseHandle( *hOldUser );
            *hOldUser = NULL;
        }
        DebugMsg((DM_VERBOSE, TEXT("ImpersonateUser: Failed to impersonate user with %d."), GetLastError()));
        return FALSE;
    }

    return TRUE;
}

//*************************************************************
//
//  RevertToUser()
//
//  Purpose:    Revert back to original user
//
//  Parameters: hUser  -  original user token
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RevertToUser (HANDLE *hUser)
{
    BOOL    bRetVal;

    bRetVal = SetThreadToken(NULL, *hUser);

    if (!bRetVal)
    {
        DebugMsg((DM_WARNING, TEXT("RevertToUser: SetThreadToken failed with %d."), GetLastError()));
    }

    if (*hUser)
    {
        CloseHandle (*hUser);
        *hUser = NULL;
    }

    return bRetVal;
}


//*************************************************************
//
//  GuidToString, StringToGuid, ValidateGuid, CompareGuid()
//
//  Purpose:    Guid utility functions
//
//*************************************************************

//
// Length in chars of string form of guid {44cffeec-79d0-11d2-a89d-00c04fbbcfa2}
//

#define GUID_LENGTH 38

void GuidToStringEx( const GUID *pGuid, TCHAR * szValue, UINT cchValue)
{
    StringCchPrintf( szValue, cchValue,
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
              pGuid->Data1,
              pGuid->Data2,
              pGuid->Data3,
              pGuid->Data4[0], pGuid->Data4[1],
              pGuid->Data4[2], pGuid->Data4[3],
              pGuid->Data4[4], pGuid->Data4[5],
              pGuid->Data4[6], pGuid->Data4[7] );
}


void GuidToString( const GUID *pGuid, TCHAR * szValue)
{

    //
    //  Assume the buffer is big enough (39 chars) to hold the string,
    //  try to use GuidToStringEx() instead!!!
    //
    StringCchPrintf( szValue, GUID_LENGTH + 1,
              TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
              pGuid->Data1,
              pGuid->Data2,
              pGuid->Data3,
              pGuid->Data4[0], pGuid->Data4[1],
              pGuid->Data4[2], pGuid->Data4[3],
              pGuid->Data4[4], pGuid->Data4[5],
              pGuid->Data4[6], pGuid->Data4[7] );
}


void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

BOOL ValidateGuidPrefix( TCHAR *szValue) 
// This function is different from ValidateGuid in only one case. szValue is checked to be prefixed with Guid.
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //
    
    // Fixing bug 570352
    
    DWORD i;

    if ( lstrlen(szValue) < GUID_LENGTH ) // this function is different from ValidateGuid here.
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }
   
    for ( i = 0; (i <= 37); i++ )
    {
        if ( i != 0 && i != 9 && i != 14 && i != 19 && i != 24 && i != 37 )
        {
            // it shld be between 0-9 or A-F or a-f
            if (szValue[i] >= L'0' && szValue[i] <= L'9')
                continue;

            if (szValue[i] >= L'a' && szValue[i] <= L'f') 
                continue;
                  
            if (szValue[i] >= L'A' && szValue[i] <= L'F')
                continue;

            return FALSE; // It is here because of invalid character in the string
        }
    }
    return TRUE;
}

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //
    
    // Fixing bug 570352
    
    DWORD i;

    if ( lstrlen(szValue) != GUID_LENGTH )
        return FALSE;

    
    return ValidateGuidPrefix(szValue);
}



INT CompareGuid( GUID * pGuid1, GUID * pGuid2 )
{
    INT i;

    if ( pGuid1->Data1 != pGuid2->Data1 )
        return ( pGuid1->Data1 < pGuid2->Data1 ? -1 : 1 );

    if ( pGuid1->Data2 != pGuid2->Data2 )
        return ( pGuid1->Data2 < pGuid2->Data2 ? -1 : 1 );

    if ( pGuid1->Data3 != pGuid2->Data3 )
        return ( pGuid1->Data3 < pGuid2->Data3 ? -1 : 1 );

    for ( i = 0; i < 8; i++ )
    {
        if ( pGuid1->Data4[i] != pGuid2->Data4[i] )
            return ( pGuid1->Data4[i] < pGuid2->Data4[i] ? -1 : 1 );
    }

    return 0;
}

//*************************************************************
//
//  RegCleanUpValue()
//
//  Purpose:    Removes the target value and if no more values / keys
//              are present, removes the key.  This function then
//              works up the parent tree removing keys if they are
//              also empty.  If any parent key has a value / subkey,
//              it won't be removed.
//
//  Parameters: hKeyRoot    -   Root key
//              lpSubKey    -   SubKey
//              lpValueName -   Value to remove
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName)
{
    TCHAR szDelKey[2 * MAX_PATH];
    LPTSTR lpEnd;
    DWORD dwKeys, dwValues;
    LONG lResult;
    HKEY hKey;


    //
    // Make a copy of the subkey so we can write to it.
    //

    if (FAILED(StringCchCopy (szDelKey, ARRAYSIZE(szDelKey), lpSubKey)))
    {
        DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to copy value name.")));
        return FALSE;
    }

    //
    // First delete the value
    //

    lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegDeleteValue (hKey, lpValueName);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult != ERROR_FILE_NOT_FOUND)
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to delete value <%s> with %d."), lpValueName, lResult));
                return FALSE;
            }
        }
    }

    //
    // Now loop through each of the parents.  If the parent is empty
    // eg: no values and no other subkeys, then remove the parent and
    // keep working up.
    //

    lpEnd = szDelKey + lstrlen(szDelKey) - 1;

    while (lpEnd >= szDelKey)
    {

        //
        // Find the parent key
        //

        while ((lpEnd > szDelKey) && (*lpEnd != TEXT('\\')))
            lpEnd--;


        //
        // Open the key
        //

        lResult = RegOpenKeyEx (hKeyRoot, szDelKey, 0, KEY_READ, &hKey);

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_FILE_NOT_FOUND)
            {
                goto LoopAgain;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to open key <%s> with %d."), szDelKey, lResult));
                return FALSE;
            }
        }

        //
        // See if there any any values / keys
        //

        lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL,
                         &dwValues, NULL, NULL, NULL, NULL);

        RegCloseKey (hKey);

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("RegCleanUpKey:  Failed to query key <%s> with %d."), szDelKey, lResult));
            return FALSE;
        }


        //
        // Exit now if this key has values or keys
        //

        if ((dwKeys != 0) || (dwValues != 0))
        {
            return TRUE;
        }

        RegDeleteKey (hKeyRoot, szDelKey);

LoopAgain:
        //
        // If we are at the beginning of the subkey, we can leave now.
        //

        if (lpEnd == szDelKey)
        {
            return TRUE;
        }


        //
        // There is a parent key.  Remove the slash and loop again.
        //

        if (*lpEnd == TEXT('\\'))
        {
            *lpEnd = TEXT('\0');
        }
    }

    return TRUE;
}

//*************************************************************
//
//  InitializePingCritSec()
//
//  Purpose:    Initializes a CRITICAL_SECTION for pinging
//              computers
//
//  Parameters: none
//
//
//  Return:     ERROR_SUCCESS if successful
//              An error if it fails.
//
//*************************************************************

DWORD InitializePingCritSec( void )
{
    CRITICAL_SECTION *pCritSec     = NULL;
    DWORD             result       = ERROR_SUCCESS;
    BOOL              fInitialized = FALSE;
    CRITICAL_SECTION *pInitial;

    // If the critical section already exists, return.
    if (g_PingCritSec != NULL)
        return ERROR_SUCCESS;

    // Allocate memory for the critial section.
    pCritSec = (CRITICAL_SECTION *) LocalAlloc( LMEM_FIXED,
                                                sizeof(CRITICAL_SECTION) );
    if (pCritSec == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    // Initialize the critical section.  Using the flag 0x80000000
    // preallocates the event so that EnterCriticalSection can only
    // throw timeout exceptions.
    __try
    {
        if (!InitializeCriticalSectionAndSpinCount( pCritSec, 0x80000000 ))
            result = GetLastError();
        else
            fInitialized = TRUE;
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        result = GetExceptionCode();
    }
    if (result != ERROR_SUCCESS)
        goto Exit;

    // Save the critical section.
    pInitial = (CRITICAL_SECTION *) InterlockedCompareExchangePointer(
        (void **) &g_PingCritSec, (void *) pCritSec, NULL );

    // If the InterlockedCompareExchange succeeded, don't free the
    // critical section just allocated.
    if (pInitial == NULL)
        pCritSec = NULL;

Exit:
    if (pCritSec != NULL)
    {
        if (fInitialized)
            DeleteCriticalSection( pCritSec );
        LocalFree( pCritSec );
    }
    return result;
}

//*************************************************************
//
//  ClosePingCritSec()
//
//  Purpose:    Closes the CRITICAL_SECTION for pinging
//              computers
//
//  Parameters: none
//
//
//  Return:     none
//
//*************************************************************

void ClosePingCritSec( void )
{
    if (g_PingCritSec != NULL)
    {
        DeleteCriticalSection( g_PingCritSec );
        LocalFree( g_PingCritSec );
        g_PingCritSec = NULL;
    }
}

#define PING_BUFFER_SIZE  2048

//*************************************************************
//
//  PingComputerEx()
//
//  Purpose:    Pings the specified computer to determine
//              what the data transfer rate is
//
//  Parameters: ipaddr  -  IP address of computer
//              ulSpeed -  Data transfer rate (see Notes below)
//              pdwAdapterIndex - index of the adapter that services
//              calls to the DC
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//  Notes:      For fast connections (eg: LAN), it isn't possible
//              to get accurate transfer rates since the response
//              time from the computer is less than 10ms.  In
//              this case, the function returns ERROR_SUCCESS and 
//              ulSpeed is set to maximum speed of network interface.  
//
//              This function will ping the computer 3 times with
//              no data and 3 times with 4K of data.  If the response
//              time from any of the pings is less than 10ms, the
//              function assumes this is a fast link (eg: LAN) and
//              returns with ulSpeed set to maximum speed of network 
//              interface.
//
//              If the pings respond in a time greater than 10ms,
//              the time of the second ping is subtracted from
//              the time of the first ping to determine the amount
//              of time it takes to move just the data.  This
//              is repeated for the 3 sets of pings.  Then the
//              average time is computed from the 3 sets of pings.
//              From the average time, the kbps is calculated.
//
//*************************************************************

DWORD WINAPI
PingComputerEx( ULONG ipaddr, ULONG *ulSpeed, DWORD* pdwAdapterIndex )
{
    DWORD            dwResult   = ERROR_SUCCESS;
    DWORD            i;
    DWORD            dwReplySize;
    HANDLE           icmpHandle = NULL;
    LPBYTE           lpReply    = NULL;
    PICMP_ECHO_REPLY pReplyStruct;
    ULONG            ulFirst;
    ULONG            ulSecond;
    ULONG            ulDiff;
    ULONG            ulTotal    = 0;
    ULONG            ulCount    = 0;
    PICMP_API        pIcmp;
    HRSRC            hJPEG;
    MIB_IFROW        mibIfRow;
    PIPHLPAPI_API    pIpHlpApi;
    HGLOBAL          hGlobalJPEG;

    dwResult = InitializePingCritSec();
    if (dwResult != ERROR_SUCCESS)
        return dwResult;
    EnterCriticalSection( g_PingCritSec );

    //
    // Load iphlpapi.dll
    //

    pIpHlpApi = LoadIpHlpApi();
    if ( !pIpHlpApi )
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer: iphlpapi.dll is not loaded, %d"), dwResult ));
        goto Exit;
    }

    //
    // Load the icmp api
    //

    dwResult = LoadIcmp( &pIcmp );

    if (dwResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to load icmp api.")));
        goto Exit;
    }


    //
    // Load the slow link data if appropriate
    //

    if (!g_lpTestData) {

        hJPEG = FindResource (g_hDllInstance, MAKEINTRESOURCE(IDB_SLOWLINK), TEXT("JPEG"));

        if (hJPEG) {

            hGlobalJPEG = LoadResource (g_hDllInstance, hJPEG);

            if (hGlobalJPEG) {
                g_lpTestData = LockResource (hGlobalJPEG);
            }
        }
    }


    if (!g_lpTestData) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to load slow link data.")));
        goto Exit;
    }


    //
    // Set default speed
    //
    ZeroMemory( &mibIfRow, sizeof( mibIfRow ) );

    //
    // get the interface index corr. to the interface that services traffic to ipaddr ( DC )
    //
    dwResult = pIpHlpApi->pfnGetBestInterface( ipaddr, &mibIfRow.dwIndex );
    if ( dwResult != NO_ERROR )
    {
        DebugMsg((DM_WARNING, TEXT("PingComputer: GetBestInterface with %d"), dwResult));
    }
    else
    {
        //
        // get information about the interface. We use the dwSpeed as the default speed of the link.
        //
        dwResult = pIpHlpApi->pfnGetIfEntry( &mibIfRow );
        if ( dwResult != NO_ERROR )
        {
            DebugMsg((DM_WARNING, TEXT("PingComputer: GetIfEntry with %d"), dwResult));
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer: Adapter speed %d bps"), mibIfRow.dwSpeed));
        }
    }

    if ( pdwAdapterIndex )
    {
        *pdwAdapterIndex = mibIfRow.dwIndex;
    }
    *ulSpeed = mibIfRow.dwSpeed/1024; // In kbps

    //
    // Allocate space for the receive buffer
    //

    dwReplySize = PING_BUFFER_SIZE + sizeof(ICMP_ECHO_REPLY) + 8;
    lpReply = LocalAlloc (LPTR, dwReplySize);

    if (!lpReply) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to allocate memory with %d"), dwResult));
        goto Exit;
    }


    //
    // Open the Icmp handle
    //

    icmpHandle = pIcmp->pfnIcmpCreateFile();

    if (icmpHandle == INVALID_HANDLE_VALUE) {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("PingComputer:  Failed to open handle with %d"), dwResult));
        goto Exit;
    }


    //
    // Loop through the 3 sets of pings
    //

    for (i = 0; i < 3; i++) {

        //
        // Initialize the return value
        //

        dwResult = ERROR_SUCCESS;


        //
        // First ping with no data
        //

        if (pIcmp->pfnIcmpSendEcho (icmpHandle, ipaddr, g_lpTestData, 0, NULL, lpReply,
                                dwReplySize, 5000) == 0) {

            dwResult = GetLastError();

            if (dwResult == IP_DEST_HOST_UNREACHABLE) {
                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer 0x%x not found"), (DWORD)ipaddr));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First send 0x%x failed with %d"), (DWORD)ipaddr, dwResult));
                continue;
            }
        }


        pReplyStruct = (PICMP_ECHO_REPLY) lpReply;

        if (pReplyStruct->Status != IP_SUCCESS) {

            if (pReplyStruct->Status == IP_DEST_HOST_UNREACHABLE) {

                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer not found")));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First send has a reply buffer failure of %d"), pReplyStruct->Status));
                continue;
            }
        }


        ulFirst = pReplyStruct->RoundTripTime;
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First time:  %d"), ulFirst));

        if (ulFirst < 10) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Fast link.  Exiting.")));
            goto Exit;
        }


        //
        // Second ping with dwSize data
        //

        if (pIcmp->pfnIcmpSendEcho (icmpHandle, ipaddr, g_lpTestData, PING_BUFFER_SIZE, NULL, lpReply,
                                dwReplySize, 5000) == 0) {

            dwResult = GetLastError();

            if (dwResult == IP_DEST_HOST_UNREACHABLE) {
                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer not found")));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second send failed with %d"), dwResult));
                continue;
            }
        }


        pReplyStruct = (PICMP_ECHO_REPLY) lpReply;

        if (pReplyStruct->Status != IP_SUCCESS) {

            if (pReplyStruct->Status == IP_DEST_HOST_UNREACHABLE) {

                dwResult = ERROR_BAD_NETPATH;
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Target computer not found")));
                goto Exit;

            } else {
                DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second send has a reply buffer failure of %d"), pReplyStruct->Status));
                continue;
            }
        }

        ulSecond = pReplyStruct->RoundTripTime;
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second time:  %d"), ulSecond));

        if (ulSecond < 10) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Fast link.  Exiting.")));
            goto Exit;
        }


        //
        // Study the results
        //

        if (ulFirst > ulSecond) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Second time less than first time.")));

        } else if (ulFirst == ulSecond) {
            DebugMsg((DM_VERBOSE, TEXT("PingComputer:  First and second times match.")));

        } else {
            ulTotal += (ulSecond - ulFirst);
            ulCount++;
        }
    }


    //
    // Study the results
    //

    if (ulTotal > 0) {

        ulTotal = (ulTotal / ulCount);
        *ulSpeed = ((((PING_BUFFER_SIZE * 2) * 1000) / ulTotal) * 8) / 1024;
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  Transfer rate:  %d Kbps  Loop count:  %d"),*ulSpeed, ulCount));
        dwResult = ERROR_SUCCESS;

    } else {
        DebugMsg((DM_VERBOSE, TEXT("PingComputer:  No data available")));
        dwResult = ERROR_UNEXP_NET_ERR;
    }


Exit:

    if (icmpHandle) {
        pIcmp->pfnIcmpCloseHandle (icmpHandle);
    }

    if (lpReply) {
        LocalFree (lpReply);
    }

    LeaveCriticalSection( g_PingCritSec );

    return dwResult;
}

DWORD WINAPI PingComputer (ULONG ipaddr, ULONG *ulSpeed)
{
    return PingComputerEx( ipaddr, ulSpeed, 0 );
}

//*************************************************************
//
//  GetDomainControllerInfo()
//
//  Purpose:    Wrapper for DsGetDcName().
//
//  Parameters:
//              pNetAPI32       - Net API entry points
//              szDomainName    - domain name
//              ulFlags         - flags, see DsGetDcName()
//              ppInfo          - see DOMAIN_CONTROLLER_INFO
//              pfSlow          - slow link?
//
//  Comments:
//
//
//  Return:     NO_ERROR if successful
//              Error code if an error occurs
//
//*************************************************************

DWORD GetDomainControllerInfo(  PNETAPI32_API pNetAPI32,
                                LPTSTR szDomainName,
                                ULONG ulFlags,
                                HKEY hKeyRoot,
                                PDOMAIN_CONTROLLER_INFO* ppInfo,
                                BOOL* pfSlow,
                                DWORD* pdwAdapterIndex )
{
    DWORD   dwResult;

    //
    //  get DC info.
    //
    dwResult = pNetAPI32->pfnDsGetDcName(   0,
                                            szDomainName,
                                            0,
                                            0,
                                            ulFlags,
                                            ppInfo);


    if ( dwResult == ERROR_SUCCESS ) {

        //
        // Check for slow link
        //
        dwResult = IsSlowLink(  hKeyRoot,
                                (*ppInfo)->DomainControllerAddress,
                                pfSlow,
                                pdwAdapterIndex );

        if ( dwResult != ERROR_SUCCESS ){

            //
            // force rediscovery to obtain a live DC
            //
            dwResult = pNetAPI32->pfnDsGetDcName(   0,
                                                    szDomainName,
                                                    0,
                                                    0,
                                                    ulFlags | DS_FORCE_REDISCOVERY,
                                                    ppInfo);
            if ( dwResult == ERROR_SUCCESS ) {

                //
                // re-evaluate link speed
                //
                dwResult = IsSlowLink(  hKeyRoot,
                                        (*ppInfo)->DomainControllerAddress,
                                        pfSlow,
                                        pdwAdapterIndex );
            }
        }
    }
    return dwResult;
}


//***************************************************************************
//
//  GetUserGuid
//
//  Purpose:    Allocates and returns a string representing the user guid of
//                the current user.
//
//  Parameters: hToken          -   user's token
//
//  Return:     szUserString is successful
//              NULL if an error occurs
//
//  Comments:   Note, this only works for domain accounts.  Local accounts
//              do not have GUIDs.
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************

LPTSTR GetUserGuid(HANDLE hToken)
{
    LPTSTR szUserGuid=NULL;
    HANDLE hOldToken;
    PSID    psidSystem = NULL, psidUser=NULL;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    BOOL    bImpersonated = FALSE;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("GetUserGuid: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    psidUser = GetUserSid(hToken);

    if (!psidUser) {
         DebugMsg((DM_WARNING, TEXT("GetUserGuid: Couldn't get user sid,  Error = %d"), GetLastError()));
         goto Exit;
    }

    if (EqualSid(psidUser, psidSystem)) {
         DebugMsg((DM_VERBOSE, TEXT("GetUserGuid: user sid matches local system, returning NULL"), GetLastError()));
         goto Exit;
    }


    //
    // impersonate the user and the get the user guid for this user.
    //

    if (!ImpersonateUser(hToken, &hOldToken)) {
        DebugMsg((DM_WARNING, TEXT("GetUserGuid: Failed to impersonate user with %d."), GetLastError()));
        goto Exit;
    }

    bImpersonated = TRUE;


    szUserGuid = MyGetUserNameEx(NameUniqueId);

    if (!szUserGuid) {
        if ((GetLastError() != ERROR_CANT_ACCESS_DOMAIN_INFO) &&
            (GetLastError() != ERROR_NONE_MAPPED)) {
            DebugMsg((DM_WARNING, TEXT("GetUserGuid: Failed to get user guid with %d."), GetLastError()));
        }
    }

Exit:
    if (bImpersonated)
        RevertToUser(&hOldToken);

    if (psidUser) {
        DeleteUserSid (psidUser);
    }

    if (psidSystem)
         FreeSid(psidSystem);

    return szUserGuid;
}



//***************************************************************************
//
//  GetOldSidString
//
//  Purpose:    Allocates and returns a string representing the old sid of
//                the current user by looking at the profile guid in the registry.
//
//  Parameters: hToken          -   user's token
//              lpKeyName       -   key to read
//
//  Return:     SidString is successful
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************

LPTSTR GetOldSidString(HANDLE hToken, LPTSTR lpKeyName)
{
    TCHAR szBuffer[MAX_PATH], *lpEnd;
    LPTSTR szUserGuid;
    DWORD dwSize=0, dwType;
    TCHAR *lpSidString = NULL;
    HKEY  hKey = NULL;
    LONG  lResult;
    DWORD dwErr;
    HRESULT hr;
    DWORD   cchEnd;


    //
    // get the prev last error
    //

    dwErr = GetLastError();

    szUserGuid = GetUserGuid(hToken);

    if (!szUserGuid) {
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Open the guid->sid mapping
    //

    hr = StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), lpKeyName);

    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    lpEnd = CheckSlashEx (szBuffer, ARRAYSIZE(szBuffer), &cchEnd);

    if (!lpEnd)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }
    
    hr = StringCchCopy(lpEnd, cchEnd, szUserGuid);

    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_VERBOSE, TEXT("GetOldSidString:  Failed to open profile profile guid key with error %d"), lResult));
        goto Exit;
    }

    //
    // Query for the Sid String, (size first)
    //

    lResult = RegQueryValueEx (hKey,
                               PROFILE_SID_STRING,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("GetOldSidString:  Failed to query size of SidString with error %d"), lResult));
        goto Exit;
    }

    lpSidString = LocalAlloc(LPTR, dwSize);

    if (!lpSidString) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("GetOldSidString:  Failed to allocate memory for SidString"), lResult));
        goto Exit;
    }

    lResult = RegQueryValueEx (hKey,
                               PROFILE_SID_STRING,
                               NULL,
                               &dwType,
                               (LPBYTE)lpSidString,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        dwErr = lResult;
        DebugMsg((DM_WARNING, TEXT("GetOldSidString:  Failed to query SidString with error %d"), lResult));
        LocalFree(lpSidString);
        lpSidString = NULL;
        goto Exit;
    }

Exit:
    if (szUserGuid)
        LocalFree(szUserGuid);

    if (hKey)
        RegCloseKey(hKey);

    SetLastError(dwErr);

    return lpSidString;
}

//***************************************************************************
//
//  SetOldSidString
//
//  Purpose:    Sets the old sid string corresp. to a user for the next domain
//              migration
//
//  Parameters: hToken          -   user's token
//              lpSidString     -   user's sid (in a string form)
//              lpKeyName       -   key to store
//
//  Return:     SidString is successful
//              NULL if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/14/95    ushaji     created
//***************************************************************************
BOOL SetOldSidString(HANDLE hToken, LPTSTR lpSidString, LPTSTR lpKeyName)
{
    TCHAR szBuffer[MAX_PATH+1], *lpEnd;
    DWORD dwSize=0, dwDisp = 0;
    HKEY  hKey = NULL;
    BOOL  bRetVal = TRUE;
    LONG lResult = 0;
    LPTSTR szUserGuid;
    DWORD dwErr;
    HRESULT hr;
    DWORD   cchEnd;

    //
    // get the prev last error
    //

    dwErr = GetLastError();

    szUserGuid = GetUserGuid(hToken);

    if (!szUserGuid) {
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Open the guid->sid mapping
    //

    hr = StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), lpKeyName);

    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    lpEnd = CheckSlashEx (szBuffer, ARRAYSIZE(szBuffer), &cchEnd);

    if (!lpEnd)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }
    
    hr = StringCchCopy(lpEnd, cchEnd, szUserGuid);

    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, 0, 0, KEY_READ | KEY_WRITE, NULL,
                            &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        dwErr = GetLastError();
        DebugMsg((DM_VERBOSE, TEXT("GetOldSidString:  Failed to open profile profile guid key with error %d"), lResult));
        goto Exit;
    }

    //
    // Set the Sid String
    //

    lResult = RegSetValueEx (hKey,
                             PROFILE_SID_STRING,
                             0,
                             REG_SZ,
                             (LPBYTE) lpSidString,
                             (lstrlen(lpSidString) + 1) * sizeof(TCHAR));

    if (lResult != ERROR_SUCCESS) {
        dwErr = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SetOldSidString:  Failed to set SidString with error %d"), lResult));
        goto Exit;
    }

    bRetVal = TRUE;

Exit:
    if (szUserGuid)
        LocalFree(szUserGuid);

    if (hKey)
        RegCloseKey(hKey);

    SetLastError(dwErr);

    return bRetVal;
}


//***************************************************************************
//
//  GetErrString
//
//  Purpose:    Calls FormatMessage to Get the error string corresp. to a error
//              code
//
//
//  Parameters: dwErr           -   Error Code
//              szErr           -   Buffer to return the error string (MAX_PATH)
//                                  is assumed.!!!
//
//  Return:     szErr
//
//  History:    Date        Author     Comment
//              4/28/99     ushaji     created
//***************************************************************************

LPTSTR GetErrString(DWORD dwErr, LPTSTR szErr)
{
    szErr[0] = TEXT('\0');

    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                  NULL, dwErr,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  szErr, MAX_PATH, NULL);

    return szErr;
}


//*************************************************************
//
//  GetMachineToken()
//
//  Purpose:    Gets the machine token
//
//  Parameters: none
//
//  Note:       This must be called from the LocalSystem context
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HANDLE GetMachineToken (void)
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS InitStatus;
    SECURITY_STATUS AcceptStatus;
    HANDLE hToken = NULL;
    PSecPkgInfo PackageInfo = NULL;
    BOOLEAN AcquiredServerCred = FALSE;
    BOOLEAN AcquiredClientCred = FALSE;
    BOOLEAN AcquiredClientContext = FALSE;
    BOOLEAN AcquiredServerContext = FALSE;
    CredHandle CredentialHandle2;
    CredHandle ServerCredHandleStorage;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    PCtxtHandle pServerContextHandle = NULL;
    PCtxtHandle pClientContextHandle = NULL;
    PCredHandle ServerCredHandle = NULL;
    TimeStamp Lifetime;
    DWORD dwSize;
    TCHAR szComputerName[MAX_PATH];
    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    PSecBufferDesc pChallengeDesc = NULL;
    SecBuffer ChallengeBuffer;
    LPBYTE pvBuffer = NULL;
    LPBYTE pvBuffer2 = NULL;
    ULONG ContextAttributes;
    PSECUR32_API pSecur32;
    HRESULT hr;


    //
    // Load pSecur32->dll
    //

    if ( !( pSecur32 = LoadSecur32 () ) ) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  Failed to load Secur32.")));
        SecStatus = GetLastError();
        return NULL;
    }


    //
    // Get the computer name
    //

    dwSize = ARRAYSIZE(szComputerName);

    if (!GetComputerName (szComputerName, &dwSize)) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken: Failed to get the computer name with %d"), GetLastError()));
        SecStatus = GetLastError();
        goto Exit;
    }

    hr = StringCchCat(szComputerName, ARRAYSIZE(szComputerName), TEXT("$"));

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken: Failed to append a '$'. ")));
        SecStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }


    //
    // Get the kerberos security package
    //

    SecStatus = pSecur32->pfnQuerySecurityPackageInfo( L"kerberos", &PackageInfo );

    if (SecStatus != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  QuerySecurityPackageInfo failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }


    //
    // Acquire a credential handle for the server side
    //

    ServerCredHandle = &ServerCredHandleStorage;

    SecStatus = pSecur32->pfnAcquireCredentialsHandle(
                    NULL,           // New principal
                    L"kerberos",    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    ServerCredHandle,
                    &Lifetime );

    if (SecStatus != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  AcquireCredentialsHandle for server failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }

    AcquiredServerCred = TRUE;


    //
    // Acquire a credential handle for the client side
    //

    SecStatus = pSecur32->pfnAcquireCredentialsHandle(
                    NULL,           // New principal
                    L"kerberos",    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if (SecStatus != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  AcquireCredentialsHandle for client failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }

    AcquiredClientCred = TRUE;


    //
    // Allocate buffers
    //

    pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken);

    if (!pvBuffer) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  LocalAlloc failed with %d"),
                 GetLastError()));
        SecStatus = GetLastError();
        goto Exit;
    }


    pvBuffer2 = LocalAlloc( 0, PackageInfo->cbMaxToken);

    if (!pvBuffer2) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  LocalAlloc failed with %d"),
                 GetLastError()));
        SecStatus = GetLastError();
        goto Exit;
    }


    while (TRUE) {

        //
        // Initialize the security context (client side)
        //

        NegotiateDesc.ulVersion = 0;
        NegotiateDesc.cBuffers = 1;
        NegotiateDesc.pBuffers = &NegotiateBuffer;

        NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
        NegotiateBuffer.pvBuffer = pvBuffer;

        InitStatus = pSecur32->pfnInitializeSecurityContext(
                        &CredentialHandle2,
                        pClientContextHandle,
                        szComputerName,
                        0,
                        0,                  // Reserved 1
                        SECURITY_NATIVE_DREP,
                        pChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &NegotiateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ((InitStatus != SEC_E_OK) && (InitStatus != SEC_I_CONTINUE_NEEDED)) {
            DebugMsg((DM_WARNING, TEXT("GetMachineToken:  InitializeSecurityContext failed with 0x%x"),
                     InitStatus));
            SecStatus = InitStatus;
            goto Exit;
        }

        pClientContextHandle = &ClientContextHandle;
        AcquiredClientContext = TRUE;


        //
        // Accept the server side context
        //

        NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
        ChallengeDesc.ulVersion = 0;
        ChallengeDesc.cBuffers = 1;
        ChallengeDesc.pBuffers = &ChallengeBuffer;

        ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
        ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
        ChallengeBuffer.pvBuffer = pvBuffer2;

        AcceptStatus = pSecur32->pfnAcceptSecurityContext(
                        ServerCredHandle,
                        pServerContextHandle,
                        &NegotiateDesc,
                        0,
                        SECURITY_NATIVE_DREP,
                        &ServerContextHandle,
                        &ChallengeDesc,
                        &ContextAttributes,
                        &Lifetime );


        if ((AcceptStatus != SEC_E_OK) && (AcceptStatus != SEC_I_CONTINUE_NEEDED)) {
            DebugMsg((DM_WARNING, TEXT("GetMachineToken:  AcceptSecurityContext failed with 0x%x"),
                     AcceptStatus));
            SecStatus = AcceptStatus;
            goto Exit;
        }

        AcquiredServerContext = TRUE;

        if (AcceptStatus == SEC_E_OK) {
            break;
        }

        pChallengeDesc = &ChallengeDesc;
        pServerContextHandle = &ServerContextHandle;

        DebugMsg((DM_VERBOSE, TEXT("GetMachineToken:  Looping for authentication again.")));
    }


    //
    // Get the server token
    //

    SecStatus = pSecur32->pfnQuerySecurityContextToken(&ServerContextHandle, &hToken);

    if ( SecStatus != STATUS_SUCCESS ) {
        DebugMsg((DM_WARNING, TEXT("GetMachineToken:  QuerySecurityContextToken failed with 0x%x"),
                 SecStatus));
        goto Exit;
    }

Exit:

    if (AcquiredClientContext) {
        pSecur32->pfnDeleteSecurityContext( &ClientContextHandle );
    }

    if (AcquiredServerContext) {
        pSecur32->pfnDeleteSecurityContext( &ServerContextHandle );
    }

    if (pvBuffer2) {
        LocalFree (pvBuffer2);
    }

    if (pvBuffer) {
        LocalFree (pvBuffer);
    }

    if (AcquiredClientCred) {
        pSecur32->pfnFreeCredentialsHandle(&CredentialHandle2);
    }

    if (AcquiredServerCred)
    {
        pSecur32->pfnFreeCredentialsHandle(ServerCredHandle);
    }

    if (PackageInfo) {
        pSecur32->pfnFreeContextBuffer(PackageInfo);
    }

    if (!hToken) {
        SetLastError(SecStatus);
    }

    return hToken;
}

//*************************************************************
//
//  IsNullGUID()
//
//  Purpose:    Determines if the passed in GUID is all zeros
//
//  Parameters: pguid   GUID to compare
//
//  Return:     TRUE if the GUID is all zeros
//              FALSE if not
//
//*************************************************************

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}

//*************************************************************
//
//  GetMachineRole()
//
//  Purpose:    Determines the role of the machine
//              server vs workstation vs standalone
//
//  Parameters: piRole -  Receives the simple role number
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetMachineRole (LPINT piRole)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic;
    DWORD dwResult;
    PNETAPI32_API pNetAPI32;


    //
    // Check the cached value first
    //

    if (g_iMachineRole != -1) {
        *piRole = g_iMachineRole;
        return TRUE;
    }


    //
    // Load netapi32
    //

    pNetAPI32 = LoadNetAPI32();

    if (!pNetAPI32) {
        DebugMsg((DM_WARNING, TEXT("GetMachineRole:  Failed to load netapi32 with %d."),
                 GetLastError()));
        return FALSE;
    }


    //
    // Ask for the role of this machine
    //

    dwResult = pNetAPI32->pfnDsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,
                                                               (PBYTE *)&pBasic);


    if (dwResult != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetMachineRole:  DsRoleGetPrimaryDomainInformation failed with %d."),
                 dwResult));
        return FALSE;
    }


    //
    // Convert the role into a simple machine role
    //

    if ((pBasic->MachineRole == DsRole_RoleStandaloneWorkstation) ||
        (pBasic->MachineRole == DsRole_RoleStandaloneServer)) {

        *piRole = 0;   // standalone machine not in a DS domain

    } else {

        if (pBasic->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT) {

            if (!IsNullGUID(&pBasic->DomainGuid)) {

                *piRole = 2;   // machine is a member of a domain with DS support

                if ((pBasic->MachineRole == DsRole_RoleBackupDomainController) ||
                    (pBasic->MachineRole == DsRole_RolePrimaryDomainController)) {
                    *piRole = 3;  // machine is a domain controller
                }
            } else {
                *piRole = 1;   // machine is a member of a NT4 domain
            }

        } else {
            *piRole = 1;   // machine is a member of a domain without DS support
        }
    }

    pNetAPI32->pfnDsRoleFreeMemory (pBasic);


    //
    // Save this value in the cache for future use
    //

    g_iMachineRole = *piRole;

    return TRUE;
}



//*************************************************************
//
//  IsUNCPath()
//
//  Purpose:    Is the given path a UNC path
//
//  Parameters: lpPath  -   Path to check
//
//  Return:     TRUE if the path is UNC
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL IsUNCPath(LPCTSTR lpPath)
{

    if ((!lpPath) || (!lpPath[0]) && (!lpPath[1]))
        return FALSE;

    if (lpPath[0] == TEXT('\\') && lpPath[1] == TEXT('\\')) {
        return(TRUE);
    }
    return(FALSE);
}


//*************************************************************
//
//  MakePathUNC()
//
//  Purpose:    Makes the given path UNC s.t. it can be accessed from a remote machine..
//              if the path contains %systemroot% expanded then it substitutes
//              \\machname\admin$ otherwise \\machname\<driveletter>$
//
//  Parameters: lpPath          -   Input Path (needs to be absolute)
//              szComputerName  -   Name of the computer on which this is the local path
//
//  Return:     Path if it was fone successfully
//              NULL if not
//
//  Comments:
//
//
//*************************************************************

LPTSTR MakePathUNC(LPTSTR pwszFile, LPTSTR szComputerName)
{
    LPTSTR szUNCPath=NULL;
    TCHAR szSysRoot[MAX_PATH];
    DWORD dwSysLen;
    LPTSTR lpEnd = NULL;
    DWORD cchUNCPath;
    DWORD cchEnd;
    HRESULT hr;


    DebugMsg((DM_VERBOSE, TEXT("MakePathUNC: Entering with <%s>"),
             pwszFile ? pwszFile : TEXT("NULL")));

    cchUNCPath = lstrlen(pwszFile)+lstrlen(szComputerName)+3+lstrlen(TEXT("admin$"))+1;
    szUNCPath = LocalAlloc(LPTR, sizeof(TCHAR)*cchUNCPath);

    if (!szUNCPath)
        return NULL;

    if (!pwszFile || !*pwszFile) {
        DebugMsg((DM_VERBOSE, TEXT("MakePathUNC: lpFile is NULL, setting lpResult to a null string")));
        *szUNCPath = TEXT('\0');
        return szUNCPath;
    }


    if (IsUNCPath(pwszFile)) {
        StringCchCopy(szUNCPath, cchUNCPath, pwszFile);
        return szUNCPath;
    }


    StringCchCopy(szUNCPath, cchUNCPath, TEXT("\\\\"));
    StringCchCat(szUNCPath, cchUNCPath, szComputerName);


    //
    // If the first part of lpFile is the expanded value of %SystemRoot%
    //

    if (FAILED(SafeExpandEnvironmentStrings (TEXT("%SystemRoot%"), szSysRoot, MAX_PATH))) {
        DebugMsg((DM_WARNING, TEXT("MakePathUNC: ExpandEnvironmentString failed with error %d, setting szSysRoot to %systemroot% "), GetLastError()));
        LocalFree(szUNCPath);
        return NULL;
    }


    dwSysLen = lstrlen(szSysRoot);
    lpEnd = CheckSlashEx(szUNCPath, cchUNCPath, &cchEnd);


    //
    // if the prefix is the same as expanded systemroot then..
    //

    if (((DWORD)lstrlen(pwszFile) > dwSysLen) &&
        (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                       szSysRoot, dwSysLen,
                       pwszFile, dwSysLen) == CSTR_EQUAL)) {

        StringCchCat(szUNCPath, cchUNCPath, TEXT("admin$"));
        StringCchCat(szUNCPath, cchUNCPath, pwszFile+dwSysLen);
    }
    else {

        if (pwszFile[1] != TEXT(':')) {
            DebugMsg((DM_WARNING, TEXT("MakePathUNC: Input path %s is not an absolute path"), pwszFile));
            StringCchCat(szUNCPath, cchUNCPath, pwszFile);
            return szUNCPath;
        }

        if (cchEnd > 2)
        {
            lpEnd[0] = pwszFile[0];
            lpEnd[1] = TEXT('$');
            lpEnd[2] = TEXT('\0');

            StringCchCat(szUNCPath, cchUNCPath, pwszFile+2);
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("MakePathUNC: Returning a UNCPath of %s"), szUNCPath));

    return szUNCPath;
}


//*************************************************************
//
//  SupportLongFileName()
//
//  Purpose:    Prepends lpDir with \\?\UNC\ or \\?\ depending on
//              whether lpDir is a UNC path or local path. Before
//              prepending this function converts relative path or 
//              absolute path started with a slash to corresponding
//              absolute path containing drive letter.
//
//  Parameters: lpDir         -   Directory
//              lpWrkDirSize  -   Size of the returned buffer in unit
//                                of TCHAR
//
//  Return:     LPTSTR pointing to prepended dir/file
//              NULL if fail to allocate memory
//
//  Comments:   Prepending with \\?\UNC\ or \\?\ allows all file api's
//              to handle file name > MAX_PATH.
//
//  History:    Date        Author     Comment
//              8/8/00      santanuc   Created
//
//*************************************************************

LPTSTR SupportLongFileName (LPTSTR lpDir, LPDWORD lpWrkDirSize)
{
    LPTSTR lpWrkDir = NULL;

    *lpWrkDirSize = lstrlen(lpDir)+2*MAX_PATH;
    lpWrkDir = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)**lpWrkDirSize);

    if (!lpWrkDir) {
        DebugMsg((DM_WARNING, TEXT("EnableLongFileNameDeletion: Failed to Allocate memory.  Error = %d"),
                GetLastError()));
        return NULL;
    }

    if ( IsUNCPath(lpDir) ) {
        // lpDir is of the form \\computername\...
        StringCchCopy(lpWrkDir, *lpWrkDirSize, c_szUNCFilePrefix);
        StringCchCat(lpWrkDir, *lpWrkDirSize, lpDir+2);
    }

    else if ( *CharNext(lpDir) == TEXT(':') ) {
        // Local storage specified with drive name
        StringCchCopy(lpWrkDir, *lpWrkDirSize, c_szLocalFilePrefix);
        StringCchCat(lpWrkDir, *lpWrkDirSize, lpDir);
    }

    else if ( *lpDir == TEXT('\\') ) {
        DWORD dwSize;

        // Prepend lpDir with c_szLocalFilePrefix followed by current drive as DeleteFile function requires 
        // drive name to delete files from local storage with path name > MAX_PATH
        StringCchCopy(lpWrkDir, *lpWrkDirSize, c_szLocalFilePrefix);
        dwSize = GetCurrentDirectory(*lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen);

        if (dwSize == 0) {
            DebugMsg((DM_VERBOSE, TEXT("DelNode: GetCurrentDirectory failed with error %d"), GetLastError()));
            // proceed to delete lpDir without long file name deletion feature
            StringCchCopy(lpWrkDir, *lpWrkDirSize, lpDir);
        }
        else {

            if (dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen) {

                // Extend lpWrkDir to accomodate current directory name with drive
                LocalFree(lpWrkDir);
                *lpWrkDirSize = dwSize+c_dwLocalFilePrefixLen;
                lpWrkDir = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)**lpWrkDirSize);
                if (!lpWrkDir) {
                    DebugMsg((DM_WARNING, TEXT("Delnode: Failed to Allocate memory.  Error = %d"), GetLastError()));
                    return NULL;
                }

                StringCchCopy(lpWrkDir, *lpWrkDirSize, c_szLocalFilePrefix);
                dwSize = GetCurrentDirectory(*lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen);

                if (dwSize == 0 || dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen) {
                    DebugMsg((DM_VERBOSE, TEXT("DelNode: GetCurrentDirectory 2nd call failed with error %d"), GetLastError()));
                    // proceed to delete lpDir without long file name deletion feature
                    StringCchCopy(lpWrkDir, *lpWrkDirSize, lpDir);
                }

                else {
                    // Copy lpDir after c_szLocalFilePrefix and drive name
                    StringCchCopy(lpWrkDir+c_dwLocalFilePrefixLen+2, *lpWrkDirSize-c_dwLocalFilePrefixLen-2, lpDir);
                }        
            
            }
            else {               
                // Copy lpDir after c_szLocalFilePrefix and drive name
                StringCchCopy(lpWrkDir+c_dwLocalFilePrefixLen+2, *lpWrkDirSize-c_dwLocalFilePrefixLen-2, lpDir);
            }
        }
    }
    else {

        LPTSTR szFileName;
        DWORD dwSize;

        // Relative path name specified. So Prepend lpDir with c_szLocalFilePrefix followed by the current directory
        StringCchCopy(lpWrkDir, *lpWrkDirSize, c_szLocalFilePrefix);
        dwSize = GetFullPathName(lpDir, *lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen, &szFileName);
        if ( dwSize == 0 ) {
            DebugMsg((DM_VERBOSE, TEXT("DelNode: GetFullPathName failed with error %d"), GetLastError()));
            // proceed to delete lpDir without long file name deletion feature
            StringCchCopy(lpWrkDir, *lpWrkDirSize, lpDir);
        }
        else {

            if ( dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen ) {

                // Extend lpWrkDir to accomodate absolute path name
                LocalFree(lpWrkDir);
                *lpWrkDirSize = dwSize+2*MAX_PATH;
                lpWrkDir = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)**lpWrkDirSize);
                if (!lpWrkDir) {
                    DebugMsg((DM_WARNING, TEXT("Delnode: Failed to Allocate memory.  Error = %d"), GetLastError()));
                    return NULL;
                }

                StringCchCopy(lpWrkDir, *lpWrkDirSize, c_szLocalFilePrefix);
                dwSize = GetFullPathName(lpDir, *lpWrkDirSize-c_dwLocalFilePrefixLen, lpWrkDir+c_dwLocalFilePrefixLen, &szFileName);
                if (dwSize == 0 || dwSize > *lpWrkDirSize-c_dwLocalFilePrefixLen) {
                    DebugMsg((DM_VERBOSE, TEXT("DelNode: GetFullPathName 2nd call failed with error %d"), GetLastError()));
                    // proceed to delete lpDir without long file name deletion feature
                    StringCchCopy(lpWrkDir, *lpWrkDirSize, lpDir);
                }
            }
        }
    }

    return lpWrkDir;
}

            

//*************************************************************
//
//  SecureNestedDir_Recurse()
//
//  Purpose:    Recursive function for securing nested dirs/files
//
//  Parameters: lpDir   -   Full Directory Path. 
//              dwSize  -   Allocated size of the working buffer
//              pDirSd  -   Security descriptor to be applied with dirs
//              pFileSd -   Security descriptor to be applied with files
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//
//
//*************************************************************

BOOL SecureNestedDir_Recurse (LPTSTR lpDir, DWORD dwSize, PSECURITY_DESCRIPTOR pDirSd, PSECURITY_DESCRIPTOR pFileSd)
{
    BOOL bOwn = FALSE, bRetVal = FALSE;
    LPTSTR lpEnd = NULL, lpWrkDir = NULL;
    WIN32_FIND_DATA *pfd = NULL;
    HANDLE hFile;
    DWORD dwWrkDirSize;
    DWORD cchEnd;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir_Recurse: Entering, lpDir = <%s>"), lpDir));


    //
    // Each filename or a directory has to be less than MAX_PATH in the worst case.
    // So make sure that we have at least MAX_PATH + 2 (for a slash and '\0'
    // space left in the working buffer case.
    //
    // In the normal case, when we have a path of length ~MAX_PATH it will do only 
    // 1 allocation
    //


    if ((DWORD)(lstrlen(lpDir) + MAX_PATH+2) > (dwSize)) {
        
        dwWrkDirSize = dwSize+2*MAX_PATH;
        lpWrkDir = (LPWSTR)LocalAlloc(LPTR, dwWrkDirSize*sizeof(TCHAR));
        if (!lpWrkDir) {
            DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Couldn't allocate memory for working buffer. Error - %d"), GetLastError()));
            goto Exit;
        }

        StringCchCopy(lpWrkDir, dwWrkDirSize, lpDir);
        bOwn = TRUE;

    }
    else {
        lpWrkDir = lpDir;
        dwWrkDirSize = dwSize;
    }

    //
    //  Allocate WIN32_FIND_DATA in the heap to save stack space
    //
    pfd = (WIN32_FIND_DATA*) LocalAlloc (LPTR, sizeof(WIN32_FIND_DATA));
    if (!pfd)
    {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Couldn't allocate memory for WIN32_FIND_DATA. Error - %d"), GetLastError()));
        goto Exit;
    }

    //
    // Attach a Slash the end if required
    //

    lpEnd = CheckSlashEx(lpWrkDir, dwWrkDirSize, &cchEnd);
    StringCchCopy(lpEnd, cchEnd, c_szStarDotStar);

    //
    // Find the first file
    //

    hFile = FindFirstFile(lpWrkDir, pfd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ((GetLastError() == ERROR_FILE_NOT_FOUND) || (GetLastError() == ERROR_PATH_NOT_FOUND)) {
            bRetVal = TRUE;
            goto Exit;
        } else {
            DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: FindFirstFile failed.  Error = %d"),
                     GetLastError()));
            goto Exit;
        }
    }


    do {
        //
        //  Verbose output
        //

        DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir_Recurse: FindFile found:  <%s>"), pfd->cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(pfd->cFileName, c_szDot)) {
            continue;
        }

        if (!lstrcmpi(pfd->cFileName, c_szDotDot)) {
            continue;
        }

        StringCchCopy(lpEnd, cchEnd, pfd->cFileName);


        if (pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for reparse point, don't recurse into it.
            //
            if (pfd->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: a reparse point was found: <%s>, will not recurse into it."), lpWrkDir));
            }
            else
            {
                SecureNestedDir_Recurse(lpWrkDir, dwWrkDirSize, pDirSd, pFileSd);
                //
                // ignore errors and go ahead..
                //
                StringCchCopy(lpEnd, cchEnd, pfd->cFileName);
            }

            if (!SetFileSecurity (lpWrkDir, DACL_SECURITY_INFORMATION, pDirSd)) {
                DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Failed to secure directory <%s>.  Error = %d"),
                          lpWrkDir, GetLastError()));
            }

        } else {

            //
            // We found a file.  Try to secure it
            //

            if (!SetFileSecurity (lpWrkDir, DACL_SECURITY_INFORMATION, pFileSd)) {
                DebugMsg((DM_WARNING, TEXT("SecureNestedDir_Recurse: Failed to secure file <%s>.  Error = %d"),
                          pfd->cFileName, GetLastError()));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, pfd));


    //
    // Close the search handle
    //

    FindClose(hFile);

    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir_Recurse: Leaving <%s>"), lpDir));

    bRetVal = TRUE;

Exit:
    if (pfd)
        LocalFree(pfd);
        
    if (bOwn) 
        LocalFree(lpWrkDir);
    
    return bRetVal;
}


//*************************************************************
//
//  SecureNestedDir()
//
//  Purpose:    Secure the dir and nested dirs(files) with input
//              SECURITY_DESCRIPTOR.
//
//  Parameters: lpDir   -   Directory
//              pDirSd  -   Security descriptor to be applied with dirs.
//              pFileSd -   Security descriptor to be applied with files. 
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  History:    Date        Author     Comment
//              8/8/00      santanuc   Created
//
//*************************************************************

BOOL SecureNestedDir (LPTSTR lpDir, PSECURITY_DESCRIPTOR pDirSd, PSECURITY_DESCRIPTOR pFileSd)
{
    LPTSTR lpWrkDir = NULL;
    DWORD  dwWrkDirSize;
    BOOL   bRetVal = FALSE;

    lpWrkDir = SupportLongFileName(lpDir, &dwWrkDirSize);

    if (!lpWrkDir) {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir: Failed to Allocate memory.  Error = %d"),
                GetLastError()));
        goto Exit;
    }

    if (!SecureNestedDir_Recurse (lpWrkDir, dwWrkDirSize, pDirSd, pFileSd)) {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir: SecureNestedDir recurse failed with error %d"),
                GetLastError()));
    }
        
    if (!SetFileSecurity (lpDir, DACL_SECURITY_INFORMATION, pDirSd)) {
        DebugMsg((DM_WARNING, TEXT("SecureNestedDir: SetFileSecurity failed.  Error = %d"), GetLastError()));
        goto Exit;
    }

    bRetVal = TRUE;

    DebugMsg((DM_VERBOSE, TEXT("SecureNestedDir: Secure directory <%s> successfully."), lpDir));

Exit:
    
    if (lpWrkDir) {
        LocalFree(lpWrkDir);
    }

    return bRetVal;
}


//*************************************************************
//
//  SetEnvironmentVariableInBlock()
//
//  Purpose:    Sets the environment variable in the given block
//
//  Parameters: pEnv        -   Environment block
//              lpVariable  -   Variables
//              lpValue     -   Value
//              bOverwrite  -   Overwrite
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/21/96     ericflo    Ported
//
//*************************************************************

BOOL SetEnvironmentVariableInBlock(PVOID *pEnv, LPTSTR lpVariable,
                                   LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;
    DWORD cb;
    LPTSTR szValue = NULL;

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpVariable);

    cb = 1025 * sizeof(WCHAR);
    Value.Buffer = LocalAlloc(LPTR, cb);
    if (Value.Buffer) {
        Value.Length = 0;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);

        LocalFree(Value.Buffer);

        if ( NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }

    szValue = (LPTSTR)LocalAlloc(LPTR, 1024*sizeof(TCHAR));
    if (!szValue) {
        DebugMsg((DM_WARNING, TEXT("SetEnvironmentVariableInBlock: Out of memory")));
        return FALSE;
    }

    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpVariable, -1, TEXT("TEMP"), -1) == CSTR_EQUAL || 
             CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpVariable, -1, TEXT("TMP") , -1) == CSTR_EQUAL ) {

             DWORD dwLength = GetShortPathName (lpValue, szValue, 1024);
             if (!dwLength || dwLength > 1024) {
                 StringCchCopy (szValue, 1024, lpValue);
             }
        } else {
            StringCchCopy (szValue, 1024, lpValue);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable(pEnv, &Name, NULL);
    }

    LocalFree(szValue);
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}

/***************************************************************************\
* ExpandUserEvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
DWORD
ExpandUserEnvironmentStrings(
    PVOID pEnv,
    LPCTSTR lpSrc,
    LPTSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;

    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(nSize*sizeof(WCHAR));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( pEnv,
                                          (PUNICODE_STRING)&Source,
                                          (PUNICODE_STRING)&Destination,
                                          &Length
                                        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length / sizeof(WCHAR) );
        }
    else {
        return( 0 );
        }
}


//*************************************************************
//
//  ConvertToShareName()
//
//  Purpose:    Convert the UNC path of a file\dir to a share
//
//  Parameters: lpShare  : Full UNC path of file\dir
//
//  Return:     None.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/21/00     santanuc   Created
//
//*************************************************************
LPTSTR ConvertToShareName(LPTSTR lpShare)
{
    BOOL bShareName = FALSE;

    lpShare += 2;   // Skip initial two slashes
    while ((!bShareName || *lpShare != TEXT('\\')) && *lpShare != TEXT('\0')) {
        if (*lpShare == TEXT('\\'))
            bShareName = TRUE;
        lpShare++;
    }

    if (*lpShare == TEXT('\\')) {
        *lpShare = TEXT('\0');
        return lpShare+1;
    }
   
    return NULL;
}


//*************************************************************
//
//  AbleToBypassCSC()
//
//  Purpose:    Try to bypass CSC using a secret api. 
//
//  Parameters: hTokenUser         -  User's token
//              lpDir              -  Roaming profile dir
//              lppCscBypassedPath -  Path name with mapped drive (OUT)
//              cpDrive            -  Mapped drive (OUT)
//
//  Return:     ERROR_SUCCESS if successful
//              Error code if an error occurs
//
//  Comments:   We will always bypass csc for roaming share. 
//              There are two reason behind this :
//                o csc mark entire server offline even if only 
//                  one share goes offline. This is a bad design 
//                  from csc perspective and they need to fix it
//                o If csc is turned on in the roaming share server
//                  then both csc and profile will try to sync files
//                  on top of one another and we will be in a inconsistent 
//                  state
//
//  History:    Date        Author     Comment
//              10/29/00    santanuc   Created
//
//*************************************************************
DWORD AbleToBypassCSC(HANDLE hTokenUser, LPCTSTR lpDir, LPTSTR *lppCscBypassedPath, TCHAR *cpDrive)
{
    NETRESOURCE     sNR;
    LPTSTR          lpShare = NULL;
    BOOL            bIsDfsConnect = FALSE, bRetValue = FALSE;
    DWORD           dwFlags = 0, dwError;
    HANDLE          hOldToken;
    WIN32_FIND_DATA fd;
    HANDLE          hResult;
    LPTSTR          lpFileName;
    BOOL            bImpersonated = FALSE;
    DWORD           cchShare;
    DWORD           cchCscBypassedPath;
    
    DebugMsg((DM_VERBOSE, TEXT("AbleToBypassCSC: Try to bypass CSC")));

    if (!lpDir || !IsUNCPath(lpDir) || !lppCscBypassedPath || !cpDrive) {
        return ERROR_INVALID_PARAMETER;  // Invalid argument
    }

    // Initialize
    *lppCscBypassedPath = NULL;
    memset(&sNR, 0, sizeof(NETRESOURCE));
    
    if (!ImpersonateUser(hTokenUser, &hOldToken)) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to impersonate user with %d."), dwError));
        goto Exit;
    }
    bImpersonated = TRUE;

    //
    // Construct the roaming share name
    //

    cchShare = lstrlen(lpDir) + 1;
    lpShare = (LPTSTR)LocalAlloc(LPTR, cchShare * sizeof(TCHAR));
    if (!lpShare) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to allocate memory")));
        goto Exit;
    }

    StringCchCopy(lpShare, cchShare, lpDir);
    lpFileName = ConvertToShareName(lpShare);

    cchCscBypassedPath = lstrlen(lpDir)+1;
    *lppCscBypassedPath = (LPTSTR)LocalAlloc(LPTR, cchCscBypassedPath * sizeof(TCHAR));
    if (!*lppCscBypassedPath) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to allocate memory")));
        goto Exit;
    }

    // 
    // Initialize NETRESOURCE structure
    //

    sNR.dwType = RESOURCETYPE_DISK;
    sNR.lpRemoteName = lpShare;
    sNR.lpLocalName = (LPTSTR)LocalAlloc(LPTR, 3 * sizeof(TCHAR));
    if (!sNR.lpLocalName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to allocate memory")));
        goto Exit;
    }
    sNR.lpLocalName[0] = TEXT('E');
    sNR.lpLocalName[1] = TEXT(':');
    sNR.lpLocalName[2] = TEXT('\0');

    do{
        __try {
            dwError = NPAddConnection3ForCSCAgent(NULL, &sNR, NULL, NULL, dwFlags, &bIsDfsConnect);
            DebugMsg((DM_VERBOSE, TEXT("AbleToBypassCSC: tried NPAddConnection3ForCSCAgent. Error %d"), dwError));
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Took exception in NPAddConnection3ForCSCAgent. Error %d"), dwError));
        }

        if (dwError == WN_SUCCESS || dwError == WN_CONNECTED_OTHER_PASSWORD ||
            dwError == WN_CONNECTED_OTHER_PASSWORD_DEFAULT){
            dwError = ERROR_SUCCESS;
            break;
        }
        if (sNR.lpLocalName[0]==TEXT('Z')) {
            goto Exit;
        }
        else if ((dwError == WN_BAD_LOCALNAME) || (dwError == WN_ALREADY_CONNECTED)){
            ++sNR.lpLocalName[0];
            continue;
        }
        else{
            if (GetNetworkProvider(&sNR) == ERROR_BAD_PROVIDER) {
                dwError = ERROR_BAD_PROVIDER;
            }
            goto Exit;
        }
    }while (TRUE);   

    // Succesfully bypassed CSC. Do not modify dwError in this part.
    bRetValue = TRUE;

    *cpDrive = sNR.lpLocalName[0];
    StringCchCopy(*lppCscBypassedPath, cchCscBypassedPath, sNR.lpLocalName);
    StringCchCat(*lppCscBypassedPath, cchCscBypassedPath, TEXT("\\"));
    if (lpFileName)
    {
        StringCchCat(*lppCscBypassedPath, cchCscBypassedPath, lpFileName);
    }
    DebugMsg((DM_VERBOSE, TEXT("AbleToBypassCSC: Share %s mapped to drive %c. Returned Path %s"), lpShare, sNR.lpLocalName[0], *lppCscBypassedPath));

Exit:
    
    if (lpShare) {
        LocalFree(lpShare);
    }

    if (!bRetValue && *lppCscBypassedPath) {
        LocalFree(*lppCscBypassedPath);
        *lppCscBypassedPath = NULL;
    }

    if (sNR.lpLocalName) {
        LocalFree(sNR.lpLocalName);
    }

    if (bImpersonated) {
        RevertToUser(&hOldToken);
    }

    return dwError;
}


//*************************************************************
//
//  CancelCSCBypassedConnection()
//
//  Purpose:    Release the mapped drive. 
//
//  Parameters: hTokenUser  -  User's token
//              cDrive      -  Drive letter to unmap
//
//  Return:     None
//
//  Comments:   We will always bypass csc for roaming share. 
//              There are two reason behind this :
//                o csc mark entire server offline even if only 
//                  one share goes offline. This is a bad design 
//                  from csc perspective and they need to fix it
//                o If csc is turned on in the roaming share server
//                  then both csc and profile will try to sync files
//                  on top of one another and we will be in a inconsistent 
//                  state
//
//  History:    Date        Author     Comment
//              10/29/00    santanuc   Created
//
//*************************************************************
void CancelCSCBypassedConnection(HANDLE hTokenUser, TCHAR cDrive)
{
    DWORD  dwError;
    TCHAR  szDrive[3];
    HANDLE hOldToken;

    if (!ImpersonateUser(hTokenUser, &hOldToken)) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CancelCSCBypassedConnection: Failed to impersonate user with %d."), dwError));
        return ;
    }

    szDrive[0] = cDrive;
    szDrive[1] = TEXT(':');
    szDrive[2] = TEXT('\0');
    DebugMsg((DM_VERBOSE, TEXT("CancelCSCBypassedConnection: Cancelling connection of %s"), szDrive));

    __try {
        dwError = NPCancelConnectionForCSCAgent(szDrive, TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CancelCSCBypassedConnection: Took exception in NPCancelConnectionForCSCAgent. Error %d"), dwError));
    }

    if (dwError != WN_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("CancelCSCBypassedConnection: Fail to delete connection. Error returned %d"), dwError));
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CancelCSCBypassedConnection: Connection deleted.")));
    }

    RevertToUser(&hOldToken);

}

//*************************************************************
//
//  GetNetworkProvider()
//
//  Purpose:    Determine network provider for a share
//
//  Parameters: 
//
//  Return:     DWORD
//
//  Comments:   Returns ERROR_BAD_PROVIDER if provider is other 
//              than microsoft SMB provider otherwise return 
//              NO_ERROR.
//
//  History:    Date        Author     Comment
//              03/08/01    santanuc   Created
//
//*************************************************************
DWORD GetNetworkProvider(NETRESOURCE *psNR)
{
    PFNWNETGETRESOURCEINFORMATION  pfnWNetGetResourceInformation;
    HMODULE                        hWNetLib = NULL;
    NETRESOURCE                    dNR;
    LPBYTE                         pbBuffer = (LPBYTE)&dNR;
    DWORD                          cbBuffer = sizeof(dNR);
    DWORD                          dwError = NO_ERROR;
    LPTSTR                         lpSystem = NULL;
    TCHAR                          szSMBProvider[100];
    HKEY                           hKeyProvider = NULL;
    DWORD                          dwSize, dwType;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, NETWORK_PROVIDER, 
                     0, KEY_READ, &hKeyProvider) != ERROR_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetNetworkProvider: Failed to open network provider key. Error %d"), GetLastError()));
        goto Exit;
    }
         
    dwSize = ARRAYSIZE(szSMBProvider);
    if (RegQueryValueEx(hKeyProvider,
                        PROVIDER_NAME,
                        NULL, 
                        &dwType,
                        (LPBYTE) szSMBProvider,
                        &dwSize) != ERROR_SUCCESS) { 
        DebugMsg((DM_WARNING, TEXT("GetNetworkProvider: Failed to get network provider name. Error %d"), GetLastError()));
        goto Exit;
    }

    if (!(hWNetLib = LoadLibrary(TEXT("mpr.dll")))) {
        DebugMsg((DM_WARNING, TEXT("GetNetworkProvider: LoadLibrary failed with %d"), GetLastError()));
        goto Exit;
    }
    pfnWNetGetResourceInformation = (PFNWNETGETRESOURCEINFORMATION)GetProcAddress(hWNetLib, "WNetGetResourceInformationW");
    if (!pfnWNetGetResourceInformation) {
        DebugMsg((DM_WARNING, TEXT("GetNetworkProvider: GetProcAddress failed with %d"), GetLastError()));
        goto Exit;
    }
        
    dwError = (*pfnWNetGetResourceInformation)(psNR, pbBuffer, &cbBuffer, &lpSystem);
    if (ERROR_MORE_DATA == dwError) {
        pbBuffer = LocalAlloc(LPTR, cbBuffer);
        if (!pbBuffer) {
            DebugMsg((DM_WARNING, TEXT("AbleToBypassCSC: Failed to impersonate user with %d."), GetLastError()));
            goto Exit;
        }
        
        dwError = (*pfnWNetGetResourceInformation)(psNR, pbBuffer, &cbBuffer, &lpSystem);
    }

    if (NO_ERROR == dwError) {
        if (lstrcmpi(((NETRESOURCE *)pbBuffer)->lpProvider, szSMBProvider) != 0) {
            dwError = ERROR_BAD_PROVIDER;
            goto Exit;
        }
    }

    dwError = NO_ERROR;

Exit:

    if (hKeyProvider) {
        RegCloseKey(hKeyProvider);
    }

    if (pbBuffer && (pbBuffer != (LPBYTE)&dNR)) {
        LocalFree(pbBuffer);
    }

    if (hWNetLib) {
        FreeLibrary(hWNetLib);
    }

    return dwError;
}
    
            
//*************************************************************
//
//  GetUserNameFromSid()
//
//  Purpose:    Returns the user name in domain\user format
//
//  Parameters: lpSidString - User's sid string
//
//  Return:     LPTSTR : domain\user name if succeeds
//                       lpSidString if fails
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/31/00    santanuc   Created
//
//*************************************************************
LPTSTR GetUserNameFromSid(LPTSTR lpSidString)
{
    PSID          pSidUser = NULL;
    LPTSTR        lpRetVal = lpSidString;
    TCHAR         szUserName[MAX_PATH], szDomainName[MAX_PATH];
    DWORD         dwUserSize = MAX_PATH, dwDomainSize = MAX_PATH;
    SID_NAME_USE  TypeOfAccount;
    DWORD         cchRetVal;

    //
    // Get the user sid
    //

    if (AllocateAndInitSidFromString(lpSidString, &pSidUser) != STATUS_SUCCESS) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameFromSid: Failed to create user sid.")));
        goto Exit;
    }

    //
    // Get the user and domain name
    //

    if (!LookupAccountSid(NULL, pSidUser, szUserName, &dwUserSize, szDomainName, &dwDomainSize, &TypeOfAccount)) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameFromSid: LookupAccountSid failed with error %d."), GetLastError()));
        goto Exit;
    }

    cchRetVal = lstrlen(szUserName) + lstrlen(szDomainName) + 2;
    lpRetVal = (LPTSTR)LocalAlloc(LPTR, cchRetVal * sizeof(TCHAR));
    if (!lpRetVal) {
        DebugMsg((DM_WARNING, TEXT("GetUserNameFromSid: Memory alloaction failure. error %d"), GetLastError()));
        lpRetVal = lpSidString;
        goto Exit;
    }
    
    // Construct the return string
    StringCchCopy(lpRetVal, cchRetVal, szDomainName);
    StringCchCat(lpRetVal, cchRetVal, TEXT("\\"));
    StringCchCat(lpRetVal, cchRetVal, szUserName);

Exit:
    
    if (pSidUser) {
        LocalFree(pSidUser);
    }

    return lpRetVal;
}

//*************************************************************
//
//  TakeOwnership()
//
//  Purpose:    Take ownership of a file or directory
//
//  Parameters: lpFileName - file or directory name to work on
//
//  Return:     S_OK for success, else for error
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              04/08/2002  mingzhu    Created
//
//*************************************************************

HRESULT TakeOwnership(LPTSTR lpFileName) 
{
    HRESULT     hr = E_FAIL;
    DWORD       dwErr;
    PSID        pSID = NULL;
    NTSTATUS    status;
    BOOLEAN     bTakeOwnerWasEnabled;
    BOOL        bTakeOwnerEnabled = FALSE;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;

    //
    //  Output a debug message
    //
    
    DebugMsg((DM_VERBOSE, TEXT("TakeOwnership : Taking ownership of %s ..."), lpFileName));

    //
    // Enable SE_TAKE_OWNERSHIP_NAME priviledge
    //

    status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE, TRUE, FALSE, &bTakeOwnerWasEnabled);

    if(!NT_SUCCESS(status))
    {
        hr = HRESULT_FROM_WIN32(RtlNtStatusToDosError(status));
        DebugMsg((DM_WARNING, TEXT("TakeOwnership: RtlAdjustPrivilege failed, error = %08x"), hr));
        goto Exit;
    }

    //
    // Create a SID for the BUILTIN\Administrators group.
    //
    
    if (!AllocateAndInitializeSid(&SIDAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0, &pSID))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("TakeOwnership: AllocateAndInitializeSid failed, error = %08x"), hr));
        goto Exit;
    }

    //
    // Set the owner in the object's security descriptor.
    //
    dwErr = SetNamedSecurityInfo(lpFileName,                    // name of the object
                                 SE_FILE_OBJECT,              // type of object
                                 OWNER_SECURITY_INFORMATION,  // change only the object's owner
                                 pSID,                        // SID of Administrator group
                                 NULL, NULL, NULL); 
 
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        DebugMsg((DM_WARNING, TEXT("TakeOwnership: SetNamedSecurityInfo failed, error = %08x"), hr));
        goto Exit;
    }

    //
    //  We're done!
    //
    DebugMsg((DM_VERBOSE, TEXT("TakeOwnership : Success!")));
    hr = S_OK;
    
Exit:

    if (bTakeOwnerEnabled && !bTakeOwnerWasEnabled)
    {
        status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE, FALSE, FALSE, &bTakeOwnerWasEnabled);
        if(!NT_SUCCESS(status))
        {
            DebugMsg((DM_WARNING, TEXT("TakeOwnership: RtlAdjustPrivilege failed, error = %08x"), status));
        }
    }

    if (pSID)
    {
        FreeSid(pSID); 
    }

    return hr;
   
}

//*************************************************************
//
//  AddAdminAccess()
//
//  Purpose:    Add administrators full access to a file or directory
//
//  Parameters: lpFileName - file or directory name to work on
//
//  Return:     S_OK for success, else for error
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              04/08/2002  mingzhu    Created
//
//*************************************************************

HRESULT AddAdminAccess(LPTSTR lpFileName)
{
    HRESULT                 hr = E_FAIL;
    DWORD                   dwErr;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PACL                    pOldDACL = NULL;
    PACL                    pNewDACL = NULL;
    EXPLICIT_ACCESS         ea;

    //
    //  Output a debug message 
    //

    DebugMsg((DM_VERBOSE, TEXT("AddAdminAccess : Adding administrators access to %s."), lpFileName));

    //
    // Get the old DACL in the file.
    //

    dwErr = GetNamedSecurityInfo(lpFileName,                   // name of the object
                                 SE_FILE_OBJECT,               // type of object
                                 DACL_SECURITY_INFORMATION,    // change only the object's owner
                                 NULL, NULL, &pOldDACL, NULL,  // DACL to get
                                 &pSD);                        // Security Descriptor of the file
    
    if (dwErr != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("AddAdminAccess : GetNamedSecurityInfo failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  Initialize an EXPLICIT_ACCESS structure for the new ACE (admin full access). 
    //
    
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = FILE_ALL_ACCESS;   
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.pMultipleTrustee = NULL;
    ea.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName = TEXT("Administrators");

    //
    //  Create a new ACL that merges the new ACE into the existing DACL.
    //

    dwErr = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    
    if (ERROR_SUCCESS != dwErr)
    {
        DebugMsg((DM_WARNING, TEXT("AddAdminAccess : SetEntriesInAcl failed.  Error = %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }  

    //
    // Set the owner in the object's security descriptor.
    //

    dwErr = SetNamedSecurityInfo(lpFileName,                   // name of the object
                                 SE_FILE_OBJECT,               // type of object
                                 DACL_SECURITY_INFORMATION,    // change only the object's owner
                                 NULL, NULL, pNewDACL, NULL);  // DACL to be set
    
    if (dwErr != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("AddAdminAccess : SetNamedSecurityInfo failed with %d"), dwErr));
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    //
    //  We're done!
    //
    
    DebugMsg((DM_VERBOSE, TEXT("AddAdminAccess : Success!")));
    hr = S_OK;

Exit:

    if(pNewDACL != NULL) 
        LocalFree(pNewDACL); 

    if(pSD != NULL) 
        LocalFree(pSD);
 
    return hr;
}

//*************************************************************
//
// Routine Description:
//
//    This routine determines if we're doing a gui-mode setup.
//
//    This value is retrieved from the following registry location:
//
//    \HKLM\System\Setup\
//
//        SystemSetupInProgress : REG_DWORD : 0x00 (where nonzero
//        means we're doing a gui-setup)
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    TRUE/FALSE
//
// Note:
//
//    This function is courtesy of Andrew Ritz and the Setup API.
//    It's copied over from base\pnp\setupapi\dll.c.
//
//***************************************************************

BOOL IsGuiSetupInProgress()
{
    HKEY hKey;
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "DriverCachePath" value.
        //
        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {
            return(TRUE);
        }
    }

    return(FALSE);

}

//*************************************************************
//
// Description:
//
//      This function will setup a new key under the ProfileList\{sid}
//      entry and give the specified user write permittion to it in order
//      to change his/her preference.
//
// Arguments:
//
//    lpSidString - String format of the sid indicate which entry we will work on.
//
// Return Value:
//
//    S_OK for success, else for failure
//
// Note:
//
// History:    Date        Author     Comment
//             04/19/2002  mingzhu    Created
//
//***************************************************************

HRESULT SetupPreferenceKey(LPCTSTR lpSidString)
{
    HRESULT hr = E_FAIL;
    LONG    lResult;
    DWORD   dwResult;

    TCHAR   szKeyName[MAX_PATH];
    HKEY    hKey = NULL;
    PSID    psidUser = NULL;
    PACL    pOldDACL = NULL;
    PACL    pNewDACL = NULL;

    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS ea;


    DebugMsg((DM_VERBOSE, TEXT("SetupPreferenceKey: Setting up the preference key for <%s>"), lpSidString));

    //
    //  Construct the key name
    //

    hr = StringCchPrintf(szKeyName,
                         ARRAYSIZE(szKeyName),
                         TEXT("%s\\%s\\%s"),
                         PROFILE_LIST_PATH,
                         lpSidString,
                         PREFERENCE_KEYNAME);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("SetupPreferenceKey: Failed to make key name, hr = %08X"), hr));
        goto Exit;
    }

    //
    //  Create the "Preference" key, using default security (inherited)
    //

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             szKeyName,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             NULL);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("SetupPreferenceKey: RegCreateKeyEx failed.  Error = %d"), lResult));
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    //
    //  Get the user's sid from its string form
    //

    if (!ConvertStringSidToSid(lpSidString, &psidUser))
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("SetupPreferenceKey: ConvertStringSidToSid failed.  Error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }

    //
    //  Get a pointer to the existing DACL and its SD
    //

    dwResult = GetSecurityInfo(hKey,
                               SE_REGISTRY_KEY, 
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               &pOldDACL,
                               NULL,
                               &pSD);
                               
    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("SetupPreferenceKey: GetSecurityInfo failed.  Error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }  

    //
    //  Initialize an EXPLICIT_ACCESS structure for the new ACE. 
    //
    
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessPermissions = KEY_READ | KEY_SET_VALUE;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType = TRUSTEE_IS_USER;
    ea.Trustee.ptstrName = psidUser;

    //
    //  Create a new ACL that merges the new ACE into the existing DACL.
    //

    dwResult = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    
    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("SetupPreferenceKey: SetEntriesInAcl failed.  Error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }  

    //
    //  Attach the new ACL to the key
    //

    dwResult = SetSecurityInfo(hKey,
                               SE_REGISTRY_KEY, 
                               DACL_SECURITY_INFORMATION,
                               NULL,
                               NULL,
                               pNewDACL,
                               NULL);
                               
    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("SetupPreferenceKey: SetSecurityInfo failed.  Error = %d"), dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }  


    DebugMsg((DM_VERBOSE, TEXT("SetupPreferenceKey: Successfully setup the preference key for <%s>"), lpSidString));

    hr = S_OK;

Exit:

    if(pSD) 
        LocalFree(pSD); 

    if(pNewDACL) 
        LocalFree(pNewDACL); 

    if (psidUser)
        LocalFree(psidUser);

    if (hKey)
        RegCloseKey(hKey);
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\gposcript.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include "SmartPtr.h"
#include "strings.h"
#include <strsafe.h>

extern "C"
{
BOOL PrependToPath( LPWSTR, LPWSTR*);
void PathUnquoteSpaces( LPWSTR );
void UpdateUserEnvironment();
LPWSTR GetSidString( HANDLE UserToken );
void DeleteSidString( LPWSTR SidString );
};

#define GPO_SCRIPTS_KEY L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts"
#define GP_STATE_KEY    L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State"
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define SCRIPT          L"Script"
#define PARAMETERS      L"Parameters"
#define EXECTIME        L"ExecTime"
#define GPOID           L"GPO-ID"
#define SOMID           L"SOM-ID"
#define FILESYSPATH     L"FileSysPath"

#define SCR_STARTUP     L"Startup"
#define SCR_SHUTDOWN    L"Shutdown"
#define SCR_LOGON       L"Logon"
#define SCR_LOGOFF      L"Logoff"

LPTSTR
CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

PSID
GetUserSid( HANDLE UserToken )
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if ( pUser == NULL )
    {
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL )
    {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = (PTOKEN_USER)LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if ( pTemp == NULL )
        {
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = (PSID)LocalAlloc(LMEM_FIXED, BytesRequired);
    if ( pSid == NULL )
    {
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}

LPWSTR
GetSidString( HANDLE UserToken )
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;

    //
    // Get the user sid
    //
    UserSid = GetUserSid( UserToken );
    if ( !UserSid )
    {
        return 0;
    }

    //
    // Convert user SID to a string.
    //
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            UserSid,
                                            (BOOLEAN)TRUE ); // Allocate
    LocalFree( UserSid );

    if ( !NT_SUCCESS(NtStatus) )
    {
        return 0;
    }

    return UnicodeString.Buffer ;
}

void
DeleteSidString( LPWSTR SidString )
{
    UNICODE_STRING String;

    RtlInitUnicodeString( &String, SidString );
    RtlFreeUnicodeString( &String );
}

typedef BOOL  (*PFNSHELLEXECUTEEX)(LPSHELLEXECUTEINFO lpExecInfo);

DWORD
ExecuteScript(  LPWSTR  szCmdLine,
                LPWSTR  szArgs,
                LPWSTR  szWorkingDir,
                BOOL    bSync,
                BOOL    bHide,
                BOOL    bRunMin,
                LPWSTR  szType,
                PFNSHELLEXECUTEEX pfnShellExecuteEx,
                HANDLE  hEventLog )
{
    WCHAR   szCmdLineEx[MAX_PATH];
    WCHAR   szArgsEx[3 * MAX_PATH];
    WCHAR   szCurDir[MAX_PATH];
    LPWSTR  szOldPath = 0;
    BOOL    bResult;
    DWORD   dwError = ERROR_SUCCESS;;
    SHELLEXECUTEINFO ExecInfo;

    if ( GetSystemDirectory( szCurDir, ARRAYSIZE( szCurDir ) ) )
    {
        bResult = SetCurrentDirectory( szCurDir );

        if ( ! bResult )
        {
            dwError = GetLastError();
        }
    }
    else
    {
        dwError = GetLastError();
    }

    if ( ERROR_SUCCESS != dwError )
    {
        goto ExecuteScript_Exit;
    }

    //
    // Expand the command line and args
    //
    DWORD cchExpanded;
    
    cchExpanded = ExpandEnvironmentStrings( szCmdLine, szCmdLineEx, ARRAYSIZE(szCmdLineEx ) );

    if ( cchExpanded > 0 )
    {
        cchExpanded = ExpandEnvironmentStrings( szArgs, szArgsEx, ARRAYSIZE(szArgsEx) );
    }

    if ( 0 == cchExpanded )
    {
        dwError = GetLastError();
        goto ExecuteScript_Exit;
    }

    //
    // Put the working directory on the front of the PATH
    // environment variable
    //
    bResult = PrependToPath( szWorkingDir, &szOldPath );

    if ( ! bResult )
    {
        dwError = GetLastError();

        goto ExecuteScript_Exit;
    }

    //
    // Run the script
    //
    PathUnquoteSpaces( szCmdLineEx );

    ZeroMemory(&ExecInfo, sizeof(ExecInfo));
    ExecInfo.cbSize = sizeof(ExecInfo);
    ExecInfo.fMask = SEE_MASK_DOENVSUBST |
                     SEE_MASK_FLAG_NO_UI |
                     SEE_MASK_NOZONECHECKS |
                     SEE_MASK_NOCLOSEPROCESS;
    ExecInfo.lpFile = szCmdLineEx;
    ExecInfo.lpParameters = !szArgsEx[0] ? 0 : szArgsEx;
    ExecInfo.lpDirectory = szWorkingDir;

    if ( bHide )
    {
        ExecInfo.nShow = SW_HIDE;
    }
    else
    {
        ExecInfo.nShow = (bRunMin ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL );
    }

    bResult = pfnShellExecuteEx( &ExecInfo );
    dwError = GetLastError();

    //
    // Try to put the PATH environment variable back the way it was
    // If this fails, we have to continue
    //
    if ( szOldPath )
    {
        SetEnvironmentVariable( L"PATH", szOldPath );
        LocalFree( szOldPath );
        szOldPath = 0;
    }

    if ( bResult )
    {
        dwError = 0;
        if (bSync)
        {
            WaitForSingleObject(ExecInfo.hProcess, INFINITE);
            UpdateUserEnvironment();
        }
        CloseHandle(ExecInfo.hProcess);
    }
    else
    {
        if ( hEventLog != 0 )
        {
            LPWSTR szMsgBuf[2] = { (LPTSTR) ExecInfo.lpFile, 0 };

            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           0,
                           dwError,
                           0,
                           (LPTSTR) (&szMsgBuf[1]),
                           1,
                           0);

            ReportEvent(hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SHELLEXEC_ERROR,
                        0,
                        2,
                        0,
                        (LPCTSTR*) szMsgBuf,
                        0);
            if ( szMsgBuf[1] )
            {
                LocalFree( szMsgBuf[1] );
            }
        }
    }

ExecuteScript_Exit:

    return dwError;
}

ScrExecGPOFromReg(  HKEY hKeyGPO,
                    HKEY hKeyStateGPO,
                    BOOL bSync,
                    BOOL bHidden,
                    BOOL bRunMin,
                    LPWSTR  szType,
                    PFNSHELLEXECUTEEX pfnShellExecuteEx,
                    HANDLE  hEventLog )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cSubKeys = 0;
    WCHAR   szFileSysPath[3*MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize;
    HRESULT hr = S_OK;
    
    //
    // FILESYSPATH
    // 
    dwType = REG_SZ;
    dwSize = sizeof( szFileSysPath );
    dwError = RegQueryValueEx(  hKeyGPO,
                                FILESYSPATH,
                                0,
                                &dwType,
                                (LPBYTE) szFileSysPath,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    hr = StringCchCat( szFileSysPath, sizeof(szFileSysPath)/sizeof(WCHAR), L"\\Scripts\\" );
    if(FAILED(hr)){
        SetLastError(HRESULT_CODE(hr));
        return HRESULT_CODE(hr);
    }
    hr = StringCchCat( szFileSysPath, sizeof(szFileSysPath)/sizeof(WCHAR), szType );
    if(FAILED(hr)){
        SetLastError(HRESULT_CODE(hr));
        return HRESULT_CODE(hr);
    }

    //
    // get the numer of Scripts
    //
    dwError = RegQueryInfoKey(  hKeyGPO,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError == ERROR_SUCCESS )
    {
        //
        // for every Script
        //
        for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
        {
            XKey    hKeyScript;
            XKey    hKeyStateScript;
            WCHAR   szTemp[32];

            dwError = RegOpenKeyEx( hKeyStateGPO,
                                    _itow( dwIndex, szTemp, 16 ),
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hKeyStateScript );
            if ( dwError != ERROR_SUCCESS )
            {
                return dwError;
            }
                                        
            //
            // open the Script key (we need only read perms)
            //
            dwError = RegOpenKeyEx( hKeyGPO,
                                    szTemp,
                                    0,
                                    KEY_READ,
                                    &hKeyScript );
            if ( dwError != ERROR_SUCCESS )
            {
                return dwError;
            }

            WCHAR   szScript[MAX_PATH];
            WCHAR   szParameters[MAX_PATH];
            SYSTEMTIME  execTime;

            //
            // script
            // 
            dwType = REG_SZ;
            dwSize = sizeof( szScript );
            dwError = RegQueryValueEx(  hKeyScript,
                                        SCRIPT,
                                        0,
                                        &dwType,
                                        (LPBYTE) szScript,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS )
            {
                break;
            }

            //
            // parameters
            // 
            dwType = REG_SZ;
            dwSize = sizeof( szParameters );
            dwError = RegQueryValueEx(  hKeyScript,
                                        PARAMETERS,
                                        0,
                                        &dwType,
                                        (LPBYTE) szParameters,
                                        &dwSize );
            if ( dwError != ERROR_SUCCESS )
            {
                break;
            }

            //
            // execute script
            //
            GetSystemTime( &execTime );
            dwError = ExecuteScript(szScript,
                                    szParameters,
                                    szFileSysPath,
                                    bSync,
                                    bHidden,
                                    bRunMin,
                                    szType,
                                    pfnShellExecuteEx,
                                    hEventLog );
            if ( dwError != ERROR_SUCCESS )
            {
                ZeroMemory( &execTime, sizeof( execTime ) );
            }

            //
            // write exec time
            // 
            RegSetValueEx(  hKeyStateScript,
                            EXECTIME,
                            0,
                            REG_QWORD,
                            (LPBYTE) &execTime,
                            sizeof( execTime ) );
        }
    }

    return dwError;
}

extern "C" DWORD
ScrExecGPOListFromReg(  LPWSTR szType,
                        BOOL bMachine,
                        BOOL bSync,
                        BOOL bHidden,
                        BOOL bRunMin,
                        HANDLE  hEventLog )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szBuffer[MAX_PATH];
    XKey    hKeyType;
    XKey    hKeyState;
    XKey    hKeyStateType;
    HRESULT hr = S_OK;

    //
    // create the following key
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State\<Target>\Scripts\<Type>
    //
    hr = StringCchCopy( szBuffer, sizeof(szBuffer)/sizeof(WCHAR), GP_STATE_KEY L"\\" );
    if(FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        return HRESULT_CODE(hr);
    }

    if ( bMachine )
    {
        hr = StringCchCat( szBuffer, sizeof(szBuffer)/sizeof(WCHAR), L"Machine\\Scripts" );
        if(FAILED(hr)){
            SetLastError(HRESULT_CODE(hr));
            return HRESULT_CODE(hr);
        }
    }
    else
    {
        XHandle hToken;

        if ( !OpenProcessToken( GetCurrentProcess(),
                                TOKEN_ALL_ACCESS,
                                &hToken ) )
        {
            return GetLastError();
        }

        LPWSTR szSid = GetSidString( hToken );

        if ( !szSid )
        {
            return GetLastError();
        }

        hr = StringCchCat( szBuffer, sizeof(szBuffer)/sizeof(WCHAR), szSid );
        if(FAILED(hr)){
            SetLastError(HRESULT_CODE(hr));
            return HRESULT_CODE(hr);
        }

        hr = StringCchCat( szBuffer, sizeof(szBuffer)/sizeof(WCHAR), L"\\Scripts" );
        if(FAILED(hr)){
            SetLastError(HRESULT_CODE(hr));
            return HRESULT_CODE(hr);
        }

        DeleteSidString( szSid );
    }

    //
    // state
    //
    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szBuffer,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyState );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = RegOpenKeyEx( hKeyState,
                            szType,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyStateType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // construct "Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\<Type>
    //
    hr = StringCchCopy( szBuffer, sizeof(szBuffer)/sizeof(WCHAR), GPO_SCRIPTS_KEY L"\\" );
    if(FAILED(hr)){
        SetLastError(HRESULT_CODE(hr));
        return HRESULT_CODE(hr);
    }

    hr = StringCchCat( szBuffer, sizeof(szBuffer)/sizeof(WCHAR), szType );
    if(FAILED(hr)){
        SetLastError(HRESULT_CODE(hr));
        return HRESULT_CODE(hr);
    }

    //
    // open the key
    //
    dwError = RegOpenKeyEx( bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                            szBuffer,
                            0,
                            KEY_READ,
                            &hKeyType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    DWORD   cSubKeys = 0;

    //
    // get the numer of GPOs
    //
    dwError = RegQueryInfoKey(  hKeyType,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    HINSTANCE hShell32;
    PFNSHELLEXECUTEEX pfnShellExecuteEx = NULL;

    hShell32 = LoadLibrary( L"shell32.dll" );

    if ( hShell32 )
    {
        pfnShellExecuteEx = (PFNSHELLEXECUTEEX) GetProcAddress( hShell32, "ShellExecuteExW" );
    }

    if ( !pfnShellExecuteEx )
    {
        return GetLastError();
    }
  
    //
    // for every GPO
    //
    for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
    {
        XKey hKeyGPO;
        XKey hKeyStateGPO;

        //
        // open the state GPO key
        //
        dwError = RegOpenKeyEx( hKeyStateType,
                                _itow( dwIndex, szBuffer, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyStateGPO );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // open the policy GPO key (we need only read perms)
        //
        dwError = RegOpenKeyEx( hKeyType,
                                szBuffer,
                                0,
                                KEY_READ,
                                &hKeyGPO );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // execute all scripts in the GPO
        //
        DWORD dwExecError;
        dwExecError = ScrExecGPOFromReg(hKeyGPO,
                                        hKeyStateGPO,
                                        bSync,
                                        bHidden,
                                        bRunMin,
                                        szType,
                                        pfnShellExecuteEx,
                                        hEventLog );
        if ( dwExecError != ERROR_SUCCESS )
        {
            dwError = dwExecError;
        }
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\helpmsg.h ===
#ifndef __Helpmsg_h__
#define __Helpmsg_h__

#ifdef __cplusplus
extern "C" {
#endif



int HelpMessageBox(
  HINSTANCE hInst,
  HWND hWnd,          // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT uType,         // message box style
  LPTSTR szHelpLine
);

#ifdef __cplusplus
}
#endif

#endif // __Helpmsg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\helpmsg.c ===
//
// html help messagebox, requires to be linked with htmlhelp.lib.
//
#include "userinit.h"

#include <Htmlhelp.h>
#pragma warning(push, 4)


LPTSTR MSGPARENT_WINDOWCLASS = TEXT("MessageHelpWndClass");

LRESULT CALLBACK MessageHelpWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static LPTSTR szHelpFile = NULL;
    switch (message)
    {
    case WM_HELP:
        HtmlHelp(hWnd, szHelpFile, HH_DISPLAY_TOPIC, 0);
        return TRUE;
        break;
    case WM_CREATE:
        szHelpFile = (LPTSTR)((LPCREATESTRUCT)lParam)->lpCreateParams;
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
}


ATOM RegisterHelpMessageClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;
    ZeroMemory(&wcex, sizeof(WNDCLASSEX));

    wcex.cbSize         = sizeof(WNDCLASSEX);
    wcex.hInstance		= hInstance;
	wcex.lpszClassName	= MSGPARENT_WINDOWCLASS;
    wcex.lpfnWndProc	= MessageHelpWndProc;

	return RegisterClassEx(&wcex);
}



int HelpMessageBox(
  HINSTANCE hInst,
  HWND hWnd,          // handle to owner window
  LPCTSTR lpText,     // text in message box
  LPCTSTR lpCaption,  // message box title
  UINT uType,         // message box style
  LPTSTR szHelpLine
)
{
    if (!(uType & MB_HELP) || !szHelpLine)
    {
        return MessageBox(hWnd, lpText, lpCaption, uType);
    }
    else
    {
        HWND hWndParent;
        int iReturn;

        //
        // create a window which will process the help message
        //
        RegisterHelpMessageClass(hInst);
        hWndParent = CreateWindow(
                MSGPARENT_WINDOWCLASS,
                NULL,
                WS_OVERLAPPEDWINDOW,
                0,
                0,
                0,
                0,
                hWnd,
                NULL,
                hInst,
                szHelpLine
                );

        iReturn = MessageBox(hWndParent, lpText, lpCaption, uType);
        DestroyWindow(hWndParent);
        return iReturn;
    }
}
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\stringid.h ===
/****************************** Module Header ******************************\
* Module Name: stringid.h
*
* Copyright (c) 1991-1993, Microsoft Corporation
*
* Defines resource ids
*
* History:
* 15-03-93 andreva      Created.
\***************************************************************************/

//
// Strings
//

#define IDS_INVALID_DISPLAY        1600
#define IDS_VMAPPLET               1601
#define IDS_DISPLAYAPPLET          1602
#define IDS_FAILING_WORKINGDIR     1603
#define IDS_FAILING_SHELLCOMMAND   1604
#define IDS_ERROR_WORKINGDIR       1605
#define IDS_ERROR_SHELLCOMMAND     1606
#define IDS_ERROR_SHELL_FAILED     1607
#define IDS_LOGON_FAILED           1608
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\msgalias.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgalias.c

Abstract:

    This file contains routines for adding and deleting message aliases
    when a user logs on/off.

Author:

    Dan Lafferty (danl)     21-Aug-1992

Environment:

    User Mode -Win32

Revision History:

    21-Aug-1992     danl
        created

--*/
// #include <nt.h>
// #include <ntrtl.h>
// #include <nturtl.h>

#include <windows.h>


#define LPTSTR  LPWSTR
#include <lmcons.h>
#include <lmerr.h>
#include <lmmsg.h>
#include <stdlib.h>
#include <msgalias.h>
#include <strsafe.h>


VOID
AddMsgAlias(
    LPWSTR   Username
    )

/*++

Routine Description:

    This function adds the Username to the list of message aliases.
    If unsuccessful, we don't care.

Arguments:

    Username - This is a pointer to a unicode Username.

Return Value:

    none.

--*/
{
    HANDLE          dllHandle;
    PMSG_NAME_ADD   NetMessageNameAdd = NULL;


    dllHandle = LoadLibraryW(L"netapi32.dll");
    if (dllHandle != NULL) {


        NetMessageNameAdd = (PMSG_NAME_ADD) GetProcAddress(
                                dllHandle,
                                "NetMessageNameAdd");


        if (NetMessageNameAdd != NULL) {
            NetMessageNameAdd(NULL,Username);
        }
        FreeLibrary(dllHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\userinit.c ===
/****************************** Module Header ******************************\
* Module Name: userinit.c
*
* Copyright (c) 1991, Microsoft Corporation
*
* Userinit main module
*
* Userinit is an app executed by winlogon at user logon.
* It executes in the security context of the user and on the user desktop.
* Its purpose is to complete any user initialization that may take an
* indeterminate time. e.g. code that interacts with the user.
* This process may be terminated at any time if a shutdown is initiated
* or if the user logs off by some other means.
*
* History:
* 20-Aug-92 Davidc       Created.
\***************************************************************************/

#include "userinit.h"
#include "winuserp.h"
#include <mpr.h>
#include <winnetp.h>
#include <winspool.h>
#include <winsprlp.h>
#include "msgalias.h"
#include "stringid.h"
#include "strings.h"
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
#include <shellapi.h>
#include <regapi.h>
#include <dsgetdc.h>
#include <lm.h>
#include "helpmsg.h"        // for HelpMessageBox
#include <userenv.h>
#include <userenvp.h>

/****************************************************************************
IsTSAppCompatOn()
Purpose:
    Checks if TS application compatibility is enabled.
    returns TRUE if enabled, FALSE - if not enabled or on case of error.
Comments:
    This function goes to the registry only once.
    All other times it just returnes the value.
****************************************************************************/
BOOL IsTSAppCompatOn();

//
// Define this to enable verbose output for this module
//

// #define DEBUG_USERINIT

#ifdef DEBUG_USERINIT
#define VerbosePrint(s) UIPrint(s)
#else
#define VerbosePrint(s)
#endif

//
// Define this to enable timing of userinit
//

//#define LOGGING

#ifdef LOGGING

void _WriteLog(LPCTSTR LogString);

#define WriteLog(s) _WriteLog(s)
#else
#define WriteLog(s)
#endif

//
// Define the environment variable names used to pass the logon
// server and script name from winlogon
//

#define LOGON_SERVER_VARIABLE       TEXT("UserInitLogonServer")
#define LOGON_SCRIPT_VARIABLE       TEXT("UserInitLogonScript")
#define MPR_LOGON_SCRIPT_VARIABLE   TEXT("UserInitMprLogonScript")
#define GPO_SCRIPT_TYPE_VARIABLE    TEXT("UserInitGPOScriptType")
#define OPTIMIZED_LOGON_VARIABLE    TEXT("UserInitOptimizedLogon")
#define EVENT_SOURCE_NAME           TEXT("UserInit")
#define USERDOMAIN_VARIABLE         TEXT("USERDOMAIN")
#define UNC_LOGON_SERVER_VARIABLE   TEXT("LOGONSERVER")
#define AUTOENROLL_VARIABLE         TEXT("UserInitAutoEnroll")
#define AUTOENROLL_NONEXCLUSIVE     TEXT("1")
#define AUTOENROLL_EXCLUSIVE        TEXT("2")
#define AUTOENROLLMODE_VARIABLE     TEXT("UserInitAutoEnrollMode")
#define AUTOENROLL_STARTUP          TEXT("1")
#define AUTOENROLL_WAKEUP           TEXT("2")
#define SCRIPT_ZONE_CHECK_VARIABLE  TEXT("SEE_MASK_NOZONECHECKS")
#define SCRIPT_ZONE_CHECK_DISABLE   TEXT("1")

//
// Define path separator
//

#define PATH_SEPARATOR          TEXT("\\")

//
// Define filename extension separator
//

#define EXTENSION_SEPARATOR_CHAR TEXT('.')

//
// Define server name prefix
//

#define SERVER_PREFIX           TEXT("\\\\")

//
// Define Logon script paths.
//

#define SERVER_SCRIPT_PATH      TEXT("\\NETLOGON")
#define LOCAL_SCRIPT_PATH       TEXT("\\repl\\import\\scripts")


#define WINLOGON_KEY            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define WINLOGON_POLICY_KEY     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")
#define GPO_SCRIPTS_KEY         TEXT("Software\\Policies\\Microsoft\\Windows\\System\\Scripts")
#define SYNC_LOGON_SCRIPT       TEXT("RunLogonScriptSync")
#define SYNC_STARTUP_SCRIPT     TEXT("RunStartupScriptSync")
#define GRPCONV_REG_VALUE_NAME  TEXT("RunGrpConv")
#define CTFMON_KEY              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run")
#define REG_CTFMON              TEXT("ctfmon.exe")

//
// We cache user preference to run logon scripts synchronously
// in the machine hive so it can be checked to determine if we
// can do cached logon without having to load the user's hive.
//

#define PROFILE_LIST_PATH               L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"


TCHAR g_szGrpConvExe[] = TEXT("grpconv.exe -p");

//
// Define extensions that should be added to scripts without extensions
// when we go search for them. Basically this list includes those extensions
// that CreateProcess handles when they are present in the executable file
// name but must be provided by the caller (us)
// We search for a script file with these extensions in this order and
// execute the first one we find.
//
static LPTSTR ScriptExtensions[] = { TEXT(".bat"), TEXT(".cmd") };

//
// Name of registry key and value to check for temp page file.
//
TCHAR szMemMan[] =
     TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

TCHAR szNoPageFile[] = TEXT("TempPageFile");


//
// Handle to a thread that may be created to deal with autoenrollment goo.  
// If this is non-null, we will wait on this thread to complete before
// terminating the process.
//
HANDLE AutoEnrollThread ;

//
// Timeout in miliseconds to wait for AddMessageAlias to complete
//

#define TIMEOUT_VALUE  (5L * 60L * 1000L)
#define MAX_STRING_BYTES 512

BOOL SetupHotKeyForKeyboardLayout ();

LPTSTR
AllocAndGetEnvironmentVariable(
    LPTSTR lpName
    );

BOOL
RunScriptHidden(HKEY hKeyRoot, LPTSTR lpValue, BOOL bDefault);

BOOL
RunLogonScriptSync(VOID);

BOOL
RunStartupScriptSync(VOID);

BOOL
UpdateUserEnvironment(VOID);

LPWSTR 
GetSidString(HANDLE UserToken);

VOID
DeleteSidString(LPWSTR SidString);

VOID
UpdateUserSyncLogonScriptsCache(BOOL bSync);

VOID
NewLogonNotify(VOID);

BOOL
RunGPOScripts(
    LPTSTR  lpGPOScriptType
    );

void
PathUnquoteSpaces(LPTSTR lpsz);

BOOLEAN 
RegCheckCtfmon(PWCHAR szCtfmon, DWORD cbSize);

BOOL
PrependToPath(
    IN LPTSTR lpLogonPath,
    OUT LPTSTR *lpOldPath
    );

typedef BOOL  (*PFNSHELLEXECUTEEX)(LPSHELLEXECUTEINFO lpExecInfo);
PFNSHELLEXECUTEEX g_pfnShellExecuteEx=NULL;

// If a path is contained in quotes then remove them.
void PathUnquoteSpaces(LPTSTR lpsz)
{
    int cch;

    cch = lstrlen(lpsz);

    // Are the first and last chars quotes?
    if (lpsz[0] == TEXT('"') && lpsz[cch-1] == TEXT('"'))
    {
        // Yep, remove them.
        lpsz[cch-1] = 0;
        MoveMemory(lpsz, lpsz+1, (cch-1) * sizeof(TCHAR));
    }
}

// Following function determines if the machine is a Pro or Personal machine 
BOOL IsPerOrProTerminalServer()
{
    OSVERSIONINFOEX osVersion = {0};

    osVersion.dwOSVersionInfoSize = sizeof(osVersion);
    return(GetVersionEx((OSVERSIONINFO*)&osVersion) &&
           (osVersion.wProductType == VER_NT_WORKSTATION) &&
           (osVersion.wSuiteMask & VER_SUITE_SINGLEUSERTS));
}

//
// The 3 functions below are duplicated in gptext as well
// for running GPO scripts
//

/***************************************************************************\
* AllocAndGetEnvironmentVariable
*
* Version of GetEnvironmentVariable that allocates the return buffer.
*
* Returns pointer to environment variable or NULL on failure
*
* The returned buffer should be free using Free()
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
LPTSTR
AllocAndGetEnvironmentVariable(
    LPTSTR lpName
    )
{
    LPTSTR Buffer;
    DWORD LengthRequired;
    DWORD LengthUsed;
    DWORD BytesRequired;

    //
    // Go search for the variable and find its length
    //

    LengthRequired = GetEnvironmentVariable(lpName, NULL, 0);

    if (LengthRequired == 0) {
        VerbosePrint(("Environment variable <%S> not found, error = %d", lpName, GetLastError()));
        return(NULL);
    }

    //
    // Allocate a buffer to hold the variable
    //

    BytesRequired = LengthRequired * sizeof(TCHAR);

    Buffer = (LPTSTR) Alloc(BytesRequired);
    if (Buffer == NULL) {
        VerbosePrint(("Failed to allocate %d bytes for environment variable", BytesRequired));
        return(NULL);
    }

    //
    // Go get the variable and pass a buffer this time
    //

    LengthUsed = GetEnvironmentVariable(lpName, Buffer, LengthRequired);

    if (LengthUsed == 0) {
        VerbosePrint(("Environment variable <%S> not found (should have found it), error = %d", lpName, GetLastError()));
        Free(Buffer);
        return(NULL);
    }

    if (LengthUsed != LengthRequired - 1) {
        VerbosePrint(("Unexpected result from GetEnvironmentVariable. Length passed = %d, length used = %d (expected %d)", LengthRequired, LengthUsed, LengthRequired - 1));
        Free(Buffer);
        return(NULL);
    }

    return(Buffer);
}

//
// Directory separator in environment strings
//

#define DIRECTORY_SEPARATOR     TEXT(";")

BOOL
PrependToPath(
    IN LPTSTR lpLogonPath,
    OUT LPTSTR *lpOldPath
    )
{
    DWORD BytesRequired;
    LPTSTR lpNewPath;
    HRESULT hr = S_OK;

    //
    // Prepend the address of the logon script to the path, so it can
    // reference other files.
    //

    *lpOldPath = AllocAndGetEnvironmentVariable( PATH );

    if (*lpOldPath == NULL) {
        return(FALSE);
    }

    BytesRequired = ( lstrlen(lpLogonPath) +
                      lstrlen(*lpOldPath)   +
                      2                           // one for terminator, one for ';'
                    ) * sizeof(TCHAR);

    lpNewPath = (LPTSTR)Alloc(BytesRequired);
    if (lpNewPath == NULL) {
        VerbosePrint(("PrependToPath: Failed to allocate %d bytes for modified path variable", BytesRequired));
        return(FALSE);
    }

    hr = StringCchCopy(lpNewPath, BytesRequired / sizeof(TCHAR), lpLogonPath);
    ASSERT(SUCCEEDED(hr));
    hr = StringCchCat(lpNewPath, BytesRequired / sizeof(TCHAR), DIRECTORY_SEPARATOR);
    ASSERT(SUCCEEDED(hr));
    hr = StringCchCat(lpNewPath, BytesRequired / sizeof(TCHAR), *lpOldPath);
    ASSERT(SUCCEEDED(hr));

//    Free( *lpOldPath );

    SetEnvironmentVariable(PATH, lpNewPath);

    Free(lpNewPath);

    return(TRUE);
}

//
// Volatile Environment
//

#define VOLATILE_ENVIRONMENT        TEXT("Volatile Environment")

FILETIME g_LastWrite = {0,0};

typedef BOOL (WINAPI *PFNREGENERATEUSERENVIRONMENT) (
              PVOID pPrevEnv, BOOL bSetCurrentEnv);


//
// This function checks if a volatile environment section
// exists in the registry, and if so does the environment
// need to be updated.
//

BOOL UpdateUserEnvironment (void)
{
    PVOID pEnv;
    HKEY hKey;
    DWORD dwDisp, dwType, dwSize;
    BOOL bRebuildEnv = FALSE;
    TCHAR szClass[MAX_PATH];
    DWORD cchClass, dwSubKeys, dwMaxSubKey, dwMaxClass,dwValues;
    DWORD dwMaxValueName, dwMaxValueData, dwSecurityDescriptor;
    FILETIME LastWrite;


    //
    // Attempt to open the Volatile Environment key
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      VOLATILE_ENVIRONMENT,
                      0,
                      KEY_READ,
                      &hKey) == ERROR_SUCCESS) {


        //
        // Query the key information for the LastWrite time.
        // This way we can update the environment only when
        // we really need to.
        //

        cchClass = MAX_PATH;

        if (RegQueryInfoKey(hKey,
                            szClass,
                            &cchClass,
                            NULL,
                            &dwSubKeys,
                            &dwMaxSubKey,
                            &dwMaxClass,
                            &dwValues,
                            &dwMaxValueName,
                            &dwMaxValueData,
                            &dwSecurityDescriptor,
                            &LastWrite) == ERROR_SUCCESS) {

            //
            // If we haven't checked this key before,
            // then just store the values for next time.
            //

            if (g_LastWrite.dwLowDateTime == 0) {

                g_LastWrite.dwLowDateTime = LastWrite.dwLowDateTime;
                g_LastWrite.dwHighDateTime = LastWrite.dwHighDateTime;

                bRebuildEnv = TRUE;

            } else {

                //
                // Compare the last write times.
                //

                if (CompareFileTime (&LastWrite, &g_LastWrite) == 1) {

                    g_LastWrite.dwLowDateTime = LastWrite.dwLowDateTime;
                    g_LastWrite.dwHighDateTime = LastWrite.dwHighDateTime;

                    bRebuildEnv = TRUE;
                }
            }
        }


        RegCloseKey (hKey);
    }


    //
    // Check if we need to rebuild the environment
    //

    if (bRebuildEnv) {
        HINSTANCE hInst;
        PFNREGENERATEUSERENVIRONMENT pRegUserEnv;

        hInst = LoadLibrary (TEXT("shell32.dll"));

        if (hInst) {
            pRegUserEnv = (PFNREGENERATEUSERENVIRONMENT) GetProcAddress(hInst, "RegenerateUserEnvironment");

            if (pRegUserEnv) {
                (*pRegUserEnv) (&pEnv, TRUE);
            }

            FreeLibrary (hInst);
        }
    }


    return TRUE;
}
    
// returns a pointer to the arguments in a cmd type path or pointer to
// NULL if no args exist
//
// abc.exe xyz.txt    -> xyz.txt
// abc.exe            -> ""
//
// Spaces in filenames must be quoted.
// "A long name.txt" bar.txt -> bar.txt

LPTSTR GetArgs(LPCTSTR pszPath)
{
    BOOL fInQuotes = FALSE;

    if (!pszPath)
            return NULL;

    while (*pszPath)
    {
        if (*pszPath == TEXT('"'))
            fInQuotes = !fInQuotes;
        else if (!fInQuotes && *pszPath == TEXT(' '))
            return (LPTSTR)pszPath;
        pszPath = CharNext(pszPath);
    }

    return (LPTSTR)pszPath;
}

/***************************************************************************\
* ExecApplication
*
* Execs an application
*
* Returns TRUE on success, FALSE on failure.
*
* 21-Aug-92 Davidc   Created.
\***************************************************************************/

BOOL
ExecApplication(
    LPTSTR pch,
    BOOL bFileNameOnly,
    BOOL bSyncApp,
    BOOL bShellExec,
    USHORT ShowState
    )
{
    BOOL Result;
    WCHAR Localpch[ MAX_PATH+1 ];
    BOOL  IsProcessExplorer = FALSE;
    HRESULT hr = S_OK;

    if ( (_wcsicmp( pch, L"explorer" ) == 0) ||
         (_wcsicmp( pch, L"explorer.exe" ) == 0 ) )
    {
        //
        // Explorer.exe might not be in the right spot on the path.  Let's wire
        // it to the right spot.
        //

        IsProcessExplorer = TRUE ;
        if ( ExpandEnvironmentStrings( L"%SystemRoot%\\Explorer.EXE", Localpch, MAX_PATH ) )
        {
            pch = Localpch ;
        }
        WriteLog( TEXT("Changed explorer.exe to") );
        WriteLog( pch );
    }
    else
    {
        if ( ExpandEnvironmentStrings( pch, Localpch, MAX_PATH ) )
        {
            pch = Localpch;
        }
    }

    //
    // Applications can be launched via ShellExecuteEx or CreateProcess
    //

    if (bShellExec)
    {
        SHELLEXECUTEINFO ExecInfo;
        LPTSTR lpArgs = NULL;
        LPTSTR lpTemp;
        HINSTANCE hShell32;

        if (!g_pfnShellExecuteEx) {
            
            Result = FALSE;

            hShell32 = LoadLibrary(TEXT("shell32.dll"));
            // this handle is not closed..

            if (hShell32) {
#ifdef UNICODE
                g_pfnShellExecuteEx = (PFNSHELLEXECUTEEX)GetProcAddress(hShell32, "ShellExecuteExW");
#else
                g_pfnShellExecuteEx = (PFNSHELLEXECUTEEX)GetProcAddress(hShell32, "ShellExecuteExA");
#endif

                if (g_pfnShellExecuteEx) {
                    Result = TRUE;
                }
            }
        }
        else {
            Result = TRUE;
        }

        if (Result) {
            lpTemp = LocalAlloc (LPTR, (lstrlen(pch) + 1) * sizeof(TCHAR));

            if (!lpTemp) {
                return FALSE;
            }

            hr = StringCchCopy (lpTemp, lstrlen(pch) + 1, pch);
            ASSERT(SUCCEEDED(hr));

            if (!bFileNameOnly) {
                lpArgs = GetArgs (lpTemp);

                if (lpArgs) {
                    if (*lpArgs) {
                        *lpArgs = TEXT('\0');
                        lpArgs++;
                    } else {
                        lpArgs = NULL;
                    }
                }
            }

            PathUnquoteSpaces(lpTemp);

            ZeroMemory(&ExecInfo, sizeof(ExecInfo));
            ExecInfo.cbSize = sizeof(ExecInfo);
            ExecInfo.fMask = SEE_MASK_DOENVSUBST | SEE_MASK_FLAG_NO_UI |
                             SEE_MASK_NOCLOSEPROCESS;
            ExecInfo.lpFile = lpTemp;
            ExecInfo.lpParameters = lpArgs;
            ExecInfo.nShow = ShowState;
            ExecInfo.lpVerb = TEXT("open");



            Result = g_pfnShellExecuteEx (&ExecInfo);

            if (Result) {

                //
                // If we are running this app synchronously, wait
                // for it to terminate.
                //

                if (bSyncApp) {
                    WaitForSingleObject(ExecInfo.hProcess, INFINITE);
                }

                //
                // Close our handles to the process and thread
                //

                CloseHandle(ExecInfo.hProcess);

            }

            LocalFree (lpTemp);
        }
    }
    else
    {
        STARTUPINFO si;
        PROCESS_INFORMATION ProcessInformation;


        //
        // Initialize process startup info
        //
        si.cb = sizeof(STARTUPINFO);
        si.lpReserved = pch; // This tells progman it's the shell!
        si.lpTitle = pch;
        si.lpDesktop = NULL; // Not used
        si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = ShowState;
        si.lpReserved2 = NULL;
        si.cbReserved2 = 0;


        //
        // Start the app
        //
        Result = CreateProcess(
                          bFileNameOnly ? pch : NULL,   // Image name
                          bFileNameOnly ? NULL : pch,   // Command line
                          NULL,  // Default process protection
                          NULL,  // Default thread protection
                          FALSE, // Don't inherit handles
                          NORMAL_PRIORITY_CLASS,
                          NULL,  // Inherit environment
                          NULL,  // Inherit current directory
                          &si,
                          &ProcessInformation
                          );

        if (!Result) {
            VerbosePrint(("Failed to execute <%S>, error = %d", pch, GetLastError()));
            // TS : For non console sessions, a app restriting process like AppSec or SAFER might not allow explorer.exe for remote session
            // In this case we cannot leave a Blue screen hanging around - so we should log-off in this case
            // Also we want this only for Server or Advanced Server where this scenario is relevant
            if ( IsPerOrProTerminalServer() == FALSE) {
                if ((NtCurrentPeb()->SessionId != 0) && (IsProcessExplorer == TRUE)) {
                    TCHAR Title[MAX_STRING_BYTES];
                    TCHAR Message[MAX_STRING_BYTES];

                    #if DBG
                    DbgPrint("Userinit : TS : Failed to launch explorer.exe for a Remote Session. Doing ExitWindowsEx to logoff. \n");
                    #endif

                    // Display a MessageBox saying why we log off
                    LoadString( NULL, IDS_LOGON_FAILED, Title, MAX_STRING_BYTES );
                    LoadString(NULL, IDS_ERROR_SHELL_FAILED, Message, MAX_STRING_BYTES );
                    MessageBox(NULL, Message, Title, MB_OK);
                    ExitWindowsEx(EWX_LOGOFF, 0);
                }
            } 
        } else {

            //
            // If we are running this app synchronously, wait
            // for it to terminate.
            //

            if (bSyncApp) {
                WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
            }

            //
            // Close our handles to the process and thread
            //

            CloseHandle(ProcessInformation.hProcess);
            CloseHandle(ProcessInformation.hThread);

        }
    }

    return(Result);
}

/***************************************************************************\
* ExecProcesses
*
* Read the registry for a list of system processes and start them up.
*
* Returns number of processes successfully started.
*
* 3-Mar-97 Eric Flo      Rewrote
\***************************************************************************/

DWORD
ExecProcesses(
    LPTSTR pszKeyName,
    LPTSTR pszDefault,
    BOOL bMachine,
    BOOL bSync,                         // Should we wait until the process finish?
    BOOL bMinimize                      // Should we use the SW_SHOWMINNOACTIVE flag
    )
{
    LPTSTR pchData, pchCmdLine, pchT;
    DWORD cbCopied;
    DWORD dwExecuted = 0 ;
    HKEY hKey;
    DWORD dwType, dwSize = (MAX_PATH * sizeof(TCHAR));
    USHORT showstate = (UINT) (bMinimize ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL);
    HRESULT hr = S_OK;
    BOOL bRestore = FALSE;

    //
    // Alloc a buffer to work with
    //

    pchData = LocalAlloc (LPTR, dwSize);

    if (!pchData) {
        return 0;
    }


    //
    // Set the default value
    //
Restore:

    if (pszDefault) {

        hr = StringCchCopy (pchData, MAX_PATH, pszDefault);

        if(FAILED(hr)){
            LocalFree(pchData);
            SetLastError(HRESULT_CODE(hr));
            return 0;
        }
    }


    //
    // Check for the requested value in the registry.
    //

    if (RegOpenKeyEx ((bMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER),
                            WINLOGON_KEY,
                            0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = (MAX_PATH * sizeof(TCHAR));
        if (ERROR_SUCCESS == RegQueryValueEx (hKey, pszKeyName, NULL, &dwType, (LPBYTE) pchData, &dwSize))
        {
            if ((REG_SZ != dwType) || (dwSize < 2) || (pchData[dwSize/sizeof(TCHAR) - 1]))
            {
                //
                // Restore the default value
                //

                if (pszDefault) {
                    hr = StringCchCopy (pchData, MAX_PATH, pszDefault);
                    ASSERT(SUCCEEDED(hr));      // Since the same one above succeeded
                }
                else {
                    pchData[0] = 0;
                }
            }
        }
        // else the buffer wasn't touched so no need to restore

        RegCloseKey (hKey);
    }


    if (!bRestore)
    {
        //
        // Check for policy override if this is a user action
        //

        if (!bMachine)
        {
            if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_POLICY_KEY,
                              0, KEY_READ, &hKey) == ERROR_SUCCESS) {

                dwSize = (MAX_PATH * sizeof(TCHAR));
                cbCopied = RegQueryValueEx (hKey, pszKeyName, NULL, &dwType, (LPBYTE) pchData, &dwSize);
                RegCloseKey (hKey);

                if (ERROR_SUCCESS == cbCopied)
                {
                    if ((REG_SZ != dwType) || (dwSize < 2) || (pchData[dwSize/sizeof(TCHAR) - 1]))
                    {
                        bRestore = TRUE;
                        goto Restore;
                    }
                }
                // else the buffer wasn't touched so no need to restore
            }
        }
    }


    //
    // If the command line(s) is still null, exit now.
    //

    if (*pchData == TEXT('\0')) {
        LocalFree(pchData);
        return 0;
    }


    //
    // Walk through the command line(s) executing the app(s)
    //

    pchCmdLine = pchT = pchData;

    while (*pchT) {

        while (*pchT && *pchT != TEXT(',')) {
            pchT++;
        }

        if (*pchT == ',') {
            *pchT = TEXT('\0');
            pchT++;
        }

        //
        // Skip any leading spaces.
        //

        while (*pchCmdLine == TEXT(' ')) {
            pchCmdLine++;
        }


        //
        // We have something... exec this application.
        //

        if (ExecApplication(pchCmdLine, FALSE, bSync, FALSE, showstate)) {
            dwExecuted++;
        }

        pchCmdLine = pchT;
    }

    LocalFree(pchData);

    return dwExecuted ;
}


/***************************************************************************\
* SearchAndAllocPath
*
* Version of SearchPath that allocates the return string.
*
* Returns pointer to full path of file or NULL if not found.
*
* The returned buffer should be free using Free()
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
LPTSTR
SearchAndAllocPath(
    LPTSTR lpPath,
    LPTSTR lpFileName,
    LPTSTR lpExtension,
    LPTSTR *lpFilePart
    )
{
    LPTSTR Buffer;
    DWORD LengthRequired;
    DWORD LengthUsed;
    DWORD BytesRequired;

    //
    // Allocate a buffer to hold the full filename
    //

    LengthRequired = MAX_PATH;
    BytesRequired = (LengthRequired * sizeof(TCHAR));

    Buffer = Alloc(BytesRequired);
    if (Buffer == NULL) {
        UIPrint(("SearchAndAllocPath: Failed to allocate %d bytes for file name", BytesRequired));
        return(NULL);
    }

    //
    // Go search for the file
    //

    LengthUsed = SearchPath(
                           lpPath,
                           lpFileName,
                           lpExtension,
                           LengthRequired,
                           Buffer,
                           lpFilePart);

    if (LengthUsed == 0) {
        VerbosePrint(("SearchAndAllocPath: Path <%S>, file <%S>, extension <%S> not found, error = %d", lpPath, lpFileName, lpExtension, GetLastError()));
        Free(Buffer);
        return(NULL);
    }

    if (LengthUsed > LengthRequired - 1) {
        UIPrint(("SearchAndAllocPath: Unexpected result from SearchPath. Length passed = %d, length used = %d (expected %d)", LengthRequired, LengthUsed, LengthRequired - 1));
        Free(Buffer);
        return(NULL);
    }

    return(Buffer);
}

BOOL
DisableScriptZoneSecurityCheck()
{
    BOOL bSucceeded;

    //
    // To make the shell skip the zone security check for launching scripts, we use
    // a special environment variable honored by the shell for this purpose and
    // set it to a specific value
    //
    bSucceeded = SetEnvironmentVariable(SCRIPT_ZONE_CHECK_VARIABLE, SCRIPT_ZONE_CHECK_DISABLE);

    return bSucceeded;
}

BOOL
EnableScriptZoneSecurityCheck()
{
    BOOL bSucceeded;

    //
    // Clear the environment variable that disables the security check 
    //
    bSucceeded = SetEnvironmentVariable(SCRIPT_ZONE_CHECK_VARIABLE, NULL);

    if ( ! bSucceeded )
    {
        //
        // If we failed to clear it, it may be that this is because the
        // environment variable wasn't set in the first place, in which
        // case we can ignore the error since we are in the desired state
        //
        LONG Status = GetLastError();

        if ( ERROR_ENVVAR_NOT_FOUND == Status )
        {
            bSucceeded = TRUE;
        }
    }

    return bSucceeded;
}

/***************************************************************************\
* ExecScript
*
* Attempts to run the command script or exe lpScript in the directory lpPath.
* If path is not specified then the default windows search path is used.
*
* This routine is basically a wrapper for CreateProcess. CreateProcess always
* assumes a .exe extension for files without extensions. It will run .cmd
* and .bat files but it keys off the .cmd and .bat extension. So we must go
* search for the file first and add the extension before calling CreateProcess.
*
* Returns TRUE if the script began executing successfully.
* Returns FALSE if we can't find the script in the path specified
* or something fails.
*
* History:
* 09-Dec-92     Davidc  Created
*
\***************************************************************************/
BOOL
ExecScript(
    LPTSTR lpPath OPTIONAL,
    LPTSTR lpScript,
    BOOL bSyncApp,
    BOOL bShellExec
    )
{
    BOOL Result;
    DWORD i;
    USHORT uFlags;
    LPTSTR lpFullName;
    DWORD BytesRequired;
    HRESULT hr = S_OK;

    //
    // First try and execute the raw script file name
    //

    if (lpPath != NULL) {

        BytesRequired = (lstrlen(lpPath) +
                         lstrlen(PATH_SEPARATOR) +
                         lstrlen(lpScript) +
                         1)
                         * sizeof(TCHAR);

        lpFullName  = Alloc(BytesRequired);
        if (lpFullName == NULL) {
            UIPrint(("ExecScript failed to allocate %d bytes for full script name", BytesRequired));
            return(FALSE);
        }

        hr = StringCchCopy(lpFullName, BytesRequired / sizeof(TCHAR), lpPath);
        ASSERT(SUCCEEDED(hr));
        hr = StringCchCat(lpFullName, BytesRequired / sizeof(TCHAR), PATH_SEPARATOR);
        ASSERT(SUCCEEDED(hr));
        hr = StringCchCat(lpFullName, BytesRequired / sizeof(TCHAR), lpScript);
        ASSERT(SUCCEEDED(hr));

    } else {
        lpFullName = lpScript;
    }


    uFlags = SW_SHOWNORMAL;

    if (!bSyncApp) {
        uFlags |= SW_SHOWMINNOACTIVE;
    }

    if (RunScriptHidden(HKEY_CURRENT_USER, TEXT("HideLegacyLogonScripts"), FALSE)) {
        uFlags = SW_HIDE;
    }

    //
    // Let CreateProcess have a hack at the raw script path and name.
    //

    Result = ExecApplication(lpFullName, FALSE, bSyncApp, bShellExec, uFlags);


    //
    // Free up the full name buffer
    //

    if (lpFullName != lpScript) {
        Free(lpFullName);
    }



    if (!Result) {

        //
        // Create process couldn't find it so add each script extension in
        // turn and try and execute the full script name.
        //
        // Only bother with this procedure if the script name doesn't
        // already contain an extension
        //
        BOOL ExtensionPresent = FALSE;
        LPTSTR p = lpScript;

        while (*p) {
            if (*p == EXTENSION_SEPARATOR_CHAR) {
                ExtensionPresent = TRUE;
                break;
            }
            p = CharNext(p);
        }

        if (ExtensionPresent) {
            VerbosePrint(("ExecScript: Skipping search path because script name contains extension"));
        } else {

            for (i = 0; i < sizeof(ScriptExtensions)/sizeof(ScriptExtensions[0]); i++) {

                lpFullName = SearchAndAllocPath(
                                    lpPath,
                                    lpScript,
                                    ScriptExtensions[i],
                                    NULL);

                if (lpFullName != NULL) {

                    //
                    // We found the file, go execute it
                    //

                    Result = ExecApplication(lpFullName, FALSE, bSyncApp, bShellExec, uFlags);

                    //
                    // Free the full path buffer
                    //

                    Free(lpFullName);

                    return(Result);
                }
            }
        }
    }


    return(Result);
}

BOOL RunScriptHidden(HKEY hKeyRoot, LPTSTR lpValue, BOOL bDefault)
{
    BOOL bResult;
    HKEY hKey;
    DWORD dwType, dwSize;


    //
    // Set the default
    //

    bResult = bDefault;


    //
    // Check for a preference
    //

    if (RegOpenKeyEx (hKeyRoot, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bResult);
        RegQueryValueEx (hKey, lpValue, NULL, &dwType,
                         (LPBYTE) &bResult, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a policy
    //

    if (RegOpenKeyEx (hKeyRoot, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(bResult);
        RegQueryValueEx (hKey, lpValue, NULL, &dwType,
                         (LPBYTE) &bResult, &dwSize);

        RegCloseKey (hKey);
    }


    return bResult;
}


/***************************************************************************\
* RunLogonScript
*
* Starts the logon script
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 21-Aug-92     Davidc  Created
*
\***************************************************************************/
BOOL
RunLogonScript(
    LPTSTR lpLogonServer OPTIONAL,
    LPTSTR lpLogonScript,
    BOOL bSyncApp,
    BOOL bShellExec
    )
{
    LPTSTR lpLogonPath;
    LPTSTR lpOldPath;
    DWORD BytesRequired;
    BOOL Result;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HRESULT hr = S_OK;
    HANDLE hToken;

    if (!lpLogonScript) {
        return TRUE;
    }

    //
    //  Skip logon script if cross forest logon
    //
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken))
    {
        hr = CheckXForestLogon(hToken);
        CloseHandle(hToken);
        if (hr == S_FALSE)
        {
            return TRUE;
        }
    }
    
    //
    // if the logon server exists, look for the logon scripts on
    // \\<LogonServer>\NETLOGON\<ScriptName>
    //

    if ((lpLogonServer != NULL) && (lpLogonServer[0] != 0)) {

        BytesRequired = ( lstrlen(SERVER_PREFIX) +
                          lstrlen(lpLogonServer) +
                          lstrlen(SERVER_SCRIPT_PATH) +
                          1
                        ) * sizeof(TCHAR);

        lpLogonPath = (LPTSTR)Alloc(BytesRequired);
        if (lpLogonPath == NULL) {
            UIPrint(("RunLogonScript: Failed to allocate %d bytes for remote logon script path", BytesRequired));
            return(FALSE);
        }

        hr = StringCchCopy(lpLogonPath, BytesRequired / sizeof(TCHAR), SERVER_PREFIX);
        ASSERT(SUCCEEDED(hr));
        hr = StringCchCat(lpLogonPath, BytesRequired / sizeof(TCHAR), lpLogonServer);
        ASSERT(SUCCEEDED(hr));
        hr = StringCchCat(lpLogonPath, BytesRequired / sizeof(TCHAR), SERVER_SCRIPT_PATH);
        ASSERT(SUCCEEDED(hr));

        if (GetFileAttributesEx (lpLogonPath, GetFileExInfoStandard, &fad)) {

            BOOL bChangedPath;

            Result = PrependToPath( lpLogonPath, &lpOldPath );

            bChangedPath = Result;

            if (Result) {
                VerbosePrint(("Successfully prepended <%S> to path", lpLogonPath));
            } else {
                VerbosePrint(("Cannot prepend <%S> path.",lpLogonPath));
            }

            //
            // Try and execute the app/script specified by lpLogonScript
            // in the directory specified by lpLogonPath
            //
            Result = ExecScript(lpLogonPath, lpLogonScript, bSyncApp, bShellExec);

            if (Result) {
                VerbosePrint(("Successfully executed logon script <%S> in directory <%S>", lpLogonScript, lpLogonPath));
            } else {
                VerbosePrint(("Cannot start logon script <%S> on LogonServer <%S>. Trying local path.", lpLogonScript, lpLogonServer));
            }

            //
            // Put the path back the way it was
            //

            if ( bChangedPath )
            {
                SetEnvironmentVariable(PATH, lpOldPath);
            }

            Free(lpOldPath);

        } else {
            Result = FALSE;
        }

        //
        // Free up the buffer
        //

        Free(lpLogonPath);

        //
        // If the script started successfully we're done, otherwise
        // drop through and try to find the script locally
        //

        if (Result) {

            if (bSyncApp) {
                //
                // Check that the volatile environment hasn't changed.
                //

                UpdateUserEnvironment();
            }

            return(TRUE);
        }
    }




    //
    // Try to find the scripts on <system dir>\repl\import\scripts\<scriptname>
    //

    BytesRequired = GetSystemDirectory(NULL, 0) * sizeof(TCHAR);
    if (BytesRequired == 0) {
        UIPrint(("RunLogonScript: GetSystemDirectory failed, error = %d", GetLastError()));
        return(FALSE);
    }

    BytesRequired += ( lstrlen(LOCAL_SCRIPT_PATH) + 1
                       // BytesRequired  does not include space for terminator
                     ) * sizeof(TCHAR);

    lpLogonPath = (LPTSTR)Alloc(BytesRequired);
    if (lpLogonPath == NULL) {
        UIPrint(("RunLogonScript failed to allocate %d bytes for logon script path", BytesRequired));
        return(FALSE);
    }

    Result = FALSE;
    if (GetSystemDirectory(lpLogonPath, BytesRequired / sizeof(TCHAR))) {

        hr = StringCchCat(lpLogonPath, BytesRequired / sizeof(TCHAR), LOCAL_SCRIPT_PATH);
        ASSERT(SUCCEEDED(hr));

        Result = PrependToPath( lpLogonPath, &lpOldPath );

        if (Result) {
            VerbosePrint(("Successfully prepended <%S> to path", lpLogonPath));
        } else {
            VerbosePrint(("Cannot prepend <%S> path.",lpLogonPath));
        }

        //
        // Try and execute the app/script specified by lpLogonScript
        // in the directory specified by lpLogonPath
        //

        Result = ExecScript(lpLogonPath, lpLogonScript, bSyncApp, bShellExec);

        if (Result) {
            VerbosePrint(("Successfully executed logon script <%S> in directory <%S>", lpLogonScript, lpLogonPath));
        } else {
            VerbosePrint(("Cannot start logon script <%S> on local path <%S>.", lpLogonScript, lpLogonPath));
        }

        //
        // Put the path back the way it was
        //

        SetEnvironmentVariable(PATH, lpOldPath);

        Free(lpOldPath);

    } else {
        UIPrint(("RunLogonScript: GetSystemDirectory failed, error = %d", GetLastError()));
    }

    //
    // Free up the buffer
    //

    Free(lpLogonPath);


    //
    // Check that the volatile environment hasn't changed.
    //

    if (Result && bSyncApp) {
        UpdateUserEnvironment();
    }

    return(Result);
}

#define SCR_STARTUP     L"Startup"
#define SCR_SHUTDOWN    L"Shutdown"
#define SCR_LOGON       L"Logon"
#define SCR_LOGOFF      L"Logoff"

DWORD
ScrExecGPOListFromReg(  LPWSTR szType,
                        BOOL bMachine,
                        BOOL bSync,
                        BOOL bHidden,
                        BOOL bRunMin,
                        HANDLE  hEventLog );

BOOL
RunGPOScripts(
    LPTSTR lpGPOScriptType
    )
{
    HKEY hKeyScripts;
    HKEY hKeyRoot;
    BOOL bSync = TRUE;
    BOOL bRunMin = TRUE;
    BOOL bHide;
    HANDLE hEventLog = NULL;
    BOOL  bMachine;
    BOOL  bResult = FALSE;
    DWORD   dwError;

    //
    // Ensure that the shell's checks for ie zones are disabled
    // since this script is trusted by an administrator to execute
    //
    bResult = DisableScriptZoneSecurityCheck();

    if ( ! bResult )
    {
        goto RunGPOScripts_exit;
    }

    //
    // Register with Event Log -- if the event source is not
    // available, we will continue and simply not log script 
    // events during execution -- a NULL return indicates this
    // below, and we will simply pass this NULL to other functions
    // which will handle it properly
    //
    hEventLog = RegisterEventSource( 0, EVENT_SOURCE_NAME );

    //
    // Preliminary work to see if the scripts should be
    // run sync or async and to decide what the appropriate
    // root key is
    //



    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpGPOScriptType, -1, SCR_LOGON, -1) == CSTR_EQUAL)
    {
        hKeyRoot = HKEY_CURRENT_USER;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideLogonScripts"), TRUE);
        bSync = RunLogonScriptSync();
        bMachine = FALSE;
        if (bSync && !bHide)
        {
            bRunMin = FALSE;
        }
    }
    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpGPOScriptType, -1, SCR_LOGOFF, -1) == CSTR_EQUAL)
    {
        hKeyRoot = HKEY_CURRENT_USER;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideLogoffScripts"), TRUE);
        bMachine = FALSE;
        if (!bHide)
        {
            bRunMin = FALSE;
        }
    }
    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpGPOScriptType, -1, SCR_STARTUP, -1) == CSTR_EQUAL)
    {
        hKeyRoot = HKEY_LOCAL_MACHINE;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideStartupScripts"), TRUE);
        bSync = RunStartupScriptSync();
        bMachine = TRUE;
        if (bSync && !bHide)
        {
            bRunMin = FALSE;
        }
    }
    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpGPOScriptType, -1, SCR_SHUTDOWN, -1) == CSTR_EQUAL)
    {
        hKeyRoot = HKEY_LOCAL_MACHINE;
        bHide = RunScriptHidden(hKeyRoot, TEXT("HideShutdownScripts"), TRUE);
        bMachine = TRUE;
        if (!bHide)
        {
            bRunMin = FALSE;
        }
    }
    else
    {
        goto RunGPOScripts_exit;
    }

    dwError = ScrExecGPOListFromReg(lpGPOScriptType,
                                    bMachine,
                                    bSync,
                                    bHide,
                                    bRunMin,
                                    hEventLog );

    bResult = ( dwError == ERROR_SUCCESS );

RunGPOScripts_exit:

    if (hEventLog)
    {
        DeregisterEventSource(hEventLog);
    }
    
    return bResult;
}


/***************************************************************************\
* RunMprLogonScripts
*
* Starts the network provider logon scripts
* The passed string is a multi-sz - we exec each script in turn.
*
* Returns TRUE on success, FALSE on failure
*
* History:
* 21-Aug-92     Davidc  Created
*
\***************************************************************************/
BOOL
RunMprLogonScripts(
    LPTSTR lpLogonScripts,
    BOOL bSyncApp
    )
{
    BOOL Result;

    if (lpLogonScripts != NULL) {

        DWORD Length;

        do {
            Length = lstrlen(lpLogonScripts);
            if (Length != 0) {

                Result = ExecScript(NULL, lpLogonScripts, bSyncApp, FALSE);

                if (Result) {
                    VerbosePrint(("Successfully executed mpr logon script <%S>", lpLogonScripts));

                    if (bSyncApp) {
                        //
                        // Check that the volatile environment hasn't changed.
                        //

                        UpdateUserEnvironment();
                    }
                } else {
                    VerbosePrint(("Cannot start mpr logon script <%S>", lpLogonScripts));
                }
            }

            lpLogonScripts += (Length + 1);

        } while (Length != 0);

    }

    return(TRUE);
}

/***************************************************************************\
* AllocAndGetEnvironmentMultiSz
*
* Gets an environment variable's value that's assumed to be an
* encoded multi-sz and decodes it into an allocated return buffer.
* Variable should have been written with SetEnvironmentMultiSz() (winlogon)
*
* Returns pointer to environment variable or NULL on failure
*
* The returned buffer should be free using Free()
*
* History:
* 01-15-93      Davidc  Created
*
\***************************************************************************/

#define TERMINATOR_REPLACEMENT  TEXT(',')

LPTSTR
AllocAndGetEnvironmentMultiSz(
    LPTSTR lpName
    )
{
    LPTSTR Buffer;
    LPTSTR p, q;

    Buffer = AllocAndGetEnvironmentVariable(lpName);
    if (Buffer == NULL) {
        return(NULL);
    }

    //
    // Now decode the string - we can do this in place since the string
    // will always get smaller
    //

    p = Buffer;
    q = Buffer;

    while (*p) {

        if (*p == TERMINATOR_REPLACEMENT) {

            p ++;
            if (*p != TERMINATOR_REPLACEMENT) {
                p --;
                *p = 0;
            }
        }

        if (p != q) {
            *q = *p;
        }

        p ++;
        q ++;
    }

    ASSERT(q <= p);

    //
    // Copy terminator
    //

    if (q != p) {
        *q = 0;
    }

    return(Buffer);
}



/***************************************************************************\
* CheckVideoSelection
*
* History:
* 15-Mar-93 Andreva          Created.
\***************************************************************************/

VOID
CheckVideoSelection(
    HINSTANCE hInstance
)

{
    //
    // First check if we are in a detection mode.
    // If we are, spawn the applet and let the user pick the mode.
    //
    // Otherwise, check to see if the display was initialized properly.
    // We may want to move this to a more appropriate place at a later date.
    //
    // Andreva
    //

    NTSTATUS Status;
    HANDLE HkRegistry;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    TCHAR achDispMode[512];
    TCHAR achDisp[512];
    TCHAR achExec[MAX_PATH];

    DWORD Mesg = 0;
    LPTSTR psz = NULL;
    DWORD cb, dwType;
    DWORD data;

    if ( NtCurrentPeb()->SessionId != 0 ) {
        // Only do this for Console
        return;

    }

    //
    // Check for a new driver installation
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet"
                         L"\\Control\\GraphicsDrivers\\DetectDisplay");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&HkRegistry,
                       GENERIC_READ | GENERIC_WRITE | DELETE,
                       &ObjectAttributes);


    if (!NT_SUCCESS(Status)) {

        //
        // Check for a new driver installation
        //

        RtlInitUnicodeString(&UnicodeString,
                             L"\\Registry\\Machine\\System\\CurrentControlSet"
                             L"\\Control\\GraphicsDrivers\\NewDisplay");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenKey(&HkRegistry,
                           GENERIC_READ | GENERIC_WRITE | DELETE,
                           &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {

            //
            // Check for an invalid driver (like a 3.51 driver) or a badly
            // configured driver.
            //

            RtlInitUnicodeString(&UnicodeString,
                                 L"\\Registry\\Machine\\System\\CurrentControlSet"
                                 L"\\Control\\GraphicsDrivers\\InvalidDisplay");

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtOpenKey(&HkRegistry,
                               GENERIC_READ | GENERIC_WRITE | DELETE,
                               &ObjectAttributes);

        }
    }

    //
    // If any of the the error keys were opened successfully, then close the
    // key and spawn the applet (we only delete the invalid display key, not
    // the DetectDisplay key !)
    //

    if (NT_SUCCESS(Status)) {

        NtClose(HkRegistry);

        LoadString(hInstance,
                   IDS_DISPLAYAPPLET,
                   achExec, sizeof(achExec) / sizeof( TCHAR ));

        ExecApplication(achExec, FALSE, TRUE, FALSE, SW_SHOWNORMAL);

    }
}


/***************************************************************************\
* InitializeMisc
*
* History:
* 14-Jul-95 EricFlo          Created.
\***************************************************************************/

void InitializeMisc (HINSTANCE hInstance)
{
    HKEY hkeyMM;
    DWORD dwTempFile, cbTempFile, dwType;
    TCHAR achExec[MAX_PATH];

    //
    // check the page file. If there is not one, then spawn the vm applet
    //

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szMemMan, 0, KEY_READ,
            &hkeyMM) == ERROR_SUCCESS) {

        cbTempFile = sizeof(dwTempFile);
        if (RegQueryValueEx (hkeyMM, szNoPageFile, NULL, &dwType,
                (LPBYTE) &dwTempFile, &cbTempFile) != ERROR_SUCCESS ||
                dwType != REG_DWORD || cbTempFile != sizeof(dwTempFile)) {
            dwTempFile = 0;
        }

        RegCloseKey(hkeyMM);
    } else
        dwTempFile = 0;

    if (dwTempFile == 1) {
        LoadString(hInstance, IDS_VMAPPLET, achExec, sizeof(achExec) / sizeof( TCHAR ));
        ExecProcesses(TEXT("vmapplet"), achExec, TRUE, FALSE, TRUE);
    }


    //
    // Tell the user if he has an invalid video selection.
    //

    CheckVideoSelection(hInstance);


    //
    // Notify other system components that a new
    // user has logged into the workstation.
    //
    NewLogonNotify();

}


#ifdef LOGGING

#define DATEFORMAT  TEXT("%d-%d %.2d:%.2d:%.2d:%.3d ")

/***************************************************************************\
* _WriteLog
*
* History:
* 22-Mar-93 Robertre          Created.
\***************************************************************************/

void
_WriteLog(
    LPCTSTR LogString
    )
{
    TCHAR Buffer[MAX_PATH];
    SYSTEMTIME st;
    TCHAR FormatString[MAX_PATH];


    #_#_lstrcpy( FormatString, DATEFORMAT );
    #_#_lstrcat( FormatString, LogString );
    #_#_lstrcat( FormatString, TEXT("\r\n") );

    GetLocalTime( &st );

    //
    // Construct the message
    //

    #_#_wsprintf( Buffer,
              FormatString,
              st.wMonth,
              st.wDay,
              st.wHour,
              st.wMinute,
              st.wSecond,
              st.wMilliseconds
              );

    OutputDebugString (Buffer);
}

#endif


DWORD
WINAPI
AddToMessageAlias(
    PVOID params
    )
/***************************************************************************\
* AddToMessageAlias
*
* History:
* 10-Apr-93 Robertre       Created.
\***************************************************************************/
{
    HANDLE hShellReadyEvent;

    WCHAR UserName[MAX_PATH + 1];
    DWORD UserNameLength = sizeof(UserName) / sizeof(*UserName);
    DWORD dwCount;

    BOOL  standardShellWasStarted = *(BOOL *)params;

    //
    // Add the user's msg alias.
    //

    WriteLog(TEXT("Userinit: Adding MsgAlias"));

    if (GetUserNameW(UserName, &UserNameLength)) {
        AddMsgAlias(UserName);
    } else {
        UIPrint(("GetUserName failed, error = %d",GetLastError()));
    }

    WriteLog( TEXT("Userinit: Finished adding MsgAlias"));

    if (standardShellWasStarted )
    {
        dwCount = 0;
        while (TRUE) {
    
            hShellReadyEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,L"ShellReadyEvent");
    
            if (hShellReadyEvent == NULL)
            {
                if (GetLastError() == ERROR_FILE_NOT_FOUND) {
    
                    if (dwCount < 5) {
                         Sleep (3000);
                         dwCount++;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            else
            {
                WaitForSingleObject(hShellReadyEvent, INFINITE);
                Sleep(20000);
                CloseHandle(hShellReadyEvent);
                break;
            }
        }
    }

    SpoolerInit();


    return( NO_ERROR );
}

BOOL
StartTheShell(
    void
    )
/***************************************************************************\
* StartTheShell
*
* Starts the shell, either explorer, the shell value specified in
* the registry for winlogon, or the alternate shell that is specified
* by the safeboot procedure.
*
* retrun
*   TRUE if the standard shell was executed
*   FALSE if a non-standard shell was executed.
*
* 14-Jan-98 WesW     Created.
\***************************************************************************/
{
    HKEY    hKey;
    DWORD   dwSize, dwType;
    WCHAR   ShellCmdLine[MAX_PATH];
    DWORD   UseAlternateShell = 0;
    HRESULT hr = S_OK;
    
    //
    // get the safeboot mode
    //

    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("system\\currentcontrolset\\control\\safeboot\\option"),
            0,
            KEY_READ,
            &hKey
            ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        RegQueryValueEx (
            hKey,
            TEXT("UseAlternateShell"),
            NULL,
            &dwType,
            (LPBYTE) &UseAlternateShell,
            &dwSize
            );

        RegCloseKey( hKey );

        if (UseAlternateShell) {

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("system\\currentcontrolset\\control\\safeboot"),
                    0,
                    KEY_READ,
                    &hKey
                    ) == ERROR_SUCCESS)
            {
                dwSize = sizeof(ShellCmdLine);
                if (RegQueryValueEx (
                    hKey,
                    TEXT("AlternateShell"),
                    NULL,
                    &dwType,
                    (LPBYTE) ShellCmdLine,
                    &dwSize
                    ) != ERROR_SUCCESS || ShellCmdLine[0] == 0)
                {
                    UseAlternateShell = 0;
                }
                RegCloseKey( hKey );
            } else {
                UseAlternateShell = 0;
            }
        }

    }

    //
    // Before we start the shell, we must re-enable the shell's script 
    // zone security checks -- if we can't do this, it is not safe
    // to start the shell since it may allow the user to run
    // unsafe code without notification.
    //
    if ( ! EnableScriptZoneSecurityCheck() )
    {
        //
        // We have to exit, and return TRUE which means that we failed to start
        // the standard shell.  We do this even if an alternate shell was desired since
        // whenever the alternate shell fails to launch for some other reason, 
        // we try to launch explorer.exe and would return TRUE in that case.
        //
        return TRUE;
    }

    if (IsTSAppCompatOn()) {
        if ( !ExecProcesses(TEXT("AppSetup"), NULL, FALSE, TRUE, TRUE ) ) {
            ExecProcesses(TEXT("AppSetup"), NULL, TRUE, TRUE, TRUE);
        }
    }

    if (UseAlternateShell) {
        if (ExecApplication(ShellCmdLine, FALSE, FALSE, FALSE, SW_MAXIMIZE)) {
            return FALSE; // an alt-shell was executed
        }
    } else if (NtCurrentPeb()->SessionId != 0) {

        //
        //  Terminal Server: For remote sessions query the Terminal Server service
        //  to see if this session has specified a initial program other than
        //  explorer.exe.
        //

        BOOLEAN bExecOk = TRUE;
        BOOLEAN IsWorkingDirWrong = FALSE;
        UINT ErrorStringId;
        LPTSTR  psz = NULL;
        LPTSTR  pszerr = NULL;
        ULONG Length;
        BOOLEAN Result, fStartCtfmon = FALSE;
        HANDLE  dllHandle;
        WCHAR   szCtfmonPath[MAX_PATH];
        DWORD   cbSize;

        //
        // Load winsta.dll
        //
        dllHandle = LoadLibraryW(L"winsta.dll");

        if (dllHandle) {

            WINSTATIONCONFIG *pConfigData = LocalAlloc(LPTR, sizeof(WINSTATIONCONFIG));
            
            if (pConfigData) {

                PWINSTATION_QUERY_INFORMATION pfnWinstationQueryInformation;

                pfnWinstationQueryInformation = (PWINSTATION_QUERY_INFORMATION) GetProcAddress(
                                                                        dllHandle,
                                                                        "WinStationQueryInformationW"
                                                                        );
                if (pfnWinstationQueryInformation) {




                    Result = pfnWinstationQueryInformation( SERVERNAME_CURRENT,
                                                             LOGONID_CURRENT,
                                                             WinStationConfiguration,
                                                             pConfigData,
                                                             sizeof(WINSTATIONCONFIG),
                                                             &Length );

                    if (Result && pConfigData->User.InitialProgram[0] ) {

                        //BUGID - 342176

                        if( !ExpandEnvironmentStrings( pConfigData->User.InitialProgram, ShellCmdLine,  MAX_PATH ) )
                        {
                            hr = StringCchCopy( ShellCmdLine, MAX_PATH, pConfigData->User.InitialProgram );
                            if( FAILED(hr) ){
                                SetLastError(HRESULT_CODE(hr));
                                bExecOk = FALSE;
                                goto badexec;
                            }
                        }

                        //
                        // If a working directory is specified,
                        // then attempt to change the current directory to it.
                        //

                        if ( pConfigData->User.WorkDirectory[0] ) {

                            WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];

                            if ( !ExpandEnvironmentStrings( pConfigData->User.WorkDirectory, WorkDirectory, DIRECTORY_LENGTH + 1 ) ) {
                                hr = StringCchCopy( WorkDirectory, DIRECTORY_LENGTH + 1, pConfigData->User.WorkDirectory );
                                if( FAILED(hr) ){
                                    SetLastError(HRESULT_CODE(hr));
                                    bExecOk = FALSE;
                                    goto badexec;
                                }
                            }

                            bExecOk = (BYTE) SetCurrentDirectory( WorkDirectory );
                        }

                        pszerr = pConfigData->User.WorkDirectory;

                        if ( !bExecOk ) {

                            DbgPrint( "USERINIT: Failed to set working directory %ws for SessionId %u\n",
                                        pConfigData->User.WorkDirectory, NtCurrentPeb()->SessionId );

                            IsWorkingDirWrong = TRUE;
                            goto badexec;

                        } else { 

                            //
                            // Also check the Registry and start ctfmon.exe 
                            // This is so that, when we r in TS single application mode, langbar will appear for FE systems
                            //
                            cbSize = sizeof(szCtfmonPath);
    
                            fStartCtfmon = RegCheckCtfmon(szCtfmonPath, cbSize);
    
                            if (fStartCtfmon) {
                                WCHAR CtfmonCmdLine[MAX_PATH];
    
                                if( !ExpandEnvironmentStrings( szCtfmonPath, CtfmonCmdLine, MAX_PATH ) ) {
                                    hr = StringCchCopy( CtfmonCmdLine, MAX_PATH, szCtfmonPath );
                                    if( FAILED(hr) ) {
                                        SetLastError(HRESULT_CODE(hr));
                                        bExecOk = FALSE;
                                        goto badexec;
                                    }
                                }

                                bExecOk = (BYTE)ExecApplication( CtfmonCmdLine, FALSE, FALSE, FALSE, SW_SHOWNORMAL );

                                if (!bExecOk) {
                                    // Ctfmon failed to start because of some reason
                                    // Lets not fail - atleast we should try to start the Application
                                    // This will fall back to the original behavior without langbar
                                    DbgPrint("USERINIT: Failed to start ctfmon.exe in TS Single App mode ! \n");
                                }
                            } 
                        }

                        bExecOk = (BYTE)ExecApplication( ShellCmdLine, FALSE, FALSE,
                                    FALSE,(USHORT)(pConfigData->User.fMaximize ? SW_SHOWMAXIMIZED : SW_SHOW) );

                        pszerr = ShellCmdLine;

                    badexec:

                        if ( !bExecOk ) {
                            DWORD   rc;
                            BOOL    bGotString;
                            #define PSZ_MAX 256
                            WCHAR   pszTemplate[PSZ_MAX];
                            LPTSTR  errbuf = NULL;

                            rc = GetLastError();
                            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                           FORMAT_MESSAGE_MAX_WIDTH_MASK,
                                           NULL,
                                           rc,
                                           0,
                                           (LPTSTR) (&psz),
                                           1,
                                           NULL);

                            if (psz) {
                                if (IsWorkingDirWrong == TRUE)
                                {
                                    ErrorStringId = IDS_FAILING_WORKINGDIR;
                                }
                                else
                                {
                                    ErrorStringId = IDS_FAILING_SHELLCOMMAND;
                                }
                                bGotString = LoadString(NULL,ErrorStringId,pszTemplate,PSZ_MAX);
                                if (bGotString) {
                                    errbuf = LocalAlloc(LPTR,  512 * sizeof(TCHAR));
                                    if (errbuf) {
                                        hr = StringCchPrintf( errbuf, 512, pszTemplate, psz, pszerr );
                                        ASSERT(SUCCEEDED(hr));
                                    }

                                }
                                LocalFree(psz);
                            }
                            else {
                                if (IsWorkingDirWrong == TRUE)
                                {
                                    ErrorStringId = IDS_ERROR_WORKINGDIR;
                                }
                                else
                                {
                                    ErrorStringId = IDS_ERROR_SHELLCOMMAND;
                                }
                                bGotString = LoadString(NULL,ErrorStringId,pszTemplate,PSZ_MAX);
                                if (bGotString) {
                                    errbuf = LocalAlloc(LPTR, 512 * sizeof(WCHAR));
                                    if (errbuf) {
                                        hr = StringCchPrintf( errbuf, 512, pszTemplate, rc, pszerr );
                                        ASSERT(SUCCEEDED(hr));
                                    }
                                }
                            }

                            if (bGotString && errbuf) {

                                HelpMessageBox(NULL, NULL, errbuf, NULL, MB_OK | MB_ICONSTOP | MB_HELP, TEXT("MS-ITS:rdesktop.chm::/rdesktop_troubleshoot.htm"));
                                LocalFree(errbuf);
                            }



                        }

                        LocalFree(pConfigData);
                        FreeLibrary(dllHandle);

                        // an alt shell/program was executed
                        return FALSE ;
                    }
                
                }

                LocalFree(pConfigData);

            } // if pConfigData

            FreeLibrary(dllHandle);
        }
    }


    if (!ExecProcesses(TEXT("shell"), NULL, FALSE, FALSE, FALSE)) {
        ExecProcesses(TEXT("shell"), TEXT("explorer"), TRUE, FALSE, FALSE);
    }

    return TRUE; // standard shell/explorer was executed
}

VOID
DoAutoEnrollment(
    LPTSTR Param
    )
{
    if (0==wcscmp(Param, AUTOENROLL_STARTUP)) {
        AutoEnrollThread = CertAutoEnrollment( GetDesktopWindow(), CERT_AUTO_ENROLLMENT_START_UP );
    } else {
        AutoEnrollThread = CertAutoEnrollment( GetDesktopWindow(), CERT_AUTO_ENROLLMENT_WAKE_UP );
    }
}

/***************************************************************************\
* WinMain
*
* History:
* 20-Aug-92 Davidc       Created.
\***************************************************************************/
typedef BOOL (WINAPI * PFNIMMDISABLEIME)( DWORD );

int
WINAPI
WinMain(
    HINSTANCE  hInstance,
    HINSTANCE  hPrevInstance,
    LPSTR   lpszCmdParam,
    int     nCmdShow
    )
{
    LPTSTR lpLogonServer;
    LPTSTR lpOriginalUNCLogonServer;
    LPTSTR lpLogonScript;
    LPTSTR lpMprLogonScripts;
    LPTSTR lpGPOScriptType;
    LPTSTR lpAutoEnroll;
    LPTSTR lpAutoEnrollMode;
    DWORD ThreadId;
    DWORD WaitResult;
    HANDLE ThreadHandle;
    BOOL bRunLogonScriptsSync;
    BOOL bRunGrpConv = FALSE;
    HKEY hKey;
    DWORD dwType, dwSize, dwTemp;
    TCHAR szCmdLine[50];
    BOOL standardShellWasStarted = FALSE;
    HANDLE  hImm = 0;
    PFNIMMDISABLEIME pfnImmDisableIME = 0;
    BOOL OptimizedLogon;
    LPTSTR OptimizedLogonStatus;
    HRESULT hr = S_OK;

    WriteLog(TEXT("Userinit: Starting"));
    if ( GetSystemMetrics( SM_IMMENABLED ) )
    {
        hImm = LoadLibrary( L"imm32.dll");
        if ( hImm )
        {
            pfnImmDisableIME = (PFNIMMDISABLEIME) GetProcAddress(   hImm,
                                                                    "ImmDisableIME" );
            if ( pfnImmDisableIME )
            {
                pfnImmDisableIME( -1 );
            }
        }
    }

    //
    // Determine if we did an optimized logon. By default assume we did not.
    //

    OptimizedLogon = FALSE;

    OptimizedLogonStatus = AllocAndGetEnvironmentVariable(OPTIMIZED_LOGON_VARIABLE);
    if (OptimizedLogonStatus) {
        if (lstrcmp(OptimizedLogonStatus, TEXT("1")) == 0) {
            OptimizedLogon = TRUE;
        }
        Free(OptimizedLogonStatus);
    }
    SetEnvironmentVariable(OPTIMIZED_LOGON_VARIABLE, NULL);
    
    //
    // Check if userinit is being started to just run GPO scripts
    //

    lpGPOScriptType = AllocAndGetEnvironmentVariable(GPO_SCRIPT_TYPE_VARIABLE);

    //
    // Check if userinit.exe is being run just for auto enrollment
    //

    lpAutoEnroll = AllocAndGetEnvironmentVariable( AUTOENROLL_VARIABLE );
    lpAutoEnrollMode = AllocAndGetEnvironmentVariable( AUTOENROLLMODE_VARIABLE );

    SetEnvironmentVariable(AUTOENROLL_VARIABLE, NULL);

    if (lpGPOScriptType) {

        //
        // Userinit was started to execute GPO scripts only
        //
        // Clean up the environment block
        //

        SetEnvironmentVariable(GPO_SCRIPT_TYPE_VARIABLE, NULL);


        //
        // Execute the scripts and clean up
        //

        RunGPOScripts (lpGPOScriptType);

        Free(lpGPOScriptType);


        //
        // We're finished.  Exit now.
        //

        if ( lpAutoEnroll == NULL )
        {
            goto Exit ;
        }
    }

    if ( lpAutoEnroll )
    {
        if ( ( wcscmp( lpAutoEnroll, AUTOENROLL_NONEXCLUSIVE ) == 0 ) ||
             ( wcscmp( lpAutoEnroll, AUTOENROLL_EXCLUSIVE ) == 0 ) )
        {
            if( lpAutoEnrollMode )
            {
                DoAutoEnrollment(  lpAutoEnrollMode );
            }

            if ( wcscmp( lpAutoEnroll, AUTOENROLL_EXCLUSIVE ) == 0 )
            {
                goto Exit;
            }

        }
    }
    //
    // Check if grpconv.exe needs to be run
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bRunGrpConv);
        if (ERROR_SUCCESS == RegQueryValueEx (hKey, GRPCONV_REG_VALUE_NAME, NULL, &dwType,
                         (LPBYTE) &bRunGrpConv, &dwSize))
        {
            if (REG_DWORD != dwType)
            {
                bRunGrpConv = FALSE;    // Restore default
            }
        }

        RegCloseKey (hKey);
    }


    //
    // Run grpconv.exe if requested
    //

    if (bRunGrpConv) {
        WriteLog(TEXT("Userinit: Running grpconv.exe"));
        ExecApplication(g_szGrpConvExe, FALSE, TRUE, FALSE, SW_SHOWNORMAL);
    }


    //
    // Get the logon script environment variables
    //

    lpLogonServer = AllocAndGetEnvironmentVariable(LOGON_SERVER_VARIABLE);
    lpLogonScript = AllocAndGetEnvironmentVariable(LOGON_SCRIPT_VARIABLE);
    lpMprLogonScripts = AllocAndGetEnvironmentMultiSz(MPR_LOGON_SCRIPT_VARIABLE);


    //
    // Delete the logon script environment variables
    //

    SetEnvironmentVariable(LOGON_SERVER_VARIABLE, NULL);
    SetEnvironmentVariable(LOGON_SCRIPT_VARIABLE, NULL);
    SetEnvironmentVariable(MPR_LOGON_SCRIPT_VARIABLE, NULL);

    //
    // See if logon scripts are to be run sync or async
    //

    bRunLogonScriptsSync = RunLogonScriptSync();

    SetupHotKeyForKeyboardLayout();
    
    //
    // For application server see if we hve any .ini file/registry sync'ing to do
    //We should do it before we start running logon scripts!
    //
    //First Check if Application compatibility is on
    //
    if (IsTSAppCompatOn())
    {
        HANDLE  dllHandle;
        
        if (lpMprLogonScripts) {
            //Force to run logon script sync when a provider logon script exists when the system
            //is a terminal server. This is because of the global flag on the registry 
            // doesn't work when two interactive users logon at the same time.
            bRunLogonScriptsSync = TRUE;
        } 

        //
        // Load tsappcmp.dll
        //
        dllHandle = LoadLibrary (TEXT("tsappcmp.dll"));

        if (dllHandle) {

            PTERMSRCHECKNEWINIFILES pfnTermsrvCheckNewIniFiles;

            pfnTermsrvCheckNewIniFiles = (PTERMSRCHECKNEWINIFILES) GetProcAddress(
                                                            dllHandle,
                                                            "TermsrvCheckNewIniFiles"
                                                            );
            if (pfnTermsrvCheckNewIniFiles) {

                pfnTermsrvCheckNewIniFiles();
            }
        
            FreeLibrary(dllHandle);
        }
    }

    //
    // If logon scripts can be run async then start the shell first.
    //

    if (bRunLogonScriptsSync) {

        //
        // Disable the shell's ie zone checking for the processes we 
        // are starting along with all their child processes
        //
        (void) DisableScriptZoneSecurityCheck();

        RunLogonScript(lpLogonServer, lpLogonScript, bRunLogonScriptsSync, TRUE);
        RunMprLogonScripts(lpMprLogonScripts, bRunLogonScriptsSync);

        standardShellWasStarted = StartTheShell();

    } else {

        WriteLog(TEXT("Userinit: Starting the shell"));
        standardShellWasStarted = StartTheShell();

        (void) DisableScriptZoneSecurityCheck();

        RunLogonScript(lpLogonServer, lpLogonScript, bRunLogonScriptsSync, TRUE);
        RunMprLogonScripts(lpMprLogonScripts, bRunLogonScriptsSync);
    }

    UpdateUserSyncLogonScriptsCache(bRunLogonScriptsSync);

    //
    // Free up the buffers
    //

    Free(lpLogonServer);
    Free(lpLogonScript);
    Free(lpMprLogonScripts);


    //
    // Lower our priority so the shell can start faster
    //

    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_LOWEST);

    //
    // Load remote fonts
    //


    LoadRemoteFonts();

    //
    // Initialize misc stuff
    //

    InitializeMisc (hInstance);


    ThreadHandle = CreateThread(
                       NULL,
                       0,
                       AddToMessageAlias,
                       &standardShellWasStarted,
                       0,
                       &ThreadId
                       );

    if (ThreadHandle)
    {
        WaitResult = WaitForSingleObject( ThreadHandle, TIMEOUT_VALUE );

        if ( WaitResult == WAIT_TIMEOUT )
        {
            //
            // This may never come back, so kill it.
            //

            UIPrint(("UserInit: AddToMessageAlias timeout, terminating thread\n"));
        }

        CloseHandle( ThreadHandle );
    }

    //
    // If appropriate, start proquota.exe
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                  0, KEY_READ, &hKey) == ERROR_SUCCESS) {


        dwTemp = 0;
        dwSize = sizeof(dwTemp);

        if ((ERROR_SUCCESS == RegQueryValueEx (hKey, TEXT("EnableProfileQuota"), NULL, &dwType,
            (LPBYTE) &dwTemp, &dwSize)) && (REG_DWORD == dwType)) {

            if (dwTemp) {
                hr = StringCchCopy (szCmdLine, 50, TEXT("proquota.exe"));
                ASSERT(SUCCEEDED(hr));
                ExecApplication(szCmdLine, FALSE, FALSE, FALSE, SW_SHOWNORMAL);
            }
        }

        RegCloseKey (hKey);
    }


Exit:

    if ( AutoEnrollThread )
    {
        WaitResult = WaitForSingleObject( AutoEnrollThread, INFINITE );

        CloseHandle( AutoEnrollThread );

        AutoEnrollThread = NULL ;
        
    }
    Free(lpAutoEnroll);
    Free(lpAutoEnrollMode);

    if ( hImm )
    {
        FreeLibrary( hImm );
    }
    
    return(0);
}


//
// Determines if logon scripts should be executed sync or async
//

BOOL RunLogonScriptSync()
{
    BOOL bSync = FALSE;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Check for a user preference
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a machine preference
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }


    //
    // Check for a user policy
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_LOGON_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }

    return bSync;
}

//
// Determines if startup scripts should be executed sync or async
//

BOOL RunStartupScriptSync()
{
    BOOL bSync = TRUE;
    HKEY hKey;
    DWORD dwType, dwSize;


    //
    // Check for a machine preference
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_STARTUP_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }


    //
    // Check for a machine policy
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, WINLOGON_POLICY_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        //
        // Check for the sync flag.
        //

        dwSize = sizeof(bSync);
        RegQueryValueEx (hKey, SYNC_STARTUP_SCRIPT, NULL, &dwType,
                         (LPBYTE) &bSync, &dwSize);


        RegCloseKey (hKey);
    }

    return bSync;
}

//
// Notify various components that a new user
// has logged into the workstation.
//

VOID
NewLogonNotify(
   VOID
   )
{
    FARPROC           lpProc;
    HMODULE           hLib;
    HANDLE            hEvent;


    //
    // Load the client-side user-mode PnP manager DLL
    //

    hLib = LoadLibrary(TEXT("setupapi.dll"));

    if (hLib) {

        lpProc = GetProcAddress(hLib, "CMP_Report_LogOn");

        if (lpProc) {

            //
            // Ping the user-mode pnp manager -
            // pass the private id as a parameter
            //

            (lpProc)(0x07020420, GetCurrentProcessId());
        }

        FreeLibrary(hLib);
    }


    //
    // Notify DPAPI that a new user has just logged in. DPAPI will take
    // this opportunity to re-synchronize its master keys if necessary.
    //

    {
        BYTE BufferIn[8] = {0};
        DATA_BLOB DataIn;
        DATA_BLOB DataOut;

        DataIn.pbData = BufferIn;
        DataIn.cbData = sizeof(BufferIn);

        CryptProtectData(&DataIn,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         CRYPTPROTECT_CRED_SYNC,
                         &DataOut);
    }


    //
    // Only do this for Console session
    //

    if ( NtCurrentPeb()->SessionId != 0 ) {
         return;
    }


    //
    // Notify RAS Autodial service that a new
    // user has logged in.
    //

    hEvent = OpenEvent(SYNCHRONIZE|EVENT_MODIFY_STATE, FALSE, L"RasAutodialNewLogonUser");

    if (hEvent) {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}

BOOL SetupHotKeyForKeyboardLayout ()
{
    if (!GetSystemMetrics(SM_REMOTESESSION)) {

        //
        // we dont care about local sessions.
        //
        return TRUE;
    }

    if (GetUserDefaultLangID() != LOWORD(GetKeyboardLayout(0))) {

        //
        // we are in a remote session, and we have different keyboard layouts for client and this users settings.
        // the user should be allowed to switch the keyboard layout even if there is only 1 kbd layout available in his settings.
        // since the current kbd layout is different that the one in his profile.
        //

        WCHAR szCtfmon[] = L"ctfmon.exe";
        WCHAR szCtfmonCmd[] = L"ctfmon.exe /n";
        HKEY hRunOnce;
        DWORD dw;

        //
        // Lets put this in RunOnce.
        //
        if (RegCreateKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Runonce",
               0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
               NULL, &hRunOnce, &dw) == ERROR_SUCCESS) {

            WCHAR *szHotKeyReg = L"Keyboard Layout\\Toggle";
            HKEY  hHotKey;
            WCHAR szHotKeylAltShft[] = L"1";
            WCHAR szNoHotKey[] = L"3";

            RegSetValueEx(hRunOnce, szCtfmon, 0, REG_SZ, (PBYTE)szCtfmonCmd, sizeof(szCtfmonCmd));
            RegCloseKey(hRunOnce);

            if (RegCreateKeyEx(HKEY_CURRENT_USER, szHotKeyReg, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                   NULL, &hHotKey, &dw) == ERROR_SUCCESS) {

                DWORD dwType;
                WCHAR szHotKey[3];
                DWORD dwLen = sizeof(szHotKey);
                BOOL bResetHotkey = FALSE;

                if (RegQueryValueEx(hHotKey, L"Hotkey", NULL, &dwType,
                                    (PBYTE)szHotKey, &dwLen) != ERROR_SUCCESS) {

                    bResetHotkey = TRUE;
                }

                if (bResetHotkey || !wcscmp(szHotKey, szNoHotKey))
                {

                    //
                    // setup the registry for Hotkey.
                    //
                    if (RegSetValueEx(hHotKey, L"Hotkey", 0, REG_SZ,
                           (const BYTE *)szHotKeylAltShft, sizeof(szHotKeylAltShft)) == ERROR_SUCCESS) {

                         //
                         // now make call to read this registry and set the hotkey appropriately.
                         //
                         SystemParametersInfo( SPI_SETLANGTOGGLE, 0, NULL, 0);
                    }
                }

                RegCloseKey(hHotKey);
            }
        }
    }

    return TRUE;
}

/****************************************************************************
IsTSAppCompatOn()
Purpose:
    Checks if TS application compatibility is enabled.
    returns TRUE if enabled, FALSE - if not enabled or on case of error.
Comments:
    This function goes to the registry only once.
    All other times it just returnes the value.
****************************************************************************/
BOOL 
IsTSAppCompatOn()
{
    
    static BOOL bAppCompatOn = FALSE;
    static BOOL bFirst = TRUE;

    if(bFirst)
    {
        HKEY hKey;
        if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                          KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS ) 
        {
            DWORD dwValue = 0;
            DWORD dwType;
            DWORD dwSize = sizeof(dwValue);
        
            if( RegQueryValueEx(hKey, REG_TERMSRV_APPCOMPAT,
                NULL, &dwType, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS )
            {
                bAppCompatOn = (dwValue != 0);   
            }

            RegCloseKey(hKey);
        }

        bFirst = FALSE;
    }

    return bAppCompatOn;
}

/****************************************************************************
UpdateUserSyncLogonScriptsCache()
Purpose:
    Update user's sync-logon-scripts setting cache in profile list.   
****************************************************************************/

VOID
UpdateUserSyncLogonScriptsCache(BOOL bSync)
{
    HANDLE UserToken;
    HKEY UserKey;
    PWCHAR UserSidString;
    PWCHAR KeyPath;
    ULONG Length;
    HRESULT hr  =  S_OK;

    //
    // Update user's sync-logon-scripts setting cache in profile list.
    //

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &UserToken)) {

        UserSidString = GetSidString(UserToken);

        if (UserSidString) {

            Length = 0;
            Length += wcslen(PROFILE_LIST_PATH);
            Length += wcslen(L"\\");
            Length += wcslen(UserSidString);

            KeyPath = Alloc((Length + 1) * sizeof(WCHAR));

            if (KeyPath) {

                hr = StringCchCopy(KeyPath, Length + 1, PROFILE_LIST_PATH);
                ASSERT(SUCCEEDED(hr));
                hr = StringCchCat(KeyPath, Length + 1, L"\\");
                ASSERT(SUCCEEDED(hr));
                hr = StringCchCat(KeyPath, Length + 1, UserSidString);
                ASSERT(SUCCEEDED(hr));

                if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, KeyPath, 0,
                      KEY_SET_VALUE, &UserKey) == ERROR_SUCCESS) {

                    RegSetValueEx(UserKey, SYNC_LOGON_SCRIPT, 0, REG_DWORD, 
                                  (BYTE *) &bSync, sizeof(bSync));
                
                    RegCloseKey(UserKey);
                }

                Free(KeyPath);
            }

            DeleteSidString(UserSidString);
        }

        CloseHandle(UserToken);
    }
 
    return;
}

//
// RegCheckCtfMon - checks if the following reg key is present and returns the Application path present there
// HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run /ctfmon.exe
//

BOOLEAN 
RegCheckCtfmon(PWCHAR szCtfmon, DWORD cbSize)
{

    HKEY     hCtfmon = NULL;
    DWORD    dwValueType;
    DWORD    dwError;
    BOOLEAN  bFound = FALSE;

    dwError = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    CTFMON_KEY,
                    0,
                    KEY_QUERY_VALUE,
                    &hCtfmon
                    );

    if (dwError != ERROR_SUCCESS) {
        return bFound;
    }

    // Check to query the value under "ctfmon.exe" subkey

    dwError = RegQueryValueEx(
                    hCtfmon,
                    REG_CTFMON,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szCtfmon,
                    &cbSize                 // number of bytes in szCtfmon
                    );

    if (ERROR_SUCCESS == dwError && dwValueType == REG_SZ) {
        // Reg key is present 
        szCtfmon[MAX_PATH-1] = L'\0';
        bFound = TRUE;
    }

    RegCloseKey(hCtfmon);
    return bFound;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\wlballoon\debug.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File   : Debug.h

  Content: Global debug facilities.

  History: 03-22-2001   dsie     created

------------------------------------------------------------------------------*/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DBG
#include <shlwapi.h>
void DebugTrace(LPCSTR pszFormat, ...)
{
    va_list arglist;
    char szBuffer[512]  = "";
    char szMessage[640] = "[Wlballoon] - ";

    va_start(arglist, pszFormat);
    if (0 < wvnsprintfA(szBuffer, sizeof(szBuffer), pszFormat, arglist))
    {
        lstrcatA(szMessage, szBuffer);
        OutputDebugStringA(szMessage);
    }
    va_end(arglist);

    return;
}
#else
inline void DebugTrace(LPCSTR pszFormat, ...) {};
#endif

#ifdef WLBALLOON_PRIVATE_DEBUG
void PrivateDebugTrace(LPCSTR pszFormat, ...)
{
    va_list arglist;
    char szBuffer[512]  = "";
    char szMessage[640] = "[Wlballoon] - ";

    va_start(arglist, pszFormat);
    if (0 < wvnsprintfA(szBuffer, sizeof(szBuffer), pszFormat, arglist))
    {
        lstrcatA(szMessage, szBuffer);
        OutputDebugStringA(szMessage);
    }
    va_end(arglist);

    return;
}
#else
inline void PrivateDebugTrace(LPCSTR pszFormat, ...) {};
#endif


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\userinit.h ===
/****************************** Module Header ******************************\
* Module Name: userinit.h
*
* Copyright (c) 1991, Microsoft Corporation
*
* Main header file for userinit
*
* History:
* 21-Aug-92 Davidc       Created.
\***************************************************************************/


#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <winstaw.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <strsafe.h>

//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


//
// Define a debug print routine
//

#define UIPrint(s)  KdPrint(("USERINIT: ")); \
                    KdPrint(s);            \
                    KdPrint(("\n"));

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

//
// Define the path environment variable
//

#define PATH                   TEXT("PATH")

//
//
// GetProcAddr Prototype for winsta.dll function WinStationQueryInformationW
//

typedef BOOLEAN (*PWINSTATION_QUERY_INFORMATION) (
                    HANDLE hServer,
                    ULONG SessionId,
                    WINSTATIONINFOCLASS WinStationInformationClass,
                    PVOID  pWinStationInformation,
                    ULONG WinStationInformationLength,
                    PULONG  pReturnLength
                    );

typedef void (*PTERMSRCHECKNEWINIFILES) (void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\userinit\msgalias.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msgalias.h

Abstract:

    Prototypes for function that adds message aliases.

Author:

    Dan Lafferty (danl)     28-Oct-1992

Environment:

    User Mode -Win32

Revision History:

    28-Oct-1992     danl
        created

--*/

//
// GetProcAddr Prototypes
//

typedef DWORD   (*PMSG_NAME_ADD) (
                    LPWSTR servername,
                    LPWSTR msgname
                    );

//
// Function Prototypes
//


VOID
AddMsgAlias(
    LPWSTR   Username
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\acui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       acui.h
//
//  Contents:   Authenticode User Interface Provider Definitions
//
//              This is an internal provider interface used by the
//              Authenticode Policy Provider to allow user interaction
//              in determining trust.  This will allow us to replace the
//              UI (including possibly having no UI) and not affect the
//              core Authenticode policy provider.
//
//  History:    08-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ACUI_H__)
#define __ACUI_H__

#include <windows.h>
#include <wintrust.h>
#include <softpub.h>

#if defined(__cplusplus)
extern "C" {
#endif

//
// ACUI_INVOKE_INFO
//
// This structure gives enough information for the provider to invoke the
// appropriate UI. It includes the following data
//
// Window Handle for display
//
// Generic Policy Info (see gentrust.h, note it includes the cert. chain)
//
// SPC SP Opus Information (see authcode.h)
//
// Alternate display name of the subject in case the Opus does not have it
//
// Invoke Reason Code
//     hr == S_OK, the subject is trusted does the user want to override
//     hr != S_OK, the subject is not trusted does the user want to override
//
// Personal Trust database interface
//

typedef struct _ACUI_INVOKE_INFO {

    DWORD                   cbSize;
    HWND                    hDisplay;
    CRYPT_PROVIDER_DATA     *pProvData;
    PSPC_SP_OPUS_INFO       pOpusInfo;
    LPCWSTR                 pwcsAltDisplayName;
    HRESULT                 hrInvokeReason;
    IUnknown*               pPersonalTrustDB;

} ACUI_INVOKE_INFO, *PACUI_INVOKE_INFO;

//
// ACUIProviderInvokeUI
//
// This is the entry point used by authenticode to invoke the provider UI. The
// input is an ACUI_INVOKE_INFO pointer and the return code is an HRESULT which
// is interpreted as follows
//
// hr == S_OK, the subject is trusted
// hr == TRUST_E_SUBJECT_NOT_TRUSTED, the subject is NOT trusted
// Otherwise, some other error has occurred, authenticode is free to do
// what it wants.
//

typedef HRESULT (WINAPI *pfnACUIProviderInvokeUI) (
                                        PACUI_INVOKE_INFO pInvokeInfo
                                        );

HRESULT WINAPI ACUIProviderInvokeUI (PACUI_INVOKE_INFO pInvokeInfo);

//
// NOTENOTE: It is still TBD how UI providers will be registered and loaded
//           by Authenticode.  For now, it will always load a hardcoded
//           default provider and look for the ACUIProviderInvokeUI entry
//           point.
//

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\asn1util.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       asn1util.h
//
//  Contents:   ASN.1 utility functions.
//
//  APIs: 
//              Asn1UtilDecodeLength
//              Asn1UtilExtractContent
//              Asn1UtilIsPKCS7WithoutContentType
//              Asn1UtilAdjustEncodedLength
//              Asn1UtilExtractValues
//              Asn1UtilExtractPKCS7SignedDataContent
//              Asn1UtilExtractCertificateToBeSignedContent
//              Asn1UtilExtractCertificatePublicKeyInfo
//              Asn1UtilExtractKeyIdFromCertInfo
//
//  History:    06-Dec-96    philh   created from kevinr's wincrmsg version
//--------------------------------------------------------------------------

#ifndef __ASN1UTIL_H__
#define __ASN1UTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

#define ASN1UTIL_INSUFFICIENT_DATA  -2

//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define ASN1UTIL_TAG_NULL                   0x00
#define ASN1UTIL_TAG_BOOLEAN                0x01
#define ASN1UTIL_TAG_INTEGER                0x02
#define ASN1UTIL_TAG_BITSTRING              0x03
#define ASN1UTIL_TAG_OCTETSTRING            0x04
#define ASN1UTIL_TAG_OID                    0x06
#define ASN1UTIL_TAG_UTC_TIME               0x17
#define ASN1UTIL_TAG_GENERALIZED_TIME       0x18
#define ASN1UTIL_TAG_CONSTRUCTED            0x20
#define ASN1UTIL_TAG_SEQ                    0x30
#define ASN1UTIL_TAG_SET                    0x31
#define ASN1UTIL_TAG_CONTEXT_0              0x80
#define ASN1UTIL_TAG_CONTEXT_1              0x81

#define ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0  \
                        (ASN1UTIL_TAG_CONSTRUCTED | ASN1UTIL_TAG_CONTEXT_0)
#define ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_1  \
                        (ASN1UTIL_TAG_CONSTRUCTED | ASN1UTIL_TAG_CONTEXT_1)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define ASN1UTIL_LENGTH_INDEFINITE          0x80
#define ASN1UTIL_LENGTH_NULL                0x00

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the DER encoding
//
//  Returns:
//          success - the number of bytes in the length field, >=0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilDecodeLength(
    OUT DWORD   *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD   cbDER);

//+-------------------------------------------------------------------------
//  Point to the content octets in a DER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractContent(
    IN const BYTE *pbDER,
    IN DWORD cbDER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent);

//+-------------------------------------------------------------------------
//  Returns TRUE if we believe this is a Bob special that has ommitted the
//  PKCS #7 ContentType.
//
//  For PKCS #7: an Object Identifier tag (0x06) immediately follows the
//  identifier and length octets. For a Bob special: an integer tag (0x02)
//  follows the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilIsPKCS7WithoutContentType(
    IN const BYTE *pbDER,
    IN DWORD cbDER);

//+-------------------------------------------------------------------------
//  Decode the Asn1 length bytes to possibly downward adjust the length.
//
//  The returned length is always <= cbDER.
//--------------------------------------------------------------------------
DWORD
WINAPI
Asn1UtilAdjustEncodedLength(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    );



typedef struct _ASN1UTIL_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag. Note, for OPTIONAL_STEP_OVER, not optional.
    const BYTE      *rgbTag;
} ASN1UTIL_EXTRACT_VALUE_PARA, *PASN1UTIL_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define ASN1UTIL_MASK_VALUE_OP                  0xFF
#define ASN1UTIL_STEP_INTO_VALUE_OP             1
#define ASN1UTIL_STEP_OVER_VALUE_OP             2
#define ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP    3

#define ASN1UTIL_RETURN_VALUE_BLOB_FLAG         0x80000000
#define ASN1UTIL_RETURN_CONTENT_BLOB_FLAG       0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (ASN1UTIL_STEP_INTO_VALUE_OP)
//  or steps over the value's tag, length and content octets 
//  (ASN1UTIL_STEP_OVER_VALUE_OP or ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  For tag matching, only supports single byte tags.  STEP_OVER values
//  must be definite-length encoded.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all values successfully extracted. For
//                        STEP_INTO, only the tag and length octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        LastError is updated with the error.
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. For OPTIONAL_STEP_OVER, if tag isn't
//  found, pbData and cbData are set to 0.  If a STEP_INTO value is
//  indefinite-length encoded, cbData is set to CMSG_INDEFINITE_LENGTH.
//  If ASN1UTIL_DEFINITE_LENGTH_FLAG is set, then, all returned lengths
//  are definite-length, ie, CMSG_INDEFINITE_LENGTH is never returned.
//
//  If ASN1UTIL_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If ASN1UTIL_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OUT DWORD *pcValue,
    IN const ASN1UTIL_EXTRACT_VALUE_PARA *rgValuePara,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );

#define ASN1UTIL_DEFINITE_LENGTH_FLAG           0x1


//+-------------------------------------------------------------------------
//  Skips past PKCS7 ASN.1 encoded values to get to the SignedData content.
//
//  Checks that the outer ContentType has the SignedData OID and optionally
//  checks the inner SignedData content's ContentType.
//
//  Returns:
//      success - the number of bytes skipped, >=0
//      failure - <0
//
//  If the SignedData content is indefinite-length encoded,
//  *pcbContent is set to CMSG_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
Asn1UtilExtractPKCS7SignedDataContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OPTIONAL const CRYPT_DER_BLOB *pEncodedInnerOID,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );

//+-------------------------------------------------------------------------
//  Verifies this is a certificate ASN.1 encoded signed content.
//  Returns the pointer to and length of the ToBeSigned content.
//
//  Returns an error if the ToBeSigned content isn't definite length
//  encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificateToBeSignedContent(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );

//+-------------------------------------------------------------------------
//  Returns the pointer to and length of the SubjectPublicKeyInfo value in
//  a signed and encoded X.509 certificate.
//
//  Returns an error if the value isn't definite length encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractCertificatePublicKeyInfo(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbPublicKeyInfo,
    OUT const BYTE **ppbPublicKeyInfo
    );


//+-------------------------------------------------------------------------
//  If the Issuer and SerialNumber in the CERT_INFO contains a special
//  KeyID RDN attribute returns TRUE with pKeyId's cbData and pbData updated
//  with the RDN attribute's OCTET_STRING value. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
Asn1UtilExtractKeyIdFromCertInfo(
    IN PCERT_INFO pCertInfo,
    OUT PCRYPT_HASH_BLOB pKeyId
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\wlballoon\wlballoon.cpp ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Microsoft Windows, Copyright (C) Microsoft Corporation, 2000

  File:    Wlballoon.cpp

  Content: Implementation of the notification balloon class.

  History: 03-22-2001   dsie     created

------------------------------------------------------------------------------*/

#pragma warning (disable: 4100)
#pragma warning (disable: 4706)


////////////////////
//
// Include
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winwlx.h>
#include <shobjidl.h>
#include <shellapi.h>
#include <stdio.h>

#include "debug.h"
#include "wlballoon.rh"


////////////////////
//
// Defines
//

#define MAX_RESOURCE_STRING_SIZE                    512
#define IQUERY_CANCEL_INTERVAL                      (10 * 1000)
#define BALLOON_SHOW_TIME                           (15 * 1000)
#define BALLOON_SHOW_INTERVAL                       (2 * 60 * 1000)
#define BALLOON_RESHOW_COUNT                        (0)
#ifdef DBG
#define BALLOON_NOTIFICATION_INTERVAL               60*1000     // Who wants to wait 10 minutes...
#define BALLOON_INACTIVITY_TIMEOUT                  60*1000     // Who wants to wait 15 minutes...
#else
#define BALLOON_NOTIFICATION_INTERVAL               10*60*1000
#define BALLOON_INACTIVITY_TIMEOUT                  15*60*1000
#endif
#define LOGOFF_NOTIFICATION_EVENT_NAME              L"Local\\WlballoonLogoffNotification"
#define KERBEROS_NOTIFICATION_EVENT_NAME            L"WlballoonKerberosNotificationEventName"
//#define KERBEROS_NOTIFICATION_EVENT_NAME            L"KerbNotification"
#define KERBEROS_NOTIFICATION_EVENT_NAME_SC         L"KerbNotificationSC"


////////////////////
//
// Classes
//

class CBalloon : IQueryContinue
{
public:
    CBalloon(HANDLE hEvent);
    ~CBalloon();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();       // S_OK -> Continue, otherwise S_FALSE

    STDMETHODIMP ShowBalloon(HWND hWnd, HINSTANCE hInstance);

private:
    LONG    m_cRef;
    HANDLE  m_hEvent;
};


class CNotify
{
public:
    CNotify();
    ~CNotify();

    DWORD RegisterNotification(LUID luidCurrentUser, HANDLE hUserToken);
    DWORD UnregisterNotification();

private:
    HANDLE  m_hWait;
    HANDLE  m_hLogoffEvent;
    HANDLE  m_hKerberosEvent;
//    HANDLE  m_hKerberosEventSC;
    HANDLE  m_hThread;
    LUID    m_luidCU;
    HANDLE  m_hUserToken;

    static VOID CALLBACK RegisterWaitNotificationCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired);
    static DWORD WINAPI NotificationThreadProc(PVOID lpParameter);
};


////////////////////
//
// Typedefs
//
typedef struct
{
  HANDLE	    hWait;
  HANDLE	    hEvent;
  HMODULE       hModule;
  CNotify *     pNotify;
} LOGOFFDATA, * PLOGOFFDATA;

LPWSTR CreateNotificationEventName(LPCWSTR pwszSuffixName, LUID luidCurrentUser);


//+----------------------------------------------------------------------------
//
// CBalloon
//
//-----------------------------------------------------------------------------

CBalloon::CBalloon(HANDLE hEvent)
{
    m_cRef   = 1;
    m_hEvent = hEvent;
}


//+----------------------------------------------------------------------------
//
// ~CBalloon
//
//-----------------------------------------------------------------------------

CBalloon::~CBalloon()
{
    ASSERT(m_hEvent);

    PrivateDebugTrace("Info: Destroying the balloon event.\n");
    CloseHandle(m_hEvent);

    return;
}


//+----------------------------------------------------------------------------
//
// QueryInterface 
//
//-----------------------------------------------------------------------------

HRESULT CBalloon::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IQueryContinue))
    {
        *ppv = static_cast<IQueryContinue *>(this);
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
// AddRef
//
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBalloon::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


//+----------------------------------------------------------------------------
//
// Release 
//
//-----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBalloon::Release()
{
    ASSERT(0 != m_cRef);
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
        delete this;
    }

    return cRef;
}


//+----------------------------------------------------------------------------
//
// QueryContinue 
//
//-----------------------------------------------------------------------------

STDMETHODIMP CBalloon::QueryContinue()
{
    ASSERT(m_hEvent);

    switch (WaitForSingleObject(m_hEvent, 0))
    {
        case WAIT_OBJECT_0:
            DebugTrace("Info: Logoff event is signaled, dismissing notification balloon.\n");
            return S_FALSE;

        case WAIT_TIMEOUT:
            PrivateDebugTrace("Info: Logoff event not set, continue to show notification balloon.\n");
            return S_OK;

        case WAIT_FAILED:

        default:
            DebugTrace("Error [%#x]: WaitForSingleObject() failed, dismissing notification balloon.\n", GetLastError());
            break;
    }
 
    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
// ShowBalloon
//
//-----------------------------------------------------------------------------

STDMETHODIMP CBalloon::ShowBalloon(HWND hWnd, HINSTANCE hInstance)
{
    HRESULT             hr                                 = S_OK;
    BOOL                bCoInitialized                     = FALSE;
    HICON               hIcon                              = NULL;
    WCHAR               wszTitle[MAX_RESOURCE_STRING_SIZE] = L"";
    WCHAR               wszText[MAX_RESOURCE_STRING_SIZE]  = L"";
    IUserNotification * pIUserNotification                 = NULL;

    PrivateDebugTrace("Entering CBalloon::ShowBalloon.\n");

    ASSERT(m_hEvent);
    ASSERT(hInstance);

    if (FAILED(hr = CoInitialize(NULL)))
    {
        DebugTrace("Error [%#x]: CoInitialize() failed.\n", hr);
        goto ErrorReturn;
    }

    bCoInitialized = TRUE;

    if (FAILED(hr = CoCreateInstance(CLSID_UserNotification,
                                     NULL,
                                     CLSCTX_ALL,
                                     IID_IUserNotification,
                                     (void **) &pIUserNotification)))
    {
        DebugTrace("Error [%#x]: CoCreateInstance() failed.\n", hr);
        goto ErrorReturn;
    }

    if (FAILED(hr = pIUserNotification->SetBalloonRetry(BALLOON_SHOW_TIME, 
                                                        BALLOON_SHOW_INTERVAL, 
                                                        BALLOON_RESHOW_COUNT)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->SetBalloonRetry() failed.\n", hr);
        goto ErrorReturn;
    }

    if (NULL == (hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_KERBEROS_TICKET))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadIcon() failed for IDI_KERBEROS_TICKET.\n", hr);
        goto ErrorReturn;
    }

    if (!LoadStringW(hInstance, IDS_BALLOON_TIP, wszText, MAX_RESOURCE_STRING_SIZE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_TIP.\n", hr);
        goto ErrorReturn;
    }
    
    if (FAILED(hr = pIUserNotification->SetIconInfo(hIcon, wszText)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->SetIconInfo() failed.\n", hr);
        goto ErrorReturn;
    }

    if (!LoadStringW(hInstance, IDS_BALLOON_TITLE, wszTitle, MAX_RESOURCE_STRING_SIZE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_TITLE.\n", hr);
        goto ErrorReturn;
    }
    
    if (!LoadStringW(hInstance, IDS_BALLOON_TEXT, wszText, MAX_RESOURCE_STRING_SIZE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_TEXT.\n", hr);
        goto ErrorReturn;
    }

    if (FAILED(hr = pIUserNotification->SetBalloonInfo(wszTitle, wszText, NIIF_ERROR)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->SetBalloonInfo() failed.\n", hr);
        goto ErrorReturn;
    }

    if (FAILED(hr = pIUserNotification->Show(static_cast<IQueryContinue *>(this), IQUERY_CANCEL_INTERVAL)))
    {
        DebugTrace("Error [%#x]: pIUserNotification->Show() failed.\n", hr);
        goto ErrorReturn;
    }

CommonReturn:

    if (hIcon)
    {
        DestroyIcon(hIcon);
    }

    if (pIUserNotification)
    {
        pIUserNotification->Release();
    }

    if (bCoInitialized)
    {
        CoUninitialize();
    }

    PrivateDebugTrace("Leaving CBalloon::ShowBalloon().\n");

    return hr;

ErrorReturn:

    ASSERT(hr != S_OK);

    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// Function : ShowNotificationBalloonW
//
// Synopsis : Display the notification balloon periodically until the specified
//            event is set.
//
// Parameter: HWND      hWnd
//            HINSTANCE hInstance
//            LPWSTR    lpwszCommandLine - Event name
//            int       nCmdShow
//
// Return   : None.
//
// Remarks  : This function is intended to be called through RunDll32 from
//            Winlogon. The reason we put these in wlnotify.dll is to save
//            distributing another EXE.
//
//            Sample calling command line:
//
//            RunDll32 wlnotify.dll,ShowNotificationBalloon EventName
//
//-----------------------------------------------------------------------------

void CALLBACK ShowNotificationBalloonW(HWND      hWnd,
                                       HINSTANCE hInstance,
                                       LPWSTR    lpwszCommandLine,
                                       int       nCmdShow)
{
    HRESULT    hr             = S_OK;
    HANDLE     hLogoffEvent   = NULL;
    HMODULE    hModule        = NULL;
    CBalloon * pBalloon       = NULL;

    PrivateDebugTrace("Entering ShowNotificationBalloonW().\n");

    if (NULL == (hModule = LoadLibraryW(L"wlnotify.dll")))
    {
        DebugTrace("Error [%#x]: LoadLibraryW() failed for wlnotify.dll.\n", GetLastError());
        goto ErrorReturn;
     }

    if (NULL == lpwszCommandLine)
    {
        DebugTrace("Error [%#x]: invalid argument, lpwszCommandLine is NULL.\n", E_INVALIDARG);
        goto ErrorReturn;
    }

    if (NULL == (hLogoffEvent = OpenEventW(SYNCHRONIZE, FALSE, LOGOFF_NOTIFICATION_EVENT_NAME)))
    {
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", GetLastError(), LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

    if (NULL == (pBalloon = new CBalloon(hLogoffEvent)))
    {
        DebugTrace("Error [%#x]: new CBalloon() failed.\n", ERROR_NOT_ENOUGH_MEMORY);
        goto ErrorReturn;
    }
    hLogoffEvent = NULL;    // this will prevent a double close in the cleanup below.

    if (S_OK == (hr = pBalloon->ShowBalloon(NULL, hModule)))
    {
        WCHAR wszTitle[MAX_RESOURCE_STRING_SIZE] = L"";
        WCHAR wszText[MAX_RESOURCE_STRING_SIZE]  = L"";

        DebugTrace("Info: User clicked on icon.\n");

        if (!LoadStringW(hModule, IDS_BALLOON_DIALOG_TITLE, wszTitle, sizeof(wszTitle) / sizeof(wszTitle[0])))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_DIALOG_TITLE.\n", hr);
            goto CommonReturn;  // hLogoffEvent will be closed in CBalloon destructor
        }

        if (!LoadStringW(hModule,
            GetSystemMetrics(SM_REMOTESESSION) ? IDS_BALLOON_DIALOG_TS_TEXT : IDS_BALLOON_DIALOG_TEXT,
            wszText, sizeof(wszText) / sizeof(wszText[0])))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugTrace("Error [%#x]: LoadStringW() failed for IDS_BALLOON_DIALOG_TEXT.\n", hr);
            goto CommonReturn;  // hLogoffEvent will be closed in CBalloon destructor
        }

        MessageBoxW(hWnd, wszText, wszTitle, MB_OK | MB_ICONERROR);
    }
    else if (S_FALSE == hr)
    {
        DebugTrace("Info: IQueryContinue cancelled the notification.\n");
    }
    else if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
    {
        DebugTrace("Info: Balloon icon timed out.\n");
    }
    else
    {
        DebugTrace("Error [%#x]: pBalloon->ShowBalloon() failed.\n", hr);
    }

CommonReturn:

    if (hLogoffEvent)
    {
        CloseHandle(hLogoffEvent);
    }

    if (pBalloon)
    {
        pBalloon->Release();
    }

    if (hModule)
    {
        FreeLibrary(hModule);
    }

    PrivateDebugTrace("Leaving ShowNotificationBalloonW().\n");

    return;

ErrorReturn:

    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// CNotify
//
//-----------------------------------------------------------------------------

CNotify::CNotify()
{
    m_hWait                   = NULL;
    m_hLogoffEvent            = NULL;
    m_hKerberosEvent          = NULL;
//    m_hKerberosEventSC        = NULL;
    m_hThread                 = NULL;
}


//+----------------------------------------------------------------------------
//
// ~CNotify
//
//-----------------------------------------------------------------------------

CNotify::~CNotify()
{
    PrivateDebugTrace("Info: Destroying the CNotify object.\n");

    if (m_hWait)
    {
        UnregisterWait(m_hWait);
    }

    if (m_hLogoffEvent)
    {
        CloseHandle(m_hLogoffEvent);
    }

    if (m_hKerberosEvent)
    {
        CloseHandle(m_hKerberosEvent);
    }

//    if (m_hKerberosEventSC)
//    {
//        CloseHandle(m_hKerberosEventSC);
//    }

    if (m_hThread)
    {
        CloseHandle(m_hThread);
    }

    return;
}


//+----------------------------------------------------------------------------
//
// RegisterNotification
//
// To register and wait for the Kerberos notification event. When the event is 
// signaled, a ticket icon and balloon will appear in the systray to warn the 
// user about the problem, and suggest them to lock and then unlock the machine 
// with their new password.
//
//-----------------------------------------------------------------------------

DWORD CNotify::RegisterNotification(LUID luidCurrentUser, HANDLE hUserToken)
{
    DWORD   dwRetCode  = 0;
    LPWSTR  lpwstrEventName = NULL;

    PrivateDebugTrace("Entering CNotify::RegisterNotification().\n");

    if (NULL == (m_hLogoffEvent = OpenEventW(SYNCHRONIZE, FALSE, LOGOFF_NOTIFICATION_EVENT_NAME)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", dwRetCode, LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

    if (NULL == (lpwstrEventName = CreateNotificationEventName(KERBEROS_NOTIFICATION_EVENT_NAME, luidCurrentUser)))
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error [%#x]: CreateNotificationEventName() failed\n", dwRetCode);
        goto ErrorReturn;
    }

    if (NULL == (m_hKerberosEvent = CreateEventW(NULL, FALSE, FALSE, lpwstrEventName)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: CreateEventW() failed for event %S.\n", dwRetCode, lpwstrEventName);
        goto ErrorReturn;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        dwRetCode = ERROR_SINGLE_INSTANCE_APP;
        DebugTrace("Error [%#x]: cannot run more than one instance of this code per unique event.\n", dwRetCode);
        goto ErrorReturn;
    }

    free(lpwstrEventName);
    lpwstrEventName = NULL;

        // Failure for this one are not fatal (we will only have a delay)
/*    if (NULL != (lpwstrEventName = CreateNotificationEventName(KERBEROS_NOTIFICATION_EVENT_NAME_SC, luidCurrentUser)))
    {
        if (NULL == (m_hKerberosEventSC = CreateEventW(NULL, FALSE, FALSE, lpwstrEventName)))
        {
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: CreateEventW() failed for event %S.\n", dwRetCode, lpwstrEventName);
        }
    }
    else
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error [%#x]: CreateNotificationEventName() failed\n", dwRetCode);
    }
*/

    m_luidCU = luidCurrentUser;
    m_hUserToken = hUserToken;

    if (!RegisterWaitForSingleObject(&m_hWait,
                                     m_hKerberosEvent,
                                     CNotify::RegisterWaitNotificationCallback,
                                     (PVOID) this,
                                     INFINITE,
                                     WT_EXECUTEONLYONCE))
    {
        dwRetCode = (DWORD) E_UNEXPECTED;
        DebugTrace("Unexpected error: RegisterWaitForSingleObject() failed.\n");
        goto ErrorReturn;
    }

CommonReturn:

    if (NULL != lpwstrEventName)
    {
        free(lpwstrEventName);
    }

    PrivateDebugTrace("Leaving CNotify::RegisterNotification().\n");

    return dwRetCode;

ErrorReturn:

    ASSERT(0 != dwRetCode);

    if (m_hWait)
    {
        UnregisterWait(m_hWait);
        m_hWait = NULL;
    }

    if (m_hLogoffEvent)
    {
        CloseHandle(m_hLogoffEvent);
        m_hLogoffEvent = NULL;
    }
  
    if (m_hKerberosEvent)
    {
        CloseHandle(m_hKerberosEvent);
        m_hKerberosEvent = NULL;
    }
  
/*    if (m_hKerberosEventSC)
    {
        CloseHandle(m_hKerberosEventSC);
        m_hKerberosEventSC = NULL;
    }
*/  
    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// UnregisterNotification
//
// Unregister the Kerberos notification wait event registered by 
// RegisterNotification().
//
//-----------------------------------------------------------------------------

DWORD CNotify::UnregisterNotification()
{
    DWORD dwRetCode = 0;

    PrivateDebugTrace("Entering CNotify::UnregisterNotification().\n");

        // No thread won't start anymore
    if (m_hWait)
    {
        UnregisterWait(m_hWait);
        m_hWait = NULL;
    }

        // That should be safe
    if (m_hThread)
    {
        if (WaitForSingleObject(m_hThread, INFINITE) == WAIT_FAILED)
        {
            DebugTrace("Error [%#x]: WaitForSingleObject() on the thread failed.\n", GetLastError());
        }
    }
 
    PrivateDebugTrace("Leaving CNotify::UnregisterNotification().\n");

    return dwRetCode;
}


//+----------------------------------------------------------------------------
//
// RegisterWaitNotificationCallback
//
//-----------------------------------------------------------------------------

VOID CALLBACK CNotify::RegisterWaitNotificationCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    DWORD dwThreadId = 0;
    CNotify * pNotify = NULL;

    PrivateDebugTrace("Entering CNotify::RegisterWaitNotificationCallback().\n");

    (void) TimerOrWaitFired;
    
    ASSERT(lpParameter);

    pNotify = (CNotify *) lpParameter;

        // We can clean that up at this point (it's OK for EXECUTEONLYONCE callbacks)
    UnregisterWait(pNotify->m_hWait);
    pNotify->m_hWait = NULL;

    if (pNotify->m_hThread)
    {
        CloseHandle(pNotify->m_hThread);
    }

        // Do the work in another thread
    if (NULL == (pNotify->m_hThread = CreateThread(NULL,
                                           0,
                                           (LPTHREAD_START_ROUTINE) CNotify::NotificationThreadProc,
                                           lpParameter,
                                           0,
                                           &dwThreadId)))
    {
        DebugTrace("Error [%#x]: CreateThread() for NotificationThreadProc failed.\n", GetLastError());
    }

    PrivateDebugTrace("Leaving CNotify::RegisterWaitNotificationCallback().\n");

    return;
}


//+----------------------------------------------------------------------------
//
// NotificationThreadProc
//
//-----------------------------------------------------------------------------

DWORD WINAPI CNotify::NotificationThreadProc(PVOID lpParameter)
{

    DWORD               dwWait;
    HANDLE              rhHandles[2];
    STARTUPINFOW        si;
    PROCESS_INFORMATION pi;
    LPWSTR              wszKerberosEventName;
    DWORD               dwRetCode                    = 0;
    WCHAR               wszCommandLine[MAX_PATH * 2];
    CNotify           * pNotify                      = NULL;
    int                 iChars;
 
    PrivateDebugTrace("Entering CNotify::NotificationThreadProc().\n");

    ASSERT(lpParameter);

    pNotify = (CNotify *) lpParameter;

    ASSERT(pNotify->m_hLogoffEvent);
    ASSERT(pNotify->m_hKerberosEvent);
    ASSERT(pNotify->m_hUserToken);

/*    if ((pNotify->m_hKerberosEventSC) &&
        (WAIT_OBJECT_0 == WaitForSingleObject(pNotify->m_hKerberosEventSC, 0)))
    {
            // In this case we want the balloon NOW!
        DebugTrace("Info: SC Event is set too. We want the balloon NOW!\n");
        dwTimeout = 0;
            // We need to set the kerberos event below
        SetEvent(pNotify->m_hKerberosEvent);
    }
*/

    rhHandles[0] = pNotify->m_hLogoffEvent;
    rhHandles[1] = pNotify->m_hKerberosEvent;

    if (NULL == (wszKerberosEventName = CreateNotificationEventName(KERBEROS_NOTIFICATION_EVENT_NAME, pNotify->m_luidCU)))
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error [%#x]: out of memory in NotificationThreadProc.\n", dwRetCode);
        goto ErrorReturn;
    }

    iChars = _snwprintf(wszCommandLine, sizeof(wszCommandLine) / sizeof(wszCommandLine[0]),
                L"RunDll32.exe wlnotify.dll,ShowNotificationBalloon %s", wszKerberosEventName);

    free(wszKerberosEventName);

    if ((iChars < 0) || (iChars == sizeof(wszCommandLine) / sizeof(wszCommandLine[0])))
    {
        DebugTrace("Error: _snwprintf failed in NotificationThreadProc.\n");
        dwRetCode = SEC_E_BUFFER_TOO_SMALL;
        goto ErrorReturn;
    }

    for (;;)
    {
        DebugTrace("Info: Kick off process to show balloon.\n");

        ZeroMemory(&pi, sizeof(pi));
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(si);
        si.lpDesktop = L"WinSta0\\Default";

        if (!CreateProcessAsUserW(
                            pNotify->m_hUserToken,
                            NULL, 
                            wszCommandLine,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi))
        {
            dwRetCode = GetLastError();
            DebugTrace( "Error [%#x]: CreateProcessW() failed.\n", dwRetCode);
            goto ErrorReturn;
        }

        WaitForSingleObject(pi.hProcess, INFINITE);

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);

        DebugTrace("Info: Process showing balloon is done.\n");

            // The user dismissed the balloon
            // We shouldn't show another one for some time.

        switch (dwWait = WaitForSingleObject(rhHandles[0], BALLOON_NOTIFICATION_INTERVAL))
        {
        case WAIT_FAILED:
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: WaitForSingleObject() on the logoff event failed.\n", dwRetCode);
            // fall through

        case WAIT_OBJECT_0:
                // Logoff detected!, get out of here
            DebugTrace("Info: Logoff detected!, get out of here.\n");
            goto CommonReturn;
        }

            // BALLOON_NOTIFICATION_INTERVAL elapsed

            // We ignore all kerb notifications received in the interval (ie we reset the event)
        if (WAIT_FAILED == WaitForSingleObject(rhHandles[1], 0))
        {
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: WaitForSingleObject() on the kerb event failed.\n", dwRetCode);
            goto ErrorReturn;
        }

            // Now we wait for logoff or a new notification
        switch (dwWait = WaitForMultipleObjects(2, rhHandles, FALSE, BALLOON_INACTIVITY_TIMEOUT))
        {
        case WAIT_FAILED:
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: WaitForMultipleleObjects() failed.\n", dwRetCode);
            // fall through

        case WAIT_OBJECT_0:
                // Logoff detected!, get out of here
            DebugTrace("Info: Logoff detected!, get out of here.\n");
            goto CommonReturn;

        case WAIT_OBJECT_0+1:
            DebugTrace("Info: New notification! Let's show the balloon again.\n");
            break;

        case WAIT_TIMEOUT:
            DebugTrace("Info: We've not been useful for a while, let's go away.\n");

                // Let's give us a chance to restart though...    
            if (!RegisterWaitForSingleObject(&pNotify->m_hWait,
                                             pNotify->m_hKerberosEvent,
                                             CNotify::RegisterWaitNotificationCallback,
                                             lpParameter,
                                             INFINITE,
                                             WT_EXECUTEONLYONCE))
            {
                dwRetCode = GetLastError();
                DebugTrace("Error [%#x]: RegisterWaitForSingleObject() failed.\n", dwRetCode);
                goto ErrorReturn;
            }
                // Reset this guy
//            if (pNotify->m_hKerberosEventSC)
//                WaitForSingleObject(pNotify->m_hKerberosEventSC, 0);

            DebugTrace("Info: Registered wait for callback again.\n");
            goto CommonReturn;
        }
    }

CommonReturn:

    PrivateDebugTrace("Leaving CNotify::NotificationThreadProc().\n");
   
    return dwRetCode;

ErrorReturn:

    ASSERT(0 != dwRetCode);

    goto CommonReturn;
}

//+----------------------------------------------------------------------------
//
// GetCurrentUsersLuid
//
//-----------------------------------------------------------------------------
DWORD GetCurrentUsersLuid(LUID *pluid)
{
    DWORD  dwRetCode       = 0;
    DWORD  cb              = 0;
    TOKEN_STATISTICS stats;
    HANDLE hThreadToken    = NULL;

    PrivateDebugTrace("Entering GetCurrentUsersLuid().\n");

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hThreadToken))
        {
            dwRetCode = GetLastError();
            DebugTrace("Error [%#x]: OpenProcessToken() failed.\n", dwRetCode);
            goto CLEANUP;
        }                  
    }

    if (!GetTokenInformation(hThreadToken, TokenStatistics, &stats, sizeof(stats), &cb))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: GetTokenInformation() failed.\n", dwRetCode);
        goto CLEANUP;
    }

    *pluid = stats.AuthenticationId;

CLEANUP:

    if (NULL != hThreadToken)
    {
        CloseHandle(hThreadToken);
    }

    PrivateDebugTrace("Leaving  GetCurrentUsersLuid().\n");

    return dwRetCode;
}

//+----------------------------------------------------------------------------
//
// CreateNotificationEventName
//
//-----------------------------------------------------------------------------

LPWSTR CreateNotificationEventName(LPCWSTR pwszSuffixName, LUID luidCurrentUser)
{
    LPWSTR pwszEventName   = NULL;
    WCHAR  wszPrefixName[] = L"Global\\";
    WCHAR  wszLuid[20]     = L"";
    WCHAR  wszSeparator[]  = L"_";

    PrivateDebugTrace("Entering CreateNotificationEventName().\n");

    wsprintfW(wszLuid, L"%08x%08x", luidCurrentUser.HighPart, luidCurrentUser.LowPart);

    if (NULL == (pwszEventName = (LPWSTR) malloc((lstrlenW(wszPrefixName) + 
                                                  lstrlenW(wszLuid) + 
                                                  lstrlenW(wszSeparator) +
                                                  lstrlenW(pwszSuffixName) + 1) * sizeof(WCHAR))))
    {
        DebugTrace("Error: out of memory.\n");
    }
    else
    {
        lstrcpyW(pwszEventName, wszPrefixName);
        lstrcatW(pwszEventName, wszLuid);
        lstrcatW(pwszEventName, wszSeparator);
        lstrcatW(pwszEventName, pwszSuffixName);
    }

    PrivateDebugTrace("Leaving CreateNotificationEventName().\n");

    return pwszEventName;
}


//+----------------------------------------------------------------------------
//
// LogoffThreadProc
//
//-----------------------------------------------------------------------------

DWORD WINAPI LogoffThreadProc(PVOID lpParameter)
{
    HMODULE     hModule = NULL;
    PLOGOFFDATA pLogoffData;

    PrivateDebugTrace("Entering LogoffThreadProc().\n");

    ASSERT(lpParameter);

    if (pLogoffData = (PLOGOFFDATA) lpParameter)
    {
        if (pLogoffData->hWait)
        {
           UnregisterWait(pLogoffData->hWait);
        }

        if (pLogoffData->pNotify)
        {
            pLogoffData->pNotify->UnregisterNotification();

            delete pLogoffData->pNotify;
        }

        if (pLogoffData->hEvent)
        {
            CloseHandle(pLogoffData->hEvent);
        }

        if (pLogoffData->hModule) 
        {
            hModule = pLogoffData->hModule;
        }

        LocalFree(pLogoffData);
    }

    PrivateDebugTrace("Leaving LogoffThreadProc().\n");

    if (hModule)
    {
        FreeLibraryAndExitThread(hModule, 0);
    }

    return 0;
}


//+----------------------------------------------------------------------------
//
// LogoffWaitCallback
//
//-----------------------------------------------------------------------------

VOID CALLBACK LogoffWaitCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired)
{
    PLOGOFFDATA pLogoffData;

    PrivateDebugTrace("Entering LogoffWaitCallback().\n");

    (void) TimerOrWaitFired;

    ASSERT(lpParameter);

    if (pLogoffData = (PLOGOFFDATA) lpParameter)
    {
        DWORD  dwThreadId = 0;
        HANDLE hThread    = NULL;
        
        if (hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) LogoffThreadProc,
                                   lpParameter,
                                   0,
                                   &dwThreadId))
        {
            CloseHandle(hThread);
        }
        else
        {
            DebugTrace("Error [%#x]: CreateThread() for LogoffThreadProc failed.\n", GetLastError());
        }
    }

    PrivateDebugTrace("Leaving LogoffWaitCallback().\n");
    
    return;
}


//+----------------------------------------------------------------------------
//
// Public
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
// Function : RegisterTicketExpiredNotificationEvent
//
// Synopsis : To register and wait for the Kerberos notification event. When the 
//            event is signaled, a ticket icon and balloon will appear in the 
//            systray to warn the user about the problem, and suggest them to 
//            lock and then unlock the machine with their new password.
//
// Parameter: PWLX_NOTIFICATION_INFO pNotificationInfo
//
// Return   : If the function succeeds, zero is returned.
// 
//            If the function fails, a non-zero error code is returned.
//
// Remarks  : This function should only be called by Winlogon LOGON 
//            notification mechanism with the Asynchronous and Impersonate
//            flags set to 1.
//
//            Also for each RegisterKerberosNotificationEvent() call, a
//            pairing call by Winlogon LOGOFF notification mechanism to 
//            UnregisterKerberosNotificationEvent() must be made at the 
//            end of each logon session.
//
//-----------------------------------------------------------------------------

DWORD WINAPI RegisterTicketExpiredNotificationEvent(PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    DWORD         dwRetCode             = 0;
    LPWSTR        pwszLogoffEventName   = LOGOFF_NOTIFICATION_EVENT_NAME;
    LUID          luidCurrentUser;
    PLOGOFFDATA   pLogoffData           = NULL;

    PrivateDebugTrace("Entering RegisterTicketExpiredNotificationEvent().\n");

    if (NULL == (pLogoffData = (PLOGOFFDATA) LocalAlloc(LPTR, sizeof(LOGOFFDATA))))
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error [%#x]: out of memory.\n", dwRetCode);
        goto ErrorReturn;
     }

    if (NULL == (pLogoffData->hEvent = CreateEventW(NULL, TRUE, FALSE, pwszLogoffEventName)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: CreateEventW() failed for event %S.\n", dwRetCode, pwszLogoffEventName);
        goto ErrorReturn;
    }

    if (ERROR_ALREADY_EXISTS == GetLastError())
    {
        dwRetCode = ERROR_SINGLE_INSTANCE_APP;
        DebugTrace("Error [%#x]: cannot run more than one instance of this code per session.\n", dwRetCode);
        goto ErrorReturn;
    }

    DebugTrace("Info: Logoff event name = %S.\n", pwszLogoffEventName);

    if (0 != (dwRetCode = GetCurrentUsersLuid(&luidCurrentUser)))
    {
        DebugTrace("Error [%#x]: GetCurrentUsersLuid() failed.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (NULL == (pLogoffData->hModule = LoadLibraryW(L"wlnotify.dll")))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: LoadLibraryW() failed.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (NULL == (pLogoffData->pNotify = new CNotify()))
    {
        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
        DebugTrace("Error [%#x]: new CNotify() failed.\n", dwRetCode);
        goto ErrorReturn;
    }

    if (0 != (dwRetCode = pLogoffData->pNotify->RegisterNotification(luidCurrentUser, pNotificationInfo->hToken)))
    {
        goto ErrorReturn;
    }

    if (!RegisterWaitForSingleObject(&pLogoffData->hWait,
                                     pLogoffData->hEvent,
                                     LogoffWaitCallback,
                                     (PVOID) pLogoffData,
                                     INFINITE,
                                     WT_EXECUTEONLYONCE))
    {
        dwRetCode = (DWORD) E_UNEXPECTED;
        DebugTrace("Unexpected error: RegisterWaitForSingleObject() failed for LogoffWaitCallback().\n");
        goto ErrorReturn;
    }

CommonReturn:

    PrivateDebugTrace("Leaving RegisterTicketExpiredNotificationEvent().\n");
    
    return dwRetCode;;
    
ErrorReturn:

    ASSERT(0 != dwRetCode);

    if (pLogoffData)
    {
        if (pLogoffData->hWait)
        {
           UnregisterWait(pLogoffData->hWait);
        }

        if (pLogoffData->pNotify)
        {
            pLogoffData->pNotify->UnregisterNotification();
            delete pLogoffData->pNotify;
        }

        if (pLogoffData->hEvent)
        {
            CloseHandle(pLogoffData->hEvent);
        }

        if (pLogoffData->hModule) 
        {
            FreeLibrary(pLogoffData->hModule);
        }

        LocalFree(pLogoffData);
    }

    goto CommonReturn;
}


//+----------------------------------------------------------------------------
//
// Function : UnregisterTicketExpiredNotificationEvent
//
// Synopsis : To unregister the Kerberos notification wait event registered by 
//            RegisterKerberosNotificationEvent().
//
// Parameter: PWLX_NOTIFICATION_INFO pNotificationInfo
//
// Return   : If the function succeeds, zero is returned.
// 
//            If the function fails, a non-zero error code is returned.
//
// Remarks  : This function should only be called by Winlogon LOGON 
//            notification mechanism with the Asynchronous and Impersonate
//            flags set to 1.
//
//-----------------------------------------------------------------------------

DWORD WINAPI UnregisterTicketExpiredNotificationEvent(PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    DWORD  dwRetCode    = 0;
    HANDLE hLogoffEvent = NULL;

    PrivateDebugTrace("Entering UnregisterTicketExpiredNotificationEvent().\n");

    if (NULL == (hLogoffEvent = OpenEventW(EVENT_MODIFY_STATE, FALSE, LOGOFF_NOTIFICATION_EVENT_NAME)))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: OpenEventW() failed for event %S.\n", dwRetCode, LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

    if (!SetEvent(hLogoffEvent))
    {
        dwRetCode = GetLastError();
        DebugTrace("Error [%#x]: SetEvent() failed for event %S.\n", dwRetCode, LOGOFF_NOTIFICATION_EVENT_NAME);
        goto ErrorReturn;
    }

CommonReturn:

    if (hLogoffEvent)
    {
        CloseHandle(hLogoffEvent);
    }

    PrivateDebugTrace("Leaving UnregisterTicketExpiredNotificationEvent().\n");

    return dwRetCode;
    
ErrorReturn:

    ASSERT(0 != dwRetCode);

    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\catutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       catutil.h
//
//  Contents:   definitions for catalog file utility functions
//
//  History:    01-may-2000 reidk created
//
//--------------------------------------------------------------------------


#ifndef __CATUTIL_H
#define __CATUTIL_H

#ifdef __cplusplus
extern "C"
{
#endif


BOOL
CatUtil_CreateCTLContextFromFileName(
    LPCWSTR         pwszFileName,
    HANDLE          *phMappedFile,
    BYTE            **ppbMappedFile,
    PCCTL_CONTEXT   *ppCTLContext,
    BOOL            fCreateSorted);


#ifdef __cplusplus
}
#endif


#endif // __CATUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\certprot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certprot.h
//
//  Contents:   Certificate Protection APIs
//
//  APIs:       I_CertProtectFunction
//              I_CertCltProtectFunction
//              I_CertSrvProtectFunction
//
//  History:    27-Nov-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPROT_H__
#define __CERTPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Calls the services process to do a protected certificate function,
//  such as, add or delete a protected root certificate.
//
//  CryptMemFree must be called to free the returned *ppbOut.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );

#define CERT_PROT_INIT_ROOTS_FUNC_ID            1
#define CERT_PROT_PURGE_LM_ROOTS_FUNC_ID        2
#define CERT_PROT_ADD_ROOT_FUNC_ID              3
#define CERT_PROT_DELETE_ROOT_FUNC_ID           4
#define CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID  5
#define CERT_PROT_ROOT_LIST_FUNC_ID             6
#define CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID       7
#define CERT_PROT_LOG_EVENT_FUNC_ID             8


//+-------------------------------------------------------------------------
//  CERT_PROT_INIT_ROOTS_FUNC_ID
//
//  Initialize the protected list of CurrentUser roots. Note, no UI.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_PURGE_LM_ROOTS_FUNC_ID
//  
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//
//  Note, no UI. Purging can be disabled by setting the
//  CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG in the registry's ProtectedRootFlags
//  value.
//
//  No IN/OUT parameters.
//
//  Even if purging is disabled, the protected list of roots is still
//  initialized.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_FUNC_ID
//  
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized certificate context to be added. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_ROOT_FUNC_ID
//  
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  certificate's SHA1 hash property. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID
//  
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ROOT_LIST_FUNC_ID
//  
//  Add or remove the signed list of certificates to/from the CurrentUser
//  SystemRegistry "Root" store and the protected list of roots. The user
//  isn't prompted before doing the add or remove.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized CTL containing the signed list of roots to be added or
//  removed. No other IN/OUT parameters.
//
//  CURRENTLY NOT SUPPORTED!!!
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID
//  
//  Add the certificate in the Auto Update CTL to the HKLM AuthRoot store.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized X.509 certificate immediately followed by the 
//  serialized CTL. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_LOG_EVENT_FUNC_ID
//  
//  Logs a crypt32 event.
//
//  pbIn and cbIn must be updated to point to the following
//  CERT_PROT_EVENT_LOG_PARA data structure. It contains the parameters
//  passed to advapi32!ReportEventW.
//
//  wNumString NULL terminated unicode strings immediately follow. Followed by
//  dwDataSize binary data bytes.
//
//  wCategory, wNumStrings and dwDataSize are optional.
//--------------------------------------------------------------------------
typedef struct _CERT_PROT_EVENT_LOG_PARA {
    WORD            wType;
    WORD            wCategory;      // OPTIONAL, may be 0
    DWORD           dwEventID;
    WORD            wNumStrings;    // OPTIONAL, may be 0
    WORD            wPad1;
    DWORD           dwDataSize;     // OPTIONAL, may be 0
} CERT_PROT_EVENT_LOG_PARA, *PCERT_PROT_EVENT_LOG_PARA;

//+-------------------------------------------------------------------------
//  Called from the client process to do the RPC to the server process.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCltProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );



typedef void __RPC_FAR * (__RPC_USER *PFN_CERT_PROT_MIDL_USER_ALLOC)(
    IN size_t cb
    );
typedef void (__RPC_USER *PFN_CERT_PROT_MIDL_USER_FREE)(
    IN void __RPC_FAR *pv
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

typedef DWORD (WINAPI *PFN_CERT_SRV_PROTECT_FUNCTION)(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\certperf.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       certperf.h
//
//  Contents:   Certificate Performance Counter Functions
//
//  APIs: 
//              CertPerfIncrementChainCount
//              CertPerfIncrementChainElementCount
//              CertPerfIncrementChainEngineCurrentCount
//              CertPerfDecrementChainEngineCurrentCount
//              CertPerfIncrementChainEngineTotalCount
//              CertPerfIncrementChainEngineResyncCount
//              CertPerfIncrementChainCertCacheCount
//              CertPerfDecrementChainCertCacheCount
//              CertPerfIncrementChainCtlCacheCount
//              CertPerfDecrementChainCtlCacheCount
//              CertPerfIncrementChainEndCertInCacheCount
//              CertPerfIncrementChainCacheEndCertCount
//              CertPerfIncrementChainRevocationCount
//              CertPerfIncrementChainRevokedCount
//              CertPerfIncrementChainRevocationOfflineCount
//              CertPerfIncrementChainNoRevocationCheckCount
//              CertPerfIncrementChainVerifyCertSignatureCount
//              CertPerfIncrementChainCompareIssuerPublicKeyCount
//              CertPerfIncrementChainVerifyCtlSignatureCount
//              CertPerfIncrementChainBeenVerifiedCtlSignatureCount
//              CertPerfIncrementChainUrlIssuerCount
//              CertPerfIncrementChainCacheOnlyUrlIssuerCount
//              CertPerfIncrementChainRequestedEngineResyncCount
//              CertPerfIncrementChangeNotifyCount
//              CertPerfIncrementChangeNotifyLmGpCount
//              CertPerfIncrementChangeNotifyCuGpCount
//              CertPerfIncrementChangeNotifyCuMyCount
//              CertPerfIncrementChangeNotifyRegCount
//              CertPerfIncrementStoreCurrentCount
//              CertPerfDecrementStoreCurrentCount
//              CertPerfIncrementStoreTotalCount
//              CertPerfIncrementStoreRegCurrentCount
//              CertPerfDecrementStoreRegCurrentCount
//              CertPerfIncrementStoreRegTotalCount
//              CertPerfIncrementRegElementReadCount
//              CertPerfIncrementRegElementWriteCount
//              CertPerfIncrementRegElementDeleteCount
//              CertPerfIncrementCertElementCurrentCount
//              CertPerfDecrementCertElementCurrentCount
//              CertPerfIncrementCertElementTotalCount
//              CertPerfIncrementCrlElementCurrentCount
//              CertPerfDecrementCrlElementCurrentCount
//              CertPerfIncrementCrlElementTotalCount
//              CertPerfIncrementCtlElementCurrentCount
//              CertPerfDecrementCtlElementCurrentCount
//              CertPerfIncrementCtlElementTotalCount
//
//  History:    04-May-99    philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPERF_H__
#define __CERTPERF_H__

#ifdef __cplusplus
extern "C" {

#include <pshpack8.h>

typedef struct _CERT_PERF_PROCESS_COUNTERS {
    LONG            lChainCnt;
    LONG            lChainElementCnt;
    LONG            lChainEngineCurrentCnt;
    LONG            lChainEngineTotalCnt;
    LONG            lChainEngineResyncCnt;
    LONG            lChainCertCacheCnt;
    LONG            lChainCtlCacheCnt;
    LONG            lChainEndCertInCacheCnt;
    LONG            lChainCacheEndCertCnt;
    LONG            lChainRevocationCnt;
    LONG            lChainRevokedCnt;
    LONG            lChainRevocationOfflineCnt;
    LONG            lChainNoRevocationCheckCnt;
    LONG            lChainVerifyCertSignatureCnt;
    LONG            lChainCompareIssuerPublicKeyCnt;
    LONG            lChainVerifyCtlSignatureCnt;
    LONG            lChainBeenVerifiedCtlSignatureCnt;
    LONG            lChainUrlIssuerCnt;
    LONG            lChainCacheOnlyUrlIssuerCnt;
    LONG            lChainRequestedEngineResyncCnt;
    LONG            lChangeNotifyCnt;
    LONG            lChangeNotifyLmGpCnt;
    LONG            lChangeNotifyCuGpCnt;
    LONG            lChangeNotifyCuMyCnt;
    LONG            lChangeNotifyRegCnt;
    LONG            lStoreCurrentCnt;
    LONG            lStoreTotalCnt;
    LONG            lStoreRegCurrentCnt;
    LONG            lStoreRegTotalCnt;
    LONG            lRegElementReadCnt;
    LONG            lRegElementWriteCnt;
    LONG            lRegElementDeleteCnt;
    LONG            lCertElementCurrentCnt;
    LONG            lCertElementTotalCnt;
    LONG            lCrlElementCurrentCnt;
    LONG            lCrlElementTotalCnt;
    LONG            lCtlElementCurrentCnt;
    LONG            lCtlElementTotalCnt;

    //--###  Add New Counters  ###--
} CERT_PERF_PROCESS_COUNTERS, *PCERT_PERF_PROCESS_COUNTERS;

extern PCERT_PERF_PROCESS_COUNTERS pCertPerfProcessCounters;
#include <poppack.h>

__inline
void
CertPerfIncrementChainCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCnt);
}

__inline
void
CertPerfIncrementChainElementCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainElementCnt);
}

__inline
void
CertPerfIncrementChainEngineCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEngineCurrentCnt);
}

__inline
void
CertPerfDecrementChainEngineCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lChainEngineCurrentCnt);
}

__inline
void
CertPerfIncrementChainEngineTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEngineTotalCnt);
}

__inline
void
CertPerfIncrementChainEngineResyncCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEngineResyncCnt);
}


__inline
void
CertPerfIncrementChainCertCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCertCacheCnt);
}

__inline
void
CertPerfDecrementChainCertCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lChainCertCacheCnt);
}


__inline
void
CertPerfIncrementChainCtlCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCtlCacheCnt);
}

__inline
void
CertPerfDecrementChainCtlCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lChainCtlCacheCnt);
}


__inline
void
CertPerfIncrementChainEndCertInCacheCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainEndCertInCacheCnt);
}

__inline
void
CertPerfIncrementChainCacheEndCertCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCacheEndCertCnt);
}


__inline
void
CertPerfIncrementChainRevocationCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRevocationCnt);
}

__inline
void
CertPerfIncrementChainRevokedCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRevokedCnt);
}

__inline
void
CertPerfIncrementChainRevocationOfflineCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRevocationOfflineCnt);
}

__inline
void
CertPerfIncrementChainNoRevocationCheckCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainNoRevocationCheckCnt);
}

__inline
void
CertPerfIncrementChainVerifyCertSignatureCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainVerifyCertSignatureCnt);
}

__inline
void
CertPerfIncrementChainCompareIssuerPublicKeyCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCompareIssuerPublicKeyCnt);
}

__inline
void
CertPerfIncrementChainVerifyCtlSignatureCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainVerifyCtlSignatureCnt);
}

__inline
void
CertPerfIncrementChainBeenVerifiedCtlSignatureCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainBeenVerifiedCtlSignatureCnt);
}

__inline
void
CertPerfIncrementChainUrlIssuerCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainUrlIssuerCnt);
}

__inline
void
CertPerfIncrementChainCacheOnlyUrlIssuerCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainCacheOnlyUrlIssuerCnt);
}

__inline
void
CertPerfIncrementChainRequestedEngineResyncCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChainRequestedEngineResyncCnt);
}

__inline
void
CertPerfIncrementChangeNotifyCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyCnt);
}

__inline
void
CertPerfIncrementChangeNotifyLmGpCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyLmGpCnt);
}

__inline
void
CertPerfIncrementChangeNotifyCuGpCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyCuGpCnt);
}

__inline
void
CertPerfIncrementChangeNotifyCuMyCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyCuMyCnt);
}

__inline
void
CertPerfIncrementChangeNotifyRegCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lChangeNotifyRegCnt);
}

__inline
void
CertPerfIncrementStoreCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreCurrentCnt);
}
__inline
void
CertPerfDecrementStoreCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lStoreCurrentCnt);
}

__inline
void
CertPerfIncrementStoreTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreTotalCnt);
}

__inline
void
CertPerfIncrementStoreRegCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreRegCurrentCnt);
}

__inline
void
CertPerfDecrementStoreRegCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lStoreRegCurrentCnt);
}

__inline
void
CertPerfIncrementStoreRegTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lStoreRegTotalCnt);
}

__inline
void
CertPerfIncrementRegElementReadCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lRegElementReadCnt);
}

__inline
void
CertPerfIncrementRegElementWriteCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lRegElementWriteCnt);
}

__inline
void
CertPerfIncrementRegElementDeleteCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lRegElementDeleteCnt);
}

__inline
void
CertPerfIncrementCertElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCertElementCurrentCnt);
}
__inline
void
CertPerfDecrementCertElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lCertElementCurrentCnt);
}

__inline
void
CertPerfIncrementCertElementTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCertElementTotalCnt);
}

__inline
void
CertPerfIncrementCrlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCrlElementCurrentCnt);
}
__inline
void
CertPerfDecrementCrlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lCrlElementCurrentCnt);
}

__inline
void
CertPerfIncrementCrlElementTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCrlElementTotalCnt);
}

__inline
void
CertPerfIncrementCtlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCtlElementCurrentCnt);
}
__inline
void
CertPerfDecrementCtlElementCurrentCount()
{
    if (pCertPerfProcessCounters)
        InterlockedDecrement(&pCertPerfProcessCounters->lCtlElementCurrentCnt);
}

__inline
void
CertPerfIncrementCtlElementTotalCount()
{
    if (pCertPerfProcessCounters)
        InterlockedIncrement(&pCertPerfProcessCounters->lCtlElementTotalCnt);
}

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\cnvcrypt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       cnvcrypt.h
//
//  Contents:   Temporary Hack for converting the (SDR) version of
//              CryptoAPI 2.0
//----------------------------------------------------------------------------

#ifndef __CNVCRYPT_H__
#define __CNVCRYPT_H__


#if(_WIN32_WINNT >= 0x0400)

#ifdef __cplusplus
extern "C" {
#endif

// In general all digest, Digest, DIGEST changed to: hash, Hash, HASH.

// A Hack to get the old error codes to work
#define CRMSG_E_GENERAL                 CRYPT_E_MSG_ERROR
#define CERT_BAD_PARAMETER              E_INVALIDARG
#define CERT_BAD_LENGTH                 CRYPT_E_BAD_LEN
#define CERT_BAD_ENCODE                 CRYPT_E_BAD_ENCODE
#define CERT_OUT_OF_MEMORY              E_OUTOFMEMORY
#define CERT_MUST_COPY_ENCODED          E_INVALIDARG
#define CERT_OSS_ERROR                  CRYPT_E_OSS_ERROR
#define CERT_STORE_BAD_PARAMETER        E_INVALIDARG
#define CERT_STORE_BAD_LEN              CRYPT_E_BAD_LEN
#define CERT_STORE_BAD_FLAGS            E_INVALIDARG
#define CERT_STORE_BAD_FILE             CRYPT_E_FILE_ERROR
#define CERT_STORE_NO_SUCH_PROPERTY     CRYPT_E_NOT_FOUND
#define CERT_STORE_ALREADY_IN_STORE     CRYPT_E_EXISTS
#define CERT_STORE_NOT_IMPLEMENTED      E_NOTIMPL
#define CERT_STORE_NOT_FOUND            CRYPT_E_NOT_FOUND
#define CERT_STORE_NO_CRYPT_PROV        CRYPT_E_NO_PROVIDER
#define CERT_STORE_SELF_SIGNED          CRYPT_E_SELF_SIGNED
#define CERT_STORE_DELETED_PREV         CRYPT_E_DELETED_PREV
#define CERT_HELPER_NO_MATCH            CRYPT_E_NO_MATCH
#define SCA_BAD_LEN_PARAMETER           CRYPT_E_BAD_LEN
#define SCA_BAD_PARAMETER               E_INVALIDARG
#define SCA_UNEXPECTED_MSG_TYPE         CRYPT_E_UNEXPECTED_MSG_TYPE
#define SCA_NO_CERT_KEY_PROV            CRYPT_E_NO_KEY_PROPERTY
#define SCA_NO_XCHG_CERT                CRYPT_E_NO_DECRYPT_CERT
#define SCA_BAD_MSG                     CRYPT_E_BAD_MSG


// A Hack to get the old APIs to work
#define CertStoreOpen                       CertOpenStore				
// Added dwFlags parameter to CertCloseStore
#define CertStoreClose                      CertCloseStore				
#define CertStoreClean                      CertCleanStore				
#define CertStoreSave                       CertSaveStore
#define CertStoreDuplicate                  CertDuplicateStore
#define CertStoreAddCert                    CertAddEncodedCertificateToStore
#define CertStoreAddCertContext             CertAddCertificateContextToStore
#define CertStoreAddCrl                     CertAddEncodedCRLToStore
#define CertStoreAddCrlContext              CertAddCRLContextToStore
#define CertStoreDeleteCert                 CertDeleteCertificateFromStore
#define CertStoreDeleteCrl                  CertDeleteCRLFromStore
#define CertStoreEnumCert                   CertEnumCertificatesInStore		
#define CertStoreFindCert                   CertFindCertificateInStore		
#define CertStoreGetSubjectCert             CertGetSubjectCertificateFromStore	
#define CertStoreGetCrl                     CertGetCRLFromStore			
#define CertStoreGetIssuerCert              CertGetIssuerCertificateFromStore	
#define CertStoreCreateCert                 CertCreateCertificateContext		
#define CertStoreDuplicateCert              CertDuplicateCertificateContext		
#define CertStoreSetCertProperty            CertSetCertificateContextProperty	
#define CertStoreGetCertProperty            CertGetCertificateContextProperty	
#define CertStoreFreeCert                   CertFreeCertificateContext		
#define CertStoreCreateCrl                  CertCreateCRLContext			
#define CertStoreDuplicateCrl               CertDuplicateCRLContext			
#define CertStoreFreeCrl                    CertFreeCRLContext			
#define CertStoreSetCrlProperty             CertSetCRLContextProperty		
#define CertStoreGetCrlProperty             CertGetCRLContextProperty

#define WinGetSystemCertificateStoreA       CertOpenSystemStoreA			
#define WinGetSystemCertificateStoreW       CertOpenSystemStoreW			
#define WinInsertCertificateA               CertAddEncodedCertificateToSystemStoreA
#define WinInsertCertificateW               CertAddEncodedCertificateToSystemStoreW

#define CertHelperCompareCert               CertCompareCertificate
#define CertHelperCompareCertName           CertCompareCertificateName
#define CertHelperCompareCertNameAttr       CertIsRDNAttrsInCertificateName

// Note parameters changed from PCRYPT_BIT_BLOB to PCERT_PUBLIC_KEY_INFO
#define CertHelperComparePublicKey          CertComparePublicKeyInfo
#define CertComparePublicKeys               CertComparePublicKeyInfo

// Note CertCompareCertificateName takes a PCERT_NAME_BLOB, not a PCERT_INFO
#define CertHelperIsIssuerOfSubjectCert     CertCompareCertificateName
#define CertHelperIsIssuerOfCrl             CertCompareCertificateName

// Note: PublicKey changed from a PCRYPT_BIT_BLOB to a PCERT_PUBLIC_KEY_INFO.
#define CertHelperKeyVerifySignature        CryptVerifyCertificateSignature

#if 0
BOOL
WINAPI
CertHelperVerifySignature(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN PCERT_INFO pIssuerInfo
    );
#else
#define CertHelperVerifySignature(hCryptProv, dwCertEncodingType, \
        pbEncoded, cbEncoded, pIssuerInfo) \
    CryptVerifyCertificateSignature(hCryptProv, dwCertEncodingType, \
        pbEncoded, cbEncoded, &pIssuerInfo->SubjectPublicKeyInfo)
#endif

#define CertHelperDigestToBeSigned          CryptHashToBeSigned
// Added dwFlags to CrytptDigestCertificate and CryptHashPublicKeyInfo
#define CertHelperComputeDigest             CryptHashCertificate
#define CertHelperDigestPublicKeyInfo       CryptHashPublicKeyInfo

// Note added HashAlgid and dwHashFlags parameters.
// Switched the order of the dwKeySpec and dwCertEncodingType parameters.
#define CertHelperSignToBeSigned            CryptSignCertificate
#define CryptSignCertificateContext         CryptSignCertificate

#define CertHelperVerifyCertTimeValidity    CertVerifyTimeValidity
#define CertHelperVerifyCrlTimeValidity     CertVerifyCRLTimeValidity
#define CertHelperVerifyValidityNesting     CertVerifyValidityNesting
#define CertHelperVerifyCertRevocation      CertVerifyRevocation
#define CryptVerifyRevocation               CertVerifyRevocation
#define CertHelperAlgIdToObjId              CertAlgIdToOID
#define CertHelperObjIdToAlgId              CertOIDToAlgId
#define CertHelperFindExtension             CertFindExtension
#define CertHelperFindAttribute             CertFindAttribute
#define CertHelperFindRDNAttr               CertFindRDNAttr
#define CertHelperGetIntendedKeyUsage       CertGetIntendedKeyUsage

// Added deCertEncodingType parameter, returns PCERT_PUBLIC_KEY_INFO instead
// of PBYTE
#define CertHelperGetPublicKey              CryptExportPublicKeyInfo
#define CertGetPublicKey                    CryptExportPublicKeyInfo

#if 0
BOOL
WINAPI
CertHelperCreatePublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    DWORD dwKeySpec,            // AT_SIGNATURE | AT_KEYEXCHANGE
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    );
#else
#define CertHelperCreatePublicKeyInfo(hCryptProv, dwKeySpec, \
        pInfo, pcbInfo) \
    CryptExportPublicKeyInfo(hCryptProv, dwKeySpec, X509_ASN_ENCODING, \
        pInfo, pcbInfo)
#endif

#define CertHelperNameValueToStr            CertRDNValueToStrA
#define CertHelperNameValueToWStr           CertRDNValueToStrW

// For all the SCA_*_PARA: dwVersion has been changed to cbSize.
// cbSize must be set to the sizeof(CRYPT_*_PARA) or else LastError
// will be updated with E_INVALIDARG.

typedef PFN_CRYPT_GET_SIGNER_CERTIFICATE PFN_SCA_VERIFY_SIGNER_POLICY;

typedef CRYPT_SIGN_MESSAGE_PARA SCA_SIGN_PARA;
typedef PCRYPT_SIGN_MESSAGE_PARA PSCA_SIGN_PARA;

// Combined into single dwMsgAndCertEncodingType
typedef CRYPT_VERIFY_MESSAGE_PARA SCA_VERIFY_PARA;
typedef PCRYPT_VERIFY_MESSAGE_PARA PSCA_VERIFY_PARA;

// Added EncryptionAlgid, dwEncryptionFlags
typedef CRYPT_ENCRYPT_MESSAGE_PARA SCA_ENCRYPT_PARA;
typedef PCRYPT_ENCRYPT_MESSAGE_PARA PSCA_ENCRYPT_PARA;

// Combined into single dwMsgAndCertEncodingType
typedef CRYPT_DECRYPT_MESSAGE_PARA SCA_DECRYPT_PARA;
typedef PCRYPT_DECRYPT_MESSAGE_PARA PSCA_DECRYPT_PARA;

// Added HashAlgid, dwHashFlags
typedef CRYPT_HASH_MESSAGE_PARA SCA_DIGEST_PARA;
typedef PCRYPT_HASH_MESSAGE_PARA PSCA_DIGEST_PARA;

// Added dwKeySpec, HashAlgid, dwHashFlags. Combined into single
// dwMsgAndCertEncodingType.
typedef CRYPT_KEY_SIGN_MESSAGE_PARA SCA_NO_CERT_SIGN_PARA;
typedef PCRYPT_KEY_SIGN_MESSAGE_PARA PSCA_NO_CERT_SIGN_PARA;

typedef CRYPT_KEY_VERIFY_MESSAGE_PARA SCA_NO_CERT_VERIFY_PARA;
typedef PCRYPT_KEY_VERIFY_MESSAGE_PARA PSCA_NO_CERT_VERIFY_PARA;

#define SCAEncrypt                          CryptEncryptMessage			
#define SCADecrypt                          CryptDecryptMessage			
#define SCASign                             CryptSignMessage			
#define SCAVerifySignature                  CryptVerifyMessageSignature		
#define SCASignAndEncrypt                   CryptSignAndEncryptMessage		
#define SCADecryptAndVerifySignature        CryptDecryptAndVerifyMessageSignature	
#define SCADigest                           CryptHashMessage			
#define SCAVerifyDigest                     CryptVerifyMessageHash		
#define SCANoCertSign                       CryptSignMessageWithKey			
#define SCANoCertVerifySignature            CryptVerifyMessageSignatureWithKey	
#define SCAVerifyDetachedDigest             CryptVerifyDetachedMessageHash
#define SCAVerifyDetachedSignature          CryptVerifyDetachedMessageSignature	
#define SETSCASignAndExEncrypt              CryptSignAndExEncryptMessage		
#define SETSCAExDecryptAndVerifySignature   CryptExDecryptAndVerifyMessageSignature		
#define SETSCAExEncrypt                     CryptExEncryptMessage			
#define SETSCAExDecrypt                     CryptExDecryptMessage			


// A Hack to get the old encode/decode APIs to work

// Renamed the structure used for X509_CERT. Futhermore, the content of the
// CERT_ENCODING structure has changed.
typedef CERT_SIGNED_CONTENT_INFO CERT_ENCODING;
typedef PCERT_SIGNED_CONTENT_INFO PCERT_ENCODING;

//  Content types
#define CERT_CONTENT            1
#define CRL_CONTENT             2
#define CERT_REQUEST_CONTENT    3


#if 0
BOOL
WINAPI
CertEncodeToBeSigned(
            IN DWORD dwEncodingType,
            IN DWORD dwContentType,
            IN void *pvInfo,
            OUT BYTE *pbEncodedToBeSigned,
            IN OUT DWORD *pcbEncodedToBeSigned
            );
#else
#define CertEncodeToBeSigned(dwEncodingType, dwContentType, pvInfo, \
        pbEncodedToBeSigned, pcbEncodedToBeSigned) \
    CryptEncodeObject(dwEncodingType, \
        (dwContentType == CERT_CONTENT) ? X509_CERT_TO_BE_SIGNED : \
        ((dwContentType == CRL_CONTENT) ? X509_CERT_CRL_TO_BE_SIGNED : \
            X509_CERT_REQUEST_TO_BE_SIGNED), \
        pvInfo, pbEncodedToBeSigned, pcbEncodedToBeSigned)
#endif

#if 0
BOOL
WINAPI
CertEncode(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncodedToBeSigned,
            IN DWORD cbEncodedToBeSigned,
            IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
            IN const BYTE *pbSignature,
            IN DWORD cbSignature,
            IN OPTIONAL void *pAdditionalInfo,
            OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
            );
#else
// You'll need to create and initialize a CERT_SIGNED_CONTENT_INFO data
// structure initialized with the above information
// You'll need to manually modify your code
#define CertEncode(dwEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, \
        pSignatureAlgorithm, pbSignature, cbSignature, pAdditionalInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_CERT, &CertSignedContentInfo, \
        pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
CertDecodeToBeSigned(
            IN DWORD dwEncodingType,
            IN DWORD dwContentType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT void *pvInfo,
            IN OUT DWORD *pcbInfo
            );
#else
#define CertDecodeToBeSigned(dwEncodingType, dwContentType, \
        pbEncoded, cbEncoded, pvInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, \
        (dwContentType == CERT_CONTENT) ? X509_CERT_TO_BE_SIGNED : \
        ((dwContentType == CRL_CONTENT) ? X509_CERT_CRL_TO_BE_SIGNED : \
            X509_CERT_REQUEST_TO_BE_SIGNED), \
        pbEncoded, cbEncoded, 0, pvInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
CertDecode(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT OPTIONAL PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
            IN OUT OPTIONAL DWORD *pcbSignatureAlgorithm,
            IN OUT OPTIONAL BYTE **ppbSignature,
            IN OUT OPTIONAL DWORD *pcbSignature,
            IN OUT BYTE **ppbEncodedToBeSigned,
            IN OUT DWORD *pcbEncodedToBeSigned,
            IN OUT OPTIONAL void *pAdditionalInfo,
            IN OUT OPTIONAL DWORD *pcbAdditionalInfo
            );
#else
// Returns a CERT_SIGNED_CONTENT_INFO data
// structure containing the above information
// You'll need to manually modify your code
#define CertDecode(dwEncodingType, pbEncoded, cbEncoded, \
        pSignatureAlgorithm, pcbSignatureAlgorithm, \
        ppbSignature, pcbSignature, \
        ppbEncodedToBeSigned, pcbEncodedToBeSigned, \
        pAdditionalInfo, pcbAdditionalInfo) \
    CryptDecodeObject(dwEncodingType, X509_CERT, pbEncoded, cbEncoded, 0, \
        pCertSignedContentInfo, &cbCertSignedContentInfo)
#endif

#if 0
BOOL
WINAPI
CertEncodeName(
            IN DWORD dwEncodingType,
            IN PCERT_NAME_INFO pInfo,
            OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
            );
#else
#define CertEncodeName(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_NAME, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
CertDecodeName(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT PCERT_NAME_INFO pInfo,
            IN OUT DWORD *pcbInfo
            );
#else
#define CertDecodeName(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_NAME, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
CertEncodeNameValue(
            IN DWORD dwEncodingType,
            IN PCERT_NAME_VALUE pInfo,
            OUT BYTE *pbEncoded,
            IN OUT DWORD *pcbEncoded
            );
#else
#define CertEncodeNameValue(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_NAME_VALUE, \
        pInfo, pbEncoded, pcbEncoded)
#endif


#if 0
BOOL
WINAPI
CertDecodeNameValue(
            IN DWORD dwEncodingType,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT PCERT_NAME_VALUE pInfo,
            IN OUT DWORD *pcbInfo
            );
#else
#define CertDecodeNameValue(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_NAME_VALUE, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
CertEncodeExtensions(
        IN DWORD dwEncodingType,
        IN PCERT_EXTENSIONS pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define CertEncodeExtensions(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_EXTENSIONS, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
CertDecodeExtensions(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_EXTENSIONS pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define CertDecodeExtensions(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_EXTENSIONS, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
PublicKeyInfoEncode(
        IN DWORD dwEncodingType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define PublicKeyInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_PUBLIC_KEY_INFO, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
PublicKeyInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_PUBLIC_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define PublicKeyInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_PUBLIC_KEY_INFO, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
AuthorityKeyIdEncode(
        IN DWORD dwEncodingType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define AuthorityKeyIdEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_AUTHORITY_KEY_ID, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
AuthorityKeyIdDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define AuthorityKeyIdDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_AUTHORITY_KEY_ID, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
KeyAttributesEncode(
        IN DWORD dwEncodingType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define KeyAttributesEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_KEY_ATTRIBUTES, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
KeyAttributesDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define KeyAttributesDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_KEY_ATTRIBUTES, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
KeyUsageRestrictionEncode(
        IN DWORD dwEncodingType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define KeyUsageRestrictionEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_KEY_USAGE_RESTRICTION, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
KeyUsageRestrictionDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define KeyUsageRestrictionDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_KEY_USAGE_RESTRICTION, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
AltNameEncode(
        IN DWORD dwEncodingType,
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define AltNameEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_ALTERNATE_NAME, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
AltNameDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define AltNameDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_ALTERNATE_NAME, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
BasicConstraintsEncode(
        IN DWORD dwEncodingType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define BasicConstraintsEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_BASIC_CONSTRAINTS, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
BasicConstraintsDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define BasicConstraintsDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_BASIC_CONSTRAINTS, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETAccountAliasEncode(
        IN DWORD dwEncodingType,
        IN BOOL *pbInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETAccountAliasEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_ACCOUNT_ALIAS, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETAccountAliasDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT BOOL *pbInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SETAccountAliasDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_ACCOUNT_ALIAS, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETHashedRootKeyEncode(
        IN DWORD dwEncodingType,
        IN BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETHashedRootKeyEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_HASHED_ROOT_KEY, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETHashedRootKeyDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        IN OUT DWORD *pcbInfo
        );
#else
#define SETHashedRootKeyDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_HASHED_ROOT_KEY, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETCertificateTypeEncode(
        IN DWORD dwEncodingType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETCertificateTypeEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_CERTIFICATE_TYPE, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETCertificateTypeDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SETCertificateTypeDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_CERTIFICATE_TYPE, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SETMerchantDataEncode(
        IN DWORD dwEncodingType,
        IN PSET_MERCHANT_DATA_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
#else
#define SETMerchantDataEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, X509_SET_MERCHANT_DATA, \
        pInfo, pbEncoded, pcbEncoded)
#endif

#if 0
BOOL
WINAPI
SETMerchantDataDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSET_MERCHANT_DATA_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SETMerchantDataDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, X509_SET_MERCHANT_DATA, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


// A Hack to get the old SPC encode/decode APIs to work

#if 0
BOOL
WINAPI
SpcSpAgencyInfoEncode(
        IN DWORD dwEncodingType,
        IN PSPC_SP_AGENCY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
SpcSpAgencyInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_SP_AGENCY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcSpAgencyInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_SP_AGENCY_INFO_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcSpAgencyInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_SP_AGENCY_INFO_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcMinimalCriteriaInfoEncode(
        IN DWORD dwEncodingType,
        IN BOOL *pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
SpcMinimalCriteriaInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT BOOL *pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcMinimalCriteriaInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_MINIMAL_CRITERIA_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcMinimalCriteriaInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_MINIMAL_CRITERIA_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcFinancialCriteriaInfoEncode(
        IN DWORD dwEncodingType,
        IN PSPC_FINANCIAL_CRITERIA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcFinancialCriteriaInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_FINANCIAL_CRITERIA pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcFinancialCriteriaInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_FINANCIAL_CRITERIA_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcFinancialCriteriaInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_FINANCIAL_CRITERIA_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcIndirectDataContentEncode(
        IN DWORD dwEncodingType,
        IN PSPC_INDIRECT_DATA_CONTENT pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcIndirectDataContentDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcIndirectDataContentEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_INDIRECT_DATA_CONTENT_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcIndirectDataContentDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_INDIRECT_DATA_CONTENT_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
SpcPeImageDataEncode(
        IN DWORD dwEncodingType,
        IN PSPC_PE_IMAGE_DATA pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcPeImageDataDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_PE_IMAGE_DATA pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcPeImageDataEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_PE_IMAGE_DATA_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcPeImageDataDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_PE_IMAGE_DATA_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#if 0
BOOL
WINAPI
SpcLinkEncode(
        IN DWORD dwEncodingType,
        IN PSPC_LINK pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcLinkDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_LINK pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcLinkEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_LINK_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcLinkDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_LINK_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
SpcStatementTypeEncode(
        IN DWORD dwEncodingType,
        IN PSPC_STATEMENT_TYPE pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcStatementTypeDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_STATEMENT_TYPE pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcStatementTypeEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_STATEMENT_TYPE_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcStatementTypeDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_STATEMENT_TYPE_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif


#if 0
BOOL
WINAPI
SpcSpOpusInfoEncode(
        IN DWORD dwEncodingType,
        IN PSPC_SP_OPUS_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SpcSpOpusInfoDecode(
        IN DWORD dwEncodingType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT PSPC_SP_OPUS_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );
#else
#define SpcSpOpusInfoEncode(dwEncodingType, pInfo, \
        pbEncoded, pcbEncoded) \
    CryptEncodeObject(dwEncodingType, SPC_SP_OPUS_INFO_STRUCT, \
        pInfo, pbEncoded, pcbEncoded)
#define SpcSpOpusInfoDecode(dwEncodingType,  pbEncoded, cbEncoded, \
        pInfo, pcbInfo) \
    CryptDecodeObject(dwEncodingType, SPC_SP_OPUS_INFO_STRUCT, \
        pbEncoded, cbEncoded, 0, pInfo, pcbInfo)
#endif

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif /* _WIN32_WINNT >= 0x0400 */

#endif // __CNVCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\codesign.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       codesign.h
//
//--------------------------------------------------------------------------

#ifndef _CODESIGN_H
#define _CODESIGN_H

// OBSOLETE :- moved to authcode.h
//--------------------------------
//--------------------------------

//////////////////////////////////////////////////////
// Policy

#define STATE_TRUSTTEST        0x00000020
#define STATE_TESTCANBEVALID   0x00000080 
#define STATE_IGNOREEXPIRATION 0x00000100   // Use expiration date
#define STATE_IGNOREREVOKATION 0x00000200   // Do revocation check
#define STATE_OFFLINEOK_IND    0x00000400   // off-line is ok for individual certs
#define STATE_OFFLINEOK_COM    0x00000800   // off-line is ok for commercial certs
#define STATE_OFFLINEOKNBU_IND 0x00001000   // off-line is ok for individual certs, no bad ui
#define STATE_OFFLINEOKNBU_COM 0x00002000   // off-line is ok for commercial certs, no bad ui
#define STATE_TIMESTAMP_IND    0x00004000   // Use timestamp for individual certs
#define STATE_TIMESTAMP_COM    0x00008000   // Use timestamp for commerical certs
#define STATE_VERIFY_V1_OFF    0x00010000   // turn verify of v1 certs off

#define REGPATH_WINTRUST_USER   "Software\\Microsoft\\Windows\\CurrentVersion\\WinTrust"
#define REGPATH_SPUB            "\\Trust Providers\\Software Publishing"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\crypt32l.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypt32l.h
//
//  Contents:   Crypt32 static library
//              API Prototypes and Definitions
//
//  APIs:       Crypt32DllMain
//
//  NB: This header is for temporary use only, with the static library
//      form of crypt32 (crypt32l).  It should not be used after IE4 ships,
//      since then the correct action will be to use the dll form of crypt32.
//
//--------------------------------------------------------------------------

#ifndef _CRYPT32L_H_
#define _CRYPT32L_H_


//+-------------------------------------------------------------------------
//
//  Function:  Crypt32DllMain
//
//  Synopsis:  Initialize the Crypt32 static library code
//
//  Returns:   FALSE iff failed
//
//  Notes:
//      If crypt32l.lib is linked with an exe, call
//          Crypt32DllMain( NULL, DLL_PROCESS_ATTACH, NULL)
//      at the start of main() and
//          Crypt32DllMain( NULL, DLL_PROCESS_DETACH, NULL)
//      at the end of main().
//
//      If linking with a dll, call Crypt32DllMain from the dll's init
//      routine, passing it the same args as were passed to the init routine.
//
//--------------------------------------------------------------------------
BOOL
WINAPI
Crypt32DllMain(
    HMODULE hInstDLL,
    DWORD   fdwReason,
    LPVOID  lpvReserved
    );


#endif //_CRYPT32L_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\crypthlp.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypthlp.h
//
//  Contents:   Misc internal crypt/certificate helper APIs
//
//  APIs:       I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              I_CryptGetFileVersion
//              I_CertSyncStoreEx
//              I_CertSyncStore
//              I_CertUpdateStore
//              I_RecursiveCreateDirectory
//              I_RecursiveDeleteDirectory
//              I_CryptReadTrustedPublisherDWORDValueFromRegistry
//              I_CryptZeroFileTime
//              I_CryptIsZeroFileTime
//              I_CryptIncrementFileTimeBySeconds
//              I_CryptDecrementFileTimeBySeconds
//              I_CryptSubtractFileTimes
//              I_CryptIncrementFileTimeByMilliseconds
//              I_CryptDecrementFileTimeByMilliseconds
//              I_CryptRemainingMilliseconds
//
//  History:    01-Jun-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTHLP_H__
#define __CRYPTHLP_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Cross Cert Distribution Retrieval Times
//

// 8 hours
#define XCERT_DEFAULT_SYNC_DELTA_TIME   (60 * 60 * 8)
// 1 hour
#define XCERT_MIN_SYNC_DELTA_TIME       (60 * 60)

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  HCRYPTPROVs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    );

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    );

//+-------------------------------------------------------------------------
//  crypt32.dll release version numbers
//--------------------------------------------------------------------------
#define IE4_CRYPT32_DLL_VER_MS          ((    5 << 16) | 101 )
#define IE4_CRYPT32_DLL_VER_LS          (( 1670 << 16) |   1 )

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//
//  Setting ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG in dwInFlags
//  inhibits the syncing of properties.
//
//  ICERT_SYNC_STORE_CHANGED_OUT_FLAG is returned and set in *pdwOutFlags
//  if any contexts were added or deleted from the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStoreEx(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwInFlags,
    OUT OPTIONAL DWORD *pdwOutFlags,
    IN OUT OPTIONAL void *pvReserved
    );

#define ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG      0x00000001
#define ICERT_SYNC_STORE_CHANGED_OUT_FLAG                   0x00010000

//+-------------------------------------------------------------------------
//  Update the original store with contexts from the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertUpdateStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwReserved,
    IN OUT void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Recursively creates a full directory path
//--------------------------------------------------------------------------
BOOL 
I_RecursiveCreateDirectory(
    IN LPCWSTR pwszDir,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

//+-------------------------------------------------------------------------
//  Recursively deletes a whole directory
//--------------------------------------------------------------------------
BOOL 
I_RecursiveDeleteDirectory(
    IN LPCWSTR pwszDelete
    );

//+-------------------------------------------------------------------------
//  Recursively copies a whole directory
//--------------------------------------------------------------------------
BOOL 
I_RecursiveCopyDirectory(
    IN LPCWSTR pwszDirFrom,
    IN LPCWSTR pwszDirTo
    );



//+-------------------------------------------------------------------------
//  First checks if the registry value exists in GPO Policies section. If
//  not, checks the LocalMachine section.
//--------------------------------------------------------------------------
BOOL
I_CryptReadTrustedPublisherDWORDValueFromRegistry(
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValue
    );

//+-------------------------------------------------------------------------
//  Zero's the filetime
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptZeroFileTime(
    OUT LPFILETIME pft
    )
{
    pft->dwLowDateTime = 0;
    pft->dwHighDateTime = 0;
}

//+-------------------------------------------------------------------------
//  Check for a filetime of 0. Normally, this indicates the filetime
//  wasn't specified.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
I_CryptIsZeroFileTime(
    IN LPFILETIME pft
    )
{
    if (0 == pft->dwLowDateTime && 0 == pft->dwHighDateTime)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Increment the filetime by the specified number of seconds.
//
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptIncrementFileTimeBySeconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwSeconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) +
        (((DWORDLONG) dwSeconds) * 10000000i64);
}

//+-------------------------------------------------------------------------
//  Decrement the filetime by the specified number of seconds.
//
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptDecrementFileTimeBySeconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwSeconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) -
        (((DWORDLONG) dwSeconds) * 10000000i64);
}

//+-------------------------------------------------------------------------
//  Subtract two filetimes and return the number of seconds.
//
//  The second filetime is subtracted from the first. If the first filetime
//  is before the second, then, 0 seconds is returned.
//  
//  Filetime is in units of 100 nanoseconds.  Each second has
//  10**7 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
DWORD
WINAPI
I_CryptSubtractFileTimes(
    IN LPFILETIME pftFirst,
    IN LPFILETIME pftSecond
    )
{
    DWORDLONG qwDiff;

    if (0 >= CompareFileTime(pftFirst, pftSecond))
        return 0;


    qwDiff = *(((DWORDLONG UNALIGNED *) pftFirst)) -
        *(((DWORDLONG UNALIGNED *) pftSecond));

    return (DWORD) (qwDiff / 10000000i64);
}


//+-------------------------------------------------------------------------
//  Increment the filetime by the specified number of milliseconds.
//
//  Filetime is in units of 100 nanoseconds.  Each millisecond has
//  10**4 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptIncrementFileTimeByMilliseconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwMilliseconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) +
        (((DWORDLONG) dwMilliseconds) * 10000i64);
}

//+-------------------------------------------------------------------------
//  Decrement the filetime by the specified number of milliseconds.
//
//  Filetime is in units of 100 nanoseconds.  Each millisecond has
//  10**4 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
void
WINAPI
I_CryptDecrementFileTimeByMilliseconds(
    IN LPFILETIME pftSrc,
    IN DWORD dwMilliseconds,
    OUT LPFILETIME pftDst
    )
{
	*(((DWORDLONG UNALIGNED *) pftDst)) =
	    *(((DWORDLONG UNALIGNED *) pftSrc)) -
        (((DWORDLONG) dwMilliseconds) * 10000i64);
}


//+-------------------------------------------------------------------------
//  Return the number of milliseconds remaining before the specified end
//  filetime.
//
//  The current filetime is subtracted from the end filetime. If the current
//  filetime is after or the same as the end filetime, then, 0 milliseconds
//  is returned.
//  
//  Filetime is in units of 100 nanoseconds.  Each millisecond has
//  10**4 100 nanoseconds.
//--------------------------------------------------------------------------
__inline
DWORD
WINAPI
I_CryptRemainingMilliseconds(
    IN LPFILETIME pftEnd
    )
{
    FILETIME ftCurrent;
    DWORDLONG qwDiff;

    GetSystemTimeAsFileTime(&ftCurrent);

    if (0 >= CompareFileTime(pftEnd, &ftCurrent))
        return 0;


    qwDiff = *(((DWORDLONG UNALIGNED *) pftEnd)) -
        *(((DWORDLONG UNALIGNED *) &ftCurrent));

    return (DWORD) (qwDiff / 10000i64);
}


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\cryptnet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptnet.h
//
//  Contents:   Internal CryptNet API prototypes
//
//  History:    22-Oct-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_H__)
#define __CRYPTNET_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// I_CryptNetGetUserDsStoreUrl.  Gets the URL to be used for open an
// LDAP store provider over a portion of the DS associated with the
// current user.  The URL can be freed using CryptMemFree
//

BOOL WINAPI
I_CryptNetGetUserDsStoreUrl (
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          );

//
// Returns TRUE if we are connected to the internet
//
BOOL
WINAPI
I_CryptNetIsConnected ();

typedef BOOL (WINAPI *PFN_I_CRYPTNET_IS_CONNECTED) ();

//
// Cracks the Url and returns the host name component.
//
BOOL
WINAPI
I_CryptNetGetHostNameFromUrl (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        );

typedef BOOL (WINAPI *PFN_I_CRYPTNET_GET_HOST_NAME_FROM_URL) (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        );

//
// Enumerate the cryptnet URL cache entries
//

typedef struct _CRYPTNET_URL_CACHE_ENTRY {
    DWORD           cbSize;
    DWORD           dwMagic;
    FILETIME        LastSyncTime;
    DWORD           cBlob;
    DWORD           *pcbBlob;
    LPCWSTR         pwszUrl;
    LPCWSTR         pwszMetaDataFileName;
    LPCWSTR         pwszContentFileName;
} CRYPTNET_URL_CACHE_ENTRY, *PCRYPTNET_URL_CACHE_ENTRY;


// Returns FALSE to stop the enumeration.
typedef BOOL (WINAPI *PFN_CRYPTNET_ENUM_URL_CACHE_ENTRY_CALLBACK)(
    IN const CRYPTNET_URL_CACHE_ENTRY *pUrlCacheEntry,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg
    );

BOOL
WINAPI
I_CryptNetEnumUrlCacheEntry(
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg,
    IN PFN_CRYPTNET_ENUM_URL_CACHE_ENTRY_CALLBACK pfnEnumCallback
    );


#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\crtem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crtem.h
//
//  Contents:   'C' Run Time Emulation Definitions
//
//  History:	03-Jun-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CRTEM_H__
#define __CRTEM_H__


///////////////////////////////////////////////////////////////////////
//
// Definitions that help reduce our dependence on the C runtimes
//
#define wcslen(sz)      lstrlenW(sz)            // yes it IS implemented by Win95

#define strlen(sz)      lstrlenA(sz)
#define strcpy(s1,s2)   lstrcpyA(s1,s2)
#define strcmp(s1,s2)   lstrcmpA(s1,s2)
#define strcat(s1,s2)   lstrcatA(s1,s2)



///////////////////////////////////////////////////////////////////////
//
// C runtime excluders that we only use in non-debug builds
//

////////////////////////////////////////////
//
// enable intrinsics that we can
//
#if !DBG

    #ifdef __cplusplus
        #ifndef _M_PPC
            #pragma intrinsic(memcpy)
            #pragma intrinsic(memcmp)
            #pragma intrinsic(memset)
        #endif
    #endif

////////////////////////////////////////////
//
// memory management
//
#define malloc(cb)          ((void*)LocalAlloc(LPTR, cb))
#define free(pv)            (LocalFree((HLOCAL)pv))
#define realloc(pv, cb)     ((void*)LocalReAlloc((HLOCAL)pv, cb, LMEM_MOVEABLE))

#endif  // !DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\cryptreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryptreg.h
//
//  Contents:   Microsoft Internet Security Registry Keys
//
//  History:    04-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef CRYPTREG_H
#define CRYPTREG_H

//
//  MAXs
//
#define REG_MAX_FUNC_NAME           64
#define REG_MAX_KEY_NAME            128
#define REG_MAX_GUID_TEXT           39      // 38 + NULL

//
//  HKEY_LOCAL_MACHINE
//

#define REG_MACHINE_SETTINGS_KEY    L"Software\\Microsoft\\Cryptography\\Machine Settings"

#define REG_INIT_PROVIDER_KEY       L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Initialization"
#define REG_OBJTRUST_PROVIDER_KEY   L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Message"
#define REG_SIGTRUST_PROVIDER_KEY   L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Signature"
#define REG_CERTTRUST_PROVIDER_KEY  L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Certificate"
#define REG_CERTPOL_PROVIDER_KEY    L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\CertCheck"
#define REG_FINALPOL_PROVIDER_KEY   L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\FinalPolicy"
#define REG_TESTPOL_PROVIDER_KEY    L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\DiagnosticPolicy"
#define REG_CLEANUP_PROVIDER_KEY    L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Cleanup"
#define REG_TRUST_USAGE_KEY         L"Software\\Microsoft\\Cryptography\\Providers\\Trust\\Usages"

//  3-Dec-1997 pberkman: removed
//#define REG_SIP_PROVIDER_KEY        L"Software\\Microsoft\\Cryptography\\Providers\\Subject"
//#define REG_SIP_HINTS_KEY           L"Software\\Microsoft\\Cryptography\\Providers\\Subject\\Hints"
//#define REG_SIP_HINTS_MAGIC_KEY     L"Software\\Microsoft\\Cryptography\\Providers\\Subject\\Hints\\MagicNumber"

#define REG_REVOKE_PROVIDER_KEY     L"Software\\Microsoft\\Cryptography\\Providers\\Revocation"
#define REG_SP_REVOKE_PROVIDER_KEY  L"Software\\Microsoft\\Cryptography\\Providers\\Revocation\\SoftwarePublishing"


#define REG_DLL_NAME                L"$DLL"
#define REG_FUNC_NAME               L"$Function"

#define REG_FUNC_NAME_SIP_GET       L"$GetFunction"
#define REG_FUNC_NAME_SIP_PUT       L"$PutFunction"
#define REG_FUNC_NAME_SIP_CREATE    L"$CreateFunction"
#define REG_FUNC_NAME_SIP_VERIFY    L"$VerifyFunction"
#define REG_FUNC_NAME_SIP_REMOVE    L"$RemoveFunction"
#define REG_FUNC_NAME_SIP_HINT_IS   L"$IsFunction"
#define REG_FUNC_NAME_SIP_HINT_IS2  L"$IsFunctionByName"

#define REG_DEF_FOR_USAGE           L"DefaultId"
#define REG_DEF_CALLBACK_ALLOC      "CallbackAllocFunction"
#define REG_DEF_CALLBACK_FREE       "CallbackFreeFunction"

//
//  HKEY_CURRENT_USER
//

#define REG_PKITRUST_USERDATA       L"Software\\Microsoft\\Cryptography\\UserData"
#define REG_PKITRUST_TSTAMP_URL     L"TimestampURL"
#define REG_PKITRUST_MY_URL         L"MyInfoURL"
#define REG_PKITRUST_LASTDESC       L"LastContentDesc"

//////////////////////////////////////////////////////////////////////////////
//
// Wintrust Policy Flags registry location
//----------------------------------------------------------------------------
//  The following is where the DWORD can be found in the HKEY_CURRENT_USER 
//  registry.  See wintrust.h for further information.
//
#define REGPATH_WINTRUST_POLICY_FLAGS   L"Software\\Microsoft\\Windows\\CurrentVersion\\" \
                                        L"WinTrust\\Trust Providers\\Software Publishing"
#define REGNAME_WINTRUST_POLICY_FLAGS   L"State"


#endif // CRYPTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#include "ossglobl.h"
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    return (HCRYPTASN1MODULE) I_CryptInstallOssGlobal(
        pvCtlTbl, dwFlags, pvReserved);
}
#else

HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptUninstallOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1encoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1decoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\cryptver.h ===
/*+-------------------------------------------------------------------------
 *
 *  Microsoft Windows
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1999
 *
 *  File:       cryptver.h
 *
 *  Contents:   Microsoft Internet Security versioning
 *
 *  History:    14-Aug-1997 pberkman   created
 *
 *--------------------------------------------------------------------------*/

#include <ntverp.h>

#define VER_FILEDESCRIPTION_STR_TRUST   "Microsoft Trust "

#undef VER_PRODUCTMINOR

#ifdef _ISPUCAB
/* x86fre IE BUILD */
#   define VER_PRODUCTMINOR         101
#else
/* REAL NT BUILD */
#   define VER_PRODUCTMINOR         131
#endif

#undef VER_PRODUCTVERSION_STRING
#define VER_PRODUCTVERSION_STRING   "5"

#undef VER_PRODUCTVERSION
#define VER_PRODUCTVERSION          5,VER_PRODUCTMINOR,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#undef VER_BPAD
#if 	(VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif	(VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif	(VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#if 	(VER_PRODUCTMINOR < 10)
#define VERM_BPAD "00"
#elif	(VER_PRODUCTMINOR < 100)
#define VERM_BPAD "0"
#else
#define VERM_BPAD
#endif


#define VER_PRODUCTVERSION_STR2x(w,x,y) VER_PRODUCTVERSION_STRING "." VERM_BPAD #w "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1x(w,x,y) VER_PRODUCTVERSION_STR2x(w, x, y)

#undef VER_PRODUCTVERSION_STR
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1x(VER_PRODUCTMINOR, VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    extern "C" 
    {
#endif
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


#ifdef _XELIBCA_SRC_

// Copied from CA\include\cs.h:

#define DBG_SS_INFO	 0x00000004	// or in with any of the below
#define DBG_SS_CERTLIB	 0x40000000
#define DBG_SS_CERTLIBI		(DBG_SS_CERTLIB | DBG_SS_INFO)
#define DBG_SS_TRACE		DBG_SS_CERTLIBI
#define DBG_SS_APP		DBG_SS_CERTLIB

#else // _XELIBCA_SRC_

//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000
#define DBG_SS_CATDBSVC                     0x00800000

#define DBG_SS_APP                          0x10000000

#define DBG_SS_TRACE			    DBG_SS_CRYPT32

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                DBG_SS_CATDBSVC,    "CATDBSV",  \
                                NULL, NULL                      \
                            }
#endif // _XELIBCA_SRC_

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

    extern int WINAPIV DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);

#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_TRACE, argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_TRACE, name)
#define SET_ERROR(name, err)            SET_ERROR_EX(DBG_SS_TRACE, name, err)
#define SET_ERROR_VAR(name, err)        SET_ERROR_VAR_EX(DBG_SS_TRACE, name, err)
#define SET_HRESULT(name, err)          SET_HRESULT_EX(DBG_SS_TRACE, name, err)
#define SET_HRESULT_VAR(name, err)      SET_HRESULT_VAR_EX(DBG_SS_TRACE, name, err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_TRACE, name)


#ifndef _XELIBCA_SRC_
#ifdef __cplusplus
    }       // balance of extern "C"
#endif
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\dpapiprv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dpapiprv.h
//
//--------------------------------------------------------------------------

//
// private header for secure storage
//

#ifndef __DPAPIPRV_H__
#define __DPAPIPRV_H__

#define SECURITY_WIN32
#include <security.h>
#include <spseal.h>
#include <sspi.h>
#include <secpkg.h>

// use TEXT() so that cred_nt.c can use Unicode RPC

#define DPAPI_LOCAL_ENDPOINT        L"protected_storage"
#define DPAPI_LOCAL_PROT_SEQ        L"ncalrpc"

#define DPAPI_BACKUP_ENDPOINT        L"\\PIPE\\protected_storage"
#define DPAPI_BACKUP_PROT_SEQ        L"ncacn_np"

#define DPAPI_LEGACY_BACKUP_ENDPOINT  L"\\PIPE\\ntsvcs"
#define DPAPI_LEGACY_BACKUP_PROT_SEQ  L"ncacn_np"



//
// CryptProtect #defines

#define REG_CRYPTPROTECT_LOC        L"SOFTWARE\\Microsoft\\Cryptography\\Protect"

#define REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC            L"Providers"
#define REG_CRYPTPROTECT_PREFERREDPROVIDER_VALUELOC     L"Preferred"
#define REG_CRYPTPROTECT_PROVIDERPATH_VALUELOC          L"Image Path"
#define REG_CRYPTPROTECT_PROVIDERNAME_VALUELOC          L"Name"
#define REG_CRYPTPROTECT_ALLOW_CACHEPW                  L"AllowCachePW"

/* df9d8cd0-1501-11d1-8c7a-00c04fc297eb */
#define CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ L"df9d8cd0-1501-11d1-8c7a-00c04fc297eb"
#define CRYPTPROTECT_DEFAULT_PROVIDER   { 0xdf9d8cd0, 0x1501, 0x11d1, {0x8c, 0x7a, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb} }

#define CRYPTPROTECT_DEFAULT_PROVIDER_FRIENDLYNAME  L"System Protection Provider"
#define CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG              L"Encr Alg"
#define CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG               L"MAC Alg"
#define CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE      L"Encr Alg Key Size"
#define CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE       L"MAC Alg Key Size"
#define CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE       L"Default CSP Type"





//
// This flag is used for the French version, indicating no encryption.
#define CRYPTPROTECT_NO_ENCRYPTION  0x10000000

#define CRYPTPROTECT_IN_PROCESS     0x20000000


#ifdef __cplusplus
extern "C" {
#endif

//
// Exports for lsasrv.dll 
//
DWORD
NTAPI
DPAPIInitialize(
    LSA_SECPKG_FUNCTION_TABLE *pSecpkgTable);

DWORD
NTAPI 
DPAPIShutdown( );


#ifdef __cplusplus
}
#endif

#endif // __DPAPIPRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\dsysdbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dsysdbg.h
//
//  Contents:   Merged all the debug code together
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-95   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DSYSDBG_H__
#define __DSYSDBG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdarg.h>

typedef struct _DEBUG_KEY {
    DWORD   Mask;
    PCHAR   Tag;
} DEBUG_KEY, * PDEBUG_KEY;

#define DSYSDBG_OPEN_ONLY       0x00000001
#define DSYSDBG_DEMAND_OPEN     0x00000002
#define DSYSDBG_BREAK_ON_ERROR  0x00000004

#define DSYSDBG_ASSERT_CONTINUE 0
#define DSYSDBG_ASSERT_BREAK    1
#define DSYSDBG_ASSERT_SUSPEND  2
#define DSYSDBG_ASSERT_KILL     3
#define DSYSDBG_ASSERT_PROMPT   4
#define DSYSDBG_ASSERT_DEBUGGER 5

//
// Global Flags exposed to callers:
//

#define DEBUG_HEAP_CHECK    0x00000040      // Check Heap on every debug out
#define DEBUG_MULTI_THREAD  0x00000080      // Use critical section in header
#define DEBUG_BREAK_ON_ERROR 0x00000400     // Break on an error out

VOID    _DsysAssertEx(PVOID FailedAssertion, PVOID FileName, ULONG LineNumber,
                        PCHAR Message, ULONG ContinueCode);
VOID    _DebugOut(PVOID pControl, ULONG Mask, CHAR * Format, va_list ArgList);
VOID    _InitDebug(DWORD Flags, DWORD * InfoLevel, PVOID * Control, char * ModuleName, PDEBUG_KEY pKey);
VOID    _UnloadDebug( PVOID pControl );
VOID    _DbgSetOption(PVOID pControl, DWORD Flag, BOOL On, BOOL Global);
VOID    _DbgSetLoggingOption(PVOID pControl, BOOL On);
VOID    DbgpDumpException(PVOID p);
VOID    _DbgSetLoggingFile(PVOID pControl, HANDLE  hLogFile);

//  Hack to allow retail builds to include debug support
//  define RETAIL_LOG_SUPPORT in your sources to do it!
#ifdef RETAIL_LOG_SUPPORT
#define DEBUG_SUPPORT
#else
#if DBG
#define DEBUG_SUPPORT
#endif
#endif


#ifdef DEBUG_SUPPORT
//
// Use this in your header file.  It declares the variables that we need
//

#define DECLARE_DEBUG2(comp)                                \
extern PVOID    comp##ControlBlock;                         \
extern DWORD    comp##InfoLevel;                            \
void   comp##DebugPrint(ULONG Mask, CHAR * Format, ... );   \

//
// Use this when you control when you are initialized, for example a DLL or
// EXE.  This defines the wrapper functions that will call into dsysdbg.lib
//

#define DEFINE_DEBUG2(comp)                                 \
PVOID   comp##ControlBlock = NULL ;                         \
DWORD   comp##InfoLevel;                                    \
PVOID   comp##__DebugKeys;                                  \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(0, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##SetOption(DWORD Option, BOOL On, BOOL Global)         \
{                                                           \
    _DbgSetOption( comp##ControlBlock, Option, On, Global); \
}                                                           \
void                                                        \
comp##SetLoggingOption(BOOL On)                             \
{                                                           \
   _DbgSetLoggingOption(comp##ControlBlock, On);            \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
    comp##ControlBlock = NULL ;                             \
}                                                           \
void                                                        \
comp##SetLoggingFile(HANDLE hLogFile)                       \
{                                                           \
   _DbgSetLoggingFile(comp##ControlBlock, hLogFile);        \
}                                                           \

//
// Use this when you don't control when you are initialized, e.g. a static
// library like the gluon code.
//
#define DEFINE_DEBUG_DEFER(comp,keys)                       \
PVOID       comp##ControlBlock = INVALID_HANDLE_VALUE;      \
DWORD       comp##InfoLevel;                    \
PDEBUG_KEY  comp##__DebugKeys = keys;                       \
void comp##DebugPrint(                                      \
    ULONG Mask,                                             \
    CHAR * Format,                                          \
    ... )                                                   \
{                                                           \
    va_list ArgList;                                        \
    va_start(ArgList, Format);                              \
    if (comp##ControlBlock == INVALID_HANDLE_VALUE)         \
    {                                                       \
        _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, comp##__DebugKeys); \
    }                                                       \
    _DebugOut( comp##ControlBlock, Mask, Format, ArgList);  \
}                                                           \
void                                                        \
comp##InitDebugEx(DWORD Flags, PDEBUG_KEY pKey)             \
{                                                           \
    comp##__DebugKeys = pKey;                               \
    _InitDebug(Flags, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##InitDebug(PDEBUG_KEY  pKey)                           \
{                                                           \
    _InitDebug(DSYSDBG_DEMAND_OPEN, & comp##InfoLevel, & comp##ControlBlock, #comp, pKey); \
}                                                           \
void                                                        \
comp##UnloadDebug(void)                                     \
{                                                           \
    _UnloadDebug( comp##ControlBlock );                     \
}


#else   // NOT DEBUG_SUPPORT

//
// Empty defines for the retail case:
//
#define DECLARE_DEBUG2(comp)

#define DEFINE_DEBUG2(comp)

#define DEFINE_DEBUG_DEFER(x, y)


#endif // DEBUG_SUPPORT 



#if DBG
//
// Moved assertions to new section, so no asserts occur in retail builds
// with DEBUG_SUPPORT. 
//
// Assertions:  Most should use DsysAssert or DsysAssertMsg.  These forward on
// the call to dsysdbg.lib, with the continue code set to drop into the
// debugger.  The more sophisticated can call DsysAssertEx, which allows you
// to specify one of the assert codes from above:
//

#define DsysAssertEx(exp, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, NULL, ContinueCode);

#define DsysAssertMsgEx(exp, Message, ContinueCode) \
            if (!(exp)) \
                _DsysAssertEx( #exp, __FILE__, __LINE__, Message, ContinueCode);

#define DsysAssertMsg(exp, Message) DsysAssertMsgEx(exp, Message, DSYSDBG_ASSERT_DEBUGGER)


#define DsysAssert(exp) DsysAssertMsgEx(exp, NULL, DSYSDBG_ASSERT_DEBUGGER)

#define DsysException(p)    DbgpDumpException(p)

#define SZ_DEFAULT_PROFILE_STRING   "Error"         

#else // retail builds cannot contain asserts...


#define DsysAssertEx(x,y)
#define DsysAssertMsgEx(x, y, z)
#define DsysAssert(x)
#define DsysAssertMsg(x, y)

#define DsysException(p)

#define SZ_DEFAULT_PROFILE_STRING   ""

#endif // dbg


#ifndef DEB_ERROR
#define DEB_ERROR   0x00000001
#endif

#ifndef DEB_WARN
#define DEB_WARN    0x00000002
#endif

#ifndef DEB_TRACE
#define DEB_TRACE   0x00000004
#endif

#define DSYSDBG_FORCE   0x80000000
#define DSYSDBG_CLEAN   0x40000000


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSYSDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\errlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       errlog.h
//
//  Contents:   generic error logging
//
//  History:    19-Jun-00   reidk   created
//
//--------------------------------------------------------------------------

#ifndef ERRLOG_H
#define ERRLOG_H

#define ERRLOG_CLIENT_ID_CATDBSCV   1
#define ERRLOG_CLIENT_ID_CATADMIN   2
#define ERRLOG_CLIENT_ID_CATDBCLI   3
#define ERRLOG_CLIENT_ID_WAITSVC    4
#define ERRLOG_CLIENT_ID_TIMESTAMP  5


#define ERRLOG_LOGERROR_LASTERROR(x,y) ErrLog_LogError(x, y, __LINE__, 0, FALSE);   
#define ERRLOG_LOGERROR_PARAM(x,y,z)   ErrLog_LogError(x, y, __LINE__, z, FALSE);
#define ERRLOG_LOGERROR_WARNING(x,y,z) ErrLog_LogError(x, y, __LINE__, z, TRUE);

void
ErrLog_LogError(
    LPWSTR  pwszLogFileName,    // NULL - means log to the catalog DB logfile
    DWORD   dwClient,
    DWORD   dwLine,
    DWORD   dwErr,              // 0 - means use GetLastError()
    BOOL    fWarning,
    BOOL    fLogToFileOnly);

void
ErrLog_LogString(
    LPWSTR  pwszLogFileName,    // NULL - means log to the catalog DB logfile
    LPWSTR  pwszMessageString,
    LPWSTR  pwszExtraString,
    BOOL    fLogToFileOnly);

BOOL
TimeStampFile_Touch(
    LPWSTR  pwszDir);

BOOL
TimeStampFile_InSync(
    LPWSTR  pwszDir1,
    LPWSTR  pwszDir2,
    BOOL    *pfInSync);


#endif // ERRLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\ihgttran.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ihgttran.h
//
//--------------------------------------------------------------------------

typedef ULONG_PTR  HUTTRAN;

typedef DWORD (__stdcall * PFNOpen) (HUTTRAN * phTran, const TCHAR * tszBinding, DWORD fOpen);
typedef DWORD (__stdcall * PFNSend) (HUTTRAN hTran, DWORD dwEncoding, DWORD cbSendBuff, const BYTE * pbSendBuff);
typedef DWORD (__stdcall * PFNFree) (HUTTRAN hTran, BYTE * pb);
typedef DWORD (__stdcall * PFNReceive) (HUTTRAN hTran, DWORD * pdwEncoding, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff);
typedef DWORD (__stdcall * PFNClose) (HUTTRAN hTran);

typedef struct _IGTS {
	HINSTANCE	hLib;
	HUTTRAN		hTran;
	PFNOpen		PfnOpen;
	PFNSend		PfnSend;
	PFNFree		PfnFree;
	PFNReceive	PfnReceive;
	PFNClose	PfnClose;
} IGTS;


#ifdef __cplusplus

extern "C" DWORD __stdcall GTInitSrv(TCHAR * tszLibrary);
extern "C" DWORD __stdcall GTUnInitSrv(void);

#else


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\frmtcom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       frmtcom.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////
//
//	   The common format file for both WIN32API and 
//	   activeX FormatCert control
//
//
//	   Created: Xiaohs
//				March-12-97
//
//
//////////////////////////////////////////////////////////////////
#ifndef __COMMON_FORMAT_H__
#define __COMMON_FORMAT_H__

#ifdef __cplusplus
extern "C" {
#endif


//constants for dwFormatStrType
//The default behavior of CryptFormatObject is to return single line
//display.  If there is no formatting routine installed for registered
//for the OID, the hex dump will be returned.  User can set the flag
//CRYPT_FORMAT_STR_NO_HEX to disable the hex dump.  If user prefers
//a multiple link display, set the flag  CRYPT_FORMAT_STR_MULTI_LINE

#define         CRYPT_FORMAT_STR_MULTI_LINE         0x0001

#define         CRYPT_FORMAT_STR_NO_HEX             0x0010

//--------------------------------------------------------------------
// Following are possible values for dwFormatType for formatting X509_NAME
// or X509_UNICODE_NAME
//--------------------------------------------------------------------
//Just get the simple string
#define	CRYPT_FORMAT_SIMPLE			0x0001

//Put an attribute name infront of the attribute
//such as "O=Microsoft,DN=xiaohs"
#define	CRYPT_FORMAT_X509			0x0002

//Put an OID infront of the simple string, such as 
//"2.5.4.22=Microsoft,2.5.4.3=xiaohs"
#define CRYPT_FORMAT_OID			0x0004


//Put a ";" between each RDN.  The default is "," 
#define	CRYPT_FORMAT_RDN_SEMICOLON	0x0100

//Put a "\n" between each RDN.   
#define	CRYPT_FORMAT_RDN_CRLF		0x0200


//Unquote the DN value, which is quoated by default va the following 
//rules: if the DN contains leading or trailing 
//white space or one of the following characters: ",", "+", "=", 
//""", "\n",  "<", ">", "#" or ";". The quoting character is ". 
//If the DN Value contains a " it is double quoted ("").
#define	CRYPT_FORMAT_RDN_UNQUOTE	0x0400

//reverse the order of the RDNs before converting to the string
#define CRYPT_FORMAT_RDN_REVERSE	0x0800


///-------------------------------------------------------------------------
// Following are possible values for dwFormatType for formatting a DN.:
//
//  The following three values are defined in the section above:
//  CRYPT_FORMAT_SIMPLE:    Just a simple string
//                          such as  "Microsoft+xiaohs+NT"
//  CRYPT_FORMAT_X509       Put an attribute name infront of the attribute
//                          such as "O=Microsoft+xiaohs+NT"
//                         
//  CRYPT_FORMAT_OID        Put an OID infront of the simple string, 
//                          such as "2.5.4.22=Microsoft+xiaohs+NT"
//
//  Additional values are defined as following:
//----------------------------------------------------------------------------
//Put a "," between each value.  Default is "+" 
#define CRYPT_FORMAT_COMMA			0x1000

//Put a ";" between each value 
#define CRYPT_FORMAT_SEMICOLON		CRYPT_FORMAT_RDN_SEMICOLON

//Put a "\n" between each value 
#define CRYPT_FORMAT_CRLF			CRYPT_FORMAT_RDN_CRLF


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif	//__COMMON_FORMAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\format.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:      format.h
//
//  Contents:   The header for format.cpp
//
//  History:    21-February-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef __FORMAT_H__
#define __FORMAT_H__


#ifdef __cplusplus
extern "C" {
#endif


//---------------------------------------------------------
//the following defines should go to the headers in 
// crypt0 2.0
//-----------------------------------------------------------

//the dll routine for formatting the attributes
//in the certificate
BOOL	WINAPI	CryptDllFormatAttr(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcBuffer);

//The routine to format the complet DN.
BOOL	WINAPI	CryptDllFormatName(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer);

BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL                                   
WINAPI                                 
FormatKeyAttributes(                   
	DWORD		dwCertEncodingType,    
	DWORD		dwFormatType,          
	DWORD		dwFormatStrType,       
	void		*pFormatStruct,        
	LPCSTR		lpszStructType,        
	const BYTE *pbEncoded,             
	DWORD		cbEncoded,             
	void	   *pbFormat,              
	DWORD	   *pcbFormat);


BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);
             
BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);





#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __FORMAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\enroll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       enroll.h
//
//--------------------------------------------------------------------------

typedef void * HSES;

BOOL WINAPI Enroll(
    WCHAR *     wszContainer,
    WCHAR *     wszProvider,
    HSES *      phSes,
    BYTE **     ppbCertReq,
    DWORD *     pcbCertReq);

BOOL WINAPI Accept(
    HSES    SessionId,
    BYTE *  pbBuff,
    DWORD   cbBuff);

BOOL WINAPI TermSession(
    HSES  SessionId);


BOOL WINAPI SetHInstance(
    HINSTANCE   hinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\keyback.h ===
/*++

Copyright (C) 1996, 1997  Microsoft Corporation

Module Name:

    keyback.h

Abstract:

    This module defines the Key Backup interface and associated data structures.

Author:

    Scott Field (sfield)    16-Aug-97

--*/

#ifndef __KEYBACK_H__
#define __KEYBACK_H__

//
// Back up a key
//
#define BACKUPKEY_BACKUP_GUID           { 0x7f752b10, 0x178e, 0x11d1, { 0xab, 0x8f, 0x00, 0x80, 0x5f, 0x14, 0xdb, 0x40 } }

//
// Restore a key, wraping it in the pbBK format,
// for downlevel compatability
//
#define BACKUPKEY_RESTORE_GUID_W2K      { 0x7fe94d50, 0x178e, 0x11d1, { 0xab, 0x8f, 0x00, 0x80, 0x5f, 0x14, 0xdb, 0x40 } }

#define BACKUPKEY_RESTORE_GUID          { 0x47270c64, 0x2fc7, 0x499b,  {0xac, 0x5b, 0x0e, 0x37, 0xcd, 0xce, 0x89, 0x9a} }
// Retrieve the public backup certificate
#define BACKUPKEY_RETRIEVE_BACKUP_KEY_GUID  { 0x018ff48a, 0xeaba, 0x40c6, { 0x8f, 0x6d, 0x72, 0x37, 0x02, 0x40, 0xe9, 0x67 } }


#define BACKUPKEY_RECOVERY_BLOB_VERSION_W2K 1   // 

 
#define BACKUPKEY_RECOVERY_BLOB_VERSION 2      // version of recovery blob containing
                                               // MK and LK directly.


//
// Header for the backupkey blob version
// Folowed by the master key and payload key encrypted
// by the key indicated by guidKey.  The encrypted data is
// represented in a PKCS#1v2 formmated (CRYPT_OAEP) blob
// That data is followed by the encrypted payload
//

typedef struct {
    DWORD dwVersion;              // version of structure (BACKUPKEY_RECOVERY_BLOB_VERSION)
    DWORD cbEncryptedMasterKey;   // quantity of encrypted master key data following structure
    DWORD cbEncryptedPayload;     // quantity of encrypted payload
    GUID guidKey;                 // guid identifying backup key used
} BACKUPKEY_RECOVERY_BLOB, 
 *PBACKUPKEY_RECOVERY_BLOB, 
 *LPBACKUPKEY_RECOVERY_BLOB;

typedef struct {
    DWORD   cbMasterKey;
    DWORD   cbPayloadKey;
} BACKUPKEY_KEY_BLOB,
  *PBACKUPKEY_KEY_BLOB,
  *LPBACKUPKEY_KEY_BLOB;


//
// Header for the inner blob of the master key recovery blob
// Following the header is LocalKey, then the SID, and finally
// a SHA_1 MAC of the contained data 

typedef struct {
    DWORD dwPayloadVersion;
    DWORD cbLocalKey;
} BACKUPKEY_INNER_BLOB, 
 *PBACKUPKEY_INNER_BLOB, 
 *LPBACKUPKEY_INNER_BLOB;

#define BACKUPKEY_PAYLOAD_VERSION   1


#define MASTERKEY_BLOB_RAW_VERSION  0

#define MASTERKEY_BLOB_VERSION_W2K  1

#define MASTERKEY_BLOB_VERSION      2

#define MASTERKEY_BLOB_LOCALKEY_BACKUP  3

#define MASTERKEY_R2_LEN_W2K            (16)
#define MASTERKEY_R3_LEN_W2K            (16)

typedef struct {
    DWORD dwVersion;            // version of structure (MASTERKEY_BLOB_VERSION_W2K)
    BYTE R2[MASTERKEY_R2_LEN_W2K];  // random data used during HMAC to derive symetric key
} MASTERKEY_BLOB_W2K, *PMASTERKEY_BLOB_W2K, *LPMASTERKEY_BLOB_W2K;


typedef struct {
    BYTE R3[MASTERKEY_R3_LEN_W2K];  // random data used to derive MAC key
    BYTE MAC[A_SHA_DIGEST_LEN]; // HMAC(R3, pbMasterKey)
} MASTERKEY_INNER_BLOB_W2K, *PMASTERKEY_INNER_BLOB_W2K, *LPMASTERKEY_INNER_BLOB_W2K;



DWORD
WINAPI
BackupKey(
    IN      LPCWSTR szComputerName,
    IN      const GUID *pguidActionAgent,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut,
    IN      DWORD dwParam
    );


#endif  // __KEYBACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\gttran.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       gttran.h
//
//  Contents:   Generic Transport APIs
//
//  APIs:
//              GTOpen
//              GTSend
//              GTFree
//              GTReceive
//              GTClose
//              GTRecSend
//              GTInitSrv
//              GTUnInitSrv
//
//  Created KeithV
//--------------------------------------------------------------------------

#ifndef _HGTTRAN_H_
#define _HGTTRAN_H_

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Encoding types
//
//  Because the Composit type for ASN is 0x30, we will define this to
//  be the encoding type for it.
//--------------------------------------------------------------------------

#define ASCII_ENCODING  0x0
#define TLV_ENCODING    0x1
#define IDL_ENCODING    0x2
#define OCTET_ENCODING  0x3
#define ASN_ENCODING    0x30

//+-------------------------------------------------------------------------
//  Functions will allow you to read, write or both
//  To do both, OR (|) them together.
//--------------------------------------------------------------------------

#define GTREAD    0x00000001
#define GTWRITE   0x00000002

typedef ULONG_PTR  HGT;

//+-------------------------------------------------------------------------
//  Any receiving (listening) DLL must export these functions
//--------------------------------------------------------------------------
typedef DWORD (__stdcall * PFNGTRecSend) (DWORD dwEncoding, DWORD cb, const BYTE * pbIn, DWORD * pcbOut, BYTE ** ppbOut);
typedef DWORD (__stdcall * PFNGTFree) (BYTE * pb);

//+-------------------------------------------------------------------------
//  Functions used by and application that wants to send a message
//  Just like File IO
//--------------------------------------------------------------------------
DWORD __stdcall GTOpen(HGT * phTran, const TCHAR * szLibrary, const TCHAR * tszBinding, DWORD fOpen);
DWORD __stdcall GTSend(HGT hTran, DWORD dwEncoding, DWORD cbSendBuff, const BYTE * pbSendBuff);
DWORD __stdcall GTFree(HGT hTran, BYTE * pb);
DWORD __stdcall GTReceive(HGT hTran, DWORD * pdwEncoding, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff);
DWORD __stdcall GTClose(HGT hTran);

//+-------------------------------------------------------------------------
//  Listening functions for a listening application.
//  The GTFree prototype is also used as specified above
//--------------------------------------------------------------------------
DWORD __stdcall GTRecSend(DWORD dwEncoding, DWORD cb, const BYTE * pbIn, DWORD * pcbOut, BYTE ** ppbOut);

//+-------------------------------------------------------------------------
//  Additonal private listening functions for a listening application.
//  Not generally implemented.
//--------------------------------------------------------------------------
DWORD __stdcall GTRecSendNoEncrypt(DWORD dwEncoding, DWORD cb, const BYTE * pbIn, DWORD * pcbOut, BYTE ** ppbOut);


//+-------------------------------------------------------------------------
//  Used to init a receiving DLL, particularly useful for HTTP BGI, CGI application
//--------------------------------------------------------------------------
DWORD __stdcall GTInitSrv(TCHAR * tszLibrary);
DWORD __stdcall GTUnInitSrv(void);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\keysvcc.h ===
//depot/Lab03_N/DS/security/inc/keysvcc.h#8 - edit change 8790 (text)
//depot/Lab03_N/DS/security/inc/keysvcc.h#5 - edit change 6380 (text)
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       keysvcc.h
//
//--------------------------------------------------------------------------


#ifndef __keysvcc_h__
#define __keysvcc_h__

#ifdef __cplusplus
extern "C"{
#endif 


#define KEYSVC_DEFAULT_ENDPOINT            TEXT("\\pipe\\keysvc")
#define KEYSVC_DEFAULT_PROT_SEQ            TEXT("ncacn_np")

#define KEYSVC_LOCAL_ENDPOINT              TEXT("keysvc")
#define KEYSVC_LOCAL_PROT_SEQ              TEXT("ncalrpc")

#define KEYSVC_LEGACY_ENDPOINT             TEXT("\\pipe\\ntsvcs")
#define KEYSVC_LEGACY_PROT_SEQ             TEXT("ncacn_np")


typedef void *KEYSVCC_HANDLE;

/****************************************
 * Client API for Key Service
 ****************************************/

ULONG KeyOpenKeyService( 
    /* [in] */ LPSTR pszMachineName,
    /* [in] */ KEYSVC_TYPE ulOwnerType,
    /* [in] */ LPWSTR pwszOwnerName,
    /* [in] */ void *pAuthentication,
    /* [out][in] */ void *pReserved,
    /* [out] */ KEYSVCC_HANDLE *phKeySvcCli);

ULONG KeyCloseKeyService( 
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved);



ULONG KeyEnroll_V2(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli, 
    /* [in] */ LPSTR pszMachineName,                    //IN Required: name of the remote machine
    /* [in] */ BOOL fKeyService,                        //IN Required: Whether the function is called remotely
    /* [in] */ DWORD dwPurpose,                         //IN Required: Indicates type of request - enroll/renew
    /* [in] */ DWORD dwFlags,                           //IN Required: Flags for enrollment
    /* [in] */ LPWSTR pwszAcctName,                     //IN Optional: Account name the service runs under
    /* [in] */ void *pAuthentication,                   //RESERVED must be NULL
    /* [in] */ BOOL fEnroll,                            //IN Required: Whether it is enrollment or renew
    /* [in] */ LPWSTR pwszCALocation,                   //IN Required: The ca machine names to attempt to enroll with
    /* [in] */ LPWSTR pwszCAName,                       //IN Required: The ca names to attempt to enroll with
    /* [in] */ BOOL fNewKey,                            //IN Required: Set the TRUE if new private key is needed
    /* [in] */ PCERT_REQUEST_PVK_NEW pKeyNew,           //IN Required: The private key information
    /* [in] */ CERT_BLOB *pCert,                        //IN Optional: The old certificate if renewing
    /* [in] */ PCERT_REQUEST_PVK_NEW pRenewKey,         //IN Optional: The new private key information
    /* [in] */ LPWSTR pwszHashAlg,                      //IN Optional: The hash algorithm
    /* [in] */ LPWSTR pwszDesStore,                     //IN Optional: The destination store
    /* [in] */ DWORD dwStoreFlags,                      //IN Optional: Flags for cert store.
    /* [in] */ PCERT_ENROLL_INFO pRequestInfo,          //IN Required: The information about the cert request
    /* [in] */ LPWSTR pwszAttributes,                   //IN Optional: Attribute string for request
    /* [in] */ DWORD dwReservedFlags,                   //RESERVED must be 0
    /* [in] */ BYTE *pReserved,                         //RESERVED must be NULL
    /* [in][out] */ HANDLE *phRequest,                      //IN OUT Optional: A handle to a created request
    /* [out] */ CERT_BLOB *pPKCS7Blob,                  //OUT Optional: The PKCS7 from the CA
    /* [out] */ CERT_BLOB *pHashBlob,                   //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
    /* [out] */ DWORD *pdwStatus);                      //OUT Optional: The status of the enrollment/renewal


ULONG KeyEnumerateAvailableCertTypes(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [out][in] */ ULONG *pcCertTypeCount,
    /* [in, out][size_is(,*pcCertTypeCount)] */
               PKEYSVC_UNICODE_STRING *ppCertTypes);

ULONG KeyEnumerateCAs(
    /* [in] */ KEYSVCC_HANDLE hKeySvcCli,
    /* [out][in] */ void *pReserved,
    /* [in] */      ULONG  ulFlags,
    /* [out][in] */ ULONG *pcCACount,
    /* [in, out][size_is(,*pcCACount)] */
               PKEYSVC_UNICODE_STRING *ppCAs);


ULONG KeyQueryRequestStatus
(/* [in] */        KEYSVCC_HANDLE                        hKeySvcCli, 
 /* [in] */        HANDLE                                hRequest, 
 /* [out, ref] */  CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO  *pQueryInfo); 

ULONG RKeyOpenKeyService
( /* [in] */       LPSTR            pszMachineName,
  /* [in] */       KEYSVC_TYPE      OwnerType,
  /* [in] */       LPWSTR           pwszOwnerName,
  /* [in] */       void            *pAuthentication,
  /* [out][in] */  void            *pReserved,
  /* [out] */      KEYSVCC_HANDLE  *phKeySvcCli);

ULONG RKeyCloseKeyService
(/* [in] */ KEYSVCC_HANDLE hKeySvcCli,
 /* [out][in] */ void *pReserved);

ULONG RKeyPFXInstall
(/* [in] */ KEYSVCC_HANDLE          hKeySvcCli,
 /* [in] */ PKEYSVC_BLOB            pPFX,
 /* [in] */ PKEYSVC_UNICODE_STRING  pPassword,
 /* [in] */ ULONG                   ulFlags);



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\lenroll.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows                                                  
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       lenroll.h
//
//  Contents:   The header for LocalEnroll API.  It is used 
//              by keyservice for remote certificate enrollment.
//
//----------------------------------------------------------------------------

#ifndef __LENROLL_H__
#define __LENROLL_H__

#ifdef __cplusplus
extern "C" {
#endif
//-----------------------------------------------------------------------
//  
// LocalEnroll
//
//
//  The routine that calls xEnroll and CA to request a certificate
//  This routine also provide confirmation dialogue
//------------------------------------------------------------------------
//-----------------------------------------------------------------------
//  CERT_ENROLL_INFO
//
//------------------------------------------------------------------------
typedef struct _CERT_ENROLL_INFO
{
    DWORD           dwSize;             //Required: Set to the sizeof(CERT_REQUEST_INFO_W)
    LPCWSTR         pwszUsageOID;       //Required: A list of comma seperated key usage oid of the certificate
    LPCWSTR         pwszCertDNName;     //Required: The certificate CN name
    DWORD           dwPostOption;       //Required: A bit wise OR of the following value:
                                        //          REQUEST_POST_ON_DS
                                        //          REQUEST_POST_ON_CSP
    LPCWSTR         pwszFriendlyName;   //Optional: The friendly name of the certificate
    LPCWSTR         pwszDescription;    //Optional: The description of the certificate
    DWORD           dwExtensions;       //Optional: The count of PCERT_EXTENSIONS array for the certificate request
    PCERT_EXTENSIONS    *prgExtensions; //Optional: the PCERT_EXTENSIONS array
}CERT_ENROLL_INFO, *PCERT_ENROLL_INFO;


///-----------------------------------------------------------------------
//  CERT_REQUEST_PVK_NEW
//
//------------------------------------------------------------------------
typedef struct _CERT_REQUEST_PVK_NEW
{
    DWORD           dwSize;             //Required: Set to the sizeof(CERT_REQUEST_PVK_EXISTING)
    DWORD           dwProvType;         //Optional: The provider type. If this field
                                        //          is 0, pwszProvider is ignored
    LPCWSTR         pwszProvider;       //Optional: The name of the provider.  
                                        //          NULL means the default
    DWORD           dwProviderFlags;    //Optional: The flag passed to CryptAcquireContext
    LPCWSTR         pwszKeyContainer;   //Optional: The private key container.  If this value is NULL,
                                        //          a new key container will be generated.  Its name is guaranteed
                                        //          to be unique.
    DWORD           dwKeySpec;          //Optional: The key specification of the private key
    DWORD           dwGenKeyFlags;      //Optional: The flags for CryptGenKey
    DWORD           dwEnrollmentFlags;  //Optional: The enrollment cert type flags for this cert request. 
    DWORD           dwSubjectNameFlags; //Optional: The subject name cert type flags for this cert request. 
    DWORD           dwPrivateKeyFlags;  //Optional: The private key cert type flags for this cert request. 
    DWORD           dwGeneralFlags;     //Optional: The general cert type flags for this cert request. 

}CERT_REQUEST_PVK_NEW, *PCERT_REQUEST_PVK_NEW;


HRESULT  WINAPI LocalEnroll(   DWORD                 dwFlags,         //IN Required
                      LPCWSTR               pRequestString,  //IN Optional
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
                      PCERT_CONTEXT        *ppCertContext   //OUT Optional: The enrolled certificate
                    ); 

HRESULT WINAPI LocalEnrollNoDS(  DWORD                 dwFlags,         //IN Required
		      LPCWSTR               pRequestString,  // Reserved:  must be NULL. 
                      void                  *pReserved,      //IN Optional
                      BOOL                  fKeyService,     //IN Required: Whether the function is called remotely
                      DWORD                 dwPurpose,       //IN Required: Whether it is enrollment or renew
                      BOOL                  fConfirmation,   //IN Required: Set the TRUE if confirmation dialogue is needed
                      HWND                  hwndParent,      //IN Optional: The parent window
                      LPWSTR                pwszConfirmationTitle,   //IN Optional: The title for confirmation dialogue
                      UINT                  idsConfirmTitle, //IN Optional: The resource ID for the title of the confirmation dialogue
                      LPWSTR                pwszCALocation,  //IN Required: The ca machine name
                      LPWSTR                pwszCAName,      //IN Required: The ca name
                      CERT_BLOB             *pCertBlob,      //IN Required: The renewed certifcate
                      CERT_REQUEST_PVK_NEW  *pRenewKey,      //IN Required: The private key on the certificate
                      BOOL                  fNewKey,         //IN Required: Set the TRUE if new private key is needed
                      CERT_REQUEST_PVK_NEW  *pKeyNew,        //IN Required: The private key information
                      LPWSTR                pwszHashAlg,     //IN Optional: The hash algorithm
                      LPWSTR                pwszDesStore,    //IN Optional: The destination store
                      DWORD                 dwStoreFlags,    //IN Optional: The store flags
                      CERT_ENROLL_INFO      *pRequestInfo,   //IN Required: The information about the cert request
                      CERT_BLOB             *pPKCS7Blob,     //OUT Optional: The PKCS7 from the CA
                      CERT_BLOB             *pHashBlob,      //OUT Optioanl: The SHA1 hash of the enrolled/renewed certificate
                      DWORD                 *pdwStatus,      //OUT Optional: The status of the enrollment/renewal
		      HANDLE                *pResult         //OUT Optional: The enrolled certificate
				 );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _LENROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\mailto.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       mailto.h
//
//--------------------------------------------------------------------------

// mailto.h

// Required symbols
#define MAX_LENGTH 256
#define MEGA_LENGTH 65535
#define WIN95_REG_KEY "Software\\Microsoft\\Windows Messaging Subsystem\\Profiles"
#define WINNT_REG_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles"

// Options
#define		MAIL_QUIET		0x00000001	// Quiet - no output
#define		MAIL_VERBOSE	0x00000002	// Verbose - status sent to standard out

// Signature
ULONG MailTo(char *szRecip,			// NULL delimited recipient list (one or more)
			char *szCC,				// NULL delimited CC list (zero or more)
			char *szBCC,			// NULL delimited BCC list (zero or more)
			char *szSubject,		// subject (may be empty string)
			char *szMessage,		// message text (may be empty string)
			char *szFileName,		// NULL delimited file attachment names (zero or more)
			unsigned int dwOptions);// Options

// szRecip		-	Recipient list
//						This should be a null terminated list of recipient names.
//						Each name should be separated with a null character and
//						the string should be terminated with two null characters.
//						This is consistent with the common open file dialog.

// szCC			-	Carbon copy recipient list
//						This should also be a null terminated list of recipient names.
//						Obviously this is the list of names to be cc'd on the mail.

// szBCC		-	Blind carbon copy recipient list
//						This should also be a null terminated list of recipient names.
//						The names on this list will also get the mail but the regular
//						recipients and carbon copy recipients will not know.

// szSubject	-	Subject text of message
//						This should be a null terminated string that will go in the
//						subject field.

// szMessage	-	Body text of message
//						This should be a null terminated string that will be the
//						body text of the message.

// szFileName	-	List of file attachments
//						This should be a null terminated list of file names to attach.
//						The files will go on the first line before the body text.

// dwOptions	-	See Options above

// Note: You are limited to thirty total recipients and thirty total files.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\passrecp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passrecp.h

Abstract:

    This module contains private data definitions for the password recovery system

Author:

    Pete Skelly (petesk)    09-May-00

--*/

#ifndef __PASSRECP_H__
#define __PASSRECP_H__

#ifdef __cplusplus
extern "C" {
#endif

#define RECOVERY_BLOB_MAGIC *((DWORD *)"MSRB")
#define RECOVERY_BLOB_VERSION 1

#define RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION 1

typedef struct _RECOVERY_SUPPLEMENTAL_CREDENTIAL
{
    DWORD dwVersion;
    DWORD cbRecoveryCertHashSize;
    DWORD cbRecoveryCertSignatureSize;
    DWORD cbEncryptedPassword;
} RECOVERY_SUPPLEMENTAL_CREDENTIAL, *PRECOVERY_SUPPLEMENTAL_CREDENTIAL;


DWORD 
RecoveryRetrieveSupplementalCredential(
    PSID pUserSid,
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL *ppSupplementalCred, 
    DWORD *pcbSupplementalCred);

DWORD 
RecoverySetSupplementalCredential(
    PSID pUserSid,
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pSupplementalCred, 
    DWORD cbSupplementalCred);

DWORD
PRImportRecoveryKey(
            IN PUNICODE_STRING pUserName,
            IN PUNICODE_STRING pCurrentPassword,
            IN BYTE* pbRecoveryPublic,
            IN DWORD cbRecoveryPublic);

DWORD 
PRGetUserSid(
    IN  PBYTE pbRecoveryPrivate,
    IN  DWORD cbRecoveryPrivate,
    OUT PSID *ppSid);

DWORD
DPAPICreateNestedDirectories(
    IN      LPWSTR szFullPath,
    IN      LPWSTR szCreationStartPoint);

#ifdef __cplusplus
}
#endif


#endif // __RECOVERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\ossutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ossutil.h
//
//  Contents:   OSS ASN.1 compiler utility functions.
//
//  APIs: 
//              OssUtilAlloc
//              OssUtilFree
//              OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilFreeHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilSetBitStringWithoutTrailingZeroes
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilEncodeInfoEx
//              OssUtilDecodeAndAllocInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __OSSUTIL_H__
#define __OSSUTIL_H__

#include <wincrypt.h>
#include <pkialloc.h>

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OssUtil allocation and free functions
//--------------------------------------------------------------------------
#define OssUtilAlloc    PkiNonzeroAlloc
#define OssUtilFree     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//
//  OssUtilFreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        );

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

#define OssUtilFreeHugeUINT     OssUtilFreeHugeInteger

void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        );

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        );

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        );

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        );

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_OSS_UTIL_DECODE_EX_CALLBACK)(
    IN void *pvOssInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\ossconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       ossconv.h
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  APIs:       OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//
//--------------------------------------------------------------------------

#ifndef __OSSCONV_H__
#define __OSSCONV_H__

#include "asn1hdr.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    );

#define OSS_UTC_TIME_CHOICE             1
#define OSS_GENERALIZED_TIME_CHOICE     2

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\lsasecpk.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1995
//
// File:        lsasecpk.h
//
// Contents:    common stuff for all sec packages
//
//
// History:     06-Mar-99   ChandanS   Created
//
//------------------------------------------------------------------------

// We need this to be a day less than maxtime so when callers
// of sspi convert to utc, they won't get time in the past.

#define MAXTIMEQUADPART (LONGLONG)0x7FFFFF36D5969FFF
#define MAXTIMEHIGHPART 0x7FFFFF36
#define MAXTIMELOWPART  0xD5969FFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\offsgn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       offsng32.h
//
//  Contents:   Microsoft Internet Security Office Helper
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef OFFSNG32_H
#define OFFSNG32_H

#ifdef __cplusplus
extern "C" 
{
#endif

//////////////////////////////////////////////////////////////////////////////
//
// OFFICESIGN_ACTION_VERIFY Guid  (Authenticode add-on)
//----------------------------------------------------------------------------
//  Assigned to the pgActionID parameter of WinVerifyTrust to verify the
//  authenticity of a Structured Storage file using the Microsoft Office
//  Authenticode add-on Policy Provider,
//  
//          {5555C2CD-17FB-11d1-85C4-00C04FC295EE}
//
#define     OFFICESIGN_ACTION_VERIFY                                    \
                { 0x5555c2cd,                                           \
                  0x17fb,                                               \
                  0x11d1,                                               \
                  { 0x85, 0xc4, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee }     \
                }

#define     OFFICE_POLICY_PROVIDER_DLL_NAME             L"OFFSGN32.DLL"
#define     OFFICE_INITPROV_FUNCTION                    L"OfficeInitializePolicy"
#define     OFFICE_CLEANUPPOLICY_FUNCTION               L"OfficeCleanupPolicy"

//////////////////////////////////////////////////////////////////////////////
//
// CryptOfficeSign
//----------------------------------------------------------------------------
//  Digitally signs the file.  The user will be prompted for signing 
//  certificate.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in  (the user will NOT be shown UI)
//
extern BOOL WINAPI CryptOfficeSignW(HWND hWndCaller, WCHAR *pwszFile);
extern BOOL WINAPI CryptOfficeSignA(HWND hWndCaller, char *pszFile);

//////////////////////////////////////////////////////////////////////////////
//
// CryptOfficeVerify
//----------------------------------------------------------------------------
//  Digitally verifies the file.  The user will be presented UI if 
//  applicable.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in (the user will NOT be shown UI).
//
extern BOOL WINAPI CryptOfficeVerifyW(HWND hWndCaller, WCHAR *pwszFile);
extern BOOL WINAPI CryptOfficeVerifyA(HWND hWndCaller, char *pszFile);

#ifdef UNICODE

#   define CryptOfficeSign      CryptOfficeSignW
#   define CryptOfficeVerify    CryptOfficeVerifyW

#else

#   define CryptOfficeSign      CryptOfficeSignA
#   define CryptOfficeVerify    CryptOfficeVerifyA

#endif // UNICODE


#ifdef __cplusplus
}
#endif

#endif // OFFSNG32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\lrucache.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lrucache.h
//
//  Contents:   LRU Cache API
//
//  History:    16-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LRUCACHE_H__)
#define __LRUCACHE_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// These API allow creation and manipulation of an LRU based cache area.  The
// identifier used for the cache area is a stream of bytes of which some set
// of bytes are used for the hash index.  In order to get optimal caching
// the identifiers used should be unique and the bytes sufficiently random.
//

typedef HANDLE HLRUCACHE;
typedef HANDLE HLRUENTRY;

//
// Configuration flags
//

#define LRU_CACHE_NO_SERIALIZE            0x00000001
#define LRU_CACHE_NO_COPY_IDENTIFIER      0x00000002

//
// Entry removal and cache freeing flags
//

#define LRU_SUPPRESS_REMOVAL_NOTIFICATION 0x00000004

//
// Entry touching flags
//

#define LRU_SUPPRESS_CLOCK_UPDATE         0x00000008

typedef VOID (WINAPI *LRU_DATA_FREE_FN) (LPVOID pvData);
typedef DWORD (WINAPI *LRU_HASH_IDENTIFIER_FN) (PCRYPT_DATA_BLOB pIdentifier);
typedef VOID (WINAPI *LRU_ON_REMOVAL_NOTIFY_FN) (LPVOID pvData, LPVOID pvRemovalContext);

//
// Configuration NOTE: If MaxEntries is zero then no LRU is applied to the
//                     cache entries, i.e. the cache is not bounded.
//

typedef struct _LRU_CACHE_CONFIG {

    DWORD                    dwFlags;
    LRU_DATA_FREE_FN         pfnFree;
    LRU_HASH_IDENTIFIER_FN   pfnHash;
    LRU_ON_REMOVAL_NOTIFY_FN pfnOnRemoval;
    DWORD                    cBuckets;
    DWORD                    MaxEntries;

} LRU_CACHE_CONFIG, *PLRU_CACHE_CONFIG;

BOOL
WINAPI
I_CryptCreateLruCache (
       IN PLRU_CACHE_CONFIG pConfig,
       OUT HLRUCACHE* phCache
       );

VOID
WINAPI
I_CryptFlushLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

VOID
WINAPI
I_CryptFreeLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

BOOL
WINAPI
I_CryptCreateLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       IN LPVOID pvData,
       OUT HLRUENTRY* phEntry
       );

PCRYPT_DATA_BLOB
WINAPI
I_CryptGetLruEntryIdentifier (
       IN HLRUENTRY hEntry
       );

LPVOID
WINAPI
I_CryptGetLruEntryData (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptAddRefLruEntry (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptReleaseLruEntry (
       IN HLRUENTRY hEntry
       );

VOID
WINAPI
I_CryptInsertLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL LPVOID pvLruRemovalContext
       );

VOID
WINAPI
I_CryptRemoveLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       );

VOID
WINAPI
I_CryptTouchLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL DWORD dwFlags
       );

// NOTE: The following find does NOT touch the cache entry

HLRUENTRY
WINAPI
I_CryptFindLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier
       );

// NOTE: The following find touches the cache entry

LPVOID
WINAPI
I_CryptFindLruEntryData (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       OUT HLRUENTRY* phEntry
       );

//
// If you cache contains multiple entries with the same identifier, then
// this function can be used to enumerate them after finding the first with
// I_CryptFindLruEntry
//
// NOTE: hPrevEntry is released
//
// NOTE: This does NOT touch the cache entries
//
// NOTE: The only way to safely use this function is if the serialization
//       is done outside of the cache handle and you use the
//       LRU_CACHE_NO_SERIALIZE flag.  If not, then you will get undefined
//       results if hPrevEntry is removed or inserted (after removal) in
//       between calls
//

HLRUENTRY
WINAPI
I_CryptEnumMatchingLruEntries (
       IN HLRUENTRY hPrevEntry
       );

//
// Temporary disabling of LRU behavior.  When it is re-enabled then entries
// are purged until the watermark is again met
//

VOID
WINAPI
I_CryptEnableLruOfEntries (
       IN HLRUCACHE hCache,
       IN OPTIONAL LPVOID pvLruRemovalContext
       );

VOID
WINAPI
I_CryptDisableLruOfEntries (
       IN HLRUCACHE hCache
       );

//
// Walk all entries function
//

typedef BOOL (WINAPI *PFN_WALK_ENTRIES) (
                          IN LPVOID pvParameter,
                          IN HLRUENTRY hEntry
                          );

VOID
WINAPI
I_CryptWalkAllLruCacheEntries (
       IN HLRUCACHE hCache,
       IN PFN_WALK_ENTRIES pfnWalk,
       IN LPVOID pvParameter
       );

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\lsaitf.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        lsaitf.h
//
// Contents:    Prototypes for auth packages to call into LSA & SAM
//
//
// History:     21-February-1997        Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __LSAITF_H__
#define __LSAITF_H__

#include <samrpc.h>
#include <lsarpc.h>
#include <samisrv.h>
#include <lsaisrv.h>

NTSTATUS
I_SamrSetInformationUser(
    IN                SAMPR_HANDLE            UserHandle,
    IN                USER_INFORMATION_CLASS UserInformationClass,
    IN                PSAMPR_USER_INFO_BUFFER Buffer
    );

NTSTATUS
I_SamrCloseHandle(
    IN OUT            SAMPR_HANDLE    *       SamHandle
    );

NTSTATUS
I_SamrOpenDomain(
    IN                SAMPR_HANDLE            ServerHandle,
    IN                ACCESS_MASK             DesiredAccess,
    IN                PRPC_SID                DomainId,
    OUT               SAMPR_HANDLE    *       DomainHandle
    );

NTSTATUS
I_SamrQueryInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    );

NTSTATUS
I_SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
I_SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

NTSTATUS
I_SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
I_SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

VOID
I_SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );

VOID
I_SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    );

VOID
I_SamIFree_SAMPR_RETURNED_USTRING_ARRAY (
    PSAMPR_RETURNED_USTRING_ARRAY Source
    );

VOID
I_SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    );

VOID
I_SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
    );

VOID
I_SamIFreeVoid(
    IN PVOID ptr
    );

NTSTATUS
I_SamIUpdateLogonStatistics(
    IN  SAMPR_HANDLE DomainHandle,
    IN  PSAM_LOGON_STATISTICS LogonStats
    );

NTSTATUS
I_SamIUPNFromUserHandle(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    );

NTSTATUS
I_LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    );

NTSTATUS
I_LsarClose(
    IN OUT LSAPR_HANDLE *ObjectHandle
    );

NTSTATUS
I_LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

VOID
I_LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );

NTSTATUS
I_LsarQueryInformationPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *PolicyInformation
    );

NTSTATUS
I_LsarCreateSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

NTSTATUS
I_LsarOpenSecret(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING SecretName,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *SecretHandle
    );

NTSTATUS
I_LsarSetSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    IN PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
    );

NTSTATUS
I_LsarQuerySecret(
    IN LSAPR_HANDLE SecretHandle,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    IN OUT OPTIONAL PLARGE_INTEGER CurrentValueSetTime,
    IN OUT OPTIONAL PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    IN OUT OPTIONAL PLARGE_INTEGER OldValueSetTime
    );

NTSTATUS
I_LsarDelete(
    IN OUT LSAPR_HANDLE ObjectHandle
    );

VOID
I_LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    );

NTSTATUS NTAPI
I_LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS NTAPI
I_LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS
I_LsaIAuditAccountLogonEx(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             LogonStatus, OPTIONAL
    IN PSID                 ClientSid
    );

NTSTATUS
I_LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    );

NTSTATUS
I_LsaISetLogonGuidInLogonSession(
    IN  PLUID  pLogonId,
    IN  LPGUID pLogonGuid
    );

VOID
I_LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid,
    IN PLSA_ADT_STRING_LIST TransittedServices
    );

NTSTATUS
I_LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,
    IN HANDLE          User1ProcessId,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid,
    IN PUNICODE_STRING pTargetName,
    IN PUNICODE_STRING pTargetInfo
    );


NTSTATUS
I_LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
I_LsaIAddNameToLogonSession(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  PUNICODE_STRING Name
    );

NTSTATUS
I_LsaIGetNameFromLuid(
    IN  PLUID           LogonId,
    IN  ULONG           NameFormat,
    IN  BOOLEAN         LocalOnly,
    OUT PUNICODE_STRING Name
    );

//
// Internal package-specific flags for the logon session
//

#define LOGONSES_FLAG_NTLM_DOWNLEVEL    0x00000001

NTSTATUS NTAPI
I_LsaISetPackageAttrInLogonSession(
    IN  PLUID LogonId,
    IN  ULONG PackageAttr
    );

#endif //  __LSAITF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pkicrit.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkicrit.h
//
//  Contents:   PKI CriticalSection Functions
//
//  APIs:       Pki_InitializeCriticalSection
//
//  History:    23-Aug-99    philh   created
//--------------------------------------------------------------------------

#ifndef __PKICRIT_H__
#define __PKICRIT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following calls InitializeCriticalSection within a try/except.
//  If an exception is raised, returns FALSE with LastError set to
//  the exception error. Otherwise, TRUE is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
Pki_InitializeCriticalSection(
    OUT LPCRITICAL_SECTION lpCriticalSection
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pfx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       pfx.h
//
//  Contents:   PFX (PKCS #12) function defintions and types
//
//----------------------------------------------------------------------------
#ifndef PFX_H
#define PFX_H

// All of the pfx definitions have been moved to the following
#include <wincrypt.h>

#endif // PFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pkioss.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkioss.h
//
//  Contents:   PKI OSS support functions.
//
//              PkiOssEncode
//              PkiOssEncode2
//              PkiOssDecode
//              PkiOssDecode2
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIOSS_H__
#define __PKIOSS_H__

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output is allocated and must be freed
//  by calling ossFreeBuf
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );


//+-------------------------------------------------------------------------
//  OSS Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssEncode2(
    IN OssGlobal *Pog,
    IN void *pvOssInfo,
    IN int id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  OSS Decode function. The allocated, decoded structure, **pvOssInfo, must
//  be freed by calling ossFreePDU().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
int
WINAPI
PkiOssDecode2(
    IN OssGlobal *Pog,
    OUT void **ppvOssInfo,
    IN int id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1Alloc
//              PkiAsn1Free
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1FreeHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1SetBitStringWithoutTrailingZeroes
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>
#include <pkialloc.h>

#ifdef OSS_CRYPT_ASN1
#include "asn1hdr.h"
#include "asn1code.h"
#include "ossglobl.h"
#include "pkioss.h"
#include "ossutil.h"
#include "ossconv.h"
#endif  // OSS_CRYPT_ASN1


#ifdef __cplusplus
extern "C" {
#endif



#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  PkiAsn1 allocation and free functions
//--------------------------------------------------------------------------
#define PkiAsn1Alloc    PkiNonzeroAlloc
#define PkiAsn1Free     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  PkiAsn1FreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

#define PkiAsn1FreeHugeUINT     PkiAsn1FreeHugeInteger

void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set BitString Without Trailing Zeroes
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitStringWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        );

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    );

#define PKI_ASN1_UTC_TIME_CHOICE            1
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    2

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    );

#else 

//+=========================================================================
// The following map to the OSS ASN1 routines
//==========================================================================

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 <= Asn1Err && 1000 > Asn1Err)
        return CRYPT_E_OSS_ERROR + Asn1Err;
    else if (0 > Asn1Err)
        return CRYPT_E_ASN1_ERROR + (-Asn1Err -1000);
    else
        return CRYPT_E_ASN1_ERROR + 0x100 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT OPTIONAL DWORD *pcbEncoded = NULL
    )
{
    return (ASN1error_e) PkiOssEncode(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ossFreeBuf((OssGlobal *) pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssEncode2(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        pbEncoded,
        cbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode2(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ossFreePDU((OssGlobal *) pDec, (int) id, pvAsn1Info);
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ossEncodingRules ossRules;
    if (ASN1_BER_RULE_BER == eRule)
        ossRules = OSS_BER;
    else
        ossRules = OSS_DER;

    return (ASN1error_e) ossSetEncodingRules((OssGlobal *) pEnc, ossRules);
}

__inline
ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ossEncodingRules ossRules;
    ossRules = ossGetEncodingRules((OssGlobal *) pEnc);
    if (OSS_BER == ossRules)
        return ASN1_BER_RULE_BER;
    else
        return ASN1_BER_RULE_DER;
}

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID OssEncodedOid;
    OssBuf dotOid;
    memset(&dotOid, 0, sizeof(dotOid));

    OssEncodedOid.length = pEncodedOid->length;
    OssEncodedOid.value = pEncodedOid->value;
    if (0 == ossEncodedOidToDotVal((OssGlobal *) pDec, &OssEncodedOid,
            &dotOid))
        return (LPSTR) dotOid.value;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ossFreeBuf((OssGlobal *) pDec, pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID eoid;
    memset(&eoid, 0, sizeof(eoid));
    if (0 == ossDotValToEncodedOid((OssGlobal *) pEnc, pszDotVal, &eoid)) {
        pEncodedOid->length = eoid.length;
        pEncodedOid->value = eoid.value;
        return 1;
    } else {
        pEncodedOid->length = 0;
        pEncodedOid->value = NULL;
        return 0;
    }
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ossFreeBuf((OssGlobal *) pEnc, pEncodedOid->value);
}

#define PkiAsn1Alloc OssUtilAlloc
#define PkiAsn1Free OssUtilFree
#define PkiAsn1ReverseBytes OssUtilReverseBytes
#define PkiAsn1AllocAndReverseBytes OssUtilAllocAndReverseBytes
#define PkiAsn1GetOctetString OssUtilGetOctetString
#define PkiAsn1SetHugeInteger OssUtilSetHugeInteger
#define PkiAsn1FreeHugeInteger OssUtilFreeHugeInteger
#define PkiAsn1GetHugeInteger OssUtilGetHugeInteger
#define PkiAsn1SetHugeUINT OssUtilSetHugeUINT
#define PkiAsn1FreeHugeUINT OssUtilFreeHugeInteger
#define PkiAsn1GetHugeUINT OssUtilGetHugeUINT
#define PkiAsn1SetBitString OssUtilSetBitString
#define PkiAsn1GetBitString OssUtilGetBitString
#define PkiAsn1SetBitStringWithoutTrailingZeroes OssUtilSetBitStringWithoutTrailingZeroes
#define PkiAsn1GetIA5String OssUtilGetIA5String
#define PkiAsn1SetUnicodeConvertedToIA5String OssUtilSetUnicodeConvertedToIA5String
#define PkiAsn1FreeUnicodeConvertedToIA5String OssUtilFreeUnicodeConvertedToIA5String
#define PkiAsn1GetIA5StringConvertedToUnicode OssUtilGetIA5StringConvertedToUnicode
#define PkiAsn1GetBMPString OssUtilGetBMPString
#define PkiAsn1SetAny OssUtilSetAny
#define PkiAsn1GetAny OssUtilGetAny

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return OssUtilDecodeAndAllocInfo(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    OssUtilFreeInfo(
        (OssGlobal *) pDec,
        (int) id,
        pvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilAllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilDecodeAndAllocInfoEx(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

#define PkiAsn1ToObjectIdentifier OssConvToObjectIdentifier
#define PkiAsn1FromObjectIdentifier OssConvFromObjectIdentifier
#define PkiAsn1ToUTCTime OssConvToUTCTime
#define PkiAsn1FromUTCTime OssConvFromUTCTime
#define PkiAsn1ToGeneralizedTime OssConvToGeneralizedTime
#define PkiAsn1FromGeneralizedTime OssConvFromGeneralizedTime


__inline
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pGeneralTime,
    OUT UTCTime *pUtcTime
    )
{
    return OssConvToChoiceOfTime(
        pFileTime,
        pwChoice,
        pGeneralTime
        );
}

#define PKI_ASN1_UTC_TIME_CHOICE            OSS_UTC_TIME_CHOICE
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    OSS_GENERALIZED_TIME_CHOICE

__inline
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pGeneralTime,
    IN UTCTime *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    return OssConvFromChoiceOfTime(
        wChoice,
        pGeneralTime,
        pFileTime
        );
}

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs:
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN size_t cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN size_t cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pkistr.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pkistr.h
//
//  Contents:   PKI String Functions
//
//  APIs:       Pki_wcsicmp
//              Pki_wcsnicmp
//              Pki_stricmp
//              Pki_strnicmp
//
//  History:    21-May-99    philh   created
//--------------------------------------------------------------------------

#ifndef __PKISTR_H__
#define __PKISTR_H__

#include <string.h>


#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  CompareString is called with the following locale:
//      MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
//--------------------------------------------------------------------------
int __cdecl Pki_wcsicmp(const wchar_t *pwsz1, const wchar_t *pwsz2);
int __cdecl Pki_wcsnicmp(const wchar_t *pwsz1, const wchar_t *pwsz2,
                    size_t cch);
int __cdecl Pki_stricmp(const char *psz1, const char *psz2);
int __cdecl Pki_strnicmp(const char *psz1, const char *psz2,
                    size_t cch);

#define _wcsicmp(s1,s2)         Pki_wcsicmp(s1,s2)
#define _wcsnicmp(s1,s2,cch)    Pki_wcsnicmp(s1,s2,cch)
#define _stricmp(s1,s2)         Pki_stricmp(s1,s2)
#define _strnicmp(s1,s2,cch)    Pki_strnicmp(s1,s2,cch)

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pstdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pstdef.h
//
//--------------------------------------------------------------------------

#ifndef _PSTDEF_H_
#define _PSTDEF_H_

/*
    Typedefs, values 
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020
#define PST_PC_NOT_AVAILABLE    0x00000040 


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area 
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/* 
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation 
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001

//
// RSABase rqmt: determine if item has ui attached
//
#define     PST_PF_NEVER_SHOW           0x00000002

/* 
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite 
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004

//
// on ReadItem call
// return value on success without UI on item is PST_E_OK
// return value on success with UI on item is PST_E_ITEM_EXISTS
// return value on failure is a different error code
//
#define     PST_PROMPT_QUERY            0x00000008

//
// on ReadItem, DeleteItem, for data migration purposes:
// Avoid displaying UI on ReadItem unless a custom password is required (highsecurity).
// Avoid displaying UI on DeleteItem, period.
//
#define     PST_NO_UI_MIGRATION         0x00000010



/* 
    Security masks, rule modifiers 
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002
#define     PST_CREATE_TYPE         0x0004
#define     PST_CREATE_SUBTYPE      0x0008
#define     PST_DELETE_TYPE         0x0010
#define     PST_DELETE_SUBTYPE      0x0020
#define     PST_USE                 0x0040

#define     PST_GENERIC_READ        PST_READ
#define     PST_GENERIC_WRITE       (PST_WRITE | PST_CREATE_TYPE | PST_CREATE_SUBTYPE)
#define     PST_GENERIC_EXECUTE     PST_USE
#define     PST_ALL_ACCESS          0x01FF


// PST_ACCESSCLAUSETYPE 

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb 
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
#define PST_E_MEMORY_IMAGE_MISMATCH     _HRESULT_TYPEDEF_(0x800C000CL)
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK

#endif // _PSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\protrust.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       protrust.h
//
//  Contents:   Protected Trust Provider
//              API Prototypes and Definitions
//
// Implements a generic trust provider that allows verification of certifciates
// and uses a call back to check the policy. The policy is called for each signature 
// in the subject and for each signer within the signature
// 
// Documentation is at the bottom of the file.
//
//--------------------------------------------------------------------------

#ifndef _PROTRUST_H_
#define _PROTRUST_H_

#include "signcde.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  PROTRUST optional certificate verification checks (elements to check)
//--------------------------------------------------------------------------
// PROTRUST_CERT_SIGNATURE_FLAG - verify certificate signature
// PROTRUST_CERT_TIME_VALIDITY_FLAG - verify certificate time 
// PROTRUST_CERT_REVOCATION_VALIDITY_FLAG - verify revocation of certificates
// 
// PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify timestamp certificate
// PROTRUST_TRUST_TEST_ROOT - verify up to the test root

#define PROTRUST_CERT_SIGNATURE_FLAG           CERT_STORE_SIGNATURE_FLAG
#define PROTRUST_CERT_TIME_VALIDITY_FLAG       CERT_STORE_TIME_VALIDITY_FLAG
#define PROTRUST_CERT_REVOCATION_VALIDITY_FLAG CERT_STORE_REVOCATION_FLAG
#define PROTRUST_TIMESTAMP_SIGNATURE_FLAG      0x00040000
#define PROTRUST_TRUST_TEST_ROOT               0x00080000

//+-------------------------------------------------------------------------
//  PROTRUST signature verification (elements that failed; See dwStatusFlags below)
//--------------------------------------------------------------------------
//  PROTRUST_TIME_FLAG  - Time of the signer certificate is not valid
//  PROTRUST_DIGEST_FLAG - digest of signature did not verify
//  PROTRUST_ROOT_FLAG - unable to find a trusted root 
//     (NOTE. check pRoot to see if a root was found)
//  These flags are supplied only to a policy call back. They are not returned
//  to the caller of WinVerifyTrust.

#define PROTRUST_TIME_FLAG              0x20000000   // Time of a certificate in chain is not valid
#define PROTRUST_DIGEST_FLAG            0x40000000   // 
#define PROTRUST_ROOT_FLAG              0x80000000


//+-------------------------------------------------------------------------
#define REGSTR_PATH_PROTRUST REGSTR_PATH_SERVICES "\\WinTrust\\TrustProviders\\Protected Trust"
#define WIN_PROTECTED_ACTION  \
{ 0xa692ba40, 0x6da8, 0x11d0, { 0xa7, 0x0, 0x0, 0xa0, 0xc9, 0x3, 0xb8, 0x3d } }

// Policy Information supplied to the call back, Use only what is required to 
// determine if the signature is to be trusted.
typedef struct _PROTECTED_POLICY_INFO {
    HCRYPTPROV         hCryptProv;     // The provider used in verfication
    DWORD              dwEncodingType; // Encoding type of certificate
    DWORD              dwSignCount;    // Signature, may be more then one signature 
    DWORD              dwSigner;       // Which signer in signature, may be more then one signer
    DWORD              dwVerifyFlags;  // Search flags used to find certificates in chain 
    PCCERT_CONTEXT     pCertContext;   // Signing Certificate found
    PCCERT_CONTEXT     pRoot;          // Root Certificate found
    PCCERT_CONTEXTLIST pCertChain;     // Chain used to verify certificate
    FILETIME           sTime;          // Valid date for certificates (ie time stamp)
    CRYPT_DIGEST_BLOB  sDigest;        // Digest (unsigned hash) from signature
    PCRYPT_ATTRIBUTES  pAuthenticatedAttributes;   // List of authenticated attributes
    PCRYPT_ATTRIBUTES  pUnauthenticatedAttributes; // List of unauthenticated attributes
    PBYTE              pbSignature;    // Encoded Signature
    DWORD              cbSignature;    // Size of Encoded Signature
    DWORD              dwStatusFlags;  // Status flags defined in PROTECTED trust model
} PROTECTED_POLICY_INFO, *PPROTECTED_POLICY_INFO;

// PROTECTED Trust Policy is defined as:
typedef HRESULT (WINAPI *_PROTECTED_TRUST_POLICY)(IN HANDLE                  hClientToken,
                                                  IN PPROTECTED_POLICY_INFO  pInfo);

// Policy List is defined as:
typedef struct _PROTECTED_TRUST_INFO {
    DWORD                   cbSize;             // sizeof(_PROTECTED_TRUST_POLICY_LIST)
    DWORD                   dwVerifyFlags;    // Should contain at least PROTRUST_CERT_SIGNATURE_FLAG
    DWORD                   dwCertEncodingType; // Optional, defaults to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
    HCRYPTPROV              hCryptProv;         // Optional, pass in provider for doing verification
    HCERTSTORE              hTrustedStore;      // Optional, list of trusted roots
    HCERTSTORE              hCertificateStore;  // Optional, additional certs to use in verification
    _PROTECTED_TRUST_POLICY pfnPolicy;          // Optional, application defined user policy
} PROTECTED_TRUST_INFO, *PPROTECTED_TRUST_INFO;

typedef struct _PROTECTED_TRUST_ACTDATA_CALLER_CONTEXT {
    HANDLE                hClientToken;
    GUID *                SubjectType;
    WIN_TRUST_SUBJECT     Subject;
    PROTECTED_TRUST_INFO  sTrustInfo; 
} PROTECTED_TRUST_ACTDATA_CALLER_CONTEXT, *LPPROTECTED_TRUST_ACTDATA_CALLER_CONTEXT;

// The policy provider must use the following return codes
// Returns S_OK: - valid signature, returns from the trust provider
//         S_FALSE: - continue on to the next signature or signer
//         ERROR: - aborts trust provider and exists with this error code.
//


//---------------------------------------------------------------------------
/*
  Generic Trust Provider

  Usage: The generic trust provider is designed to provide a flexible manner for
  implementing a policy where the developer can let the provider do as much or 
  as little of the decision making as required. Verifying is composed of two stages,
  the first is to determine if the signature matches the item that was signed. The
  second stage is to determine if the certificate used to do the signing was valid. 
  This second stage is dependent on the policy of the calling application, criteria
  like, root certificates, specific signature certicates, certificate extensions can
  all be used to determine if the signature is valid. 

  There are three ways of using the generic trust provider (GTB) to do the verification, 
  1) let the GTB verify the digest and verify the certificate.
  2) let the GTB verify the digest and verify the certificate supplying the GTB root 
  certificates that can be trusted.
  3) supply a policy call back that the GTB calls providing the signature, certificates
  and its status for the digest and the certifcate to the policy call back.

  METHOD 1) Let the trust provider do the verfication
  
  Fill in a PROTECTED_TRUST_INFO structure. The only fields that must be filled in are
  cbSize and dwVerifyFlags. dwVerifyFlags specify how to determine if the signing certificate
  and all the issuer certificates are valid (validity flags can be combined).

            cbSize = sizeof(PROTECTED_TRUST_INFO);

            dwVerifyFlags = zero or more of PROTRUST_CERT_SIGNATURE_FLAG 
                                            PROTRUST_CERT_TIME_VALIDITY_FLAG
                                            PROTRUST_TIMESTAMP_SIGNATURE_FLAG
                                            PROTRUST_TRUST_TEST_ROOT.
            (where:
                PROTRUST_CERT_SIGNATURE_FLAG - verify certificates on signatures 
                                               (ie find the issuer certificate and 
                                               verify the signature of the certificate).
                PROTRUST_CERT_TIME_VALIDITY_FLAG - verify that the certificate is 
                                                   valid at the current time.
                PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify that the certificate was 
                                                    valid at the time a time-stamp was 
                                                    placed on the signature. If there
                                                    is no time stamp then use the current time.
                PROTRUST_TRUST_TEST_ROOT - Verifying the certifcate chain to the test 
                                           root is valid.)

  WinVerifyTrust will return:
        S_OK - signature verified
        TRUST_E_NOSIGNATURE  - no signature found
        NTE_BAD_SIGNATURE    - signature did not verify to digest
        CERT_E_UNTRUSTEDROOT - verifyied to an untrusted root
        CERT_E_CHAINING      - a certificate could not be verified (issuer not found)
        CERT_E_EXPIRED       - a valid certificate chain could not be found 
                               (ceritifcate or issuer expired)

  METHOD 2) Let the trust provider verify to a list of certificates.

  Add a store to the PROTECTED_TRUST_INFO structure in addition to the entries 
  specified in method 1.
    
            hTrustedStore = a store that contains all roots that are to be trusted.
                            (This store can be opened using CertOpenSystemStore etc.)
            
            cbSize = sizeof(PROTECTED_TRUST_INFO);
            
            dwVerifyFlags = zero or more of PROTRUST_CERT_SIGNATURE_FLAG 
                                            PROTRUST_CERT_TIME_VALIDITY_FLAG
                                            PROTRUST_TIMESTAMP_SIGNATURE_FLAG
                                            PROTRUST_TRUST_TEST_ROOT.
              (where:
                PROTRUST_CERT_SIGNATURE_FLAG - verify certificates on signatures 
                                               (ie find the issuer certificate and 
                                               verify the signature of the certificate).
                PROTRUST_CERT_TIME_VALIDITY_FLAG - verify that the certificate is 
                                                   valid at the current time.
                PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify that the certificate was 
                                                    valid at the time a time-stamp was 
                                                    placed on the signature. If there
                                                    is no time stamp then use the current time.
                PROTRUST_TRUST_TEST_ROOT - Verifying the certifcate chain to the test 
                                           root is valid.)

  WinVerifyTrust will return:
        S_OK - signature verified
        TRUST_E_NOSIGNATURE  - no signature found
        NTE_BAD_SIGNATURE    - signature did not verify to digest
        CERT_E_UNTRUSTEDROOT - verifyied to an untrusted root
        CERT_E_CHAINING      - a certificate could not be verified (issuer not found)
        CERT_E_EXPIRED       - a valid certificate chain could not be found 
                               (ceritifcate or issuer expired)

            
  METHOD 3) Pass in a policy call back that is called prior to returning from
  WinVerifyTrust. The call back is called for every signature found and for
  each signer in a signature. When then call back returns S_OK then the WinVerifyTrust
  returns. If S_FALSE is returned from the call back then the next signer or signature
  is tried. If and error is found then WinVerifyTrust returns this error immediately.

  The call back must by of type _PROTECTED_TRUST_POLICY. This function takes a HANDLE 
  and a PPROTECTED_POLICY_INFO. The handle points to client data that is passed into
  WinVerifyTrust, it can contain data, returned elements, status flags etc. The  
  PPROTECTED_POLICY_INFO points to a structure that contains all the information the
  general trust provider found in the signature. The policy call back can use some or 
  all of this data in determining if the signature is valid.
  
  In addition to method 1 and method 2 a call back procedure is added to the 
  PROTECTED_TRUST_INFO structure.

            pfnPolicy = MyPolicy;   
              (where: 
                MyPolicy is a function defined by the caller.)

            hTrustedStore = a store that contains all roots that are to be trusted.
                            (This store can be opened using CertOpenSystemStore etc.)
            
            cbSize = sizeof(PROTECTED_TRUST_INFO);
            
            dwVerifyFlags = zero or more of PROTRUST_CERT_SIGNATURE_FLAG 
                                            PROTRUST_CERT_TIME_VALIDITY_FLAG
                                            PROTRUST_TIMESTAMP_SIGNATURE_FLAG
                                            PROTRUST_TRUST_TEST_ROOT.
              (where:
                PROTRUST_CERT_SIGNATURE_FLAG - verify certificates on signatures 
                                               (ie find the issuer certificate and 
                                               verify the signature of the certificate).
                PROTRUST_CERT_TIME_VALIDITY_FLAG - verify that the certificate is 
                                                   valid at the current time.
                PROTRUST_TIMESTAMP_SIGNATURE_FLAG - verify that the certificate was 
                                                    valid at the time a time-stamp was 
                                                    placed on the signature. If there
                                                    is no time stamp then use the current time.
                PROTRUST_TRUST_TEST_ROOT - Verifying the certifcate chain to the test 
                                           root is valid.)
  WinVerifyTrust will return:
        The return code from the policy module.

        Example: of policy callback.
         
    //
    // Protest3 - tool for manually calling WinVerifyTrust
    //
            
    #include <stdio.h>
    #include <windows.h>
    #include "wincrypt.h"
    #include "signcde.h" 
    #include "protrust.h"
    
    
    // Potential Subject ids
    GUID guidProtectedTrust    = WIN_PROTECTED_ACTION;
    GUID guidSubjectPeImage    = WIN_TRUST_SUBJTYPE_PE_IMAGE;
    GUID guidSubjectJavaClass  = WIN_TRUST_SUBJTYPE_JAVA_CLASS;
    GUID guidSubjectCabinet    = WIN_TRUST_SUBJTYPE_CABINET;
            
    
            // Which action and subject will be used
    GUID*   pguidActionID = &guidProtectedTrust;
    GUID*   pguidSubject  = &guidSubjectPeImage;
    
            // Structures used to call WinVerifyTrust
    PROTECTED_TRUST_ACTDATA_CALLER_CONTEXT  sSetup;
    WIN_TRUST_SUBJECT_FILE                  sSubjectFile;
    
            // Set up my own error codes
    #define MY_CODE_NO_ROOT          0x00010000
    #define MY_CODE_BAD_DIGEST       0x00100000
    #define MY_CODE_BAD_TIME         0x00200000
    
    // Define my structure for use in the Policy call back.
    typedef struct _CLIENT_DATA {
        DWORD  dwStatusFlags; // Verification Status
        BOOL   dwRealRoot;    // Did it verify to the real microsoft root
        BOOL   dwTestRoot;    // Did it verify to the test root
    } CLIENT_DATA, *PCLIENT_DATA;
    
    HRESULT WINAPI MyPolicy(IN HANDLE hClientToken,
                            IN PPROTECTED_POLICY_INFO pInfo)
    {
        HRESULT hr = S_OK;
        PCLIENT_DATA pClient = (PCLIENT_DATA) hClientToken;
        
        if(pInfo->dwStatusFlags & PROTRUST_DIGEST_FLAG) {
            // Bad digest
            pClient->dwStatusFlags |= MY_CODE_BAD_DIGEST;
            return S_FALSE; // Try next one
        }
    
        // Check to see if the signing certificate had a valid time
        if(pInfo->dwStatusFlags & PROTRUST_TIME_FLAG) {
            // time expired on certificate or issuer
            pClient->dwStatusFlags |= MY_CODE_BAD_TIME;
            return S_FALSE; // Try next one
        }
    
        // Check to see we got a root cert. If not then we did
        // not verify up to a root.
        if(!pInfo->pRoot) {
            pClient->dwStatusFlags |= MY_CODE_NO_ROOT;
            hr = CERT_E_ISSUERCHAINING;
        }
        else {
    
            // Test the Cert to see which one it is
            hr = SpcIsRootCert(pInfo->pRoot);
            if(hr == S_FALSE) { // The certificate is the test root cert
                pClient->dwRealRoot = FALSE;
                pClient->dwTestRoot = TRUE;
            }
            else if(hr == S_OK) {
                pClient->dwRealRoot = TRUE;
                pClient->dwTestRoot = FALSE;
            }
        }
        return hr;
    }
    
    
    // Information defined by me for use in my policy
    WCHAR   rgwSubjectPath[_MAX_PATH];
    BOOL    fCheckTimeStamp = FALSE;
    BOOL    fCheckCurrentTime = FALSE;
    BOOL    fTestRootOk = FALSE;
    
    void Usage ()
    {
        printf ( "Usage:   CHKTRUST [-options] file-name\n" );
        printf ( "Options:\n" );
        printf ( "  -I       : subject type is PE executable image file (default)\n" );
        printf ( "  -J       : subject type is Java class\n" );
        printf ( "  -C       : subject type is Cabinet file\n" );
        printf ( "  -S       : check for a time stamp\n");
        printf ( "  -T       : test root is valid\n");
        printf ( "  -U       : use current time to see if certificates are valid\n");
                    
        exit ( 0 );
    }
           
           
    VOID
    WINAPI
    ParseSwitch (CHAR chSwitch,
                 int *pArgc,
                 char **pArgv[])
    {
           
        switch (toupper (chSwitch)) {
        case '?':
            Usage();
            break;
        case 'I':
            pguidSubject = &guidSubjectPeImage;
            break;
        case 'J':
            pguidSubject = &guidSubjectJavaClass;
            break;
        case 'C':
            pguidSubject = &guidSubjectCabinet;
            break;
        case 'S':
            fCheckTimeStamp  = TRUE;
            break;
        case 'T':
            fTestRootOk  = TRUE;
            break;
        case 'U':
            fCheckCurrentTime  = TRUE;
            break;
        default:
            Usage ();
            break;
        }
    }
    
    void _cdecl main ( int argc, char** argv )
    {
        HCERTSTORE hRoots = NULL;
        WCHAR wpath[_MAX_PATH];
        char chChar, *pchChar;
    
        if ( argc <= 1 ) Usage ();
    
        while (--argc) {
            pchChar = *++argv;
            if (*pchChar == '/' || *pchChar == '-') {
                while (chChar = *++pchChar) {
                    ParseSwitch (chChar, &argc, &argv);
                }
            }
            else {
                MultiByteToWideChar ( CP_ACP, 0, pchChar, -1, wpath, _MAX_PATH );
                sSubjectFile.hFile = INVALID_HANDLE_VALUE;
                sSubjectFile.lpPath = &(wpath[0]);
                sSetup.SubjectType = pguidSubject;
                sSetup.Subject = &sSubjectFile;
            }
        }
        
        // Make sure we have a file
        if ( sSubjectFile.lpPath == NULL ) 
            Usage();
        
        // Setup up client data for policy (application decides what this is)
        CLIENT_DATA sClientData; 
        //   Zero out structure
        ZeroMemory(&sClientData, sizeof(CLIENT_DATA));
            
        //   Set the Client structure to return status codes
        sSetup.hClientToken = (HANDLE) &sClientData;
    
        //==================
        // Setup the Protrust structure
            
        // Setup the Protected Trust info (Most fields are optional)
        //   Zero out structure
        ZeroMemory(&sSetup.sTrustInfo, sizeof(PROTECTED_TRUST_INFO));
            
            //   Set size of structure for extensibility
        sSetup.sTrustInfo.cbSize = sizeof(PROTECTED_TRUST_INFO); // 
            
        //   Check the possible flags for verifying certificates
        sSetup.sTrustInfo.dwVerifyFlags = PROTRUST_CERT_SIGNATURE_FLAG;
        if(fTestRootOk)
            sSetup.sTrustInfo.dwVerifyFlags |= PROTRUST_TRUST_TEST_ROOT;
        if(fCheckTimeStamp) 
            sSetup.sTrustInfo.dwVerifyFlags |= PROTRUST_TIMESTAMP_SIGNATURE_FLAG;
        if(fCheckCurrentTime)
            sSetup.sTrustInfo.dwVerifyFlags |= PROTRUST_CERT_TIME_VALIDITY_FLAG;
            
            
            //   Set the policy (defined above)
        sSetup.sTrustInfo.pfnPolicy = MyPolicy;
        
        //   The rest of sSetup.sTrustInfo is the default values
       
            //==================
            // Check the file
    
        DWORD r = WinVerifyTrust ( NULL, pguidActionID, &sSetup );
        if(sClientData.dwStatusFlags & MY_CODE_NO_ROOT)
            printf ("Did not find a root certificate\n");
        if(sClientData.dwStatusFlags & MY_CODE_BAD_DIGEST)
            printf ("There was no valid signature\n");
        if(sClientData.dwStatusFlags & MY_CODE_BAD_TIME)
            
            printf ("The certificate had an invalid time\n");
    
        switch(r) {
        case TRUST_E_NOSIGNATURE:
            printf ("No signature found\n");
            break;
        default:
            printf ("Result: %0x\n", r );
        }
    
        if(hRoots)
            CertCloseStore(hRoots, 0);
        exit ( r == 0 ? 0 : 1 );
    }
    
    */ 
//---------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif

#endif //_PROTRUST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\safelock.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    safelock.h

Abstract:

    "safe lock" collection of routines

    This code is a debug-only replacement for APIs dealing with
    critical sections and resources.  It is essentially a thin
    wrapper around those routines that ensures proper ordering
    of locks and helps catch potential deadlock situations.

    The code will generate debug spew (and optionally assert)
    when locks are acquired outside of the given order.

    Utilizing this code will have zero impact on the FRE builds
    and negligible impact on DBG builds (as it is lock- and
    contention-free)

    Here is how you use it:

    o  #include <safelock.h>

    o  determine the lock order for your routine and add an enum
       such as:

       typedef enum {

           LockTypeA,
           LockTypeB,
           LockTypeC

       } MY_ENUM;

       The code will ensure that, for instance, LockTypeA
       is not acquired with LockTypeC held, unless that thread
       already holds LockTypeA.

    o  Once per process initialization, call the SafeLockInit()
       routine.  This routine should only be called in checked
       builds.

    o  replace every declaration of RTL_CRITICAL_SECTION
       with SAFE_CRITICAL_SECTION

    o  replace every declaration of RTL_RESOURCE
       with SAFE_RESOURCE

    o  replace every call to RtlEnterCriticalSection with
       SafeEnterCriticalSection (similary for RtlLeaveCriticalSection
       and other Rtl* calls involving RTL_CRITICAL_SECTION)

    o  replace every call to RtlAcquireResource with
       SafeAcquireResource (similarly for RtlReleaseResource and
       other Rtl* calls involving RTL_RESOURCE)

    o  RtlInitializeCriticalSection and RtlInitializeResource
       are replaced with SafeEnterCriticalSection and
       SafeInitializeResource and take one additional parameter -
       the enum value associated with the critical section:

       e.g. replace

       RtlInitializeCriticalSection( &critsecA );

       with

       SafeInitializeCriticalSection( &critsecA, LockTypeA );

--*/

#ifndef __SAFELOCK_H
#define __SAFELOCK_H

#include <nturtl.h>

#ifdef DBG

NTSTATUS
SafeLockInit(
    IN DWORD MaxLocks,
    IN BOOL AssertOnErrors
    );

NTSTATUS
SafeLockCleanup(
    );

typedef struct _SAFE_CRITICAL_SECTION {

    RTL_CRITICAL_SECTION CriticalSection;
    LONG Enum;

} SAFE_CRITICAL_SECTION, *PSAFE_CRITICAL_SECTION;

NTSTATUS
SafeEnterCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection
    );

NTSTATUS
SafeLeaveCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection
    );

BOOLEAN
SafeTryEnterCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection
    );

NTSTATUS
SafeInitializeCriticalSection(
    PSAFE_CRITICAL_SECTION SafeCriticalSection,
    DWORD Enum
    );

NTSTATUS
SafeInitializeCriticalSectionAndSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount,
    DWORD Enum
    );

ULONG
SafeSetCriticalSectionSpinCount(
    PSAFE_CRITICAL_SECTION CriticalSection,
    ULONG SpinCount
    );

NTSTATUS
SafeDeleteCriticalSection(
    PSAFE_CRITICAL_SECTION CriticalSection
    );

#define SafeCritsecLockCount( _critsec )            ((_critsec)->CriticalSection.LockCount )

typedef struct _SAFE_RESOURCE {

    RTL_RESOURCE Resource;
    LONG Enum;

} SAFE_RESOURCE, *PSAFE_RESOURCE;

VOID
SafeInitializeResource(
    PSAFE_RESOURCE Resource,
    DWORD Enum
    );

BOOLEAN
SafeAcquireResourceShared(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    );

BOOLEAN
SafeAcquireResourceExclusive(
    PSAFE_RESOURCE Resource,
    BOOLEAN Wait
    );

VOID
SafeReleaseResource(
    PSAFE_RESOURCE Resource
    );

VOID
SafeConvertSharedToExclusive(
    PSAFE_RESOURCE Resource
    );

VOID
SafeConvertExclusiveToShared(
    PSAFE_RESOURCE Resource
    );

VOID
NTAPI
SafeDeleteResource (
    PSAFE_RESOURCE Resource
    );

#define SafeEnterResourceCritsec( _resrc )          RtlEnterCriticalSection( &(_resrc)->Resource.CriticalSection )
#define SafeLeaveResourceCritsec( _resrc )          RtlLeaveCriticalSection( &(_resrc)->Resource.CriticalSection )
#define SafeNumberOfActive( _resrc )                ((_resrc)->Resource.NumberOfActive )
#define SafeNumberOfWaitingShared( _resrc )         ((_resrc)->Resource.NumberOfWaitingShared )
#define SafeNumberOfWaitingExclusive( _resrc )      ((_resrc)->Resource.NumberOfWaitingExclusive )

#else

#define SAFE_CRITICAL_SECTION RTL_CRITICAL_SECTION
#define PSAFE_CRITICAL_SECTION PRTL_CRITICAL_SECTION

#define SafeEnterCriticalSection                    RtlEnterCriticalSection
#define SafeLeaveCriticalSection                    RtlLeaveCriticalSection
#define SafeTryEnterCriticalSection                 RtlTryEnterCriticalSection
#define SafeInitializeCriticalSection( _cs, _enum ) RtlInitializeCriticalSection( _cs )
#define SafeInitializeCriticalSectionAndSpinCount( _cs, _count, _enum )   RtlInitializeCriticalSectionAndSpinCount( _cs, _count )
#define SafeSetCriticalSectionSpinCount             RtlSetCriticalSectionSpinCount
#define SafeDeleteCriticalSection                   RtlDeleteCriticalSection

#define SafeCritsecLockCount( _critsec )            ((_critsec)->LockCount )

#define SAFE_RESOURCE         RTL_RESOURCE
#define PSAFE_RESOURCE        PRTL_RESOURCE

#define SafeInitializeResource( _res, _enum )       RtlInitializeResource( _res )
#define SafeAcquireResourceShared                   RtlAcquireResourceShared
#define SafeAcquireResourceExclusive                RtlAcquireResourceExclusive
#define SafeReleaseResource                         RtlReleaseResource
#define SafeConvertSharedToExclusive                RtlConvertSharedToExclusive
#define SafeConvertExclusiveToShared                RtlConvertExclusiveToShared
#define SafeDeleteResource                          RtlDeleteResource

#define SafeEnterResourceCritsec( _resrc )          RtlEnterCriticalSection( &(_resrc)->CriticalSection )
#define SafeLeaveResourceCritsec( _resrc )          RtlLeaveCriticalSection( &(_resrc)->CriticalSection )
#define SafeNumberOfActive( _resrc )                ((_resrc)->NumberOfActive )
#define SafeNumberOfWaitingShared( _resrc )         ((_resrc)->NumberOfWaitingShared )
#define SafeNumberOfWaitingExclusive( _resrc )      ((_resrc)->NumberOfWaitingExclusive )

#endif

#endif // __SAFELOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\sclogon2.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ScLogon2

Abstract:

    This header defines APIs for use by GINA and LSA during logon via a
    smart card, these API's merely redirect the calls from the LSA procoess
    back to the corresponing Winlogon process to make the needed CSP calls

Author:

    reidk

Environment:

    Win32

Revision History:

Notes:

--*/

#ifndef __SCLOGON2_H__
#define __SCLOGON2_H__


#define SCLOGONRPC_DEFAULT_ENDPOINT             TEXT("\\pipe\\sclogonpipe")
#define SCLOGONRPC_DEFAULT_PROT_SEQ             TEXT("ncacn_np")

#define SCLOGONRPC_LOCAL_ENDPOINT               TEXT("sclogonrpc")
#define SCLOGONRPC_LOCAL_PROT_SEQ               TEXT("ncalrpc")

#define SZ_ENDPOINT_NAME_FORMAT                 TEXT("%s-%lx")


#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS WINAPI
__ScHelperInitializeContext(
    IN OUT PBYTE                    pbLogonInfo,
    IN ULONG                        cbLogonInfo
    );

VOID WINAPI
__ScHelperRelease(
    IN PBYTE                        ppbLogonInfo
    );

NTSTATUS WINAPI
__ScHelperGetProvParam(
    IN PUNICODE_STRING              pucPIN,
    IN PBYTE                        pbLogonInfo,
    IN ULONG_PTR                    KerbHProv,
    DWORD                           dwParam,
    BYTE                            *pbData,
    DWORD                           *pdwDataLen,
    DWORD                           dwFlags
    );

NTSTATUS WINAPI
__ScHelperGetCertFromLogonInfo(
    IN PBYTE                        pbLogonInfo,
    IN PUNICODE_STRING              pucPIN,
    OUT PCCERT_CONTEXT              *CertificateContext
    );

NTSTATUS WINAPI
__ScHelperGenRandBits(
    IN PBYTE                        pbLogonInfo,
    IN ScHelper_RandomCredBits      *psc_rcb
);


NTSTATUS WINAPI
__ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING              pucPIN,
    IN PCCERT_CONTEXT               CertificateContext,
    IN PBYTE                        pbLogonInfo,
    IN PBYTE                        SignedEncryptedData,
    IN ULONG                        SignedEncryptedDataSize,
    OUT OPTIONAL PBYTE              CleartextData,
    OUT PULONG                      CleartextDataSize
    );

NTSTATUS WINAPI
__ScHelperEncryptCredentials(
    IN PUNICODE_STRING              pucPIN,
    IN PCCERT_CONTEXT               CertificateContext,
    IN ScHelper_RandomCredBits      *psch_rcb,
    IN PBYTE                        pbLogonInfo,
    IN PBYTE                        CleartextData,
    IN ULONG                        CleartextDataSize,
    OUT OPTIONAL PBYTE              EncryptedData,
    OUT PULONG                      EncryptedDataSize
    );

NTSTATUS WINAPI
__ScHelperSignMessage(
    IN PUNICODE_STRING              pucPIN,
    IN PBYTE                        pbLogonInfo,
    IN OPTIONAL ULONG_PTR           KerbHProv,
    IN ULONG                        Algorithm,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    OUT PBYTE                       Signature,
    OUT PULONG                      SignatureLength
    );

NTSTATUS WINAPI
__ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING     pucPIN,
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN OPTIONAL ULONG_PTR           KerbHProv,
    IN PCCERT_CONTEXT               Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER  Algorithm,
    IN OPTIONAL DWORD               dwSignMessageFlags,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    OUT OPTIONAL PBYTE              SignedBuffer,
    OUT OPTIONAL PULONG             SignedBufferLength
    );

NTSTATUS WINAPI
__ScHelperVerifyMessage(
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN PCCERT_CONTEXT               CertificateContext,
    IN ULONG                        Algorithm,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    IN PBYTE                        Signature,
    IN ULONG                        SignatureLength
    );

/*NTSTATUS WINAPI
__ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN OPTIONAL HCRYPTPROV          Provider,
    IN PBYTE                        Buffer,
    IN ULONG                        BufferLength,
    OUT OPTIONAL PBYTE              DecodedBuffer,
    OUT OPTIONAL PULONG             DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT     *CertificateContext
    );*/

NTSTATUS WINAPI
__ScHelperDecryptMessage(
    IN PUNICODE_STRING              pucPIN,
    IN OPTIONAL PBYTE               pbLogonInfo,
    IN OPTIONAL ULONG_PTR           KerbHProv,
    IN PCCERT_CONTEXT               CertificateContext,
    IN PBYTE                        CipherText,         // Supplies formatted CipherText
    IN ULONG                        CipherLength,       // Supplies the length of the CiperText
    OUT PBYTE                       ClearText,          // Receives decrypted message
    IN OUT PULONG                   pClearLength        // Supplies length of buffer, receives actual length
    );

NTSTATUS WINAPI
__ScHelper_CryptAcquireCertificatePrivateKey(
    IN PCCERT_CONTEXT               CertificateContext,
    OUT ULONG_PTR                   *pKerbHProv,
    OUT DWORD                       *pLastError
    );

NTSTATUS WINAPI
__ScHelper_CryptSetProvParam(
    IN ULONG_PTR                    KerbHProv,
    IN LPSTR                        pszPIN,
    OUT DWORD                       *pLastError
    );

NTSTATUS WINAPI
__ScHelper_CryptReleaseContext(
    IN ULONG_PTR                    KerbHProv
    );


/////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // __SCLOGON2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pvkhlpr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.h
//
//  Contents:   Private Key Helper API Prototypes and Definitions
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  APIs:       PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContext
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//              PrivateKeyLoadA
//              PrivateKeySaveA
//              PrivateKeyLoadFromMemoryA
//              PrivateKeySaveToMemoryA
//              PrivateKeyAcquireContextA
//              PrivateKeyAcquireContextFromMemoryA
//              PrivateKeyReleaseContextA
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------

#ifndef __PVKHLPR_H__
#define __PVKHLPR_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PRIVATEKEYBLOB
#define PRIVATEKEYBLOB  0x7
#endif


    //+-------------------------------------------------------------------------
    //  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  from the file into the cryptographic provider.
    //
    //  If the private key was password encrypted, then, the user is first
    //  presented with a dialog box to enter the password.
    //
    //  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
    //  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
    //  a mismatch. *pdwKeySpec is updated with the key type.
    //
    //  dwFlags is passed through to CryptImportKey.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyLoad(IN HCRYPTPROV hCryptProv,
                       IN HANDLE hFile,
                       IN HWND hwndOwner,
                       IN LPCWSTR pwszKeyName,     // name used in dialog
                       IN DWORD dwFlags,
                       IN OUT OPTIONAL DWORD *pdwKeySpec);

    BOOL WINAPI
        PvkPrivateKeyLoadA(IN HCRYPTPROV hCryptProv,
                        IN HANDLE hFile,
                        IN HWND hwndOwner,
                        IN LPCTSTR pwszKeyName,     // name used in dialog
                        IN DWORD dwFlags,
                        IN OUT OPTIONAL DWORD *pdwKeySpec);

    //+-------------------------------------------------------------------------
    //  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  to the specified file.
    //
    //  The user is presented with a dialog box to enter an optional password to
    //  encrypt the private key.
    //
    //  dwFlags is passed through to CryptExportKey.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeySave(IN HCRYPTPROV hCryptProv,
                       IN HANDLE hFile,
                       IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                       IN HWND hwndOwner,
                       IN LPCWSTR pwszKeyName,     // name used in dialog
                       IN DWORD dwFlags);

    BOOL WINAPI
        PvkPrivateKeySaveA(IN HCRYPTPROV hCryptProv,
                        IN HANDLE hFile,
                        IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                        IN HWND hwndOwner,
                        IN LPCTSTR pwszKeyName,     // name used in dialog
                        IN DWORD dwFlags);
    //+-------------------------------------------------------------------------
    //  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  from memory into the cryptographic provider.
    //
    //  Except for the key being loaded from memory, identical to PrivateKeyLoad.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyLoadFromMemory(IN HCRYPTPROV hCryptProv,
                                 IN BYTE *pbData,
                                 IN DWORD cbData,
                                 IN HWND hwndOwner,
                                 IN LPCWSTR pwszKeyName,     // name used in dialog
                                 IN DWORD dwFlags,
                                 IN OUT OPTIONAL DWORD *pdwKeySpec);

    BOOL WINAPI
        PvkPrivateKeyLoadFromMemoryA(IN HCRYPTPROV hCryptProv,
                                  IN BYTE *pbData,
                                  IN DWORD cbData,
                                  IN HWND hwndOwner,
                                  IN LPCTSTR pwszKeyName,     // name used in dialog
                                  IN DWORD dwFlags,
                                  IN OUT OPTIONAL DWORD *pdwKeySpec);
    
    //+-------------------------------------------------------------------------
    //  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
    //  to memory.
    //
    //  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
    //  return an error (also, the user isn't prompted for a password).
    //
    //  Except for the key being saved to memory, identical to PrivateKeySave.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeySaveToMemory(IN HCRYPTPROV hCryptProv,
                               IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                               IN HWND hwndOwner,
                               IN LPCWSTR pwszKeyName,     // name used in dialog
                               IN DWORD dwFlags,
                               OUT BYTE *pbData,
                               IN OUT DWORD *pcbData);

    BOOL WINAPI
        PvkPrivateKeySaveToMemoryA(IN HCRYPTPROV hCryptProv,
                                IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
                                IN HWND hwndOwner,
                                IN LPCTSTR pwszKeyName,     // name used in dialog
                                IN DWORD dwFlags,
                                OUT BYTE *pbData,
                                IN OUT DWORD *pcbData);

    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from the specified file.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoad is called to load the private key into the temporary
    //  container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContext(IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN HANDLE hFile,
                                 IN HWND hwndOwner,
                                 IN LPCWSTR pwszKeyName,     // name used in dialog
                                 IN OUT OPTIONAL DWORD *pdwKeySpec,
                                 OUT HCRYPTPROV *phCryptProv,
                                 OUT LPWSTR *ppwszTmpContainer
                                 );

    BOOL WINAPI
        PvkPrivateKeyAcquireContextA(IN LPCTSTR pwszProvName,
                                  IN DWORD dwProvType,
                                  IN HANDLE hFile,
                                  IN HWND hwndOwner,
                                  IN LPCTSTR pwszKeyName,     // name used in dialog
                                  IN OUT OPTIONAL DWORD *pdwKeySpec,
                                  OUT HCRYPTPROV *phCryptProv,
                                  OUT LPTSTR *ppwszTmpContainer);
    //+-------------------------------------------------------------------------
    //  Creates a temporary container in the provider and loads the private key
    //  from memory.
    //  For success, returns a handle to a cryptographic provider for the private
    //  key and the name of the temporary container. PrivateKeyReleaseContext must
    //  be called to release the hCryptProv and delete the temporary container.
    //
    //  PrivateKeyLoadFromMemory is called to load the private key into the
    //  temporary container.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemory(IN LPCWSTR pwszProvName,
                                           IN DWORD dwProvType,
                                           IN BYTE *pbData,
                                           IN DWORD cbData,
                                           IN HWND hwndOwner,
                                           IN LPCWSTR pwszKeyName,     // name used in dialog
                                           IN OUT OPTIONAL DWORD *pdwKeySpec,
                                           OUT HCRYPTPROV *phCryptProv,
                                           OUT LPWSTR *ppwszTmpContainer);

    BOOL WINAPI
        PvkPrivateKeyAcquireContextFromMemoryA(IN LPCTSTR pwszProvName,
                                            IN DWORD dwProvType,
                                            IN BYTE *pbData,
                                            IN DWORD cbData,
                                            IN HWND hwndOwner,
                                            IN LPCTSTR pwszKeyName,     // name used in dialog
                                            IN OUT OPTIONAL DWORD *pdwKeySpec,
                                            OUT HCRYPTPROV *phCryptProv,
                                            OUT LPTSTR *ppwszTmpContainer);

    //+-------------------------------------------------------------------------
    //  Releases the cryptographic provider and deletes the temporary container
    //  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
    //--------------------------------------------------------------------------
    BOOL WINAPI
        PvkPrivateKeyReleaseContext(IN HCRYPTPROV hCryptProv,
                                 IN LPCWSTR pwszProvName,
                                 IN DWORD dwProvType,
                                 IN LPWSTR pwszTmpContainer);

    BOOL WINAPI
        PvkPrivateKeyReleaseContextA(IN HCRYPTPROV hCryptProv,
                                  IN LPCTSTR pwszProvName,
                                  IN DWORD dwProvType,
                                  IN LPTSTR pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Acquiring hprovs, Trys the file first and then the KeyContainer. Use
//  PvkFreeCryptProv to release HCRYPTPROV and resources.
//--------------------------------------------------------------------------
    HCRYPTPROV WINAPI 
        PvkGetCryptProvA(IN HWND hwnd,
                         IN LPCSTR pszCaption,
                         IN LPCSTR pszCapiProvider,
                         IN DWORD  dwProviderType,
                         IN LPCSTR pszPrivKey,
                         OUT LPSTR *ppszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvA(IN HCRYPTPROV hProv,
                          IN LPCSTR  pszCapiProvider,
                          IN DWORD   dwProviderType,
                          IN LPSTR   pszTmpContainer);

    HCRYPTPROV WINAPI 
        PvkGetCryptProvU(IN HWND hwnd,
                         IN LPCWSTR pwszCaption,
                         IN LPCWSTR pwszCapiProvider,
                         IN DWORD   dwProviderType,
                         IN LPCWSTR pwszPrivKey,
                         OUT LPWSTR *ppwszTmpContainer);
    
    void WINAPI
        PvkFreeCryptProvU(IN HCRYPTPROV hProv,
                          IN LPCWSTR  pwszCapiProvider,
                          IN DWORD    dwProviderType,
                          IN LPWSTR   pwszTmpContainer);

//+-------------------------------------------------------------------------
//  Private Key helper  error codes
//--------------------------------------------------------------------------
#define PVK_HELPER_BAD_PARAMETER        0x80097001
#define PVK_HELPER_BAD_PVK_FILE         0x80097002
#define PVK_HELPER_WRONG_KEY_TYPE       0x80097003
#define PVK_HELPER_PASSWORD_CANCEL      0x80097004

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\scuisupp.h ===
#if !defined(__SCUISUPP_INCLUDED__)
#define __SCUISUPP_INCLUDED__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <wincrypt.h>

// use these strings for RegisterWindowMessage
#define SCARDUI_READER_ARRIVAL		"SCardUIReaderArrival"
#define SCARDUI_READER_REMOVAL		"SCardUIReaderRemoval"
#define SCARDUI_SMART_CARD_INSERTION	"SCardUISmartCardInsertion"
#define SCARDUI_SMART_CARD_REMOVAL	"SCardUISmartCardRemoval"
#define SCARDUI_SMART_CARD_STATUS	"SCardUISmartCardStatus"
#define SCARDUI_SMART_CARD_CERT_AVAIL   "SCardUISmartCardCertAvail"

typedef LPVOID HSCARDUI;

typedef struct _CERT_ENUM
{
	// status of the reader / card 	  
	// typical values:
	// SCARD_S_SUCCESS
	// SCARD_E_UNKNOWN_CARD - unregistered / unknown card
	// SCARD_W_UNRESPONSIVE_CARD - card upside down
	// NTE_KEYSET_NOT_DEF - known card with no certificate
	// SCARD_W_REMOVED_CARD - card removed shortly after insertion
	DWORD				dwStatus;

	// name of the reader that contains the card
	LPTSTR				pszReaderName;

	// name of the card (NULL if card is unknown)
	LPTSTR				pszCardName;

	// certificate context 
	// (NULL if card is unknown or can't be read)
	PCERT_CONTEXT		pCertContext;

} CERT_ENUM, *PCERT_ENUM;


// initialize smart card ui
HSCARDUI 
WINAPI
SCardUIInit(
    HWND hWindow			// handle of parent window
    );

// clean up 
DWORD 
WINAPI
SCardUIExit(
	HSCARDUI hSCardUI		// handle that was returned by SCardUIInit
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\pstprv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pstprv.h
//
//--------------------------------------------------------------------------

//
// private header for secure storage
//

#ifndef __PSTPRV_H__
#define __PSTPRV_H__

#define PROTSTOR_VERSION            1
#define MAXPROTSEQ                  20     // increase avail bind handles to 20

#define PSTORE_LOCAL_ENDPOINT        L"protected_storage"
#define PSTORE_LOCAL_PROT_SEQ        L"ncalrpc"

#define PST_EVENT_INIT              "PS_SERVICE_STARTED"
//
// For Windows NT5, terminal server requires the "Global\" prefix in order
// for the named-event to be shared across all sessions.
//
#define PST_EVENT_INIT_NT5          "Global\\PS_SERVICE_STARTED"
#define PST_EVENT_STOP              "PS_SERVICE_STOP"
#define PST_EVENT_DEFER_QUERY       "PS_SERVICE_QUERY"

//
// file name of our network provider
//

#define FILENAME_CLIENT_INTERFACE   L"pstorec.dll"


#define PASSWORD_LOGON_NT           1

//
// WinNT doesn't have logoff notification.  Scavenger will call LSA to see if
// session deleted.
//
#define PASSWORD_LOGON_LEGACY_95    3   // old case-sensitive passwords on Win95, don't use!
#define PASSWORD_LOGOFF_95          4
#define PASSWORD_LOGON_95           5

#define MODULE_RAISE_COUNT          4   // Ref count on process raise count



#define REG_PSTTREE_LOC             L"SOFTWARE\\Microsoft\\Protected Storage System Provider"



//
// private callbacks exposed for server which are specific to base provider.
//

#define SS_SERVERPARAM_CALLBACKS    0x6997  // server get param value

typedef
BOOL FGETWINDOWSPASSWORD(
        PST_PROVIDER_HANDLE     *hPSTProv,
        BYTE                    rgbPasswordDerivedBytes[],
        DWORD                   cbPasswordDerivedBytes);

FGETWINDOWSPASSWORD FGetWindowsPassword;

typedef
HRESULT PRIVATE_AUTHENTICODEINITPOLICY(
    IN      LPVOID lpV
    );

PRIVATE_AUTHENTICODEINITPOLICY PrivateAuthenticodeInitPolicy;

typedef
HRESULT PRIVATE_AUTHENTICODEFINALPOLICY(
    IN      LPVOID lpV
    );

PRIVATE_AUTHENTICODEFINALPOLICY PrivateAuthenticodeFinalPolicy;

typedef struct {
    DWORD                               cbSize; // sizeof(PRIVATE_CALLBACKS)

    FGETWINDOWSPASSWORD*                pfnFGetWindowsPassword;

    PRIVATE_AUTHENTICODEINITPOLICY*     pfnAuthenticodeInitPolicy;
    PRIVATE_AUTHENTICODEFINALPOLICY*    pfnAuthenticodeFinalPolicy;

} PRIVATE_CALLBACKS, *PPRIVATE_CALLBACKS, *LPPRIVATE_CALLBACKS;


typedef struct {
    PST_PROVIDER_HANDLE hPSTProv;   // copy of client provided handle
    handle_t hBinding;              // client binding handle

    HANDLE hThread;                 // client thread handle
    HANDLE hProcess;                // client process handle (not to be closed)
    DWORD dwProcessId;              // client process ID
    LPVOID lpContext;               // Win95 HACKHACK context

} CALL_STATE, *PCALL_STATE, *LPCALL_STATE;


//
// installed provider item data buffer
//

typedef struct {
    DWORD cbSize;                   // sizeof(PST_PROVIDER)
    BYTE FileHash[20];              // SHA-1 hash of file szFileName
    WCHAR szFileName[ANYSIZE_ARRAY];// Unicode (in-place) file name
} PST_PROVIDER, *PPST_PROVIDER, *LPPST_PROVIDER;


#endif // __PSTPRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\scrdcert.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scrdcert.h
//
//  Contents:   Smart Card Certificate Helper API
//
//  History:    21-Nov-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SCRDCERT_H__)
#define __SCRDCERT_H__

#if defined(__cplusplus)
extern "C" {
#endif 

//
// Register and Unregister a smart card certificate store.  These stores
// appear as physical stores under the Smart Card Logical Store in the 
// Current User location.  When registering a card store, the caller must
// provide the following information:
//
// Card Friendly Name
// Provider Name ( NULL means use the Microsoft Base Smart Card Provider )
// Container Name ( NULL means use the Card Friendly Name )
//
// If a card store of the given name already exists the registration will
// return an error (ERROR_ALREADY_EXISTS) unless the 
// SMART_CARD_STORE_REPLACE_EXISTING flag is used
//

#define SMART_CARD_STORE_REPLACE_EXISTING 0x00000001
         
BOOL WINAPI
I_CryptRegisterSmartCardStore (
       IN LPCWSTR pwszCardName,
       IN OPTIONAL LPCWSTR pwszProvider,
       IN OPTIONAL DWORD dwProviderType,
       IN OPTIONAL LPCWSTR pwszContainer,
       IN DWORD dwFlags
       );

BOOL WINAPI
I_CryptUnregisterSmartCardStore (
       IN LPCWSTR pwszCardName
       );  

//
// Find a smart card certificate in a store
//
// For a certificate to be considered a smart card certificate.  It must have
// the CERT_SMART_CARD_DATA_PROP_ID.  The SMART_CARD_CERT_FIND_DATA can be used
// to place additional filtering on the returned smart card certificates. 
// Optionally, the CERT_SMART_CARD_DATA_PROP_ID value can be returned as well.
// The value can be freed using LocalFree or if the *ppSmartCardData is non NULL 
// will be freed for the caller
//

typedef struct _SMART_CARD_CERT_FIND_DATA {

    DWORD  cbSize;                        
    LPWSTR pwszProvider;
    DWORD  dwProviderType;
    LPWSTR pwszContainer;
    DWORD  dwKeySpec;
    
} SMART_CARD_CERT_FIND_DATA, *PSMART_CARD_CERT_FIND_DATA;

PCCERT_CONTEXT WINAPI
I_CryptFindSmartCardCertInStore (
       IN HCERTSTORE hStore,
       IN PCCERT_CONTEXT pPrevCert,
       IN OPTIONAL PSMART_CARD_CERT_FIND_DATA pFindData,
       IN OUT OPTIONAL PCRYPT_DATA_BLOB* ppSmartCardData
       );
       
//
// Add a smart card certificate to a store and add the specified properties
// to it.
//

BOOL WINAPI
I_CryptAddSmartCardCertToStore (
       IN HCERTSTORE hStore,
       IN PCRYPT_DATA_BLOB pEncodedCert,
       IN OPTIONAL LPWSTR pwszCertFriendlyName,
       IN PCRYPT_DATA_BLOB pSmartCardData,
       IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
       );      
       
//
// Definitions
//

#define MS_BASE_PROVIDER         L"Microsoft Base Cryptographic Provider"
#define MAX_PROVIDER_TYPE_STRLEN 13
#define SMART_CARD_SYSTEM_STORE  L"SmartCard"
                          
#if defined(__cplusplus)
}
#endif 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\secauth.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       secauth.h
//
//--------------------------------------------------------------------------

//Security dialog box help

#define SECAUTH_HELPFILENAME                "SECAUTH.HLP"

//Topics were copied from iexplore.rtf (IE help)
#define IDH_SECAUTH_ENTER_SSL               52168 //Entering a secure site
#define IDH_SECAUTH_ENTER_SSL_W_INVALIDCERT 52169 //Entering a secure site with an invalid certificate
#define IDH_SECAUTH_FILE_DOWN               52170 //File Download
#define IDH_SECAUTH_SEND_N_REC_COOKIES      52171 //Sending and Receiving Information About Your Browsing
#define IDH_SECAUTH_SIGNED                  52172 //Signed ActiveX/Java Download
#define IDH_SECAUTH_SIGNED_N_INVALID        52173 //Signed and Invalid ActiveX/Java Download
#define IDH_SECAUTH_UNSIGNED                52174 //Unsigned ActiveX/Java Download
#define IDH_SECAUTH_MIXED_DOWNLOAD_FROM_SSL 52175 //Insecure content download from a secure Web site
#define IDH_SECAUTH_ENTER_NON_SECURE_SITE   52226 //Entering non-secure Web site without a cert, from a secure web site
#define IDH_SECAUTH_SIGNED_N_INVALID_WEB    52227 //Entering Web site with invalid cert, from a secure web site

#define IDH_TRUSTCOMMERCIAL                 1
#define IDH_TRUSTLIST                       4
#define IDH_TRUSTREMOVE                     5

#define IDH_DIGSIGNATURE                    11
#define IDH_DIGCERTIFICATE                  12
#define IDH_CONTENTDESC                     13
#define IDH_MYURL                           14
#define IDH_TIMESTAMPURL                    15

#define IDH_CERTVIEW_GENERAL_SUBJECT_EDIT           101
#define IDH_CERTVIEW_GENERAL_ISSUER_EDIT            102
#define IDH_CERTVIEW_GENERAL_INSTALLCERT_BUTTON     103
#define IDH_CERTVIEW_GENERAL_EDITPROPERTIES_BUTTON  104
#define IDH_CERTVIEW_GENERAL_DISCLAIMER_BUTTON      105
#define IDH_CERTVIEW_GENERAL_ACCEPT_BUTTON          106
#define IDH_CERTVIEW_GENERAL_DECLINE_BUTTON         107
#define IDH_CERTVIEW_GENERAL_GOODFOR_EDIT           108
#define IDH_CERTVIEW_GENERAL_VALID_EDIT             110
#define IDH_CERTVIEW_GENERAL_PRIVATE_KEY_INFO       111

#define IDH_CERTVIEW_DETAILS_SHOW_COMBO             115
#define IDH_CERTVIEW_DETAILS_SAVECERT_BUTTON        116
#define IDH_CERTVIEW_DETAILS_ITEM_LIST              117
#define IDH_CERTVIEW_DETAILS_ITEM_EDIT              118

#define IDH_CERTVIEW_HIERARCHY_TRUST_TREE           120
#define IDH_CERTVIEW_HIERARCHY_SHOW_DETAILS_BUTTON  121
#define IDH_CERTVIEW_HIERARCHY_ERROR_EDIT           122

#define IDH_CTLVIEW_GENERAL_ITEM_LIST               125
#define IDH_CTLVIEW_GENERAL_ITEM_EDIT               126
#define IDH_CTLVIEW_GENERAL_VIEWSIGNATURE_BUTTON    127

#define IDH_CTLVIEW_TRUSTLIST_CERTIFICATE_LIST      130
#define IDH_CTLVIEW_TRUSTLIST_CERTVALUE_LIST        131
#define IDH_CTLVIEW_TRUSTLIST_VALUE_DETAIL_EDIT     132
#define IDH_CTLVIEW_TRUSTLIST_VIEWCERT_BUTTON       133

#define IDH_CRLVIEW_GENERAL_ITEM_LIST               135
#define IDH_CRLVIEW_GENERAL_ITEM_EDIT               136

#define IDH_CRLVIEW_REVOCATIONLIST_REVOCATION_LIST  140
#define IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY       141
#define IDH_CRLVIEW_REVOCATIONLIST_LIST_ENTRY_DETAIL 142

#define IDH_CERTPROPERTIES_CERTIFICATENAME          145
#define IDH_CERTPROPERTIES_DESCRIPTION              146
#define IDH_CERTPROPERTIES_USAGE_LIST               147
#define IDH_CERTPROPERTIES_ADDPURPOSE_BUTTON        148
#define IDH_CERTPROPERTIES_ENABLE_ALL_RADIO         260
#define IDH_CERTPROPERTIES_DISABLE_ALL_RADIO        261
#define IDH_CERTPROPERTIES_ENABLE_CUSTOM_RADIO      262


#define IDH_SIGNERINFO_GENERAL_SIGNERNAME           150
#define IDH_SIGNERINFO_GENERAL_SIGNEREMAIL          151
#define IDH_SIGNERINFO_GENERAL_SIGNETIME            152
#define IDH_SIGNERINFO_GENERAL_VIEW_CERTIFICATE     153
#define IDH_SIGNERINFO_GENERAL_COUNTERSIG_LIST      154
#define IDH_SIGNERINFO_GENERAL_COUNTERSIG_DETAILS   155

#define IDH_SIGNERINFO_ADVANCED_DETAIL_LIST         160
#define IDH_SIGNERINFO_ADVANCED_DETAIL_EDIT         161

#define IDH_SELECTSTORE_STORE_TREE                  167
#define IDH_SELECTSTORE_SHOWPHYSICAL_CHECK          168

#define IDH_SELECTCERTIFICATE_VIEWCERT_BUTTON       172
#define IDH_SELECTCERTIFICATE_CERTIFICATE_LIST      173

#define IDH_CATALOGVIEW_GENERAL_ITEM_LIST           175
#define IDH_CATALOGVIEW_GENERAL_ITEM_EDIT           176
#define IDH_CATALOGVIEW_GENERAL_VIEWSIGNATURE_BUTTON 177

#define IDH_CATALOG_ENTRY_LIST                      180
#define IDH_CATALOG_ENTRY_DETAILS                   181
#define IDH_CATALOG_ENTRY_DETAIL_DISPLAY            182

// DSIE: followings are for Cross Certificate dialog page.
#define IDH_CHECKFORNEWCERTS_CHECK                  190
#define IDH_NUMBEROFUNITS_EDIT                      191
#define IDH_UNITS_COMBO                             192
#define IDH_USE_DEFAULT_BUTTON                      193
#define IDH_ADDURL_BUTTON                           194
#define IDH_NEWURL_EDIT                             195
#define IDH_URL_LIST                                196
#define IDH_REMOVEURL_BUTTON                        197

//the following is the help for CertMgr window.
//reserve # from 200-250                                                    
#define IDH_CERTMGR_LIST                            220
#define IDH_CERTMGR_PURPOSE_COMBO                   221
#define IDH_CERTMGR_IMPORT                          223
#define IDH_CERTMGR_EXPORT                          224
#define IDH_CERTMGR_VIEW                            225
#define IDH_CERTMGR_REMOVE                          226
#define IDH_CERTMGR_ADVANCE                         227

#define IDH_CERTMGR_ADV_LIST                        240
#define IDH_CERTMGR_EXPORT_COMBO                    241
#define IDH_CERTMGR_EXPORT_CHECK                    242
#define IDH_SELCA_LIST                              247

#define IDH_CERTMGR_FIELD_PURPOSE                   252

#define IDH_DIGSIG_PROPSHEET_LIST                   270
#define IDH_DIGSIG_PROPSHEET_DETAIL                 271
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\secwarn.h ===
// W4 is too cumbersome. For that matter, even 4701 is painful,
// But, it's still very helpful in catching uninitialized vars.

// Add any other diagnostics here
#include <warning.h>
#pragma warning(error:4701)

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\setcert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       setcert.h
//
//  Contents:   SET X509 Certificate Extension Definitions
//              
//
//  History:    22-Nov-96   philh   created
//--------------------------------------------------------------------------

#ifndef __SETCERT_H__
#define __SETCERT_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Predefined X509 SET certificate extension data structures that can be
//  encoded / decoded.
//--------------------------------------------------------------------------
#define X509_SET_ACCOUNT_ALIAS              ((LPCSTR) 1000)
#define X509_SET_HASHED_ROOT_KEY            ((LPCSTR) 1001)
#define X509_SET_CERTIFICATE_TYPE           ((LPCSTR) 1002)
#define X509_SET_MERCHANT_DATA              ((LPCSTR) 1003)

//+-------------------------------------------------------------------------
//  SET Private Extension Object Identifiers
//--------------------------------------------------------------------------
#define szOID_SET_ACCOUNT_ALIAS         "2.99999.1"
#define szOID_SET_HASHED_ROOT_KEY       "2.99999.2"
#define szOID_SET_CERTIFICATE_TYPE      "2.99999.3"
#define szOID_SET_MERCHANT_DATA         "2.99999.4"

#define SET_ACCOUNT_ALIAS_OBJID         szOID_SET_ACCOUNT_ALIAS
#define SET_HASHED_ROOT_KEY_OBJID       szOID_SET_HASHED_ROOT_KEY
#define SET_CERTIFICATE_TYPE_OBJID      szOID_SET_CERTIFICATE_TYPE
#define SET_MERCHANT_DATA_OBJID         szOID_SET_MERCHANT_DATA

//+-------------------------------------------------------------------------
//  szOID_SET_ACCOUNT_ALIAS private extension
//
//  pvStructInfo points to BOOL.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  szOID_SET_HASHED_ROOT_KEY private extension
//
//  pvStructInfo points to: BYTE rgbInfo[SET_HASHED_ROOT_LEN].
//--------------------------------------------------------------------------
#define SET_HASHED_ROOT_LEN 20


//+-------------------------------------------------------------------------
//  szOID_SET_CERTIFICATE_TYPE private extension
//
//  pvStructInfo points to CRYPT_BIT_BLOB.
//--------------------------------------------------------------------------
// BYTE 0
#define SET_CERT_CARD_FLAG          0x80
#define SET_CERT_MER_FLAG           0x40
#define SET_CERT_PGWY_FLAG          0x20
#define SET_CERT_CCA_FLAG           0x10
#define SET_CERT_MCA_FLAG           0x08
#define SET_CERT_PCA_FLAG           0x04
#define SET_CERT_GCA_FLAG           0x02
#define SET_CERT_BCA_FLAG           0x01
// BYTE 1
#define SET_CERT_RCA_FLAG           0x80
#define SET_CERT_ACQ_FLAG           0x40

//+-------------------------------------------------------------------------
//  szOID_SET_MERCHANT_DATA private extension
//
//  pvStructInfo points to following SET_MERCHANT_DATA_INFO
//--------------------------------------------------------------------------
typedef struct _SET_MERCHANT_DATA_INFO {
    LPSTR       pszMerID;
    LPSTR       pszMerAcquirerBIN;
    LPSTR       pszMerTermID;
    LPSTR       pszMerName;
    LPSTR       pszMerCity;
    LPSTR       pszMerStateProvince;
    LPSTR       pszMerPostalCode;
    LPSTR       pszMerCountry;
    LPSTR       pszMerPhone;
    BOOL        fMerPhoneRelease;
    BOOL        fMerAuthFlag;
} SET_MERCHANT_DATA_INFO, *PSET_MERCHANT_DATA_INFO;

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\signdll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signdll.h
//
//--------------------------------------------------------------------------

#ifndef _SIGNDLL2_H
#define _SIGNDLL2_H

// SignCode.h : main header file for the SIGNCODE application
//

#include "spc.h"

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WINAPI 
    SignCode(IN  HWND    hwnd,
             IN  LPCWSTR pwszFilename,       // file to sign
             IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
             IN  DWORD   dwProviderType,
             IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
             IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
             IN  LPCWSTR pwszOpusName,       // the name of the program to appear in
             // the UI
             IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more
             // info...
             IN  BOOL    fIncludeCerts,
             IN  BOOL    fCommercial,
             IN  BOOL    fIndividual,
             IN  ALG_ID  algidHash,
             IN  PBYTE   pbTimeStamp,      // Optional
             IN  DWORD   cbTimeStamp );    // Optional

HRESULT WINAPI 
    TimeStampCode32(IN  HWND    hwnd,
                    IN  LPCWSTR pwszFilename,       // file to sign
                    IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
                    IN  DWORD   dwProviderType,
                    IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
                    IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
                    IN  LPCWSTR pwszOpusName,       // the name of the program to appear in the UI
                    IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more info...
                    IN  BOOL    fIncludeCerts,
                    IN  BOOL    fCommercial,
                    IN  BOOL    fIndividual,
                    IN  ALG_ID  algidHash,
                    OUT PBYTE pbTimeRequest,
                    IN OUT DWORD* cbTimeRequest);

HRESULT WINAPI 
    TimeStampCode(IN  HWND    hwnd,
                  IN  LPCWSTR pwszFilename,       // file to sign
                  IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
                  IN  DWORD   dwProviderType,
                  IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
                  IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
                  IN  LPCWSTR pwszOpusName,       // the name of the program to appear in the UI
                  IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more info...
                  IN  BOOL    fIncludeCerts,
                  IN  BOOL    fCommercial,
                  IN  BOOL    fIndividual,
                  IN  ALG_ID  algidHash,
                  IN  PCRYPT_DATA_BLOB sTimeRequest);   // Returns result in sTimeRequest 
// By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to specify a different
// memory model.

//-------------------------------------------------------------------------
// Puts up a signing dialog
HRESULT WINAPI 
     SignWizard(HWND hwnd); 

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\signcde.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signcde.h
//
//--------------------------------------------------------------------------

#ifndef _SIGNCDE_H
#define _SIGNCDE_H

// OBSOLETE :- Split up, moved to mssip32.h, mscat.h, gentrust.h and authcode.h
//---------------------------------------------------------------------
//---------------------------------------------------------------------


// SignCode.h : main header file for the SIGNCODE application
//

#include "wincrypt.h"

#include  "wintrust.h"
#include  "signutil.h"

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////
// OID's used for SPC
//   

//+-------------------------------------------------------------------------
// Structures types for CryptEncodeObject() and CryptDecodeObject()
//  ( see spc.h for addtional structures and information )
//+-------------------------------------------------------------------------
//  SPC_CERT_EXTENSIONS_OBJID
//
//  Since the type of this attribute value is CERT_EXTENSIONS, uses the
//  CERT_EXTENSIONS data structure defined in wincrypt.h. It can be encoded/decoded
//  using the the predefined lpszStructType of X509_EXTENSIONS.
//+-------------------------------------------------------------------------
//  SPC_MINIMAL_CRITERIA_STRUCT
//
//  pvStructInfo points to BOOL
//+-------------------------------------------------------------------------
#define SPC_COMMON_NAME_OBJID               szOID_COMMON_NAME
#define SPC_CERT_EXTENSIONS_OBJID           "1.3.6.1.4.1.311.2.1.14"
#define SPC_RAW_FILE_DATA_OBJID             "1.3.6.1.4.1.311.2.1.18"
#define SPC_STRUCTURED_STORAGE_DATA_OBJID   "1.3.6.1.4.1.311.2.1.19"
#define SPC_JAVA_CLASS_DATA_OBJID           "1.3.6.1.4.1.311.2.1.20"
#define SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.21"
#define SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.22"
#define SPC_CAB_DATA_OBJID                  "1.3.6.1.4.1.311.2.1.25"
#define SPC_GLUE_RDN_OBJID                  "1.3.6.1.4.1.311.2.1.25" // Duplicate number??
// Structure passed in and out is CryptoGraphicTimeStamp


//+-------------------------------------------------------------------------
//  SPC X.509 v3 Certificate Extension Object Identifiers
//
//  SPC certificates can also contain the following extensions
//  defined in wincrypt.h:
//      szOID_KEY_USAGE_RESTRICTION     "2.5.29.4"
//      szOID_BASIC_CONSTRAINTS         "2.5.29.10"
//      szOID_AUTHORITY_KEY_IDENTIFIER  "2.5.29.1"
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  SPC_COMMON_NAME_OBJID
//
//  Since the type of the common name extension is a CERT_NAME_VALUE
//  uses the CERT_NAME_VALUE data structure defined in wincrypt.h.
//  It can be encoded/decoded using the the predefined lpszStructType of
//  X509_NAME_VALUE.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  SPC Indirect Data Content Data Attribute Values:
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  List of SPC Indirect Data Content Data Attribute Values are:
//      SPC_PE_IMAGE_DATA_OBJID
//      SPC_RAW_FILE_DATA_OBJID
//      SPC_JAVA_CLASS_DATA_OBJID
//      SPC_STRUCTURED_STORAGE_DATA_OBJID
//      SPC_CAB_DATA_OBJID
//  
//  These are the values can be currently added to SPC_INDIRECT_DATA_CONTENT
//  Data field.
//
//  SPC_LINK value types.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\signer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signer.h
//
//  Contents:   Digital Signing APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------

#ifndef SIGNER_H
#define SIGNER_H



#ifdef __cplusplus
extern "C" {
#endif	 

//-------------------------------------------------------------------------
//
//	Struct to define the file to sign and/or timestamp
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_FILE_INFO
{
	DWORD		cbSize;					//Required: should be set to sizeof(SIGNER_FILE_INFO)
	LPCWSTR		pwszFileName;			//Required: name of the file.  
    HANDLE      hFile;                  //Optional: open handle to pwszFileName. If hFile is set
										//			to values other than NULL or INVALID_HANDLE_VALUE,
										//			this handle is used for access the file	instead of pwszFileName
}SIGNER_FILE_INFO, *PSIGNER_FILE_INFO;


//-------------------------------------------------------------------------
//
//	Struct to define the BLOB to sign and/or timestamp
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_BLOB_INFO
{
	DWORD				cbSize;				//Required: should be set to sizeof(SIGNER_BLOB_INFO)
	GUID                *pGuidSubject;      //Required: Idenfity the sip functions to load
    DWORD               cbBlob;				//Required: the size of BLOB, in bytes
    BYTE                *pbBlob;			//Required: the pointer to the BLOB
    LPCWSTR             pwszDisplayName;    //Optional: the display name of the BLOB
}SIGNER_BLOB_INFO, *PSIGNER_BLOB_INFO;
			
//-------------------------------------------------------------------------
//
//	Struct to define the subject to sign and/or timestamp
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_SUBJECT_INFO
{
	DWORD					cbSize;				//Required: should be set to sizeof(SIGNER_SUBJECTINFO)
	DWORD					*pdwIndex;			//Required: 0 based index of the signature
                                                //          Currently, only 0 is supported
	DWORD					dwSubjectChoice;	//Required:	indicate whether to the subject is a file
												//			or a memory BLOB.  Can be either SIGNER_SUBJECT_FILE
												//			or SIGNER_SUBJECT_BLOB
	union
	{
		SIGNER_FILE_INFO	*pSignerFileInfo;	//Required if dwSubjectChoice==SIGNER_SUBJECT_FILE
		SIGNER_BLOB_INFO	*pSignerBlobInfo;	//Required if dwSubhectChoice==SIGNER_SUBJECT_BLOB
	};

}SIGNER_SUBJECT_INFO, *PSIGNER_SUBJECT_INFO;

#define	SIGNER_SUBJECT_FILE		0x01
#define	SIGNER_SUBJECT_BLOB		0x02

//-------------------------------------------------------------------------
//
//	Struct to define attributes of the signature for authenticode
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_ATTR_AUTHCODE
{
	DWORD				cbSize;			//Required: should be set to sizeof(SIGNER_ATTR_AUTHCODE)
	BOOL				fCommercial;	//Required:	whether to sign the document as a commercial publisher
	BOOL				fIndividual;	//Required: whether to sign the document as an individual publisher
										//			if both fCommercial and fIndividual are FALSE,
										//			the document will be signed with certificate's highest capabitlity
	LPCWSTR				pwszName;		//Optional: the display name of the file upon download time
	LPCWSTR				pwszInfo;		//Optional: the display information(URL) of the file upon download time
}SIGNER_ATTR_AUTHCODE, *PSIGNER_ATTR_AUTHCODE;


//-------------------------------------------------------------------------
//
//	Struct to define the signature information
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_SIGNATURE_INFO
{
	DWORD					cbSize;				//Required: should be set to sizeof(SIGNER_SIGNATURE_INFO)
	ALG_ID					algidHash;			//Required: the hashing algorithm for signature
	DWORD					dwAttrChoice;		//Required: indicate the predefined attributes of the signature
												//			can be either SIGNER_NO_ATTR or SIGNER_AUTHCODE_ATTR
	union
	{
		SIGNER_ATTR_AUTHCODE *pAttrAuthcode;	//Optional: should be set if dwAttrChoide==SIGNER_AUTHCODE_ATTR 
												//			pre-defined attributes added to the signature
												//			Those attributes are related to authenticode
	};

	PCRYPT_ATTRIBUTES		psAuthenticated;	//Optional: user supplied authenticated attributes added to the signature
	PCRYPT_ATTRIBUTES		psUnauthenticated;	//Optional:	user supplied unauthenticated attributes added to the signature
}SIGNER_SIGNATURE_INFO, *PSIGNER_SIGNATURE_INFO;

//dwAttrChoice should be one of the following:
#define  SIGNER_NO_ATTR			0x00
#define  SIGNER_AUTHCODE_ATTR	0x01

//-------------------------------------------------------------------------
//
//	Struct to define the cryptographic secutiry provider(CSP) and
//  private key information
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_PROVIDER_INFO
{
	DWORD					cbSize;				//Required: should be set of sizeof(SIGNER_PROVIDER_INFO)
	LPCWSTR					pwszProviderName;	//Required: the name of the CSP	provider.  NULL means default provider
	DWORD					dwProviderType;		//Required: the provider type.  
	DWORD					dwKeySpec;			//Required: the specification of the key.  This value can be set to 0,
												//        	which means using the same key specification as in the 
												//			private key file or keyContainer.  If there are more than
												//			one key specification in the keyContainer, we will try
												//			AT_SIGNATURE, if it fails, try AT_KEYEXCHANGE.
	DWORD					dwPvkChoice;		//Required: indicate the private key information
												//			either PVK_TYPE_FILE_NAME or PVK_TYPE_KEYCONTAINER
	union
	{
		LPWSTR				pwszPvkFileName;	//Required if dwPvkChoice==PVK_TYPE_FILE_NAME
		LPWSTR				pwszKeyContainer;	//Required if dwPvkChoice==PVK_TYPE_KEYCONTAINER
	};
	
}SIGNER_PROVIDER_INFO, *PSIGNER_PROVIDER_INFO;


//dwPvkChoice in SIGNER_PKV_INFO should be one of the following:
#define	PVK_TYPE_FILE_NAME				0x01
#define	PVK_TYPE_KEYCONTAINER			0x02

//-------------------------------------------------------------------------
//
//	Struct to define the SPC file and certificate chain used to sign the document
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_SPC_CHAIN_INFO
{
	DWORD					cbSize;					//Required: should be set to sizeof(SIGNER_SPC_CHAIN_INFO)
	LPCWSTR					pwszSpcFile;	        //Required: the name of the CSP file to use 
	DWORD					dwCertPolicy;			//Required:	the policy of adding certificates to the signature:
													//			it can be set with one of the following the following flag:
													//			SIGNER_CERT_POLICY_CHAIN:           add only the certs in the cert chain
													//			SIGNER_CERT_POLICY_CHAIN_NO_ROOT:   add only the certs in the cert chain, excluding the root certificate
                                                    //
                                                    //          The following flag can be Ored with any of the above flags:
													//			SIGNER_CERT_POLICY_STORE: add all the certs in hCertStore 
													//			
                                                    //          When we search for the certificate chain, we search
													//			MY, CA, ROOT, SPC store, and also hCertStore if it is set.
	HCERTSTORE				hCertStore;				//Optional: additional certificate store.
}SIGNER_SPC_CHAIN_INFO, *PSIGNER_SPC_CHAIN_INFO;

//-------------------------------------------------------------------------
//
//	Struct to define the certificate store used to sign the document
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_CERT_STORE_INFO
{
	DWORD					cbSize;					//Required: should be set to sizeof(SIGNER_CERT_STORE_INFO)
	PCCERT_CONTEXT			pSigningCert;			//Required: the signing certificate context
	DWORD					dwCertPolicy;			//Required:	the policy of adding certificates to the signature:
													//			it can be set with one of the following the following flag:
													//			SIGNER_CERT_POLICY_CHAIN:           add only the certs in the cert chain
													//			SIGNER_CERT_POLICY_CHAIN_NO_ROOT:   add only the certs in the cert chain, excluding the root certificate
                                                    //
                                                    //          The following flag can be Ored with any of the above flags:
													//			SIGNER_CERT_POLICY_STORE: add all the certs in hCertStore 
													//			
	HCERTSTORE				hCertStore;				//Optional: additional certificate store.
}SIGNER_CERT_STORE_INFO, *PSIGNER_CERT_STORE_INFO;

//dwCertPolicy in SIGNER_CERT_STORE_INFO should be ORed with the following flags:
#define	SIGNER_CERT_POLICY_STORE			0x01
#define	SIGNER_CERT_POLICY_CHAIN			0x02
#define	SIGNER_CERT_POLICY_SPC				0x04
#define SIGNER_CERT_POLICY_CHAIN_NO_ROOT    0x08

//-------------------------------------------------------------------------
//
//	Struct to define the certificate used to sign the docuemnt.  The
//	certificate can be in a SPC file, or in a cert store.
//
//-------------------------------------------------------------------------
typedef struct _SIGNER_CERT
{
	DWORD						cbSize;			 //Required: should be set to sizeof(SIGNER_CERT)
	DWORD						dwCertChoice;	 //Required: Can be set to one of the following:
                                                 //         SIGNER_CERT_SPC_FILE 
                                                 //         SIGNER_CERT_STORE 
                                                 //         SIGNER_CERT_SPC_CHAIN
	union
	{
		LPCWSTR					pwszSpcFile;	 //Required if dwCertChoice==SIGNER_CERT_SPC_FILE.
												 //			the name of the spc file to use
		SIGNER_CERT_STORE_INFO	*pCertStoreInfo; //Required if dwCertChoice==SIGNER_CERT_STORE
												 //          the certificate store to use
        SIGNER_SPC_CHAIN_INFO   *pSpcChainInfo;  //Required if dwCertChoice==SIGNER_CERT_SPC_CHAIN
                                                 //         the name of the spc file and the cert chain
	};
	HWND						hwnd;			 //Optional: The optional window handler for promting user for 
												 //			 password of the private key information.  NULL means
												 //			 default window
}SIGNER_CERT, *PSIGNER_CERT;

//dwCertChoice in SIGNER_CERT_INFO should be one of the following
#define	SIGNER_CERT_SPC_FILE	0x01
#define	SIGNER_CERT_STORE		0x02
#define SIGNER_CERT_SPC_CHAIN   0x03

//-------------------------------------------------------------------------
//
//	The signed blob
//
//-------------------------------------------------------------------------
typedef struct  _SIGNER_CONTEXT
{
    DWORD                       cbSize;         
    DWORD                       cbBlob;
    BYTE                        *pbBlob;
}SIGNER_CONTEXT, *PSIGNER_CONTEXT;

//+-----------------------------------------------------------------------
//  
//  SignerSign:
//		Sign and/or timestamp a file.
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSign(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be signed and/or timestamped 
IN	SIGNER_CERT				*pSignerCert,		//Required: The signing certificate to use
IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,	//Required: The signature information during signing process
IN	SIGNER_PROVIDER_INFO	*pProviderInfo,		//Optional:	The crypto security provider to use.
												//			This parameter has to be set unless
												//			certStoreInfo is set in *pSignerCert
												//			and the signing certificate has provider
												//			information associated with it
IN  LPCWSTR					pwszHttpTimeStamp,	//Optional: Timestamp server http address.  If this parameter
												//			is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES		psRequest,			//Optional: Attributes added to Time stamp request. Ignored
												//			unless pwszHttpTimeStamp is set   
IN	LPVOID					pSipData			//Optional: The additional data passed to sip funcitons
);									

//+-----------------------------------------------------------------------
//  
//  SignerSignEx:
//		Sign and/or timestamp a file.  This function is the same as SignerSign with
//      exception of the out put parameter ppSignerContext
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSignEx(
IN  DWORD                   dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be signed and/or timestamped 
IN	SIGNER_CERT				*pSignerCert,		//Required: The signing certificate to use
IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,	//Required: The signature information during signing process
IN	SIGNER_PROVIDER_INFO	*pProviderInfo,		//Optional:	The crypto security provider to use.
												//			This parameter has to be set unless
												//			certStoreInfo is set in *pSignerCert
												//			and the signing certificate has provider
												//			information associated with it
IN  LPCWSTR					pwszHttpTimeStamp,	//Optional: Timestamp server http address.  If this parameter
												//			is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES		psRequest,			//Optional: Attributes added to Time stamp request. Ignored
												//			unless pwszHttpTimeStamp is set   
IN	LPVOID					pSipData,			//Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext   //Optional: The signed BLOB.  User has to free
                                                //          the context via SignerFreeSignerContext
);									

//+-----------------------------------------------------------------------
//  
//  SignerFreeSignerContext:
//     
//------------------------------------------------------------------------
HRESULT WINAPI
SignerFreeSignerContext(
IN  SIGNER_CONTEXT          *pSignerContext     //Required: The signerContext to free
);


//+-----------------------------------------------------------------------
//  
//  SignerTimeStamp:
//		Timestamp a file.  
//     
//------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStamp(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be timestamped 
IN  LPCWSTR					pwszHttpTimeStamp,	// Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES		psRequest,			// Optional, attributes added to the timestamp 
IN	LPVOID					pSipData			// Optional: The additional data passed to sip funcitons
);					

//+-----------------------------------------------------------------------
//  
//  SignerTimeStampEx:
//		Timestamp a file.  This function is the same as SignerTimeStamp with
//      exception of the out put parameter ppSignerContext
//     
//------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStampEx(
IN  DWORD                   dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be timestamped 
IN  LPCWSTR					pwszHttpTimeStamp,	// Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES		psRequest,			// Optional, attributes added to the timestamp 
IN	LPVOID					pSipData,			// Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext   // Optional: The signed BLOB.  User has to free
                                                //          the context via SignerFreeSignerContext
);					


//+-----------------------------------------------------------------------
//  
//  SignerCreateTimeStampRequest:
//		Create a timestamp request for a file.
//
//		If pbTimestampRequest==NULL, *pcbTimeStampRequest is the size of 
//		the timestampRequest, in bytes.  
//     
//------------------------------------------------------------------------
HRESULT WINAPI 
SignerCreateTimeStampRequest(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
IN  PCRYPT_ATTRIBUTES		psRequest,			// Optional: attributes added to Time stamp request 
IN	LPVOID					pSipData,			// Optional: The additional data passed to sip funcitons
OUT PBYTE					pbTimeStampRequest,	// Required: buffer to receive the timestamp request BLOB
IN OUT DWORD*				pcbTimeStampRequest	// Required: the number of bytes of the timestamp request BLOB
);


//+-----------------------------------------------------------------------
//  
//   SignerAddTimeStampResponse:
//		Add the timestamp response from the timestamp server to a signed file. 
//     
//------------------------------------------------------------------------

HRESULT WINAPI
SignerAddTimeStampResponse(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
IN	PBYTE					pbTimeStampResponse,	//Required: the timestamp response BLOB
IN	DWORD					cbTimeStampResponse,	//Required: the size of the tiemstamp response BLOB
IN	LPVOID					pSipData				//Optional: The additional data passed to sip funcitons
);


//+-----------------------------------------------------------------------
//  
//   SignerAddTimeStampResponseEx:
//		Add the timestamp response from the timestamp server to a signed file. 
//      This function is the same as SignerTimeStamp with
//      exception of the out put parameter ppSignerContext
//------------------------------------------------------------------------

HRESULT WINAPI
SignerAddTimeStampResponseEx(
IN  DWORD                   dwFlags,                //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
IN	PBYTE					pbTimeStampResponse,	//Required: the timestamp response BLOB
IN	DWORD					cbTimeStampResponse,	//Required: the size of the tiemstamp response BLOB
IN	LPVOID					pSipData,				//Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext       // Optional: The signed BLOB.  User has to free
                                                    //          the context via SignerFreeSignerContext
);


#ifdef __cplusplus
}
#endif

#endif  // SIGNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\sgnerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sgnerror.h
//
//--------------------------------------------------------------------------

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: SPC_BAD_PARAMETER
//
// MessageText:
//
//  Bad parameter for spc utility
//
#define SPC_BAD_PARAMETER                0x80096001L

//
// MessageId: SPC_BAD_LENGTH
//
// MessageText:
//
//  Bad length for data
//
#define SPC_BAD_LENGTH                   0x80096002L

//
// MessageId: SPC_BAD_CONTENT_DATA_ATTR
//
// MessageText:
//
//  SPC Message contained corrupted content
//
#define SPC_BAD_CONTENT_DATA_ATTR        0x80096003L

//
// MessageId: SPC_BAD_INDIRECT_CONTENT_TYPE
//
// MessageText:
//
//  SPC Message did not contain indirect data type
//
#define SPC_BAD_INDIRECT_CONTENT_TYPE    0x80096004L

//
// MessageId: SPC_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
//  Message contains an unexpected content type
//
#define SPC_UNEXPECTED_MSG_TYPE          0x80096005L

//
// MessageId: SPC_NOT_JAVA_CLASS_FILE
//
// MessageText:
//
//  File is not a java class file
//
#define SPC_NOT_JAVA_CLASS_FILE          0x80096006L

//
// MessageId: SPC_BAD_JAVA_CLASS_FILE
//
// MessageText:
//
//  File is a corrupted java class file
//
#define SPC_BAD_JAVA_CLASS_FILE          0x80096007L

//
// MessageId: SPC_BAD_STRUCTURED_STORAGE
//
// MessageText:
//
//  Structured file is corrupted
//
#define SPC_BAD_STRUCTURED_STORAGE       0x80096008L

//
// MessageId: SPC_BAD_CAB_FILE
//
// MessageText:
//
//  File is a corrupted CAB file
//
#define SPC_BAD_CAB_FILE                 0x80096009L

//
// MessageId: SPC_NO_SIGNED_DATA_IN_FILE
//
// MessageText:
//
//  No signed message was found in file
//
#define SPC_NO_SIGNED_DATA_IN_FILE       0x8009600AL

//
// MessageId: SPC_REVOCATION_OFFLINE
//
// MessageText:
//
//  Could not connect to online revocation server.
//
#define SPC_REVOCATION_OFFLINE           0x8009600BL

//
// MessageId: SPC_REVOCATION_ERROR
//
// MessageText:
//
//  An error occured while accessing online revocation server.
//
#define SPC_REVOCATION_ERROR             0x8009600CL

//
// MessageId: SPC_CERT_REVOKED
//
// MessageText:
//
//  Signing certificate or issuing certifcate has been revoked.
//
#define SPC_CERT_REVOKED                 0x8009600DL

//
// MessageId: SPC_NO_SIGNATURE
//
// MessageText:
//
//  AUTHENTICODE signature not found.
//
#define SPC_NO_SIGNATURE                 0x8009600EL

//
// MessageId: SPC_BAD_SIGNATURE
//
// MessageText:
//
//  The signature does not match the content of the signed message.
//
#define SPC_BAD_SIGNATURE                0x8009600FL

//
// MessageId: SPC_BAD_FILE_DIGEST
//
// MessageText:
//
//  Software does not match contents of signature.
//
#define SPC_BAD_FILE_DIGEST              0x80096010L

//
// MessageId: SPC_NO_VALID_SIGNER
//
// MessageText:
//
//  Signature does not contain a valid signing certifcate.
//
#define SPC_NO_VALID_SIGNER              0x80096011L

//
// MessageId: SPC_CERT_EXPIRED
//
// MessageText:
//
//  A certificate (signing or issuer) has expired.
//
#define SPC_CERT_EXPIRED                 0x80096012L

//
// MessageId: SPC_NO_SIGNER_ROOT
//
// MessageText:
//
//  The signing certificate did not have a valid root certificate.
//
#define SPC_NO_SIGNER_ROOT               0x80096013L

//
// MessageId: SPC_NO_STATEMENT_TYPE
//
// MessageText:
//
//  Signing certificate does not contain AUTHENTICODE extensions.
//
#define SPC_NO_STATEMENT_TYPE            0x80096014L

//
// MessageId: SPC_NO_COMMERCIAL_TYPE
//
// MessageText:
//
//  No commercial or individual setting in signing certificate.
//
#define SPC_NO_COMMERCIAL_TYPE           0x80096015L

//
// MessageId: SPC_INVALID_CERT_NESTING
//
// MessageText:
//
//  Signing certificate's starting or ending time is outside one of its issuers starting or ending time.
//
#define SPC_INVALID_CERT_NESTING         0x80096016L

//
// MessageId: SPC_INVALID_ISSUER
//
// MessageText:
//
//  Wrong issuing Certificate used to verify a certificate.
//
#define SPC_INVALID_ISSUER               0x80096017L

//
// MessageId: SPC_INVALID_PURPOSE
//
// MessageText:
//
//  A purpose specified in a certificate (signing or issuer) makes it invalid for AUTHENTICODE.
//
#define SPC_INVALID_PURPOSE              0x80096018L

//
// MessageId: SPC_INVALID_BASIC_CONSTRAINTS
//
// MessageText:
//
//  A basic contraint of a certificate in the signature failed for AUTHENTICODE.
//
#define SPC_INVALID_BASIC_CONSTRAINTS    0x80096019L

//
// MessageId: SPC_UNSUPPORTED_BASIC_CONSTRAINTS
//
// MessageText:
//
//  Unsupported basic contraint found in a certificate used by the signature.
//
#define SPC_UNSUPPORTED_BASIC_CONSTRAINTS 0x8009601AL

//
// MessageId: SPC_NO_OPUS_INFO
//
// MessageText:
//
//  No opus information provided for the signing certificate.
//
#define SPC_NO_OPUS_INFO                 0x8009601BL

//
// MessageId: SPC_INVALID_CERT_TIME
//
// MessageText:
//
//  The date for the signing certificate is not valid.
//
#define SPC_INVALID_CERT_TIME            0x8009601CL

//
// MessageId: SPC_UNTRUSTED_TIMESTAMP_ROOT
//
// MessageText:
//
//  The test root is not trusted as the time stamp root.
//
#define SPC_UNTRUSTED_TIMESTAMP_ROOT     0x8009601DL

//
// MessageId: SPC_INVALID_FINANCIAL
//
// MessageText:
//
//  Certificate does not contain AUTHENTICODE financial extension.
//
#define SPC_INVALID_FINANCIAL            0x8009601EL

//
// MessageId: SPC_NO_AUTHORITY_KEYID
//
// MessageText:
//
//  No authority key id extension in certificate.
//
#define SPC_NO_AUTHORITY_KEYID           0x8009601FL

//
// MessageId: SPC_INVALID_EXTENSION
//
// MessageText:
//
//  The extension in a certificate means the certificate can not be used for AUTHENTICODE.
//
#define SPC_INVALID_EXTENSION            0x80096020L

//
// MessageId: SPC_CERT_SIGNATURE
//
// MessageText:
//
//  Certificate signature could not be verified using issuers certificate.
//
#define SPC_CERT_SIGNATURE               0x80096021L

//
// MessageId: SPC_CHAINING
//
// MessageText:
//
//  Unable to create certificate chain from the signing certificate to a root.
//
#define SPC_CHAINING                     0x80096022L

//
// MessageId: SPC_UNTRUSTED
//
// MessageText:
//
//  Signature is not trusted by AUTHENTICODE.
//
#define SPC_UNTRUSTED                    0x80096023L

//
// MessageId: SPC_SAFETY_LEVEL_UNTRUSTED
//
// MessageText:
//
//  Signature is not trusted by AUTHENTICODE at this safety level.
//
#define SPC_SAFETY_LEVEL_UNTRUSTED       0x80096024L

//
// MessageId: SPC_UNTRUSTED_ROOT
//
// MessageText:
//
//  The test root is has not been enabled as a trusted root.
//
#define SPC_UNTRUSTED_ROOT               0x80096025L

//
// MessageId: SPC_UNKNOWN_SIGNER_ROOT
//
// MessageText:
//
//  Verified chain to an unknown root certificate.
//
#define SPC_UNKNOWN_SIGNER_ROOT          0x80096026L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\signutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       signutil.h
//
//--------------------------------------------------------------------------

#ifndef _SIGNUTIL_H
#define _SIGNUTIL_H

// OBSOLETE :- Was used for signcde.dll that is no longer required
//---------------------------------------------------------------------
//---------------------------------------------------------------------

// SignCode.h : main header file for the SIGNCODE application
//

#include "wincrypt.h"
#include "ossglobl.h"
#include "sgnerror.h"
#include "spcmem.h"
#include "pvkhlpr.h"
#include "spc.h"

#include "wintrust.h"
#include "sipbase.h"
#include "mssip.h"

#ifdef __cplusplus
extern "C" {
#endif

//
//+-------------------------------------------------------------------------
//  SPC_TIME_STAMP_REQUEST_STRUCT (placed in PKCS#7 Content for a time request)
//  pvStructInfo points to SPC_TIMESTAMP_REQ 
//
typedef struct _SPC_ContentInfo {
    LPCSTR            pszContentType;
    PBYTE             pbContentValue;
    DWORD             cbContentValue;
} SPC_CONTENT_INFO, *PSPC_CONTENT_INFO;


typedef struct _SPC_TimeStampRequest {
    LPCSTR             pszTimeStampAlg;
    DWORD             cAuthAttr;
    PCRYPT_ATTRIBUTE  rgAuthAttr;
    SPC_CONTENT_INFO  sContent;
} SPC_TIMESTAMP_REQ, *PSPC_TIMESTAMP_REQ;
//
//+-------------------------------------------------------------------------


//+------------------------------------------------------------------------------
// Certificate List structures. Ordered list of Certificate contexts
//
typedef struct CERT_CONTEXTLIST {
    PCCERT_CONTEXT* psList;   // List
    DWORD           dwCount;  // Number of entries in list
    DWORD           dwList;   // Max size of list
} CERT_CONTEXTLIST, *PCERT_CONTEXTLIST;
    
typedef const CERT_CONTEXTLIST *PCCERT_CONTEXTLIST;
    
//+------------------------------------------------------------------------------
// Crl List structures. Ordered list of Certificate contexts
//
typedef struct CRL_CONTEXTLIST {
    PCCRL_CONTEXT*  psList;   // List
    DWORD           dwCount;  // Number of entries in list
    DWORD           dwList;   // Max size of list
} CRL_CONTEXTLIST, *PCRL_CONTEXTLIST;
    
typedef const CRL_CONTEXTLIST *PCCRL_CONTEXTLIST;
    

//+------------------------------------------------------------------------------
// Capi Provider information structure (see SpcGetCapiProviders)
//
typedef struct CAPIPROV
    {
    TCHAR       szProviderName[MAX_PATH];
    TCHAR       szProviderDisplayName[MAX_PATH];
    DWORD       dwProviderType;
    } CAPIPROV;

//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
// Spc utility functions


//+-------------------------------------------------------------------------
//  Converts error (see GetLastError())  to an HRESULT
//--------------------------------------------------------------------------
HRESULT SpcError();

//+-------------------------------------------------------------------------
//  SPC PKCS #7 Indirect Data Content
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcGetSignedDataIndirect(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwMsgAndCertEncodingType,
    IN PBYTE pbSignedData,
    IN DWORD cbSignedData,
    OUT PSPC_INDIRECT_DATA_CONTENT pInfo,
    IN OUT DWORD *pcbInfo);

//+=========================================================================
//
// SPC PKCS #7 Signed Message Authenticated Attributes
//
//-=========================================================================

//+-------------------------------------------------------------------------
//  Create a SignedData message consisting of the certificates and
//  CRLs copied from the specified cert store and write to the specified file.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcWriteSpcFile(
    IN HANDLE hFile,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
//  Read a SignedData message consisting of certificates and
//  CRLs from the specified file and copy to the specified cert store.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcReadSpcFile(
    IN HANDLE hFile,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
//  Create a SignedData message consisting of the certificates and
//  CRLs copied from the specified cert store and write to memory
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error.
//
//  Except for the SPC being saved to memory, identical to SpcWriteSpcFile.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcWriteSpcToMemory(
    IN HANDLE hFile,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData);

//+-------------------------------------------------------------------------
//  Read a SignedData message consisting of certificates and
//  CRLs from memory and copy to the specified cert store.
//
//  Except for the SPC being loaded from memory, identical to SpcReadSpcFile.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcReadSpcFromMemory(
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFlags);

//+-------------------------------------------------------------------------
//  By default (according to the world of BOB) the SignedData doesn't have
//  the normal PKCS #7 ContentType at the beginning. Set the following
//  flag in the SpcSign* and SpcWriteSpcFile functions to include the
//  PKCS #7 ContentType.
//
//  The SpcVerify* functions take SignedData with or without the PKCS #7
//  ContentType.
//--------------------------------------------------------------------------
#define SPC_PKCS_7_FLAG                     0x00010000

//+-------------------------------------------------------------------------
//  Sign Portable Executable (PE) image file where the signed data is stored
//  in the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_PE_IMAGE_DATA_OBJID and its optional value is set to the
//  PeImageData parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignPeImageFile(IN PSPC_SIGN_PARA pSignPara,
                   IN HANDLE hFile,
                   IN OPTIONAL PSPC_PE_IMAGE_DATA pPeImageData,
                   IN DWORD dwFlags,
                   OUT PBYTE* pbEncoding,
                   OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify Portable Executable (PE) image file where the signed data is
//  extracted from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyPeImageFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert);

//+-------------------------------------------------------------------------
//  Sign Java class file where the signed data is stored in the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_JAVA_CLASS_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignJavaClassFile(IN PSPC_SIGN_PARA pSignPara,
                     IN HANDLE hFile,
                     IN OPTIONAL PSPC_LINK pLink,
                     IN DWORD dwFlags,
                     OUT PBYTE* pbEncoding,
                     OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify Java class file where the signed data is extracted from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyJavaClassFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert);

//+-------------------------------------------------------------------------
//  Sign Structured Storage file where the signed data is stored in the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_STRUCTURED_STORAGE_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignStructuredStorageFile(IN PSPC_SIGN_PARA pSignPara,
                             IN IStorage *pStg,
                             IN OPTIONAL PSPC_LINK pLink,
                             IN DWORD dwFlags,
                             OUT PBYTE* pbEncoding,
                             OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify Structured Storage file where the signed data is extracted
//  from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyStructuredStorageFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN IStorage *pStg,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Sign Raw file. The signed data is stored OUTSIDE of the file.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_RAW_FILE_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  If pbSignedData == NULL or *pcbSignedData == 0, then, the
//  SPC_LENGTH_ONLY_FLAG and SPC_DISABLE_DIGEST_FILE_FLAG are implicitly set.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignRawFile(IN PSPC_SIGN_PARA pSignPara,
               IN HANDLE hFile,
               IN OPTIONAL PSPC_LINK pLink,
               IN DWORD dwFlags,
               OUT PBYTE *pbSignedData,
               IN OUT DWORD *pcbSignedData);

//+-------------------------------------------------------------------------
//  Verify Raw file. The signed data is stored OUTSIDE of the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyRawFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN const BYTE *pbSignedData,
    IN DWORD cbSignedData,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  Sign Diamond Cabinet (.cab) file where the signed data is stored in the
//  the file's cabinet header reserved data space.
//
//  The signed data's IndirectDataContentAttr is updated with its type set to
//  SPC_CAB_DATA_OBJID and its optional value is set to the
//  Link parameter.
//
//  The SPC_LENGTH_ONLY_FLAG or SPC_DISABLE_DIGEST_FILE_FLAG isn't allowed
//  and return an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcSignCabFile(IN PSPC_SIGN_PARA pSignPara,
               IN HANDLE hFile,
               IN OPTIONAL PSPC_LINK pLink,
               IN DWORD dwFlags,
               OUT PBYTE* pbEncoding,
               OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify cabinet file where the signed data is extracted from the file.
//
//  See SpcVerifyFile for details about the other parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyCabFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN HANDLE hFile,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert);

//+=========================================================================
//
//  SPC Sign and Verify File APIs and Type Definitions
//
//  Supports any file type via a table of functions for accessing the file.
//  The above file types have been implemented on top of these
//  sign and verify file APIs.
//
//-=========================================================================




//+-------------------------------------------------------------------------
// A convient way of setting up the SPC dll and loading the oid encode and decode
// routines.  Not a required call!
//
// Returns: 
//    E_OUTOFMEMORY - unable to set up dll
//    S_OK

HRESULT WINAPI 
SpcInitialize(DWORD dwEncodingType, // Defaults to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
              SpcAlloc*);           // Defaults to no memory allocator

HRESULT WINAPI 
SpcInitializeStd(DWORD dwEncodingType); // Defaults to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
                                        // Sets memory to LocalAlloc and LocalFree.

////////////////////////////////////
// Helper functions

/////////////////////////////////////////////////////////////////////////////
// Time Stamping structures
typedef struct _SPC_SignerInfo {
    DWORD                         dwVersion;
    CRYPT_INTEGER_BLOB            sSerialNumber;
    CERT_NAME_BLOB                sIssuer;
    PCRYPT_ALGORITHM_IDENTIFIER   psDigestEncryptionAlgorithm;
    PCRYPT_ALGORITHM_IDENTIFIER   psDigestAlgorithm;
    DWORD                         cAuthAttr;
    PCRYPT_ATTRIBUTE              rgAuthAttr;
    DWORD                         cUnauthAttr;
    PCRYPT_ATTRIBUTE              rgUnauthAttr;
    PBYTE                         pbEncryptedDigest;
    DWORD                         cbEncryptedDigest;
} SPC_SIGNER_INFO, *PSPC_SIGNER_INFO;

//+------------------------------------------------------------------------------
// Checks if the certificate is self signed. 
// Returns: S_FALSE                - certificate is not self signed
//          NTE_BAD_SIGNATURE      - self signed certificate but signature is invalid
//          S_OK                   - certificate is self signed and signature is valid
//          CRYPT_E_NO_PRVOIDER    - no provider supplied
//
HRESULT WINAPI
SpcSelfSignedCert(IN HCRYPTPROV hCryptProv,
                  IN PCCERT_CONTEXT pSubject);

//+-----------------------------------------------------------------------------------
//  Checks if the certificate is the Microsoft real root or one of the test roots used
//  in IE30
//  Returns: S_OK                   - For the Microsoft root
//           S_FALSE                - For the Microsoft test root
//           CRYPT_E_NOT_FOUND       - When it is not a root certificate
//
HRESULT WINAPI
SpcIsRootCert(PCCERT_CONTEXT pSubject);

//+---------------------------------------------------------------------------
//  Checks if the certificate a glue certificate
//  in IE30
//  Returns: S_OK                   - Is a glue certificate
//           S_FALSE                - Not a certificate
//           CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcIsGlueCert(IN PCCERT_CONTEXT pCert);

//+--------------------------------------------------------------------
// Gets the list of providers, pass in the address to a CAPIPROV
// structer and a long.
//  ppsList - Vector of CAPIPROV (free pointer using the SpcAllocator)
//  pdwEntries - number of entries in the vector.
//----------------------------------------------------------------------

HRESULT WINAPI 
SpcGetCapiProviders(CAPIPROV** ppsList, 
                    DWORD* pdwEntries);


//+-------------------------------------------------------------------
// Checks the certifcate chain based on trusted roots then on glue certs
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using trusted roots
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcCheckTrustStore(IN HCRYPTPROV hCryptProv,
                   IN DWORD dwVerifyFlags,
                   IN OPTIONAL FILETIME*  pTimeStamp,
                   IN HCERTSTORE hCertStore,
                   IN PCCERT_CONTEXT pChild,
                   IN OPTIONAL PCCERT_CONTEXTLIST,
                   OUT PCCERT_CONTEXT* pRoot);

//+---------------------------------------------------------------------------
// Checks the certifcate by finding a glue certificate and walking that chain
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using store
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcCheckGlueChain(IN HCRYPTPROV hCryptProv,
                  IN DWORD dwVerifyFlags,
                  IN OPTIONAL FILETIME*  pTimeStamp,
                  IN HCERTSTORE hCertStore,
                  IN OPTIONAL PCCERT_CONTEXTLIST pIssuers,
                  IN PCCERT_CONTEXT pChild);

//+-------------------------------------------------------------------
// Checks the certifcate chain based on trusted roots then on glue certs
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using trusted roots
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcCheckCertChain(IN HCRYPTPROV hCryptProv,
                  IN DWORD dwVerifyFlags,
                  IN OPTIONAL FILETIME* pTimeStamp,
                  IN HCERTSTORE hTrustedRoots,
                  IN HCERTSTORE hCertStore,
                  IN PCCERT_CONTEXT pChild,
                  IN OPTIONAL PCCERT_CONTEXTLIST hChainStore,
                  OUT PCCERT_CONTEXT* pRoot); 


//+--------------------------------------------------------------------------
// Sign a file, optional supply a timestamp. 
//
// Returns:
//
// NOTE: By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to 
// specify a different memory model.
// NOTE: Time Stamp must be an encoded pkcs7 message.

HRESULT WINAPI 
SpcSignCode(IN  HWND    hwnd,
         IN  LPCWSTR pwszFilename,       // file to sign
         IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
         IN  DWORD   dwProviderType,     // Uses default if 0
         IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
         IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
         IN  LPCWSTR pwszOpusName,       // the name of the program to appear in
         IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more
         IN  BOOL    fIncludeCerts,      // add the certificates to the signature
         IN  BOOL    fCommercial,        // commerical signing
         IN  BOOL    fIndividual,        // individual signing
         IN  ALG_ID  algidHash,          // Algorithm id used to create digest
         IN  PBYTE   pbTimeStamp,        // Optional
         IN  DWORD   cbTimeStamp );      // Optional
    
//+--------------------------------------------------------------------------
// Create a time stamp request. It does not actually sign the file.
//
// Returns:
//
// NOTE: By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to 
// specify a different memory model.

HRESULT WINAPI 
SpcTimeStampCode(IN  HWND    hwnd,
              IN  LPCWSTR pwszFilename,       // file to sign
              IN  LPCWSTR pwszCapiProvider,   // NULL if to use non default CAPI provider
              IN  DWORD   dwProviderType,
              IN  LPCWSTR pwszPrivKey,        // private key file / CAPI key set name
              IN  LPCWSTR pwszSpc,            // the credentials to use in the signing
              IN  LPCWSTR pwszOpusName,       // the name of the program to appear in the UI
              IN  LPCWSTR pwszOpusInfo,       // the unparsed name of a link to more info...
              IN  BOOL    fIncludeCerts,
              IN  BOOL    fCommercial,
              IN  BOOL    fIndividual,
              IN  ALG_ID  algidHash,
              OUT  PCRYPT_DATA_BLOB sTimeRequest);   // Returns result in sTimeRequest 

//+-------------------------------------------------------------------------
//  Crack a PKCS7 message and builds an encoded response. Store should
//  contain all the required certificates to crack the incoming message
//  and build the out going message.
//  Input:
//      pbEncodedMsg - encoded time stamp request.
//      cbEncodedMsg - length of time stamp request.
//
//  Parameter Returns:
//      pbResponse - allocated response message containing the time stamp
//      cbResponse - length of response
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
//      CRYPT_E_NO_MATCH - could not locate certificate in store
     
HRESULT WINAPI
SpcCreateTimeStampResponse(IN DWORD dwCertEncodingType,
                           IN HCRYPTPROV hSignProv,
                           IN HCERTSTORE hCertStore,
                           IN DWORD dwAlgId,
                           IN OPTIONAL FILETIME* pFileTime,
                           IN PBYTE pbEncodedMsg,
                           IN DWORD cbEncodedMsg,
                           OUT PBYTE* pbResponse,
                           OUT DWORD* cbResponse);


//+-------------------------------------------------------------------------
//  Creates PKCS7 message using the information supplied
//  Parameter Returns:
//      pbPkcs7 - allocated pkcs7 message containing the time stamp
//      cbPkcs7 - length of pkcs7
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
     
HRESULT WINAPI
SpcCreatePkcs7(IN DWORD dwCertEncodingType,
              IN HCRYPTPROV hCryptProv,    // if Null it will get provider from signing certificate
              IN DWORD dwKeySpec,          // if 0 it will get signing key type from signing certificate
              IN PCCERT_CONTEXT pSigningCert,
              IN CRYPT_ALGORITHM_IDENTIFIER dwDigestAlgorithm,
              IN OPTIONAL PCCERT_CONTEXTLIST pCertList,
              IN OPTIONAL PCRL_CONTEXTLIST pCrlList,
              IN OPTIONAL PCRYPT_ATTRIBUTE rgAuthAttr,  
              IN OPTIONAL DWORD cAuthAttr,
              IN OPTIONAL PCRYPT_ATTRIBUTE rgUnauthAttr,
              IN OPTIONAL DWORD cUnauthAttr,
              IN LPCSTR pszContentType,
              IN PBYTE pbSignerData,
              IN DWORD cbSignerData,
              OUT PBYTE* pbPkcs7,
              OUT DWORD* pcbPkcs7);

//+--------------------------------------------------------------------------
// Retrieve the signature from an encoded PKCS7 message. 
// 
// Returns:
//
// Note: Returns the signature of the first signer.
    
HRESULT WINAPI
SpcGetSignature(IN PBYTE pbMessage,               // Pkcs7 Message
                IN DWORD cbMessage,               // length of Message
                OUT PCRYPT_DATA_BLOB);            // Signature returned.
    
//+--------------------------------------------------------------------------
// Returns the content value from within a timestamp request. 
// 
// Returns:
//     S_OK - Success
//
// Note:  By default this will use CoTaskMemAlloc. Use CryptSetMemoryAlloc() to specify 
//        a different allocation routine
    
HRESULT WINAPI
SpcGetTimeStampContent(IN PBYTE pbEncoding,               // Pkcs7 Message
                    IN DWORD cbEncoding,               // length of Message
                    OUT PCRYPT_DATA_BLOB pSig);        // Time Stamped Data 

//+--------------------------------------------------------------------------
// Returns: the type of file
// 
// Note: See defines for the type returned
DWORD WINAPI
SpcGetFileType(LPCWSTR pszFile);

#define SIGN_FILE_IMAGE 1
#define SIGN_FILE_JAVACLASS 2
#define SIGN_FILE_RAW 4
#define SIGN_FILE_CAB 8



//+---------------------------------------------------------------
//+---------------------------------------------------------------
// SignCode Internal OID's and structurs
// Global values
#define EMAIL_OID                  "1.2.840.113549.1.9.1"
// Not implemented
#define CONTENT_TYPE_OID           "1.2.840.113549.1.9.3"
// Uses a LPSTR
#define MESSAGE_DIGEST_OID         "1.2.840.113549.1.9.4"
// Not implemented
#define SIGNING_TIME_OID           "1.2.840.113549.1.9.5"
// Structure passed in and out is FILETIME
#define COUNTER_SIGNATURE_OID      "1.2.840.113549.1.9.6"
// Not implemented
#define DIRECTORY_STRING_OID       "2.5.4.4"
// Not implemented (see Printable and Wide versions below)


// OID functions
#define OID_BASE                           101
#define TIMESTAMP_REQUEST_SPCID            101
// Uses TimeStampRequest structure
#define WIDE_DIRECTORY_STRING_SPCID        102
// Structure is LPWSTR
#define PRINTABLE_DIRECTORY_STRING_SPCID   103
// Structure is LPSTR
#define IA5_STRING_SPCID                   104
// Structure is LPSTR
#define OCTET_STRING_SPCID                 105
// Structure is CRYPT_DATA_BLOB
#define CONTENT_INFO_SPCID                 106
// Structure is SPC_CONTENT_INFO
#define SIGNING_TIME_SPCID                 107
// Structure is a SPC_SIGNER_INFO
#define SIGNER_INFO_SPCID                  108
// Structure is a SPC_SIGNER_INFO
#define ATTRIBUTES_SPCID                   109
// Structure is a CMSG_ATTR 
#define OBJECTID_SPCID                     110
// Structure is a LPTSTR
#define CONTENT_TYPE_SPCID                 111
// Structure is a LPTSTR
#define ATTRIBUTE_TYPE_SPCID               112
// Structure is a CRYPT_ATTRIBUTE     

HRESULT WINAPI
SpcEncodeOid(IN  DWORD        dwAlgorithm,
             IN  const void  *pStructure,
             OUT PBYTE*       ppsEncoding,
             IN  OUT DWORD*   pdwEncoding);

HRESULT WINAPI
SpcDecodeOid(IN  DWORD       dwAlgorithm,
             IN  const PBYTE psEncoding,
             IN  DWORD       dwEncoding,
             IN  DWORD       dwFlags,
             OUT LPVOID*     ppStructure,
             IN OUT DWORD*   pdwStructure);


//+-------------------------------------------------------------------
// Pushes a certificate on the list, ONLY use SpcDeleteCertChain to free 
// up certificate list.
// Returns:
//      S_OK

HRESULT WINAPI 
SpcPushCertChain(IN PCCERT_CONTEXT pCert,
                 IN PCCERT_CONTEXTLIST pIssuer);


//+-------------------------------------------------------------------
// Frees up a list of cert contexts
// Returns:
//      S_OK

HRESULT WINAPI
SpcDeleteCertChain(IN PCCERT_CONTEXTLIST sIssuer);


//+--------------------------------------------------------------------------
// Creates a list of glue certs that apply to the pSubject. If the crypt memory
// allocator is set it will return a list that must be freed. (Returned memory
// is a vector so free just the returned pointer) If there is no allocator then 
// use the two pass win32 style. (NOTE: PCCERT_CONTEXTLIST must be supplied) 
//
// Parameter Returns:
//      pGlue - List of cert contexts that must be released. 
// 
// Returns:
//      S_OK                          - Created list
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
//      E_OUTOFMEMORY                 - Memory allocation error occured

HRESULT WINAPI
SpcFindGlueCerts(IN PCCERT_CONTEXT pSubject,
                 IN HCERTSTORE     hCertStore,
                 IN OUT PCCERT_CONTEXTLIST pGlue);


//+-------------------------------------------------------------------
// Locate the issuers in the trusted list. (NOTE: PCCERT_CONTEXTLIST must be supplied) 
// Parameter Returns:
//      pIssuerChain   - List of cert contexts that must be released.
//
// Returns:
//      S_OK           - Created list
//      E_OUTOFMEMORY  - Memory allocation error occured

                                              
HRESULT WINAPI
SpcLocateIssuers(IN DWORD dwVerifyFlags,
                 IN HCERTSTORE hCertStore,
                 IN PCCERT_CONTEXT item,
                 IN OUT PCCERT_CONTEXTLIST pIssuerChain);



//+-------------------------------------------------------------------------
//  Find the the cert from the hprov
//  Parameter Returns:
//      pReturnCert - context of the cert found (must pass in cert context);
//  Returns:
//      S_OK - everything worked
//      E_OUTOFMEMORY - memory failure
//      E_INVALIDARG - no pReturnCert supplied
//      CRYPT_E_NO_MATCH - could not locate certificate in store
//
     
HRESULT WINAPI
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN OUT PCCERT_CONTEXT* pReturnCert);


/*
//+-------------------------------------------------------------------------
//  Locates a certificate in the store that matches the public key
//  dictated by the HCRYPTPROV
//-=========================================================================
PCCERT_CONTEXT WINAPI
SpcFindCert(IN HCERTSTORE hStore,
            IN HCRYPTPROV hProv);
            */
//+-------------------------------------------------------------------
// Retrieves the a cert context from the store based on the issuer
// and serial number.
// Returns:
//      Cert context   - on success
//      NULL           - if no certificate existed or on Error
//    
/*
PCCERT_CONTEXT WINAPI
SpcFindCertWithIssuer(IN DWORD dwCertEncodingType,
                   IN HCERTSTORE hCertStore,
                   IN CERT_NAME_BLOB* psIssuer,
                   IN CRYPT_INTEGER_BLOB* psSerial);
                   */

//+-------------------------------------------------------------------------
//  Given a signing cert, a store with the certs chain, hashing algorithm,
//  and a time request structure it will return an encoded time stamp request 
//  message.
//  Parameter Returns:
//      pbEncoding - time stamp response (PKCS7 message)
//      cbEncoding - length of encoding
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
     
HRESULT WINAPI
SpcBuildTimeStampResponse(IN HCRYPTPROV hCryptProv,
                          IN HCERTSTORE hCertStore,
                          IN PCCERT_CONTEXT pSigningCert,
                          IN ALG_ID  algidHash,
                          IN OPTIONAL FILETIME* pFileTime,
                          IN PSPC_TIMESTAMP_REQ psRequest,
                          OUT PBYTE* pbEncoding,
                          OUT DWORD* cbEncoding);


//+-------------------------------------------------------------------------
//  Encodes the current time
//  Parameter Returns:
//      pbEncodedTime - encoded time (current UTC time)
//      cbEncodedTime - length of encoding
//  Returns:
//      S_OK - everything worked
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
     
HRESULT WINAPI
SpcEncodeCurrentTime(OUT PBYTE* pbEncodedTime,
                     OUT DWORD* cbEncodedTime);



//+-------------------------------------------------------------------------
//  Crack a PKCS7 message returns the content and content type. Data is verified
//  
//  Parameter Returns:
//      pSignerCert - Context that was used to sign the certificate
//      ppbContent - the content of the message
//      pcbContent - the length
//      pOid       - the oid of the content (content type)
//  Returns:
//      S_OK - everything worked
//
//      CERT_E_NOT_FOUND - Cannot load certificate from encoded pkcs7 message
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
HRESULT WINAPI
SpcLoadData(IN HCRYPTPROV hCryptProv,
            IN PBYTE pbEncoding,
            IN DWORD cbEncoding,
            IN DWORD lSignerIndex, 
            OUT PCCERT_CONTEXT& pSignerCert,
            OUT PBYTE& pbContent,
            OUT DWORD& cbContent,
            OUT LPSTR& pOid);

//+-------------------------------------------------------------------------
//  Crack a PKCS7 message which contains a time request
//  Parameter Returns:
//      ppCertContext - returns contexts if pointer provided (optional)
//      ppbRequest - allocates a Time request structure (delete just the pointer)
//  Returns:
//      S_OK - everything worked
//
//      CERT_E_NOT_FOUND - Cannot load certificate from encoded pkcs7 message
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
HRESULT WINAPI
SpcLoadTimeStamp(IN HCRYPTPROV hCryptProv,
                 IN PBYTE pbEncoding,
                 IN DWORD cbEncoding,
                 OUT PCCERT_CONTEXT* ppCertContext, // Optional
                 OUT PSPC_TIMESTAMP_REQ* ppbRequest);


//+-------------------------------------------------------------------
// Verifies the certifcate chain based on glue certs
// Return Parameters:
//      pRoot          - Context to the root certificate of the chain
//                       (must be freed)
//      pIssuers       - Stores the chain in pIssuers if it is present
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified 
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
    
HRESULT WINAPI
SpcVerifyCertChain(IN HCRYPTPROV hCryptProv,
                   IN DWORD dwVerifyFlags,
                   IN FILETIME*  pTimeStamp,
                   IN HCERTSTORE hCertStore,
                   IN PCCERT_CONTEXT pChild,
                   IN OUT OPTIONAL PCCERT_CONTEXTLIST pIssuers,
                   OUT PCCERT_CONTEXT* pRoot);

//+-------------------------------------------------------------------
// Checks the certifcate chain for a glue certificate
// Returns:
//      S_OK           - Cert was found and was verified at the given time
//      S_FALSE        - Cert was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using 
//      CERT_E_EXPIRED - An issuing certificate was found but it was not currently valid
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcVerifyGlueChain(IN DWORD dwVerifyFlags,
                   IN HCRYPTPROV hCryptProv,
                   IN OPTIONAL FILETIME*  pTimeStamp,
                   IN HCERTSTORE hCertStore,
                   IN OPTIONAL PCCERT_CONTEXTLIST pIssuers,
                   IN PCCERT_CONTEXT pChild);

//-------------------------------------------------------------------
// Retrieves the a cert context from the store based on the issuer
// and serial number. psIssuer and psSerial can be obtained from
// the SPC_CONTENT_INFO.
//
// Returns:
//      Cert context   - on success
//      NULL           - if no certificate existed or on Error (use SpcError() to retirieve HRESULT)
//    

PCCERT_CONTEXT WINAPI
SpcGetCertFromStore(IN DWORD dwCertEncodingType,
                    IN HCERTSTORE hCertStore,
                    IN CERT_NAME_BLOB* psIssuer,
                    IN CRYPT_INTEGER_BLOB* psSerial);

//+---------------------------------------------------------------------------
// Verifies the signer at the specified time. The psSignerInfo can be
// obtained be decoding and encoded signature using SIGNER_INFO_SPCID.
// Verify flags can be CERT_STORE_SIGNATURE_FLAG and/or CERT_STORE_REVOCATION_FLAG.
// If pTimeStamp is present the certificate must have been valid at that time
// Returns:
//      S_OK           - Time stamp was found and verified
//      S_FALSE        - Time stamp was found and verified to a test root
//      CERT_E_CHAINING - Could not be verified using tursted roots or certificate store 
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcVerifySignerInfo(IN DWORD dwCertEncodingType,
                    IN HCRYPTPROV hCryptProv,
                    IN DWORD dwVerifyFlags,
                    IN HCERTSTORE hTrustedRoots,
                    IN HCERTSTORE hCertStore,
                    IN PSPC_SIGNER_INFO psSignerInfo,
                    IN LPFILETIME pTimeStamp,
                    IN PSPC_CONTENT_INFO psData);

//+-------------------------------------------------------------------------------
// Verifies the encoded signature if there is a time stamp present. If there is no
// time stamp the CERT_E_NO_MATCH is returned. If there is a time stamp then the 
// certificate and ceritifcate chain is  verfified at that time.
//
// Verify flags can be CERT_STORE_SIGNATURE_FLAG and/or CERT_STORE_REVOCATION_FLAG.
//
// Parameter Returns:
//      psTime   - Filled in time, time is set to zero on error.
//
// Returns:
//      S_OK           - Time stamp was found and verified
//      S_FALSE        - Time stamp was found and verified to a test root
//      CERT_E_NO_MATCH - Unable to find time stamp in signer info
//      CERT_E_CHAINING - Could not be verified using trusted roots or certicate store
//
//      E_OUTOFMEMORY  - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.

HRESULT WINAPI
SpcVerifyEncodedSigner(IN DWORD dwCertEncodingType,
                       IN HCRYPTPROV hCryptProv,
                       IN DWORD dwVerifyFlags,
                       IN HCERTSTORE hTrustedRoots,
                       IN HCERTSTORE hCertStore,
                       IN PBYTE psEncodedSigner,
                       IN DWORD dwEncodedSigner,
                       IN PSPC_CONTENT_INFO psData,
                       OUT FILETIME* pReturnTime);

//+-------------------------------------------------------------------
// Finds a counter signature attribute (OID: COUNTER_SIGNATURE_OID == 
// "1.2.840.113549.1.9.6"). The counter signature is then verified.
// (see CryptVerifySignerInfo)
// Parameter Returns:
//      psTime   - Filled in time, time is set to zero on error.
//
// Returns:
//      S_OK              - Time stamp was found and verified
//      S_FALSE           - Time stamp was found and verified to a test root
//      CRYPT_E_NO_MATCH  - Time stamp attribute could not be found
//
//      CERT_E_CHAINING   - Could not be verified using trusted roots or certicate store
//      E_OUTOFMEMORY     - Memory allocation error occured
//      CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
    
    
HRESULT WINAPI
SpcVerifyTimeStampAttribute(IN DWORD dwCertEncodingType,
                            IN HCRYPTPROV hCryptProv,
                            IN DWORD dwVerifyFlags,
                            IN HCERTSTORE hTrustedRoots,
                            IN HCERTSTORE hCertStore,
                            IN PCRYPT_ATTRIBUTE psAttributes,
                            IN DWORD dwAttributes,
                            IN PSPC_CONTENT_INFO psData,
                            OUT FILETIME* pReturnTime);
    
//+-------------------------------------------------------------------------
// Cracks the SignerInfo out of the PKCS7 message and returns the encoded representation.
// Parameter Returns:
//  pbSignerData    - Encoded signer info from the message.
//  cbSignerData    - Length of the message
// Returns:
//  TRUE - Succeeded.
//  FALSE - Failed.
//

HRESULT WINAPI
SpcGetEncodedSigner(IN  DWORD dwMsgAndCertEncodingType,
                      IN  HCERTSTORE hMsgCertStore,
                      IN  PCCERT_CONTEXT  pSignerCert,
                      IN  PBYTE pbEncoding, 
                      IN  DWORD cbEncoding,
                      OUT PBYTE* pbSignerData,
                      OUT DWORD* cbSignerData);

//+-------------------------------------------------------------------------
//  Gets (and will set) the CERT_KEY_PROV_INFO_PROP_ID property for a cert
//  context.
//+--------------------------------------------------------------------------
HRESULT WINAPI
SpcGetCertKeyProv(IN PCCERT_CONTEXT pCert,
                    OUT HCRYPTPROV *phCryptProv,
                    OUT DWORD *pdwKeySpec,
                    OUT BOOL *pfDidCryptAcquire);

//+-------------------------------------------------------------------------
//  Returns TRUE if message is not wrapped in a 
//  ContentInfo.
//+--------------------------------------------------------------------------
BOOL WINAPI 
SpcNoContentWrap(IN const BYTE *pbDER,
                 IN DWORD cbDER);


//+-------------------------------------------------------------------------
// Retrieves the specified parameter from the Signature. The parameter is 
// allocated using the SPC allocation.
// 
// Parameter Returns:
//      pbData:  Allocated data
//      cbData:  size of data allocated
// Returns: 
//      S_OK            - Created parameter
//      E_OUTOFMEMORY   - Memory Allocation error
// 
//--------------------------------------------------------------------------

HRESULT SpcGetParam(IN HCRYPTMSG hMsg,
                    IN DWORD dwParamType,
                    IN DWORD dwIndex,
                    OUT PBYTE& pbData,
                    OUT DWORD& cbData);

//+-------------------------------------------------------------------------
// Retrieves the Signer Id from the Signature. The parameter is 
// allocated using the SPC allocation.
// 
// Returns: 
//      S_OK            - Created Signer id
//      E_OUTOFMEMORY   - Memory Allocation error
// 
//--------------------------------------------------------------------------

HRESULT SpcGetCertIdFromMsg(IN HCRYPTMSG hMsg,
                            IN DWORD dwIndex,
                            OUT PCERT_INFO& pSignerId);

//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//  Certificate and CRL encoding types 
//+--------------------------------------------------------------------------
#define CERT_OSS_ERROR          0x80093000


typedef HRESULT (*SpcEncodeFunction)(const SpcAlloc* pManager,
                                     const void*     pStructure,
                                     PBYTE&          psEncoding,
                                     DWORD&          dwEncoding);

typedef HRESULT (*SpcDecodeFunction)(const SpcAlloc* pManager,
                                     const PBYTE pEncoding,
                                     DWORD       dwEncoding,
                                     DWORD       dwFlags,
                                     LPVOID&     pStructure,
                                     DWORD&      dwStructure);

typedef struct _SPC_OidFuncEntry {
    SpcEncodeFunction pfEncode;
    SpcDecodeFunction pfDecode;
} SPC_OidFuncEntry;


// 
// Decode routines
// #define CRYPT_DECODE_NOCOPY_FLAG            0x1

HRESULT WINAPI 
SpcEncodeOid32(IN  DWORD        dwAlgorithm,
               IN  const void  *pStructure,
               OUT PBYTE        ppsEncoding,
               IN  OUT DWORD*   pdwEncoding);
// Win32 version of above function

HRESULT WINAPI
SpcDecodeOid32(IN  DWORD         dwAlgorithm,
               IN  const PBYTE   psEncoding,
               IN  DWORD         dwEncoding,
               IN  DWORD         dwFlags,
               OUT LPVOID        ppStructure,
               IN OUT DWORD*     pdwStructure);
// Win32 version of above function

//+-------------------------------------------------------------------
// Asn routines, Uses specified memory allocator or Win32 dual call
// if no allocator set.

typedef  OssGlobal  *POssGlobal;  

HRESULT WINAPI 
SpcASNEncode(IN const SpcAlloc* pManager,
             IN POssGlobal   pOssGlobal,
             IN DWORD        pdu, 
             IN const void*  sOssStructure,
             OUT PBYTE&      psEncoding,
             OUT DWORD&      dwEncoding);

HRESULT WINAPI
SpcASNDecode(IN POssGlobal     pOssGlobal,
             IN  DWORD         pdu, 
             IN  const PBYTE   psEncoding,
             IN  DWORD         dwEncoding,
             IN  DWORD         dwFlags,
             OUT LPVOID&       psStructure);

//+-------------------------------------------------------------------
// Memory Functions

HRESULT WINAPI
SpcSetMemoryAlloc(SpcAlloc& pAlloc);

const SpcAlloc* WINAPI
SpcGetMemoryAlloc();

BOOL WINAPI
SpcGetMemorySet();

BOOL WINAPI
SpcSetMemoryAllocState(BOOL state);

HRESULT WINAPI
SpcSetEncodingType(DWORD type);

HRESULT WINAPI
SpcGetEncodingType(DWORD* type);

//+-------------------------------------------------------------------
// Time Stamp functions

HRESULT WINAPI
SpcCompareTimeStamps(IN   PBYTE   psTime1,
                     IN   DWORD   dwTime1,
                     IN   PBYTE   psTime2,
                     IN   DWORD   dwTime2);

HRESULT WINAPI
SpcCreateTimeStampHash(IN HCRYPTPROV  hCryptProv,
                         IN DWORD dwAlgoCAPI,
                         IN PBYTE pbData,
                         IN DWORD cbData,
                         OUT HCRYPTHASH& hHash);

HRESULT WINAPI
SpcGetTimeStampHash(IN HCRYPTPROV  hCryptProv,
                      IN DWORD dwAlgoCAPI,
                      IN PBYTE pbData,
                      IN DWORD cbData,
                      OUT PBYTE& pbHashValue,
                      IN OUT DWORD& cbHashValue);

HRESULT WINAPI
SpcTimeStampHashContent(IN HCRYPTPROV  hCryptProv,
                          IN SPC_CONTENT_INFO& sContent,
                          IN SPC_SIGNER_INFO& sTimeStamp,
                          OUT PBYTE& pbHashValue,
                          IN OUT DWORD& cbHashValue);

HRESULT WINAPI
SpcVerifyTimeStampSignature(IN HCRYPTPROV    hCryptProv,
                         IN CERT_INFO&    sCertInfo,
                         IN SPC_SIGNER_INFO&  sTimeStamp);

HRESULT WINAPI
SpcVerifyTimeStampDigest(IN HCRYPTPROV  hCryptProv,
                      IN SPC_CONTENT_INFO& sContent,
                      IN SPC_SIGNER_INFO& sTimeStamp);

HRESULT WINAPI
SpcVerifyTimeStamp(IN HCRYPTPROV  hCryptProv,
                IN CERT_INFO&  sCertInfo,
                IN SPC_CONTENT_INFO& sContent,
                IN SPC_SIGNER_INFO& sTimeStamp);

HRESULT SpcError();


//+-------------------------------------------------------------------
// String functions

HRESULT WINAPI
SpcCopyPrintableString(const SpcAlloc* pManager, 
                    LPCSTR sz,
                    LPSTR& str,
                    DWORD& lgth);

BOOL WINAPI
SpcIsPrintableStringW(LPCWSTR wsz);

BOOL WINAPI
SpcIsPrintableString(LPCSTR sz);

HRESULT WINAPI
SpcWideToPrintableString(const SpcAlloc* psManager,
                      LPCWSTR wsz,
                      LPSTR& pString,
                      DWORD& dwString);

HRESULT WINAPI
SpcPrintableToWideString(const SpcAlloc* psManager,
                      LPCSTR sz,
                      LPWSTR& psString,
                      DWORD&  dwString);


HRESULT WINAPI
SpcBMPToWideString(const SpcAlloc* psManager,
                WORD*  pbStr, 
                DWORD   cbStr,
                LPWSTR& psString,
                DWORD&  dwString);

HRESULT WINAPI
SpcBMPToPrintableString(const SpcAlloc* psManager,
                     WORD*  pbStr, 
                     DWORD   cbStr,
                     LPSTR&  psString,
                     DWORD&  dwString);

HRESULT WINAPI
SpcUniversalToWideString(const SpcAlloc* psManager,
                      DWORD*  pbStr, 
                      USHORT  cbStr,
                      LPWSTR& psString,
                      DWORD&  dwString);

HRESULT WINAPI
SpcWideToUniversalString(const SpcAlloc* psManager,
                      LPWSTR  pSource, 
                      DWORD*  pString,
                      DWORD&  dwString);
HRESULT WINAPI
SpcPrintableToUniversalString(const SpcAlloc* psManager,
                           LPSTR  pSource, 
                           DWORD*  pString,
                           DWORD&  dwString);

HRESULT WINAPI 
SpcUniversalToPrintableString(const SpcAlloc* psManager,
                           DWORD*  pbStr, 
                           USHORT  cbStr,
                           LPSTR&  psString,
                           DWORD&  dwString);

//+-------------------------------------------------------------------
// Asn functions

HRESULT WINAPI 
SpcASNEncodeTimeStamp(IN const SpcAlloc* pManager,
                      IN const void* pStructure,
                      OUT PBYTE&     psEncoding,
                      IN OUT DWORD&  dwEncoding);

HRESULT WINAPI 
SpcASNDecodeTimeStamp(IN const SpcAlloc* pManager,
                      IN  const PBYTE psEncoding,
                      IN  DWORD       dwEncoding,
                      IN  DWORD       dwFlags,
                      OUT LPVOID&     psStructure,
                      IN OUT DWORD&   dwStructure);

HRESULT WINAPI
SpcASNEncodeObjectId(IN const SpcAlloc* pManager,
                     IN const void*   pStructure,
                     OUT PBYTE&       psEncoding,
                     IN OUT DWORD&    dwEncoding);

HRESULT 
SpcASNDecodeObjectId(IN const SpcAlloc* pManager,
                     IN  const PBYTE psEncoding,
                     IN  DWORD       dwEncoding,
                     IN  DWORD       dwFlags,
                     OUT LPVOID&     psStructure,
                     IN OUT DWORD&   dwStructure);

HRESULT WINAPI
SpcASNEncodeDirectoryString(IN const SpcAlloc* pManager,
                            const void* psData,
                            PBYTE&      pEncoding,
                            DWORD&      dwEncoding);

HRESULT WINAPI 
SpcASNDecodeDirectoryString(IN const SpcAlloc* pManager,
                            IN const PBYTE psEncoding, 
                            IN DWORD       dwEncoding, 
                            IN DWORD       dwFlags,
                            OUT LPVOID&    psString,
                            IN OUT DWORD&  dwString);

HRESULT WINAPI
SpcASNEncodeDirectoryStringW(IN const SpcAlloc* pManager,
                             const void* psData,
                             PBYTE&      pEncoding,
                             DWORD&      dwEncoding);

HRESULT WINAPI 
SpcASNDecodeDirectoryStringW(IN const SpcAlloc* pManager,
                             IN const PBYTE psEncoding, 
                             IN DWORD       dwEncoding, 
                             IN DWORD       dwFlags,
                             OUT LPVOID&    psString,
                             IN OUT DWORD&  dwString);

HRESULT WINAPI 
SpcASNEncodeOctetString(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE&      psEncoding,
                        IN OUT DWORD&   dwEncoding);


HRESULT WINAPI 
SpcASNDecodeOctetString(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeAttributes(IN const SpcAlloc* pManager,
                       IN  const void* pStructure,
                       OUT PBYTE&      psEncoding,
                       IN OUT DWORD&   dwEncoding);

HRESULT WINAPI 
SpcASNDecodeAttributes(IN const SpcAlloc* pManager,
                       IN  const PBYTE psEncoding,
                       IN  DWORD       dwEncoding,
                       IN  DWORD       dwFlags,
                       OUT LPVOID&     psStructure,
                       IN OUT DWORD&   dwStructure);
HRESULT WINAPI 
SpcASNEncodeIA5String(IN const SpcAlloc* pManager,
                      IN const void*   pStructure,
                      OUT PBYTE&  psEncoding,
                      IN OUT DWORD&  dwEncoding);

HRESULT WINAPI 
SpcASNDecodeIA5String(IN const SpcAlloc* pManager,
                      IN  const PBYTE psEncoding,
                      IN  DWORD       dwEncoding,
                      IN  DWORD       dwFlags,
                      OUT LPVOID&     psStructure,
                      IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeTimeRequest(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE& psEncoding,
                        IN OUT DWORD& dwEncoding);

HRESULT WINAPI 
SpcASNDecodeTimeRequest(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeSignerInfo(IN const SpcAlloc* pManager,
                       IN  const void* pStructure,
                       OUT PBYTE&      psEncoding,
                       IN OUT DWORD&   dwEncoding);

HRESULT WINAPI 
SpcASNDecodeSignerInfo(IN const SpcAlloc* pManager,
                       IN  const PBYTE psEncoding,
                       IN  DWORD       dwEncoding,
                       IN  DWORD       dwFlags,
                       OUT LPVOID&     psStructure,
                       IN OUT DWORD&   dwStructure);
HRESULT WINAPI 
SpcASNEncodeContentInfo(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE&      psEncoding,
                        IN OUT DWORD&   dwEncoding);

HRESULT WINAPI 
SpcASNDecodeContentInfo(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeContentType(IN const SpcAlloc* pManager,
                        IN  const void* pStructure,
                        OUT PBYTE& psEncoding,
                        IN OUT DWORD& dwEncoding);

HRESULT WINAPI 
SpcASNDecodeContentType(IN const SpcAlloc* pManager,
                        IN  const PBYTE psEncoding,
                        IN  DWORD       dwEncoding,
                        IN  DWORD       dwFlags,
                        OUT LPVOID&     psStructure,
                        IN OUT DWORD&   dwStructure);

HRESULT WINAPI 
SpcASNEncodeAttribute(IN const SpcAlloc* pManager,
                      IN  const void* pStructure,
                      OUT PBYTE& psEncoding,
                      IN OUT DWORD& dwEncoding);

HRESULT WINAPI 
SpcASNDecodeAttribute(IN const SpcAlloc* pManager,
                      IN  const PBYTE psEncoding,
                      IN  DWORD       dwEncoding,
                      IN  DWORD       dwFlags,
                      OUT LPVOID&     psStructure,
                      IN OUT DWORD&   dwStructure);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\spcmem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       spcmem.h
//
//--------------------------------------------------------------------------

#ifndef _SPCMEM_H
#define _SPCMEM_H

#if defined(__cplusplus) && defined(TRYTHROW)
class PkiError {
public:

    PkiError(HRESULT err = E_UNEXPECTED)
    { pkiError = err; }

    HRESULT  pkiError;

};
#else
typedef struct _PkiError {
    HRESULT pkiError;
} PkiError;
#endif

#if defined(DBG) && defined(__cplusplus) && defined(TRYTHROW)
#define PKITRY       try
#define PKITHROW(x)  throw PkiError(x); //   
#define PKICATCH(x)  catch (PkiError x) 
#define PKIEND       //
#else
#define PKITRY       HRESULT _tpkiError; 
#define PKITHROW(x)  {_tpkiError = x; goto PKIERROR;} //
#define PKICATCH(x)  goto PKICONT; PKIERROR: { PkiError x; x.pkiError = _tpkiError; 
#define PKIEND       } PKICONT: //                                        
#endif


#ifdef __cplusplus
extern "C" {
#endif

// Internal memory manager for calls.
typedef LPVOID (WINAPI *AllocMem)(ULONG);
typedef VOID   (WINAPI *FreeMem)(LPVOID);

typedef struct _SpcAlloc {
    AllocMem Alloc;
    FreeMem  Free;
} SpcAlloc, *PSpcAlloc;

HRESULT WINAPI SpcInitializeStdAsn();  // Initialize to ASN and standard C allocators

#ifdef __cplusplus
}   /* extern "C" */
#endif 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\spc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       spc.h
//
//  Contents:   Software Publishing Certificate (SPC) Prototypes and Definitions
//              
//              Defines a set of Win32 APIs specific to software publishing
//              for encoding and decoding X.509 v3 certificate extensions and
//              PKCS #7 signed message content and authenticated attributes.
//              Defines a PKCS #10 attribute containing X509 v3 extensions.
//
//              Defines a set of Win32 APIs for signing and verifying files
//              used in software publishing. The APIs have file processing
//              callbacks to accommodate any type of file. Direct support is
//              provided for: Portable Executable (PE) image, Java class,
//              structured storage and raw files.
//
//  APIs:
//              SpcGetSignedDataIndirect
//              SpcWriteSpcFile
//              SpcReadSpcFile
//              SpcWriteSpcToMemory
//              SpcReadSpcFromMemory
//              SpcSignPeImageFile
//              SpcVerifyPeImageFile
//              SpcSignJavaClassFile
//              SpcVerifyJavaClassFile
//              SpcSignStructuredStorageFile
//              SpcVerifyStructuredStorageFile
//              SpcSignRawFile
//              SpcVerifyRawFile
//              SpcSignCabFile
//              SpcVerifyCabFile
//              SpcSignFile
//              SpcVerifyFile
//
//  History:    15-Apr-96   philh   created
//--------------------------------------------------------------------------

#ifndef __SPC_H__
#define __SPC_H__

#include "wincrypt.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  SPC_SP_AGENCY_INFO_OBJID
//
//  All the fields in the Image and Info structures are optional. When
//  omitted, a pointer is NULL or a blob's cbData is 0.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  SPC_MINIMAL_CRITERIA_OBJID
//
//  Type of BOOL. Its set to TRUE if publisher meets minimal criteria.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  SPC_FINANCIAL_CRITERIA_OBJID
//--------------------------------------------------------------------------

//+=========================================================================
//
// SPC PKCS #7 Signed Message Content
//
//-=========================================================================

//+-------------------------------------------------------------------------
//  SPC PKCS #7 IndirectData ContentType Object Identifier
//--------------------------------------------------------------------------

//+=========================================================================
//
//  SPC Sign and Verify File APIs and Type Definitions
//
//  Following file types are directly supported:
//      Portable Executable (PE) Image
//      Java Class
//      Structured Storage
//      Raw (signed data is stored outside of the file)
//
//-=========================================================================


//+-------------------------------------------------------------------------
//  Callback to get and verify the software publisher's certificate.
//
//  Passed the CertId of the signer (its Issuer and SerialNumber), a
//  handle to a cert store containing certs and CRLs copied from
//  the signed message, the indirect data content attribute extracted from
//  the signed data's indirect content,
//  flag indicating if computed digest of the file matched the digest in the
//  signed data's indirect content and the signer's authenticated attributes.
//
//  If the file's signed data doesn't contain any content or signers, then,
//  called with pSignerId, pIndirectDataContentAttr and rgAuthnAttr == NULL.
//
//  For a valid signer certificate, returns SPC_VERIFY_SUCCESS and a pointer
//  to a read only CERT_CONTEXT. The returned CERT_CONTEXT is either obtained
//  from a cert store or was created via CertStoreCreateCert. For either case,
//  its freed via CertStoreFreeCert.
//
//  If this is the wrong signer or if a certificate wasn't found for the
//  signer, returns either
//  SPC_VERIFY_CONTINUE to continue on to the next signer or SPC_VERIFY_FAILED
//  to terminate the verification process.
//
//  The NULL implementation tries to get the Signer certificate from the
//  signed data's cert store. It doesn't verify the certificate.
//--------------------------------------------------------------------------
typedef int (WINAPI *PFN_SPC_VERIFY_SIGNER_POLICY)(
            IN void *pvVerifyArg,
            IN DWORD dwCertEncodingType,
            IN OPTIONAL PCERT_INFO pSignerId,   // Only the Issuer and
                                                // SerialNumber fields have
                                                // been updated
            IN HCERTSTORE hMsgCertStore,
            IN OPTIONAL PCRYPT_ATTRIBUTE_TYPE_VALUE pIndirectDataContentAttr,
            IN BOOL fDigestResult,
            IN DWORD cAuthnAttr,
            IN OPTIONAL PCRYPT_ATTRIBUTE rgAuthnAttr,
            IN DWORD cUnauthAttr,
            IN OPTIONAL PCRYPT_ATTRIBUTE rgUnauthAttr,
            IN DWORD cDigest,
            IN OPTIONAL PBYTE rgDigest,
            OUT PCCERT_CONTEXT *ppSignerCert
            );

#define SPC_VERIFY_SUCCESS      0
#define SPC_VERIFY_FAILED       -1
#define SPC_VERIFY_CONTINUE     1

//+-------------------------------------------------------------------------
//  The SPC_SIGN_PARA are used for signing files used in software publishing.
//  
//  Either the CERT_KEY_PROV_HANDLE_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID must
//  be set for pSigningCert. Either one specifies the private
//  signature key to use.
//
//  If any certificates and/or CRLs are to be included in the file's signed
//  data, then, the MsgCert and MsgCrl fields need to be updated. If the
//  rgpSigningCerts are to be included, then, they must also be in the
//  rgpMsgCert array.
//
//  If any authenticated attributes are to be included, then, the AuthnAttr
//  fields must be updated.
//--------------------------------------------------------------------------
typedef struct _SPC_SIGN_PARA {
    DWORD                         dwVersion;
    DWORD                         dwMsgAndCertEncodingType;
    PCCERT_CONTEXT                pSigningCert;
    CRYPT_ALGORITHM_IDENTIFIER    DigestAlgorithm;
    DWORD                         cMsgCert;
    PCCERT_CONTEXT                *rgpMsgCert;
    DWORD                         cMsgCrl;
    PCCRL_CONTEXT                 *rgpMsgCrl;
    DWORD                         cAuthnAttr;
    PCRYPT_ATTRIBUTE              rgAuthnAttr;
    DWORD                         cUnauthnAttr;
    PCRYPT_ATTRIBUTE              rgUnauthnAttr;
} SPC_SIGN_PARA, *PSPC_SIGN_PARA;

//+-------------------------------------------------------------------------
//  The SCA_VERIFY_PARA are used to verify files signed for software
//  publishing.
//
//  hCryptProv is used to do digesting and signature verification.
//
//  hMsgCertStore is the store to copy certificates and CRLs from the message
//  to. If hMsgCertStore is NULL, then, a temporary store is created before
//  calling the VerifySignerPolicy callback.
//
//  The dwMsgAndCertEncodingType specifies the encoding type of the certificates
//  and/or CRLs in the message.
//
//  pfnVerifySignerPolicy is called to verify the message signer's certificate.
//--------------------------------------------------------------------------
typedef struct _SPC_VERIFY_PARA {
    DWORD                           dwVersion;
    DWORD                           dwMsgAndCertEncodingType;
    HCRYPTPROV                      hCryptProv;
    HCERTSTORE                      hMsgCertStore;          // OPTIONAL
    PFN_SPC_VERIFY_SIGNER_POLICY    pfnVerifySignerPolicy;
    void                            *pvVerifyArg;
} SPC_VERIFY_PARA, *PSPC_VERIFY_PARA;


//+-------------------------------------------------------------------------
//  Sign / Verify Flags
//--------------------------------------------------------------------------
#define SPC_LENGTH_ONLY_FLAG                0x00000001
#define SPC_DISABLE_DIGEST_FILE_FLAG        0x00000002
#define SPC_DISABLE_VERIFY_SIGNATURE_FLAG   0x00000004
#define SPC_ADD_SIGNER_FLAG                 0x00000100
#define SPC_GET_SIGNATURE                   0x00000200

//+-------------------------------------------------------------------------
//  Put any certs/crl's into the store, and verify the SignedData's signature
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifySignedData(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN PBYTE pbSignedData,
    IN DWORD cbSignedData
    );

//+-------------------------------------------------------------------------
//  Table of functions called to support the signing and verifying of files
//  used in software publishing. The functions read the portions of the
//  file to be digested, store the signed data or retrieve the signed data.
//
//  pfnOpenSignFile is called with the pvSignFileArg passed to either
//  SpcSignFile() or SpcVerifyFile(). It returns a handle to be passed to the
//  other functions. pfnCloseSignFile is called to close the hSignFile.
//
//  pfnDigestSignFile reads the portions of the file to be digested and
//  calls pfnDigestData to do the actual digesting.
//
//  pfnSetSignedData stores the PKCS #7 Signed Data in the appropriate place
//  in the file. pfnGetSignedData retrieves the PKCS #7 Signed Data from the
//  file. pfnGetSignedData returns a pointer to its copy of the signed
//  data. Its not freed until pfnCloseSignFile is called.
//--------------------------------------------------------------------------

typedef void *HSPCDIGESTDATA;
typedef BOOL (WINAPI *PFN_SPC_DIGEST_DATA)(
            IN HSPCDIGESTDATA hDigestData,
            IN const BYTE *pbData,
            IN DWORD cbData
            );

typedef void *HSPCSIGNFILE;

typedef HSPCSIGNFILE (WINAPI *PFN_SPC_OPEN_SIGN_FILE)(
            IN void *pvSignFileArg
            );
typedef BOOL (WINAPI *PFN_SPC_CLOSE_SIGN_FILE)(
            IN HSPCSIGNFILE hSignFile
            );
typedef BOOL (WINAPI *PFN_SPC_DIGEST_SIGN_FILE)(
            IN HSPCSIGNFILE hSignFile,
            IN DWORD dwMsgAndCertEncodingType,
            IN PCRYPT_ATTRIBUTE_TYPE_VALUE pIndirectDataContentAttr,
            IN PFN_SPC_DIGEST_DATA pfnDigestData,
            IN HSPCDIGESTDATA hDigestData
            );
typedef BOOL (WINAPI *PFN_SPC_GET_SIGNED_DATA)(
            IN HSPCSIGNFILE hSignFile,
            OUT const BYTE **ppbSignedData,
            OUT DWORD *pcbSignedData
            );
typedef BOOL (WINAPI *PFN_SPC_SET_SIGNED_DATA)(
            IN HSPCSIGNFILE hSignFile,
            IN const BYTE *pbSignedData,
            IN DWORD cbSignedData
            );

typedef struct _SPC_SIGN_FILE_FUNC_TABLE {
    PFN_SPC_OPEN_SIGN_FILE      pfnOpenSignFile;
    PFN_SPC_CLOSE_SIGN_FILE     pfnCloseSignFile;
    PFN_SPC_DIGEST_SIGN_FILE    pfnDigestSignFile;
    PFN_SPC_GET_SIGNED_DATA     pfnGetSignedData;
    PFN_SPC_SET_SIGNED_DATA     pfnSetSignedData;
} SPC_SIGN_FILE_FUNC_TABLE, *PSPC_SIGN_FILE_FUNC_TABLE;
typedef const SPC_SIGN_FILE_FUNC_TABLE *PCSPC_SIGN_FILE_FUNC_TABLE;


//+-------------------------------------------------------------------------
//  Sign any type of file used for software publishing.
//
//  The IndirectDataContentAttr indicates the type of file being digested
//  and signed. It may have an optional value, such as, a link to the file.
//  Its stored with the file's digest algorithm and digest in the
//  indirect data content of the signed data.
//
//  The SPC_DISABLE_DIGEST_FLAG inhibits the digesting of the file.
//  The SPC_LENGTH_ONLY_FLAG implicitly sets the SPC_DISABLE_DIGEST_FLAG_FLAG 
//  and only calculates a length for the signed data.
//--------------------------------------------------------------------------
BOOL
WINAPI
    SpcSignFile(IN PSPC_SIGN_PARA pSignPara,
                IN PCSPC_SIGN_FILE_FUNC_TABLE pSignFileFuncTable,
                IN void *pvSignFileArg,
                IN PCRYPT_ATTRIBUTE_TYPE_VALUE pIndirectDataContentAttr,
                IN DWORD dwFlags,
                OUT PBYTE* pbEncoding,
                OUT DWORD* cbEncoding);

//+-------------------------------------------------------------------------
//  Verify any type of file signed for software publishing.
//
//  pVerifyPara's pfnVerifySignerPolicy is called to verify the signer's
//  certificate.
//
//  For a verified signer and file, *ppSignerCert is updated
//  with the CertContext of the signer. It must be freed by calling
//  CertStoreFreeCert. Otherwise, *ppSignerCert is set to NULL.
//  For *pbcbDecoded == 0 on input, *ppSignerCert is always set to
//  NULL.
//
//  ppSignerCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext of the signer.
//
//  If specified, the attribute type of the indirect data content in the
//  file's signed data is compared with pszDataAttrObjId.
//
//  The SPC_DISABLE_DIGEST_FLAG inhibits the digesting of the file.
//  The SPC_DISABLE_VERIFY_SIGNATURE_FLAG inhibits the verification of the
//  the signed data in the file. The SPC_LENGTH_ONLY_FLAG isn't allowed and
//  returns an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
SpcVerifyFile(
    IN PSPC_VERIFY_PARA pVerifyPara,
    IN PCSPC_SIGN_FILE_FUNC_TABLE pSignFileFuncTable,
    IN void *pvSignFileArg,
    IN OPTIONAL LPSTR pszDataAttrObjId,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

//+-------------------------------------------------------------------------
//  SPC error codes
//--------------------------------------------------------------------------
#include "sgnerror.h"

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\trustcom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       trustcom.h
//
//  Contents:   Microsoft Internet Security COM interface
//
//  History:    14-Aug-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef TRUSTCOM_H
#define TRUSTCOM_H

#ifdef __cplusplus
extern "C" 
{
#endif

//////////////////////////////////////////////////////////////////////////////
//
// TrustSign
//----------------------------------------------------------------------------
//  Digitally signs the file.  The user will be prompted for signing 
//  certificate.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in  (the user will NOT be shown UI)
//
extern BOOL WINAPI TrustSign(HWND hWndCaller, WCHAR *pwszFile);

//////////////////////////////////////////////////////////////////////////////
//
// TrustVerify
//----------------------------------------------------------------------------
//  Digitally verifies the file.  The user will be presented UI if 
//  applicable.
//
// Returns:
//      TRUE:                           No fatal errors
//      FALSE:                          Errors occured.  See GetLastError()
//
// Last Errors:
//      ERROR_INVALID_PARAMETER:        bad argument passed in (the user will NOT be shown UI).
//
extern BOOL WINAPI TrustVerify(HWND hWndCaller, WCHAR *pwszFile);

#ifdef __cplusplus
}
#endif

#endif // TRUSTCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\sipprov.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipprov.h
//
//--------------------------------------------------------------------------

//
// sipprov.h
//
// Miscellaneous definitions to be shared between
// the pieces of our NT trust provider and its SIPs
//

//
// internal definitions that help us process things
//
typedef enum
    {
    SUBJTYPE_NONE            = 0,
    SUBJTYPE_FILE            = 1,
    SUBJTYPE_FILEANDDISPLAY  = 2
    } SUBJTYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\trustglu.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       trustglu.h
//
//--------------------------------------------------------------------------

//
// trustglue.h
//
// This is TEMPORARY housing for this data, permanent housing will
// be winbase.h
//

//////////////////////////////////////////////////////////////////
//
// Subject form for CAB files that uses WIN_TRUST_SUBJECT_FILE
//
//////////////////////////////////////////////////////////////////

#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }

//////////////////////////////////////////////////////////////////
//
// Extended subject forms that use the newer, improved subject
// form WIN_TWIN_TRUST_SUBJECT_FILE_AND_DISPLAY
//
//////////////////////////////////////////////////////////////////

#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }


//////////////////////////////////////////////////////////////////
//
// Subject forms
//
//////////////////////////////////////////////////////////////////

//
// from winbase.h
//
// typedef struct _WIN_TRUST_SUBJECT_FILE {
//
//    HANDLE  hFile;
//    LPCWSTR lpPath;
//
// } WIN_TRUST_SUBJECT_FILE, *LPWIN_TRUST_SUBJECT_FILE;
//

typedef struct _WIN_TRUST_SUBJECT_FILE_AND_DISPLAY {

    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user 
                                //      in place of path

} WIN_TRUST_SUBJECT_FILE_AND_DISPLAY, *LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\uihlpr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       uihlpr.h
//
//--------------------------------------------------------------------------

#ifndef _UIHLPR_H
#define _UIHLPR_H

//
// uihlpr.h : CryptUI helper functions.
//

#ifdef __cplusplus
extern "C" {
#endif

#include <wininet.h>

//+-------------------------------------------------------------------------
//  Check to see if a specified URL is http scheme.
//--------------------------------------------------------------------------
BOOL
WINAPI
IsHttpUrlA(
    IN LPCTSTR  pszUrlString
);

BOOL
WINAPI
IsHttpUrlW(
    IN LPCWSTR  pwszUrlString
);

//+-------------------------------------------------------------------------
// Check to see if a specified string is OK to be formatted as link based on
// severity of error code, and internet scheme of the string.
//--------------------------------------------------------------------------
BOOL
WINAPI
IsOKToFormatAsLinkA(
    IN LPSTR    pszUrlString,
    IN DWORD    dwErrorCode
);

BOOL
WINAPI
IsOKToFormatAsLinkW(
    IN LPWSTR   pwszUrlString,
    IN DWORD    dwErrorCode
);

//+-------------------------------------------------------------------------
// Return the display name for a cert. Caller must free the string by
// free().
//--------------------------------------------------------------------------
LPWSTR
WINAPI
GetDisplayNameString(
    IN  PCCERT_CONTEXT   pCertContext,
	IN  DWORD            dwFlags
);

#ifdef __cplusplus
}
#endif

#endif // _UIHLPR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\unicode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       unicode.h
//
//--------------------------------------------------------------------------

#ifndef __ECM_UNICODE_H__
#define __ECM_UNICODE_H__

// necessary defns -- remove?
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>

#include "commctrl.h"
#include "commdlg.h"
#include "prsht.h"
#include "shellapi.h"

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI FIsWinNT(void);
BOOL WINAPI FIsWinNT5(VOID);
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW, char ** pszMB, int *pcbConverted);
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB);
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB);

LPWSTR WINAPI MkWStr(char * szMB);
void WINAPI FreeWStr(LPWSTR wsz);


BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut);
BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut);

// The following is also needed for non-x86 due to the fact that the
// A/W versions of the ListView_ functions do not exist.
// (these are implemented in ispu\common\unicode\commctrl.cpp)
HTREEITEM WINAPI TreeView_InsertItemU(
    HWND hwndTV,
    LPTVINSERTSTRUCTW lpis
    );	

int WINAPI ListView_InsertItemU(
    HWND hwnd,
    const LPLVITEMW pitem
    );

void WINAPI ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPCWSTR pszText
    );

int WINAPI ListView_InsertColumnU(
    HWND hwnd,
    int i,
    const LPLVCOLUMNW plvC);

BOOL WINAPI ListView_GetItemU(
    HWND hwnd,
    LPLVITEMW pitem
    );


LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
    );

//
//  the following api's handle the problem with impersinating another user
//  and having the HKEY_CURRENT_USER opened to an incorrect user's SID.
//
LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    );

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    );

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to only open
// HKEY_USERS\.Default if the current user is the LocalSystem SID.
#define REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG     0x1

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to always disable the opening of
// HKEY_USERS\.Default. If HKEY_USERS\CurrentSid doesn't exist, RegOpenHKCUEx
// returns ERROR_FILE_NOT_FOUND.
#define REG_HKCU_DISABLE_DEFAULT_FLAG               0x2

LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    );

BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    );


#ifdef _M_IX86


// Reg.cpp
LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegDeleteKeyU(
    HKEY hKey,
    LPCWSTR lpSubKey
   );

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   );

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG WINAPI RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );

// File.cpp
HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
CopyFileU(
          LPCWSTR lpwExistingFileName,
          LPCWSTR lpwNewFileName,
          BOOL bFailIfExists
          );

BOOL
WINAPI
MoveFileExU(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags);

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
WINAPI
GetCurrentDirectoryU(
    DWORD nBufferLength,
    LPWSTR lpBuffer);

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
WINAPI
RemoveDirectoryU(
    LPCWSTR lpPathName
    );

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    );

UINT
WINAPI
GetTempFileNameU(
    IN LPCWSTR lpPathName,
    IN LPCWSTR lpPrefixString,
    IN UINT uUnique,
    OUT LPWSTR lpTempFileName
    );

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    );

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );

HANDLE
WINAPI
FindFirstFileU(
    IN LPCWSTR pwszDir,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    );

BOOL
WINAPI
FindNextFileU(
    IN HANDLE hFindFile,
    OUT LPWIN32_FIND_DATAW lpFindFileData
    );

HANDLE
WINAPI
FindFirstChangeNotificationU(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );


// capi.cpp

BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

BOOL WINAPI CryptEnumProvidersU(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR pwszProvName,
    DWORD *pcbProvName
    );

BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags
    );

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType
    );

// Ole.cpp
RPC_STATUS RPC_ENTRY UuidToStringU(
    UUID *  Uuid,
    WCHAR * *  StringUuid
   );

// nt.cpp
BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
   );

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
   );

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   );

// user.cpp
int WINAPI LoadStringU(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
   );

BOOL
WINAPI
InsertMenuU(
    HMENU       hMenu,
    UINT        uPosition,
    UINT        uFlags,
    UINT_PTR    uIDNewItem,
    LPCWSTR     lpNewItem
    );


DWORD WINAPI FormatMessageU(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
   );

int
WINAPI
CompareStringU(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR  lpString1,
    int      cchCount1,
    LPCWSTR  lpString2,
    int      cchCount2);

INT_PTR WINAPI PropertySheetU(
    LPPROPSHEETHEADERW  lppsph);

HPROPSHEETPAGE WINAPI CreatePropertySheetPageU(LPCPROPSHEETPAGEW    pPage);

UINT WINAPI     DragQueryFileU(
    HDROP   hDrop,
    UINT    iFile,
    LPWSTR  lpwszFile,
    UINT    cch);


BOOL WINAPI SetWindowTextU(
    HWND hWnd,
    LPCWSTR lpString
   );

int WINAPI GetWindowTextU(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount
   );

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam
    );

int WINAPI DialogBoxU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc
    );

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount
   );

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString
    );

int WINAPI MessageBoxU(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

int WINAPI LCMapStringU(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest
    );

int WINAPI GetDateFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate
    );

int WINAPI GetTimeFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
    );

BOOL WINAPI WinHelpU(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );

LRESULT WINAPI SendMessageU(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG WINAPI
SendDlgItemMessageU(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LPWSTR
WINAPI
GetCommandLineU(void);

BOOL
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax);

void
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz);

int
WINAPI
DrawTextU(
    HDC     hDC,
    LPCWSTR lpString,
    int     nCount,
    LPRECT  lpRect,
    UINT    uFormat
);

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL
WINAPI
GetSaveFileNameU(
    LPOPENFILENAMEW pOpenFileName
);

//
// NOTE the following fields in LPOPENFILENAMEW are NOT supported:
//      nFileOffset
//      nFileExtension
//      lpTemplateName
//
BOOL
WINAPI
GetOpenFileNameU(
    LPOPENFILENAMEW pOpenFileName
);

// event.cpp
HANDLE
WINAPI
CreateEventU(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName);

HANDLE
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
                    LPCWSTR lpSourceName);

HANDLE
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HANDLE
WINAPI
CreateMutexU(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName);

HANDLE
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf);

#else

#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define MoveFileExU             MoveFileExW
#define GetTempFileNameU        GetTempFileNameW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define RemoveDirectoryU        RemoveDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define FindFirstFileU          FindFirstFileW
#define FindNextFileU           FindNextFileW
#define FindFirstChangeNotificationU    FindFirstChangeNotificationW

#define CryptAcquireContextU    CryptAcquireContextW
#define CryptEnumProvidersU     CryptEnumProvidersW
#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define InsertMenuU             InsertMenuW
#define FormatMessageU          FormatMessageW
#define	CompareStringU			CompareStringW
#define PropertySheetU          PropertySheetW
#define CreatePropertySheetPageU    CreatePropertySheetPageW
#define DragQueryFileU          DragQueryFileW
#define SetWindowTextU          SetWindowTextW
#define GetWindowTextU          GetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define DialogBoxU              DialogBoxW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU     MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW
#define GetSaveFileNameU        GetSaveFileNameW
#define GetOpenFileNameU        GetOpenFileNameW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif // _M_IX86

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\vercert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       vercert.h
//
//--------------------------------------------------------------------------

#ifndef _VERCERT_

#define _VERCERT_

#define	CRYPT_SAVE_CERTS_IN_CA_STORE			0x01
#define	CRYPT_SAVE_PERSONAL_CERT_IN_MY_STORE		0x02
#define	CRYPT_SAVE_SELFSIGN_CERT_IN_ROOT_STORE		0x04
#define	CRYPT_NO_PROP_ENHANCED_KEY_USAGE		0x08
#define	CRYPT_NO_EXT_ENHANCED_KEY_USAGE			0x10
#define	CRYPT_NO_REVOCATION_CHECKS			0x20
#define	CRYPT_NO_ROOT_REVOCATION_CHECKS			0x40

extern "C" BOOL WINAPI CryptVerifyCertificate(
	PCCERT_CONTEXT pCert,
   	LPCSTR szEKU,
	DWORD flags);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\unicode5.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       unicode5.h
//
//--------------------------------------------------------------------------

//
// include this file instead of unicode.h, or after unicode.h
// for NT5 only compatibility.
//

#ifndef __UNICODE5_H__
#define __UNICODE5_H__

#define FIsWinNT() (TRUE)
#define FIsWinNT5() (TRUE)


#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define MoveFileExU             MoveFileExW
#define GetTempFileNameU        GetTempFileNameW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define InsertMenuU             InsertMenuW
#define FormatMessageU          FormatMessageW
#define PropertySheetU          PropertySheetW
#define CreatePropertySheetPageU    CreatePropertySheetPageW
#define DragQueryFileU          DragQueryFileW
#define SetWindowTextU          SetWindowTextW
#define GetWindowTextU          GetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define DialogBoxU              DialogBoxW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU             MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW
#define GetSaveFileNameU        GetSaveFileNameW
#define GetOpenFileNameU        GetOpenFileNameW
#define CreateFileMappingU      CreateFileMappingW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif  // __UNICODE5_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\voidlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       voidlist.h
//
//  Contents:   definitions for list functions
//
//  History:    01-Jan-2000 reidk created
//
//--------------------------------------------------------------------------


#ifndef __VOIDLIST_H
#define __VOIDLIST_H

#ifdef __cplusplus
extern "C"
{
#endif


typedef struct LIST_NODE_
{
    void *pNext;
    void *pElement;

} LIST_NODE, *PLIST_NODE;


typedef struct LIST_
{
    LIST_NODE   *pHead;
    LIST_NODE   *pTail;
    DWORD       dwNumNodes;

} LIST, *PLIST;


void
LIST_Initialize(LIST *pList);

PLIST_NODE
LIST_AddHead(LIST *pList, void *pElement);

PLIST_NODE
LIST_AddTail(LIST *pList, void *pElement);

BOOL
LIST_RemoveElement(LIST *pList, void *pElement);

BOOL
LIST_RemoveAll(LIST *pList);

PLIST_NODE
LIST_GetFirst(LIST *pList);

PLIST_NODE
LIST_GetNext(PLIST_NODE pNode);

void *
LIST_GetElement(PLIST_NODE pNode);


#ifdef __cplusplus
}
#endif


#endif // __VOIDLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\waitsvc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       waitsvc.h
//
//--------------------------------------------------------------------------

#ifndef __WAITSVC_H__
#define __WAITSVC_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// routine called by code that calls into the Cryptography service (ProtectedStorage)
// code that makes RPC calls into the service should call this function before
// making the RPC bind call.
//

BOOL
WaitForCryptService(
    IN      LPWSTR  pwszService,
    IN      BOOL    *pfDone,
    IN      BOOL    fLogErrors = FALSE);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __WAITSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\winchain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       winchain.h
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    15-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__WINCHAIN_H__)
#define __WINCHAIN_H__

#include <wincrypt.h>

#if defined(__cplusplus)
extern "C" {
#endif

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\whctl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       whctl.h
//
//  Contents:   Windows Hardware Compatibility Trust Provider
//              API Prototypes and Definitions
//
//--------------------------------------------------------------------------

#ifndef _WHCTL_H_
#define _WHCTL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WHCTL_SOURCE_
#define WHCTLAPI __stdcall
#else
#define WHCTLAPI DECLSPEC_IMPORT __stdcall
#endif


#define WHCTL_KEY_PURPOSE_OBJID "1.3.6.1.4.1.311.2.1.28"

/* WindowsCompatibleHardware = 8aa7fc60-101b-11d0-ad9a-00a0c90833eb */
#define WIN_HCTL_ACTION_WINDOWS_COMPATIBLE                  \
        { 0x8aa7fc60,                                       \
          0x101b,                                           \
          0x11d0,                                           \
          {0xad, 0x9a, 0x00, 0xa0, 0xc9, 0x08, 0x33, 0xeb}  \
        }


#define REGSTR_PATH_WHCTL REGSTR_PATH_SERVICES "\\WinTrust\\TrustProviders\\Windows Compatible Hardware"


#ifdef __cplusplus
}
#endif

#endif //_WHCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\wintrold.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       wintrold.h
//
//--------------------------------------------------------------------------

#ifndef WINTROLD_H
#define WINTROLD_H


/************************************************************************
*                                                                       *
*   wintrust.h -- This module defines the 32-Bit WinTrust definitions   *
*                 needed to build Trust Providers and / Subject         *
*                 Interface Packages.                                   *
*                                                                       *
*   Copyright (c) 1990-1996, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _WINTRUST_
#define _WINTRUST_ 

#ifdef __cplusplus
extern "C" {
#endif



/***********************************************************************
*                                                                      *
* This section contains definitions related to:                        *
*                                                                      *
*                           WinTrust in general                        *
*                                                                      *
************************************************************************/


//
// WinTrust Revisioning
//
#define WIN_TRUST_MAJOR_REVISION_MASK       0xFFFF0000
#define WIN_TRUST_MINOR_REVISION_MASK       0x0000FFFF
#define WIN_TRUST_REVISION_1_0              0x00010000




/***********************************************************************
*                                                                      *
* This section contains definitions related to:                        *
*                                                                      *
*                           Subject Interface Packages                 *
*                                                                      *
************************************************************************/

//
// Allows passing of subject and type material.
//

typedef struct _WIN_TRUST_SIP_SUBJECT {
    GUID *                  SubjectType;
    WIN_TRUST_SUBJECT       Subject;
} WIN_TRUST_SIP_SUBJECT, *LPWIN_TRUST_SIP_SUBJECT;

//
// Templates of services that must be EXPORTED by SIPs
// FOR USE by Trust Providers (calling through WinTrust).
//

typedef BOOL
( *LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,          // pointer to subject info
    IN     LPWIN_CERTIFICATE                lpSignedData       // PKCS #7 Signed Data
    );

typedef BOOL
( *LPWINTRUST_SUBJECT_ENUM_CERTIFICATES)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,          // pointer to subject info
    IN     DWORD                            dwTypeFilter,       // 0 or WIN_CERT_TYPE_xxx
    OUT    LPDWORD                          lpCertificateCount,
    IN OUT LPDWORD                          lpIndices,          // Rcvs WIN_CERT_TYPE_
    IN     DWORD                            dwIndexCount
    );

typedef BOOL
( *LPWINTRUST_SUBJECT_GET_CERTIFICATE)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,
    IN     DWORD                            dwCertificateIndex,
    OUT    LPWIN_CERTIFICATE                lpCertificate,
    IN OUT LPDWORD                          lpRequiredLength
    );

typedef BOOL
( *LPWINTRUST_SUBJECT_GET_CERT_HEADER)(
    IN     LPWIN_TRUST_SIP_SUBJECT          lpSubject,
    IN     DWORD                            dwCertificateIndex,
    OUT    LPWIN_CERTIFICATE                lpCertificateHeader
    );

typedef BOOL
(*LPWINTRUST_SUBJECT_GET_NAME)(
    IN     LPWIN_TRUST_SIP_SUBJECT      lpSubject, 
    IN     LPWIN_CERTIFICATE            lpSignedData,
    IN OUT LPWSTR                       lpBuffer,
    IN OUT LPDWORD                      lpRequiredLength
    );
    
typedef DWORD
(*LPWINTRUST_PROVIDER_PING) (
    IN      LPWSTR              lpProviderName,
    IN      DWORD               dwClientParameter,
    OUT     LPDWORD             lpdwServerReturnValue
    );


typedef struct _WINTRUST_SIP_DISPATCH_TABLE
{
    LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO   CheckSubjectContentInfo;
    LPWINTRUST_SUBJECT_ENUM_CERTIFICATES    EnumSubjectCertificates;
    LPWINTRUST_SUBJECT_GET_CERTIFICATE      GetSubjectCertificate;
    LPWINTRUST_SUBJECT_GET_CERT_HEADER      GetSubjectCertHeader;
    LPWINTRUST_SUBJECT_GET_NAME             GetSubjectName;

} WINTRUST_SIP_DISPATCH_TABLE, *LPWINTRUST_SIP_DISPATCH_TABLE;



//
// Structure describing an individual SIP.
//
// This structure is passed back to WinTrust from a Subject Interface Package
// initialization call.
//
typedef struct _WINTRUST_SIP_INFO {
    DWORD                               dwRevision;
    LPWINTRUST_SIP_DISPATCH_TABLE       lpServices;
    DWORD                               dwSubjectTypeCount;
    GUID *                              lpSubjectTypeArray;
} WINTRUST_SIP_INFO, *LPWINTRUST_SIP_INFO;



//
// SIP Intialization routine.
// SIP DLLs are required to have a routine named:
//
//                          WinTrustSipInitialize.
//
// This initialization routine must have the following
// definition:
//

typedef BOOL
(*LPWINTRUST_SUBJECT_PACKAGE_INITIALIZE)(
    IN     DWORD                            dwWinTrustRevision,
    OUT    LPWINTRUST_SIP_INFO              *lpSipInfo
    );




/***********************************************************************
*                                                                      *
* This section contains definitions related to:                        *
*                                                                      *
*                           Trust Providers                            *
*                                                                      *
************************************************************************/


//
// This should be with the other SPUB GUIDs in winbase.h
//
// PublishedSoftwareNoBad {C6B2E8D0-E005-11cf-A134-00C04FD7BF43}
#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI              \
            { 0xc6b2e8d0,                                       \
              0xe005,                                           \
              0x11cf,                                           \
              { 0xa1, 0x34, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x43 } \
             }


//
// Dispatch table of WinTrust services available to Trust Providers
//
// Client side...

typedef struct _WINTRUST_CLIENT_TP_DISPATCH_TABLE
{
    LPWINTRUST_PROVIDER_PING                ServerPing;
    LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO   CheckSubjectContentInfo;
    LPWINTRUST_SUBJECT_ENUM_CERTIFICATES    EnumSubjectCertificates;
    LPWINTRUST_SUBJECT_GET_CERTIFICATE      GetSubjectCertificate;
    LPWINTRUST_SUBJECT_GET_CERT_HEADER      GetSubjectCertHeader;
    LPWINTRUST_SUBJECT_GET_NAME             GetSubjectName;
    
} WINTRUST_CLIENT_TP_DISPATCH_TABLE, *LPWINTRUST_CLIENT_TP_DISPATCH_TABLE;


// Server side...

typedef struct _WINTRUST_SERVER_TP_DISPATCH_TABLE
{
    LPWINTRUST_SUBJECT_CHECK_CONTENT_INFO   CheckSubjectContentInfo;
    LPWINTRUST_SUBJECT_ENUM_CERTIFICATES    EnumSubectCertificates;
    LPWINTRUST_SUBJECT_GET_CERTIFICATE      GetSubjectCertificate;
    LPWINTRUST_SUBJECT_GET_CERT_HEADER      GetSubjectCertHeader;
    LPWINTRUST_SUBJECT_GET_NAME             GetSubjectName;
    
} WINTRUST_SERVER_TP_DISPATCH_TABLE, *LPWINTRUST_SERVER_TP_DISPATCH_TABLE;


//
// The following structures are passed by WinTrust to a
// Trust Provider being initialized.
//
// Client side...

typedef struct _WINTRUST_CLIENT_TP_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_CLIENT_TP_DISPATCH_TABLE     lpServices;
} WINTRUST_CLIENT_TP_INFO,  *LPWINTRUST_CLIENT_TP_INFO;

// Server side
typedef struct _WINTRUST_SERVER_TP_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_SERVER_TP_DISPATCH_TABLE     lpServices;
} WINTRUST_SERVER_TP_INFO,  *LPWINTRUST_SERVER_TP_INFO;


//
// Templates of Trust Provider services available to WinTrust
//
typedef LONG
(*LPWINTRUST_PROVIDER_VERIFY_TRUST) (
    IN     HWND                             hwnd,
    IN     GUID *                           ActionID,
    IN     LPVOID                           ActionData
    );

typedef VOID
(*LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE) (
    IN     LPWIN_CERTIFICATE                lpCertificate
    );

typedef VOID
(*LPWINTRUST_PROVIDER_CLIENT_UNLOAD) (
    IN     LPVOID                           lpTrustProviderInfo
    );

typedef VOID
(*LPWINTRUST_PROVIDER_SERVER_UNLOAD) (
    IN     LPVOID                           lpTrustProviderInfo
    );

//
// Dispatch table of Trust provider services available for use by WinTrust
//
//  Client side...

typedef struct _WINTRUST_PROVIDER_CLIENT_SERVICES
{
    LPWINTRUST_PROVIDER_CLIENT_UNLOAD       Unload;
    LPWINTRUST_PROVIDER_VERIFY_TRUST        VerifyTrust;
    LPWINTRUST_PROVIDER_SUBMIT_CERTIFICATE  SubmitCertificate;
    
} WINTRUST_PROVIDER_CLIENT_SERVICES, *LPWINTRUST_PROVIDER_CLIENT_SERVICES;


typedef struct _WINTRUST_PROVIDER_SERVER_SERVICES
{
    LPWINTRUST_PROVIDER_SERVER_UNLOAD       Unload;
    LPWINTRUST_PROVIDER_PING                Ping;
    
} WINTRUST_PROVIDER_SERVER_SERVICES, *LPWINTRUST_PROVIDER_SERVER_SERVICES;


//
// This structure is passed back from the client-side Trust Provider
// following initialization of that Trust Provider.
//
typedef struct _WINTRUST_PROVIDER_CLIENT_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_PROVIDER_CLIENT_SERVICES     lpServices;
    DWORD                                   dwActionIdCount;
    GUID *                                  lpActionIdArray;
} WINTRUST_PROVIDER_CLIENT_INFO, *LPWINTRUST_PROVIDER_CLIENT_INFO;

//
// This structure is passed back from the server-side trust provider following
// initialization of that trust provider.
//
typedef struct _WINTRUST_PROVIDER_SERVER_INFO {
    DWORD                                   dwRevision;
    LPWINTRUST_PROVIDER_SERVER_SERVICES     lpServices;
} WINTRUST_PROVIDER_SERVER_INFO, *LPWINTRUST_PROVIDER_SERVER_INFO;





//
// Trust Provider Initialization Routines
// Each Trust Provider DLL must have a client and server side initialization
// routine.  The routines must be named:
//
//              WinTrustProviderClientInitialize()
//      and
//              WinTrustProviderServerInitialize()
//
// and must be defined to match the following templates...
//
typedef BOOL
(*LPWINTRUST_PROVIDER_CLIENT_INITIALIZE)(
    IN     DWORD                                dwWinTrustRevision,
    IN     LPWINTRUST_CLIENT_TP_INFO            lpWinTrustInfo,
    IN     LPWSTR                               lpProviderName,
    OUT    LPWINTRUST_PROVIDER_CLIENT_INFO      *lpTrustProviderInfo
    );

typedef BOOL
(*LPWINTRUST_PROVIDER_SERVER_INITIALIZE) (
    IN     DWORD                            dwWinTrustRevision,
    IN     LPWINTRUST_SERVER_TP_INFO        lpWinTrustInfo,
    IN     LPWSTR                           lpProviderName,
    OUT    LPWINTRUST_PROVIDER_SERVER_INFO  *lpTrustProviderInfo
    );


#ifdef __cplusplus
}
#endif
                   
#endif // _WINTRUST_




#endif // WINTROLD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\wvtver1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wvtver1.h
//
//  Contents:   Microsoft Internet Security WinVerifyTrust v1 support
//
//  History:    31-May-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WVTVER1_H
#define WVTVER1_H

#define V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE_NOBADUI           \
            { 0xc6b2e8d0,                                       \
              0xe005,                                           \
              0x11cf,                                           \
              { 0xa1, 0x34, 0x0, 0xc0, 0x4f, 0xd7, 0xbf, 0x43 } \
             }

#define V1_WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                    \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }

extern BOOL             WintrustIsVersion1ActionID(GUID *pgActionID);
extern WINTRUST_DATA    *ConvertDataFromVersion1(HWND hWnd,
                                                 GUID *pgActionID,
                                                 WINTRUST_DATA *pWTDNew, 
                                                 WINTRUST_FILE_INFO *pWTFINew,
                                                 LPVOID pWTDOld);


#endif // WVTVER1_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\inc\xelib.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       xelib.h
//
//  Contents:   defines and prototypes for functions moved from ca
//
//----------------------------------------------------------------------------
#ifndef _XELIB_H_
#define _XELIB_H_

#include <certca.h>
#define SECURITY_WIN32
#include <security.h>	// for EXTENDED_NAME_FORMAT

//defines
#define CCLOCKSKEWMINUTESDEFAULT	      10
#define CBMAX_CRYPT_HASH_LEN                  20

#define DWORDROUND(cb)	(((cb) + (sizeof(DWORD) - 1)) & ~(sizeof(DWORD) - 1))
#define POINTERROUND(cb) (((cb) + (sizeof(VOID *) - 1)) & ~(sizeof(VOID *) - 1))

// Constants chosen to avoid DWORD overflow:
#define CVT_WEEKS	(7 * CVT_DAYS)
#define CVT_DAYS	(24 * CVT_HOURS)
#define CVT_HOURS	(60 * CVT_MINUTES)
#define CVT_MINUTES	(60 * CVT_SECONDS)
#define CVT_SECONDS	(1)
#define CVT_BASE	(1000 * 1000 * 10)


// _XENROLL_SRC_ allows cs.h to define its own macros
#if defined(_XENROLL_SRC_) || defined(_XELIBCA_SRC_) || defined(__CERTLIB_H__)

// Size of a fixed array:
#define ARRAYSIZE(a)		((DWORD) (sizeof(a)/sizeof((a)[0])))

#ifndef CSASSERT
#if DBG
# include <assert.h>
# include <string.h>
# define CSASSERT(exp)	assert(exp)

__inline char const *
_DBGBASENAME(IN char const *pszFile)
{
    char const *psz = strrchr(pszFile, '\\');
    if (NULL == psz)
    {
	psz = pszFile;
    }
    else
    {
	psz++;
    }
    return(psz);
}

# define DBGPRINTF(pszMessage, hr) \
            DbgPrintf(DBG_SS_APP,  \
                "%hs(%u): %hs: error 0x%x\n", \
		_DBGBASENAME(__FILE__), \
                __LINE__, \
                pszMessage, \
                hr)
#else
# define CSASSERT(exp)
# define DBGPRINTF(pszMessage, hr)
#endif //DBG

#define _JumpIfError(hr, label, pszMessage) \
    { \
        if (S_OK != (hr)) \
        { \
            DBGPRINTF(pszMessage, hr); \
            goto label; \
        } \
    }

#define _JumpError(hr, label, pszMessage) \
    { \
        DBGPRINTF(pszMessage, hr); \
        goto label; \
    }

#define _PrintError(hr, pszMessage) \
    { \
        DBGPRINTF(pszMessage, hr); \
    }

#define _PrintIfError(hr, pszMessage) \
    { \
        if (S_OK != (hr)) \
        { \
            DBGPRINTF(pszMessage, hr); \
        } \
    }
#endif //CSASSERT

#if !defined(_XENROLL_SRC_)
# if DBG

#define LocalFree		myLocalFree
#define SysFreeString		mySysFreeString
#define LocalReAlloc            myLocalReAlloc
#define LocalAlloc		myLocalAlloc
#define CoTaskMemAlloc		myCoTaskMemAlloc
#define SysAllocStringByteLen	mySysAllocStringByteLen
#define CoTaskMemFree		myCoTaskMemFree
#define FormatMessageW		myFormatMessageW
#define CoTaskMemRealloc        myCoTaskMemRealloc
#define StringFromCLSID		myStringFromCLSID
#define StringFromIID		myStringFromIID
#define SysAllocString		mySysAllocString
#define SysReAllocString        mySysReAllocString
#define SysAllocStringLen	mySysAllocStringLen
#define SysReAllocStringLen     mySysReAllocStringLen
#define PropVariantClear	myPropVariantClear
#define VariantClear		myVariantClear
#define VariantChangeType	myVariantChangeType
#define VariantChangeTypeEx	myVariantChangeTypeEx
#define AllocateAndInitializeSid myAllocateAndInitializeSid
#define FreeSid			myFreeSid

void *myNew(IN size_t size);
void myDelete(IN void *pv);

__inline void *__cdecl operator new(
    IN size_t size)
{
    return(myNew(size));
}

__inline void __cdecl operator delete(
    IN void *pv)
{
    return(myDelete(pv));
}


DWORD
myFormatMessageW(
    IN DWORD dwFlags,
    IN LPCVOID lpSource,
    IN DWORD dwMessageId,
    IN DWORD dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN DWORD nSize,
    IN va_list *Arguments);

HLOCAL
myLocalAlloc(
    IN UINT uFlags,
    IN UINT uBytes);

HLOCAL
myLocalReAlloc(
    IN HLOCAL hMem,
    IN UINT uBytes,
    IN UINT uFlags);

HLOCAL
myLocalFree(
    IN HLOCAL hMem);

VOID *
myCoTaskMemAlloc(
    IN ULONG cb);

VOID *
myCoTaskMemRealloc(
    IN VOID *pv,
    IN ULONG cb);

VOID
myCoTaskMemFree(
    IN VOID *pv);

HRESULT
myStringFromCLSID(
    IN REFCLSID rclsid,
    OUT LPOLESTR FAR* lplpsz);

HRESULT
myStringFromIID(
    IN REFIID rclsid,
    OUT LPOLESTR FAR* lplpsz);

BSTR
mySysAllocString(
    IN const OLECHAR *pwszIn);

INT
mySysReAllocString(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwszIn);

BSTR
mySysAllocStringLen(
    IN const OLECHAR *pwcIn,
    IN UINT cwc);

INT
mySysReAllocStringLen(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwcIn,
    IN UINT cwc);

VOID
mySysFreeString(
    IN BSTR str);

HRESULT
myPropVariantClear(
    IN PROPVARIANT *pvar);

HRESULT
myVariantClear(
    IN VARIANTARG *pvar);

HRESULT
myVariantChangeType(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN unsigned short wFlags,
    IN VARTYPE vt);

HRESULT
myVariantChangeTypeEx(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN LCID lcid,
    IN unsigned short wFlags,
    IN VARTYPE vt);

BSTR
mySysAllocStringByteLen(
    LPCSTR pszIn,
    UINT cb);

BOOL
myAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    IN BYTE nSubAuthorityCount,
    IN DWORD nSubAuthority0,
    IN DWORD nSubAuthority1,
    IN DWORD nSubAuthority2,
    IN DWORD nSubAuthority3,
    IN DWORD nSubAuthority4,
    IN DWORD nSubAuthority5,
    IN DWORD nSubAuthority6,
    IN DWORD nSubAuthority7,
    OUT PSID *pSid);

VOID *
myFreeSid(
    IN PSID pSid);

#define CSM_LOCALALLOC		0
#define CSM_COTASKALLOC		1
#define CSM_SYSALLOC		2
#define CSM_MALLOC		3
#define CSM_NEW			4
#define CSM_SID			5
#define CSM_MAX			6
#define CSM_MASK		0xff
#define CSM_MIDLUSERALLOC	CSM_COTASKALLOC
#define CSM_VARIANT		100
#define CSM_GLOBALDESTRUCTOR	0x200
#define CSM_TRACEASSERT		0x400

VOID
myRegisterMemDump(VOID);

VOID
myRegisterMemAlloc(
    IN VOID const *pv,
    IN LONG cb,
    IN DWORD Flags);

VOID
myRegisterMemFree(
    IN VOID const *pv,
    IN DWORD Flags);

# else //DBG

#define myRegisterMemDump()
#define myRegisterMemAlloc(pv, cb, Flags)
#define myRegisterMemFree(pv, Flags)

# endif //DBG
#endif //!defined(_XENROLL_SRC_)


// SUNDOWN-Safe pointer subtraction

#ifndef SAFE_SUBTRACT_POINTERS
#define SAFE_SUBTRACT_POINTERS(__x__, __y__) ( DW_PtrDiffc(__x__, sizeof(*(__x__)), __y__, sizeof(*(__y__))) )

#pragma warning(push)
#pragma warning(disable: 4100)        // unreferenced formal parameter
__inline DWORD
DW_PtrDiffc(
    IN void const *pb1,
    IN DWORD dwPtrEltSize1,
    IN void const *pb2,
    IN DWORD dwPtrEltSize2)
{
    // pb1 should be greater
    CSASSERT((ULONG_PTR)pb1 >= (ULONG_PTR)pb2);

    // both should have same elt size
    CSASSERT(dwPtrEltSize1 == dwPtrEltSize2);

    // assert that the result doesn't overflow 32-bits
    CSASSERT((DWORD)((ULONG_PTR)pb1 - (ULONG_PTR)pb2) == (ULONG_PTR)((ULONG_PTR)pb1 - (ULONG_PTR)pb2));

    // return number of objects between these pointers
    return (DWORD) ( ((ULONG_PTR)pb1 - (ULONG_PTR)pb2) / dwPtrEltSize1 );
}
#pragma warning(pop)
#endif SAFE_SUBTRACT_POINTERS

#endif //defined(_XENROLL_SRC_) || defined(__CERTLIB_H__)

//xenroll implemented apis but called in xelib but not ca
PCCRYPT_OID_INFO
WINAPI
xeCryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    );

//types

enum CERTLIB_ALLOCATOR {
    CERTLIB_NO_ALLOCATOR = 0,
    CERTLIB_USE_COTASKMEMALLOC = 1,
    CERTLIB_USE_LOCALALLOC = 2,
    CERTLIB_USE_NEW = 3,
};

//prototypes

VOID *
myAlloc(IN size_t cbBytes, IN CERTLIB_ALLOCATOR allocType);

VOID
myFree(IN VOID *pv, IN CERTLIB_ALLOCATOR allocType);

HRESULT
myHError(IN HRESULT hr);

HRESULT
myHLastError(VOID);

BOOL
myEncodeObject(
    DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

BOOL
myDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo);

BOOL WINAPI
myCryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,            // AT_SIGNATURE | AT_KEYEXCHANGE
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_PUBLIC_KEY_INFO **ppPubKey,
    OUT DWORD *pcbPubKey);

HRESULT
myEncodeSignedContent(
    IN HCRYPTPROV hProv,
    IN DWORD dwCertEncodingType,
    IN char const *pszObjIdSignatureAlgorithm,
    IN BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned);

VOID
myMakeExprDateTime(
    IN OUT FILETIME *pft,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod);

HRESULT
myCryptMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData);

HRESULT
MultiByteIntegerToBstr(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OUT BSTR *pstrOut);

HRESULT
MultiByteIntegerToWszBuf(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT WCHAR *pwszOut);

typedef struct _CRYPT_REQUEST_CLIENT_INFO
{
    DWORD  dwClientId;
    WCHAR *pwszUser;
    WCHAR *pwszMachine;
    WCHAR *pwszProcess;
} CRYPT_REQUEST_CLIENT_INFO;

HRESULT
myEncodeUTF8String(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myDecodeUTF8String(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszOut);

HRESULT
myEncodeRequestClientAttribute(
    IN CRYPT_REQUEST_CLIENT_INFO const *pcrci,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myDecodeRequestClientAttribute(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CRYPT_REQUEST_CLIENT_INFO **ppcrci);

HRESULT
myEncodeRequestClientAttributeFromClientId(
    IN DWORD dwClientId,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut);

HRESULT
myGetUserNameEx(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszUserName);

HRESULT
myGetMachineDnsName(
    OUT WCHAR **ppwszDnsName);

HRESULT
myGetProcessName(
    OUT WCHAR **ppwszProcessName);

#define wszCNXCHGSUFFIX		L"-Xchg"
#define cchCOMMONNAMEMAX_XELIB	64

HRESULT
myAddNameSuffix(
    IN WCHAR const *pwszValue,
    IN WCHAR const *pwszSuffix,
    IN DWORD cwcNameMax,
    OUT WCHAR **ppwszOut);

HRESULT
BuildCMCAttributes(
    IN DWORD cAttribute,
    IN CRYPT_ATTRIBUTE const *rgAttribute,
    IN DWORD dwCMCDataReference,
    IN DWORD dwBodyPartIdOfRequest,
    IN DWORD dwBodyPartId,
    OUT CMC_TAGGED_ATTRIBUTE *pTaggedAttribute,
    OUT CRYPT_ATTR_BLOB *pBlob);

HRESULT
BuildCMCRequest(
    IN DWORD dwClientId,
    IN BOOL fNestedCMCRequest,
    IN BYTE const *pbReq,
    IN DWORD cbReq,
    OPTIONAL IN CERT_EXTENSION const *rgExt,
    IN DWORD cExt,
    OPTIONAL IN CRYPT_ATTRIBUTES const *rgAttributes,
    IN DWORD cAttributes,
    OPTIONAL IN CRYPT_ATTRIBUTE const *rgAttributeUnauth,
    IN DWORD cAttributeUnauth,
    OPTIONAL IN BYTE const *pbKeyIdRequest,
    IN DWORD cbKeyIdRequest,
    OPTIONAL IN HCRYPTPROV hProvRequest,
    IN DWORD dwKeySpecRequest,
    OPTIONAL IN LPCSTR pszOIDSignHashRequest,
    OPTIONAL IN CERT_CONTEXT const *pCertSigner,
    OPTIONAL IN HCRYPTPROV hProvSigner,
    IN DWORD dwKeySpecSigner,
    OPTIONAL IN LPCSTR pszObjIdHashSigner,
    OUT BYTE **ppbReqCMC,
    OUT DWORD *pcbReqCMC);

typedef struct _XCMCRESPONSE
{
    CMC_STATUS_INFO  StatusInfo;
    WCHAR           *pwszBodyPart;	// Body Part Id string: "1.3.3.1"
    BYTE	    *pbCertHash;
    DWORD            cbCertHash;
    BYTE	    *pbEncryptedKeyHash;
    DWORD            cbEncryptedKeyHash;
} XCMCRESPONSE;

HRESULT
ParseCMCResponse(
    IN BYTE *pbResponse,
    IN DWORD cbResponse,
    OPTIONAL OUT HCERTSTORE *phStoreResponse,
    OUT XCMCRESPONSE **prgResponse,
    OUT DWORD *pcResponse);

VOID
FreeCMCResponse(
    IN XCMCRESPONSE *rgResponse,
    IN DWORD cResponse);

HRESULT
myDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut);

HRESULT
myDecodePKCS7(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT BYTE **ppbContents,
    OPTIONAL OUT DWORD *pcbContents,
    OPTIONAL OUT DWORD *pdwMsgType,
    OPTIONAL OUT char **ppszInnerContentObjId,
    OPTIONAL OUT DWORD *pcSigner,
    OPTIONAL OUT DWORD *pcRecipient,
    OPTIONAL OUT HCERTSTORE *phStore,
    OPTIONAL OUT HCRYPTMSG *phMsg);

HRESULT
myGetPublicKeyHash(
    OPTIONAL IN CERT_INFO const *pCertInfo,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData);

HRESULT
myCreateSubjectKeyIdentifierExtension(
    IN CERT_PUBLIC_KEY_INFO const *pPubKey,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded);

HRESULT
myCalculateKeyArchivalHash(
    IN const BYTE     *pbEncryptedKey,
    IN DWORD           cbEncryptedKey,
    OUT BYTE         **ppbHash,
    OUT DWORD         *pcbHash);

HRESULT
myInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut);

HRESULT
myInternetUncanonicalizeURL(
    IN WCHAR const *pwszURLIn,
    OUT WCHAR **ppwszURLOut);

BOOL
myConvertWszToUTF8(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc);

BOOL
myConvertWszToSz(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc);

BOOL
myConvertUTF8ToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch);

BOOL
myConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN CHAR const *pch,
    IN LONG cch);

VOID
mydbgDumpHex(
    IN DWORD dwSubSysId,
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb);

#endif //_XELIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\accdbg.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:        accdbg.h
//
//  Contents:    debug internal includes for
//
//  History:     8-94        Created         DaveMont
//
//--------------------------------------------------------------------
#ifndef __ACCDEBUGHXX__
#define __ACCDEBUGHXX__

#include <dsysdbg.h>

#if DBG == 1

    #ifdef ASSERT
        #undef ASSERT
    #endif

    #define ASSERT DsysAssert

    DECLARE_DEBUG2(ac)

    #define DEB_TRACE_API           0x08
    #define DEB_TRACE_ACC           0x10
    #define DEB_TRACE_CACHE         0x20
    #define DEB_TRACE_PROP          0x40
    #define DEB_TRACE_SD            0x80
    #define DEB_TRACE_SID           0x100
    #define DEB_TRACE_LOOKUP        0x200
    #define DEB_TRACE_MEM           0x400
    #define DEB_TRACE_HANDLE        0x800

    #define acDebugOut(args) acDebugPrint args

    VOID
    DebugInitialize();

    VOID
    DebugDumpSid(PSTR   pszTag,
                 PSID   pSid);

    VOID
    DebugDumpSD(PSTR                    pszTag,
                PSECURITY_DESCRIPTOR    pSD);

    VOID
    DebugDumpAcl(PSTR   pszTag,
                 PACL   pAcl);

    #define DebugDumpGuid(tag, pguid)                                       \
    pguid == NULL ? acDebugOut((DEB_TRACE_SD, "%s: (NULL)\n", tag))     :   \
    acDebugOut((DEB_TRACE_SD,                                               \
    "%s: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n",                \
    tag,pguid->Data1,pguid->Data2,pguid->Data3,pguid->Data4[0],             \
    pguid->Data4[1],pguid->Data4[2],pguid->Data4[3],pguid->Data4[4],        \
    pguid->Data4[5],pguid->Data4[6],pguid->Data4[7]))

    PVOID   DebugAlloc(ULONG cSize);
    VOID    DebugFree(PVOID  pv);


#else

    #define acDebugOut(args)

    #define DebugInitialize()

    #define DebugDumpSid(tag,sid)

    #define DebugDumpSD(tag, sd)

    #define DebugDumpAcl(tag, acl)

    #define DebugDumpGuid(tag, guid)

#endif // DBG


#ifdef PERFORMANCE
    #define START_PERFORMANCE ULONG starttime = GetCurrentTime();
    #define MEASURE_PERFORMANCE(args)              \
    (args)                                         \
        { Log(starttime - GetCurrentTime(),"args") }

#else
    #define START_PERFORMANCE
    #define MEASURE_PERFORMANCE(args) (args)
#endif

extern HANDLE WmiGuidHandle;

#endif // __ACCDEBUGHXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\kernel.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefKernelContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseKernelContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetKernelProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetKernelTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetKernelRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenKernelNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenKernelHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetKernelRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\ds.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefDsObjectContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseDsObjectContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaConvertDsObjectNameToGuid(
    IN  LPCWSTR   pObjectName,
    OUT GUID    * pGuid
    );

DWORD
MartaConvertGuidToDsName(
    IN  GUID     Guid,
    OUT LPWSTR * ppObjectName
    );

DWORD
MartaGetDsObjectProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetDsObjectTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetDsObjectRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenDsObjectNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetDsObjectRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

DWORD
MartaGetDsParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\file.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefFileContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseFileContext(
    IN MARTA_CONTEXT Context
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindFirstFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    );

////////////////////////////////////////////////////////////////////////
// Frees up the current context.                                      //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindNextFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaGetFileParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    );

DWORD
MartaGetFileProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetFileTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetFileRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenFileNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenFileHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetFileRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

// The following function is exported for testing

DWORD
MartaConvertFileContextToNtName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszNtObject
    );

ACCESS_MASK
MartaGetFileDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

DWORD
MartaReopenFileContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaReopenFileOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaGetFileNameFromContext(
    IN LPWSTR DosName,
    IN LPWSTR NtName,
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    );

DWORD
MartaGetFileParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\guidtables.h ===
#ifndef __GUIDTABLES_H__
#define  __GUIDTABLES_H__

typedef DWORD (*FN_CONVERT_NAME_TO_GUID) (
                    IN  LPCWSTR   pObjectName,
                    OUT GUID    * pGuid
                    );

FN_CONVERT_NAME_TO_GUID MartaConvertNameToGuid [] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaConvertDsObjectNameToGuid,
    &MartaConvertDsObjectNameToGuid,
    NULL,
    NULL
};

typedef DWORD (*FN_CONVERT_GUID_TO_NAME) (
                    IN  GUID     Guid,
                    OUT LPWSTR * ppObjectName
                    );

FN_CONVERT_GUID_TO_NAME MartaConvertGuidToName [] = {
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaConvertGuidToDsName,
    &MartaConvertGuidToDsName,
    NULL,
    NULL
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\lmsh.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefLMShareContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseLMShareContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetLMShareProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetLMShareTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetLMShareRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenLMShareNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetLMShareRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\printer.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefPrinterContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaClosePrinterContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetPrinterProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetPrinterTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetPrinterRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenPrinterNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenPrinterHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetPrinterRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\global.h ===
#ifndef __GLOBAL_H__
#define __GLOBAL_H__

typedef PVOID MARTA_CONTEXT, *PMARTA_CONTEXT;
#define NULL_MARTA_CONTEXT ((MARTA_CONTEXT) 0)

typedef struct _MARTA_OBJECT_PROPERTIES {
    DWORD cbSize;
    DWORD dwFlags;
} MARTA_OBJECT_PROPERTIES, *PMARTA_OBJECT_PROPERTIES;

#define MARTA_OBJECT_IS_CONTAINER   0x1

typedef struct _MARTA_OBJECT_TYPE_PROPERTIES {
    DWORD           cbSize;
    DWORD           dwFlags;
    GENERIC_MAPPING GenMap;
} MARTA_OBJECT_TYPE_PROPERTIES, *PMARTA_OBJECT_TYPE_PROPERTIES;

#define MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG   0x1
#define MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG   0x2

#define CONDITIONAL_EXIT(a, b) if (ERROR_SUCCESS != (a)) { goto b; }
#define CONDITIONAL_RETURN(a)  if (ERROR_SUCCESS != (a)) { return (a); }
#define CONDITIONAL_ACE_SIZE_ERROR(a)                                         \
            if ((a) > 0xFFFF) { return ERROR_BAD_INHERITANCE_ACL; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\lucache.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       lucache.h
//
//  Contents:   Name/Sid and Name/Property mapping and cache
//              functions and declarations
//
//  History:    2-Feb-97    MacM        Created
//
//--------------------------------------------------------------------
#ifndef __LUCACHE_H__
#define __LUCACHE_H__

#include <winldap.h>
#include <accctrl.h>

typedef struct _ACTRL_NAME_CACHE
{
    PWSTR           pwszName;
    PSID            pSid;
    SID_NAME_USE    SidUse;
    struct _ACTRL_NAME_CACHE *pNextName;
    struct _ACTRL_NAME_CACHE *pNextSid;
} ACTRL_NAME_CACHE, *PACTRL_NAME_CACHE;

#define ACTRL_NAME_TABLE_SIZE   15

//
// Comment this out to use the LSA routines directly for every lookup
//
#define USE_NAME_CACHE

#define ACTRL_OBJ_ID_TABLE_SIZE 100


#ifndef PGUID
    typedef GUID *PGUID;
#endif

typedef struct _ACTRL_OBJ_ID_CACHE
{
    PWSTR           pwszName;
    GUID            Guid;
    struct _ACTRL_OBJ_ID_CACHE *pNextName;
    struct _ACTRL_OBJ_ID_CACHE *pNextGuid;
} ACTRL_OBJ_ID_CACHE, *PACTRL_OBJ_ID_CACHE;

//
// This supports the control rights cache.
typedef struct _ACTRL_RIGHTS_CACHE
{
    GUID            ObjectClassGuid;
    ULONG           cRights;
    PWSTR          *RightsList;
    struct _ACTRL_RIGHTS_CACHE *pNext;
}
ACTRL_RIGHTS_CACHE, *PACTRL_RIGHTS_CACHE;

//
// Information on the last access to the DS
//
typedef struct _ACTRL_ID_SCHEMA_INFO
{
    LDAP    LDAP;
    BOOL    fLDAP;
    PWSTR   pwszPath;
    DWORD   LastReadTime;
} ACTRL_ID_SCHEMA_INFO, *PACTRL_ID_SCHEMA_INFO;


//
// Keep the name and sid caches in synch.
// Nodes are only inserted into the name cache, and are merely referenced
// by the sid cache.
extern PACTRL_NAME_CACHE    grgNameCache[ACTRL_NAME_TABLE_SIZE];
extern PACTRL_NAME_CACHE    grgSidCache[ACTRL_NAME_TABLE_SIZE];

extern PACTRL_OBJ_ID_CACHE  grgIdNameCache[ACTRL_OBJ_ID_TABLE_SIZE];
extern PACTRL_OBJ_ID_CACHE  grgIdGuidCache[ACTRL_OBJ_ID_TABLE_SIZE];

extern PACTRL_RIGHTS_CACHE  grgRightsNameCache[ACTRL_OBJ_ID_TABLE_SIZE];

INT
ActrlHashName(PWSTR pwszName);

INT
ActrlHashSid(PSID   pSid);

DWORD
AccctrlInitializeSidNameCache(VOID);

VOID
AccctrlFreeSidNameCache(VOID);

DWORD
AccctrlLookupName(IN  PWSTR          pwszServer,
                  IN  PSID           pSid,
                  IN  BOOL           fAllocateReturn,
                  OUT PWSTR         *ppwszName,
                  OUT PSID_NAME_USE  pSidNameUse);

DWORD
AccctrlLookupSid(IN  PWSTR          pwszServer,
                 IN  PWSTR          pwszName,
                 IN  BOOL           fAllocateReturn,
                 OUT PSID          *ppSid,
                 OUT PSID_NAME_USE  pSidNameUse);

INT
ActrlHashIdName(PWSTR   pwszName);

INT
ActrlHashGuid(PGUID pGuid);

DWORD
AccctrlInitializeIdNameCache(VOID);

VOID
AccctrlFreeIdNameCache(VOID);

DWORD
AccctrlLookupIdName(IN  PLDAP       pLDAP,
                    IN  PWSTR       pwszDsPath,
                    IN  PGUID       pGuid,
                    IN  BOOL        fAllocateReturn,
                    IN  BOOL        fFailUnknownGuid,
                    OUT PWSTR      *ppwszIdName);

DWORD
AccctrlLookupGuid(IN   PLDAP       pLDAP,
                  IN   PWSTR       pwszDsPath,
                  IN   PWSTR       pwszName,
                  IN   BOOL        fAllocateReturn,
                  OUT  PGUID      *ppGuid);

//
// Control rights lookup
//
DWORD
AccctrlInitializeRightsCache(VOID);

VOID
AccctrlFreeRightsCache(VOID);

DWORD
AccctrlLookupRightsByName(IN  PLDAP      pLDAP,
                          IN  PWSTR      pwszDsPath,
                          IN  PWSTR      pwszName,
                          OUT PULONG     pCount,
                          OUT PACTRL_CONTROL_INFOW *ControlInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\registry.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefRegistryKeyContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseRegistryKeyContext(
    IN MARTA_CONTEXT Context
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindFirstRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    );

////////////////////////////////////////////////////////////////////////
// Frees up the current context.                                      //
////////////////////////////////////////////////////////////////////////

DWORD
MartaFindNextRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    );

////////////////////////////////////////////////////////////////////////
// Does not free up the current context.                              //
////////////////////////////////////////////////////////////////////////

DWORD
MartaGetRegistryKeyParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    );

DWORD
MartaGetRegistryKeyProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetRegistryKeyTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetRegistryKeyRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenRegistryKeyNamedObject(
    IN  LPCWSTR              pObjectName,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    );

DWORD
MartaOpenRegistryKeyHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetRegistryKeyRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

// The following two functions are exported for testing

DWORD
MartaConvertRegistryKeyContextToName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszObject
    );

// The returned Handle isn't duplicated. It has the same lifetime as
// the Context
DWORD
MartaConvertRegistryKeyContextToHandle(
    IN MARTA_CONTEXT        Context,
    OUT HANDLE              *pHandle
    );

ACCESS_MASK
MartaGetRegistryKeyDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

ACCESS_MASK
MartaGetRegistryKey32DesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

ACCESS_MASK
MartaGetDefaultDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    );

DWORD
MartaReopenRegistryKeyContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaReopenRegistryKeyOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    );

DWORD
MartaGetRegistryKeyNameFromContext(
    IN LPWSTR Ignore1,
    IN LPWSTR Ignore2,
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    );

DWORD
MartaGetRegistryKeyParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\wmiguid.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefWMIGuidContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseWMIGuidContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetWMIGuidProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetWMIGuidTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetWMIGuidRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenWMIGuidNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenWMIGuidHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetWMIGuidRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\strings.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        strings.h
//
//  Contents:    Definitions to use for loading string resources
//
//  History:     20-Aug-96      MacM        Created
//
//--------------------------------------------------------------------

#define ACCPROV_MARTA_DACL_PROTECTED 1000
#define ACCPROV_MARTA_SACL_PROTECTED 1001
#define ACCPROV_MARTA_BOTH_PROTECTED 1002
#define ACCPROV_ACCOUNT_OPS          1003
#define ACCPROV_PRINTER_OPS          1004
#define ACCPROV_SYSTEM_OPS           1005
#define ACCPROV_POWER_USERS          1006
#define ACCPROV_NTAUTHORITY          1007
#define ACCPROV_BUILTIN              1008


//
// The counts of entries needs to be manually kept in synch with the
// rights defined in accctrl.h.
//

//
// This is the length of the longest string in the resource table.  This must
// be manually kept in synch
//
#define ACCPROV_LONGEST_STRING  28

//
// Base and count of standard access permissions
//
#define ACCPROV_STD_ACCESS      1100
#define ACCPROV_NUM_STD            7

//
// Base and count of ds access permissions
//
#define ACCPROV_DS_ACCESS       1200
#define ACCPROV_NUM_DS             9

//
// Base and count of file access permissions
//
#define ACCPROV_FILE_ACCESS     1300
#define ACCPROV_NUM_FILE           9

//
// Base and count of direcotry access permissions
//
#define ACCPROV_DIR_ACCESS      1400
#define ACCPROV_NUM_DIR            5

//
// Base and count of kernel access permissions
//
#define ACCPROV_KERNEL_ACCESS   1500
#define ACCPROV_NUM_KERNEL        16

//
// Base and count of printer access permissions
//
#define ACCPROV_PRINT_ACCESS    1600
#define ACCPROV_NUM_PRINT         5

//
// Base and count of service access permissions
//
#define ACCPROV_SERVICE_ACCESS  1700
#define ACCPROV_NUM_SERVICE        9

//
// Base and count of registry access permissions
//
#define ACCPROV_REGISTRY_ACCESS 1800
#define ACCPROV_NUM_REGISTRY       6

//
// Base and count of window station access permissions
//
#define ACCPROV_WIN_ACCESS      1900
#define ACCPROV_NUM_WIN            9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\service.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefServiceContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseServiceContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetServiceProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetServiceTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetServiceRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenServiceNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenServiceHandleObject(
    IN  HANDLE         Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaSetServiceRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\tables.h ===
#ifndef __TABLES_H__
#define  __TABLES_H__

typedef DWORD (*FN_ADD_REF_CONTEXT) (
                    IN MARTA_CONTEXT Context
                    );

FN_ADD_REF_CONTEXT MartaAddRefContext [] = {
    NULL,
    &MartaAddRefFileContext,
    &MartaAddRefServiceContext,
    &MartaAddRefPrinterContext,
    &MartaAddRefRegistryKeyContext,
    &MartaAddRefLMShareContext,
    &MartaAddRefKernelContext,
    &MartaAddRefWindowContext,
    &MartaAddRefDsObjectContext,
    &MartaAddRefDsObjectContext,
    NULL,
    &MartaAddRefWMIGuidContext,
    &MartaAddRefRegistryKeyContext
};

typedef DWORD (*FN_CLOSE_CONTEXT) (
                    IN MARTA_CONTEXT Context
                    );

FN_CLOSE_CONTEXT MartaCloseContext [] = {
    NULL,
    &MartaCloseFileContext,
    &MartaCloseServiceContext,
    &MartaClosePrinterContext,
    &MartaCloseRegistryKeyContext,
    &MartaCloseLMShareContext,
    &MartaCloseKernelContext,
    &MartaCloseWindowContext,
    &MartaCloseDsObjectContext,
    &MartaCloseDsObjectContext,
    NULL,
    &MartaCloseWMIGuidContext,
    &MartaCloseRegistryKeyContext
};

typedef DWORD (*FN_FIND_FIRST) (
                    IN  MARTA_CONTEXT  Context,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pChildContext
                    );

FN_FIND_FIRST MartaFindFirst [] = {
    NULL,
    &MartaFindFirstFile,
    NULL,
    NULL,
    &MartaFindFirstRegistryKey,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaFindFirstRegistryKey
};

typedef DWORD (*FN_FIND_NEXT) (
                    IN  MARTA_CONTEXT  Context,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pSiblingContext
                    );

FN_FIND_NEXT MartaFindNext [] = {
    NULL,
    &MartaFindNextFile,
    NULL,
    NULL,
    &MartaFindNextRegistryKey,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaFindNextRegistryKey
};

typedef DWORD (*FN_GET_PARENT_CONTEXT) (
                    IN  MARTA_CONTEXT  Context,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pParentContext
                    );

FN_GET_PARENT_CONTEXT MartaGetParentContext [] = {
    NULL,
    &MartaGetFileParentContext,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentContext
};

typedef DWORD (*FN_GET_TYPE_PROPERTIES) (
                    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
                    );

FN_GET_TYPE_PROPERTIES MartaGetTypeProperties [] = {
    NULL,
    &MartaGetFileTypeProperties,
    &MartaGetServiceTypeProperties,
    &MartaGetPrinterTypeProperties,
    &MartaGetRegistryKeyTypeProperties,
    &MartaGetLMShareTypeProperties,
    &MartaGetKernelTypeProperties,
    &MartaGetWindowTypeProperties,
    &MartaGetDsObjectTypeProperties,
    &MartaGetDsObjectTypeProperties,
    NULL,
    &MartaGetWMIGuidTypeProperties,
    &MartaGetRegistryKeyTypeProperties
};

typedef DWORD (*FN_GET_PROPERTIES) (
                    IN     MARTA_CONTEXT            Context,
                    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
                    );

FN_GET_PROPERTIES MartaGetProperties [] = {
    NULL,
    &MartaGetFileProperties,
    &MartaGetServiceProperties,
    &MartaGetPrinterProperties,
    &MartaGetRegistryKeyProperties,
    &MartaGetLMShareProperties,
    &MartaGetKernelProperties,
    &MartaGetWindowProperties,
    &MartaGetDsObjectProperties,
    &MartaGetDsObjectProperties,
    NULL,
    &MartaGetWMIGuidProperties,
    &MartaGetRegistryKeyProperties
};

typedef DWORD (*FN_GET_RIGHTS) (
                    IN  MARTA_CONTEXT        Context,
                    IN  SECURITY_INFORMATION SecurityInfo,
                    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
                    );

FN_GET_RIGHTS MartaGetRights [] = {
    NULL,
    &MartaGetFileRights,
    &MartaGetServiceRights,
    &MartaGetPrinterRights,
    &MartaGetRegistryKeyRights,
    &MartaGetLMShareRights,
    &MartaGetKernelRights,
    &MartaGetWindowRights,
    &MartaGetDsObjectRights,
    &MartaGetDsObjectRights,
    NULL,
    &MartaGetWMIGuidRights,
    &MartaGetRegistryKeyRights
};

typedef DWORD (*FN_OPEN_HANDLE_OBJECT) (
                    IN  HANDLE         Handle,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pContext
                    );

FN_OPEN_HANDLE_OBJECT MartaOpenHandleObject [] = {
    NULL,
    &MartaOpenFileHandleObject,
    &MartaOpenServiceHandleObject,
    &MartaOpenPrinterHandleObject,
    &MartaOpenRegistryKeyHandleObject,
    NULL,
    &MartaOpenKernelHandleObject,
    &MartaOpenWindowHandleObject,
    NULL,
    NULL,
    NULL,
    &MartaOpenWMIGuidHandleObject,
    &MartaOpenRegistryKeyHandleObject
};

typedef DWORD (*FN_OPEN_NAMED_OBJECT) (
                    IN  LPCWSTR        pObjectName,
                    IN  ACCESS_MASK    AccessMask,
                    OUT PMARTA_CONTEXT pContext
                    );

FN_OPEN_NAMED_OBJECT MartaOpenNamedObject [] = {
    NULL,
    &MartaOpenFileNamedObject,
    &MartaOpenServiceNamedObject,
    &MartaOpenPrinterNamedObject,
    &MartaOpenRegistryKeyNamedObject,
    &MartaOpenLMShareNamedObject,
    &MartaOpenKernelNamedObject,
    &MartaOpenWindowNamedObject,
    &MartaOpenDsObjectNamedObject,
    &MartaOpenDsObjectNamedObject,
    NULL,
    &MartaOpenWMIGuidNamedObject,
    &MartaOpenRegistryKeyNamedObject
};

typedef DWORD (*FN_SET_RIGHTS) (
                    IN MARTA_CONTEXT        Context,
                    IN SECURITY_INFORMATION SecurityInfo,
                    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
                    );

FN_SET_RIGHTS MartaSetRights [] = {
    NULL,
    &MartaSetFileRights,
    &MartaSetServiceRights,
    &MartaSetPrinterRights,
    &MartaSetRegistryKeyRights,
    &MartaSetLMShareRights,
    &MartaSetKernelRights,
    &MartaSetWindowRights,
    &MartaSetDsObjectRights,
    &MartaSetDsObjectRights,
    NULL,
    &MartaSetWMIGuidRights,
    &MartaSetRegistryKeyRights
};

typedef DWORD (*FN_GET_DESIRED_ACCESS) (
                    IN SECURITY_OPEN_TYPE   OpenType,
                    IN BOOL                 Attribs,
                    IN SECURITY_INFORMATION SecurityInfo
                    );

FN_GET_DESIRED_ACCESS MartaGetDesiredAccess [] = {
    NULL,
    &MartaGetFileDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetRegistryKeyDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    &MartaGetDefaultDesiredAccess,
    NULL,
    &MartaGetDefaultDesiredAccess,
    &MartaGetRegistryKey32DesiredAccess
};

typedef DWORD (*FN_REOPEN_CONTEXT) (
                    IN OUT MARTA_CONTEXT Context,
                    IN     ACCESS_MASK   AccessMask
                    );

FN_REOPEN_CONTEXT MartaReopenContext [] = {
    NULL,
    &MartaReopenFileContext,
    NULL,
    NULL,
    &MartaReopenRegistryKeyContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaReopenRegistryKeyContext
};

typedef DWORD (*FN_REOPEN_ORIG_CONTEXT) (
                    IN OUT MARTA_CONTEXT Context,
                    IN     ACCESS_MASK   AccessMask
                    );

FN_REOPEN_CONTEXT MartaReopenOrigContext [] = {
    NULL,
    &MartaReopenFileOrigContext,
    NULL,
    NULL,
    &MartaReopenRegistryKeyOrigContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaReopenRegistryKeyOrigContext
};

typedef DWORD (*FN_GET_PARENT_NAME) (
                    IN LPWSTR ObjectName,
                    OUT LPWSTR *pParentName
                    );

FN_GET_PARENT_NAME MartaGetParentName [] = {
    NULL,
    &MartaGetFileParentName,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentName,
    NULL,
    NULL,
    NULL,
    &MartaGetDsParentName,
    &MartaGetDsParentName,
    NULL,
    NULL,
    &MartaGetRegistryKeyParentName
};

typedef DWORD (*FN_GET_NAME_FROM_CONTEXT) (
                    IN LPWSTR DosObjectName,
                    IN LPWSTR NtObjectName,
                    IN MARTA_CONTEXT Context,
                    OUT LPWSTR *pObjectName
                    );

FN_GET_NAME_FROM_CONTEXT MartaGetNameFromContext [] = {
    NULL,
    &MartaGetFileNameFromContext,
    NULL,
    NULL,
    &MartaGetRegistryKeyNameFromContext,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    &MartaGetRegistryKeyNameFromContext
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newinc\window.h ===
////////////////////////////////////////////////////////////////////////
//                                                                    //
// Context structure is not known to the caller. It is defined by the //
// callee when Open/FindFirst is called and is used subsequently as   //
// input to other calls.                                              //
//                                                                    //
// Since the caller is not aware of the context structure the object  //
// manager must provide a free context funtion.                       //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#include "global.h"

DWORD
MartaAddRefWindowContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaCloseWindowContext(
    IN MARTA_CONTEXT Context
    );

DWORD
MartaGetWindowProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    );

DWORD
MartaGetWindowTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    );

DWORD
MartaGetWindowRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaOpenWindowNamedObject(
    IN  LPCWSTR        pObjectName,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pContext
    );

DWORD
MartaOpenWindowHandleObject(
    IN  HANDLE               Handle,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT       pContext
    );

DWORD
MartaSetWindowRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\aclutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1995.
//
//  File:    aclutil.cxx
//
//  Contents:    utility function(s) for ACL api
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
}

DLLFuncsTable    DLLFuncs;

typedef struct _NAME_RID_INFO {

    PWSTR pwszName;
    ULONG Rid;

} NAME_RID_INFO, *PNAME_RID_INFO;

BOOL NameSidLookupInfoLoaded = FALSE;
NAME_RID_INFO NameSidLookup[] = {
    { NULL, DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { NULL, DOMAIN_ALIAS_RID_PRINT_OPS },
    { NULL, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { NULL, DOMAIN_ALIAS_RID_POWER_USERS }
    };


//
// Private functions
//

DWORD AccpLoadLocalizedNameTranslations()
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG Value = 0,i;
    WCHAR wszStringBuffer[ 256];

    RtlAcquireResourceExclusive(&gLocalSidCacheLock, TRUE);

    if ( !NameSidLookupInfoLoaded ) {

        for (i = 0; i < sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ); i++ )
        {

            switch ( NameSidLookup[ i ].Rid )
            {
            case DOMAIN_ALIAS_RID_ACCOUNT_OPS:
                Value = ACCPROV_ACCOUNT_OPS;
                break;

            case DOMAIN_ALIAS_RID_PRINT_OPS:
                Value = ACCPROV_PRINTER_OPS;
                break;

            case DOMAIN_ALIAS_RID_SYSTEM_OPS:
                Value = ACCPROV_SYSTEM_OPS;
                break;

            case DOMAIN_ALIAS_RID_POWER_USERS:
                Value = ACCPROV_POWER_USERS;
                break;
            }

            if (LoadString(ghDll,
                           Value,
                           wszStringBuffer,
                           sizeof( wszStringBuffer ) / sizeof( WCHAR )) != 0)
            {

                ACC_ALLOC_AND_COPY_STRINGW(wszStringBuffer,
                                           NameSidLookup[ i ].pwszName,
                                           dwErr );
            }
            else
            {
                dwErr = GetLastError();
            }

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

        if(dwErr != ERROR_SUCCESS)
        {
            for(i = 0; i< sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ); i++ )
            {
                LocalFree( NameSidLookup[ i ].pwszName );
                NameSidLookup[ i ].pwszName = NULL;
            }
        }
        else
        {
            NameSidLookupInfoLoaded = TRUE;
        }

    }
    RtlReleaseResource( &gLocalSidCacheLock );

    return( dwErr );
}


DWORD AccpDoSidLookup(IN  PWSTR         pwszServer,
                      IN  PWSTR         pwszName,
                      OUT PSID         *ppSid,
                      OUT SID_NAME_USE *pSidType)
{
#define BASE_DOMAIN_NAME_SIZE 64
#define BASE_SID_SIZE 64

    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   cusid = BASE_SID_SIZE;
    DWORD   crd = BASE_DOMAIN_NAME_SIZE;
    SID_NAME_USE esidtype = SidTypeUnknown;
    WCHAR    domainbuf[BASE_DOMAIN_NAME_SIZE];
    LPWSTR  domain = (LPWSTR)domainbuf;

    domainbuf[0] = L'\0';
    if (LoadString(ghDll,
                   ACCPROV_NTAUTHORITY,
                   domainbuf,
                   sizeof( domainbuf ) / sizeof( WCHAR )) != 0)
    {

        if(_wcsicmp(pwszServer, domainbuf) == 0)
        {

            pwszServer = NULL;
        }
    } else if(_wcsicmp(pwszServer, L"NT AUTHORITY") == 0)
    {

        pwszServer = NULL;
    }

    *ppSid = (PSID)AccAlloc(cusid);

    if(*ppSid == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        if(!LookupAccountName(pwszServer,
                              pwszName,
                              *ppSid,
                              &cusid,
                              domain,
                              &crd,
                              &esidtype))
        {
            dwErr = GetLastError();

            if(dwErr == ERROR_INSUFFICIENT_BUFFER)
            {
                dwErr = ERROR_SUCCESS;

                //
                // if the rooom for the sid was not big enough,
                // grow it.
                //
                if(cusid > BASE_SID_SIZE)
                {
                    AccFree(*ppSid);
                    *ppSid = (PSID)AccAlloc(cusid);
                    if (*ppSid == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {

                    if(crd > BASE_DOMAIN_NAME_SIZE)
                    {
                        domain = (LPWSTR)AccAlloc(crd * sizeof(WCHAR));
                        if (NULL == domain)
                        {
                            AccFree(*ppSid);
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        if(!LookupAccountName(pwszServer,
                                              pwszName,
                                              *ppSid,
                                              &cusid,
                                              domain,
                                              &crd,
                                              &esidtype))
                        {
                            dwErr = GetLastError();
                            AccFree(*ppSid);

                        }
                        if(domain != (LPWSTR)domainbuf)
                        {
                            AccFree(domain);
                        }
                    }
                }
            }
            else if(dwErr != ERROR_SUCCESS)
            {
                AccFree(*ppSid);
                *ppSid = NULL;
            }
        }
        else if(dwErr != ERROR_SUCCESS)
        {
            AccFree(*ppSid);
            *ppSid = NULL;
        }
    }

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function :  AccLookupAccountSid
//
//  Synopsis :  returns the SID for the specified trustee
//
//  Arguments: [IN  pwszServer]         --  Name of the server to remote the
//                                          call to
//             [IN  pName]              --  the name to lookup the SID for
//             [OUT ppwszName]          --  Where the name is returned
//             [OUT pSidType]           --  Where the SID type is returned
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed.
//              ERROR_INVALID_PARAMETER --  The trustee form was bad
//
//----------------------------------------------------------------------------
DWORD AccLookupAccountSid(IN  PWSTR         pwszServer,
                          IN  PTRUSTEE      pName,
                          OUT PSID         *ppsid,
                          OUT SID_NAME_USE *pSidType)
{

#define BASE_DOMAIN_NAME_SIZE 64
#define BASE_SID_SIZE 64

    DWORD   dwErr = ERROR_SUCCESS;
    DWORD   cusid = BASE_SID_SIZE;
    DWORD   crd = BASE_DOMAIN_NAME_SIZE;
    SID_NAME_USE esidtype = SidTypeUnknown;
    WCHAR    domainbuf[BASE_DOMAIN_NAME_SIZE];
    LPWSTR  domain = (LPWSTR)domainbuf;
    PWSTR   pwszSep;
    PWSTR   pwszTempName;

    if(pName->TrusteeForm == TRUSTEE_IS_SID)
    {
        //
        // Trustee is of form TRUSTEE_IS_SID
        //
        *ppsid = (PSID) AccAlloc( GetLengthSid((PSID)pName->ptstrName) );
        if (*ppsid != NULL)
        {
            if (!CopySid( GetLengthSid((PSID)pName->ptstrName),
                          *ppsid,
                          (PSID)pName->ptstrName))
            {
                dwErr = GetLastError();
                AccFree(*ppsid);
                *ppsid = NULL;
            }
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else if(pName->TrusteeForm == TRUSTEE_IS_NAME)
    {
        //
        // Trustee is of form TRUSTEE_IS_NAME.
        //

        //
        // Check for CURRENT_USER (in which case we get the name from
        // the token)
        //
        if(_wcsicmp(pName->ptstrName, L"CURRENT_USER") == 0)
        {

            HANDLE token_handle;

            dwErr = GetCurrentToken( &token_handle );

            //
            // if we have a token, get the user SID from it
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccGetSidFromToken(pwszServer,
                                           token_handle,
                                           TokenUser,
                                           ppsid);
                CloseHandle(token_handle);
            }
        }
        else
        {
            //
            // if not current user, we have to do a name lookup
            // first allocate a default sid (so the name lookup is not
            // always performed twice.)
            //
            *ppsid = (PSID)AccAlloc(cusid);

            if(*ppsid != NULL)
            {
                if(!LookupAccountName(pwszServer,
                                      pName->ptstrName,
                                      *ppsid,
                                      &cusid,
                                      domain,
                                      &crd,
                                      &esidtype))
                {
                    dwErr = GetLastError();
                    if(dwErr == ERROR_INSUFFICIENT_BUFFER)
                    {
                        dwErr = ERROR_SUCCESS;

                        //
                        // if the rooom for the sid was not big enough,
                        // grow it.
                        //
                        if(cusid > BASE_SID_SIZE)
                        {
                            AccFree(*ppsid);
                            *ppsid = (PSID)AccAlloc(cusid);
                            if (*ppsid == NULL)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {

                            if(crd > BASE_DOMAIN_NAME_SIZE)
                            {
                                domain = (LPWSTR)AccAlloc(crd * sizeof(WCHAR));
                                if (NULL == domain)
                                {
                                    AccFree(*ppsid);
                                    *ppsid = NULL;
                                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }

                            if(dwErr == ERROR_SUCCESS)
                            {
                                if(!LookupAccountName(pwszServer,
                                                      pName->ptstrName,
                                                      *ppsid,
                                                      &cusid,
                                                      domain,
                                                      &crd,
                                                      &esidtype))
                                {
                                    dwErr = GetLastError();
                                    AccFree(*ppsid);
                                    *ppsid = NULL;
                                }

                                if(crd > BASE_DOMAIN_NAME_SIZE)
                                {
                                    AccFree(domain);
                                }
                            }
                        }
                    }
                    else
                    {
                        //
                        // See if is a translation of a known name
                        //

                        dwErr = AccpLoadLocalizedNameTranslations();

                        AccFree(*ppsid);
                        *ppsid = NULL;

                        if(dwErr == ERROR_SUCCESS)
                        {

                            //
                            // Check our well known sids
                            //
                            static SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority =
                                                                        SECURITY_NT_AUTHORITY;
                            DWORD BuiltSid[sizeof(SID)/sizeof(DWORD) + 2 ];
                            PSID pSid = (PSID)BuiltSid;
                            RtlInitializeSid( pSid,
                                              &UaspBuiltinAuthority,
                                              1 );

                            *(RtlSubAuthoritySid(pSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

                            for( ULONG i = 0;
                                 i < sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO );
                                 i++ )
                            {
                                if ( _wcsicmp( pName->ptstrName, NameSidLookup[ i ].pwszName ) == 0)
                                {
                                    *(RtlSubAuthoritySid(pSid, 1)) = NameSidLookup[ i ].Rid;
                                    break;
                                }
                            }

                            if ( i == sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ) )
                            {

                                pSid = NULL;
                            }
                            else
                            {
                                dwErr = ERROR_SUCCESS;
                                ACC_ALLOC_AND_COPY_SID(pSid,
                                                       *ppsid,
                                                       dwErr);
                            }

                            }
                        //
                        // See if we have a server name specified in the user name
                        // when we didn't have one provided.
                        //
                        if(pwszServer == NULL)
                        {

                            ACC_ALLOC_AND_COPY_STRINGW(pName->ptstrName,
                                                       pwszTempName,
                                                       dwErr );

                            if(dwErr == ERROR_SUCCESS)
                            {

                                pwszSep = wcschr(pwszTempName, L'\\');

                                if(pwszSep != NULL)
                                {
                                    *pwszSep = L'\0';

                                    dwErr = AccpDoSidLookup(pwszTempName,
                                                            pwszSep + 1,
                                                            ppsid,
                                                            pSidType);

                                    if(dwErr != ERROR_SUCCESS)
                                    {
                                        //
                                        // Ok, may that was a domain name instead of a
                                        // server name
                                        //
                                        PDOMAIN_CONTROLLER_INFOW pDCI = NULL;
                                        dwErr = DsGetDcNameW(NULL,
                                                             pwszTempName,
                                                             NULL,
                                                             NULL,
                                                             0,
                                                             &pDCI);
                                        if(dwErr == ERROR_SUCCESS)
                                        {
                                            dwErr = AccpDoSidLookup(
                                                        pDCI[0].DomainControllerAddress,
                                                        pwszSep + 1,
                                                        ppsid,
                                                        pSidType );

                                            NetApiBufferFree(pDCI);
                                        }

                                    }

                                }

                                LocalFree(pwszTempName);
                            }
                        }

                        //
                        // If for any reason we haven't converted it, go ahead and
                        // dump it as a string.
                        //
                        if(*ppsid == NULL)
                        {
                            dwErr = ConvertStringToSid(pName->ptstrName,
                                                       ppsid);
                        }
                    }
                }
            }
            else
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else
    {
        //
        // Trustee is not of known form
        //
        dwErr = ERROR_INVALID_PARAMETER;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        *pSidType = esidtype;
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function :  AccGetSidFromToken
//
//  Synopsis :  Gets the SID from the given token handle
//
//  Arguments:  IN  pwszServer      --      Name of server to remote the
//                                          call to
//              IN  [hToken]        --      Token handle
//              IN  [TIC]           --      Token information class
//              OUT [ppSidFromToken]--      Where the SID is returned
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD AccGetSidFromToken(IN  PWSTR                    pwszServer,
                         IN  HANDLE                   hToken,
                         IN  TOKEN_INFORMATION_CLASS  TIC,
                         IN  PSID                    *ppSidFromToken)
{
    DWORD   dwErr = ERROR_SUCCESS;

    ULONG   cSize;
    BYTE    bBuf[64];

    PTOKEN_USER pTknUsr = (TOKEN_USER *)bBuf;

    if(GetTokenInformation(hToken,
                           TIC,
                           pTknUsr,
                           sizeof(bBuf),
                           &cSize) == FALSE)
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;

            pTknUsr = (PTOKEN_USER)AccAlloc(cSize);
            if(pTknUsr == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                //
                // Now, call it again...
                //
                if(GetTokenInformation(hToken,
                                       TIC,
                                       pTknUsr,
                                       sizeof(bBuf),
                                       &cSize) == FALSE)
                {
                    dwErr = GetLastError();

                    //
                    // deallocate our buffer here, since noone else
                    // will
                    //
                    AccFree(pTknUsr);
                }
            }
        }
    }

    //
    // One way or another, we got the token info, so we'll grab the
    // sid
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // allocate room for the returned sid
        //
        ULONG cSidSize = RtlLengthSid(pTknUsr->User.Sid);
        *ppSidFromToken = (PSID)AccAlloc(cSidSize);
        if(*ppSidFromToken == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // and copy the new sid
            //
            NTSTATUS Status = RtlCopySid(cSidSize,
                                         *ppSidFromToken,
                                         pTknUsr->User.Sid);
            if(!NT_SUCCESS(Status))
            {
                dwErr = RtlNtStatusToDosError(Status);
                AccFree(*ppSidFromToken);
                *ppSidFromToken = NULL;
            }
        }

        //
        // See if we had to allocate
        //
        if(pTknUsr != (PTOKEN_USER)bBuf)
        {
            AccFree(pTknUsr);
        }

    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function :  AccLookupAccountTrustee
//
//  Synopsis :  returns the TRUSTEE for the specified sid
//
//  Arguments:  [IN  pwszServer]    --      The server to remote the call to
//              OUT [pTrustee]      --      the returned trustee
//              IN [pSid]           --      the SID
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD AccLookupAccountTrustee(IN  PWSTR     pwszServer,
                              IN  PSID      pSid,
                              OUT PTRUSTEE *ppTrustee)
{
    #define BASE_TRUSTEE_NAME_SIZE 256

    acDebugOut((DEB_TRACE_ACC, "in  AccLookupAccountTrustee \n"));

    PWSTR           pwszName;
    PWSTR           pwszDomain;
    SID_NAME_USE    SidType;

    DWORD dwErr = AccLookupAccountName(pwszServer,
                                       pSid,
                                       &pwszName,
                                       &pwszDomain,
                                       &SidType);
    if(dwErr == ERROR_SUCCESS)
    {
        PTRUSTEE pTrustee;
        LPWSTR   pName;

        pTrustee = (PTRUSTEE) AccAlloc(sizeof(TRUSTEE) + SIZE_PWSTR(pwszName));
        if(pTrustee != NULL)
        {
            pName = (LPWSTR) ((PBYTE)pTrustee + sizeof(TRUSTEE));
            CopyMemory(pName,
                       pwszName,
                       SIZE_PWSTR(pwszName));

            pTrustee->pMultipleTrustee = NULL;
            pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
            pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
            pTrustee->ptstrName = pName;
            *ppTrustee = pTrustee;

            if(SidType == SidTypeUnknown)
            {
                pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
            }
            else
            {
                pTrustee->TrusteeType = (TRUSTEE_TYPE)(SidType);
            }
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        AccFree(pwszName);
        AccFree(pwszDomain);
    }


    acDebugOut((DEB_TRACE_ACC, "out  AccLookupAccountTrustee:%lu\n", dwErr));

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function :  AccLookupAccountName
//
//  Synopsis :  Returns the name for the given SID
//
//  Arguments: [IN  pwszServer]         --  The name of the server to remote
//                                          the call to.
//             [IN  pSid]               --  the SID to lookup the name for
//             [OUT ppwszName]          --  Where the name is returned
//             [OUT pSidType]           --  Where the SID type is returned
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed.
//
//----------------------------------------------------------------------------
DWORD   AccLookupAccountName(IN  PWSTR          pwszServer,
                             IN   PSID          pSid,
                             OUT  LPWSTR       *ppwszName,
                             OUT  LPWSTR       *ppwszDomain,
                             OUT  SID_NAME_USE *pSidType)
{
    #define BASE_TRUSTEE_NAME_SIZE 256
    acDebugOut((DEB_TRACE_ACC,"in  AccLookupAccountName\n"));

    DWORD           dwErr = ERROR_SUCCESS;
    SID_NAME_USE    esidtype = SidTypeUnknown;
    LPWSTR          pwszDomain = NULL;
    LPWSTR          pwszName = NULL;
    ULONG           cName = 0;
    ULONG           cDomain = 0;

    DebugDumpSid("AccLookupAccountName", pSid);

    if(LookupAccountSid(pwszServer,
                        pSid,
                        NULL,
                        &cName,
                        NULL,
                        &cDomain,
                        &esidtype) == FALSE)
    {
        pwszName = NULL;
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;

            //
            // Allocate for the name and the domain
            //
            pwszName = (PWSTR)AccAlloc(cName * sizeof(WCHAR));
            if(pwszName != NULL)
            {
                pwszDomain = (PWSTR)AccAlloc(cDomain * sizeof(WCHAR));
                if(pwszDomain == NULL)
                {
                    AccFree(pwszName);
                    pwszName = NULL;
                }
            }

            if(pwszName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(LookupAccountSid(pwszServer,
                                    pSid,
                                    pwszName,
                                    &cName,
                                    pwszDomain,
                                    &cDomain,
                                    &esidtype) == FALSE)
                {
                    dwErr = GetLastError();
                    AccFree(pwszName);
                    pwszName = NULL;
                    AccFree(pwszDomain);
                    pwszDomain = NULL;
                }
            }
        }
        else // if(dwErr == ERROR_NONE_MAPPED)
        {
            dwErr = AccpLoadLocalizedNameTranslations();

            if(dwErr == ERROR_SUCCESS)
            {

                //
                // Check our well known sids
                //
                static SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority =
                                                                SECURITY_NT_AUTHORITY;
                DWORD BuiltSid[sizeof(SID)/sizeof(DWORD) + 2 ];
                PSID pKnownSid = (PSID)BuiltSid;
                RtlInitializeSid( pKnownSid,
                                  &UaspBuiltinAuthority,
                                  1 );

                *(RtlSubAuthoritySid(pKnownSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

                for( ULONG i = 0;i < sizeof( NameSidLookup ) / sizeof( NAME_RID_INFO ); i++)
                {
                    *(RtlSubAuthoritySid(pKnownSid, 1)) = NameSidLookup[ i ].Rid;
                    if ( RtlEqualSid( pKnownSid, pSid ) == TRUE )
                    {
                        ACC_ALLOC_AND_COPY_STRINGW(NameSidLookup[ i ].pwszName,
                                                   pwszName,
                                                   dwErr);
                        break;
                    }
                }
            }

            //
            // If it isn't someone we recognize, convert it to a string..
            //
            if(dwErr == ERROR_SUCCESS && pwszName == NULL)
            {
                //
                // Ok, return the sid as a name
                //
                UCHAR   String[256];
                UNICODE_STRING  SidStr;
                SidStr.Buffer = (PWSTR)String;
                SidStr.Length = SidStr.MaximumLength = 256;

                NTSTATUS Status = RtlConvertSidToUnicodeString(&SidStr,
                                                               pSid,
                                                               FALSE);
                if(NT_SUCCESS(Status))
                {
                    ACC_ALLOC_AND_COPY_STRINGW(SidStr.Buffer,
                                               pwszName,
                                               dwErr);
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(Status);
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
#if 1
        //
        // Convert to RDN
        //
        *ppwszName = pwszName;
        *ppwszDomain = pwszDomain;
        *pSidType  = esidtype;

        ULONG   cLen = wcslen(pwszName);
        if(pwszDomain != NULL && *pwszDomain != L'\0')
        {
            cLen += wcslen(pwszDomain) + 1;
        }

        if(cLen != wcslen(pwszName))
        {
            cLen++;
            PWSTR   pwszFullName = (PWSTR)AccAlloc(cLen * sizeof(WCHAR));
            if(pwszFullName == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                 swprintf(pwszFullName,
                          L"%ws\\%ws",
                          pwszDomain,
                          pwszName);
                AccFree(pwszName);
                pwszName = NULL;
                *ppwszName = pwszFullName;
            }
        }
        AccFree(pwszDomain);
        pwszDomain = NULL;
        *ppwszDomain = NULL;

#else
        dwErr = Nt4NameToNt5Name(pwszName,
                                 pwszDomain,
                                 ppwszName);

        if(dwErr == ERROR_SUCCESS)
        {
            AccFree(pwszName);
            *ppwszDomain = pwszDomain;
            *pSidType  = esidtype;
        }
#endif
    }

    if(dwErr != ERROR_SUCCESS)
    {
        AccFree(pwszDomain);
        AccFree(pwszName);
    }

    acDebugOut((DEB_TRACE_ACC,"Out AccLookupAccountName: %lu\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function : GetDesiredAccess
//
//  Synopsis : Gets the access required to open object to be able to set or
//             get the specified security info.
//
//  Arguments: IN [SecurityOpenType]  - Flag indicating if the object is to be
//                                      opened to read or write the DACL
//
//----------------------------------------------------------------------------
ACCESS_MASK GetDesiredAccess(IN SECURITY_OPEN_TYPE   OpenType,
                             IN SECURITY_INFORMATION SecurityInfo)
{
    acDebugOut((DEB_TRACE_ACC, "in GetDesiredAccess \n"));

    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    acDebugOut((DEB_TRACE_ACC, "out GetDesiredAccess: %lu\n", DesiredAccess));

    return (DesiredAccess);
}




//+---------------------------------------------------------------------------
//
//  Function : GetSecurityDescriptorParts
//
//  Synopsis : extracts the specified components of a security descriptor
//             It is the responsibility of the invoker to free (using AccFree)
//             any acquired security components.
//
//  Arguments: IN [pSecurityDescriptor]   - the input security descriptor
//             IN [SecurityInfo]   - flag indicating what security info to return
//             OUT [psidOwner]   - the (optional) returned owner sid
//             OUT [psidGroup]   - the (optional) returned group sid
//             OUT [pDacl]   - the (optional) returned DACL
//             OUT [pSacl]   - the (optional) returned SACL
//
//  Returns:
//
//----------------------------------------------------------------------------
DWORD GetSecurityDescriptorParts( IN PISECURITY_DESCRIPTOR pSecurityDescriptor,
                                  IN SECURITY_INFORMATION SecurityInfo,
                                  OUT PSID *psidOwner,
                                  OUT PSID *psidGroup,
                                  OUT PACL *pDacl,
                                  OUT PACL *pSacl,
                                  OUT PSECURITY_DESCRIPTOR *pOutSecurityDescriptor)
{
    acDebugOut((DEB_TRACE_ACC, "in GetSecurityDescriptorParts\n"));
    NTSTATUS Status;
    DWORD    dwErr = ERROR_SUCCESS;

    //
    // if no security descriptor found, don't return one!
    //
    if(psidOwner)
    {
        *psidOwner = NULL;
    }

    if(psidGroup)
    {
        *psidGroup = NULL;
    }

    if(pDacl)
    {
        *pDacl = NULL;
    }

    if(pSacl)
    {
        *pSacl = NULL;
    }

    *pOutSecurityDescriptor = NULL;

    if(pSecurityDescriptor)
    {
        PSID                    owner = NULL, group = NULL;
        PACL                    dacl = NULL, sacl = NULL;
        ULONG                   cSize = sizeof(SECURITY_DESCRIPTOR);
        BOOLEAN                 bDummy, bParmPresent = FALSE;
        PISECURITY_DESCRIPTOR   pOutSD;

        //
        // if the security descriptor is self relative, get absolute
        // pointers to the components
        //
        Status = RtlGetOwnerSecurityDescriptor(pSecurityDescriptor,
                                               &owner,
                                               &bDummy);
        if(NT_SUCCESS(Status))
        {
            Status = RtlGetGroupSecurityDescriptor(pSecurityDescriptor,
                                                   &group,
                                                   &bDummy);
        }

        if(NT_SUCCESS(Status))
        {
            Status = RtlGetDaclSecurityDescriptor(pSecurityDescriptor,
                                                  &bParmPresent,
                                                  &dacl,
                                                  &bDummy);
            if(NT_SUCCESS(Status) && !bParmPresent)
            {
                dacl = NULL;
            }
        }

        if(NT_SUCCESS(Status))
        {
            Status = RtlGetSaclSecurityDescriptor(pSecurityDescriptor,
                                                  &bParmPresent,
                                                  &sacl,
                                                  &bDummy);
            if(NT_SUCCESS(Status) && !bParmPresent)
            {
                sacl = NULL;
            }
        }

        if(NT_SUCCESS(Status))
        {
            //
            // Build the new security descriptor
            //
            cSize = RtlLengthSecurityDescriptor( pSecurityDescriptor ) +
                          sizeof(SECURITY_DESCRIPTOR) - sizeof(SECURITY_DESCRIPTOR_RELATIVE);


            pOutSD = (PISECURITY_DESCRIPTOR)AccAlloc(cSize);
            if(pOutSD == NULL)
            {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            RtlCreateSecurityDescriptor(pOutSD, SECURITY_DESCRIPTOR_REVISION);

            void *bufptr = Add2Ptr(pOutSD, sizeof(SECURITY_DESCRIPTOR));

            if(SecurityInfo & OWNER_SECURITY_INFORMATION)
            {
                if(NULL != owner)
                {
                    //
                    // no error checking as these should not fail!!
                    //
                    RtlCopySid(RtlLengthSid(owner), (PSID)bufptr, owner);
                    RtlSetOwnerSecurityDescriptor(pOutSD,
                                                  (PSID)bufptr, FALSE);
                    bufptr = Add2Ptr(bufptr,RtlLengthSid(owner));
                    if(psidOwner)
                    {
                        *psidOwner = pOutSD->Owner;
                    }
                }
                else
                {
                    AccFree(pOutSD);
                    return(ERROR_NO_SECURITY_ON_OBJECT);
                }
            }

            if(SecurityInfo & GROUP_SECURITY_INFORMATION)
            {
                if(NULL != group)
                {
                    //
                    // no error checking as these should not fail!!
                    //
                    RtlCopySid(RtlLengthSid(group), (PSID)bufptr, group);
                    RtlSetGroupSecurityDescriptor(pOutSD,
                                                  (PSID)bufptr, FALSE);
                    bufptr = Add2Ptr(bufptr,RtlLengthSid(group));
                    if(psidGroup)
                    {
                        *psidGroup = pOutSD->Group;
                    }
                }
                else
                {
                    AccFree(pOutSD);
                    return(ERROR_NO_SECURITY_ON_OBJECT);
                }
            }

            //
            // The DACL and SACL may or may not be on the object.
            //
            if(SecurityInfo & DACL_SECURITY_INFORMATION)
            {
                if(NULL != dacl)
                {
                    RtlCopyMemory(bufptr, dacl, dacl->AclSize);
                    RtlSetDaclSecurityDescriptor(pOutSD,
                           TRUE,
                           (ACL *)bufptr,
                           FALSE);
                    if(pDacl)
                    {
                        *pDacl = pOutSD->Dacl;
                    }
                }
            }

            if(SecurityInfo & SACL_SECURITY_INFORMATION)
            {
                if(NULL != sacl)
                {
                    RtlCopyMemory(bufptr, sacl, sacl->AclSize);
                    RtlSetSaclSecurityDescriptor(pOutSD,
                                                 TRUE,
                                                 (PACL)bufptr,
                                                 FALSE);
                    if(pSacl)
                    {
                        *pSacl = pOutSD->Sacl;
                    }
                }
            }

            *pOutSecurityDescriptor = pOutSD;
        }

        if(!NT_SUCCESS(Status))
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }
    acDebugOut((DEB_TRACE_ACC, "Out GetSecurityDescriptorParts(%d)\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function : ParseName
//
//  Synopsis : parses a UNC name for the machine name
//
//  Arguments: [IN OUT pObjectName] --      the name of the object
//             [OUT pMachineName]   --      the machine the object is on
//             [OUT pRemainingName] --      the remaining name after the
//                                          machine name
//
//  Returns:    ERROR_SUCCESS       --      The call succeeded
//
//----------------------------------------------------------------------------
DWORD ParseName(IN OUT  LPWSTR  pObjectName,
                OUT     LPWSTR *pMachineName,
                OUT     LPWSTR *pRemainingName)
{
    acDebugOut((DEB_TRACE_ACC, "in/out  ParseName \n"));

    if(pObjectName == wcsstr(pObjectName, L"\\\\"))
    {
        *pMachineName = pObjectName + 2;
        *pRemainingName =  wcschr(*pMachineName, L'\\');
        if (*pRemainingName != NULL)
        {
            **pRemainingName = L'\0';
            *pRemainingName += 1;
        }
    }
    else
    {
        *pMachineName = NULL;
        *pRemainingName = pObjectName;
    }

    return(ERROR_SUCCESS);
}




//+---------------------------------------------------------------------------
//
//  Function:   DoTrusteesMatch
//
//  Synopsis:   Determines if 2 trustess reference the same thing (ie:
//              (are they equal)
//
//  Arguments:  [IN  pwszServer]        --  Server to lookup information on
//              [IN  pTrustee1]         --  First trustee
//              [IN  pTrustee2]         --  Second trustee
//              [OUT pfMatch]           --  Where the match results are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
DoTrusteesMatch(IN  PWSTR       pwszServer,
                IN  PTRUSTEE    pTrustee1,
                IN  PTRUSTEE    pTrustee2,
                IN  PBOOL       pfMatch)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Assume failure...
    //
    *pfMatch = FALSE;

    //
    // Make sure they are the same type...
    //
    if(pTrustee1->MultipleTrusteeOperation ==
                                        pTrustee2->MultipleTrusteeOperation)
    {
        //
        // Ok, first compare the base trustee information...
        //
        if(pTrustee1->TrusteeForm == pTrustee2->TrusteeForm)
        {
            //
            // Now, the trustee form...  If they match, it's easy... Otherwise,
            // we'll have to do some lookups...
            //
            if(pTrustee1->TrusteeForm == pTrustee2->TrusteeForm)
            {
                if(pTrustee1->TrusteeForm == TRUSTEE_IS_NAME)
                {
                    if(_wcsicmp(pTrustee1->ptstrName,
                                pTrustee2->ptstrName) == 0)
                    {
                        *pfMatch = TRUE;
                    }
                }
                else
                {
                    *pfMatch = RtlEqualSid((PSID)(pTrustee1->ptstrName),
                                          (PSID)(pTrustee2->ptstrName));
                }
            }
        }
        else
        {
            //
            // We'll look it up...
            //
            PSID        pKnownSid;
            PTRUSTEE    pLookupTrustee;
            if(pTrustee1->TrusteeForm == TRUSTEE_IS_NAME)
            {
                pLookupTrustee = pTrustee1;
                pKnownSid = (PSID)pTrustee2->ptstrName;
            }
            else
            {
                pLookupTrustee = pTrustee2;
                pKnownSid = (PSID)pTrustee1->ptstrName;
            }

            PSID            pNewSid;
            SID_NAME_USE    SidType;
            dwErr = AccctrlLookupSid(pwszServer,
                                     pLookupTrustee->ptstrName,
                                     TRUE,
                                     &pNewSid,
                                     &SidType);
            if(dwErr == ERROR_SUCCESS)
            {
                *pfMatch = RtlEqualSid(pKnownSid,
                                       pNewSid);
                AccFree(pNewSid);
            }
        }

        //
        // Now, if that worked, look for the multiple trustee case
        //
        if(dwErr == ERROR_SUCCESS && *pfMatch == TRUE &&
                pTrustee1->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
        {
            dwErr = DoTrusteesMatch(pwszServer,
                                    pTrustee1->pMultipleTrustee,
                                    pTrustee2->pMultipleTrustee,
                                    pfMatch);
        }
    }
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccessMaskForAccessEntry
//
//  Synopsis:   Converts a Provider Independent access entry to an NT
//              access mask format.
//
//  Arguments:  [IN     pAE]            --  The access entry that gets
//                                          converted
//
//  Returns:    Converted acess mask
//
//  Notes:
//
//----------------------------------------------------------------------------
ACCESS_MASK
AccessMaskForAccessEntry(IN PACTRL_ACCESS_ENTRY  pAE,
                         IN  SE_OBJECT_TYPE      ObjType)
{
    ACCESS_MASK RetMask = 0;

    //
    // We have some standard rights, so we'll add those in
    //
    if((pAE->Access & (ACTRL_STD_RIGHTS_ALL)) != 0)
    {
        RetMask = (pAE->Access & ACTRL_STD_RIGHTS_ALL) >> 11;
    }

    if((pAE->Access & (ACTRL_SYSTEM_ACCESS)) != 0)
    {
        RetMask |= ACCESS_SYSTEM_SECURITY;
    }

    //
    // Then, we or in the rest of the access bits, plus the provider specific
    // bits.
    //
    RetMask |= (pAE->Access & ~(ACTRL_STD_RIGHTS_ALL | ACTRL_SYSTEM_ACCESS));
    RetMask |= pAE->ProvSpecificAccess;

    //
    // Handle any special case stuff here
    //
    switch (ObjType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
    default:
        break;
    }

    return(RetMask);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAccessMaskToActrlAccess
//
//  Synopsis:   Converts an NT access mask to the appropriate Provider
//              Independent format.
//
//  Arguments:  [IN     Access]         --  Access mask to convert
//              [IN     ObjType]        --  Type of the object
//              [IN     KernelObjectType]   If this is a kernel object, the type of the
//                                          object
//              [IN     pAE]            --  The access entry that gets
//                                          modified
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
AccConvertAccessMaskToActrlAccess(IN  ACCESS_MASK           Access,
                                  IN  SE_OBJECT_TYPE        ObjType,
                                  IN  MARTA_KERNEL_TYPE     KernelObjectType,
                                  IN  PACTRL_ACCESS_ENTRY   pAE)
{

    //
    // Ok, first thing we'll have to do is look for and remove any generic
    // rights.
    //
    GENERIC_MAPPING GenMap = {0, 0, 0, 0};
    switch(ObjType)
    {
    case SE_FILE_OBJECT:
    case SE_LMSHARE:
        GenMap.GenericRead    = FILE_GENERIC_READ;
        GenMap.GenericWrite   = FILE_GENERIC_WRITE;
        GenMap.GenericExecute = FILE_GENERIC_EXECUTE;
        GenMap.GenericAll     = FILE_ALL_ACCESS;
        break;

    case SE_SERVICE:
        GenMap.GenericRead    =  STANDARD_RIGHTS_READ               |
                                    SERVICE_QUERY_CONFIG            |
                                    SERVICE_QUERY_STATUS            |
                                    SERVICE_ENUMERATE_DEPENDENTS    |
                                    SERVICE_INTERROGATE;

        GenMap.GenericWrite   = STANDARD_RIGHTS_WRITE               |
                                    SERVICE_CHANGE_CONFIG;

        GenMap.GenericExecute = STANDARD_RIGHTS_EXECUTE             |
                                    SERVICE_START                   |
                                    SERVICE_STOP                    |
                                    SERVICE_PAUSE_CONTINUE          |
                                    SERVICE_USER_DEFINED_CONTROL;

        GenMap.GenericAll     = SERVICE_ALL_ACCESS;
        break;

    case SE_PRINTER:
        GenMap.GenericRead    = PRINTER_READ;
        GenMap.GenericWrite   = PRINTER_WRITE;
        GenMap.GenericExecute = PRINTER_EXECUTE;
        GenMap.GenericAll     = PRINTER_ALL_ACCESS;
        break;

    case SE_REGISTRY_KEY:
        GenMap.GenericRead    = KEY_READ;
        GenMap.GenericWrite   = KEY_WRITE;
        GenMap.GenericExecute = KEY_EXECUTE;
        GenMap.GenericAll     = KEY_ALL_ACCESS;
        break;

    case SE_KERNEL_OBJECT:
        switch ( KernelObjectType )
        {
//        case MARTA_WMI_GUID:
//            GenMap.GenericRead    = WMIGUID_QUERY;
//            GenMap.GenericWrite   = WMIGUID_SET;
//            GenMap.GenericExecute = WMIGUID_EXECUTE;
//            GenMap.GenericAll     = WMIGUID_QUERY | WMIGUID_SET | WMIGUID_EXECUTE;
//            break;

        case MARTA_EVENT:
        case MARTA_EVENT_PAIR:
        case MARTA_MUTANT:
        case MARTA_PROCESS:
        case MARTA_SECTION:
        case MARTA_SEMAPHORE:
        case MARTA_SYMBOLIC_LINK:
        case MARTA_THREAD:
        case MARTA_TIMER:
        case MARTA_JOB:
        default:
            GenMap.GenericRead    = STANDARD_RIGHTS_READ     | 0x1;
            GenMap.GenericWrite   = STANDARD_RIGHTS_WRITE    | 0x2;
            GenMap.GenericExecute = STANDARD_RIGHTS_EXECUTE  | 0x4;
            GenMap.GenericAll     = STANDARD_RIGHTS_REQUIRED | 0xFFFF;
            break;

        }
        break;

    case SE_WINDOW_OBJECT:
        GenMap.GenericRead    = STANDARD_RIGHTS_READ     | 0x1;
        GenMap.GenericWrite   = STANDARD_RIGHTS_WRITE    | 0x2;
        GenMap.GenericExecute = STANDARD_RIGHTS_EXECUTE  | 0x4;
        GenMap.GenericAll     = STANDARD_RIGHTS_REQUIRED | 0x1FF;
        break;

    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        GenMap.GenericRead    = GENERIC_READ_MAPPING;
        GenMap.GenericWrite   = GENERIC_WRITE_MAPPING;
        GenMap.GenericExecute = GENERIC_EXECUTE_MAPPING;
        GenMap.GenericAll     = GENERIC_ALL_MAPPING;
        break;
    }

    MapGenericMask(&Access,
                   &GenMap);

    //
    // Look for the known entries first
    //
    if((Access & STANDARD_RIGHTS_ALL) != 0)
    {
        pAE->Access = (Access & STANDARD_RIGHTS_ALL) << 11;
    }

    if((Access & ACCESS_SYSTEM_SECURITY) != 0)
    {
        pAE->Access |= ACTRL_SYSTEM_ACCESS;
    }

    //
    // Add in the remaining rights
    //
    pAE->Access |= (Access & ~(STANDARD_RIGHTS_ALL | ACCESS_SYSTEM_SECURITY ));

}




//+---------------------------------------------------------------------------
//
//  Function:  LoadDLLFuncTable
//
//  Synopsis:
//
//  Arguments:
//+---------------------------------------------------------------------------
DWORD
LoadDLLFuncTable()
{
    DWORD dwErr;

    if( !(DLLFuncs.dwFlags & LOADED_ALL_FUNCS))
    {
        HINSTANCE NetApiHandle = NULL;
        HINSTANCE SamLibHandle = NULL;
        HINSTANCE WinspoolHandle = NULL;

        //
        // Load the functions needed from netapi32.dll
        //
        NetApiHandle = LoadLibraryA( "NetApi32" );
        if(NetApiHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetApiBufferFree = (PNET_API_BUFFER_FREE)
            GetProcAddress( NetApiHandle, "NetApiBufferFree");
        if(DLLFuncs.PNetApiBufferFree == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetShareGetInfo = (PNET_SHARE_GET_INFO)
            GetProcAddress( NetApiHandle, "NetShareGetInfo");
        if(DLLFuncs.PNetShareGetInfo == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetShareSetInfo = (PNET_SHARE_SET_INFO)
            GetProcAddress( NetApiHandle, "NetShareSetInfo");
        if(DLLFuncs.PNetShareSetInfo == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PNetDfsGetInfo = (PNET_DFS_GET_INFO)
            GetProcAddress( NetApiHandle, "NetDfsGetInfo");
        if(DLLFuncs.PNetDfsGetInfo == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PI_NetGetDCList = (PINET_GET_DC_LIST)
            GetProcAddress( NetApiHandle, "I_NetGetDCList");
        if(DLLFuncs.PI_NetGetDCList == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        //
        // Load the functions needed from samlib.dll
        //
        SamLibHandle = LoadLibraryA( "Samlib" );
        if(SamLibHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamCloseHandle = (PSAM_CLOSE_HANDLE)
            GetProcAddress( SamLibHandle, "SamCloseHandle");
        if(DLLFuncs.PSamCloseHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamOpenDomain = (PSAM_OPEN_DOMAIN)
            GetProcAddress( SamLibHandle, "SamOpenDomain");
        if(DLLFuncs.PSamOpenDomain == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamConnect = (PSAM_CONNECT)
            GetProcAddress( SamLibHandle, "SamConnect");
        if(DLLFuncs.PSamConnect == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamGetMembersInGroup = (PSAM_GET_MEMBERS_IN_GROUP)
            GetProcAddress( SamLibHandle, "SamGetMembersInGroup");
        if(DLLFuncs.PSamGetMembersInGroup == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamOpenGroup = (PSAM_OPEN_GROUP)
            GetProcAddress( SamLibHandle, "SamOpenGroup");
        if(DLLFuncs.PSamOpenGroup == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamGetMembersInAlias = (PSAM_GET_MEMBERS_IN_ALIAS)
            GetProcAddress( SamLibHandle, "SamGetMembersInAlias");
        if(DLLFuncs.PSamGetMembersInAlias == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSamOpenAlias = (PSAM_OPEN_ALIAS)
            GetProcAddress( SamLibHandle, "SamOpenAlias");
        if(DLLFuncs.PSamOpenAlias == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        //
        // Load functions from winspool.drv
        //

        WinspoolHandle = LoadLibraryA( "winspool.drv" );
        if(WinspoolHandle == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.POpenPrinter = (POPEN_PRINTER)
            GetProcAddress( WinspoolHandle, "OpenPrinterW");
        if(DLLFuncs.POpenPrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PClosePrinter = (PCLOSE_PRINTER)
            GetProcAddress( WinspoolHandle, "ClosePrinter");
        if(DLLFuncs.PClosePrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PSetPrinter = (PSET_PRINTER)
            GetProcAddress( WinspoolHandle, "SetPrinterW");
        if(DLLFuncs.PSetPrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }

        DLLFuncs.PGetPrinter = (PGET_PRINTER)
            GetProcAddress( WinspoolHandle, "GetPrinterW");
        if(DLLFuncs.PGetPrinter == NULL)
        {
            dwErr = GetLastError();
            return (dwErr);
        }


        DLLFuncs.dwFlags |= LOADED_ALL_FUNCS;
    }

    return (NO_ERROR);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccSetEntriesInAList
//
//  Synopsis:   Helper function.  Adds the given access entries to an optional
//              existing list, and returns the resultant list
//
//  Arguments:  [IN  cEntries]      --  Number of items to add
//              [IN  pAccessEntryList]  List to add
//              [IN  AccessMode]    --  How to do the add (MERGE or SET)
//              [IN  lpProperty]    --  Property to do the add for
//              [IN  fDoOldStyleMerge]  If TRUE, does an NT4 ACLAPI style
//                                      merge (Existing explicit entries are
//                                      removed).  Otherwise, and new style
//                                      merge is done.
//              [IN  pOldList]      --  Optional.  If present, the new items
//                                      are merged with this list [assuming a
//                                      merge operation].
//              [OUT ppNewList]     --  Where the new list is returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
AccSetEntriesInAList(IN  ULONG                 cEntries,
                     IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                     IN  ACCESS_MODE           AccessMode,
                     IN  SECURITY_INFORMATION  SeInfo,
                     IN  LPCWSTR              lpProperty,
                     IN  BOOL                  fDoOldStyleMerge,
                     IN  PACTRL_AUDITW         pOldList,
                     OUT PACTRL_AUDITW        *ppNewList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, a little parameter validation...
    //
    if(pAccessEntryList == NULL || ppNewList == NULL ||
       (SeInfo != SACL_SECURITY_INFORMATION &&
                                         SeInfo != DACL_SECURITY_INFORMATION))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CAccessList AccList;
        dwErr = AccList.SetObjectType(SE_UNKNOWN_OBJECT_TYPE);

        if(dwErr == ERROR_SUCCESS)
        {
            if(pOldList != NULL && AccessMode != SET_ACCESS)
            {
                dwErr = AccList.AddAccessLists(SeInfo,
                                               pOldList,
                                               FALSE);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // We need to build a ACTRL_ALIST
            //
            ACTRL_ACCESSW           AList;
            ACTRL_PROPERTY_ENTRY    APE;
            ACTRL_ACCESS_ENTRY_LIST AAEL;

            AAEL.cEntries    = cEntries;
            AAEL.pAccessList = pAccessEntryList;

            APE.lpProperty       = (PWSTR)lpProperty;
            APE.pAccessEntryList = &(AAEL);
            APE.fListFlags       = 0;

            AList.cEntries            = 1;
            AList.pPropertyAccessList = &APE;

            //
            // Now, we'll just do another add...
            //
            if(AccessMode == REVOKE_ACCESS)
            {
                dwErr = AccList.RevokeTrusteeAccess(SeInfo,
                                                    &AList,
                                                    (PWSTR)lpProperty);
            }
            else
            {
                dwErr = AccList.AddAccessLists(SeInfo,
                                               &AList,
                                               AccessMode == GRANT_ACCESS ?
                                                                    TRUE  :
                                                                    FALSE,
                                               fDoOldStyleMerge);

            }
        }

        //
        // If all of that worked, we'll simply marshal it up, and return it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccList.MarshalAccessLists(
                                        SeInfo,
                                        FLAG_ON(SeInfo,
                                                DACL_SECURITY_INFORMATION) ?
                                                                ppNewList  :
                                                                NULL,
                                        FLAG_ON(SeInfo,
                                                SACL_SECURITY_INFORMATION) ?
                                                                ppNewList  :
                                                                NULL);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAccessToSecurityDescriptor
//
//  Synopsis:   Helper function.  Converts a set of access lists and owner/
//              group into a security descriptor.  Only items that are present
//              are added.
//
//  Arguments:  [IN  pAccessList]   --  OPTIONAL.  Access list to convert
//              [IN  pAuditList]    --  OPTIONAL.  Audit list to add
//              [IN  lpOwner]       --  OPTIONAL.  Owner to add
//              [IN  lpGroup]       --  OPTIONAL.  Group to add
//              [OUT ppSecDescriptor]   Where the created security descriptor
//                                      is returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned security descriptor must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertAccessToSecurityDescriptor(IN  PACTRL_ACCESSW        pAccessList,
                                     IN  PACTRL_AUDITW         pAuditList,
                                     IN  LPCWSTR               lpOwner,
                                     IN  LPCWSTR               lpGroup,
                                     OUT PSECURITY_DESCRIPTOR *ppSecDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, verify the parameters.  At least one has to be present
    //
    if(pAccessList == NULL && pAuditList == NULL && lpOwner == NULL &&
                                                              lpGroup == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Initialize our access lists
        //
        CAccessList AccList;

        TRUSTEE_W   Group;
        TRUSTEE_W   Owner;

        dwErr = AccList.SetObjectType(SE_UNKNOWN_OBJECT_TYPE);

        if(dwErr == ERROR_SUCCESS && lpGroup != NULL)
        {
            memset(&Group, 0, sizeof(TRUSTEE_W));
            Group.TrusteeForm = TRUSTEE_IS_NAME;
            Group.ptstrName = (PWSTR)lpGroup;
            dwErr = AccList.AddOwnerGroup(GROUP_SECURITY_INFORMATION,
                                          NULL,
                                          &Group);

        }

        if(dwErr == ERROR_SUCCESS && lpOwner)
        {
            memset(&Owner, 0, sizeof(TRUSTEE_W));
            Owner.TrusteeForm = TRUSTEE_IS_NAME;
            Owner.ptstrName = (PWSTR)lpOwner;
            dwErr = AccList.AddOwnerGroup(OWNER_SECURITY_INFORMATION,
                                          &Owner,
                                          NULL);
        }

        if(dwErr == ERROR_SUCCESS && pAccessList != NULL)
        {
            dwErr = AccList.AddAccessLists(DACL_SECURITY_INFORMATION,
                                           pAccessList,
                                           FALSE);
        }

        if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
        {
            dwErr = AccList.AddAccessLists(SACL_SECURITY_INFORMATION,
                                           pAuditList,
                                           FALSE);
        }

        //
        // Now, build the Security Descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_INFORMATION    SeInfo;
            dwErr = AccList.BuildSDForAccessList(ppSecDescriptor,
                                                 &SeInfo,
                                                 ACCLIST_SD_ABSOK   |
                                                           ACCLIST_SD_NOFREE);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertSDToAccess
//
//  Synopsis:   Helper function.  "Cracks" a security descriptor into the
//              associated access lists and owner/group.  Only the OUT
//              parameters that are supplied will be cracked
//
//  Arguments:  [IN  ObjectType]    --  What type of object the security
//                                      descriptor came from
//              [IN  pSecDescriptor]--  Security descriptor to crack
//              [OUT ppAccessList]  --  OPTIONAL.  Where the access list is
//                                      returned.
//              [OUT ppAuditList]   --  OPTIONAL.  Where the audit list is
//                                      returned
//              [OUT lppOwner]      --  OPTIONAL.  Where the owner is returned
//              [OUT lppGroup]      --  OPTIONAL.  Where the group is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned items must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertSDToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                     IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                     OUT PACTRL_ACCESSW      *ppAccessList,
                     OUT PACTRL_AUDITW       *ppAuditList,
                     OUT LPWSTR              *lppOwner,
                     OUT LPWSTR              *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Make sure we have valid parameters
    //
    if(pSecDescriptor == NULL || ObjectType == SE_UNKNOWN_OBJECT_TYPE)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Make sure we have something to do
        //
        SECURITY_INFORMATION    SeInfo = 0;

        if(ppAccessList != NULL)
        {
            SeInfo |= DACL_SECURITY_INFORMATION;
        }

        if(ppAuditList != NULL)
        {
            SeInfo |= SACL_SECURITY_INFORMATION;
        }

        if(lppOwner != NULL)
        {
            SeInfo |= OWNER_SECURITY_INFORMATION;
        }

        if(lppGroup != NULL)
        {
            SeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(SeInfo != 0)
        {
            CAccessList AccList;

            dwErr = AccList.SetObjectType(ObjectType);

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccList.AddSD(pSecDescriptor,
                                      SeInfo,
                                      NULL);

                //
                // Now, build our individual lists from it...
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AccList.MarshalAccessLists(SeInfo,
                                                       ppAccessList,
                                                       ppAuditList);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // Save off the strings
                        //
                        if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                        {
                            PTRUSTEE_W  pOwner;

                            dwErr = AccList.GetSDSidAsTrustee(
                                            OWNER_SECURITY_INFORMATION,
                                            &pOwner);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                ACC_ALLOC_AND_COPY_STRINGW(
                                                        pOwner->ptstrName,
                                                       *lppOwner,
                                                        dwErr);
                                AccFree(pOwner);
                            }
                        }

                        if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                        {
                            PTRUSTEE_W  pGroup;

                            dwErr = AccList.GetSDSidAsTrustee(
                                            GROUP_SECURITY_INFORMATION,
                                            &pGroup);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                ACC_ALLOC_AND_COPY_STRINGW(
                                                    pGroup->ptstrName,
                                                    *lppGroup,
                                                    dwErr);
                                AccFree(pGroup);
                            }

                            if(dwErr != ERROR_SUCCESS &&
                               FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                            {
                                AccFree(*lppOwner);
                            }
                        }

                        if(dwErr != ERROR_SUCCESS)
                        {
                            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                            {
                                AccFree(ppAccessList);
                            }

                            if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                            {
                                AccFree(ppAuditList);
                            }
                        }
                    }
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccGetAccessForTrustee
//
//  Synopsis:   Helper function.  Determines the access/audits for the
//              given trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to check access for
//              [IN  pAcl]          --  Acl to get information from
//              [IN  SeInfo]        --  Whether to handle this as an access or
//                                      audit list
//              [IN  pwszProperty]  --  Property on the acl to use
//              [OUT pAllowed]      --  Where the allowed/success mask is
//                                      returned
//              [OUT pDenied]       --  Where the denied/failure mask is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned items must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccGetAccessForTrustee(IN PTRUSTEE                  pTrustee,
                       IN PACL                      pAcl,
                       IN SECURITY_INFORMATION      SeInfo,
                       IN PWSTR                     pwszProperty,
                       IN PACCESS_RIGHTS            pAllowed,
                       IN PACCESS_RIGHTS            pDenied)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, initialize our access list
    //
    CAccessList AccList;

    PACL    pDAcl = NULL, pSAcl = NULL;

    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        pDAcl = pAcl;
    }
    else
    {
        pSAcl = pAcl;
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccList.AddAcl(pDAcl,
                               pSAcl,
                               NULL,
                               NULL,
                               SeInfo,
                               NULL,
                               TRUE);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, get the rights..
        //
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
        {
            dwErr = AccList.GetExplicitAccess(pTrustee,
                                              pwszProperty,
                                              pDenied,
                                              pAllowed);
        }
        else
        {
            dwErr = AccList.GetExplicitAudits(pTrustee,
                                              pwszProperty,
                                              pDenied,
                                              pAllowed);
        }
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAclToAccess
//
//  Synopsis:   Helper function. Converts an ACL into access lists
//
//  Arguments:  [IN  ObjectType]    --  Type of object the acl came from
//              [IN  pAcl]          --  Acl to convert
//              [OUT ppAccessList]  --  Where to return the access list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned items must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertAclToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                      IN  PACL                 pAcl,
                      OUT PACTRL_ACCESSW      *ppAccessList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Make sure we have valid parameters
    //
    if(pAcl == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CAccessList AccList;

        dwErr = AccList.SetObjectType(ObjectType);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccList.AddAcl(pAcl,
                                   NULL,
                                   NULL,
                                   NULL,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   TRUE);

            //
            // Now, build our individual lists from it...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccList.MarshalAccessLists(DACL_SECURITY_INFORMATION,
                                                   ppAccessList,
                                                   NULL);
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccConvertAccessToSD
//
//  Synopsis:   Helper function.  Converts a set of access lists and owner/
//              group into a security descriptor.
//
//  Arguments:  [IN  ObjectType]    --  Type of object to add
//              [IN  SeInfo]        --  Items being set in the SD
//              [IN  pAccessList]   --  OPTIONAL.  Access list to convert
//              [IN  pAuditList]    --  OPTIONAL.  Audit list to add
//              [IN  lpOwner]       --  OPTIONAL.  Owner to add
//              [IN  lpGroup]       --  OPTIONAL.  Group to add
//              [IN  fOpts]         --  Options to use when building the SD
//              [OUT ppSecDescriptor]   Where the created security descriptor
//                                      is returned.
//              [OUT pcSDSize]      --  Where the size of the security descriptor
//                                      is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned security descriptor must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccConvertAccessToSD(IN  SE_OBJECT_TYPE         ObjectType,
                     IN  SECURITY_INFORMATION   SeInfo,
                     IN  PACTRL_ACCESSW         pAccessList,
                     IN  PACTRL_AUDITW          pAuditList,
                     IN  LPWSTR                 lpOwner,
                     IN  LPWSTR                 lpGroup,
                     IN  ULONG                  fOpts,
                     OUT PSECURITY_DESCRIPTOR  *ppSD,
                     OUT PULONG                 pcSDSize)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, verify the parameters.
    //
    if(ObjectType > SE_PROVIDER_DEFINED_OBJECT || ppSD == NULL || pcSDSize == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                                                        pAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                                                        pAuditList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Initialize our access lists
        //
        CAccessList AccList;

        TRUSTEE_W   Group;
        TRUSTEE_W   Owner;

        dwErr = AccList.SetObjectType(ObjectType);

        if(dwErr == ERROR_SUCCESS && lpGroup != NULL)
        {
            memset(&Group, 0, sizeof(TRUSTEE_W));
            Group.TrusteeForm = TRUSTEE_IS_NAME;
            Group.ptstrName = (PWSTR)lpGroup;
            dwErr = AccList.AddOwnerGroup(GROUP_SECURITY_INFORMATION,
                                          NULL,
                                          &Group);

        }

        if(dwErr == ERROR_SUCCESS && lpOwner)
        {
            memset(&Owner, 0, sizeof(TRUSTEE_W));
            Owner.TrusteeForm = TRUSTEE_IS_NAME;
            Owner.ptstrName = (PWSTR)lpOwner;
            dwErr = AccList.AddOwnerGroup(OWNER_SECURITY_INFORMATION,
                                          &Owner,
                                          NULL);
        }

        if(dwErr == ERROR_SUCCESS && pAccessList != NULL)
        {
            dwErr = AccList.AddAccessLists(DACL_SECURITY_INFORMATION,
                                           pAccessList,
                                           FALSE);
        }

        if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
        {
            dwErr = AccList.AddAccessLists(SACL_SECURITY_INFORMATION,
                                           pAuditList,
                                           FALSE);
        }

        //
        // Now, build the Security Descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_INFORMATION    LocalSeInfo;
            dwErr = AccList.BuildSDForAccessList(ppSD,
                                                 &LocalSeInfo,
                                                 ACCLIST_SD_NOFREE      |
                                                 (FLAG_ON(fOpts, ACCCONVERT_SELF_RELATIVE) ? 0 : ACCLIST_SD_ABSOK)
                                                 );

            if(dwErr == ERROR_SUCCESS)
            {
                *pcSDSize = AccList.QuerySDSize();
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccGetExplicitEntries
//
//  Synopsis:   Helper function. Gets the list of explicit entries for
//              the given trustee from the acl.
//
//  Arguments:  [IN  pTrustee]      --  Trustee to get the list for
//              [IN  ObjectType]    --  Type of object the acl came from
//              [IN  pAcl]          --  Acl to examine
//              [IN  pwszProperty]  --  Which acl property to examine
//              [OUT pcEntries]     --  Where the count of entries is returned
//              [OUT ppAEList]      --  Where the list of explicit entries
//                                      is returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned list must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AccGetExplicitEntries(IN  PTRUSTEE              pTrustee,
                      IN  SE_OBJECT_TYPE        ObjectType,
                      IN  PACL                  pAcl,
                      IN  PWSTR                 pwszProperty,
                      OUT PULONG                pcEntries,
                      OUT PACTRL_ACCESS_ENTRYW *ppAEList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Make sure we have valid parameters
    //
    if(pAcl == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CAccessList AccList;

        dwErr = AccList.SetObjectType(ObjectType);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccList.AddAcl(pAcl,
                                   NULL,
                                   NULL,
                                   NULL,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   TRUE);

            //
            // Now, build our individual lists from it...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccList.GetExplicitEntries(pTrustee,
                                                   pwszProperty,
                                                   DACL_SECURITY_INFORMATION,
                                                   pcEntries,
                                                   ppAEList);
            }
        }
    }

    return(dwErr);
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertStringToSid
//
//  Synopsis:   Converts a string representation of a SID back into a SID.
//              This is the converse of RtlConvertSidToUnicode.  If a non-
//              SID string is given, an error is returned.
//
//  Arguments:  [IN  pwszString]    --  String to convert
//              [OUT ppSid]         --  Where the convertd sid is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NONE_MAPPED   --  The given string does not represent
//                                      a SID
//
//  Notes:      The returned sid must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertStringToSid(IN  PWSTR    pwszString,
                   OUT PSID    *ppSid)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(wcslen(pwszString) < 2 ||
                           (*pwszString != L'S' && *(pwszString + 1) != L'-'))
    {
        return(ERROR_NONE_MAPPED);
    }

    acDebugOut((DEB_TRACE_SID, "Converting %ws to sid\n", pwszString));

    UCHAR                       Revision;
    UCHAR                       cSubs;
    SID_IDENTIFIER_AUTHORITY    IDAuth;
    PULONG                      pSubAuth = NULL;
    PWSTR                       pwszEnd;

    PWSTR   pwszCurr = pwszString + 2;

    Revision = (UCHAR)wcstol(pwszCurr, &pwszEnd, 10);

    pwszCurr = pwszEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    PWSTR   pwszNext = wcschr(pwszCurr, L'-');

    if(pwszNext - pwszCurr == 6)
    {
        for(ULONG iIndex = 0; iIndex < 6; iIndex++)
        {
            IDAuth.Value[iIndex] = (UCHAR)pwszNext[iIndex];
        }

        pwszCurr +=6;
    }
    else
    {
         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         ULONG Auto = wcstoul(pwszCurr, &pwszEnd, 10);
         IDAuth.Value[5] = (UCHAR)Auto & 0xF;
         IDAuth.Value[4] = (UCHAR)((Auto >> 8) & 0xFF);
         IDAuth.Value[3] = (UCHAR)((Auto >> 16) & 0xFF);
         IDAuth.Value[2] = (UCHAR)((Auto >> 24) & 0xFF);
         pwszCurr = pwszEnd;
    }

    pwszCurr++;

    //
    // Now, count the number of sub auths
    //
    cSubs = 0;
    pwszNext = pwszCurr;

    if(pwszCurr != NULL)
    {
        cSubs++;
    }

    while(TRUE)
    {
        pwszNext = wcschr(pwszNext,'-');
        if(pwszNext == NULL || *(pwszNext + 1) == L'\0')
        {
            break;
        }
        pwszNext++;
        cSubs++;
    }

    if(cSubs != 0)
    {
        pSubAuth = (PULONG)AccAlloc(cSubs * sizeof(ULONG));
        if(pSubAuth == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            for(ULONG iIndex = 0; iIndex < cSubs; iIndex++)
            {
                pSubAuth[iIndex] = wcstoul(pwszCurr, &pwszEnd, 10);
                pwszCurr = pwszEnd + 1;
            }
        }
    }
    else
    {
        dwErr = ERROR_NONE_MAPPED;
    }

    //
    // Now, create the SID
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppSid = (PSID)AccAlloc(sizeof(SID) + cSubs * sizeof(ULONG));
        if(*ppSid == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            PISID pSid = (PISID)*ppSid;
            pSid->Revision = Revision;
            pSid->SubAuthorityCount = cSubs;
            memcpy(&(pSid->IdentifierAuthority),
                   &IDAuth,
                   sizeof(SID_IDENTIFIER_AUTHORITY));
            memcpy(pSid->SubAuthority,
                   pSubAuth,
                   cSubs * sizeof(ULONG));

#if DBG
            UNICODE_STRING SidString;
            NTSTATUS Status = RtlConvertSidToUnicodeString(&SidString,
                                                           pSid,
                                                           TRUE);
            if(!NT_SUCCESS(Status))
            {
                acDebugOut((DEB_TRACE_SID, "Can't convert sid to string: 0x%lx\n",
                            Status));
            }
            else
            {
                acDebugOut((DEB_TRACE_SID, "Converted sid: %wZ\n", &SidString));
                RtlFreeUnicodeString(&SidString);
            }

            if(FLAG_ON(acInfoLevel, DEB_TRACE_SID))
            {
                DebugBreak();
            }
#endif
        }
    }

    AccFree(pSubAuth);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetCurrentToken
//
//  Synopsis:   Gets the token from the current thread, if possible, or the
//              process.
//
//  Arguments:  [IN  pHandle]       --  Where the token is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetCurrentToken( OUT HANDLE *pHandle )
{
    DWORD dwErr = ERROR_SUCCESS;

    //
    // see if a thread token exists
    //
    if(!OpenThreadToken(GetCurrentThread(),
                        TOKEN_QUERY,
                        TRUE,
                        pHandle))
    {
        dwErr = GetLastError();

        //
        // if not, use the process token
        //
        if(dwErr == ERROR_NO_TOKEN)
        {
            dwErr = ERROR_SUCCESS;
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_QUERY,
                                  pHandle))
            {
                dwErr = GetLastError();
            }
        }
    }

    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\dsctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dsctx.h
//
//  Contents:   NT Marta DS object context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__DSCTX_H__)
#define __DSCTX_H__

#include <windows.h>
#include <ds.h>
#include <ldapsp.h>
#include <assert.h>
#include <ntldap.h>
#include <rpc.h>
#include <rpcndr.h>
#include <ntdsapi.h>
#include <ole2.h>

//
// CDsObjectContext.  This represents a DS object to the NT Marta
// infrastructure
//

class CDsObjectContext
{
public:

    //
    // Construction
    //

    CDsObjectContext ();

    ~CDsObjectContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetDsObjectProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetDsObjectRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetDsObjectRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

    DWORD GetDsObjectGuid (
             GUID* pGuid
             );

private:

    //
    // Reference count
    //

    DWORD               m_cRefs;

    //
    // LDAP URL components
    //

    LDAP_URL_COMPONENTS m_LdapUrlComponents;

    //
    // LDAP binding handle
    //

    LDAP*               m_pBinding;
};

DWORD
MartaReadDSObjSecDesc(IN  PLDAP                  pLDAP,
                      IN  LPWSTR                 pszObject,
                      IN  SECURITY_INFORMATION   SeInfo,
                      OUT PSECURITY_DESCRIPTOR  *ppSD);

DWORD
MartaStampSD(IN  LPWSTR               pszObject,
             IN  ULONG                cSDSize,
             IN  SECURITY_INFORMATION SeInfo,
             IN  PSECURITY_DESCRIPTOR pSD,
             IN  PLDAP                pLDAP);

#define SD_PROP_NAME L"nTSecurityDescriptor"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\acclist.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        acclist.cxx
//
//  Contents:    Class implementation of the CAccessList class
//
//  Classes:     CAccessList
//
//  History:     28-Jul-96      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <alsup.hxx>

#include <seopaque.h>
#include <sertlp.h>

//+---------------------------------------------------------------------------
//
//  Member:     CAcccessList::CAccessList, public
//
//  Synopsis:   Constructor for the class
//
//  Arguments:  None
//
//  Returns:    Void
//
//----------------------------------------------------------------------------
CAccessList::CAccessList()      :
        _AccList(DelAcclistNode),
        _TrusteeList (DelTrusteeNode),
        _pGroup (NULL),
        _pOwner (NULL),
        _fSDValid (FALSE),
        _fFreeSD (FALSE),
        _pSD (NULL),
        _cSDSize (0),
        _fDAclFlags (0),
        _fSAclFlags (0),
        _ObjType (SE_UNKNOWN_OBJECT_TYPE),
        _pLDAP (NULL),
        _pwszDsPathReference (NULL),
        _pwszLookupServer (NULL)
{
    acDebugOut((DEB_TRACE_ACC, "In - out CAccessList::CAccessList\n"));
}





//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::~CAccessList, public
//
//  Synopsis:   Destructor for the class
//
//  Arguments:  None
//
//  Returns:    Void
//
//----------------------------------------------------------------------------
CAccessList::~CAccessList()
{
    acDebugOut((DEB_TRACE_ACC, "In - out CAccessList::~CAccessList\n"));

    AccFree(_pGroup);
    AccFree(_pOwner);

    if(_fFreeSD == TRUE)
    {
        AccFree(_pSD);
    }

    AccFree(_pwszLookupServer);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddSD, public
//
//  Synopsis:   Adds a new security descriptor to the list.  It converts the
//              acls into an access list
//
//  Arguments:  [IN pSD]        --      The information about the security
//                                      descriptor
//              [IN SeInfo]     --      SecurityInfo
//              [IN pwszProperty]       Property name
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddSD(IN   PSECURITY_DESCRIPTOR    pSD,
                         IN   SECURITY_INFORMATION    SeInfo,
                         IN   PWSTR                   pwszProperty,
                         IN   BOOL                    fAddAll)
{
    acDebugOut((DEB_TRACE_ACC, "In CAccessList::AddSD\n"));

    DWORD   dwErr = ERROR_SUCCESS;


    PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pSD;

    dwErr = AddAcl(RtlpDaclAddrSecurityDescriptor(pISD),
                   RtlpSaclAddrSecurityDescriptor(pISD),
                   RtlpOwnerAddrSecurityDescriptor(pISD),
                   RtlpGroupAddrSecurityDescriptor(pISD),
                   SeInfo,
                   pwszProperty,
                   fAddAll,
                   pISD->Control);

    acDebugOut((DEB_TRACE_ACC, "Out CAccessList::AddSD: 0x%lx\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddAcl, public
//
//  Synopsis:   Adds a new acl to the list.  It converts the acls into an
//              access list
//
//  Arguments:  [IN pDAcl]      --      The DAcl to add
//              [IN pSAcl]      --      The SAcl to add
//              [IN SeInfo]     --      SecurityInfo
//              [IN pwszProperty]       Property name
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddAcl(IN  PACL                 pDAcl,
                          IN  PACL                 pSAcl,
                          IN  PSID                 pOwner,
                          IN  PSID                 pGroup,
                          IN  SECURITY_INFORMATION SeInfo,
                          IN  PWSTR                pwszProperty,
                          IN  BOOL                 fAddAll,
                          IN  ULONG                fControl)
{
    acDebugOut((DEB_TRACE_ACC, "In CAccessList::AddAcl: 0x%lx\n", pDAcl));

    DWORD   dwErr = ERROR_SUCCESS;

    _fSDValid = FALSE;

    //
    // If no parameters are given, just return success
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Ok, save off the group and owner if they exist
    //
    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
    {
        if(pOwner == NULL || RtlValidSid((PSID)pOwner) == FALSE)
        {
            dwErr = ERROR_INVALID_OWNER;
        }
        else
        {
            ACC_ALLOC_AND_COPY_SID(pOwner, _pOwner, dwErr);
        }
    }

    if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        if(pGroup == NULL || RtlValidSid((PSID)pGroup) == FALSE)
        {
            dwErr = ERROR_INVALID_PRIMARY_GROUP;
        }
        else
        {
            ACC_ALLOC_AND_COPY_SID(pGroup, _pGroup, dwErr);
        }
    }

    //
    // Otherwise, we'll start processing them...
    //
    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        dwErr = ConvertAclToAccess(DACL_SECURITY_INFORMATION,
                                   pDAcl,
                                   pwszProperty,
                                   fAddAll,
                                   (BOOL)FLAG_ON(fControl, SE_DACL_PROTECTED));
    }

    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
    {
        dwErr = ConvertAclToAccess(SACL_SECURITY_INFORMATION,
                                   pSAcl,
                                   pwszProperty,
                                   fAddAll,
                                   (BOOL)FLAG_ON(fControl, SE_SACL_PROTECTED));
    }

    acDebugOut((DEB_TRACE_ACC, "Out CAccessList::AddAcl: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::RemoveTrusteeFromAccess, public
//
//  Synopsis:   This method goes through and removes any explicit entries from
//              an access list for the given trustee.
//
//  Arguments:  [IN  SeInfo]        --      Type of access list to operate on
//              [IN  pTrustee]      --      Trustee to remove
//              [IN  pwszProperty]  --      If present, this is the property to
//                                          revoke the access on
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::RemoveTrusteeFromAccess(IN  SECURITY_INFORMATION  SeInfo,
                                           IN  PTRUSTEE              pTrustee,
                                           IN  PWSTR                 pwszProperty OPTIONAL)
{
    acDebugOut((DEB_TRACE_ACC,"In CAccessList::RemoveTrusteeFromAccess\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL PropertiesMatch = FALSE;
    GUID Guid;
    PWSTR pwszNewPropertyName, pwszSourceName;

    //
    // Now, we'll simply process all of the lists, and remove any of the
    // specified entries
    //

    _fSDValid = FALSE;

    //
    // Enumerate through the list
    //
    _AccList.Reset();
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();

    while(pAccNode != NULL && dwErr == ERROR_SUCCESS)
    {
        PropertiesMatch = DoPropertiesMatch(pAccNode->pwszProperty, pwszProperty);

        if(PropertiesMatch == FALSE && pwszProperty != NULL && pAccNode->pwszProperty != NULL)
        {
            //
            // See if we should convert one to/from a guid and then
            // compare it again
            //
            dwErr = UuidFromString(pwszProperty, &Guid);
            if(dwErr == ERROR_SUCCESS)
            {
                pwszSourceName = pAccNode->pwszProperty;
            }
            else
            {
                dwErr = UuidFromString(pAccNode->pwszProperty, &Guid);
                if(dwErr == ERROR_SUCCESS)
                {
                    pwszSourceName = pwszProperty;
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccctrlLookupIdName(_pLDAP,
                                            _pwszDsPathReference,
                                            &Guid,
                                            FALSE,
                                            FALSE,
                                            &pwszNewPropertyName);

                if(dwErr == ERROR_SUCCESS)
                {
                    PropertiesMatch = DoPropertiesMatch(pwszSourceName,
                                                        pwszNewPropertyName);
                }

            }
        }

        if(PropertiesMatch)
        {
            //
            // Get the list we need
            //
            PACTRL_ACCESS_ENTRY_LIST pList = SeInfo == DACL_SECURITY_INFORMATION ?
                                                        pAccNode->pAccessList :
                                                        pAccNode->pAuditList;
            if(pList != NULL)
            {
                //
                // Now, process it...
                //
                ULONG   cRemoved = 0;
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    BOOL    fMatch = FALSE;
                    dwErr = DoTrusteesMatch(_pwszLookupServer,
                                            pTrustee,
                                            &(pList->pAccessList[iIndex].Trustee),
                                            &fMatch);
                    if(dwErr == ERROR_SUCCESS && fMatch == TRUE)
                    {
                        cRemoved++;

                        //
                        // Indicate that this node is to be removed by setting the
                        // access flags to 0xFFFFFFFF
                        //
                        pList->pAccessList[iIndex].Access = 0xFFFFFFFF;
                    }
                }

                //
                // Now, see if we need to do anything...
                //
                if(dwErr == ERROR_SUCCESS && cRemoved != 0)
                {
                    PACTRL_ACCESS_ENTRY_LIST pNew;
                    dwErr = ShrinkList(pList,
                                       cRemoved,
                                       &pNew);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // Finally, replace what is there with our new one
                        //
                        if(SeInfo == DACL_SECURITY_INFORMATION)
                        {
                            CHECK_HEAP
                            AccFree(pAccNode->pAccessList);
                            pAccNode->pAccessList = pNew;
                            if(pNew == NULL)
                            {
                                pAccNode->SeInfo &= ~DACL_SECURITY_INFORMATION;
                            }
                        }
                        else
                        {
                            AccFree(pAccNode->pAuditList);
                            pAccNode->pAuditList = pNew;
                            if(pNew == NULL)
                            {
                                pAccNode->SeInfo &= ~SACL_SECURITY_INFORMATION;
                            }
                        }
                    }

                }
            }

        }
        pAccNode = (PACCLIST_NODE)_AccList.NextData();
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::RemoveTrusteeFromAccess: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::ConvertAclToAccess, private
//
//  Synopsis:   Converts the given dacl/sacl to an ACCLIST_NODE format
//
//  Arguments:  [IN SeInfo]             --      What type of ACL this is
//              [IN pAcl]               --      The Acl to convert
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//              ERROR_INVALID_ACL       --      ACL came in as downlevel
//
//----------------------------------------------------------------------------
DWORD CAccessList::ConvertAclToAccess(IN  SECURITY_INFORMATION SeInfo,
                                      IN  PACL                 pAcl,
                                      IN  PWSTR                pwszProperty,
                                      IN  BOOL                 fAddAll,
                                      IN  BOOL                 fProtected)
{
    acDebugOut((DEB_TRACE_ACC, "In CAccessList::ConvertAclToAccess\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    CSList  AceList((FreeFunc)AccFree);
    ACL     EmptyAcl;
//    CSList  AceList((FreeFunc)DebugFree);

    //
    // Check for the case where we're setting a NULL acl.  If it's a NULL SACL, turn
    // it into an empty one.
    //
    if(pAcl == NULL && FLAG_ON(SeInfo,SACL_SECURITY_INFORMATION))
    {
        EmptyAcl.AclRevision = ACL_REVISION;
        EmptyAcl.Sbz1 = 0;
        EmptyAcl.AclSize = sizeof( ACL );
        EmptyAcl.AceCount = 0;
        EmptyAcl.Sbz2 = 0;

        pAcl = &EmptyAcl;
    }

    if(pAcl == NULL)
    {
        //
        // Ok, find the node for this property
        //
        PACCLIST_NODE   pAccNode;

        dwErr = GetNodeForProperty(_AccList,
                                   pwszProperty,
                                   &pAccNode);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // We'll fill in the information now
            //
            pAccNode->SeInfo |= SeInfo;
            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
            {
                pAccNode->pAccessList = NULL;
                if(fProtected)
                {
                    pAccNode->fState |= ACCLIST_DACL_PROTECTED;
                }
            }
            else
            {
                pAccNode->pAuditList = NULL;
                if(fProtected)
                {
                    pAccNode->fState |= ACCLIST_SACL_PROTECTED;
                }
            }
        }
    }
    else
    {
        //
        // Ok, we've got a valid acl list, so we'll process it...
        //

        //
        // Basically, we'll save off our flags...
        //
        SeInfo == DACL_SECURITY_INFORMATION ?
                                    _fDAclFlags = pAcl->Sbz1  :
                                    _fSAclFlags = pAcl->Sbz1;

        ULONG rgInheritFlags[] = {0,
                                  INHERITED_PARENT,
                                  INHERITED_GRANDPARENT};
        //
        // We need to keep track of the changes in denied/allowed pairs,
        // so that we can determine between the inherited and parent
        // inherited aces are, so that we can mark our new entries
        //
        ULONG   iIFIndex = 0;
        ULONG   PrevIn = 0;
        BOOL    fPrevAllowed = FALSE;


        //
        // Ok, now we'll simply process each of the entries in the list
        //
        PACE_HEADER pAceHeader = (PACE_HEADER)FirstAce(pAcl);
        for(ULONG iAce = 0;
            iAce < pAcl->AceCount && dwErr == ERROR_SUCCESS;
            iAce++, pAceHeader = (PACE_HEADER)NextAce(pAceHeader))
        {
            BOOL    fThisAllowed = FALSE;
            BOOL    fIsExtendedAce = FALSE;
            GUID    PropID;
            GUID   *pPropID = NULL;

            //
            // Ok, now lets try to figure out what type of ACE this is, so we can
            // do the neccessary mapping into the provider rights
            //
            switch(pAceHeader->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                fThisAllowed = TRUE;
                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                fThisAllowed = TRUE;
                fIsExtendedAce = TRUE;
                break;

            //
            // Currently unsupported
            //
            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                dwErr = ERROR_INVALID_ACL;
                break;

            case ACCESS_DENIED_ACE_TYPE:
                break;

            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                fIsExtendedAce = TRUE;
                break;

            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                fIsExtendedAce = TRUE;
                fThisAllowed = TRUE;
                break;

            case SYSTEM_AUDIT_ACE_TYPE:
                fThisAllowed = TRUE;
                break;

            default:
                dwErr = ERROR_INVALID_ACL;
                break;

            }

            LPGUID  pProp = NULL;

            if(dwErr == ERROR_SUCCESS)
            {
                if(fIsExtendedAce == TRUE)
                {
                    PACCESS_ALLOWED_OBJECT_ACE pExAce =
                                       (PACCESS_ALLOWED_OBJECT_ACE)pAceHeader;
                    if(FLAG_ON(pExAce->Flags,ACE_OBJECT_TYPE_PRESENT))
                    {
                        pProp = RtlObjectAceObjectType(pAceHeader);
                    }
                }

                //
                // Pull what we can from the ace header
                //
                if((fThisAllowed == FALSE && fPrevAllowed == TRUE) ||
                    (FLAG_ON(pAceHeader->AceFlags,INHERITED_ACE) &&
                                                                PrevIn == 0))
                {
                    iIFIndex++;
                    ASSERT(iIFIndex < sizeof(rgInheritFlags) / sizeof(ULONG));
                    if(iIFIndex >= sizeof(rgInheritFlags) / sizeof(ULONG))
                    {
                        dwErr = ERROR_INVALID_ACL;
                    }

                    PrevIn = pAceHeader->AceFlags;
                }
                else
                {
                    PrevIn = pAceHeader->AceFlags;
                }

                dwErr = InsertAtoANode(AceList,
                                       pProp,
                                       pAceHeader,
                                       rgInheritFlags[iIFIndex]);
            }
        }
    }

    //
    // Ok, now we'll turn it into PACTRL_ACCESS structure, and call our
    // add access routine
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_ACCESS Access;

        Access.cEntries = 0;

        PACTRL_PROPERTY_ENTRY pAPE = (PACTRL_PROPERTY_ENTRY)
                AccAlloc(max( AceList.QueryCount(), 1 ) * sizeof(ACTRL_PROPERTY_ENTRY));
        if(pAPE == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Access.cEntries = AceList.QueryCount();
            Access.pPropertyAccessList = pAPE;

            //
            // Now, start filling them in...
            //
            AceList.Reset();
            for(ULONG i = 0; i < Access.cEntries; i++)
            {
                if(fProtected)
                {
                    pAPE[i].fListFlags = ACTRL_ACCESS_PROTECTED;
                }


                PACCLIST_ATOACCESS pAToA = (PACCLIST_ATOACCESS)AceList.NextData();
                if(pAToA->pGuid != NULL)
                {
                    dwErr = AccctrlLookupIdName(_pLDAP,
                                                _pwszDsPathReference,
                                                pAToA->pGuid,
                                                TRUE,
                                                FALSE,  // avoid object GUIDs
                                                (PWSTR *)&pAPE[i].lpProperty);

                }

                if(dwErr == ERROR_SUCCESS)
                {
                    pAPE[i].pAccessEntryList = (PACTRL_ACCESS_ENTRY_LIST)
                                    AccAlloc(sizeof(ACTRL_ACCESS_ENTRY_LIST));
                    if(pAPE[i].pAccessEntryList == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    pAPE[i].pAccessEntryList->cEntries =
                                                  pAToA->AceList.QueryCount();

                    pAPE[i].pAccessEntryList->pAccessList =
                        (PACTRL_ACCESS_ENTRY)AccAlloc(
                                        pAPE[i].pAccessEntryList->cEntries *
                                                  sizeof(ACTRL_ACCESS_ENTRY));
                    if(pAPE[i].pAccessEntryList->pAccessList == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        PACTRL_ACCESS_ENTRY pAEL =
                                        pAPE[i].pAccessEntryList->pAccessList;
                        pAToA->AceList.Reset();
                        for(ULONG j = 0;
                            j < pAPE[i].pAccessEntryList->cEntries &&
                                                       dwErr == ERROR_SUCCESS;
                            j++)
                        {

                            PACCLIST_ATOANODE pNode = (PACCLIST_ATOANODE)
                                                    pAToA->AceList.NextData();

                            dwErr = AceToAccessEntry(pNode->pAce,
                                                     pNode->fInherit,
                                                     _ObjType,
                                                     _KernelObjectType,
                                                     &(pAEL[j]));
                        }
                    }
                }
            }

            //
            // Handle the empty case...
            //
            if ( Access.cEntries == 0 && pAcl != NULL ) {

                Access.cEntries = 1;
                pAPE->pAccessEntryList = (PACTRL_ACCESS_ENTRY_LIST)
                                AccAlloc(sizeof(ACTRL_ACCESS_ENTRY_LIST));
                if(pAPE->pAccessEntryList == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    pAPE->pAccessEntryList->cEntries = 0;
                    pAPE->pAccessEntryList->pAccessList = NULL;
                    if(fProtected)
                    {
                        pAPE->fListFlags = ACTRL_ACCESS_PROTECTED;
                    }
                }
            }

            //
            // If all of that worked, add it...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AddAccessLists(SeInfo,
                                       &Access,
                                       TRUE);
            }

            //
            // Regardless of success or failure, delete all memory
            //
            for(i = 0; i < Access.cEntries; i++)
            {
                AccFree((PWSTR *)Access.pPropertyAccessList[i].lpProperty);
                if(Access.pPropertyAccessList[i].pAccessEntryList != NULL)
                {
                    for(ULONG j = 0;
                        j < Access.pPropertyAccessList[i].
                                            pAccessEntryList->cEntries;
                        j++)
                    {
                        if(Access.pPropertyAccessList[i].pAccessEntryList->pAccessList != NULL )
                        {
                            AccFree(Access.pPropertyAccessList[i].
                                             pAccessEntryList->pAccessList[j].lpInheritProperty);
                        }
                    }

                    AccFree(Access.pPropertyAccessList[i].
                                           pAccessEntryList->pAccessList);
                    AccFree(Access.pPropertyAccessList[i].pAccessEntryList);
                }
            }

            AccFree(Access.pPropertyAccessList);
        }
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::ConvertAclToAccess: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::MarshalAccessList, private
//
//  Synopsis:   Marshals the information specified by SeInfo into a single
//              buffer
//
//  Arguments:  [IN  SeInfo]            --      Type of info to marshal
//              [OUT ppAList]           --      Where the information is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERRROR_NOT_ENOUGH_MEMORY--      A memory allocation failed
//
//  Notes:      Memory is allocated as a block via a AccAlloc call and
//              should be freed with a AccFree call
//
//              SeInfo can only contain a SINGLE information value
//
//----------------------------------------------------------------------------
DWORD CAccessList::MarshalAccessList(IN  SECURITY_INFORMATION  SeInfo,
                                     OUT PACTRL_ACCESSW       *ppAList)
{
    acDebugOut((DEB_TRACE_ACC,"In qCAccessList::MarshalAccessList\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    PACCLIST_CNODE  pCNode = NULL;
    ULONG           cItems = 0;

    ASSERT( SeInfo == DACL_SECURITY_INFORMATION || SeInfo == SACL_SECURITY_INFORMATION );

    //
    // First, compress the list...
    //
    dwErr = CompressList(SeInfo,
                         &pCNode,
                         &cItems);
    //
    // Then, we need to get the size of the memory block we need to allocate
    //
    DWORD   cSize = 0;
    DWORD   cAEs = 0;
    PBYTE   pbEndOBuff = NULL;
    ULONG   cUsed = 0;
    ULONG   i = 0;

    CSList  TrusteesToMarshal(NULL);
    CSList  InheritPropsToMarshal((FreeFunc)LocalFree);
//    CSList  InheritPropsToMarshal((FreeFunc)DebugFree);


    for(i = 0; i < cItems && dwErr == ERROR_SUCCESS; i++)
    {
        //
        // Get the list we need
        //
        ULONG cEnts = pCNode[i].cExp + pCNode[i].cL1Inherit +
                                                         pCNode[i].cL2Inherit;

        if(pCNode[i].pList != NULL)
        {

            cUsed++;
            cSize += sizeof(ACTRL_ACCESS_ENTRY) * cEnts;

            if ((SeInfo == DACL_SECURITY_INFORMATION ?
                    pCNode[ i ].pONode->pAccessList->pAccessList : pCNode[ i ].pONode->pAuditList->pAccessList) == NULL )
            {
                pCNode[i].Empty = TRUE;
            }

            //
            // Finally, go through and figure out what trustees we'll need to
            // marshal
            //
            for(ULONG iIndex = 0;
                iIndex < cEnts && dwErr == ERROR_SUCCESS && pCNode[i].Empty == FALSE;
                iIndex++)
            {
                dwErr = TrusteesToMarshal.InsertIfUnique(
                                          &(pCNode[i].pList[iIndex].Trustee),
                                          CompTrustees);
                if(dwErr == ERROR_SUCCESS &&
                   pCNode[i].pList[iIndex].Trustee.MultipleTrusteeOperation ==
                                                       TRUSTEE_IS_IMPERSONATE)
                {
                    dwErr = TrusteesToMarshal.InsertIfUnique(
                             pCNode[i].pList[iIndex].Trustee.pMultipleTrustee,
                             CompTrustees);

                }

                //
                // Now, see if we have any inheritable properties to add
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    if(pCNode[i].pList[iIndex].lpInheritProperty != NULL &&
                        InheritPropsToMarshal.Find(
                            (PVOID)pCNode[i].pList[iIndex].lpInheritProperty,
                            CompInheritProps) == NULL)
                    {
                        PIPROP_IN_BUFF pPIB =
                             (PIPROP_IN_BUFF)AccAlloc(sizeof(IPROP_IN_BUFF));
                        if(pPIB == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            pPIB->pwszIProp = (LPWSTR)
                                    pCNode[i].pList[iIndex].lpInheritProperty;
                            dwErr = InheritPropsToMarshal.Insert((PVOID)pPIB);
                            if(dwErr != ERROR_SUCCESS)
                            {
                                AccFree(pPIB);
                            }
                            else
                            {
                                cSize +=
                                 SIZE_PWSTR(pCNode[i].pList[iIndex].
                                                           lpInheritProperty);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            cUsed++;
        }

        //
        // Also, add in the property size
        //
        cSize += SIZE_PWSTR(pCNode[i].pONode->pwszProperty);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        TrusteesToMarshal.Reset();
        PTRUSTEE    pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
        while(pTrustee != NULL)
        {
            if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
            {
                cSize += SIZE_PWSTR(pTrustee->ptstrName);
            }
            else
            {
                PTRUSTEE_NODE   pTN = NULL;
                dwErr = GetTrusteeNode(pTrustee,
                                       TRUSTEE_OPT_NOTHING,
                                       &pTN);
                cSize += SIZE_PWSTR(pTN->pwszTrusteeName);
            }

            if(pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
            {
                cSize += sizeof(TRUSTEE);
            }

            pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, all that we have is the size of the entries and the strings.
        // We now need to add the size of our structures...
        //
        cSize += sizeof(PACTRL_ACCESSW)                                  +
                 (cUsed * sizeof(ACTRL_PROPERTY_ENTRY)) +
                 (cUsed * sizeof(ACTRL_ACCESS_ENTRY))  +
                 sizeof(ACTRL_ACCESS_ENTRY_LIST);

        acDebugOut((DEB_TRACE_ACC, "Total size needed: %lu\n", cSize));

        //
        // Now, we'll allocate it, and start filling it in
        //
        *ppAList = (PACTRL_ACCESSW)AccAlloc(cSize);
        if(*ppAList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Now, we'll have to through first and add the property and
            // names to the end of the block.  We need to do this before
            // adding the individual entries, so that as we go through and
            // add each access entry, we can point the trustee to the
            // proper place
            //
            pbEndOBuff = (PBYTE)*ppAList + cSize;

            //
            // First, process all of the property names
            //
            for(i = 0; i < cItems; i++)
            {
                //
                // If we don't have a property name, set it to NULL
                //
                if(pCNode[i].pONode->pwszProperty == NULL)
                {
                    pCNode[i].pONode->pwszPropInBuff = NULL;
                }
                else
                {
                    ULONG cLen = SIZE_PWSTR(pCNode[i].pONode->pwszProperty);
                    pbEndOBuff -= cLen;

                    memcpy(pbEndOBuff,
                           pCNode[i].pONode->pwszProperty,
                           cLen);
                    pCNode[i].pONode->pwszPropInBuff = (PWSTR)pbEndOBuff;

                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                TrusteesToMarshal.Reset();
                PTRUSTEE    pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
                while(pTrustee != NULL)
                {
                    PTRUSTEE_NODE   pTN = NULL;
                    dwErr = GetTrusteeNode(pTrustee,
                                           TRUSTEE_OPT_NOTHING,
                                           &pTN);
                    ULONG cLen = SIZE_PWSTR(pTN->pwszTrusteeName);
                    pbEndOBuff -= cLen;

                    memcpy(pbEndOBuff,
                           pTN->pwszTrusteeName,
                           cLen);
                    pTN->pwszTrusteeInBuff = (PWSTR)pbEndOBuff;

                    pTrustee = (PTRUSTEE)TrusteesToMarshal.NextData();
                }
            }


            if(dwErr == ERROR_SUCCESS)
            {
                InheritPropsToMarshal.Reset();
                PIPROP_IN_BUFF pPIB =
                                (PIPROP_IN_BUFF)InheritPropsToMarshal.NextData();
                while(pPIB != NULL)
                {
                    ULONG cLen = SIZE_PWSTR(pPIB->pwszIProp);
                    pbEndOBuff -= cLen;

                    memcpy(pbEndOBuff,
                           pPIB->pwszIProp,
                           cLen);
                    pPIB->pwszIPropInBuff = (PWSTR)pbEndOBuff;

                    pPIB = (PIPROP_IN_BUFF)InheritPropsToMarshal.NextData();
                }
            }

            //
            // Ok, now we'll start processing everything else... This
            // begins by setting our count
            //

            (*ppAList)->cEntries = cUsed;

            PBYTE pCurrBuff = (PBYTE)*ppAList + sizeof(ACTRL_PROPERTY_ENTRY);;

            if((*ppAList)->cEntries != 0)
            {
                (*ppAList)->pPropertyAccessList =
                                              (PACTRL_PROPERTY_ENTRYW)pCurrBuff;

                pCurrBuff += (*ppAList)->cEntries * sizeof(ACTRL_PROPERTY_ENTRY);
            }
            else
            {
                (*ppAList)->pPropertyAccessList = NULL;
            }

            //
            // Go through and set our property entry list correctly
            //
            ULONG   iProp = 0;    // Property list index
            for(i = 0; i < cItems && cUsed != 0; i++)
            {
                BOOL    fNullAcl = FALSE;

                if(FLAG_ON(SeInfo,DACL_SECURITY_INFORMATION))
                {
                    if(FLAG_ON(pCNode[i].pONode->fState, ACCLIST_DACL_PROTECTED) ||
                       FLAG_ON(_fDAclFlags, ACCLIST_DACL_PROTECTED) )
                    {
                        (*ppAList)->pPropertyAccessList[iProp].fListFlags =
                                                                        ACTRL_ACCESS_PROTECTED;
                    }

                }

                if(FLAG_ON(SeInfo,SACL_SECURITY_INFORMATION))
                {
                    if(FLAG_ON(pCNode[i].pONode->fState, ACCLIST_SACL_PROTECTED) ||
                       FLAG_ON(_fSAclFlags, ACCLIST_SACL_PROTECTED) )
                    {
                        (*ppAList)->pPropertyAccessList[iProp].fListFlags =
                                                                        ACTRL_ACCESS_PROTECTED;
                    }

                }

                if(pCNode[i].pList == NULL)
                {
                    fNullAcl = TRUE;
                }

                //
                // Set our prop pointer
                //
                (*ppAList)->pPropertyAccessList[iProp].lpProperty =
                                                 pCNode[i].pONode->pwszPropInBuff;

                if(fNullAcl == TRUE)
                {
                    (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList = NULL;
                }
                else
                {
                    (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList =
                                             (PACTRL_ACCESS_ENTRY_LIST)pCurrBuff;

                    if(pCNode[i].pList != NULL)
                    {
                        pCurrBuff +=
                             (sizeof(ACTRL_ACCESS_ENTRY_LIST));
                    }
                }


                iProp++;
            }

            //
            // Ok, now we'll actually go through and build the individual
            // lists
            //
            iProp = 0;
            if((*ppAList)->pPropertyAccessList != NULL)
            {
                pCurrBuff =
                   (PBYTE)(*ppAList)->pPropertyAccessList[iProp].pAccessEntryList;
                pCurrBuff +=
                        (cUsed * sizeof(ACTRL_ACCESS_ENTRY_LIST));
            }
            for(i = 0; i < cItems && dwErr == ERROR_SUCCESS; i++)
            {
                //
                // Get the list we need
                //
                if(pCNode[i].pList != NULL &&
                   (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList != NULL)
                {
                    PACTRL_ACCESS_ENTRY_LIST pAEL =
                          (*ppAList)->pPropertyAccessList[iProp].pAccessEntryList;

                    pAEL->cEntries = pCNode[i].cExp + pCNode[i].cL1Inherit +
                                                             pCNode[i].cL2Inherit;

                    if( !pCNode[i].Empty )
                    {
                        pAEL->pAccessList = (PACTRL_ACCESS_ENTRY)pCurrBuff;
                        pCurrBuff += (sizeof(ACTRL_ACCESS_ENTRY) * pAEL->cEntries);

                    }
                    else
                    {
                        pAEL->pAccessList = NULL;
                        pAEL->cEntries = 0;
                    }

                    //
                    // Copy the node and adjust our trustee
                    //
                    for(ULONG iIndex = 0; iIndex < pAEL->cEntries && !pCNode[i].Empty; iIndex++)
                    {
                        //
                        // Make sure we strip any of our internal flags info
                        //

                        pAEL->pAccessList[iIndex].fAccessFlags       =
                                        pCNode[i].pList[iIndex].fAccessFlags &
                                                        ~ACCLIST_VALID_TYPE_FLAGS;
                        pAEL->pAccessList[iIndex].Access             =
                                        pCNode[i].pList[iIndex].Access;
                        pAEL->pAccessList[iIndex].ProvSpecificAccess =
                                        pCNode[i].pList[iIndex].ProvSpecificAccess;
                        pAEL->pAccessList[iIndex].Inheritance        =
                                        pCNode[i].pList[iIndex].Inheritance;
                        if(pCNode[i].pList[iIndex].lpInheritProperty != NULL)
                        {
                            PIPROP_IN_BUFF pPIB =
                                (PIPROP_IN_BUFF)InheritPropsToMarshal.Find(
                                    (PVOID)pCNode[i].pList[iIndex].
                                                                lpInheritProperty,
                                                                CompInheritProps);
                            ASSERT(pPIB != NULL);
                            pAEL->pAccessList[iIndex].lpInheritProperty =
                                                        pPIB->pwszIPropInBuff;
                        }

                        //
                        // Now, we only have to adjust our trustee
                        //
                        PTRUSTEE pTrustee = &(pCNode[i].pList[iIndex].Trustee);
                        PTRUSTEE_NODE   pTN = NULL;
                        dwErr = GetTrusteeNode(pTrustee,
                                               TRUSTEE_OPT_NOTHING,
                                               &pTN);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // We'll add the trustee now...
                            //
                            pAEL->pAccessList[iIndex].Trustee.pMultipleTrustee =
                                                        NULL;
                            pAEL->pAccessList[iIndex].Trustee.MultipleTrusteeOperation =
                                                        NO_MULTIPLE_TRUSTEE;
                            pAEL->pAccessList[iIndex].Trustee.TrusteeForm =
                                                        TRUSTEE_IS_NAME;
                            pAEL->pAccessList[iIndex].Trustee.TrusteeType =
                                                        pTN->Trustee.TrusteeType;
                            pAEL->pAccessList[iIndex].Trustee.ptstrName   =
                                                        pTN->pwszTrusteeInBuff;

                            if(pTN->pImpersonate != NULL)
                            {
                                //
                                // Ok, 2 things to do: adjust our current trustee
                                // state and add the new one
                                //
                                pAEL->pAccessList[iIndex].Trustee.
                                                    MultipleTrusteeOperation =
                                                           TRUSTEE_IS_IMPERSONATE;
                                pTrustee = pAEL->pAccessList[iIndex].Trustee.
                                                                 pMultipleTrustee;
                                pbEndOBuff -= sizeof(TRUSTEE);
                                pTrustee = (PTRUSTEE)pbEndOBuff;
                                pTrustee->MultipleTrusteeOperation =
                                                              NO_MULTIPLE_TRUSTEE;
                                pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
                                pTrustee->TrusteeType = TRUSTEE_IS_USER;
                                pTrustee->ptstrName =
                                             pTN->pImpersonate->pwszTrusteeInBuff;
                            }
                        }
                        else
                        {
                            break;
                        }
                    }

                    iProp++;

                }
            }

            //
            // Free our memory if something failed
            //
            if(dwErr != ERROR_SUCCESS)
            {
                AccFree(*ppAList);
                *ppAList = NULL;
            }
        }
    }

    FreeCompressedList(pCNode,
                       cItems);

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::MarshalAccessList: %lu\n", dwErr));
    return(dwErr);
}







//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::MarshalAccessLists, public
//
//  Synopsis:   Returns the requested lists in single buffer form.  Each
//              access or audit list is returned seperately.
//
//  Arguments:  [IN  SeInfo]            --      Type of info requested
//              [OUT ppAccess]          --      Where the ACCESS list is
//                                              returned if requested
//              [OUT ppAudit]           --      Where the AUDIT list is
//                                              returned if requested
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::MarshalAccessLists(IN  SECURITY_INFORMATION  SeInfo,
                                      OUT PACTRL_ACCESS        *ppAccess,
                                      OUT PACTRL_AUDIT         *ppAudit)
{
    acDebugOut((DEB_TRACE_ACC,"In CAccessList::MarshalAccessLists\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(FLAG_ON(SeInfo,DACL_SECURITY_INFORMATION))
    {
        dwErr = MarshalAccessList(DACL_SECURITY_INFORMATION,
                                  ppAccess);
    }

    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(SeInfo,SACL_SECURITY_INFORMATION))
    {
        dwErr = MarshalAccessList(SACL_SECURITY_INFORMATION,
                                  ppAudit);

        //
        // If it failed and we allocated our Access list, make sure to free it
        //
        if(dwErr != ERROR_SUCCESS &&
           FLAG_ON(SeInfo,DACL_SECURITY_INFORMATION))
        {
            AccFree(*ppAccess);
        }
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::MarshalAccessLists: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetTrusteeNode, private
//
//  Synopsis:   Returns a pointer to a TRUSTEE_NODE for the given
//              trustee.  The flags indicate what information about the
//              trustee needs to be present in the node.  If the trustee
//              does not already exist in the list, it will be added
//
//  Arguments:  [IN  pTrustee]      --      Trustee to find
//              [IN  fNodeOptions]  --      Information that needs to be
//                                          present in the node
//              [OUT ppTrusteeNode] --      Where the node pointer is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetTrusteeNode(IN  PTRUSTEE         pTrustee,
                                  IN  ULONG            fNodeOptions,
                                  OUT PTRUSTEE_NODE   *ppTrusteeNode)
{

    acDebugOut((DEB_TRACE_ACC,"In CAccessList::GetTrusteeNode\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // If we're doing an insert, we'll always want to create the name
    //
    if(FLAG_ON(fNodeOptions, TRUSTEE_OPT_INSERT_ONLY))
    {
        fNodeOptions |= TRUSTEE_OPT_NAME;
    }

    //
    // First, see if it exists in our list...
    //
    PTRUSTEE_NODE pTrusteeNode =
                    (PTRUSTEE_NODE)_TrusteeList.Find((PVOID)pTrustee,
                                                     CompTrusteeToTrusteeNode);
    if(pTrusteeNode == NULL)
    {
        //
        // Ok, we'll have to create one...
        //
        pTrusteeNode = (PTRUSTEE_NODE)AccAlloc(sizeof(TRUSTEE_NODE));
        if(pTrusteeNode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(&(pTrusteeNode->Trustee),
                   pTrustee,
                   sizeof(TRUSTEE));
            pTrusteeNode->SidType = SidTypeUnknown;


            //
            // Copy off whatever information we need
            //
            if(dwErr == ERROR_SUCCESS)
            {
                if(pTrustee->TrusteeForm == TRUSTEE_IS_SID)
                {
                    if(RtlValidSid((PSID)pTrustee->ptstrName))
                    {
                        DWORD cSidSize =
                                    RtlLengthSid((PSID)pTrustee->ptstrName);
                        pTrusteeNode->pSid = (PSID)AccAlloc(cSidSize);
                        if(pTrusteeNode->pSid == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            memcpy(pTrusteeNode->pSid,
                                  (PSID)pTrustee->ptstrName,
                                  cSidSize);
                            pTrusteeNode->Trustee.ptstrName =
                                                   (PWSTR)pTrusteeNode->pSid;
                            pTrusteeNode->fFlags |= TRUSTEE_DELETE_SID;
                        }
                    }
                    else
                    {
                        dwErr = ERROR_INVALID_SID;
                    }
                }
                else
                {
                    pTrusteeNode->pwszTrusteeName =
                            (PWSTR)AccAlloc(SIZE_PWSTR(pTrustee->ptstrName));
                    if(pTrusteeNode->pwszTrusteeName == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(pTrusteeNode->pwszTrusteeName,
                               pTrustee->ptstrName);
                        pTrusteeNode->Trustee.ptstrName =
                                                pTrusteeNode->pwszTrusteeName;
                        pTrusteeNode->fFlags |= TRUSTEE_DELETE_NAME;
                    }
                }
            }


            //
            // See if we need to insert an impersonate node as well
            //
            if(dwErr == ERROR_SUCCESS)
            {
                if(pTrustee->MultipleTrusteeOperation ==
                                                      TRUSTEE_IS_IMPERSONATE)
                {
                    if(pTrustee->pMultipleTrustee == NULL)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    else
                    {
                        PTRUSTEE_NODE pImpersonate;
                        dwErr = GetTrusteeNode(pTrustee->pMultipleTrustee,
                                               fNodeOptions,
                                               &pImpersonate);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            pTrusteeNode->pImpersonate = pImpersonate;
                        }
                    }
                }
            }

            //
            // Finally, insert it in the list
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = _TrusteeList.Insert((PVOID)pTrusteeNode);
            }

            //
            // If something went wrong, cleanup
            //
            if(dwErr != ERROR_SUCCESS)
            {
                DelTrusteeNode(pTrusteeNode);
            }
        }
    }

    //
    // Increment our use count if we were inserting
    //
    if(dwErr == ERROR_SUCCESS &&
       FLAG_ON(fNodeOptions, TRUSTEE_OPT_INSERT_ONLY))
    {
        pTrusteeNode->cUseCount++;
    }

    //
    // Now, if that worked, we'll need to make sure we have all the info
    // we need...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, if we don't have our sid type, we'll go ahead and determine it
        //
        if(pTrusteeNode->SidType == SidTypeUnknown)
        {
            //
            // We'll do this by turning on the appropriate flag
            //
            if(pTrusteeNode->Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                fNodeOptions |= TRUSTEE_OPT_NAME;
            }
            else
            {
                fNodeOptions |= TRUSTEE_OPT_SID;
            }
        }

        dwErr = LookupTrusteeNodeInformation(_pwszLookupServer,
                                             pTrusteeNode,
                                             fNodeOptions);

        //
        // Finally, if that worked, and we have a compound trustee, do the
        // child
        //
        if(dwErr == ERROR_SUCCESS && pTrusteeNode->pImpersonate != NULL)
        {
            dwErr = GetTrusteeNode(&(pTrusteeNode->pImpersonate->Trustee),
                                   fNodeOptions,
                                   &(pTrusteeNode->pImpersonate));
        }
    }

    //
    // If it all worked, return the new information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ASSERT(pTrusteeNode->Trustee.ptstrName == pTrusteeNode->pSid ||
               pTrusteeNode->Trustee.ptstrName == pTrusteeNode->pwszTrusteeName);

        if(ppTrusteeNode != NULL)
        {
            *ppTrusteeNode = pTrusteeNode;
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetTrusteeNode: %lu\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddAccessLists, private
//
//  Synopsis:
//
//  Arguments:  [IN  pTrustee]      --      Trustee to find
//              [IN  fNodeOptions]  --      Information that needs to be
//                                          present in the node
//              [OUT ppTrusteeNode] --      Where the node pointer is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddAccessLists(IN  SECURITY_INFORMATION  SeInfo,
                                  IN  PACTRL_ACCESSW        pAdd,
                                  IN  BOOL                  fMerge,
                                  IN  BOOL                  fOldStyleMerge)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,
                "In  CAccessList::AddAccessLists (%ws)\n",
                fMerge == TRUE ? L"Merge" : L"NoMerge"));

    //
    // If NULL parameters are given, just return success
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Handle the empty list case
    //
    ACTRL_ACCESSW   NullAccess;
    ACTRL_PROPERTY_ENTRY EmptyPropList;
    ACTRL_ACCESS_ENTRY_LIST EmptyAccessList;
    if(pAdd == NULL)
    {
        //
        // We don't allow NULL sacls, only empty ones
        //
        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
        {
            NullAccess.cEntries = 1;
            NullAccess.pPropertyAccessList = &EmptyPropList;
            memset(&EmptyPropList,0,sizeof(EmptyPropList));
            EmptyPropList.pAccessEntryList = &EmptyAccessList;
            memset(&EmptyAccessList,0,sizeof(EmptyAccessList));
        }
        else
        {
            NullAccess.cEntries = 0;
            NullAccess.pPropertyAccessList = NULL;
        }
        pAdd = &NullAccess;
    }


    if(pAdd->cEntries != 0 && pAdd->pPropertyAccessList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }
    else
    {
        _fSDValid = FALSE;
    }

    //
    // If we're doing an old style merge, make sure we remove all of the
    // existing entries for these trustees
    //
    if(fOldStyleMerge == TRUE)
    {
        dwErr = RevokeTrusteeAccess(SeInfo,
                                    pAdd,
                                    NULL);
    }

    //
    // If we're doing a set, we'll have to go through and remove any entries
    // that would be replaced before we go through and add the new entries
    // This is because our input list can have multiple lists that deal
    // with the same property, so a set applied then has disasterous results
    //
    ULONG iIndex = 0;
    while(fMerge == FALSE && iIndex < pAdd->cEntries)
    {
        PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)
                                 (pAdd->cEntries == 0 ?
                                                NULL   :
                                                pAdd->pPropertyAccessList
                                                         [iIndex].lpProperty),
                                 CompProps);
        if(pAccNode != NULL)
        {
            if(SeInfo == DACL_SECURITY_INFORMATION)
            {
                FreeAEList(pAccNode->pAccessList);
                pAccNode->pAccessList = NULL;
                pAccNode->fState &= ~ACCLIST_DACL_PROTECTED;

            }
            else
            {
                FreeAEList(pAccNode->pAuditList);
                pAccNode->fState &= ~ACCLIST_SACL_PROTECTED;
                pAccNode->pAuditList = NULL;
            }
        }
        iIndex++;
    }


    //
    // We have to do this in a while loop, so we handle the empty access list
    // properly without having to duplicate a bunch o' code
    //
    iIndex = 0;
    while(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, first, we need to find the matching property...
        //
        PACCLIST_NODE   pAccNode;
        dwErr = GetNodeForProperty(_AccList,
                                   (PWSTR)(pAdd->cEntries == 0 ?
                                                    NULL   :
                                                    pAdd->pPropertyAccessList
                                                         [iIndex].lpProperty),
                                   &pAccNode);
        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Otherwise, we'll figure out what we're doing...
        //
        PACTRL_ACCESS_ENTRY_LIST pList =
                                    SeInfo == DACL_SECURITY_INFORMATION ?
                                                   pAccNode->pAccessList  :
                                                   pAccNode->pAuditList;

        pAccNode->SeInfo |= SeInfo;

        if(pAdd->cEntries && FLAG_ON(pAdd->pPropertyAccessList[iIndex].fListFlags, ACTRL_ACCESS_PROTECTED))
        {
            SeInfo == DACL_SECURITY_INFORMATION ?
                    _fDAclFlags |= ACCLIST_DACL_PROTECTED :
                    _fSAclFlags |= ACCLIST_SACL_PROTECTED;
        }

        //
        // Ok, we can quit now if we have an empty list
        //
        if( pAdd->cEntries == 0 ||
            pAdd->pPropertyAccessList[iIndex].pAccessEntryList == NULL )
        {
            break;
        }

        //
        // Validate that the list is correct
        //
        if(pAdd->cEntries &&
           pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries != 0 &&
           pAdd->pPropertyAccessList[iIndex].pAccessEntryList->pAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Save our flags
        //
        SeInfo == DACL_SECURITY_INFORMATION ?
                _fDAclFlags |= pAdd->pPropertyAccessList[iIndex].fListFlags :
                _fSAclFlags |= pAdd->pPropertyAccessList[iIndex].fListFlags;

        //
        // Now, we'll have to generate a new list
        //
        ULONG cSize = 0;

        if(pAdd->pPropertyAccessList[iIndex].pAccessEntryList != NULL)
        {
            cSize += pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries;
        }

        if(pList != NULL)
        {
            cSize += pList->cEntries;
        }

        PACTRL_ACCESS_ENTRY_LIST pNew = (PACTRL_ACCESS_ENTRY_LIST)AccAlloc(
                                        sizeof(ACTRL_ACCESS_ENTRY_LIST) +
                                        (cSize * sizeof(ACTRL_ACCESS_ENTRY)));
        if(pNew == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Otherwise, we'll add all the new denieds, followed by the old
        // denieds, then the new accesses, followed by the old accesses
        //
        ULONG iNewIndex = 0;

        ULONG cNewCopy = 0;
        ULONG cOldCopy = 0;

        pNew->pAccessList = (PACTRL_ACCESS_ENTRY)((PBYTE)pNew +
                                             sizeof(ACTRL_ACCESS_ENTRY_LIST));

        if ( pAdd->pPropertyAccessList[iIndex].pAccessEntryList->pAccessList == NULL ) {

            pNew->cEntries = 0;
            pNew->pAccessList = NULL;
            SeInfo == DACL_SECURITY_INFORMATION ?
                                pAccNode->pAccessList = pNew :
                                pAccNode->pAuditList  = pNew;
            break;
        }
        //
        // Count the new denieds
        //
        for(ULONG iCnt = 0;
            pAdd->pPropertyAccessList[iIndex].pAccessEntryList != NULL &&
            iCnt < pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries;
            iCnt++)
        {
            if(FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                               pAccessList[iCnt].fAccessFlags,
                       ACTRL_ACCESS_DENIED))
            {
                cNewCopy++;
            }
            else
            {
                break;
            }
        }

        //
        // Now, the old denieds
        //
        if(pList != NULL)
        {
            for(iCnt = 0;
                iCnt < pList->cEntries;
                iCnt++)
            {
                if(FLAG_ON(pList->pAccessList[iCnt].fAccessFlags,
                           ACTRL_ACCESS_DENIED))
                {
                    cOldCopy++;
                }
                else
                {
                    break;
                }
            }
        }

        //
        // Excellent.. Now, a series of copies
        //
        if(cNewCopy != 0)
        {
            for(iCnt = 0; iCnt < cNewCopy && dwErr == ERROR_SUCCESS; iCnt++)
            {
                if(SeInfo == DACL_SECURITY_INFORMATION)
                {
                    if(!(FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                            pAccessList[iCnt].fAccessFlags,ACTRL_ACCESS_DENIED) ||
                         FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                            pAccessList[iCnt].fAccessFlags,ACTRL_ACCESS_ALLOWED)))
                    {
                        dwErr = ERROR_INVALID_ACL;
                        break;
                    }
                }
                else
                {
                    if(!(FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                            pAccessList[iCnt].fAccessFlags,ACTRL_AUDIT_SUCCESS) ||
                         FLAG_ON(pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                             pAccessList[iCnt].fAccessFlags,ACTRL_AUDIT_FAILURE)))
                    {
                        dwErr = ERROR_INVALID_ACL;
                        break;
                    }

                }
                dwErr = CopyAccessEntry(&(pNew->pAccessList[iNewIndex]),
                                        &(pAdd->pPropertyAccessList[iIndex].
                                         pAccessEntryList->pAccessList[iCnt]));
                iNewIndex++;
            }
            pNew->cEntries += cNewCopy;
        }

        if(cOldCopy != 0)
        {
            memcpy(&(pNew->pAccessList[iNewIndex]),
                   pList->pAccessList,
                   cOldCopy * sizeof(ACTRL_ACCESS_ENTRY));
            iNewIndex += cOldCopy;
            pNew->cEntries += cOldCopy;

        }

        //
        // Then, copy the alloweds...
        //
        for(iCnt = cNewCopy;
            dwErr == ERROR_SUCCESS &&
            pAdd->pPropertyAccessList[iIndex].pAccessEntryList != NULL &&
            iCnt < pAdd->pPropertyAccessList[iIndex].pAccessEntryList->cEntries;
            iCnt++)
        {
            ULONG fAccessFlag = pAdd->pPropertyAccessList[iIndex].pAccessEntryList->
                                               pAccessList[iCnt].fAccessFlags;

            if(fAccessFlag != ACTRL_ACCESS_ALLOWED &&
               fAccessFlag != ACTRL_ACCESS_DENIED  &&
               (fAccessFlag & ~(ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE)))
            {
                dwErr = ERROR_INVALID_FLAGS;
                break;
            }

            if(SeInfo == DACL_SECURITY_INFORMATION)
            {
                if(!(FLAG_ON(fAccessFlag,ACTRL_ACCESS_DENIED) ||
                     FLAG_ON(fAccessFlag,ACTRL_ACCESS_ALLOWED)))
                {
                    dwErr = ERROR_INVALID_ACL;
                    break;
                }
            }
            else
            {
                if(!(FLAG_ON(fAccessFlag,ACTRL_AUDIT_SUCCESS) ||
                     FLAG_ON(fAccessFlag,ACTRL_AUDIT_FAILURE)))
                {
                    dwErr = ERROR_INVALID_ACL;
                    break;
                }

            }

            if(fAccessFlag == ACTRL_ACCESS_DENIED)
            {
                dwErr = ERROR_INVALID_ACL;
                break;
            }

            dwErr = CopyAccessEntry(&(pNew->pAccessList[iNewIndex]),
                                    &(pAdd->pPropertyAccessList[iIndex].
                             pAccessEntryList->pAccessList[iCnt]));
            iNewIndex++;
            pNew->cEntries++;
        }


        if(dwErr == ERROR_SUCCESS &&
                             pList != NULL && pList->cEntries - cOldCopy > 0)
        {
            memcpy(&(pNew->pAccessList[iNewIndex]),
                   &pList->pAccessList[cOldCopy],
                   (pList->cEntries - cOldCopy) * sizeof(ACTRL_ACCESS_ENTRY));
            iNewIndex += cOldCopy;
            pNew->cEntries += (pList->cEntries - cOldCopy);

        }

        //
        // Now, if we got this far, we'll set it back in our list
        //
        if(dwErr == ERROR_SUCCESS)
        {
            SeInfo == DACL_SECURITY_INFORMATION ?
                                pAccNode->pAccessList = pNew :
                                pAccNode->pAuditList  = pNew;
            if(FLAG_ON(pAdd->pPropertyAccessList[iIndex].fListFlags, ACTRL_ACCESS_PROTECTED))
            {
                pAccNode->fState |= (SeInfo == DACL_SECURITY_INFORMATION ?
                                                        ACCLIST_DACL_PROTECTED :
                                                        ACCLIST_SACL_PROTECTED);
            }
        }
        else
        {
            AccFree(pNew);
        }

        iIndex++;

        if(iIndex >= pAdd->cEntries)
        {
            break;
        }
    }



    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::AddAccessLists: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetExplicitAccess, public
//
//  Synopsis:   Determines the explicit access for a given trustee.  This
//              includes group membership lookup
//
//  Arguments:  [IN  pTrustee]      --      Trustee to check the access for
//              [IN  pwszProperty]  --      Property to get access for
//              [OUT pDeniedMask]   --      Where the denied mask is returned
//              [OUT pAllowedMask]  --      Where the allowed mask is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetExplicitAccess(IN  PTRUSTEE   pTrustee,
                                     IN  PWSTR      pwszProperty,
                                     OUT PULONG     pDeniedMask,
                                     OUT PULONG     pAllowedMask)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetExplicitAccess\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL PropertiesMatch = FALSE;
    GUID Guid;
    PWSTR pwszNewPropertyName, pwszSourceName;

    //
    // Ok, first, get the specified access list for our property
    //
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszProperty,
                                                           CompProps);
    if(pAccNode == NULL)
    {
        //
        // If that failed, lets see if we can translate it from a guid to a string
        //

        //
        // See if we should convert one to/from a guid and then
        // compare it again
        //
        dwErr = UuidFromString(pwszProperty, &Guid);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccctrlLookupIdName(_pLDAP,
                                        _pwszDsPathReference,
                                        &Guid,
                                        FALSE,
                                        FALSE,
                                        &pwszNewPropertyName);

            if(dwErr == ERROR_SUCCESS)
            {
                pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszNewPropertyName,
                                                        CompProps);
            }

        }


        //
        // Whoops... No such property...
        //
        if(pAccNode == NULL)
        {
            dwErr = ERROR_UNKNOWN_PROPERTY;
        }
    }

    if(pAccNode != NULL)
    {
        PACTRL_ACCESS_ENTRY_LIST pList = pAccNode->pAccessList;

        if(pList == NULL)
        {
            *pDeniedMask = 0;
            *pAllowedMask = 0xFFFFFFFF;
        }
        else if(pList->cEntries == 0)
        {
            *pDeniedMask = 0xFFFFFFFF;
            *pAllowedMask = 0;
        }
        else
        {

            //
            // Now, we'll process each one of the entries, and build our masks
            //
            *pDeniedMask = 0;
            *pAllowedMask = 0;

            //
            // Add our trustee, so we get our information
            //
            PTRUSTEE_NODE   pTNode;
            dwErr = GetTrusteeNode(pTrustee,
                                   TRUSTEE_OPT_SID,
                                   &pTNode);

            if(dwErr == ERROR_SUCCESS)
            {
                CMemberCheck    MemberCheck(pTNode);
                dwErr = MemberCheck.Init();

                //
                // Now, we'll just go
                //
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    if(!(pList->pAccessList[iIndex].Inheritance & INHERIT_ONLY_ACE))
                    {
                        PTRUSTEE_NODE   pATNode;
                        dwErr = GetTrusteeNode(&(pList->pAccessList[iIndex].Trustee),
                                               TRUSTEE_OPT_SID,
                                               &pATNode);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            BOOL    fAddMask;
                            dwErr = MemberCheck.IsMemberOf(pATNode,
                                                           &fAddMask);
                            if(dwErr == ERROR_SUCCESS && fAddMask == TRUE)
                            {
                                //
                                // Great, then we'll simply or in the bits
                                //
                                if(pList->pAccessList[iIndex].fAccessFlags ==
                                                             ACTRL_ACCESS_ALLOWED)
                                {
                                    *pAllowedMask |= pList->pAccessList[iIndex].Access;
                                }
                                else
                                {
                                    *pDeniedMask |= pList->pAccessList[iIndex].Access;
                                }
                            }
                        }
                    }
                }
            }
        }
    }


    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::GetExplicitAccess: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetExplicitAudits, public
//
//  Synopsis:   Determines the explicit audits for a given trustee.  This
//              includes group membership lookup
//
//  Arguments:  [IN  pTrustee]      --      Trustee to check the access for
//              [IN  pwszProperty]  --      Property to get access for
//              [OUT pSuccessMask]  --      Where the successful audit mask
//                                          is returned
//              [OUT pFailureMask]  --      Where the failed audit mask is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetExplicitAudits(IN  PTRUSTEE   pTrustee,
                                     IN  PWSTR      pwszProperty,
                                     OUT PULONG     pSuccessMask,
                                     OUT PULONG     pFailureMask)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetExplicitAudits\n"));
    DWORD   dwErr = ERROR_SUCCESS;


    //
    // Ok, first, get the specified access list for our property
    //
    //
    // Ok, first, get the specified access list for our property
    //
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszProperty,
                                                           CompProps);
    if(pAccNode == NULL)
    {
        //
        // Whoops... No such property...
        //

        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LIST pList = pAccNode->pAuditList;

        if(pList == NULL)
        {
            *pSuccessMask = 0;
            *pFailureMask = 0;
        }
        else if(pList->cEntries == 0)
        {
            *pSuccessMask = 0;
            *pFailureMask = 0;
        }
        else
        {
            //
            // Now, we'll process each one of the entries, and build our masks
            //
            *pSuccessMask = 0;
            *pFailureMask = 0;

            //
            // Add our trustee, so we get our information
            //
            PTRUSTEE_NODE   pTNode;
            dwErr = GetTrusteeNode(pTrustee,
                                   TRUSTEE_OPT_SID,
                                   &pTNode);

            if(dwErr == ERROR_SUCCESS)
            {
                CMemberCheck    MemberCheck(pTNode);
                dwErr = MemberCheck.Init();

                //
                // Now, we'll just go
                //
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    PTRUSTEE_NODE   pATNode;
                    dwErr = GetTrusteeNode(&(pList->pAccessList[iIndex].Trustee),
                                           TRUSTEE_OPT_SID,
                                           &pATNode);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        BOOL    fAddMask;
                        dwErr = MemberCheck.IsMemberOf(pATNode,
                                                       &fAddMask);
                        if(dwErr == ERROR_SUCCESS && fAddMask == TRUE)
                        {
                            //
                            // Great, then we'll simply or in the bits
                            //
                            if(pList->pAccessList[iIndex].fAccessFlags ==
                                                          ACTRL_AUDIT_SUCCESS)
                            {
                                *pSuccessMask |= AccessMaskForAccessEntry(
                                                            &(pList->pAccessList[iIndex]),
                                                            _ObjType);
                            }

                            if(pList->pAccessList[iIndex].fAccessFlags ==
                                                          ACTRL_AUDIT_FAILURE)
                            {
                                *pFailureMask |= AccessMaskForAccessEntry(
                                                        &(pList->pAccessList[iIndex]),
                                                        _ObjType);
                            }
                        }
                    }
                }
            }
        }
    }


    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::GetExplicitAudits: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CopyAccessEntry, private
//
//  Synopsis:   Copies one access entry to another
//
//  Arguments:  [IN  pNewEntry]     --      Entry to be copied to
//              [IN  pOldEntry]     --      Entry to copy from
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:      pNewEntry must already exist
//
//----------------------------------------------------------------------------
DWORD CAccessList::CopyAccessEntry(IN PACTRL_ACCESS_ENTRY  pNewEntry,
                                   IN PACTRL_ACCESS_ENTRY  pOldEntry)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::CopyAccessEntry\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, copy the members
    //
    memcpy(pNewEntry,
           pOldEntry,
           sizeof(ACTRL_ACCESS_ENTRY));

    //
    // We'll have to NULL out the inherit property on the given entry,
    // since we only share it, and we don't want to prematurely delete it
    //
    pOldEntry->lpInheritProperty = NULL;

    //
    // Then, adjust the trustee
    //
    PTRUSTEE_NODE   pTNode;
    dwErr = GetTrusteeNode(&(pOldEntry->Trustee),
                           TRUSTEE_OPT_NOTHING,
                           &pTNode);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszNewTrustee;
        if(pOldEntry->Trustee.TrusteeForm == TRUSTEE_IS_SID)
        {
            acDebugOut((DEB_TRACE_ACC,
                       "Transfered %p\n",
                       pTNode->pSid));
            pwszNewTrustee = (PWSTR)pTNode->pSid;
        }
        else
        {
            pwszNewTrustee = pTNode->pwszTrusteeName;
            acDebugOut((DEB_TRACE_ACC,
                        "Transfered %ws\n",
                        pwszNewTrustee));
        }

        pNewEntry->Trustee.ptstrName = pwszNewTrustee;
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::CopyAccessEntry: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GrowInheritedAces, private
//
//  Synopsis:   Expands inherited aces of a DS Object.  This will actually
//              add the appropriate access entries
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_INVALID_DATA  --      The root access list was not
//                                          loaded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GrowInheritedAces()
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GrowInheritedAces\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(_ObjType != SE_DS_OBJECT && _ObjType != SE_DS_OBJECT_ALL)
    {
        acDebugOut((DEB_TRACE_ACC,
                    "Out CAccessList::GrowInheritedAces: %lu\n",
                    dwErr));
        return(dwErr);
    }

    //
    // Ok, find the node whose property is NULL
    //
    PACCLIST_NODE pNode = (PACCLIST_NODE)_AccList.Find(NULL,
                                                       CompProps);
    if(pNode == NULL)
    {
        //
        // If we haven't loaded the root, so we're screwed
        //

        dwErr = ERROR_INVALID_DATA;
    }


    if(dwErr == ERROR_SUCCESS && _AccList.QueryCount() > 1)
    {
        PACTRL_ACCESS_ENTRYW    *ppAccInherit = NULL;
        PACTRL_ACCESS_ENTRYW    *ppAudInherit = NULL;
        ULONG                   cAud = 0;
        ULONG                   cAcc = 0;

        PACTRL_ACCESS_ENTRY_LIST pILists[2];
        PACTRL_ACCESS_ENTRY    **ppInheritList[2];
        PULONG                   pulCounts[2];

        pILists[0]       = pNode->pAccessList;
        ppInheritList[0] = &ppAccInherit;
        pulCounts[0]     = &cAcc;

        pILists[1]       = pNode->pAuditList;
        ppInheritList[1] = &ppAudInherit;
        pulCounts[1]     = &cAud;

        //
        // Now, build the lists
        //
        for(ULONG iIndex = 0;
            iIndex < 2 && dwErr == ERROR_SUCCESS;
            iIndex++)
        {
            //
            // Skip empty lists
            //
            if(pILists[iIndex] == NULL)
            {
                continue;
            }

            for(ULONG iItems = 0; iItems < pILists[iIndex]->cEntries; iItems++)
            {
                if(FLAG_ON(pILists[iIndex]->pAccessList[iItems].Inheritance,
                           VALID_INHERIT_FLAGS))
                {
                    (*pulCounts[iIndex])++;
                }
            }

            //
            // Now, we'll do an allocation, and repeat the operation, doing
            // the assignment
            //
            *ppInheritList[iIndex] = (PACTRL_ACCESS_ENTRY *)
                AccAlloc(sizeof(PACTRL_ACCESS_ENTRY) * *pulCounts[iIndex]);

            if(*ppInheritList[iIndex] == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            ULONG iInherit = 0;
            for(iItems = 0; iItems < pILists[iIndex]->cEntries; iItems++)
            {
                if(FLAG_ON(pILists[iIndex]->pAccessList[iItems].Inheritance,
                           VALID_INHERIT_FLAGS))
                {
                    (*ppInheritList)[iIndex][iInherit] =
                                    &(pILists[iIndex]->pAccessList[iItems]);
                }
            }
        }

        _AccList.Reset();
        PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();

        //
        // We'll do this for both the access and audit lists
        //

        while(pAccNode != NULL && dwErr == ERROR_SUCCESS)
        {
            if(pAccNode->pwszProperty == NULL)
            {
                PACTRL_ACCESS_ENTRY_LIST *ppLists[2];

                ppLists[0] = &(pAccNode->pAccessList);
                ppLists[1] = &(pAccNode->pAuditList);

                for(ULONG iList = 0;
                    iList < 2 && dwErr == ERROR_SUCCESS;
                    iList++)
                {
                    //
                    // Skip empty lists
                    //
                    if(ppLists[iList] == NULL ||
                       (*ppInheritList)[iList] == NULL)
                    {
                        continue;
                    }

                    //
                    // We'll build an AList and then do a merge
                    //
                    ACTRL_ACCESS_ENTRY_LIST     AEL;
                    AEL.cEntries    = *pulCounts[iList];
                    AEL.pAccessList = **ppInheritList[iList];

                    ACTRL_PROPERTY_ENTRY        PEntry;
                    PEntry.lpProperty       = pAccNode->pwszProperty;
                    PEntry.pAccessEntryList = &AEL;

                    ACTRL_ACCESSW               AList;
                    AList.cEntries            = 1;
                    AList.pPropertyAccessList = &PEntry;

                    dwErr = AddAccessLists(iList == 0  ?
                                                  DACL_SECURITY_INFORMATION :
                                                  SACL_SECURITY_INFORMATION,
                                           &AList,
                                           TRUE);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        break;
                    }
                }
            }
            pAccNode = (PACCLIST_NODE)_AccList.NextData();
        }

        //
        // Finally, free our memory
        //
        for(iIndex = 0; iIndex < 2; iIndex++)
        {
            AccFree(*ppInheritList[iIndex]);;
        }

    }




    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GrowInheritedAces: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CollapseInheritedAces, private
//
//  Synopsis:   The inverse of the above function.  Goes through the lists
//              and collapses the inherited access entries for a DS object
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::CollapseInheritedAces()
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::CollapseInheritedAces\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(_ObjType != SE_DS_OBJECT && _ObjType != SE_DS_OBJECT_ALL)
    {
        acDebugOut((DEB_TRACE_ACC,
                    "Out CAccessList::CollapseInheritedAces: %lu\n",
                    dwErr));
        return(dwErr);
    }

    //
    // Now, we'll process all the items EXCEPT the root.  (We only collapse
    // on properties)
    //
    _AccList.Reset();
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();

    //
    // We'll do this for both the access and audit lists
    //

    while(pAccNode != NULL && dwErr == ERROR_SUCCESS)
    {
        if(pAccNode->pwszProperty == NULL)
        {
            PACTRL_ACCESS_ENTRY_LIST *ppLists[2];
            ULONG                    cLists = 0;

            if(pAccNode->pAccessList != NULL)
            {
                ppLists[cLists++] = &(pAccNode->pAccessList);
            }

            if(pAccNode->pAuditList != NULL)
            {
                ppLists[cLists++] = &(pAccNode->pAuditList);
            }

            for(ULONG iList = 0;
                iList < cLists && dwErr == ERROR_SUCCESS;
                iList++)
            {
                ULONG   cRemoved = 0;
                for(ULONG iIndex = 0;
                    iIndex < (*ppLists)[iList]->cEntries;
                    iIndex++)
                {
                    if(FLAG_ON((*ppLists)[iList]->pAccessList[iIndex].
                                                                  Inheritance,
                               INHERITED_ACE))
                    {
                        (*ppLists)[iList]->pAccessList[iIndex].Access =
                                                                  0xFFFFFFFF;
                        cRemoved++;
                    }
                }

                if(dwErr == ERROR_SUCCESS && cRemoved != 0)
                {
                    PACTRL_ACCESS_ENTRY_LIST pNew;
                    dwErr = ShrinkList((*ppLists)[iList],
                                       cRemoved,
                                       &pNew);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        AccFree((*ppLists)[iList]);
                        (*ppLists)[iList] = pNew;
                    }
                }
            }
        }
        pAccNode = (PACCLIST_NODE)_AccList.NextData();
    }


    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::CollapseInheritedAces: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::ShrinkList, private
//
//  Synopsis:   Shrinks the given list.  This goes through and removes any
//              nodes that have been marked as "deleted", as indicated by the
//              access mask.
//
//  Arguments:  [IN  pOldList]      --      List to shrink
//              [IN  cRemoved]      --      Number of items to be removed
//              [OUT ppNewList]     --      Where the "shrunk" list is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::ShrinkList(IN  PACTRL_ACCESS_ENTRY_LIST     pOldList,
                              IN  ULONG                        cRemoved,
                              IN  PACTRL_ACCESS_ENTRY_LIST    *ppNewList)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::ShrinkList\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, we'll process the list, and repackage it...
    //
    PACTRL_ACCESS_ENTRY_LIST pNew = (PACTRL_ACCESS_ENTRY_LIST)
                                    AccAlloc(sizeof(ACTRL_ACCESS_ENTRY_LIST) +
                                            ((pOldList->cEntries - cRemoved) *
                                                 sizeof(ACTRL_ACCESS_ENTRY)));
    if(pNew == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNew->pAccessList = (PACTRL_ACCESS_ENTRY)((PBYTE)pNew +
                                             sizeof(ACTRL_ACCESS_ENTRY_LIST));
        //
        // Now, copy the ones that we still want to keep over
        //
        ULONG iNew = 0;
        ULONG Removed = 0;
        for(ULONG iIndex = 0; iIndex < pOldList->cEntries; iIndex++)
        {
            if(pOldList->pAccessList[iIndex].Access != 0xFFFFFFFF)
            {
                memcpy(&(pNew->pAccessList[iNew]),
                       &(pOldList->pAccessList[iIndex]),
                       sizeof(ACTRL_ACCESS_ENTRY));
                iNew++;
            }
            else
            {
                //
                // Remove the trustee from the list
                //
                dwErr = RemoveTrustee(&(pOldList->pAccessList[iIndex].Trustee));

                Removed++;
            }
        }

        //
        // If we've removed all of the entries, remove the item as well...
        //
        if(iNew == 0 && Removed > 0 )
        {
            AccFree( pNew );
            *ppNewList = NULL;
        }
        else
        {
            pNew->cEntries = iNew;
            *ppNewList = pNew;
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::ShrinkList: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::BuildSDForAccessList, public
//
//  Synopsis:   Builds a security descriptor for the loaded access lists
//
//  Arguments:  [OUT  ppSD]         --      Where the built security
//                                          descriptor is returned
//              [OUT  pSeInfo]      --      Where the SeInfo corresponding
//                                          to the Security Descriptor is
//                                          returned
//              [IN   fFlags]       --      Flags that govern the lifetime
//                                          of the SD.  It controls whether
//                                          the class deletes the SD or  not
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::BuildSDForAccessList(OUT PSECURITY_DESCRIPTOR  *ppSD,
                                        OUT PSECURITY_INFORMATION  pSeInfo,
                                        IN  ULONG                  fFlags)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::BuildSDForAccessList\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // If our current SD is valid, simply return it...
    //
    if(_fSDValid == TRUE)
    {
        *ppSD = _pSD;
        *pSeInfo = _SeInfo;

        acDebugOut((DEB_TRACE_ACC,
                    "Out CAccessList::BuildSDForAccessList: 0\n"));
        return(dwErr);
    }
    else
    {
        AccFree(_pSD);
        _pSD = NULL;
        _fFreeSD = FALSE;
        _cSDSize = 0;
    }


    if(FLAG_ON(fFlags,ACCLIST_SD_NOFREE))
    {
        _fFreeSD = FALSE;
    }
    else
    {
        _fFreeSD = TRUE;
    }

    UCHAR    AclRevision = ACL_REVISION2;
    if(_ObjType == SE_DS_OBJECT || _ObjType == SE_DS_OBJECT_ALL)
    {
        AclRevision = ACL_REVISION_DS;
    }

    PACCLIST_CNODE  pCDAcl = NULL;
    PACCLIST_CNODE  pCSAcl = NULL;
    ULONG           cDAcls = 0;
    ULONG           cSAcls = 0;
    ULONG           cDAclSize = 0;
    ULONG           cSAclSize = 0;

    dwErr = CompressList(DACL_SECURITY_INFORMATION,
                         &pCDAcl,
                         &cDAcls);
    if(dwErr == ERROR_SUCCESS)
    {
        if(cDAcls != 0)
        {
            *pSeInfo = DACL_SECURITY_INFORMATION;
        }
        else
        {
            *pSeInfo = 0;
        }

        dwErr = CompressList(SACL_SECURITY_INFORMATION,
                             &pCSAcl,
                             &cSAcls);
        if(dwErr == ERROR_SUCCESS && cSAcls != 0)
        {
            *pSeInfo |= SACL_SECURITY_INFORMATION;
        }
    }

    //
    // Now, go through and size the DACL and SACL
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SizeCompressedListAsAcl(pCDAcl,
                                        cDAcls,
                                        &cDAclSize,
                                        FALSE);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SizeCompressedListAsAcl(pCSAcl,
                                            cSAcls,
                                            &cSAclSize,
                                            TRUE);
        }
    }

    //
    // If all that worked, add in our security descriptor size and owner/group
    //
    ULONG   cSize = 0;
    if(dwErr == ERROR_SUCCESS)
    {
        cSize = cDAclSize + cSAclSize;
        cSize += sizeof(SECURITY_DESCRIPTOR);

        //
        // Owner and group
        //
        if(_pOwner != NULL)
        {
            cSize += RtlLengthSid(_pOwner);
            *pSeInfo |= OWNER_SECURITY_INFORMATION;
        }

        if(_pGroup != NULL)
        {
            cSize += RtlLengthSid(_pGroup);
            *pSeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
        {
            cSize += sizeof(ULONG);
        }
    }

    //
    // If that worked, then we'll allocate for the security descriptor.
    // We allocate in a block, so we can free it in another routine later
    //
    BOOL                    fProtected=FALSE;
    PSECURITY_DESCRIPTOR    pSD;
    if(dwErr == ERROR_SUCCESS)
    {
        pSD = (PSECURITY_DESCRIPTOR)AccAlloc(cSize);
        if(pSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            PBYTE   pbEndOBuff = (PBYTE)pSD + cSize;

            if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
            {
                pSD = (PSECURITY_DESCRIPTOR)((PBYTE)pSD + sizeof(ULONG));
            }

            _cSDSize = cSize;

            //
            // First, build an absolute SD
            //
            if(InitializeSecurityDescriptor(pSD,
                                            SECURITY_DESCRIPTOR_REVISION) ==
                                                                        FALSE)
            {
                dwErr = GetLastError();
            }

            //
            // First, set the owner
            //
            if(dwErr == ERROR_SUCCESS && _pOwner != NULL)
            {
                PSID pOwner = (PSID)(pbEndOBuff - RtlLengthSid(_pOwner));
                RtlCopySid((ULONG)(pbEndOBuff - (PBYTE)pOwner),
                           pOwner,
                           _pOwner);
                pbEndOBuff = (PBYTE)pOwner;
                if(SetSecurityDescriptorOwner(pSD,
                                              pOwner,
                                              FALSE) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Next, try our hand with the group
            //
            if(dwErr == ERROR_SUCCESS && _pGroup != NULL)
            {
                PSID pGroup = (PSID)(pbEndOBuff - RtlLengthSid(_pGroup));
                RtlCopySid((ULONG)(pbEndOBuff - (PBYTE)pGroup),
                           pGroup,
                           _pGroup);
                pbEndOBuff = (PBYTE)pGroup;
                if(SetSecurityDescriptorGroup(pSD,
                                              pGroup,
                                              FALSE) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Ok, then the DACL
            //
            if(dwErr == ERROR_SUCCESS && cDAclSize != 0)
            {
                PACL pAcl = (PACL)(pbEndOBuff - cDAclSize);

                pAcl->AclRevision = AclRevision;
                pAcl->Sbz1        = (BYTE)_fDAclFlags;
                pAcl->AclSize     = (USHORT)cDAclSize;
                pAcl->AceCount    = 0;

                if(cDAclSize > sizeof(ACL))
                {
                    dwErr = BuildAcl(pCDAcl,
                                     cDAcls,
                                     pAcl,
                                     DACL_SECURITY_INFORMATION,
                                     &fProtected);

#if DBG
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DWORD cChk = 0;

                        PKNOWN_ACE pAce = (PKNOWN_ACE)FirstAce(pAcl);
                        for(ULONG z = 0; z < pAcl->AceCount; z++)
                        {
                            cChk += (DWORD)pAce->Header.AceSize;

                            pAce = (PKNOWN_ACE)NextAce(pAce);
                        }

                        cChk += sizeof(ACL);

                        ASSERT(cChk == cDAclSize);

                    }
#endif
                }
                else
                {
                    if( FLAG_ON(_fDAclFlags, ACCLIST_DACL_PROTECTED ))
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_DACL_PROTECTED;
                    }

                }

                pbEndOBuff = (PBYTE)pAcl;

                if(dwErr == ERROR_SUCCESS)
                {
                    if(SetSecurityDescriptorDacl(pSD,
                                                 TRUE,
                                                 pAcl,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                    if(dwErr == ERROR_SUCCESS && fProtected == TRUE)
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_DACL_PROTECTED;
                    }
                }

            }
            else
            {

                if( cDAclSize == 0 && FLAG_ON(_fDAclFlags,ACCLIST_DACL_PROTECTED ))
                {
                    ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_DACL_PROTECTED;
                }

                if ( FLAG_ON( *pSeInfo, DACL_SECURITY_INFORMATION ) )
                {
                    ((SECURITY_DESCRIPTOR *) pSD)->Dacl = NULL;
                    ((SECURITY_DESCRIPTOR *) pSD)->Control |= SE_DACL_PRESENT;
                }

            }

            //
            // Finally, the SACL
            //
            fProtected=FALSE;

            if(dwErr == ERROR_SUCCESS && cSAclSize != 0)
            {
                PACL pAcl = (PACL)(pbEndOBuff - cSAclSize);

                pAcl->AclRevision = AclRevision;
                pAcl->Sbz1        = (BYTE)_fSAclFlags;
                pAcl->AclSize     = (USHORT)cSAclSize;
                pAcl->AceCount    = 0;

                if(cSAclSize > sizeof(ACL))
                {
                    dwErr = BuildAcl(pCSAcl,
                                     cSAcls,
                                     pAcl,
                                     SACL_SECURITY_INFORMATION,
                                     &fProtected);
                }
                else
                {

                    if( FLAG_ON(_fSAclFlags,ACCLIST_SACL_PROTECTED ))
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_SACL_PROTECTED;
                    }

                }


                pbEndOBuff = (PBYTE)pAcl;


                if(dwErr == ERROR_SUCCESS)
                {
                    if(SetSecurityDescriptorSacl(pSD,
                                                 TRUE,
                                                 pAcl,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                    if(dwErr == ERROR_SUCCESS && fProtected == TRUE)
                    {
                        ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_SACL_PROTECTED;
                    }
                }

            }
            else
            {
                if( cSAclSize == 0 && FLAG_ON(_fSAclFlags, ACCLIST_SACL_PROTECTED ))
                {
                    ((SECURITY_DESCRIPTOR *)pSD)->Control |= SE_SACL_PROTECTED;
                }

                if ( FLAG_ON( *pSeInfo, SACL_SECURITY_INFORMATION ) )
                {
                    if(SetSecurityDescriptorSacl(pSD,
                                                 TRUE,
                                                 NULL,
                                                 FALSE) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }
            }


#if DBG
            if(dwErr == ERROR_SUCCESS)
            {
                ASSERT(pbEndOBuff == (PBYTE)pSD + sizeof(SECURITY_DESCRIPTOR));
                acDebugOut((DEB_TRACE_ACC,"pbEndOBuff: 0x%lx\n", pbEndOBuff));
                acDebugOut((DEB_TRACE_ACC,"pSD: 0x%lx\n",
                                       (PBYTE)pSD + sizeof(SECURITY_DESCRIPTOR)));
            }
#endif


            //
            // Great.. Now if all of that worked, we'll convert it to
            // an absolute format if necessary, or
            //
            if(dwErr == ERROR_SUCCESS)
            {
                if(FLAG_ON(fFlags,ACCLIST_SD_ABSOK))
                {
                    *ppSD = pSD;
                }
                else
                {
                    //
                    // We'll need to make this self relative
                    //
                    ULONG cNewSDSize = 0;
                    MakeSelfRelativeSD(pSD,
                                       NULL,
                                       &cNewSDSize);
                    ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

                    if(FLAG_ON(fFlags,ACCLIST_SD_DS_STYLE))
                    {
                        cNewSDSize += sizeof(ULONG);
                    }

                    *ppSD = (PSECURITY_DESCRIPTOR)AccAlloc(cNewSDSize);
                    if(*ppSD == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        if(FLAG_ON(fFlags,ACCLIST_SD_DS_STYLE))
                        {
                            *ppSD = (PSECURITY_DESCRIPTOR)
                                       ((PBYTE)*ppSD + sizeof(ULONG));
                        }
                        _cSDSize = cNewSDSize;
                        if(MakeSelfRelativeSD(pSD,
                                              *ppSD,
                                              &cNewSDSize) == FALSE)
                        {
                            dwErr = GetLastError();
                        }
                        else
                        {
                            if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
                            {
                                pSD = (PSECURITY_DESCRIPTOR)((PBYTE)pSD - sizeof(ULONG));
                            }
                            //
                            // It all worked, so free our initial sd
                            //
                            AccFree(pSD);
                        }
                    }
                }
            }



            if(dwErr != ERROR_SUCCESS)
            {
                if(FLAG_ON(fFlags, ACCLIST_SD_DS_STYLE))
                {
                    pSD = (PSECURITY_DESCRIPTOR)((PBYTE)pSD - sizeof(ULONG));
                }
                AccFree(pSD);
            }
        }
    }

    //
    // Save and return our security information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        _pSD     = *ppSD;
        _SeInfo  = *pSeInfo;
    }

    //
    // Set our flags properly
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(FLAG_ON(*pSeInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR)_pSD)->Control |=
                                                    SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(*pSeInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR)_pSD)->Control |=
                                                    SE_SACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(fFlags,ACCLIST_SD_DS_STYLE))
        {
            PULONG pSE = (PULONG)((PBYTE)*ppSD - sizeof(ULONG));
            *pSE = *pSeInfo;

            *ppSD = (PSECURITY_DESCRIPTOR)pSE;
        }
    }


    FreeCompressedList(pCDAcl, cDAcls);
    FreeCompressedList(pCSAcl, cSAcls);


    if(dwErr != ERROR_SUCCESS)
    {

        _fFreeSD = FALSE;

    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::BuildSDForAccessList: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddOwnerGroup, public
//
//  Synopsis:   Adds an owner and or group to the class
//
//  Arguments:  [IN  SeInfo]        --      Add owner or group?
//              [IN  pOwner]        --      Owner to add
//              [IN  pGroup]        --      Group to add
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddOwnerGroup(IN  SECURITY_INFORMATION      SeInfo,
                                 IN  PTRUSTEE                  pOwner,
                                 IN  PTRUSTEE                  pGroup)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::AddOwnerGroup\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    SID_NAME_USE    SidType;
    //
    // Basically, we'll simply add them in..
    //
    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
    {
        if(pOwner->TrusteeForm ==  TRUSTEE_IS_SID)
        {
            if(RtlValidSid((PSID)pOwner->ptstrName) == FALSE)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                ACC_ALLOC_AND_COPY_SID((PSID)pOwner->ptstrName,_pOwner, dwErr);
            }
        }
        else
        {
            dwErr = AccctrlLookupSid(_pwszLookupServer,
                                     pOwner->ptstrName,
                                     TRUE,
                                     &_pOwner,
                                     &SidType);
        }
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        if(pGroup->TrusteeForm ==  TRUSTEE_IS_SID)
        {
            if(RtlValidSid((PSID)pGroup->ptstrName) == FALSE)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }
            else
            {
                ACC_ALLOC_AND_COPY_SID((PSID)pGroup->ptstrName,_pGroup, dwErr);
            }
        }
        else
        {
            dwErr = AccctrlLookupSid(_pwszLookupServer,
                                     pGroup->ptstrName,
                                     TRUE,
                                     &_pGroup,
                                     &SidType);
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::AddOwnerGroup: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetSDSidAsTrustee, public
//
//  Synopsis:   Returns the specified owner/group as a trustee...
//
//  Arguments:  [IN  SeInfo]        --      Get owner or group?
//              [OUT ppTrustee]     --      Where the trustee is returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetSDSidAsTrustee(IN  SECURITY_INFORMATION      SeInfo,
                                     OUT PTRUSTEE                 *ppTrustee)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetSDSidAsTrustee\n"));
    DWORD   dwErr = ERROR_SUCCESS;


    PSID    pSid;
    if(FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        pSid = _pGroup;
    }
    else
    {
        pSid = _pOwner;
    }

    dwErr = AccLookupAccountTrustee(_pwszLookupServer,
                                    pSid,
                                    ppTrustee);

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetSDSidAsTrustee: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::GetExplicitEntries, public
//
//  Synopsis:   Returns a list of explicit entries for the given trustee.
//              This will lookup group membership
//
//  Arguments:  [IN  pTrustee]      --      Trustee to lookup
//              [IN  pwszProperty]  --      Property to worry about
//              [IN  SeInfo]        --      Look for access or audit list
//              [OUT pcEntries]     --      Where the count of items is
//                                          returned.
//              [OUT ppAEList]      --      Where the explicit entry list is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::GetExplicitEntries(IN  PTRUSTEE              pTrustee,
                                      IN  PWSTR                 pwszProperty,
                                      IN  SECURITY_INFORMATION  SeInfo,
                                      OUT PULONG                pcEntries,
                                      OUT PACTRL_ACCESS_ENTRYW *ppAEList)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::GetExplicitEntries\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, get the specified access list for our property
    //
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.Find((PVOID)pwszProperty,
                                                           CompProps);
    if(pAccNode == NULL)
    {
        //
        // Whoops... No such property...
        //

        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LIST pList = pAccNode->pAccessList;

        if(pList != NULL)
        {
            //
            // Now, we'll process each one of the entries, and build our masks
            //

            CSList  MemberList(NULL);

            //
            // Add our trustee, so we get our information
            //
            PTRUSTEE_NODE   pTNode;
            dwErr = GetTrusteeNode(pTrustee,
                                   TRUSTEE_OPT_SID,
                                   &pTNode);

            if(dwErr == ERROR_SUCCESS)
            {
                CMemberCheck    MemberCheck(pTNode);
                dwErr = MemberCheck.Init();

                //
                // Now, we'll just go
                //
                for(ULONG iIndex = 0;
                    iIndex < pList->cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    PTRUSTEE_NODE   pATNode;
                    dwErr = GetTrusteeNode(
                                       &(pList->pAccessList[iIndex].Trustee),
                                       TRUSTEE_OPT_SID,
                                       &pATNode);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        BOOL    fAddMask;
                        dwErr = MemberCheck.IsMemberOf(pATNode,
                                                       &fAddMask);
                        if(dwErr == ERROR_SUCCESS && fAddMask == TRUE)
                        {
                            dwErr = MemberList.Insert((PVOID)
                                                &pList->pAccessList[iIndex]);
                        }
                    }
                }
            }

            //
            // Ok, if we have everything, build our list
            //
            if(dwErr == ERROR_SUCCESS)
            {
                *pcEntries = 0;
                if(MemberList.QueryCount() == 0)
                {
                    *ppAEList = NULL;
                }
                else
                {
                    dwErr = GetTrusteeNode(pTrustee,
                                           TRUSTEE_OPT_NAME,
                                           &pTNode);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        ULONG cSize = SIZE_PWSTR(pTNode->pwszTrusteeName);

                        cSize += MemberList.QueryCount() *
                                                   sizeof(ACTRL_ACCESS_ENTRY);

                        *ppAEList = (PACTRL_ACCESS_ENTRY)AccAlloc(cSize);

                        if(*ppAEList == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            PWSTR pwszTrustee = (PWSTR)((PBYTE)(*ppAEList) +
                                                    (MemberList.QueryCount() *
                                                     sizeof(ACTRL_ACCESS_ENTRY)));
                            wcscpy(pwszTrustee,
                                   pTNode->pwszTrusteeName);

                            //
                            // Now, copy the rest of the information
                            //
                            MemberList.Reset();
                            PACTRL_ACCESS_ENTRY pCurrent =
                                   (PACTRL_ACCESS_ENTRY)MemberList.NextData();
                            while(pCurrent != NULL)
                            {
                                memcpy(&((*ppAEList)[*pcEntries]),
                                       pCurrent,
                                       sizeof(ACTRL_ACCESS_ENTRY));

                                //
                                // Then, adjust the trustee...
                                //
                                (*ppAEList)[*pcEntries].Trustee.TrusteeType =
                                                       pTrustee->TrusteeType;

                                (*ppAEList)[*pcEntries].Trustee.TrusteeForm =
                                                             TRUSTEE_IS_NAME;
                                (*ppAEList)[*pcEntries].Trustee.ptstrName =
                                                                 pwszTrustee;
                                pCurrent =
                                   (PACTRL_ACCESS_ENTRY)MemberList.NextData();
                                (*pcEntries)++;
                            }
                        }
                    }
                }
            }
        }
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetExplicitEntries: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::RevokeTrusteeAccess, public
//
//  Synopsis:   Removes any explicit entries that exist for the named
//              trustees
//
//  Arguments:  [IN  SeInfo]        --      Whether to process the access and
//                                          or audit list
//              [IN  pSrcList]      --      Trustee information list to
//                                          process
//              [IN  pwszProperty]  --      Optional property to do the revoke for
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::RevokeTrusteeAccess(IN  SECURITY_INFORMATION    SeInfo,
                                       IN  PACTRL_ACCESSW          pSrcList,
                                       IN  PWSTR                   pwszProperty OPTIONAL)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::RevokeTrusteeAccess\n"));

    CSList  TrusteeList(NULL);

    //
    // First, generate a list of all of the passed in trustees
    //
    for(ULONG iAcc = 0;
        iAcc < pSrcList->cEntries && dwErr == ERROR_SUCCESS;
        iAcc++)
    {
        PACTRL_ACCESS_ENTRY_LIST  pAEL =
                      pSrcList->pPropertyAccessList[iAcc].pAccessEntryList;

        //
        // Then the access entry strings
        //
        for(ULONG iEntry = 0;
            pAEL && iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS;
            iEntry++)
        {
            dwErr = TrusteeList.InsertIfUnique(
                              (PVOID)&(pAEL->pAccessList[iEntry].Trustee),
                              CompTrustees);
        }
    }

    //
    // Ok, now if that worked, we have a list of trustees... We'll simply
    // go through and revoke them all from our current list before
    // continuing
    //
    TrusteeList.Reset();
    PTRUSTEE    pTrustee = (PTRUSTEE)TrusteeList.NextData();
    while(pTrustee != NULL && dwErr == ERROR_SUCCESS)
    {
        TRUSTEE TempTrustee;
        TempTrustee.TrusteeForm = TRUSTEE_IS_SID;
        TempTrustee.ptstrName = NULL;

        //
        // If we have a domain relative name, we'll look the name as a sid
        //
        if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME && wcschr(pTrustee->ptstrName, L'\\') == NULL)
        {
            SID_NAME_USE    Type;
            dwErr = AccctrlLookupSid(_pwszLookupServer,
                                     pTrustee->ptstrName,
                                     TRUE,
                                     (PSID *)&(TempTrustee.ptstrName),
                                     &Type);

            if(dwErr == ERROR_SUCCESS)
            {
                pTrustee = &TempTrustee;
            }

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = RemoveTrusteeFromAccess(SeInfo,
                                            pTrustee,
                                            pwszProperty);
        }

        AccFree(TempTrustee.ptstrName);

        pTrustee = (PTRUSTEE)TrusteeList.NextData();
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::GetExplicitEntries: %lu\n",
                dwErr));
    return(dwErr);
}








//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CompressList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::CompressList(IN  SECURITY_INFORMATION   SeInfo,
                                OUT PACCLIST_CNODE        *ppList,
                                OUT PULONG                 pcItems)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::CompressList\n"));
    BOOL    fEmpty = FALSE;

    //
    // Ok, first, we'll have to go through and determine how many items there
    // are
    //
    *pcItems = 0;
    *ppList = 0;
    _AccList.Reset();
    PACCLIST_NODE pAccNode = (PACCLIST_NODE)_AccList.NextData();
    while(pAccNode != NULL)
    {
        if(FLAG_ON(pAccNode->SeInfo, SeInfo))
        {
            (*pcItems)++;
        }
        pAccNode = (PACCLIST_NODE)_AccList.NextData();
    }

    //
    // Now, do some allocations
    //
    if(*pcItems != 0)
    {
        *ppList = (PACCLIST_CNODE)AccAlloc(sizeof(ACCLIST_CNODE) * *pcItems);
        if(*ppList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            _AccList.Reset();
            ULONG i = 0;
            while(i < *pcItems )
            {
                pAccNode = (PACCLIST_NODE)_AccList.NextData();

                if(FLAG_ON(pAccNode->SeInfo, SeInfo))
                {
                    (*ppList)[i++].pONode = pAccNode;
                }
            }

            //
            // Now, sort the list based upon the property name
            //
            qsort(*ppList,
                  *pcItems,
                  sizeof(ACCLIST_CNODE),
                  CNodeCompare);
            //
            // Now, start processing them all...
            //
            for(i = 0; i < *pcItems; i++)
            {
                PACCLIST_CNODE pCN = &(*ppList)[i];
                PACTRL_ACCESS_ENTRY_LIST pList =
                        SeInfo == DACL_SECURITY_INFORMATION ?
                                                pCN->pONode->pAccessList :
                                                pCN->pONode->pAuditList;
                if(pList == NULL)
                {
                    continue;
                }

                if(pList->cEntries == 0)
                {

                    fEmpty = TRUE;
                    (*ppList)[i].Empty = TRUE;
                    pList->pAccessList = NULL;
                }
                else
                {
                    fEmpty = FALSE;
                }


                //
                // Go through and build some temprorary lists for each
                // type.
                //
                CSList  ExpList(NULL);
                CSList  L1List(NULL);
                CSList  L2List(NULL);

                //
                // We'll go through each entry and add it to our
                // proper list.  We'll also check for entries to
                // collapse here as well.  We'll do this by having our
                // node comparrison routine mark the new access entry with
                // a special bit if it finds a match
                //
                for(ULONG j = 0; j < pList->cEntries && !fEmpty; j++)
                {
                    //
                    // Mark our ordering information
                    //
                    pList->pAccessList[j].fAccessFlags |=
                            GetOrderTypeForAccessEntry(
                                            (*ppList)[i].pONode->pwszProperty,
                                            &pList->pAccessList[j],
                                            SeInfo);
                    if(FLAG_ON(pList->pAccessList[j].Inheritance,
                               INHERITED_GRANDPARENT))
                    {
                        dwErr = L2List.InsertIfUnique(
                                                &(pList->pAccessList[j]),
                                                CompAndMarkCompressNode);
                    }
                    else if(FLAG_ON(pList->pAccessList[j].Inheritance,
                                    INHERITED_PARENT) ||
                            FLAG_ON(pList->pAccessList[j].Inheritance,
                                    INHERITED_ACCESS_ENTRY))
                    {
                        dwErr = L1List.InsertIfUnique(
                                                &(pList->pAccessList[j]),
                                                CompAndMarkCompressNode);
                    }
                    else
                    {
                        dwErr = ExpList.InsertIfUnique(
                                                &(pList->pAccessList[j]),
                                                CompAndMarkCompressNode);
                    }

                    if(dwErr != ERROR_SUCCESS)
                    {
                        break;
                    }
                } // for(j = 0; j < pList->cEntries; j++)

                if ( fEmpty ) {

                     dwErr = ExpList.Insert( &(pList->pAccessList));

                }

                //
                // Ok, now we are read to actually build our new list
                //
                ULONG cUsed = ExpList.QueryCount() + L1List.QueryCount() +
                                                         L2List.QueryCount();
                ULONG cCompressed = pList->cEntries - cUsed;

                if(dwErr == ERROR_SUCCESS)
                {
                    pCN->pList = (PACTRL_ACCESS_ENTRY)AccAlloc(
                                    sizeof(ACTRL_ACCESS_ENTRY) * cUsed);
                    if(pCN->pList == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        //
                        // Start processing them all...
                        //
                        ULONG iIndex = 0;
                        ULONG cComp;
                        pCN->cExp = ExpList.QueryCount();
                        pCN->cL1Inherit = L1List.QueryCount();
                        pCN->cL2Inherit = L2List.QueryCount();

                        if(pCN->cExp != 0)
                        {
                            dwErr = AddSubList(pCN,
                                               ExpList,
                                               iIndex);
                        }

                        if(dwErr == ERROR_SUCCESS && pCN->cL1Inherit != 0)
                        {
                            iIndex += pCN->cExp;

                            dwErr = AddSubList(pCN,
                                               L1List,
                                               iIndex);
                        }

                        if(dwErr == ERROR_SUCCESS && pCN->cL2Inherit != 0)
                        {
                            iIndex += pCN->cL1Inherit;
                            dwErr = AddSubList(pCN,
                                               L2List,
                                               iIndex);
                        }


                        //
                        // If that worked, we'll see about compressing
                        //
                        if(dwErr == ERROR_SUCCESS && cCompressed > 0)
                        {
                            for(j = 0;
                                j < pList->cEntries && cCompressed > 0;
                                j++)
                            {
                                if(FLAG_ON(pList->pAccessList[j].fAccessFlags,
                                           ACCLIST_COMPRESS))
                                {
                                    for(ULONG k = 0; k < cUsed; k++)
                                    {
                                        if(CompAndMarkCompressNode(
                                                &(pList->pAccessList[j]),
                                                &(pCN->pList[k])) == TRUE)
                                        {
                                            pList->pAccessList[j].fAccessFlags &=
                                                ~ACCLIST_COMPRESS;
                                            pCN->pList[k].fAccessFlags |=
                                                pList->pAccessList[j].fAccessFlags;
                                            pCN->pList[k].Access |=
                                                pList->pAccessList[j].Access;
                                            pCN->pList[k].Inheritance |=
                                                pList->pAccessList[j].Inheritance;
                                            pCN->pList[k].ProvSpecificAccess |=
                                                pList->pAccessList[j].ProvSpecificAccess;
                                        }
                                    }
                                }
                            }

                        }
                    }
                }

                if(dwErr != ERROR_SUCCESS  && cCompressed > 0)
                {
                    //
                    // We'll have to go through and undo any compress
                    // bits we may have set
                    //
                    for(ULONG k = 0; k < j; k++)
                    {
                        pList->pAccessList[j].fAccessFlags &=
                                                    ~ACCLIST_COMPRESS;
                    }

                }


            }
        }

        if(dwErr != ERROR_SUCCESS)
        {
            FreeCompressedList(*ppList,
                               *pcItems);
            *ppList = 0;
        }
        //
        // Handle the special case of the non-zero, empty list
        //
        else if(fEmpty == TRUE)
        {
            (*ppList)[0].cExp = 1;
        }
    }


    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::CompressList: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CompressList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID CAccessList::FreeCompressedList(IN  PACCLIST_CNODE   pList,
                                     IN  ULONG            cItems)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::FreeCompressedList\n"));

    if(pList != NULL)
    {
        for(ULONG i = 0; i < cItems; i++)
        {
            if(pList[i].pList == NULL)
            {
                break;
            }
            else
            {
                AccFree(pList[i].pList);
            }
        }

        AccFree(pList);
    }

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::FreeCompressedList\n"));
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::AddSubList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::AddSubList(IN  PACCLIST_CNODE            pCList,
                              IN  CSList&                   TempList,
                              IN  ULONG                     iStart)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::AddSubList\n"));

    if ( pCList->Empty ) {

        return( dwErr );
    }
    //
    // First, we copy all of the list entries
    //
    TempList.Reset();
    PACTRL_ACCESS_ENTRY pAE = (PACTRL_ACCESS_ENTRY)TempList.NextData();
    ULONG i = iStart;
    while(pAE != NULL)
    {
        memcpy(&(pCList->pList[i]), pAE, sizeof(ACTRL_ACCESS_ENTRY));
        i++;
        pAE = (PACTRL_ACCESS_ENTRY)TempList.NextData();
    }

    //
    // Now, order them...
    //
    dwErr = OrderListBySid(pCList,
                           iStart,
                           TempList.QueryCount());


    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::AddSubList: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::CompressList, private
//
//  Synopsis:
//
//  Arguments:  []        --      Whether to process the access and
//                                          or audit list
//              []      --      Trustee information list to
//                                          process
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::SizeCompressedListAsAcl(IN  PACCLIST_CNODE  pList,
                                           IN  ULONG           cItems,
                                           OUT PULONG          pcSize,
                                           IN  BOOL            fForceNullToEmpty)
{
    DWORD   dwErr = ERROR_SUCCESS;
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::SizeCompressedListAsAcl\n"));
    ULONG   cTotalEnts = 0;
    BOOL    Empty = FALSE;

    *pcSize = 0;

    for(ULONG i = 0; i < cItems; i++)
    {
        ULONG cEnts = pList[i].cExp + pList[i].cL1Inherit + pList[i].cL2Inherit;
        cTotalEnts += cEnts;
        for(ULONG j = 0; j < cEnts; j++)
        {
            BOOL    fObjectAce = FALSE;
            if(pList[i].pONode->pwszProperty != NULL)
            {
                (*pcSize) += sizeof(GUID);
                fObjectAce = TRUE;
            }

            if(pList[i].pList == NULL || pList[i].Empty == TRUE)
            {
                continue;
            }

            if(pList[i].pList[j].lpInheritProperty != NULL)
            {
                (*pcSize) += sizeof(GUID);
                fObjectAce = TRUE;
            }

            //
            // Find the trustee for this node
            //
            PTRUSTEE_NODE   pTN = NULL;
            dwErr = GetTrusteeNode(&(pList[i].pList[j].Trustee),
                                   TRUSTEE_OPT_SID,
                                   &pTN);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Then, add in the SID
                //
                (*pcSize) += RtlLengthSid(pTN->pSid) - sizeof(ULONG);
                if(pTN->pImpersonate != NULL)
                {
                    (*pcSize) += RtlLengthSid(pTN->pSid);
                }
            }
            else
            {
                break;
            }

            //
            // Then, add the size of the ACE
            //
            if(pTN->pImpersonate != NULL)
            {
                if(fObjectAce == FALSE)
                {
                    (*pcSize) += sizeof(KNOWN_COMPOUND_ACE);
                }
                else
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                if(fObjectAce == TRUE)
                {
                    (*pcSize) += sizeof(KNOWN_OBJECT_ACE);
                }
                else
                {
                    (*pcSize) += sizeof(KNOWN_ACE);
                }
            }
        }

        if(cEnts == 0 && fForceNullToEmpty == TRUE)
        {
            Empty = TRUE;
        }
    }

    if(cTotalEnts != 0 || Empty == TRUE)
    {
        (*pcSize) += sizeof(ACL);
    }

    acDebugOut((DEB_TRACE_ACC,
                "Out CAccessList::SizeCompressedListAsAcl: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::BuildAcl, private
//
//  Synopsis:   The method will build an acl out of the individual access entries
//
//  Arguments:  [pList]         --      List of entries in compressed form
//              [cItems]        --      Number of items in the list
//              [pAcl]          --      Acl to fill in
//              [SeInfo]        --      Building DACL or SACL
//              [pfProtected]   --      If TRUE, the acl should be protected
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::BuildAcl(IN  PACCLIST_CNODE         pList,
                            IN  ULONG                  cItems,
                            IN  PACL                   pAcl,
                            IN  SECURITY_INFORMATION   SeInfo,
                            OUT BOOL                  *pfProtected)
{
    acDebugOut((DEB_TRACE_ACC,"In  CAccessList::BuildAcl\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fIsSacl = FALSE;


    PULONG  pIList = (PULONG)AccAlloc(cItems * sizeof(ULONG));
    if(pIList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    //
    // Ok, now we'll process this list several times, so we get entries
    // in the following order:
    //
    // ACCESS_DENIED_ACE on the object
    // ACCESS_DENIED_OBJECT_ACE
    // ACCESS_ALLOWED_ACE on the object
    // ACCESS_ALLOWED_OBJECT_ACE on an object
    // ACCESS_ALLOWED_OBJECT_ACE on a property set
    // ACCESS_ALLOWED_OBJECT_ACE on a property
    //

    //
    // List of entry attributes we're looking for
    //
    ULONG EntryAttribs[] = {ACCLIST_DENIED,
                            ACCLIST_OBJ_DENIED,
                            ACCLIST_ALLOWED,
                            ACCLIST_OBJ_ALLOWED,
                            ACCLIST_PSET_ALLOWED,
                            ACCLIST_PROP_ALLOWED,
                            0};         // Cover anything out of place...

    //
    // Process all of the items
    //

    *pfProtected = FALSE;
    //
    // We'll process the list of compressed entries each time, looking for
    // entries from a different level (base, then inherited, then grandparent
    // inherited
    //
    ULONG InheritAttribs[] = {0,
                              INHERITED_PARENT,
                              INHERITED_GRANDPARENT};

    for(ULONG iInherit = 0;
        iInherit < sizeof(InheritAttribs) / sizeof(ULONG) && dwErr == ERROR_SUCCESS;
        iInherit++)
    {
        for(ULONG iEntry = 0;
            iEntry < sizeof(EntryAttribs) / sizeof(ULONG) && dwErr == ERROR_SUCCESS;
            iEntry++)
        {
            for(ULONG i = 0; i < cItems && dwErr == ERROR_SUCCESS; i++)
            {
                LPGUID  pObjectId = NULL;
                if(pList[i].pONode->pwszProperty != NULL)
                {
                    dwErr = AccctrlLookupGuid(_pLDAP,
                                        _pwszDsPathReference,
                                        pList[i].pONode->pwszProperty,
                                        FALSE,
                                        &pObjectId);

                }

                //
                // Process the items in the lists that match our criteria...
                //
                for(ULONG j = pIList[i];
                    j < pList[i].cExp + pList[i].cL1Inherit +
                                                        pList[i].cL2Inherit &&
                    dwErr == ERROR_SUCCESS;
                    j++)
                {
                    if((FLAG_ON(pList[i].pList[j].Inheritance,
                                InheritAttribs[iInherit]) ||
                       InheritAttribs[iInherit] == 0 &&
                       !FLAG_ON(pList[i].pList[j].Inheritance,
                                INHERITED_PARENT | INHERITED_GRANDPARENT)) &&
                       (FLAG_ON(pList[i].pList[j].fAccessFlags,
                                EntryAttribs[iEntry]) ||
                        EntryAttribs[iEntry] == 0))
                    {
                        //
                        // Ok, we can add this in
                        //
                        dwErr = InsertEntryInAcl(&(pList[i].pList[j]),
                                                 pObjectId,
                                                 pAcl);

                    }
                    else
                    {
                        break;
                    }

                }

                pIList[i] = j;

                //
                // See if it's protected
                //
                if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                   FLAG_ON(pList[i].pONode->fState, ACCLIST_DACL_PROTECTED))
                {
                    *pfProtected = TRUE;
                }

                if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                   FLAG_ON(pList[i].pONode->fState, ACCLIST_SACL_PROTECTED))
                {
                    *pfProtected = TRUE;
                }
            }
        }
    }

    AccFree(pIList);

    acDebugOut((DEB_TRACE_ACC,"Out CAccessList::BuildAcl: %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CAccessList::InsertEntryInAcl, private
//
//  Synopsis:   Inserts an access entry into the acl
//
//  Arguments:  [pAE]           --      Access entry to insert
//              [pObject]       --      If present, this is an object type ace
//              [pAcl]          --      Acl to do the insertion for
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_INVALID_ACL       A compound ace type was specified
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CAccessList::InsertEntryInAcl(IN  PACTRL_ACCESS_ENTRY pAE,
                                    IN  GUID               *pObject,
                                    IN  PACL                pAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LPGUID  pInheritId = NULL;
    BOOL    fIsObjectAce = FALSE;
    BOOL    fIsSacl = FALSE;

    if(pAE->lpInheritProperty != NULL)
    {
        dwErr = AccctrlLookupGuid(_pLDAP,
                            _pwszDsPathReference,
                            pAE->lpInheritProperty,
                            FALSE,
                            &pInheritId);
        fIsObjectAce = TRUE;
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }
    }

    if(pObject != NULL)
    {
        fIsObjectAce = TRUE;
    }

    //
    // First, get the trustee
    //
    PTRUSTEE_NODE   pTN;
    dwErr = GetTrusteeNode(&(pAE->Trustee),
                           TRUSTEE_OPT_SID,
                           &pTN);
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // Add the ace
    //
    ACCESS_MASK AM = AccessMaskForAccessEntry(pAE, _ObjType);
    ACCESS_RIGHTS fAccess = pAE->fAccessFlags & ~ACCLIST_VALID_TYPE_FLAGS;
    INHERIT_FLAGS Inherit = pAE->Inheritance & ~ACCLIST_VALID_IN_LEVEL_FLAGS;


    if(dwErr == ERROR_SUCCESS)
    {
        if(pTN->pImpersonate == NULL)
        {
            if(fAccess == ACTRL_ACCESS_ALLOWED)
            {
                if(fIsObjectAce == TRUE)
                {
                    if(AddAccessAllowedObjectAce(
                                        pAcl,
                                        ACL_REVISION4,
                                        Inherit,
                                        AM,
                                        pObject,
                                        pInheritId,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                }
                else
                {
                    if(AddAccessAllowedAceEx(
                                        pAcl,
                                        ACL_REVISION2,
                                        Inherit,
                                        AM,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }
            }
            else if(fAccess == ACTRL_ACCESS_DENIED)
            {
                if(fIsObjectAce == TRUE)
                {
                    if(AddAccessDeniedObjectAce(
                                        pAcl,
                                        ACL_REVISION4,
                                        Inherit,
                                        AM,
                                        pObject,
                                        pInheritId,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                }
                else
                {
                    if(AddAccessDeniedAceEx(
                                        pAcl,
                                        ACL_REVISION2,
                                        Inherit,
                                        AM,
                                        pTN->pSid) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }
            }
            else if(FLAG_ON(fAccess,
                            (ACTRL_AUDIT_SUCCESS |
                                    ACTRL_AUDIT_FAILURE)))
            {
                fIsSacl = TRUE;
                if(fIsObjectAce == TRUE)
                {
                    if(AddAuditAccessObjectAce(
                                        pAcl,
                                        ACL_REVISION4,
                                        Inherit,
                                        AM,
                                        pObject,
                                        pInheritId,
                                        pTN->pSid,
                              FLAG_ON(fAccess,
                                      ACTRL_AUDIT_SUCCESS),
                              FLAG_ON(fAccess,
                                      ACTRL_AUDIT_FAILURE)) == FALSE)
                    {
                        dwErr = GetLastError();
                    }

                }
                else
                {
                    if(AddAuditAccessAceEx(
                          pAcl,
                          ACL_REVISION2,
                          Inherit,
                          AM,
                          pTN->pSid,
                          (BOOL)FLAG_ON(fAccess,
                                        ACTRL_AUDIT_SUCCESS),
                          (BOOL)FLAG_ON(fAccess,
                                        ACTRL_AUDIT_FAILURE)) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }


            }
            else
            {
                dwErr = ERROR_INVALID_ACL;
            }
        }
        else
        {
        #if 0
            if(pAE->fAccessFlags == ACTRL_ACCESS_ALLOWED)
            {
                NTSTATUS Status;
                if(pANList[j].pNode->pwszProperty != NULL)
                {
                    dwErr = ERROR_INVALID_ACL;
                }
                else
                {
                    Status = RtlAddCompoundAce(
                                pAcl,
                                ACL_REVISION3,
                                ACCESS_ALLOWED_COMPOUND_ACE_TYPE,
                                AM,
                                pTN->pSid,
                                pTN->pImpersonate->pSid);
                }
            }
            else
            {
                dwErr = ERROR_INVALID_ACL;
            }
            #endif
            //
            // Compound aces are disabled for the PDC
            //
            dwErr = ERROR_INVALID_ACL;
        }

    }

    //
    // Add in our protected flag...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ULONG fFlags = fIsSacl == FALSE  ?
                                    _fDAclFlags :
                                    _fSAclFlags;
        if(FLAG_ON(fFlags,ACTRL_ACCESS_PROTECTED))
        {
            pAcl->Sbz1 |= fIsSacl == FALSE  ?
                                    SE_DACL_PROTECTED :
                                    SE_SACL_PROTECTED;
        }
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\dsobject.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       DSOBJECT.CXX
//
//  Contents:   DSObject support functions
//
//  History:    01-Jul-96        MacM           Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#define NO_PROPAGATE

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"
#define ACTRL_EXT_RIGHTS_CONTAINER L"CN=Extended-Rights,"

#include <dsgetdc.h>
#include <lmapibuf.h>
#include <mapicode.h>
extern "C"
{
    #include <permit.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <ntdsguid.h>
    #include <ntldap.h>
}

#define PSD_FROM_DS_PSD(psd)  (PSECURITY_DESCRIPTOR)((PBYTE)psd + sizeof(ULONG))

#define BYTE_0_MASK 0xFF
#define BYTE_3(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_0(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

#define MartaPutUlong(Buffer, Value) {          \
    ((PBYTE)Buffer)[0] = BYTE_0(Value),         \
    ((PBYTE)Buffer)[1] = BYTE_1(Value),         \
    ((PBYTE)Buffer)[2] = BYTE_2(Value),         \
    ((PBYTE)Buffer)[3] = BYTE_3(Value);         \
}

DWORD
ConvertStringAToStringW (
    IN  PSTR            pszString,
    OUT PWSTR          *ppwszString
)
/*++

Routine Description:

    This routine will convert an ASCII string to a UNICODE string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pszString - The string to convert
    ppwszString - Where the converted string is returned

Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pszString == NULL)
    {
        *ppwszString = NULL;
    }
    else
    {
        ULONG cLen = strlen(pszString);
        *ppwszString = (PWSTR)AccAlloc(sizeof(WCHAR) *
                                                        (mbstowcs(NULL, pszString, cLen + 1) + 1));
        if(*ppwszString  != NULL)
        {
             mbstowcs(*ppwszString,
                      pszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




DWORD
ConvertStringWToStringA (
    IN  PWSTR           pwszString,
    OUT PSTR           *ppszString
)
/*++

Routine Description:

    This routine will convert a UNICODE string to an ANSI string.

    The returned string buffer must be freed via a call to LocalFree


Arguments:

    pwszString - The string to convert
    ppszString - Where the converted string is returned



Return Value:

    ERROR_SUCCESS - Success
    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{

    if(pwszString == NULL)
    {
        *ppszString = NULL;
    }
    else
    {
        ULONG cLen = wcslen(pwszString);
        *ppszString = (PSTR)AccAlloc(sizeof(CHAR) *
                                  (wcstombs(NULL, pwszString, cLen + 1) + 1));
        if(*ppszString  != NULL)
        {
             wcstombs(*ppszString,
                      pwszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   DspSplitPath
//
//  Synopsis:   This function splits a path into the server portion and the
//              path portion.  If the server portion doesn't exist, a NULL is
//              returned
//
//  Arguments:  [IN  pwszObjectPath]--  The name of the object to be split
//              [OUT ppwszAllocatedServer]  -- Where the server name is returned.
//                                      Must be freed via AccFree
//              [OUT ppwszReferencePath]    --  Ptr within the input path that
//                                      contains the path portion.
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD DspSplitPath(IN  PWSTR    pwszObjectPath,
                   OUT PWSTR   *ppwszAllocatedServer,
                   OUT PWSTR   *ppwszReferencePath)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR Temp = NULL;
    ULONG Len = 0;

    if(IS_UNC_PATH(pwszObjectPath, wcslen(pwszObjectPath)))
    {

        Temp = wcschr(pwszObjectPath + 2, L'\\');

        if (Temp == NULL) {

            Len = wcslen(pwszObjectPath);
        }
        else
        {
            Len = (ULONG)(Temp - pwszObjectPath);
        }

        *ppwszAllocatedServer = ( PWSTR )AccAlloc( ( Len + 1 ) * sizeof( WCHAR ) );

        if(*ppwszAllocatedServer == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        }
        else
        {
            wcsncpy( *ppwszAllocatedServer, pwszObjectPath, Len );
            *( *ppwszAllocatedServer + Len ) = UNICODE_NULL;
        }

        if(Temp != NULL)
        {
            *ppwszReferencePath = Temp + 1;
        }
        else
        {
            *ppwszReferencePath = NULL;
        }
    }
    else
    {
        *ppwszReferencePath = pwszObjectPath;
        *ppwszAllocatedServer = NULL;
    }

    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   PingDSObjByNameRes
//
//  Synopsis:   "Pings" the specified DS object, to determine if it is
//              reachable or not
//
// REMOVE POST BETA - 1.  Raid 107329
//
//  Arguments:  [IN  pObjectName]   --  The name of the object
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
PingDSObjByNameRes(IN PWSTR pwszDSObj,
                   IN PDS_NAME_RESULTW pNameRes)
{
    acDebugOut((DEB_TRACE, "in PingDSObjByNameRes\n"));
    DWORD dwErr;

    if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
    {
        dwErr = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        //
        // Now, we'll bind to the object, and then do the read
        //
        PLDAP   pLDAP;

        dwErr = BindToDSObject(NULL,
                               pNameRes->rItems[0].pDomain,
                               &pLDAP);

        if(dwErr == ERROR_SUCCESS)
        {
            PLDAPMessage    pMessage = NULL;
            PWSTR           rgAttribs[2];

            rgAttribs[0] = L"distinguishedName";
            rgAttribs[1] = NULL;


            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ldap_search_s(pLDAP,
                                      (PWSTR)pwszDSObj,
                                      LDAP_SCOPE_BASE,
                                      L"(objectClass=*)",
                                      rgAttribs,
                                      0,
                                      &pMessage);

                dwErr = LdapMapErrorToWin32( dwErr );
            }

            if(dwErr == ERROR_SUCCESS)
            {
                LDAPMessage *pEntry = NULL;
                pEntry = ldap_first_entry(pLDAP,
                                          pMessage);

                if(pEntry == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    //
                    // Now, we'll have to get the values
                    //
                    PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                         pEntry,
                                                         rgAttribs[0]);
                    if(ppwszValues == NULL)
                    {

                        if(pLDAP->ld_errno == LDAP_NO_SUCH_ATTRIBUTE )
                        {

                            dwErr =  ERROR_SUCCESS;
                        }
                        else
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                    }
                    else
                    {
                        ldap_value_free(ppwszValues);
                    }
                }

                ldap_msgfree(pMessage);
            }
            else
            {
                ldap_msgfree(pMessage);
            }
        }
    }

    acDebugOut((DEB_TRACE, "out PingDSObjByNameRes: %lu\n", dwErr));
    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   DspBindAndCrack
//
//  Synopsis:   Does a DsCrackName on the object
//
//  Arguments:  [IN  pwszServer]    --  Optional server name to bind to
//              [IN  pwszDSObj]     --  The DS object to bind to
//              [OUT pResults]      --  The returned cracked name
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD DspBindAndCrack( IN  PWSTR pwszServer, OPTIONAL
                       IN  PWSTR pwszDSObj,
                       IN  DWORD OptionalDsGetDcFlags,
                       OUT PDS_NAME_RESULTW *pResults )
{
    return DspBindAndCrackEx( pwszServer,
                              pwszDSObj,
                              OptionalDsGetDcFlags,
                              DS_FQDN_1779_NAME,
                              pResults );
}


//+---------------------------------------------------------------------------
//
//  Function:   DspBindAndCrackEx
//
//  Synopsis:   Does a DsCrackName on the object
//
//  Arguments:  [IN  pwszServer]    --  Optional server name to bind to
//              [IN  pwszDSObj]     --  The DS object to bind to
//              [IN  formatDesired] --  indicates the format of the returned name
//              [OUT pResults]      --  The returned cracked name
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD DspBindAndCrackEx( IN  PWSTR pwszServer,
                         IN  PWSTR pwszDSObj,
                         IN  DWORD OptionalDsGetDcFlags,
                         IN  DS_NAME_FORMAT formatDesired,
                         OUT PDS_NAME_RESULTW *pResults )
{
    DWORD dwErr = ERROR_SUCCESS;

    HANDLE  hDS = NULL;
    PDS_NAME_RESULTW   pNameRes;
    PDOMAIN_CONTROLLER_INFOW pDCI = NULL;
    BOOL NamedServer = FALSE;

    //
    // The path we are given could be of the form \\\\servername\\path.  If it is, it
    // is not necessary to do the DsGetDcName call.  We'll just use the server name
    // we are given
    //
    if(pwszServer != NULL)
    {
        NamedServer = TRUE;
    }
    else
    {
        dwErr = DsGetDcNameW(NULL,
                             NULL,
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED | OptionalDsGetDcFlags,  // DS_IP_REQUIRED
                             &pDCI);

        if(dwErr == ERROR_SUCCESS)
        {
            pwszServer = pDCI[0].DomainControllerName; // pDCI[0].DomainControllerAddress;
        }
    }


    //
    // Do the bind and crack
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = DsBindW(pwszServer,
                        NULL,
                        &hDS);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = DsCrackNamesW(hDS,
                                  DS_NAME_NO_FLAGS,
                                  DS_UNKNOWN_NAME,
                                  formatDesired,
                                  1,
                                  &pwszDSObj,
                                  &pNameRes);

            if (dwErr == ERROR_SUCCESS)
            {

                if(pNameRes->cItems != 0 &&
                   pNameRes->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY &&
                   NamedServer == FALSE )
                {
                    NetApiBufferFree(pDCI);
                    pDCI = NULL;
                    dwErr = DsGetDcNameW(NULL,
                                         pNameRes->rItems[0].pDomain,
                                         NULL,
                                         NULL,
                                         DS_DIRECTORY_SERVICE_REQUIRED | OptionalDsGetDcFlags, // DS_IP_REQUIRED |
                                         &pDCI);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DsUnBindW(&hDS);
                        hDS = NULL;

                        dwErr = DsBindW(pDCI[0].DomainControllerName, // DomainControllerAddress,
                                        NULL,
                                        &hDS);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = DsCrackNamesW(hDS,
                                                  DS_NAME_NO_FLAGS,
                                                  DS_UNKNOWN_NAME,
                                                  formatDesired,
                                                  1,
                                                  &pwszDSObj,
                                                  &pNameRes);
                        }

                    }

                }

                //
                // If this is a case where we don't have a named server, handle
                // the case where an object was created on one Dc, but we've just
                // bound to a second one
                //
                //
                if (dwErr == ERROR_SUCCESS && formatDesired == DS_FQDN_1779_NAME &&
                    NamedServer == FALSE )
                {
                    dwErr = PingDSObjByNameRes( pwszDSObj,pNameRes );

                    if(dwErr != ERROR_SUCCESS)
                    {
                        DsFreeNameResultW(pNameRes);
                    }

                    if(dwErr == ERROR_PATH_NOT_FOUND && OptionalDsGetDcFlags == 0)
                    {
                        dwErr = DspBindAndCrackEx( pDCI[0].DomainControllerName, //DomainControllerAddress,
                                                   pwszDSObj,
                                                   DS_WRITABLE_REQUIRED,
                                                   formatDesired,
                                                   &pNameRes );
                    }
                }

                *pResults = pNameRes;
            }


            if(hDS != NULL)
            {
                DsUnBindW(&hDS);
            }
        }
    }

    if(pDCI != NULL)
    {
        NetApiBufferFree(pDCI);
    }

    return( dwErr );
}


//+---------------------------------------------------------------------------
//
//  Function:   BindToDSObject
//
//  Synopsis:   Binds to a DS object
//
//  Arguments:  [IN  pwszServer]    --  OPTIONAL.  If specified, this is the name
//                                      of the server to bind to
//              [IN  pwszDSObj]     --  The DS object to bind to
//              [OUT ppLDAP]        --  The returned LDAP handle
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//
//  Notes:      The returned LDAP handle must be closed via UnbindFromDSObject
//
//----------------------------------------------------------------------------
DWORD   BindToDSObject(IN  PWSTR    pwszServer, OPTIONAL
                       IN  LPWSTR   pwszDSObj,
                       OUT PLDAP   *ppLDAP)
{
    acDebugOut((DEB_TRACE, "in BindToDSObject\n"));
    PDOMAIN_CONTROLLER_INFOW pDCI = NULL;
    DWORD dwErr = ERROR_SUCCESS;

    //
    // The path we are given could be of the form \\\\servername\\path.  If it is, it
    // is not necessary to do the DsGetDcName call.  We'll just use the server name
    // we are given
    //
    // Change: in order to use mutual authentication, A DNS format domain name must
    // be passed into ldap_open/ldap_init. So even a servername is passed in, it's
    // necessary to call DsGetDcNameW to get the DNS format domain name.
    // Since we asked for DIRECTORY_SERVICE_REQUIRED, this call won't talk to any
    // NT4 domain and the DNS name should always be returned. If it fails to get the
    // DNS name, we will fail this function - by design.
    //

    dwErr = DsGetDcNameW(pwszServer,
                         NULL,
                         NULL,
                         NULL,
                         DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                         &pDCI);


    if(dwErr == ERROR_SUCCESS)
    {
        *ppLDAP = ldap_open(pDCI->DomainName, LDAP_PORT);

        if(*ppLDAP == NULL)
        {
            dwErr = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            //
            // Do a bind...
            //
            dwErr = ldap_bind_s(*ppLDAP,
                                NULL,
                                NULL,
                                LDAP_AUTH_SSPI);

        }

    }

    if(pDCI != NULL)
    {
        NetApiBufferFree(pDCI);
    }

    acDebugOut((DEB_TRACE, "out BindToDSObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   UnBindFromDSObject
//
//  Synopsis:   Closes a binding to a DS object
//
//  Arguments:  [IN  ppLDAP]        --  The LDAP connection to close
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD   UnBindFromDSObject(OUT PLDAP               *ppLDAP)
{
    acDebugOut((DEB_TRACE, "in UnBindFromDSObject\n"));
    DWORD dwErr = ERROR_SUCCESS;

    if(*ppLDAP != NULL)
    {
        ldap_unbind(*ppLDAP);
        *ppLDAP = NULL;
    }

    acDebugOut((DEB_TRACE, "out UnBindFromDSObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadDSObjSecDesc
//
//  Synopsis:   Reads the security descriptor from the specied object via
//              the open ldap connection
//
//  Arguments:  [IN  pLDAP]         --  The open LDAP connection
//              [IN  SeInfo]        --  Parts of the security descriptor to
//                                      read.
//              [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [OUT ppSD]          --  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
ReadDSObjSecDesc(IN  PLDAP                  pLDAP,
                 IN  PWSTR                  pwszObject,
                 IN  SECURITY_INFORMATION   SeInfo,
                 OUT PSECURITY_DESCRIPTOR  *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PLDAPMessage    pMessage = NULL;
    PWSTR           rgAttribs[2];
    BYTE            berValue[8];

    //
    // JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;



    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ldap_search_ext_s(pLDAP,
                                  pwszObject,
                                  LDAP_SCOPE_BASE,
                                  L"(objectClass=*)",
                                  rgAttribs,
                                  0,
                                  (PLDAPControl *)&ServerControls,
                                  NULL,
                                  NULL,
                                  10000,
                                  &pMessage);

        dwErr = LdapMapErrorToWin32( dwErr );
    }

    if(dwErr == ERROR_SUCCESS)
    {
        LDAPMessage *pEntry = NULL;
        pEntry = ldap_first_entry(pLDAP,
                                  pMessage);

        if(pEntry == NULL)
        {
            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
        }
        else
        {
            //
            // Now, we'll have to get the values
            //
            PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                 pEntry,
                                                 rgAttribs[0]);
            if(ppwszValues == NULL)
            {
                if(pLDAP->ld_errno == LDAP_NO_SUCH_ATTRIBUTE)
                {
                    dwErr = ERROR_ACCESS_DENIED;
                }
                else
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }

            }
            else
            {
                PLDAP_BERVAL *pSize = ldap_get_values_len(pLDAP,
                                                          pMessage,
                                                          rgAttribs[0]);
                if(pSize == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)AccAlloc((*pSize)->bv_len);
                    if(*ppSD == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        memcpy(*ppSD,
                               (PBYTE)(*pSize)->bv_val,
                               (*pSize)->bv_len);
                    }
                    ldap_value_free_len(pSize);
                }

                ldap_value_free(ppwszValues);
            }
        }
    }

    ldap_msgfree(pMessage);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSDForDSObj
//
//  Synopsis:   Gets a security descriptor from a DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [OUT ppSD]          --  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER The object name that was given was in
//                                      a bad format (not \\x\y)
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
GetSDForDSObj(IN  LPWSTR                pwszDSObj,
              IN  SECURITY_INFORMATION  SeInfo,
              OUT PSECURITY_DESCRIPTOR *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetSDForDSObj\n"));
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR pwszServer = NULL, pwszPath = NULL;

    dwErr = DspSplitPath(pwszDSObj,
                         &pwszServer,
                         &pwszPath);

    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Convert the name into attributed format
        //
        PDS_NAME_RESULTW   pNameRes;

        dwErr = DspBindAndCrack( pwszServer, pwszPath, 0, &pNameRes );

        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                //
                // Now, we'll bind to the object, and then do the read
                //
                PLDAP   pLDAP;

                dwErr = BindToDSObject(pwszServer,
                                       pNameRes->rItems[0].pDomain,
                                       &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Now, we'll do the read...
                    //
                    dwErr = ReadDSObjSecDesc(pLDAP,
                                             pNameRes->rItems[0].pName,
                                             SeInfo,
                                             ppSD);
                    UnBindFromDSObject(&pLDAP);
                }
            }
            DsFreeNameResultW(pNameRes);
        }

        AccFree(pwszServer);
    }

    acDebugOut((DEB_TRACE, "Out GetSDForDSObj: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadDSObjPropertyRights
//
//  Synopsis:   Reads the specified property rights from the named DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [IN  pRightsList]   --  The rights information to get
//              [IN  cRights]       --  Number of items in the rights list
//              [IN  AccessList]    --  The access list to initialize
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_INVALID_PARAMETER A NULL parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadDSObjPropertyRights(IN  LPWSTR               pwszDSObj,
                        IN  PACTRL_RIGHTS_INFO   pRightsList,
                        IN  ULONG                cRights,
                        IN  CAccessList&         AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadDSObjPropertyRights\n"));
    DWORD dwErr = ERROR_SUCCESS;

    if(pwszDSObj == NULL || pRightsList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Build the security info structure we will need
        //
        SECURITY_INFORMATION SeInfo = 0;

        for(ULONG i = 0; i < cRights; i++)
        {
            SeInfo |= pRightsList[i].SeInfo;
        }

        PSECURITY_DESCRIPTOR    pSD;
        dwErr = GetSDForDSObj(pwszDSObj,
                              SeInfo,
                              &pSD);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, we'll simply add the appropriate property based entries
            // to our access list.
            //
            for(ULONG iIndex = 0;
                iIndex < cRights && dwErr == ERROR_SUCCESS;
                iIndex++)
            {
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList[iIndex].SeInfo,
                                         pRightsList[iIndex].pwszProperty,
                                         FALSE);

            }
            AccFree(pSD);
        }

    }

    acDebugOut((DEB_TRACE, "out ReadDSObjPropertyRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadAllDSObjPropertyRights
//
//  Synopsis:   Reads the all the property rights from the named DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [IN  pRightsList]   --  The rights information to get
//              [IN  cRights]       --  Number of items in the rights list
//              [IN  AccessList]    --  The access list to initialize
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_INVALID_PARAMETER A NULL parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadAllDSObjPropertyRights(IN  LPWSTR               pwszDSObj,
                           IN  PACTRL_RIGHTS_INFO   pRightsList,
                           IN  ULONG                cRights,
                           IN  CAccessList&         AccessList)
{
    DWORD dwErr = ERROR_SUCCESS;

    if(pwszDSObj == NULL || pRightsList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // Build the security info structure we will need
        //
        SECURITY_INFORMATION SeInfo = 0;

        for(ULONG i = 0; i < cRights; i++)
        {
            SeInfo |= pRightsList[i].SeInfo;
        }

        PSECURITY_DESCRIPTOR    pSD;
        dwErr = GetSDForDSObj(pwszDSObj,
                              SeInfo,
                              &pSD);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, we'll simply add it to our access list.  We'll ignore
            // any rights info after the first one.
            //
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[0].SeInfo,
                                     NULL,
                                     TRUE);
            AccFree(pSD);
        }

    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDSObjSecurityInfo
//
//  Synopsis:   Sets the security descriptor on the DS object
//
//  Arguments:  [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [IN  SeInfo]        --  Security Infofor the security
//                                      descriptor
//              [IN  pwszProperty]  --  Object property to set the access on
//              [IN  pSD]           --  Security descriptor to set
//              [IN  cSDSize]       --  Size of the security descriptor
//              [IN  pfStopFlag]    --  The stop flag to monitor
//              [IN  pcProcessed]   --  Where to increment the count of
//                                      processsed items
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_INVALID_PARAMETER A NULL parameter was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SetDSObjSecurityInfo(IN  LPWSTR                  pwszDSObj,
                     IN  SECURITY_INFORMATION    SeInfo,
                     IN  PWSTR                   pwszProperty,
                     IN  PSECURITY_DESCRIPTOR    pSD,
                     IN  ULONG                   cSDSize,
                     IN  PULONG                  pfStopFlag,
                     IN  PULONG                  pcProcessed)
{
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR pwszServer = NULL, pwszPath = NULL;

    dwErr = DspSplitPath(pwszDSObj,
                         &pwszServer,
                         &pwszPath);

    if(dwErr == ERROR_SUCCESS)
    {


        //
        // Convert the name into attributed format
        //
        PDS_NAME_RESULTW pNameRes;

        dwErr = DspBindAndCrack( pwszServer, pwszPath, 0, &pNameRes );

        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                //
                // Convert our name to ascii
                //
                PLDAP   pLDAP;

                dwErr = BindToDSObject(pwszServer,
                                       pNameRes->rItems[0].pDomain,
                                       &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
#ifdef NO_PROPAGATE
                    dwErr = StampSD(pNameRes->rItems[0].pName,
                                    cSDSize,
                                    SeInfo,
                                    pSD,
                                    pLDAP);
#else
                    dwErr = PropagateDSRightsDeep(NULL,
                                                  pSD,
                                                  SeInfo,
                                                  pNameRes->rItems[0].pName,
                                                  pLDAP,
                                                  pcProcessed,
                                                  pfStopFlag);
#endif
                    UnBindFromDSObject(&pLDAP);
                }

            }

            DsFreeNameResultW(pNameRes);
        }

        AccFree(pwszServer);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   PingDSObj
//
//  Synopsis:   "Pings" the specified DS object, to determine if it is
//              reachable or not
//
//  Arguments:  [IN  pObjectName]   --  The name of the object
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_PATH_NOT_FOUND--  The object was not reachable
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
PingDSObj(IN LPCWSTR  pwszDSObj)
{
    acDebugOut((DEB_TRACE, "in PingDSObj\n"));
    DWORD dwErr;

    PWSTR pwszServer = NULL, pwszPath = NULL;

    dwErr = DspSplitPath((PWSTR)pwszDSObj,
                         &pwszServer,
                         &pwszPath);

    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Convert the name into attributed format
        //
        PDS_NAME_RESULTW   pNameRes;
        dwErr = DspBindAndCrack(pwszServer, pwszPath, 0, &pNameRes);
        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                //
                // Now, we'll bind to the object, and then do the read
                //
                PLDAP   pLDAP;

                dwErr = BindToDSObject(pwszServer,
                                       pNameRes->rItems[0].pDomain,
                                       &pLDAP);

                if(dwErr == ERROR_SUCCESS)
                {
                    PLDAPMessage    pMessage = NULL;
                    PWSTR           rgAttribs[2];

                    rgAttribs[0] = L"distinguishedName";
                    rgAttribs[1] = NULL;


                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = ldap_search_s(pLDAP,
                                              pwszPath,
                                              LDAP_SCOPE_BASE,
                                              L"(objectClass=*)",
                                              rgAttribs,
                                              0,
                                              &pMessage);

                        dwErr = LdapMapErrorToWin32( dwErr );
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        LDAPMessage *pEntry = NULL;
                        pEntry = ldap_first_entry(pLDAP,
                                                  pMessage);

                        if(pEntry == NULL)
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                        else
                        {
                            //
                            // Now, we'll have to get the values
                            //
                            PWSTR *ppwszValues = ldap_get_values(pLDAP,
                                                                 pEntry,
                                                                 rgAttribs[0]);
                            if(ppwszValues == NULL)
                            {

                                if(pLDAP->ld_errno == LDAP_NO_SUCH_ATTRIBUTE )
                                {

                                    dwErr =  ERROR_SUCCESS;
                                }
                                else
                                {
                                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                                }
                            }
                            else
                            {
                                ldap_value_free(ppwszValues);
                            }
                        }
                    }

                    ldap_msgfree(pMessage);
                }
            }
            DsFreeNameResultW(pNameRes);
        }

        AccFree(pwszServer);
    }
    acDebugOut((DEB_TRACE, "out PingDSObj: %lu\n", dwErr));
    return(dwErr);
}




DWORD
Nt4NameToNt5Name(IN  PWSTR      pwszName,
                 IN  PWSTR      pwszDomain,
                 OUT PWSTR     *ppwszNt5Name)
{
    DWORD   dwErr = ERROR_SUCCESS;

    WCHAR   wszFullName[MAX_PATH + 1];
    LPWSTR  pwszFullName;

    ULONG   cLen = wcslen(pwszName) + 1;

    if(pwszDomain != NULL)
    {
        cLen += wcslen(pwszDomain) + 1;
    }

    if(cLen < MAX_PATH + 1)
    {
        pwszFullName = wszFullName;
    }
    else
    {
        pwszFullName = (PWSTR)AccAlloc(cLen * sizeof(WCHAR));
        if(pwszFullName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        if(pwszDomain != NULL)
        {
            wcscpy(pwszFullName, pwszDomain);
            wcscat(pwszFullName, L"\\");
        }
        else
        {
            *pwszFullName = L'\0';
        }
        wcscat(pwszFullName, pwszName);

    }

    //
    // Now, for the crack name...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PDS_NAME_RESULTW   pNameRes;

        dwErr = DspBindAndCrack(NULL, wszFullName, 0, &pNameRes );
        if(dwErr == ERROR_SUCCESS)
        {
            if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
            else
            {
                ACC_ALLOC_AND_COPY_STRINGW(pNameRes->rItems[0].pName,
                                           *ppwszNt5Name,
                                           dwErr);
            }
        }
        else
        {
            if(dwErr == MAPI_E_LOGON_FAILED)
            {
                dwErr = ERROR_LOGON_FAILURE;
            }

        }

        DsFreeNameResultW(pNameRes);
    }


    //
    // See if we need to free our buffer
    //
    if(pwszFullName != wszFullName)
    {
        AccFree(pwszFullName);
    }

    return(dwErr);
}




#define CLEANUP_ON_INTERRUPT(pstopflag)                                     \
if(*pstopflag != 0)                                                         \
{                                                                           \
    goto DSCleanup;                                                         \
}
//+---------------------------------------------------------------------------
//
//  Function:   PropagateDSRightsDeep, recursive
//
//  Synopsis:   Does a deep propagation of the access.
//
//  Arguments:  [IN  pParentSD]         --      The current parent sd
//              [IN  SeInfo]            --      What is being written
//              [IN  pwszFile]          --      Parent file path
//              [IN  pcProcessed]       --      Where the number processed is
//                                              returned.
//              [IN  pfStopFlag]        --      Stop flag to monitor
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
PropagateDSRightsDeep(IN  PSECURITY_DESCRIPTOR    pParentSD,
                      IN  PSECURITY_DESCRIPTOR    pChildSD,
                      IN  SECURITY_INFORMATION    SeInfo,
                      IN  PWSTR                   pwszDSObject,
                      IN  PLDAP                   pLDAP,
                      IN  PULONG                  pcProcessed,
                      IN  PULONG                  pfStopFlag)
{
    acDebugOut((DEB_TRACE, "in PropagateDSRightsDeep\n"));
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fFreeChildSD = FALSE;


    acDebugOut((DEB_TRACE_PROP, "Processing %ws\n", pwszDSObject));

    //
    // If our security descriptor is already in DS form, then we'll have
    // to adjust for that
    //
    if(pChildSD != NULL)
    {
        PULONG pSE = (PULONG)(pChildSD);
        if(*pSE == SeInfo)
        {
            pChildSD = (PSECURITY_DESCRIPTOR)((PBYTE)pChildSD + sizeof(ULONG));
        }
    }
    else
    {
        dwErr = ReadDSObjSecDesc(pLDAP,
                                 pwszDSObject,
                                 SeInfo,
                                 &pChildSD);
        if(dwErr == ERROR_SUCCESS)
        {
            fFreeChildSD = TRUE;
        }
        else
        {
            return(dwErr);
        }
    }

    //
    // Ok, we'll convert our path to a narrow string, and then we'll enumerate
    // all of the children
    //
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    PLDAPMessage            pMessage = NULL;

    //
    // First, we'll create the new SD...
    //
    HANDLE                  hProcessToken = NULL;
    GENERIC_MAPPING GenMap;
    GenMap.GenericRead    = GENERIC_READ_MAPPING;
    GenMap.GenericWrite   = GENERIC_WRITE_MAPPING;
    GenMap.GenericExecute = GENERIC_EXECUTE_MAPPING;
    GenMap.GenericAll     = GENERIC_ALL_MAPPING;

    dwErr = GetCurrentToken( &hProcessToken );
    if(dwErr == ERROR_SUCCESS)
    {
#ifdef DBG
        DebugDumpSD("CPOSE ParentSD", pParentSD);
        DebugDumpSD("CPOSE ChildSD",  pChildSD);
#endif
        if(CreatePrivateObjectSecurityEx(pParentSD,
                                         pChildSD,
                                         &pNewSD,
                                         NULL,
                                         TRUE,
                                         SEF_DACL_AUTO_INHERIT |
                                            SEF_SACL_AUTO_INHERIT,
                                         hProcessToken,
                                         &GenMap) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
#ifdef DBG
            DebugDumpSD("CPOSE NewSD", pNewSD);
#endif
            //
            // Stamp the SD on the object...  This means that we'll have
            // to allocate a new security descriptor that is 4 bytes
            // bigger than what we need, and set our SeInfo
            //
            PSECURITY_DESCRIPTOR    pSetSD = NULL;
            ULONG cNewSDSize = 0;

            if(RtlpAreControlBitsSet((PISECURITY_DESCRIPTOR)pChildSD,
                                     SE_SELF_RELATIVE))
            {
                cNewSDSize = RtlLengthSecurityDescriptor(pNewSD);
                ASSERT(cNewSDSize != 0);
            }
            else
            {
                MakeSelfRelativeSD(pNewSD,
                                   NULL,
                                   &cNewSDSize);
                ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);
            }

            cNewSDSize += sizeof(ULONG);

            pSetSD = (PSECURITY_DESCRIPTOR)AccAlloc(cNewSDSize);
            if(pSetSD == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                pSetSD = (PSECURITY_DESCRIPTOR)
                               ((PBYTE)pSetSD + sizeof(ULONG));

                if(RtlpAreControlBitsSet((PISECURITY_DESCRIPTOR)pChildSD,
                                         SE_SELF_RELATIVE))
                {
                    memcpy(pSetSD, pNewSD, cNewSDSize - sizeof(ULONG));
                }
                else
                {
                    if(MakeSelfRelativeSD(pNewSD,
                                          pSetSD,
                                          &cNewSDSize) == FALSE)
                    {
                        dwErr = GetLastError();
                    }
                }


                PULONG pSE = (PULONG)((PBYTE)pSetSD - sizeof(ULONG));
                *pSE = SeInfo;

                //
                // We need to pass in the security_information
                //
                pSetSD = (PSECURITY_DESCRIPTOR)pSE;


                //
                // Now, do the write
                //
                dwErr = StampSD(pwszDSObject,
                                cNewSDSize,
                                SeInfo,
                                pSetSD,
                                pLDAP);
                AccFree(pSetSD);
            }
        }
    }


    CLEANUP_ON_INTERRUPT(pfStopFlag);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR            rgAttribs[2];
        WCHAR            wszAttrib[]=L"distinguishedName";

        //
        // Do the search...
        //
        rgAttribs[0] = wszAttrib;
        rgAttribs[1] = NULL;


        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ldap_search_s(pLDAP,
                                  pwszDSObject,
                                  LDAP_SCOPE_ONELEVEL,
                                  L"(objectClass=*)",
                                  rgAttribs,
                                  0,
                                  &pMessage);

            dwErr = LdapMapErrorToWin32( dwErr );
        }

        if(dwErr == ERROR_SUCCESS)
        {

            ULONG   cChildren = ldap_count_entries(pLDAP,
                                                   pMessage);
            acDebugOut((DEB_TRACE_PROP,
                        "%ws has %lu children\n",
                        pwszDSObject, cChildren));

            LDAPMessage *pEntry = ldap_first_entry(pLDAP,
                                                   pMessage);
            for(ULONG i = 0; i < cChildren; i++)
            {
                if(pEntry == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                    break;
                }

                //
                // Now, we'll have to get the values
                //
                CLEANUP_ON_INTERRUPT(pfStopFlag);
                PWSTR  *ppwszValues = ldap_get_values(pLDAP,
                                                      pEntry,
                                                      rgAttribs[0]);

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    //
                    // Go ahead and propagate to the child
                    //
                    acDebugOut((DEB_TRACE_PROP,
                                "Child %ws of %ws [%lu]\n",
                                ppwszValues[0], pwszDSObject, i));

                    dwErr = PropagateDSRightsDeep(pNewSD,
                                                  NULL,
                                                  SeInfo,
                                                  ppwszValues[0],
                                                  pLDAP,
                                                  pcProcessed,
                                                  pfStopFlag);

                    ldap_value_free(ppwszValues);
                    CLEANUP_ON_INTERRUPT(pfStopFlag);
                }

                pEntry = ldap_next_entry(pLDAP,
                                         pEntry);
            }
        }
    }

DSCleanup:
    ldap_msgfree(pMessage);
    DestroyPrivateObjectSecurity(&pNewSD);

    if(fFreeChildSD == TRUE)
    {
        AccFree(pChildSD);
    }

    acDebugOut((DEB_TRACE, "Out PropagateDSRightsDeep: %ld\n", dwErr));
    return(dwErr);

}





//+---------------------------------------------------------------------------
//
//  Function:   StampSD
//
//  Synopsis:   Actually stamps the security descriptor on the object.
//
//  Arguments:  [IN  pwszObject]        --      The object to stamp the SD on
//              [IN  cSDSize]           --      The size of the security descriptor
//              [IN  SeInfo]            --      SecurityInformation about the security
//                                              descriptor
//              [IN  pSD]               --      The SD to stamp
//              [IN  pLDAP]             --      The LDAP connection to use
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
StampSD(IN  PWSTR                pwszObject,
        IN  ULONG                cSDSize,
        IN  SECURITY_INFORMATION SeInfo,
        IN  PSECURITY_DESCRIPTOR pSD,
        IN  PLDAP                pLDAP)
{
    DWORD   dwErr = ERROR_SUCCESS;

    acDebugOut((DEB_TRACE_PROP, "Stamping %ws\n", pwszObject));

    //
    // Now, we'll do the write.  The security descriptor
    // we got passed in better not be in the old Ds  format,
    // where the leading 4 bytes are the SECURITY_INFORMATION, which we'll skip
    // and replace with control information
    //

    ASSERT(*(PULONG)pSD > 0xF );

    PLDAPMod        rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPMod         Mod;
    LDAP_BERVAL     BVal;
    BYTE            ControlBuffer[ 5 ];

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) &ControlBuffer
                        },
                        TRUE
                    };

    //
    // !!! Hardcoded for now.  Use Andyhe's BER_printf once it's done.
    //

    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;    // Denotes an integer;
    ControlBuffer[3] = 0x01;    // Size
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    ASSERT(IsValidSecurityDescriptor( pSD ) );


    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    BVal.bv_len = cSDSize;
    BVal.bv_val = (PCHAR)pSD;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    //
    // Now, we'll do the write...
    //
    dwErr = ldap_modify_ext_s(pLDAP,
                              pwszObject,
                              rgMods,
                              (PLDAPControl *)&ServerControls,
                              NULL);

    dwErr = LdapMapErrorToWin32(dwErr);

#if DBG
    PACL pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR)pSD);
    ACL_SIZE_INFORMATION        AclSize;
    ACL_REVISION_INFORMATION    AclRev;
    PKNOWN_ACE                  pAce;
    PSID                        pSid;
    DWORD                       iIndex;
    DWORD                       GuidPart;
    DWORD                       OldInfoLevel;

    //
    // Now, dump all of the aces
    //
    if(pAcl)
    {
        pAce = (PKNOWN_ACE)FirstAce(pAcl);
        for(iIndex = 0; iIndex < pAcl->AceCount; iIndex++)
        {
            //
            // If it's an object ace, dump the guids
            //
            if(IsObjectAceType(pAce))
            {
                OldInfoLevel = acInfoLevel;
//                acInfoLevel |= DEB_TRACE_SD;
                DebugDumpGuid("\t\t\tObjectId", RtlObjectAceObjectType(pAce));
                GuidPart = (ULONG)((ULONG_PTR)RtlObjectAceObjectType(pAce));
                ASSERT(GuidPart != 0x2bfff20);
                acInfoLevel = OldInfoLevel;
            }
            pAce = (PKNOWN_ACE)NextAce(pAce);
        }
    }
#endif

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   AccDsReadSchemaInfo
//
//  Synopsis:   Reads the schema object/property info.
//
//  Arguments:  [IN  pLDAP]                 --      LDAP connection to use
//              [OUT pcClasses]             --      Where the count of class info
//                                                  is returned
//              [OUT pppwszClasses]         --      Where the list of classes info
//                                                  is returned.  Freed with
//                                                  ldap_value_free
//              [OUT pcAttributes]          --      Where the count of property infos
//                                                  is returned
//              [OUT pppwszAttributes]      --      Where the list of property infos
//                                                  is returned.  Freed with
//                                                  ldap_value_free
//
//  Returns:    ERROR_SUCCESS               --      Success
//
//----------------------------------------------------------------------------
DWORD
AccDsReadSchemaInfo (IN  PLDAP          pLDAP,
                     OUT PULONG         pcClasses,
                     OUT PWSTR        **pppwszClasses,
                     OUT PULONG         pcAttributes,
                     OUT PWSTR        **pppwszAttributes)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR              *ppwszValues = NULL;
    PWSTR               rgwszAttribs[3];
    PDS_NAME_RESULTW    pNameRes = NULL;
    LDAPMessage         *pMessage, *pEntry;

    *pcClasses    = 0;
    *pcAttributes = 0;
    *pppwszAttributes = NULL;
    *pppwszClasses = NULL;

    //
    // Get the subschema path
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgwszAttribs[0] = L"subschemaSubentry";
        rgwszAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgwszAttribs,
                              0,
                              &pMessage);
        if(dwErr == ERROR_SUCCESS)
        {
            pEntry = ldap_first_entry(pLDAP,
                                      pMessage);

            if(pEntry == NULL)
            {
                ldap_msgfree(pMessage);
                pMessage = NULL;
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Now, we'll have to get the values
                //
                ppwszValues = ldap_get_values(pLDAP,
                                              pEntry,
                                              rgwszAttribs[0]);
                ldap_msgfree(pMessage);
                pMessage = NULL;

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    rgwszAttribs[0] = L"extendedClassInfo";
                    rgwszAttribs[1] = L"extendedAttributeInfo";
                    rgwszAttribs[2] = NULL;

                    dwErr = ldap_search_s(pLDAP,
                                          ppwszValues[0],
                                          LDAP_SCOPE_BASE,
                                          L"(objectClass=*)",
                                          rgwszAttribs,
                                          0,
                                          &pMessage);
                    ldap_value_free(ppwszValues);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        ldap_count_entries( pLDAP, pMessage );
                        pEntry = ldap_first_entry(pLDAP,
                                                  pMessage);

                        if(pEntry == NULL)
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                        else
                        {
                            //
                            // Now, we'll have to get the values
                            //
                            *pppwszClasses = ldap_get_values(pLDAP,
                                                             pEntry,
                                                             rgwszAttribs[0]);
                            if(*pppwszClasses == NULL)
                            {
                                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                            }
                            else
                            {
                                *pcClasses = ldap_count_values(*pppwszClasses);

                                *pppwszAttributes = ldap_get_values(pLDAP,
                                                                    pEntry,
                                                                    rgwszAttribs[1]);
                                if(*pppwszAttributes == NULL)
                                {
                                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

                                    ldap_value_free(*pppwszClasses);
                                }
                                else
                                {
                                    *pcAttributes =
                                            ldap_count_values(*pppwszAttributes);
                                }
                            }
                        }

                    }
                    else
                    {
                        dwErr = LdapMapErrorToWin32( dwErr );
                    }

                    ldap_msgfree(pMessage);
                }
            }

        }
        else
        {
            ldap_msgfree(pMessage);
            dwErr = LdapMapErrorToWin32( dwErr );
        }

    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccDsReadExtendedRights
//
//  Synopsis:   Reads the list of extended rights from the schema
//
//  Arguments:  [IN  pLDAP]                 --      LDAP connection to use
//              [OUT pcItems]               --      Where the count of items
//                                                  is returned
//              [OUT ppwszNames]            --      Where the list of Names is
//                                                  returned.
//              [OUT ppwszGuids]            --      Where the list of guids is
//                                                  returned.
//
//  Notes:      Freed via AccDsFreeExtendedRights
//
//  Returns:    ERROR_SUCCESS               --      Success
//
//----------------------------------------------------------------------------
DWORD
AccDsReadExtendedRights(IN PLDAP        pLDAP,
                        OUT PULONG      pcItems,
                        OUT PWSTR     **pppwszNames,
                        OUT PWSTR     **pppwszGuids)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR              *ppwszValues = NULL;
    PWSTR               rgwszAttribs[3];
    PWSTR               pwszERContainer = NULL;
    PDS_NAME_RESULTW    pNameRes = NULL;
    LDAPMessage         *pMessage, *pEntry;
    ULONG               cEntries = 0, i;

    *pcItems = 0;
    *pppwszNames = NULL;
    *pppwszGuids = NULL;

    //
    // Get the subschema path
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgwszAttribs[0] = L"configurationNamingContext";
        rgwszAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgwszAttribs,
                              0,
                              &pMessage);
        if(dwErr == ERROR_SUCCESS)
        {
            pEntry = ldap_first_entry(pLDAP,
                                      pMessage);

            if(pEntry == NULL)
            {
                ldap_msgfree(pMessage);
                pMessage = NULL;
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Now, we'll have to get the values
                //
                ppwszValues = ldap_get_values(pLDAP,
                                              pEntry,
                                              rgwszAttribs[0]);
                ldap_msgfree(pMessage);
                pMessage = NULL;

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    pwszERContainer = (PWSTR)AccAlloc((wcslen(ppwszValues[0]) * sizeof(WCHAR)) +
                                                      sizeof(ACTRL_EXT_RIGHTS_CONTAINER));
                    if(pwszERContainer == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(pwszERContainer,
                               ACTRL_EXT_RIGHTS_CONTAINER);
                        wcscat(pwszERContainer,
                               ppwszValues[0]);


                        rgwszAttribs[0] = L"displayName";
                        rgwszAttribs[1] = L"rightsGuid";
                        rgwszAttribs[2] = NULL;

                        //
                        // Read the control access rights
                        //
                        dwErr = ldap_search_s(pLDAP,
                                              pwszERContainer,
                                              LDAP_SCOPE_ONELEVEL,
                                              L"(objectClass=controlAccessRight)",
                                              rgwszAttribs,
                                              0,
                                              &pMessage);

                        dwErr = LdapMapErrorToWin32( dwErr );

                        AccFree(pwszERContainer);
                    }
                    ldap_value_free(ppwszValues);


                    if(dwErr == ERROR_SUCCESS)
                    {
                        cEntries = ldap_count_entries( pLDAP, pMessage );

                        *pppwszNames = (PWSTR *)AccAlloc( sizeof( PWSTR ) * cEntries );

                        if(*pppwszNames == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            *pppwszGuids = (PWSTR *)AccAlloc( sizeof( PWSTR ) * cEntries );

                            if(*pppwszGuids == NULL)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                AccFree(*pppwszNames);
                                *pppwszNames = NULL;
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            pEntry = ldap_first_entry(pLDAP,
                                                      pMessage);

                            if(pEntry == NULL)
                            {
                                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                            }
                            else
                            {
                                for(i = 0; i < cEntries && dwErr == ERROR_SUCCESS; i++) {
                                    ppwszValues = ldap_get_values(pLDAP,
                                                                  pEntry,
                                                                  rgwszAttribs[0]);
                                    if(ppwszValues == NULL)
                                    {
                                        dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                                    }
                                    else
                                    {
                                        //
                                        // Now, we'll have to get the values
                                        //
                                        ACC_ALLOC_AND_COPY_STRINGW(ppwszValues[0],
                                                                   (*pppwszNames)[i],
                                                                   dwErr);

                                        ldap_value_free(ppwszValues);

                                        if(dwErr == ERROR_SUCCESS)
                                        {
                                            ppwszValues = ldap_get_values(pLDAP,
                                                                          pEntry,
                                                                          rgwszAttribs[1]);
                                            if(ppwszValues == NULL)
                                            {
                                                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );

                                            }
                                            else
                                            {
                                                ACC_ALLOC_AND_COPY_STRINGW(ppwszValues[0],
                                                                           (*pppwszGuids)[i],
                                                                           dwErr);
                                                ldap_value_free(ppwszValues);
                                            }
                                        }
                                    }

                                    pEntry = ldap_next_entry( pLDAP, pEntry );
                                }

                                if(dwErr != ERROR_SUCCESS)
                                {
                                    AccDsFreeExtendedRights(i,
                                                            *pppwszNames,
                                                            *pppwszGuids);
                                }
                            }
                        }

                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        *pcItems = cEntries;
                    }

                    ldap_msgfree(pMessage);
                }
            }

        }
        else
        {
            ldap_msgfree(pMessage);
            dwErr = LdapMapErrorToWin32( dwErr );
        }

    }

    return(dwErr) ;
}




VOID
AccDsFreeExtendedRights(IN ULONG      cItems,
                        IN PWSTR     *ppwszNames,
                        IN PWSTR     *ppwszGuids)
{
    ULONG i;

    for(i = 0;i < cItems;i++ )
    {
        AccFree( ppwszNames[ i ]);
        AccFree( ppwszGuids[ i ]);
    }

    AccFree(ppwszNames);
    AccFree(ppwszGuids);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\alsup.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        alsup.cxx
//
//  Contents:    CAccessList support functions
//
//  Classes:
//
//  History:     06-Nov-96      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <alsup.hxx>
#include <netlib.h>
#include <seopaque.h>
#include <sertlp.h>
#include <martaevt.h>
#include <ntprov.hxx>
#include <strings.h>

DWORD
InitializeEvents(void);



//+---------------------------------------------------------------------------
//
//  Function:   GetOrderTypeForAccessEntry
//
//  Synopsis:   Determines the "order" type of entry given the node
//              information
//
//  Arguments:  [pwszProperty]      --      The property this entry is
//                                          associated with
//              [pAE]               --      The entry to check
//              [SeInfo]            --      Type of node this is supposed to
//                                          be
//
//  Returns:    The type of the node.  This is a bitmask flag of the types
//              ACCLIST_DENIED through ACCLIST_PROP_ALLOWED
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG   GetOrderTypeForAccessEntry(IN  PWSTR                pwszProperty,
                                   IN  PACTRL_ACCESS_ENTRY  pAE,
                                   IN  SECURITY_INFORMATION SeInfo)
{
    ULONG Type = 0;

    //
    // First, check the simple cases (like audit or invalid)
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(FLAG_ON(pAE->fAccessFlags,
                   ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE))
        {
            Type = ACCLIST_AUDIT;
        }
    }
    else
    {
        if(!FLAG_ON(pAE->fAccessFlags,
                ACTRL_AUDIT_SUCCESS  | ACTRL_AUDIT_FAILURE) &&
           FLAG_ON(pAE->fAccessFlags,
                  ACTRL_ACCESS_ALLOWED | ACTRL_ACCESS_DENIED))
        {
            Type = ACCLIST_UNKOWN_ENTRY;
        }
        else
        {
            Type = ACCLIST_AUDIT;
        }
    }


    if(Type == 0)
    {
        if(pwszProperty == NULL && pAE->lpInheritProperty == NULL)
        {
            Type = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    ACCLIST_DENIED  :
                                                    ACCLIST_ALLOWED;
        }
        else if(pwszProperty == NULL)
        {
            Type = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    ACCLIST_OBJ_DENIED  :
                                                    ACCLIST_PROP_ALLOWED;
        }
        else
        {
            Type = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    ACCLIST_OBJ_DENIED  :
                                                    ACCLIST_OBJ_ALLOWED;
        }

        //
        // See if it's inherited.  If it is, and we don't have a level
        // flag, assume it's level 1 and mark it as such
        //
        if(FLAG_ON(pAE->Inheritance, INHERITED_ACCESS_ENTRY) &&
           !FLAG_ON(pAE->Inheritance,
                            INHERITED_PARENT | INHERITED_GRANDPARENT))
        {
            pAE->Inheritance |= INHERITED_PARENT;
        }
    }

    return(Type);
}



//+---------------------------------------------------------------------------
//
//  Function:   OrderListBySid
//
//  Synopsis:   Orders an acclist_cnode list by sid.  The order would be:
//                  Everyone
//                  Well known groups
//                  Groups
//                  Users
//                  Anyone else
//
//  Arguments:  [pList]             --      List of the nodes to sort
//              [iStart]            --      Where to start in the list
//              [iLen]              --      Number of nodes in the list
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG   OrderListBySid(IN  PACCLIST_CNODE   pList,
                       IN  ULONG            iStart,
                       IN  ULONG            iLen)
{
    DWORD   dwErr = ERROR_SUCCESS;


    return(dwErr);
}





//
// Local functions
//
//+---------------------------------------------------------------------------
//
//  Function:   DelAcclistNode
//
//  Synopsis:   Deletes an ACCLIST_NODE that's kept in the _AccList.  This is
//              used by the CSList
//
//  Arguments:  [IN pvNode]     --      Node to delete
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
void DelAcclistNode(PVOID   pvNode)
{
    PACCLIST_NODE pNode = (PACCLIST_NODE)pvNode;

    AccFree(pNode->pAccessList);
    AccFree(pNode->pAuditList);
    AccFree(pNode->pwszProperty);

    AccFree(pNode);
}




//+---------------------------------------------------------------------------
//
//  Function:   DelTrusteeNode
//
//  Synopsis:   Deletes an TRUSTEE_NODE that's kept in the _TrusteeList.
//              This is used by the CSList
//
//  Arguments:  [IN pvNode]     --      Node to delete
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
void DelTrusteeNode(PVOID   pvNode)
{
    acDebugOut((DEB_TRACE_ACC, "IN DelTrusteeNode\n"));

    PTRUSTEE_NODE pNode = (PTRUSTEE_NODE)pvNode;

    if(FLAG_ON(pNode->fFlags,TRUSTEE_DELETE_SID))
    {
        AccFree(pNode->pSid);
    }

    if(FLAG_ON(pNode->fFlags,TRUSTEE_DELETE_NAME))
    {
        AccFree(pNode->pwszTrusteeName);
        AccFree(pNode->pwszDomainName);
    }
    else if(FLAG_ON(pNode->fFlags, TRUSTEE_DELETE_DOMAIN))
    {
        AccFree(pNode->pwszDomainName);
    }

    AccFree(pNode);

    acDebugOut((DEB_TRACE_ACC, "Out DelTrusteeNode\n"));
}




//+---------------------------------------------------------------------------
//
//  Function:   CompInheritProps
//
//  Synopsis:   Compare the given property name to the PIPROP_IN_BUFF stuct
//
//  Arguments:  [IN pvTrustee]  --      Trustee to look for
//              [IN pvNode2]    --      2nd node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompInheritProps(IN  PVOID      pvInheritProp,
                         IN  PVOID      pvNode2)
{
    BOOL    fRet = FALSE;
    PIPROP_IN_BUFF  pPIB = (PIPROP_IN_BUFF)pvNode2;

    if(pvInheritProp != NULL)
    {
        if(_wcsicmp((PWSTR)pvInheritProp, (PWSTR)(pPIB->pwszIProp)) == 0)
        {
            fRet = TRUE;
        }
    }

    return(fRet);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompTrustees
//
//  Synopsis:   Compare two TRUSTEE_NODES.  Used by _TrusteeList.
//
//  Arguments:  [IN pvTrustee]  --      Trustee to look for
//              [IN pvNode2]    --      2nd node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompTrustees(IN  PVOID     pvTrustee,
                     IN  PVOID     pvTrustee2)
{
    PTRUSTEE        pTrustee = (PTRUSTEE)pvTrustee;
    TRUSTEE_NODE    TrusteeNode;
    BOOL            Result = FALSE;

    memset( &TrusteeNode, 0, sizeof( TrusteeNode ) );
    memcpy( &TrusteeNode.Trustee, pvTrustee2, sizeof( TRUSTEE ) );

    Result = CompTrusteeToTrusteeNode(pvTrustee, &TrusteeNode);


    if(FLAG_ON(TrusteeNode.fFlags,TRUSTEE_DELETE_SID))
    {
        AccFree(TrusteeNode.pSid);
    }

    if(FLAG_ON(TrusteeNode.fFlags,TRUSTEE_DELETE_NAME))
    {
        AccFree(TrusteeNode.pwszTrusteeName);
        AccFree(TrusteeNode.pwszDomainName);
        TrusteeNode.pwszDomainName = NULL;
    }

    if(FLAG_ON(TrusteeNode.fFlags, TRUSTEE_DELETE_DOMAIN))
    {
        AccFree(TrusteeNode.pwszDomainName);
    }

    return(Result);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompTrusteeToTrusteeNode
//
//  Synopsis:   Compare two trustees for equality
//
//  Arguments:  [IN pvTrustee]  --      Trustee to look for
//              [IN pvNode2]    --      2nd node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompTrusteeToTrusteeNode(IN  PVOID     pvTrustee,
                                 IN  PVOID     pvNode2)
{
    PTRUSTEE        pTrustee = (PTRUSTEE)pvTrustee;
    PTRUSTEE_NODE   pNode2 = (PTRUSTEE_NODE)pvNode2;

    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fMatch = FALSE;
    if(pTrustee->MultipleTrusteeOperation ==
                                    pNode2->Trustee.MultipleTrusteeOperation)
    {
        //
        // Ok, first compare the base trustee information...
        //
        if(pTrustee->TrusteeForm != pNode2->Trustee.TrusteeForm)
        {
            //
            // We don't have matching information, so we'll have to look
            // it up.
            //
            ULONG fOptions = 0;

            if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
            {
                fOptions = TRUSTEE_OPT_NAME;
            }
            else
            {
                fOptions = TRUSTEE_OPT_SID;
            }

            dwErr = LookupTrusteeNodeInformation(NULL,  
                                                 pNode2,
                                                 fOptions);
        }

        //
        // Now, do the comparrisons
        //
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, compare the trustees
            //
            if(pTrustee->TrusteeForm == TRUSTEE_IS_NAME)
            {
                if(_wcsicmp(pTrustee->ptstrName,
                            pNode2->pwszTrusteeName ?
                                pNode2->pwszTrusteeName :
                                pNode2->Trustee.ptstrName) == 0)
                {
                    fMatch = TRUE;
                }
            }
            else
            {
                if(pTrustee->ptstrName == NULL ||
                   (pNode2->Trustee.ptstrName == NULL && pNode2->pSid == NULL))
                {
                    fMatch = FALSE;
                }
                else
                {
                    fMatch = RtlEqualSid((PSID)(pTrustee->ptstrName),
                                         (PSID)(pNode2->pSid ?
                                                    pNode2->pSid :
                                                    pNode2->Trustee.ptstrName));
                }
            }
        }

        //
        // Now, if that worked, look for the multiple trustee case
        //
        if(fMatch == TRUE &&
                pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
        {
            fMatch = CompTrusteeToTrusteeNode(pTrustee->pMultipleTrustee,
                                              pNode2->pImpersonate);
        }
    }

    return(fMatch);
}




//+---------------------------------------------------------------------------
//
//  Function:   DoPropertiesMatch
//
//  Synopsis:   Determines if 2 properties are equal.  It takes into account
//              the possibility of a NULL property.
//
//  Arguments:  [IN pwszProp1]  --      1st property to compare
//              [IN pwszProp2]  --      2nd property to compare
//
//  Returns:    TRUE            --      Properties are equal
//              FALSE           --      Properties are not equal
//
//----------------------------------------------------------------------------
BOOL DoPropertiesMatch(IN  PWSTR    pwszProp1,
                       IN  PWSTR    pwszProp2)
{
    BOOL    fReturn = FALSE;

    if(pwszProp1 == NULL || pwszProp2 == NULL)
    {
        if(pwszProp1 == pwszProp2)
        {
            fReturn = TRUE;
        }
    }
    else
    {
        if(_wcsicmp(pwszProp1, pwszProp2) == 0)
        {
            fReturn = TRUE;
        }
    }

    return(fReturn);
}





//+---------------------------------------------------------------------------
//
//  Function:   CompProps
//
//  Synopsis:   Compare an ACCLIST_NODE to a property
//
//  Arguments:  [IN pvProp]     --      Property string
//              [IN pvNode]     --      Node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompProps(IN  PVOID     pvProp,
                  IN  PVOID     pvNode)
{
    PACCLIST_NODE    pAN = (PACCLIST_NODE)pvNode;

    return(DoPropertiesMatch((PWSTR)pvProp, pAN->pwszProperty));
}




//+---------------------------------------------------------------------------
//
//  Function:   CompGuids
//
//  Synopsis:   Compare an ACCLIST_ATOACCESS structure to a guid
//
//  Arguments:  [IN pvGuid]     --      Guid
//              [IN pvNode]     --      Node to compare
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL    CompGuids(IN  PVOID     pvGuid,
                  IN  PVOID     pvNode)
{
    PACCLIST_ATOACCESS  pAA = (PACCLIST_ATOACCESS)pvNode;
    GUID               *pGuid = (GUID *)pvGuid;

    if(pGuid == NULL && pAA->pGuid == NULL)
    {
        return(TRUE);
    }
    else if(pGuid == NULL || pAA->pGuid == NULL)
    {
        return(FALSE);
    }

    return((BOOL)!memcmp(pGuid, pAA->pGuid, sizeof(GUID)));
}




//+---------------------------------------------------------------------------
//
//  Function:   LookupTrusteeNodeInformation
//
//  Synopsis:   Looks up the appropriate trustee information.  This involves
//              either looking up the trustees sid or name, depending on
//              the options
//
//  Arguments:  [pwszServer]        --      Name of server to lookup information on
//              [pTrusteeNode]      --      Trustee to lookup the information
//                                          for
//              [fOptions]          --      What information to lookup
//
//  Returns:    ERROR_SUCCESS       --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD LookupTrusteeNodeInformation(IN  PWSTR          pwszServer,
                                   IN  PTRUSTEE_NODE  pTrusteeNode,
                                   IN  ULONG          fOptions)
{
    DWORD   dwErr = ERROR_SUCCESS;

    SID_NAME_USE    SidType = SidTypeUnknown;

    //
    // Need to make sure we have the SID
    //
    if(FLAG_ON(fOptions, TRUSTEE_OPT_SID))
    {
        //
        // Make sure we have the sids
        //
        if(pTrusteeNode->pSid == NULL)
        {
            dwErr = AccctrlLookupSid(pwszServer,
                                     pTrusteeNode->Trustee.ptstrName,
                                     TRUE,
                                     &(pTrusteeNode->pSid),
                                     &SidType);

            if(dwErr == ERROR_SUCCESS)
            {
                pTrusteeNode->fFlags |= TRUSTEE_DELETE_SID;
            }
        }
    }

    //
    // Ok, we need to have the name
    //
    if(dwErr == ERROR_SUCCESS && FLAG_ON(fOptions, TRUSTEE_OPT_NAME))
    {
        //
        // Make sure we have the name
        //
        if(pTrusteeNode->pwszTrusteeName == NULL)
        {
            dwErr = AccctrlLookupName(pwszServer,
                                      pTrusteeNode->pSid,
                                      TRUE,
                                      &(pTrusteeNode->pwszTrusteeName),
                                      &SidType);
            if(dwErr == ERROR_SUCCESS)
            {
                pTrusteeNode->fFlags |= TRUSTEE_DELETE_NAME;
            }
        }
    }

    //
    // Then, take care of our sid type
    //
    if(dwErr == ERROR_SUCCESS && pTrusteeNode->SidType == SidTypeUnknown)
    {
        pTrusteeNode->SidType = SidType;

        if(SidType == SidTypeUnknown)
        {
            pTrusteeNode->Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        }
        else
        {
            pTrusteeNode->Trustee.TrusteeType = (TRUSTEE_TYPE)(SidType);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetATypeForEntry
//
//  Synopsis:   Determines the type of entry given the node information
//
//  Arguments:  [pwszProperty]      --      The property this entry is
//                                          associated with
//              [pAE]               --      The entry to check
//              [SeInfo]            --      Type of node this is supposed to
//                                          be
//
//  Returns:    The type of the node
//
//  Notes:
//
//----------------------------------------------------------------------------
ACC_ACLBLD_TYPE   GetATypeForEntry(IN  PWSTR                pwszProperty,
                                   IN  PACTRL_ACCESS_ENTRY  pAE,
                                   IN  SECURITY_INFORMATION SeInfo)
{
    ACC_ACLBLD_TYPE AType = AAT_DENIED;

    //
    // First, check the simple cases (like audit or invalid)
    //

    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(FLAG_ON(pAE->fAccessFlags,
                   ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE))
        {
            AType = AAT_INVALID;
        }
    }
    else
    {
        if(!FLAG_ON(pAE->fAccessFlags,
                ACTRL_AUDIT_SUCCESS  | ACTRL_AUDIT_FAILURE) &&
           FLAG_ON(pAE->fAccessFlags,
                  ACTRL_ACCESS_ALLOWED | ACTRL_ACCESS_DENIED))
        {
            AType = AAT_INVALID;
        }
        else
        {
            AType = AAT_AUDIT;
        }
    }


    if(AType == 0)
    {
        if(pwszProperty == NULL && pAE->lpInheritProperty == NULL)
        {
            AType = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    AAT_DENIED  :
                                                    AAT_ALLOWED;
        }
        else if(pwszProperty == NULL)
        {
            AType = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    AAT_OBJ_DENIED  :
                                                    AAT_PROP_ALLOWED;
        }
        else
        {
            AType = pAE->fAccessFlags == ACTRL_ACCESS_DENIED ?
                                                    AAT_OBJ_DENIED  :
                                                    AAT_OBJ_ALLOWED;
        }

        //
        // See if it's inherited
        //
        if(FLAG_ON(pAE->Inheritance, INHERITED_ACCESS_ENTRY))
        {
            AType =(ACC_ACLBLD_TYPE)
                    ((ULONG)AType + ((ULONG)AAT_IDENIED - (ULONG)AAT_DENIED));
        }
    }

    return(AType);
}




//+---------------------------------------------------------------------------
//
//  Function:   CNodeCompare
//
//  Synopsis:   Used by CSList class.  Used to determine if 2 acclist_cnodes are
//              identical, based upon the property
//
//  Arguments:  [pv1]               --      1st node
//              [pv2]               --      2nd node
//
//  Returns:    0   on equality
//              non-0 otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
int __cdecl CNodeCompare(const void  *pv1, const void  *pv2)
{
    PACCLIST_CNODE  pCN1 = (PACCLIST_CNODE)pv1;
    PACCLIST_CNODE  pCN2 = (PACCLIST_CNODE)pv2;

    if(pCN1->pONode->pwszProperty == NULL)
    {
        return(-1);
    }

    if(pCN2->pONode->pwszProperty == NULL)
    {
        return(1);
    }

    return(_wcsicmp(pCN1->pONode->pwszProperty, pCN2->pONode->pwszProperty));
}








//+---------------------------------------------------------------------------
//
//  Function:   CompAndMarkCompressNode
//
//  Synopsis:   Used by CSList class.  Used to determine if 2 nodes can be
//              compressed into one.  If so, the first node has its access
//              flag marked with a bit signifying it can be compressed.  See
//              below for the definition of what it means to be compressible
//
//  Arguments:  [pvAE]              --      New node
//              [pvNode]            --      Node already existing in list
//
//  Returns:    0   on equality
//              non-0 otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL  CompAndMarkCompressNode(IN  PVOID pvAE,
                              IN  PVOID pvNode)
{
    PACTRL_ACCESS_ENTRY pAE1 = (PACTRL_ACCESS_ENTRY)pvAE;
    PACTRL_ACCESS_ENTRY pAE2 = (PACTRL_ACCESS_ENTRY)pvNode;

    //
    // We will consider nodes identical iff:
    // They match trustee, inheritance, and access flags exactly and the
    // inherit property or (along with the rest of the above):
    //  - Both nodes are inherited and one is marked l1 inherited and the
    //    other is not marked at all, or neither node is inherited
    //    and the inheritance is identical or the inheritance is different
    //    but the access masks are the same
    //  - fAccessFlags indicates that combining this 2 nodes will still
    //    yield an audit node.
    //
    if(CompTrustees(&pAE1->Trustee,&pAE2->Trustee) == TRUE &&
        //
        // Check the inheritance
        //
       (pAE1->Inheritance == pAE2->Inheritance ||
        (pAE1->Inheritance & ~INHERITED_PARENT) ==
                                    (pAE2->Inheritance & ~INHERITED_PARENT) ||
        (!FLAG_ON(pAE1->Inheritance, INHERITED_ACCESS_ENTRY) &&
         !FLAG_ON(pAE2->Inheritance, INHERITED_ACCESS_ENTRY)&&
         (pAE1->Inheritance != 0 && pAE2->Inheritance != 0) &&
         (pAE1->Access) == pAE2->Access)) &&
         //
         // Check the access
         //

        (((pAE1->fAccessFlags & ~(ACCLIST_COMPRESS | ~ACCLIST_VALID_TYPE_FLAGS)) ==
                                          ( pAE2->fAccessFlags & ~~ACCLIST_VALID_TYPE_FLAGS ) ||
        (((((pAE1->fAccessFlags & ~(ACCLIST_COMPRESS | ~ACCLIST_VALID_TYPE_FLAGS)) |
                                          (pAE2->fAccessFlags & ~~ACCLIST_VALID_TYPE_FLAGS)) &
                 ~(ACTRL_AUDIT_SUCCESS | ACTRL_AUDIT_FAILURE)) == 0))) &&
                 pAE1->Access == pAE2->Access) &&
        //
        // Check the properties
        //
        DoPropertiesMatch(pAE1->lpInheritProperty,
                          pAE2->lpInheritProperty) == TRUE)
    {
        pAE1->fAccessFlags |= ACCLIST_COMPRESS;
        return(TRUE);
    }

    return(FALSE);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetNodeForProperty
//
//  Synopsis:   This function will lookup the existing list node for the given
//              property.  If the node doesn't exist, it will be created and
//              inserted into the list
//
//  Arguments:  [List]              --      List to examine
//              [pwszProperty]      --      The property to look for
//              [ppNode]            --      Where the found or inserted node is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetNodeForProperty(CSList&        List,
                         PWSTR          pwszProperty,
                         PACCLIST_NODE *ppNode)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACCLIST_NODE pAccNode = (PACCLIST_NODE)List.Find(pwszProperty,
                                                      CompProps);
    if(pAccNode == NULL)
    {
        //
        // Doesn't exist.  We'll have to add it...
        //
        pAccNode = (PACCLIST_NODE)AccAlloc(sizeof(ACCLIST_NODE));
        if(pAccNode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if(pwszProperty != NULL)
            {
                ACC_ALLOC_AND_COPY_STRINGW(pwszProperty,
                                           pAccNode->pwszProperty,
                                           dwErr);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = List.Insert((PVOID)pAccNode);

                if(dwErr != ERROR_SUCCESS)
                {
                    AccFree(pAccNode->pwszProperty);
                    AccFree(pAccNode);
                }
            }
            else
            {
                AccFree(pAccNode);
                pAccNode = 0;
            }
        }
    }

    *ppNode = pAccNode;

    return(dwErr);
}



VOID
FreeAToAccessStruct(PVOID pv)
{
    ((PACCLIST_ATOACCESS)pv)->AceList.FreeList((FreeFunc)AccFree);
    AccFree(pv);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNodeForGuid
//
//  Synopsis:   Finds the node in the given list based upon the guid.  If the
//              node doesn't exist, it is inserted
//
//  Arguments:  [List]              --      List to examine
//              [pGuid]             --      The guid to look for
//              [ppNode]            --      Where the found or inserted node is
//                                          returned
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetNodeForGuid(CSList&             List,
                     GUID               *pGuid,
                     PACCLIST_ATOACCESS *ppNode)
{
    DWORD   dwErr = ERROR_SUCCESS;

    List.Init((FreeFunc)FreeAToAccessStruct);

    PACCLIST_ATOACCESS pNode = (PACCLIST_ATOACCESS)List.Find(pGuid,
                                                             CompGuids);
    if(pNode == NULL)
    {
        //
        // Doesn't exist.  We'll have to add it...
        //
        pNode = (PACCLIST_ATOACCESS)AccAlloc(sizeof(ACCLIST_ATOACCESS));
        if(pNode == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            pNode->AceList.Init((FreeFunc)AccFree);

            if(pGuid != NULL)
            {
                pNode->pGuid = (GUID *)AccAlloc(sizeof(GUID));
                if(pNode->pGuid == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    AccFree(pNode);
                    pNode = 0;
                }
                else
                {
                    memcpy(pNode->pGuid,
                           pGuid,
                           sizeof(GUID));
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = List.Insert((PVOID)pNode);

                if(dwErr != ERROR_SUCCESS)
                {
                    AccFree(pNode->pGuid);
                    AccFree(pNode);
                }
            }
        }
    }

    *ppNode = pNode;

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   InsertAtoANode
//
//  Synopsis:   Inserts an access to ace node into the list.
//
//  Arguments:  [List]              --      List to insert in
//              [pProperty]         --      Property to match
//              [pAce]              --      Ace to be inserted
//              [fInherit]          --      Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD InsertAtoANode(CSList&        List,
                     GUID          *pProperty,
                     PACE_HEADER    pAce,
                     ULONG          fInherit)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACCLIST_ATOANODE pAANode =
                        (PACCLIST_ATOANODE)AccAlloc(sizeof(ACCLIST_ATOANODE));
    if(pAANode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pAANode->pAce = pAce;
        pAANode->fInherit = fInherit;

        PACCLIST_ATOACCESS pParent;

        dwErr = GetNodeForGuid(List,
                               pProperty,
                               &pParent);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = pParent->AceList.Insert((PVOID)pAANode);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            AccFree(pAANode);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AceToAccessEntry
//
//  Synopsis:   Converts an ACE into an access entry
//
//  Arguments:  [pAce]              --      Ace to convert
//              [fInheritLevel]     --      What inheritance level (effective,
//                                          parent inherit, etc) are we at
//              [ObjType]           --      Type of object we're dealing with
//              [pAE]               --      Already existing access entry to
//                                          initialize
//
//  Returns:    ERROR_SUCCESS       --      Success
//              ERROR_INVALID_ACL   --      A bad ace type was encountered
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD   AceToAccessEntry(PACE_HEADER            pAce,
                         ULONG                  fInheritLevel,
                         SE_OBJECT_TYPE         ObjType,
                         IN MARTA_KERNEL_TYPE   KernelObjectType,
                         PACTRL_ACCESS_ENTRY    pAE)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Go ahead and initialize the node
    //
    BOOL    fIsImpersonate = FALSE;
    BOOL    fIsExtendedAce = FALSE;

    //
    // Ok, now lets try to figure out what type of ACE this is, so we can
    // do the neccessary mapping into the provider rights
    //
    switch(pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_ALLOWED;
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_ALLOWED;
        fIsExtendedAce = TRUE;
        break;

    //
    // Currently unsupported
    //
    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_ALLOWED;
        fIsImpersonate = TRUE;
        dwErr = ERROR_INVALID_ACL;
        break;

    case ACCESS_DENIED_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_DENIED;
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        pAE->fAccessFlags = ACTRL_ACCESS_DENIED;
        fIsExtendedAce = TRUE;
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

        pAE->fAccessFlags = 0;

        if(FLAG_ON(pAce->AceFlags,SUCCESSFUL_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_SUCCESS;
        }

        if(FLAG_ON(pAce->AceFlags,FAILED_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_FAILURE;
        }
        fIsExtendedAce = TRUE;
        break;

    case SYSTEM_AUDIT_ACE_TYPE:

        pAE->fAccessFlags = 0;

        if(FLAG_ON(pAce->AceFlags,SUCCESSFUL_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_SUCCESS;
        }

        if(FLAG_ON(pAce->AceFlags,FAILED_ACCESS_ACE_FLAG))
        {
            pAE->fAccessFlags |= ACTRL_AUDIT_FAILURE;
        }
        break;

    default:
        dwErr = ERROR_INVALID_ACL;
        break;

    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Pull what we can from the ace header
        //
        pAE->Inheritance = (INHERIT_FLAGS)( pAce->AceFlags & VALID_INHERIT_FLAGS );
        pAE->Inheritance |= fInheritLevel;

        PSID pSid = NULL;
        ACCESS_MASK AccessMask = 0;
        if(fIsImpersonate == FALSE)
        {
            if(fIsExtendedAce == TRUE)
            {
                pSid = RtlObjectAceSid(pAce);
                AccessMask = ((PKNOWN_OBJECT_ACE)pAce)->Mask;
            }
            else
            {
                pSid = &((PKNOWN_ACE)pAce)->SidStart;
                AccessMask = ((PKNOWN_ACE)pAce)->Mask;
            }
        }
        else
        {
            if(fIsExtendedAce == TRUE)
            {
                dwErr = ERROR_INVALID_ACL;
            }
            else
            {
                pSid =
                 (PSID)Add2Ptr(&((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->SidStart,
                 RtlLengthSid(&((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->SidStart));
                AccessMask = ((PCOMPOUND_ACCESS_ALLOWED_ACE)pAce)->Mask;
            }
        }

        //
        // Build the trustee
        //
        pAE->Trustee.pMultipleTrustee = NULL;
        pAE->Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        pAE->Trustee.TrusteeForm = TRUSTEE_IS_SID;
        pAE->Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        pAE->Trustee.ptstrName = (LPWSTR)pSid;


        //
        // Convert our access
        //
        AccConvertAccessMaskToActrlAccess(AccessMask,
                                          ObjType,
                                          KernelObjectType,
                                          pAE);

        //
        // Deal with the inheritance property...
        //
        if(fIsExtendedAce == TRUE)
        {
            PACCESS_ALLOWED_OBJECT_ACE pExAce =
                               (PACCESS_ALLOWED_OBJECT_ACE)pAce;

            if(FLAG_ON(pExAce->Flags,
                       ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                PWSTR StrUuid;
                dwErr = UuidToString(RtlObjectAceInheritedObjectType(pAce),
                                     &StrUuid );

                //
                // The calling functions expect a buffer allocated with AccAlloc
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    ACC_ALLOC_AND_COPY_STRINGW(StrUuid, (PWSTR)pAE->lpInheritProperty, dwErr);
                    RpcStringFree(&StrUuid);
                }

            }
        }
        else
        {
            pAE->lpInheritProperty = NULL;
        }

    }


    if(dwErr != ERROR_SUCCESS)
    {
        if(pAE->lpInheritProperty != NULL)
        {
            AccFree((PWSTR)pAE->lpInheritProperty);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertToAutoInheritSD
//
//  Synopsis:   Determines the inheritance necessary for the current security
//              descriptor given the parent security descriptor
//
//  Arguments:  [IN  pCurrentSD]        --      The security descriptor to
//                                              update
//              [IN  pParentSD]         --      The parent security descriptor
//              [IN  fIsContainer]      --      Does the Sec. Desc. refer to
//                                              a container?
//              [IN  pGenericMapping]   --      Generic mapping to apply
//              [OUT ppNewSD]           --      Where the new SD is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//  Notes:      The returned security descriptor must be freed via a call to
//              DestroyPrivateObjectSecurity
//
//----------------------------------------------------------------------------
DWORD
ConvertToAutoInheritSD(IN  PSECURITY_DESCRIPTOR   pParentSD,
                       IN  PSECURITY_DESCRIPTOR   pCurrentSD,
                       IN  BOOL                   fIsContainer,
                       IN  PGENERIC_MAPPING       pGenericMapping,
                       OUT PSECURITY_DESCRIPTOR  *ppNewSD)
{
    DWORD                       dwErr = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR_CONTROL OldControl;

    //
    // Turn off the inherited bits, so we can always do the
    // necessary inheritance checks.  This is because we don't know if some
    // downlevel process came in and messed with one of our security
    // descriptors, and left is in a hosed state
    //
    OldControl = ((SECURITY_DESCRIPTOR *)pCurrentSD)->Control;

    ((SECURITY_DESCRIPTOR *)pCurrentSD)->Control &=
                       ~(SE_DACL_AUTO_INHERITED | SE_SACL_AUTO_INHERITED);

#ifdef DBG
    if(pParentSD != NULL)
    {
        ASSERT(IsValidSecurityDescriptor(pParentSD));
        DebugDumpSD("CTAIPOS ParentSD", pParentSD);
    }

    ASSERT(IsValidSecurityDescriptor(pCurrentSD));
    DebugDumpSD("CTAIPOS CurrentSD",  pCurrentSD);
#endif

    if(ConvertToAutoInheritPrivateObjectSecurity(pParentSD,
                                                 pCurrentSD,
                                                 ppNewSD,
                                                 NULL,
                                                 fIsContainer != 0,
                                                 pGenericMapping) == FALSE)
    {
        dwErr = GetLastError();
    }
#ifdef DBG
    else
    {
        ASSERT(IsValidSecurityDescriptor(*ppNewSD));
        DebugDumpSD("CTAIPOS NewSD", *ppNewSD);
    }
#endif

    ((SECURITY_DESCRIPTOR *)pCurrentSD)->Control = OldControl;

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   MakeSDAbsolute
//
//  Synopsis:   Allocates a new security descriptor and makes an absolute copy
//              of the supplied SD
//
//  Arguments:  [IN  pOriginalSD]       --      The security descriptor to
//                                              convert
//              [IN  SeInfo]            --      SD components to care about
//              [IN  *ppNewSD]          --      Where the new SD is returned
//              [IN  pOwnerToAdd]       --      OPTIONAL.  Owner SID to add to
//                                              absolute SD.
//              [IN  pGroupToAdd]       --      OPTIONAL.  Group SID to add to
//                                              absolute SD.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation falied
//
//  Notes:      The returned security descriptor must be freed via a call to
//              AccFree
//
//----------------------------------------------------------------------------
DWORD
MakeSDAbsolute(IN  PSECURITY_DESCRIPTOR     pOriginalSD,
               IN  SECURITY_INFORMATION     SeInfo,
               OUT PSECURITY_DESCRIPTOR    *ppNewSD,
               IN  PSID                     pOwnerToAdd,
               IN  PSID                     pGroupToAdd)
{
    DWORD   dwErr = ERROR_SUCCESS;

    BOOL    fDAclPresent = FALSE;
    BOOL    fSAclPresent = FALSE;
    BOOL    fDAclDef = FALSE, fSAclDef = FALSE;
    BOOL    fOwnerDef = FALSE, fGroupDef = FALSE;
    PACL    pDAcl = NULL, pSAcl = NULL;
    PSID    pOwner = NULL, pGroup = NULL;
    ULONG   cSize = 0;

    //
    // First, get the info out of the current SD
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
    {
        if(GetSecurityDescriptorDacl(pOriginalSD, &fDAclPresent, &pDAcl, &fDAclDef) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDAcl != NULL)
            {
                cSize += pDAcl->AclSize;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
    {
        if(GetSecurityDescriptorSacl(pOriginalSD, &fSAclPresent, &pSAcl, &fSAclDef) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSAcl != NULL)
            {
                cSize += pSAcl->AclSize;
            }
        }
    }

    if(pOwnerToAdd != NULL)
    {
        pOwner = pOwnerToAdd;
    }
    else
    {
        if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
        {
            if(GetSecurityDescriptorOwner(pOriginalSD, &pOwner, &fOwnerDef) == FALSE)
            {
                dwErr = GetLastError();
            }
        }
    }

    if(pGroupToAdd != NULL)
    {
        pGroup = pGroupToAdd;
    }
    else
    {
        if(dwErr == ERROR_SUCCESS && FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
        {
            if(GetSecurityDescriptorGroup(pOriginalSD, &pGroup, &fGroupDef) == FALSE)
            {
                dwErr = GetLastError();
            }
        }
    }

    if(pOwner != NULL)
    {
        cSize += RtlLengthSid(pOwner);
    }

    if(pGroup != NULL)
    {
        cSize += RtlLengthSid(pGroup);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Allocate the buffer...
        //
        PBYTE   pBuff = (PBYTE)AccAlloc(cSize + sizeof(SECURITY_DESCRIPTOR));
        if(pBuff == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Start copying in the existing items...
            //
            DWORD   cLen;
            PBYTE   pbEndOBuf = pBuff + cSize + sizeof(SECURITY_DESCRIPTOR);

            if(pOwner != NULL)
            {
                cLen = RtlLengthSid(pOwner);
                pbEndOBuf -= cLen;
                RtlCopyMemory(pbEndOBuf, pOwner, cLen);
                pOwner = (PSID)pbEndOBuf;
            }

            if(pGroup != NULL)
            {
                cLen = RtlLengthSid(pGroup);
                pbEndOBuf -= cLen;
                RtlCopyMemory(pbEndOBuf, pGroup, cLen);
                pGroup = (PSID)pbEndOBuf;
            }

            if(pDAcl != NULL)
            {
                pbEndOBuf -= pDAcl->AclSize;
                RtlCopyMemory(pbEndOBuf, pDAcl, pDAcl->AclSize);
                pDAcl = (PACL)pbEndOBuf;
            }

            if(pSAcl != NULL)
            {
                pbEndOBuf -= pSAcl->AclSize;
                RtlCopyMemory(pbEndOBuf, pSAcl, pSAcl->AclSize);
                pSAcl = (PACL)pbEndOBuf;
            }

            //
            // Ok, now build it...
            //
            *ppNewSD = (PSECURITY_DESCRIPTOR)pBuff;
            if(InitializeSecurityDescriptor(*ppNewSD, SECURITY_DESCRIPTOR_REVISION) == FALSE)
            {
                dwErr = GetLastError();
            }

            if(dwErr == ERROR_SUCCESS && fDAclPresent == TRUE)
            {
                if(SetSecurityDescriptorDacl(*ppNewSD, TRUE, pDAcl, fDAclDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && fSAclPresent == TRUE)
            {
                if(SetSecurityDescriptorSacl(*ppNewSD, TRUE, pSAcl, fSAclDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && pOwner != NULL)

            {
                if(SetSecurityDescriptorOwner(*ppNewSD, pOwner, fOwnerDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS && pGroup != NULL)

            {
                if(SetSecurityDescriptorGroup(*ppNewSD, pGroup, fGroupDef) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

            //
            // Set the new control bits to look like the old ones (minus the selfrel flag, of
            // course...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                RtlpPropagateControlBits((PISECURITY_DESCRIPTOR)*ppNewSD,
                                         (PISECURITY_DESCRIPTOR)pOriginalSD,
                                         ~SE_SELF_RELATIVE );
            }

            if(dwErr != ERROR_SUCCESS)
            {
                AccFree(*ppNewSD);
                *ppNewSD = NULL;
            }

        }

    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   EqualSecurityDescriptors
//
//  Synopsis:   Determines if 2 security descriptors are identical.  It does
//              this by comparing control fields, owner/group, and sids.
//
//  Arguments:  [IN  pSD1]              --      1st SD to compare
//              [IN  pSD2]              --      2nd SD to compare
//
//  Returns:    TRUE                    --      They are identical
//              FALSE                   --      They are not identical
//
//
//----------------------------------------------------------------------------
BOOL
EqualSecurityDescriptors(IN  PSECURITY_DESCRIPTOR   pSD1,
                         IN  PSECURITY_DESCRIPTOR   pSD2)
{
    BOOL    fRet = TRUE;

    SECURITY_DESCRIPTOR *pS1 = (SECURITY_DESCRIPTOR *)pSD1;
    SECURITY_DESCRIPTOR *pS2 = (SECURITY_DESCRIPTOR *)pSD2;

    if(pS1->Control != pS2->Control)
    {
        return(FALSE);
    }

    PACL    pA1, pA2;

    //
    // Dacl
    //
    pA1 = RtlpDaclAddrSecurityDescriptor(pS1);
    pA2 = RtlpDaclAddrSecurityDescriptor(pS2);

    if((pA1 == NULL && pA2 != NULL) || (pA2 == NULL && pA1 != NULL))
    {
        return(FALSE);
    }

    if(pA1 != NULL)
    {
        if(!(pA1->AclSize == pA2->AclSize && memcmp(pA1, pA2, pA1->AclSize)))
        {
            return(FALSE);
        }
    }

    //
    // Sacl
    //
    pA1 = RtlpSaclAddrSecurityDescriptor(pS1);
    pA2 = RtlpSaclAddrSecurityDescriptor(pS2);

    if((pA1 == NULL && pA2 != NULL) || (pA2 == NULL && pA1 != NULL))
    {
        return(FALSE);
    }

    if(pA1 != NULL)
    {
        if(!(pA1->AclSize == pA2->AclSize && memcmp(pA1, pA2, pA1->AclSize)))
        {
            return(FALSE);
        }
    }

    //
    // Group
    //
    PSID    pSid1, pSid2;
    pSid1 = RtlpGroupAddrSecurityDescriptor(pS1);
    pSid2 = RtlpGroupAddrSecurityDescriptor(pS2);

    if((pSid1 == NULL && pSid2 != NULL) || (pSid2 == NULL && pSid1 != NULL))
    {
        return(FALSE);
    }

    if(pSid1 != NULL)
    {
        if(!RtlEqualSid(pSid1, pSid2))
        {
            return(FALSE);
        }
    }

    //
    // Owner
    //
    pSid1 = RtlpOwnerAddrSecurityDescriptor(pS1);
    pSid2 = RtlpOwnerAddrSecurityDescriptor(pS2);

    if((pSid1 == NULL && pSid2 != NULL) || (pSid2 == NULL && pSid1 != NULL))
    {
        return(FALSE);
    }

    if(pSid1 != NULL)
    {
        if(!RtlEqualSid(pSid1, pSid2))
        {
            return(FALSE);
        }
    }

    acDebugOut((DEB_TRACE, "Nodes 0x%lx and 0x%lx are equal!\n", pSD1, pSD2));
#ifdef DBG
    DebugDumpSD("SD1", pSD1);
    DebugDumpSD("SD2", pSD2);
#endif

    return(TRUE);
}



//+---------------------------------------------------------------------------
//
//  Function:   InsertPropagationFailureEntry
//
//  Synopsis:   Adds a propagation failure entry to the list of items
//              to be written to the event log
//
//  Arguments:  [IN  LogList]           --      Reference to the log list
//              [IN  ErrorCode]         --      Error of propagation
//              [IN  Protected]         --      Flags determining whether the dacl
//                                              or sacl was protected
//              [IN  pwszPath]          --      Path that expierneced the error
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//
//----------------------------------------------------------------------------
DWORD
InsertPropagationFailureEntry( IN  CSList&  LogList,
                               IN  ULONG    ErrorCode,
                               IN  ULONG    Protected,
                               IN  PWSTR    pwszPath)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PACCESS_PROP_LOG_ENTRY pEntry = NULL;

    pEntry = (PACCESS_PROP_LOG_ENTRY)AccAlloc(sizeof(ACCESS_PROP_LOG_ENTRY));
    if(pEntry == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        ACC_ALLOC_AND_COPY_STRINGW(pwszPath, pEntry->pwszPath, dwErr );

        if(pwszPath == NULL)
        {
            AccFree(pEntry);
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            pEntry->Protected = Protected;
            pEntry->Error = ErrorCode;
            dwErr = LogList.Insert(pEntry);

            if(dwErr != ERROR_SUCCESS)
            {
                FreePropagationFailureListEntry(pEntry);
            }
        }
    }
    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   FreePropagationFailureListEntry
//
//  Synopsis:   Frees the propagation failure list
//
//  Arguments:  [IN  LogList]           --      Reference to the log list
//
//  Returns:    VOID
//
//
//----------------------------------------------------------------------------
VOID
FreePropagationFailureListEntry(IN PVOID Entry)
{
    PACCESS_PROP_LOG_ENTRY pLogEntry = (PACCESS_PROP_LOG_ENTRY)Entry;

    AccFree(pLogEntry->pwszPath);
    AccFree(pLogEntry);
}



//+---------------------------------------------------------------------------
//
//  Function:   WritePropagationFailureList
//
//  Synopsis:   Logs the propagation failures to the event log
//
//  Arguments:  [IN  EventType]         --      Type of event to log:
//                                                  registry or filesystem
//              [IN  LogList]           --      Reference to the log list
//              [IN  hToken]            --      Current process/thread token
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WritePropagationFailureList(IN ULONG   EventType,
                            IN CSList& LogList,
                            IN HANDLE  hToken)
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hEventlog = NULL;
    TOKEN_USER *UserInfo;
    ULONG InfoSize, StrCount, i;
    PSID pSid = NULL;
    BYTE Buffer[ 7 * sizeof( ULONG ) + sizeof( TOKEN_USER ) ], *pBuff = NULL;
    WCHAR ErrorNumberBuffer[25];
    WCHAR wszErrorBuffer[ 256];
    PWSTR pwszStringBuffer = NULL, pwszCurrent;
    PACCESS_PROP_LOG_ENTRY pLogEntry;
    ULONG ProtectedValue;

    if(LogList.QueryCount() == 0)
    {
        return(dwErr);
    }

    //
    // Get the user sid
    //
    if(GetTokenInformation(hToken,
                           TokenUser,
                           (PVOID)&Buffer,
                           sizeof(Buffer),
                           &InfoSize ) == FALSE )
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            pBuff = (PBYTE)AccAlloc( InfoSize );

            if(pBuff == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {

                if(GetTokenInformation(hToken,
                                       TokenUser,
                                       (PVOID)pBuff,
                                       InfoSize,
                                       &InfoSize ) == FALSE )
                {
                    dwErr = GetLastError();
                }
                else
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }
    else
    {
        pBuff = Buffer;
    }


    if(dwErr == ERROR_SUCCESS)
    {
        UserInfo = ( PTOKEN_USER )pBuff;
        pSid = UserInfo->User.Sid;
    }

    //
    // Build the list of paths and associated error codes
    // The format of the buffer is [tab][path]   [error][cr/lf]
    //
    if(dwErr == ERROR_SUCCESS)
    {
        InfoSize = 1;

        LogList.Reset();
        pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();
        for(; pLogEntry;)
        {
            InfoSize += 1 + wcslen( pLogEntry->pwszPath ) + 5;

            //
            // Determine the size of the buffer for the error message
            //
            if(pLogEntry->Protected)
            {
                switch(pLogEntry->Protected & (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
                {
                case SE_DACL_PROTECTED | SE_SACL_PROTECTED:
                    ProtectedValue = ACCPROV_MARTA_BOTH_PROTECTED;
                    break;

                case SE_DACL_PROTECTED:
                    ProtectedValue = ACCPROV_MARTA_DACL_PROTECTED;
                    break;

                case SE_SACL_PROTECTED:
                    ProtectedValue = ACCPROV_MARTA_SACL_PROTECTED;
                    break;

                default:
                    ProtectedValue = 0;
                    break;
                }

                if (LoadString(ghDll,
                               ProtectedValue,
                               wszErrorBuffer,
                               sizeof( wszErrorBuffer ) / sizeof( WCHAR )) == 0)
                {
                    dwErr = GetLastError();
                    break;

                }
            }
            else
            {
                if( FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                                   NULL,
                                   pLogEntry->Error,
                                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                   wszErrorBuffer,
                                   256,
                                   NULL ) == 0 )
                {
                    dwErr = GetLastError();
                    break;
                }

            }

            InfoSize += wcslen( wszErrorBuffer );
            pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();
        }

        //
        // Now, allocate the buffer
        //
        if(dwErr == ERROR_SUCCESS)
        {
            pwszStringBuffer = (PWSTR)AccAlloc(( InfoSize + 1 ) * sizeof( WCHAR ));
            if(pwszStringBuffer == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                LogList.Reset();
                pwszCurrent = pwszStringBuffer;
                pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();
                for(; pLogEntry;)
                {
                    if(pLogEntry->Protected == 0 )
                    {
                        FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                                       NULL,
                                       pLogEntry->Error,
                                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                       wszErrorBuffer,
                                       256,
                                       NULL );
                    }
                    else
                    {
                        switch( pLogEntry->Protected & (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
                        {
                        case SE_DACL_PROTECTED | SE_SACL_PROTECTED:
                            ProtectedValue = ACCPROV_MARTA_BOTH_PROTECTED;
                            break;

                        case SE_DACL_PROTECTED:
                            ProtectedValue = ACCPROV_MARTA_DACL_PROTECTED;
                            break;

                        case SE_SACL_PROTECTED:
                            ProtectedValue = ACCPROV_MARTA_SACL_PROTECTED;
                            break;

                        default:
                            ProtectedValue = 0;
                            break;
                        }

                        LoadString(ghDll,
                                   ProtectedValue,
                                   wszErrorBuffer,
                                   sizeof( wszErrorBuffer ) / sizeof( WCHAR ));
                    }
                    InfoSize = swprintf( pwszCurrent,
                           