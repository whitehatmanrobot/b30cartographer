  // CODE_IMPROVMENT: Currently creates a big tracing string. Might be cool
    // save tracing records with all the fields so that the debugger ext.
    // could choose the output formatting on the fly. i.e. print just the
    // level you want, no grep required
    //

    //
    //  Grab the next element in the RAM message buffer.  We use the
    //  mask to define which bits we are using for the counter.  This 
    //  allows us to wrap the counter in one call to InterlockedIncrement.
    //
    idxBuffer = InterlockedIncrement((PLONG)&TRC_CurrentMsg) & TRC_RamMsgMask;

    msgBufEntry = (char *)&TRC_RecentTraces[idxBuffer];
    msgBufEntry[0] = 0;

    processId = (ULONG_PTR)PsGetCurrentProcess();
    //threadId  = (ULONG_PTR)PsGetCurrentThread();
    threadId  = 0;

	 KeQuerySystemTime(&time);
    RtlTimeToTimeFields(&time, &TimeFields);

    //
    //  Add the timestamp.
    //

    _snprintf(tempString, sizeof(tempString), TRC_TIME_FMT "%c", TimeFields.Hour, TimeFields.Minute,
            TimeFields.Second, TimeFields.Milliseconds, separator);
    strncat(msgBufEntry, tempString, TRC_BUFFER_SIZE - strlen(msgBufEntry));
    msgBufEntry[TRC_BUFFER_SIZE - 1] = 0;

    //
    //  Add the process ID and thread ID
    //
    
    _snprintf(tempString, sizeof(tempString), TRC_PROC_FMT ":" TRC_PROC_FMT "%c", processId, 
            threadId, separator);
    strncat(msgBufEntry, tempString, TRC_BUFFER_SIZE - strlen(msgBufEntry));
    msgBufEntry[TRC_BUFFER_SIZE - 1] = 0;

    //
    //  Add the rest.
    //

    _snprintf(tempString, sizeof(tempString),
            TRC_FUNC_FMT "%c" TRC_LINE_FMT "%c%s\n",
            TRC_FUNCNAME_LEN,
            TRC_FUNCNAME_LEN,
            funcName,
            separator,
            lineNumber,
            separator,
            traceString);
    strncat(msgBufEntry, tempString, TRC_BUFFER_SIZE - strlen(msgBufEntry));
    msgBufEntry[TRC_BUFFER_SIZE - 1] = 0;
    msgBufEntry[TRC_BUFFER_SIZE - 2] = '\n';

    //
    //  Now that we have got the trace string, we need to write it out to
    //  the debugger, if so configured.
    //

    if (TRC_WillTrace(traceLevel, fileName, lineNumber)) {
        DbgPrint(msgBufEntry);
    }
}

BOOL TRCPrefixMatch(PCHAR cpnt, PCHAR prefix)
/*++

Routine Description:

    Internal function to compare a component name to a prefix.  
    - assumes both are the same case                            
    - returns                                                   
    - TRUE  if characters up to end of prefix match           
    - FALSE otherwise                                         

Arguments:
    cpnt - filename
    prefix - characters to match


Return Value:

    TRUE if matching, or FALSE

--*/
{
    while ((*cpnt == *prefix) && (*prefix != 0))
    {
        cpnt++;
        prefix++;
    }

    if (*prefix == 0)
    {
        return(TRUE);
    }

    return(FALSE);
}

BOOL TRC_WillTrace(
    IN ULONG traceLevel,
    IN PCHAR fileName,
    IN ULONG line
    )
/*++

Routine Description:

    Return whether tracing is turned on for a particular component.

Arguments:

    traceComponent  -   Component producing this trace.
    traceLevel      -   Trace level (TRC_LEVEL_DBG, TRC_LEVEL_NRM, etc).
    fileName        -   Name of file being traced.
    line            -   Line of tracing call.

Return Value:

    NA

--*/
{
    BOOL rc = FALSE;
    int i;

    //
    //  First of all check the trace level.  If the trace level is error or
    //  above then we trace regardless.                                    
    //

    if ((traceLevel >= TRC_LEVEL_ERR) && (traceLevel != TRC_PROFILE_TRACE)) {
        rc = TRUE;
        goto ExitFunc;
    }

    if (traceLevel < TRC_Config.TraceLevel) {
        rc = FALSE;
        goto ExitFunc;
    }

    /************************************************************************/
    /* Trace all lines if no prefixes are defined.                          */
    /************************************************************************/
    if (TRC_Config.Prefix[0].name[0] == 0)
    {
        rc = TRUE;
        goto ExitFunc;
    }

    /************************************************************************/
    /* Some prefixes are defined - check whether this line matches any of   */
    /* them.                                                                */
    /************************************************************************/
    for (i = 0; i < TRC_MAX_PREFIX; i++)
    {
        if (TRC_Config.Prefix[i].name[0] == 0)
        {
            /****************************************************************/
            /* End of list - break                                          */
            /****************************************************************/
            break;
        }

        if (TRCPrefixMatch(fileName, TRC_Config.Prefix[i].name))
        {
            /****************************************************************/
            /* Found matching filename - is there a line number range       */
            /* specified?                                                   */
            /****************************************************************/
            if ((TRC_Config.Prefix[i].start == 0) &&
                (TRC_Config.Prefix[i].end == 0))
            {
                /************************************************************/
                /* No line number range - trace this line                   */
                /************************************************************/
                rc = TRUE;
                goto ExitFunc;
            }

            /****************************************************************/
            /* There's a line number range - see if this line falls within  */
            /* it.                                                          */
            /****************************************************************/
            if ((line >= TRC_Config.Prefix[i].start) &&
                (line <= TRC_Config.Prefix[i].end))
            {
                /************************************************************/
                /* Line within prefix range - trace it.                     */
                /************************************************************/
                rc = TRUE;
                goto ExitFunc;
            }
        }
    } /* for */

    /************************************************************************/
    /* If we get here, we've searched the list of prefixes and failed to    */
    /* find a match - don't trace the line                                  */
    /************************************************************************/
    rc = FALSE;

ExitFunc:
    return rc;
}

#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\rdr2kd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rx.h"       // NT network file system driver include file
#include "ntddnfs2.h" // new stuff device driver definitions
#include "smbmrx.h"   // smbmini rdr global include file

#include <string.h>
#include <stdio.h>


#include <kdextlib.h>
#include <rdr2kd.h>


VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct);

VOID
MyDprintf(PCSTR, ULONG_PTR);

ULONG
MyCheckControlC(VOID);

ULONG_PTR
MyGetExpression(PCSTR);

/*
 * RDR2 global variables.
 *
 */

LPSTR GlobalBool[]  = {
            "mrxsmb!MRxSmbDeferredOpensEnabled",
            "mrxsmb!MRxSmbOplocksDisabled",
             0};

LPSTR GlobalShort[] = {0};
LPSTR GlobalLong[]  = {
            0};

LPSTR GlobalPtrs[]  = {
            "rdbss!RxExpCXR",
            "rdbss!RxExpEXR",
            "rdbss!RxExpAddr",
            "rdbss!RxExpCode",
            "rdbss!RxActiveContexts",
            "rdbss!RxNetNameTable",
            "rdbss!RxProcessorArchitecture",
            "rdbss!RxBuildNumber",
            "rdbss!RxPrivateBuild",
            "mrxsmb!SmbMmExchangesInUse",
            "mrxsmb!MRxSmbBuildNumber",
            "mrxsmb!MRxSmbPrivateBuild",
            0};


/*
 * IRP_CONTEXT debugging.
 *
 */

FIELD_DESCRIPTOR RxContextFields[] =
   {
      FIELD3(FieldTypeUShort,RX_CONTEXT,NodeTypeCode),
      FIELD3(FieldTypeShort,RX_CONTEXT,NodeByteSize),
      FIELD3(FieldTypeULong,RX_CONTEXT,ReferenceCount),
      FIELD3(FieldTypeULong,RX_CONTEXT,SerialNumber),
      FIELD3(FieldTypeStruct,RX_CONTEXT,WorkQueueItem),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrp),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrpSp),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFcb),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFobx),
      //FIELD3(FieldTypePointer,RX_CONTEXT,pRelevantSrvOpen),
      FIELD3(FieldTypePointer,RX_CONTEXT,LastExecutionThread),
#ifdef RDBSS_TRACKER
      FIELD3(FieldTypePointer,RX_CONTEXT,AcquireReleaseFcbTrackerX),
#endif
      FIELD3(FieldTypePointer,RX_CONTEXT,MRxContext[2]),
      FIELD3(FieldTypeSymbol,RX_CONTEXT,ResumeRoutine),
      FIELD3(FieldTypePointer,RX_CONTEXT,RealDevice),
      FIELD3(FieldTypeULongFlags,RX_CONTEXT,Flags),
      FIELD3(FieldTypeChar,RX_CONTEXT,MajorFunction),
      FIELD3(FieldTypeChar,RX_CONTEXT,MinorFunction),
      FIELD3(FieldTypeULong,RX_CONTEXT,StoredStatus),
      FIELD3(FieldTypeStruct,RX_CONTEXT,SyncEvent),
      FIELD3(FieldTypeStruct,RX_CONTEXT,RxContextSerializationQLinks),
      FIELD3(FieldTypeStruct,RX_CONTEXT,Create),
      FIELD3(FieldTypeStruct,RX_CONTEXT,LowIoContext),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.NetNamePrefixEntry),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvCall),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pNetRoot),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pVNetRoot),
      //FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvOpen),
      0
   };

/*
 * SRV_CALL debugging.
 *
 */

//CODE.IMPROVEMENT we should have a fieldtype for prefixentry that
//                 will print out the names

FIELD_DESCRIPTOR SrvCallFields[] =
   {
      FIELD3(FieldTypeUShort,SRV_CALL,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_CALL,NodeByteSize),
      FIELD3(FieldTypeStruct,SRV_CALL,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,SRV_CALL,PrefixEntry.Prefix),
      FIELD3(FieldTypePointer,SRV_CALL,Context),
      FIELD3(FieldTypePointer,SRV_CALL,Context2),
      FIELD3(FieldTypeULong,SRV_CALL,Flags),
      0
   };

/*
 * NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR NetRootFields[] =
   {
      FIELD3(FieldTypeUShort,NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeStruct,NET_ROOT,FcbTable),
      //FIELD3(FieldTypePointer,NET_ROOT,Dispatch),
      FIELD3(FieldTypePointer,NET_ROOT,Context),
      FIELD3(FieldTypePointer,NET_ROOT,Context2),
      FIELD3(FieldTypePointer,NET_ROOT,SrvCall),
      FIELD3(FieldTypeULong,NET_ROOT,Flags),
      0
   };


/*
 * V_NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR VNetRootFields[] =
   {
      FIELD3(FieldTypeUShort,V_NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,V_NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,V_NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,V_NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,NamePrefix),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context2),
      FIELD3(FieldTypePointer,V_NET_ROOT,NetRoot),
      0
   };


/*
 * FCB debugging.
 *
 */

FIELD_DESCRIPTOR FcbFields[] =
   {
      FIELD3(FieldTypeUShort,FCB,Header.NodeTypeCode),
      FIELD3(FieldTypeShort,FCB,Header.NodeByteSize),
      FIELD3(FieldTypeULong,FCB,NodeReferenceCount),
      FIELD3(FieldTypeULong,FCB,FcbState),
      FIELD3(FieldTypeULong,FCB,OpenCount),
      FIELD3(FieldTypeULong,FCB,UncleanCount),
      FIELD3(FieldTypePointer,FCB,Header.Resource),
      FIELD3(FieldTypePointer,FCB,Header.PagingIoResource),
      FIELD3(FieldTypeStruct,FCB,FcbTableEntry),
      FIELD3(FieldTypeUnicodeString,FCB,PrivateAlreadyPrefixedName),
      FIELD3(FieldTypePointer,FCB,VNetRoot),
      FIELD3(FieldTypePointer,FCB,NetRoot),
      FIELD3(FieldTypePointer,FCB,Context),
      FIELD3(FieldTypePointer,FCB,Context2),
      FIELD3(FieldTypeStruct,FCB,SrvOpenList),
      0
   };

FIELD_DESCRIPTOR FcbTableEntry[]=
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeByteSize),
    FIELD3(FieldTypeULong, RX_FCB_TABLE_ENTRY,HashValue),
    FIELD3(FieldTypeUnicodeString,RX_FCB_TABLE_ENTRY,Path),
    FIELD3(FieldTypeULong,RX_FCB_TABLE_ENTRY,HashLinks),
    FIELD3(FieldTypeLong,RX_FCB_TABLE_ENTRY,Lookups),
    0
   };

FIELD_DESCRIPTOR FcbTable[] =
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeByteSize),
    FIELD3(FieldTypeULong,RX_FCB_TABLE,Version),
    FIELD3(FieldTypeBoolean,RX_FCB_TABLE,CaseInsensitiveMatch),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NumberOfBuckets),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Lookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,FailedLookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Compares),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,TableEntryForNull),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,HashBuckets),
    0
   };

/*
 * SRV_OPEN debugging.
 *
 */

FIELD_DESCRIPTOR SrvOpenFields[] =
   {
      FIELD3(FieldTypeShort,SRV_OPEN,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_OPEN,NodeByteSize),
      FIELD3(FieldTypeULong,SRV_OPEN,NodeReferenceCount),
      FIELD3(FieldTypePointer,SRV_OPEN,Fcb),
      FIELD3(FieldTypeULong,SRV_OPEN,Flags),
      0
   };


/*
 * FOBX debugging.
 *
 */

FIELD_DESCRIPTOR FobxFields[] =
   {
      FIELD3(FieldTypeShort,FOBX,NodeTypeCode),
      FIELD3(FieldTypeShort,FOBX,NodeByteSize),
      FIELD3(FieldTypeULong,FOBX,NodeReferenceCount),
      FIELD3(FieldTypePointer,FOBX,SrvOpen),
      0
   };



#define SMBCE_ENTRY_FIELDS(__TYPE__) \
      FIELD3(FieldTypeULong,__TYPE__,Header.SwizzleCount),    \
      FIELD3(FieldTypeChar,__TYPE__,Header.Flags),    \
      FIELD3(FieldTypeLong,__TYPE__,Header.State),



FIELD_DESCRIPTOR ServerEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SERVER_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,Name),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DomainName),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Sessions),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,NetRoots),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,VNetRootContexts),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pTransport),
        FIELD3(FieldTypeULong,SMBCEDB_SERVER_ENTRY,ServerStatus),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pMidAtlas),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Server),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DfsRootName),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DnsName),
        0
    };

FIELD_DESCRIPTOR SessionEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SESSION_ENTRY)
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypeStruct,SMBCEDB_SESSION_ENTRY,Session),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SESSION_ENTRY,pNetRootName),
        0
    };

FIELD_DESCRIPTOR NetRootEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_NET_ROOT_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_NET_ROOT_ENTRY,Name),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pRdbssNetRoot),
        FIELD3(FieldTypeStruct,SMBCEDB_NET_ROOT_ENTRY,NetRoot),
        FIELD3(FieldTypeBoolean,SMBCEDB_NET_ROOT_ENTRY,NetRoot.DfsAware),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hShare),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hRootDir),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscEnabled),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscShadowable),
        FIELD3(FieldTypeBoolean,SMBCEDB_NET_ROOT_ENTRY,NetRoot.Disconnected),
        0
    };

FIELD_DESCRIPTOR VNetRootContextFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCE_V_NET_ROOT_CONTEXT)
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pRdbssVNetRoot),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pServerEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pSessionEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pNetRootEntry),
        FIELD3(FieldTypeUShort,SMBCE_V_NET_ROOT_CONTEXT,Flags),
        FIELD3(FieldTypeULong,SMBCE_V_NET_ROOT_CONTEXT,TreeId),
        0
    };

FIELD_DESCRIPTOR ServerTransportFields[] =
    {
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pDispatchVector),
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pTransport),
        FIELD3(FieldTypeULong,SMBCE_SERVER_TRANSPORT,MaximumSendSize),
        0
    };

FIELD_DESCRIPTOR TransportFields[] =
    {
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeTransport),
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeAddress),
        FIELD3(FieldTypeULong,SMBCE_TRANSPORT,Priority),
        0
    };

#define EXCHANGE_FIELDS(__TYPE__) \
      FIELD3(FieldTypePointer,__TYPE__,RxContext),  \
      FIELD3(FieldTypePointer,__TYPE__,SmbCeContext.pServerEntry),  \
      FIELD3(FieldTypeULong,__TYPE__,Status),       \
      FIELD3(FieldTypeULong,__TYPE__,SmbStatus),    \
      FIELD3(FieldTypeUShort,__TYPE__,SmbCeState),    \
      FIELD3(FieldTypeULong,__TYPE__,SmbCeFlags),   \
      FIELD3(FieldTypeStruct,__TYPE__,WorkQueueItem),



FIELD_DESCRIPTOR OrdinaryExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_PSE_ORDINARY_EXCHANGE)
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,StufferStateDbgPtr),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,DataPartialMdl),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificFlags),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificState),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ParseResumeState),
      FIELD3(FieldTypeUShortFlags,SMB_PSE_ORDINARY_EXCHANGE,Flags),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,MessageLength),
      FIELD3(FieldTypeSymbol,SMB_PSE_ORDINARY_EXCHANGE,ContinuationRoutine),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,StartEntryCount),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,AsyncResumptionRoutine),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ReadWrite),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,AssociatedStufferState),
      0
   };

FIELD_DESCRIPTOR TransactExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_TRANSACT_EXCHANGE)
      0
   };

typedef struct _ZZEXCHANGE {
    SMB_EXCHANGE;
} ZZEXCHANGE, *PZZEXCHANGE;

FIELD_DESCRIPTOR GeneralExchangeFields[] =
   {
      EXCHANGE_FIELDS(ZZEXCHANGE)
      0
   };


typedef struct _ZZSMB_HEADER {
    union {
        SMB_HEADER;
        NT_SMB_HEADER Nt;
    };
} ZZSMB_HEADER, *PZZSMB_HEADER;

FIELD_DESCRIPTOR SmbHeaderFields[] =
   {
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Command),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,ErrorClass),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Error),
      FIELD3(FieldTypeULongUnaligned,ZZSMB_HEADER,Nt.Status.NtStatus),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Flags),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Flags2),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,PidHigh),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Pid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Tid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Uid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Mid),
      0
   };

FIELD_DESCRIPTOR StufferStateFields[] =
   {
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,SpecificProblem),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,RxContext),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,Exchange),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderPartialMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,ActualBufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferLimit),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,DataMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentPosition),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentWct),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentBcc),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentDataOffset),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,PreviousCommand),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,CurrentCommand),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,FlagsCopy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,Flags2Copy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,DataSize),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,Started),
      0
   };


FIELD_DESCRIPTOR IrpList[] =
   {
      FIELD3(FieldTypePointer,RX_IRP_LIST_ITEM,pIrp),
      FIELD3(FieldTypePointer,RX_IRP_LIST_ITEM,CopyDataBuffer),
      FIELD3(FieldTypeULong,RX_IRP_LIST_ITEM,Completed),
      0
   };

//this enum is used in the definition of the structures that can be dumped....the order here
//is not important, only that there is a definition for each dumpee structure.....

typedef enum _STRUCTURE_IDS {
    StrEnum_RX_CONTEXT = 1,
    StrEnum_FCB,
    StrEnum_SRV_OPEN,
    StrEnum_FOBX,
    StrEnum_SRV_CALL,
    StrEnum_NET_ROOT,
    StrEnum_V_NET_ROOT,
    StrEnum_SMBCEDB_SERVER_ENTRY,
    StrEnum_SMBCEDB_SESSION_ENTRY,
    StrEnum_SMBCEDB_NET_ROOT_ENTRY,
    StrEnum_SMBCE_V_NET_ROOT_CONTEXT,
    StrEnum_SMB_PSE_ORDINARY_EXCHANGE,
    StrEnum_SMB_TRANSACT_EXCHANGE,
    StrEnum_ZZEXCHANGE,
    StrEnum_SMBSTUFFER_BUFFER_STATE,
    StrEnum_SMBCE_TRANSPORT,
    StrEnum_SMBCE_SERVER_TRANSPORT,
    StrEnum_ZZSMB_HEADER,
    StrEnum_RX_FCB_TABLE_ENTRY,
    StrEnum_RX_FCB_TABLE,
    StrEnum_RX_IRP_LIST_ITEM,
    StrEnum_last
};


//
// List of structs currently handled by the debugger extensions
//

STRUCT_DESCRIPTOR Structs[] =
   {
       STRUCT(RX_CONTEXT,RxContextFields,0xffff,RDBSS_NTC_RX_CONTEXT),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0)),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0xf0)),
       STRUCT(SRV_OPEN,SrvOpenFields,0xffff,RDBSS_NTC_SRVOPEN),
       STRUCT(FOBX,FobxFields,0xffff,RDBSS_NTC_FOBX),
       STRUCT(SRV_CALL,SrvCallFields,0xffff,RDBSS_NTC_SRVCALL),
       STRUCT(NET_ROOT,NetRootFields,0xffff,RDBSS_NTC_NETROOT),
       STRUCT(V_NET_ROOT,VNetRootFields,0xffff,RDBSS_NTC_V_NETROOT),
       STRUCT(SMBCEDB_SERVER_ENTRY,ServerEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SERVER)),
       STRUCT(SMBCEDB_SESSION_ENTRY,SessionEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SESSION)),
       STRUCT(SMBCEDB_NET_ROOT_ENTRY,NetRootEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_NETROOT)),
       STRUCT(SMBCE_V_NET_ROOT_CONTEXT,VNetRootContextFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_VNETROOTCONTEXT)),
       STRUCT(SMB_PSE_ORDINARY_EXCHANGE,OrdinaryExchangeFields,0xffff,SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE)),
       STRUCT(SMB_TRANSACT_EXCHANGE,TransactExchangeFields,0xffff,SMB_EXCHANGE_NTC(TRANSACT_EXCHANGE)),
       STRUCT(ZZEXCHANGE,GeneralExchangeFields,0xfff0,SMB_EXCHANGE_NTC(0)),
       STRUCT(SMBSTUFFER_BUFFER_STATE,StufferStateFields,0xffff,SMB_NTC_STUFFERSTATE),
       STRUCT(SMBCE_TRANSPORT,TransportFields,0x0,0xffff),
       STRUCT(SMBCE_SERVER_TRANSPORT,ServerTransportFields,0x0,0xffff),
       STRUCT(ZZSMB_HEADER,SmbHeaderFields,0x0,0xffff),
       STRUCT(RX_FCB_TABLE_ENTRY,FcbTableEntry,0xffff,RDBSS_NTC_FCB_TABLE_ENTRY),
       STRUCT(RX_FCB_TABLE,FcbTable,0xffff,RDBSS_NTC_FCB_TABLE),
       STRUCT(RX_IRP_LIST_ITEM,IrpList,0x0,0xffff),
       0
   };


ULONG_PTR FieldOffsetOfContextListEntryInRxC(){ return FIELD_OFFSET(RX_CONTEXT,ContextListEntry);}


PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture){
    switch (DebugeeArchitecture) {
    case RX_PROCESSOR_ARCHITECTURE_INTEL:
        return L"kdextx86.dll";
    case RX_PROCESSOR_ARCHITECTURE_MIPS:
        return L"kdextmip.dll";
    case RX_PROCESSOR_ARCHITECTURE_ALPHA:
        return L"kdextalp.dll";
    case RX_PROCESSOR_ARCHITECTURE_PPC:
        return L"kdextppc.dll";
    default:
        return(NULL);
    }
}

//CODE.IMPROVEMENT it is poor to try to structure along the lines of "this routine knows
//                 rxstructures" versus "this routine knows debugger extensions". also we
//                 need a precomp.h

BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2)
{
    RX_CONTEXT RxContextBuffer;
    if (!wGetData(RxContext,&RxContextBuffer,sizeof(RxContextBuffer),"RxContextFieldss")) return;
    *pFcb = (ULONG_PTR)(RxContextBuffer.pFcb);
    *pThread = (ULONG_PTR)(RxContextBuffer.LastExecutionThread);
    *pMiniCtx2 = (ULONG_PTR)(RxContextBuffer.MRxContext[2]);
}


FOLLOWON_HELPER_RETURNS
__FollowOnError (
    OUT    PBYTE Buffer2,
    IN     PBYTE followontext,
    ULONG LastId,
    ULONG Index)
{
    if (LastId==0) {
        sprintf(Buffer2,"Cant dump a %s. no previous dump.\n",
                 followontext,Index);
    } else {
        sprintf(Buffer2,"Cant dump a %s from a %s\n",
                 followontext,Structs[Index].StructName);
    }
    return(FOLLOWONHELPER_ERROR);
}
#define FollowOnError(A) (__FollowOnError(Buffer2,A,p->IdOfLastDump,p->IndexOfLastDump))

VOID dprintfsprintfbuffer(BYTE *Buffer);


DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn)
{
    //BYTE DbgBuf[200];
    //sprintf(DbgBuf,"top p,id=%08lx,%d",p,p->IdOfLastDump);
    //dprintfsprintfbuffer(DbgBuf);

    switch (p->IdOfLastDump) {
    case StrEnum_RX_CONTEXT:{
        PRX_CONTEXT RxContext = (PRX_CONTEXT)(&p->StructDumpBuffer[0]);
        sprintf(Buffer2," %08p\n",RxContext->pFcb);
        return(FOLLOWONHELPER_DUMP);
        }
        break;
    default:
        return FollowOnError("irp");
    }
}

VOID
DumpList(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress, STRUCT_DESCRIPTOR *pStruct),
    STRUCT_DESCRIPTOR *pStruct
)
{
    LIST_ENTRY listHead, listNext;

    //
    // Get the value in the LIST_ENTRY at dwAddress
    //

    MyDprintf( "Dumping list @ %08lx\n", dwListEntryAddress );

    if (wGetData(dwListEntryAddress, &listHead, sizeof(LIST_ENTRY),"")) {

        ULONG_PTR dwNextLink = (ULONG_PTR) listHead.Flink;

        if (dwNextLink == 0) {
            MyDprintf( "Uninitialized list!\n", 0 );
        } else if (dwNextLink == dwListEntryAddress) {
            MyDprintf( "Empty list!\n", 0);
        } else {
            while( dwNextLink != dwListEntryAddress) {
                ULONG_PTR dwStructAddress;

                if (MyCheckControlC())
                    return;
                dwStructAddress = dwNextLink - linkOffset;

                dumpRoutine(dwStructAddress, pStruct);

                if (wGetData( dwNextLink, &listNext, sizeof(LIST_ENTRY),"")) {
                    dwNextLink = (ULONG_PTR) listNext.Flink;
                } else {
                    MyDprintf( "Unable to get next item @%08lx\n", dwNextLink );
                    break;
                }

            }
        }

    } else {

        MyDprintf("Unable to read list head @ %08lx\n", dwListEntryAddress);

    }

}

//
// All the DoXXXlist routines could be collapsed into one routine, but I
// have left them separate in case future changes are structure-specific.
//


VOID
DoServerlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCEDB_SERVER_ENTRY", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCEDB_SERVER_ENTRY, ServersList),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoNetRootlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCEDB_NET_ROOT_ENTRY", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCEDB_NET_ROOT_ENTRY, NetRootsList),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoSessionlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCEDB_SESSION_ENTRY", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCEDB_SESSION_ENTRY, SessionsList),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoVNetRootContextlist(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("SMBCE_V_NET_ROOT_CONTEXT", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(SMBCE_V_NET_ROOT_CONTEXT, ListEntry),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoCscFcbsList(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("FCB", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(MRX_SMB_FCB, ShadowReverseTranslationLinks),
        DumpAStruct,
        &Structs[i]);
}

VOID
DoRxIrpsList(ULONG_PTR dwAddress)
{
    ULONG i;
    BOOLEAN fFound = FALSE;

    for (i = 0; Structs[i].StructName != NULL; i++) {
        if (strcmp("RX_IRP_LIST_ITEM", Structs[i].StructName) == 0) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound == FALSE)
        return;

    DumpList(
        dwAddress,
        FIELD_OFFSET(RX_IRP_LIST_ITEM, IrpsList),
        DumpAStruct,
        &Structs[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\strucsup.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdr2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

//need this for unaligned smbget macros
#include <smbgtpt.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
//EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf
#define    PRINTF     dprintf

#define    NL      1
#define    NONL    0

BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
#ifndef RXKD_2col
ULONG s_NoOfColumns = 1;
#else
ULONG s_NoOfColumns = 2;
#endif

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
wPrintStringU( IN LPSTR PrefixMsg OPTIONAL, IN PUNICODE_STRING puStr, IN LPSTR SuffixMsg OPTIONAL )
{
    PWCHAR    StringData;
    UNICODE_STRING UnicodeString;
    ULONG BytesRead;

    if (PrefixMsg == NULL) {
        PrefixMsg = "";
    }
    if (SuffixMsg == NULL) {
        SuffixMsg = "";
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }
    UnicodeString.Buffer =  StringData; //puStr->Buffer;
    UnicodeString.Length =  puStr->Length;
    UnicodeString.MaximumLength =  puStr->MaximumLength;

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        dprintf("%s%wZ%s", PrefixMsg, &UnicodeString, SuffixMsg );
    } else {
        dprintf("MEMORYREAD FAILED %s%s",PrefixMsg,SuffixMsg);
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

VOID
SetFlagString(
    ULONG Value,
    PCHAR FlagString
    )
{
    ULONG i,t,mask;
    *FlagString = '('; FlagString++;
    for (i=t=0,mask=1;i<32;i++,mask<<=1) {
        //PRINTF("hithere %08lx %08lx %08lx\n",Value,mask,i);
        if (i==t+10) {
            *FlagString = ':'; FlagString++;
            t=t+10;
        }
        if (Value&mask) {
            *FlagString = '0'+(UCHAR)(i-t); FlagString++;
        }
    }

    *FlagString = ')'; FlagString++;
    *FlagString = 0;
}

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16X%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongUnaligned:
        case FieldTypeLongUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUlong( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShortUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUshort( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongFlags:{ULONG Value; char FlagString[60];
            Value = *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset );
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUShortFlags:{USHORT Value; char FlagString[60];
            Value = *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUnicodeString:
            wPrintStringU( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NULL );
            PRINTF( NewLine );
            break;
        //case FieldTypeAnsiString:
        //    //PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
        //    //PRINTF( NewLine );
        //    PRINTF( NewLine );
        //    break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numericla value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
            }
            break;
        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
        case FieldTypeFileTime:
        default:
            ERRPRT( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}

DECLARE_API( columns )
{
    ULONG NoOfColumns;
    int   i;

    //SETCALLBACKS();

    //sscanf(lpArgumentString,"%ld",&NoOfColumns);
    sscanf(args,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@"
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PPERSISTENT_RDR2KD_INFO
LocatePersistentInfoFromView()
/*
    the purpose of this routine is to allocate or find the named section that holds the
    data we expect to find across calls. the way that we make this persitent is that we
    do not close the handle used to create the view. it will go away when the process does.
*/
{
    BYTE SectionName[128];
    DWORD SectionSize;
    DWORD ProcessId;
    HANDLE h;
    BOOLEAN CreatedSection = FALSE;
    PPERSISTENT_RDR2KD_INFO p;

    ProcessId = GetCurrentProcessId();
    SectionSize = sizeof(PERSISTENT_RDR2KD_INFO);
    sprintf(SectionName,"Rdr2KdSection_%08lx",ProcessId);
    //PRINTF("sectionname=%s, size=%x\n",SectionName,SectionSize);

    h = OpenFileMappingA(
           FILE_MAP_WRITE, //DWORD  dwDesiredAccess,	// access mode
           FALSE,           //BOOL  bInheritHandle,	// inherit flag
           SectionName     //LPCTSTR  lpName 	// address of name of file-mapping object
           );

    if (h==NULL) {
        h = CreateFileMappingA(
                   (HANDLE)IntToPtr(0xFFFFFFFF), // HANDLE  hFile,	// handle of file to map
                    NULL,              //LPSECURITY_ATTRIBUTES  lpFileMappingAttributes,	// optional security attributes
                    PAGE_READWRITE,    //DWORD  flProtect,	// protection for mapping object
                    0,                 //DWORD  dwMaximumSizeHigh,	// high-order 32 bits of object size
                    SectionSize,       //DWORD  dwMaximumSizeLow,	// low-order 32 bits of object size
                    SectionName        //LPCTSTR  lpName 	// name of file-mapping object
                    );
        if (h==NULL) {
            return(FALSE);
        }
        CreatedSection = TRUE;
    }

    //now we have a filemapping....get a view.....
    p = MapViewOfFile(h,FILE_MAP_WRITE,0,0,0);
    if (p==NULL) {
        CloseHandle(h);
        return(NULL);
    }

    if (CreatedSection) {
        //zero the stuff that needs to be zeroed....
        ULONG i;
        p->IdOfLastDump = 0;
        for (i=0;i<100;i++) {
            p->LastAddressDumped[i] = 0;
        }
        p->OpenCount = 100;
    } else {
        CloseHandle(h);
        p->OpenCount++;
    }

    //PRINTF("Opencount for persistent section = %08lx\n",p->OpenCount);
    return(p);
}

VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    )
{
    UnmapViewOfFile(p);
}

VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct
    )
{
    DWORD Index = (DWORD)(pStruct - Structs);
    DWORD SizeToRead = min(pStruct->StructSize,2048);
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    PRINTF("top @ %lx and %lx for %s(%d,%d)\n",dwAddress,p,pStruct->StructName,Index,p->IdOfLastDump);
    if (!p) {
        PRINTF("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    if ((dwAddress==0) &&(Index<100)) {
        dwAddress = p->LastAddressDumped[Index];
        PRINTF("setting @ %lx and %lx for %s\n",dwAddress,p->LastAddressDumped[Index],pStruct->StructName);
    }

    if (wGetData(dwAddress,&p->StructDumpBuffer[0],SizeToRead,pStruct->StructName)) {

        p->LastAddressDumped[Index] = dwAddress;
        p->IdOfLastDump = pStruct->EnumManifest;
        p->IndexOfLastDump = Index;

        PRINTF("++++++++++++++++ %s(%d/%d)@%lx ---+++++++++++++\n",
            pStruct->StructName,
            p->IdOfLastDump,p->IndexOfLastDump,
            dwAddress);
        PrintStructFields(
            dwAddress,
            &p->StructDumpBuffer[0],
            pStruct->FieldDescriptors);
        PRINTF("---------------- %s@%lx ----------------\n",
            pStruct->StructName,
            dwAddress);
    }

    if (p!= NULL) FreePersistentInfoView(p);
    return;
}


DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                DumpAStruct(dwAddress,&Structs[Index]);
                //if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize,"..structure")) {
                //
                //    PRINTF(
                //        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //    PrintStructFields(
                //        dwAddress,
                //        &DataBuffer,
                //        Structs[Index].FieldDescriptors);
                //    PRINTF(
                //        "---------------- %s@%lx ----------------\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //} else {
                //    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                //}
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
#if 0
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
#endif
            //
            // here we try to figure out what to display based on the context....whoa, nellie!
            //
            USHORT Tag;
            STRUCT_DESCRIPTOR *pStructs = Structs;
            ULONG             NameIndex = INVALID_INDEX;
            BYTE DataBuffer[512];
            //ULONG             ArgumentLength = strlen(lpArgument);
            //BOOLEAN           fAmbigous = FALSE;



            dwAddress = GetExpression( args );
            if (!wGetData(dwAddress,&Tag,sizeof(Tag),"..structure TAG")) return;

            PRINTF("here's the tag: %04lx\n",Tag);

            //look thru the table for matching structs

            while ((pStructs->StructName != 0)) {
                int Result = (Tag&pStructs->MatchMask)==pStructs->MatchValue;

                if (Result != 0) {

                    DumpAStruct(dwAddress,pStructs);
                    break;
                }


                pStructs++;
            }

        }
    } else {
            DisplayStructs();
    }

    return;
}


DECLARE_API( ddd )
{
    dump( hCurrentProcess,
          hCurrentThread,
          dwCurrentPc,
          dwProcessor,
          args
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdr2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?

VOID
DoServerlist(ULONG_PTR);

VOID
DoNetRootlist(ULONG_PTR);

VOID
DoSessionlist(ULONG_PTR);

VOID
DoVNetRootContextlist(ULONG_PTR);

VOID
DoCscFcbsList(ULONG_PTR dwAddress);

VOID
DoRxIrpsList(ULONG_PTR dwAddress);

/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1, "..stringfetch") ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s RDBSS+SMBmini Extension dll for Build %d debugging %s kernel for Build %d\n",
                    kind,
                    VER_PRODUCTBUILD,
                    SavedMajorVersion == 0x0c ? "Checked" : "Free",
                    SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

LPSTR LibCommands[] = {
    "dump <Struct Type Name>@<address expr> ",
    "ddd <address expr> -- dump using context"
    "columns <d> -- controls the number of columns in the display ",
    "lg [<logentries>][@filename] -- dump the log",
    "gv -- dump out important variables",
    "activerx [fcbtomatch]-- dump the list of active contexts",
    "flags <value>-- print which flags are actually set (no text yet)",
    "cxr -- looks up cxr value from memory and does !cxr/!kb",
    "irp,thread,fcb,fobx,srvopen,exchange,stuff,smbbuf -- dumps the named item from the last dumpee",
    "version",
    "serverlist -- dump the list of server entries",
    "netrootlist <address expr> -- dump the netroot entries on a list",
    "sessionlist <address expr> -- dump the session entries on a list",
    "vnetrootcontextlist <address expr> -- dump the vnetroot context entries on a list",
    "cscfcbslist -- dump the csc fcb list",
    "rxirpslist -- dump the irps waiting on transports",
    0
};

DECLARE_API( help )
{
    int i;

    dprintf( "\nRDBSS debugger extensions:\n");

    for( i=0; LibCommands[i]; i++ )
        dprintf( "   %s\n", LibCommands[i] );
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );
DECLARE_API( activerx )
{
    //ULONG dwAddress;
    LIST_ENTRY LEbuffer;
    PLIST_ENTRY pRxActiveContexts,pListEntry;
    ULONG_PTR RxContext,CapturedFcb,LastThread,MinirdrCtx2;
    ULONG_PTR MatchFcb = 0x1badf00d;

    pRxActiveContexts = pListEntry = (PLIST_ENTRY)GetExpression("rdbss!RxActiveContexts");

    if( args && *args ) {
        MatchFcb = GetExpression( args );
    }

    dprintf("\n Firstplentry: %08lx\n", pListEntry);

    for (;;) {
        if (!wGetData((ULONG_PTR)pListEntry,&LEbuffer,sizeof(LEbuffer),"RxActiveContexts")) return;
        if (LEbuffer.Flink == pRxActiveContexts) {
            if (pRxActiveContexts == pListEntry){
                dprintf("Active RxContext List Empty!\n");
            }
            return;
        }
        RxContext = ((ULONG_PTR)LEbuffer.Flink)-FieldOffsetOfContextListEntryInRxC();
        CapturedFcb = LastThread = 0x0badf00d;
        ReadRxContextFields(RxContext,&CapturedFcb,&LastThread,&MinirdrCtx2);
        if (MatchFcb == 0x1badf00d) {
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
        } else if ((MatchFcb == CapturedFcb)
                         || (MatchFcb == LastThread) ) {
            // if a matchfcb is specified and we have a match, the print and dump
            char Bufferqq[100];
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
            sprintf(Bufferqq," %08lx ",RxContext);
            dump( hCurrentProcess,
                  hCurrentThread,
                  dwCurrentPc,
                  dwProcessor,
                  Bufferqq
                  );

        }
        pListEntry = LEbuffer.Flink;
    }
}


#define GV_dprintf(__FORMAT__,__NAME__,__VALUE__) { \
        dprintf( "%s%-30s %08lx " __FORMAT__ "%s",  \
            c&1 ? "    " : "",                      \
            __NAME__,                               \
            dwAddress,                              \
            __VALUE__,                              \
            c&1 ? "\n" : "" );                      \
}
DECLARE_API( gv )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    //CODE.IMPROVEMENT maybe we should hallucinate the moduleprefix instead
    // of having to specify it
    //CODE.IMPROVEMENT if we're not doing that, we shouldn't copy the name!

    //cause stuff to be loaded before we start printing
    dwAddress = GetExpression( "rdbss!RxExpCXR" );
    dwAddress = GetExpression( "mrxsmb!SmbMmExchangesInUse" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[0], GlobalBool[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !wGetData( dwAddress,&b, sizeof(b), "global BOOL") ) continue;

        GV_dprintf("%10s",GlobalBool[i],(b ? " TRUE" : "FALSE"));
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[0], GlobalShort[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !wGetData( dwAddress,&s,sizeof(s), "global SHORT") )  continue;

        GV_dprintf("%10d",GlobalShort[i],s);
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[0], GlobalLong[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global LONG") )  continue;

        GV_dprintf("%10d",GlobalLong[i],l);
    }

    for( i=0; GlobalPtrs[i]; i++, c++ ) {
        LONG l;

        //ERRPRT( "zaaaaa %s\n", GlobalPtrs[i] );
        strcpy( &buf[0], GlobalPtrs[i] );
        dwAddress = GetExpression( buf );
        //ERRPRT( "zbbbbb %s %08lx\n", GlobalPtrs[i], dwAddress );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalPtrs[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global PTR") )  continue;
        //ERRPRT( "zccccc %s %08lx\n", GlobalPtrs[i], dwAddress );

        GV_dprintf("  %08lx",GlobalPtrs[i],l);
    }

    dprintf( "\n" );
}



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}


DECLARE_API( lg )
{
    ULONG_PTR dwAddress;
    BYTE DataBuffer[MAX_RX_LOG_ENTRY_SIZE];
    BYTE AlternateLine[110];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    BOOLEAN LogEntriesSpecified = FALSE;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();
    dwAddress = GetExpression("rdbss!s_RxLog");
    if (!wGetData(dwAddress,&RxLog,sizeof(RX_LOG),"RxLog")) return;


    DumpFile = INVALID_HANDLE_VALUE;
    if( args && *args ) {
        LPSTR lpArgs;
        for (;*args;) {
            if (*args=='@') { break;}
            if ((*args>='0') && (*args<='9')) {
                sscanf(args,"%ld",&LogEntries);
                LogEntriesSpecified = TRUE;
                break;
            }
            args++;
        }
        lpArgs = strpbrk(args, "@");
        if (lpArgs) {
            DumpFile = CreateFileA(lpArgs+1,
                       GENERIC_READ|GENERIC_WRITE,0,
                       NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
            if (DumpFile == INVALID_HANDLE_VALUE){
                ULONG rc = LOWORD(GetLastError());
                dprintf("Error Opening <%s> is %d.",lpArgs+1,rc);
                return;
            }
            if (!LogEntriesSpecified) {
                LogEntries = 99999999; //this will be reset to the right size
            }
        }
    }


    // Dump the log header followed by the log entries ...

    dprintf("s_RxLog.State                    %lx\n",RxLog.State);
    dprintf("s_RxLog.CurrentEntry             %lx\n",RxLog.CurrentEntry);
    dprintf("s_RxLog.BaseEntry                %lx\n",RxLog.BaseEntry);
    dprintf("s_RxLog.EntryLimit               %lx\n",RxLog.EntryLimit);
    dprintf("s_RxLog.LogBufferSizeInEntries   %ld\n",RxLog.LogBufferSizeInEntries);
    dprintf("s_RxLog.NumberOfEntriesIgnored   %ld\n",RxLog.NumberOfEntriesIgnored);
    dprintf("s_RxLog.NumberOfLogWriteAttempts %ld\n",RxLog.NumberOfLogWriteAttempts);
    dprintf("s_RxLog.NumberOfLogWraps         %ld\n",RxLog.NumberOfLogWraps);

    if (LogEntries > RxLog.LogBufferSizeInEntries) {
        LogEntries = RxLog.LogBufferSizeInEntries;
    }
    if (LogEntries < 1) {
        LogEntries = 1;
    }

    CurrentEntry = RxLog.CurrentEntry;
    CurrentEntry -= (LogEntries-1);
    if (CurrentEntry < RxLog.BaseEntry) {
        CurrentEntry += (RxLog.EntryLimit - RxLog.BaseEntry);
    }

    for (;;) {
        ULONG TextPtr;
        BOOLEAN ExtraOrdinaryLogEntry;
        LogEntries--;
        if ( CheckControlC() ) {
            return;
        }
        if (!wGetData((ULONG_PTR)CurrentEntry,&TextPtr,sizeof(TextPtr),"TextPtr")) return;
        if (!wGetData(TextPtr,&DataBuffer[0],sizeof(DataBuffer),"LogEntryBuffer")) return;

        ExtraOrdinaryLogEntry = (DataBuffer[0] == '#')&&(DataBuffer[1] == '>')&&(DataBuffer[3] == 0);

        if (!ExtraOrdinaryLogEntry) {
            //dprintf("-%06d:  %s\n",LogEntries,DataBuffer);
            DumpRoutine(LogEntries,DataBuffer);
        } else {
            ULONG BinaryArgs = DataBuffer[2]-'0';
            PULONG_PTR x = (PULONG_PTR)&DataBuffer[sizeof(ULONG_PTR)];
            char Buffers[12*100]; //CODE.IMPROVEMENT this is poor but effective
            ULONG i;
            ULONG_PTR BinaryStringMask;
            PSZ ffFormat;

            //dprintf("textptr = %08lx, binaryString = %08lx\n", TextPtr, x[0]);
            for (i=1,BinaryStringMask=x[0];i<=BinaryArgs;i++) {
                if (BinaryStringMask & (1<<(i-1))) {
                    //dprintf("Stringing %d\n",i);
                    wGetString(x[i],&Buffers[i*100]); //this could fail!!!!
                    x[i] = ((ULONG_PTR)&Buffers[i*100]);
                    //dprintf("    string is %s\n",x[i]);
                }
            }

            ffFormat = (PSZ)(x[1]);

            switch (BinaryArgs) {
            case 9:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
                break;
            case 8:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8]);
                break;
            case 7:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7]);
                break;
            case 6:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6]);
                break;
            case 5:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5]);
                break;
            case 4:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4]);
                break;
            case 3:
                sprintf(AlternateLine,ffFormat,x[2],x[3]);
                break;
            case 2:
                sprintf(AlternateLine,ffFormat,x[2]);
                break;
            case 1:
                sprintf(AlternateLine,ffFormat);
                break;
            }
            DumpRoutine(LogEntries,AlternateLine);
        }
        if (LogEntries==0) break;
        CurrentEntry++;
        if (CurrentEntry==RxLog.EntryLimit) {
            CurrentEntry = RxLog.BaseEntry;
        }
    }

    if (DumpFile != INVALID_HANDLE_VALUE) {
        CloseHandle(DumpFile);
        DumpFile = INVALID_HANDLE_VALUE;
    }
}


PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);

PWINDBG_EXTENSION_ROUTINE
GetKdExtProcAddress(
    IN PCSTR FuncName
    )
{
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = NULL;
    //dprintf( "yaya\n");
    if (hExtensionMod == NULL) {
        if (DebugeeArchitecture == 0) {
            ULONG_PTR pArchitecture;
            ReloadSymbols(" rdbss.sys");
            pArchitecture = GetExpression("rdbss!RxProcessorArchitecture");
            if (pArchitecture==0) {
                dprintf("couldn't get architecture value...\n");
                return NULL;
            }
            if (!wGetData(pArchitecture,&DebugeeArchitecture,sizeof(DebugeeArchitecture),"RxArch")) return NULL;
            if ((DebugeeArchitecture&0x0fff0000) != 0xabc0000) {
                dprintf("\n Bad DebugeeArchitecture %08lx\n", DebugeeArchitecture);
                return(NULL);
            }
            DebugeeArchitecture &= 0xffff;
        }

        ExtensionLib = GetExtensionLibPerDebugeeArchitecture(DebugeeArchitecture);
        if (ExtensionLib == NULL) {
            dprintf( "bad debuggee arch\n");
            return(NULL);
        }

        hExtensionMod = LoadLibrary( ExtensionLib );
        if (hExtensionMod == NULL) {
            dprintf( "couldn't load %ws\n", ExtensionLib );
            return(NULL);
        }

    }

    WindbgExtRoutine = (PWINDBG_EXTENSION_ROUTINE)GetProcAddress( hExtensionMod, FuncName );
    if (WindbgExtRoutine == NULL) {
        dprintf( "couldn't find %ws%s\n", ExtensionLib, FuncName );
    }
    return WindbgExtRoutine;
}

#define CALL_THRU(NAME,ARGS) { \
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = GetKdExtProcAddress(NAME); \
    if (WindbgExtRoutine != NULL) {                                                   \
        (WindbgExtRoutine)( hCurrentProcess,                                          \
                            hCurrentThread,                                           \
                            dwCurrentPc,                                              \
                            dwProcessor,                                              \
                            ARGS                                                      \
                            );                                                        \
    }                                                                                 \
}

DECLARE_API( testr )
{

    CALL_THRU ( "threadfields", "");
}

DECLARE_API( dump );
VOID
__FollowOnHelper (
     PFOLLOWON_HELPER_ROUTINE Callee,
     HANDLE                 hCurrentProcess,
     HANDLE                 hCurrentThread,
     ULONG                  dwCurrentPc,
     ULONG                  dwProcessor,
     PCSTR                  args
     )
{
    BYTE Name[100], Buffer2[200];
    FOLLOWON_HELPER_RETURNS ret;
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    if (!p) {
        dprintf("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    ret = Callee(p,Name,Buffer2);
    if (p!= NULL) FreePersistentInfoView(p);
    p = NULL;

    switch (ret) {

    case FOLLOWONHELPER_DUMP:
        dump(hCurrentProcess,
             hCurrentThread,
             dwCurrentPc,
             dwProcessor,
             Buffer2
             );
        break;

    case FOLLOWONHELPER_CALLTHRU:
        CALL_THRU ( Name, Buffer2);
        break;

    case FOLLOWONHELPER_ERROR:
        dprintf("%s",Buffer2);
        break;

    case FOLLOWONHELPER_DONE:
        break;
    }

    return;
}
#define FollowOnHelper(a) {            \
    __FollowOnHelper(a,                \
                     hCurrentProcess,  \
                     hCurrentThread,   \
                     dwCurrentPc,      \
                     dwProcessor,      \
                     args);            \
}

DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn);
DECLARE_API( fcb )
{
    FollowOnHelper(FcbFollowOn);
}


DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

DECLARE_API( cxr )
{
    ULONG_PTR dwAddress,cxr;
    BYTE NumBuffer[16];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();


    dwAddress = GetExpression("rdbss!RxExpCXR");
    if (!wGetData(dwAddress,&cxr,sizeof(cxr),"cxr")) return;

    dprintf("\nRxExpCXR=%08lx\n",cxr);
    sprintf(NumBuffer,"%08lx \n",cxr);

    CALL_THRU ( "cxr", NumBuffer);
    if (DebugeeArchitecture==0) {
        CALL_THRU ( "kb", "");
    }

}

DECLARE_API( serverlist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dwAddress = GetExpression("mrxsmb!s_DbServers");
    }
    dprintf("mrxsmb!s_DbServers @ 0x%x\n", dwAddress);
    DoServerlist(dwAddress);
}

DECLARE_API( netrootlist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dprintf("netrootlist <address>\n");
    }
    DoNetRootlist(dwAddress);
}

DECLARE_API( sessionlist )
{
    ULONG_PTR dwAddress = 0;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dprintf("sessionlist <address>\n");
    }
    
    if (dwAddress)
    {
        DoSessionlist(dwAddress);
    }
}

DECLARE_API( vnetrootcontextlist )
{
    ULONG_PTR dwAddress = 0;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dprintf("vnetrootcontextlist <address>\n");
    }
    if (dwAddress)
    {
        DoVNetRootContextlist(dwAddress);
    }
}

DECLARE_API( cscfcbslist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dwAddress = GetExpression("mrxsmb!xCscFcbsList");
    }
    dprintf("mrxsmb!xCscFcbsList @ 0x%x\n", dwAddress);
    DoCscFcbsList(dwAddress);
}

DECLARE_API( rxirpslist )
{
    ULONG_PTR dwAddress;

    if( args && *args ) {
        dwAddress = GetExpression( args );
    } else {
        dwAddress = GetExpression("rdbss!RxIrpsList");
    }
    dprintf("rdbss!RxIrpsList @ 0x%x\n", dwAddress);
    DoRxIrpsList(dwAddress);
}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}

ULONG_PTR
MyGetExpression(PCSTR Expression)
{
    return GetExpression(Expression);
}

ULONG
MyCheckControlC(VOID)
{
    return CheckControlC();
}

VOID
MyDprintf(PSTR s, ULONG_PTR a)
{
    dprintf(s, a);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\util\drrdr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Drrdr.c

Abstract:

    This module implements a minimal app to load and unload,
    the minirdr. Also explicit start/stop control is
    provided

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <..\sys\rdpdr.h>

void DrMrxStart(void);
void DrMrxStop(void);

void DrMrxLoad(void);
void DrMrxUnload(void);
void DrMrxUsage(void);

char* DrMrxDriverName = "RdpDr";


VOID
_CRTAPI1
main(
    int argc,
    char *argv[]
    )

{

    char  command[16];
    BOOL fRun = TRUE;

    DrMrxUsage();

    while (fRun)
    {
        printf("\nCommand:");
        scanf("%s",command);

        switch(command[0]) 
        {
        case 'Q':
        case 'q':
            fRun = FALSE;
            break;

        case 'L':
        case 'l':
            DrMrxLoad();
            break;

        case 'U':
        case 'u':
            DrMrxUnload();
            break;

        case 'S':
        case 's':
            DrMrxStart();
            break;

        case 'T':
        case 't':
            DrMrxStop();
            break;

        case '?':
        default:
            DrMrxUsage();
            break;
        }
    }
}

VOID DrMrxStart()
/*++

Routine Description:

    This routine starts the Dr mini redirector.

Notes:

    The start is distinguished from Load. During this phase the appropriate FSCTL
    is issued.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              DrMrxHandle;

    //
    // Open the Dr Mrx device.
    //
    RtlInitUnicodeString(&DeviceName, RDPDR_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &DrMrxHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = NtFsControlFile(
                     DrMrxHandle,
                     0,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_DR_START,
                     NULL,
                     0,
                     NULL,
                     0
                     );

        NtClose(DrMrxHandle);
    }

    printf("Dr MRx mini redirector start status %lx\n",ntstatus);
}

VOID DrMrxStop()
/*++

Routine Description:

    This routine stops the Dr mini redirector.

Notes:

    The stop is distinguished from unload. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are torn down.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              DrMrxHandle;

    //
    // Open the Dr Mrx device.
    //
    RtlInitUnicodeString(&DeviceName, RDPDR_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &DrMrxHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = NtFsControlFile(
                     DrMrxHandle,
                     0,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_DR_STOP,
                     NULL,
                     0,
                     NULL,
                     0
                     );

        NtClose(DrMrxHandle);
    }

    printf("Dr MRx mini redirector stop status %lx\n",ntstatus);
}

VOID DrMrxLoad()
{
   printf("Loading Dr minirdr.......\n");
   system("net start rdpdr");
}


VOID DrMrxUnload(void)
{
    printf("Unloading Dr minirdr\n");
    system("net stop rdpdr");
}

VOID DrMrxUsage(void){
	printf("\n");
	printf("    Dr Mini-rdr Utility");
    printf("    The following commands are valid \n");
    printf("    L   -> load the Dr minirdr driver\n");
    printf("    U -> unload the Dr minirdr driver\n");
    printf("    S  -> start the Dr minirdr driver\n");
    printf("    T -> stop the Dr minirdr driver\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

//#include <windef.h>

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeULongUnaligned,
    FieldTypeULongFlags,
    FieldTypeLong,
    FieldTypeLongUnaligned,
    FieldTypeUShort,
    FieldTypeUShortUnaligned,
    FieldTypeUShortFlags,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    //USHORT           Offset;      // The offset of the field in the structure
    LONG             Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRIPTOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    ULONG             EnumManifest;
    FIELD_DESCRIPTOR  *FieldDescriptors;
    USHORT            MatchMask;
    USHORT            MatchValue;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors,MatchMask,MatchValue) \
        { #StructTypeName,sizeof(StructTypeName), \
          StrEnum_##StructTypeName,               \
          FieldDescriptors,MatchMask,MatchValue}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\rdr2kd.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _RDR2KD_H_
#define _RDR2KD_H_

typedef enum _FOLLOWON_HELPER_RETURNS {
    FOLLOWONHELPER_CALLTHRU,
    FOLLOWONHELPER_DUMP,
    FOLLOWONHELPER_ERROR,
    FOLLOWONHELPER_DONE
} FOLLOWON_HELPER_RETURNS;

typedef struct _PERSISTENT_RDR2KD_INFO {
    DWORD OpenCount;
    ULONG_PTR LastAddressDumped[100];
    ULONG IdOfLastDump;
    ULONG IndexOfLastDump;
    BYTE StructDumpBuffer[2048];
} PERSISTENT_RDR2KD_INFO, *PPERSISTENT_RDR2KD_INFO;

PPERSISTENT_RDR2KD_INFO LocatePersistentInfoFromView ();
VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    );


typedef
FOLLOWON_HELPER_RETURNS
(NTAPI *PFOLLOWON_HELPER_ROUTINE) (
    IN OUT PPERSISTENT_RDR2KD_INFO p,
    OUT    PBYTE Name,
    OUT    PBYTE Buffer2
    );

#define DECLARE_FOLLOWON_HELPER_CALLEE(s) \
    FOLLOWON_HELPER_RETURNS s (           \
    IN OUT PPERSISTENT_RDR2KD_INFO p,     \
    OUT    PBYTE Name,                    \
    OUT    PBYTE Buffer2       \
    )

#endif // _RDR2KD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\buffring.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.c

Abstract:

    This module defines the implementation for changing buffering states in the RDBSS

Author:

    Balan Sethu Raman (SethuR) 11-Nov-95    Created

Notes:

    The RDBSS provides a mechanism for providing distributed cache coherency in conjunction with
    the various mini redirectors. This service is encapsulated in the BUFFERING_MANAGER which
    processes CHANGE_BUFFERING_STATE_REQUESTS.

    In the SMB protocol OPLOCK's ( Oppurtunistic Locks ) provide the necessary infrastructure for
    cache coherency.

    There are three components in the implementation of cache coherency protocol's in any mini
    redirector.

      1) The first constitutes the modifications to the CREATE/OPEN path. In this path the
      type of buffering to be requested is determined and the appropriate request is made to the
      server. On the return path the buffering state associated with the FCB is updated based
      on the result of the CREATE/OPEN.

      2) The receive indication code needs to modified to handle change buffering state notifications
      from the server. If such a request is detected then the local mechanism to coordinate the
      buffering states needs to be triggered.

      3) The mechanism for changing the buffering state which is implemented as part of the
      RDBSS.

    Any change buffering state request must identify the SRV_OPEN to which the request applies.
    The amount of computational effort involved in identifying the SRV_OPEN depends upon the
    protocol. In the SMB protocol the Server gets to pick the id's used for identifying files
    opened at the server. These are relative to the NET_ROOT(share) on which they are opened.
    Thus every change buffering state request is identified by two keys, the NetRootKey and the
    SrvOpenKey which need to be translated to the appropriate NET_ROOT and SRV_OPEN instance
    respectively. In order to provide better integration with the resource acquisition/release
    mechanism and to avoid duplication of this effort in the various mini redirectors the RDBSS
    provides this service.

    There are two mechanisms provided in the wrapper for indicating buffering state
    changes to SRV_OPEN's. They are

         1) RxIndicateChangeOfBufferingState

         2) RxIndicateChangeOfBufferingStateForSrvOpen.

    The mini rediretors that need an auxillary mechanism for establishing the mapping
    from the id's to the SRV_OPEN instance employ (1) while the mini redirectors that
    do not require this assistance employ (2).

    The buffering manager processes these requests in different stages. It maintains the
    requests received from the various underlying mini redirectors in one of three lists.

    The Dispatcher list contains all the requests for which the appropriate mapping to a
    SRV_OPEN instance has not been established. The Handler list contains all the requests
    for which the appropriate mapping has been established and have not yet been processed.
    The LastChanceHandlerList contains all the requests for which the initial processing was
    unsuccessful.

    This typically happens when the FCB was accquired in a SHARED mode at the time the
    change buffering state request was received. In such cases the Oplock break request
    can only be processed by a delayed worker thread.

    The Change buffering state request processing in the redirector is intertwined with
    the FCB accqusition/release protocol. This helps in ensuring shorter turn around times.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxTearDownBufferingManager)
#pragma alloc_text(PAGE, RxIndicateChangeOfBufferingStateForSrvOpen)
#pragma alloc_text(PAGE, RxPrepareRequestForHandling)
#pragma alloc_text(PAGE, RxPrepareRequestForReuse)
#pragma alloc_text(PAGE, RxpDiscardChangeBufferingStateRequests)
#pragma alloc_text(PAGE, RxProcessFcbChangeBufferingStateRequest)
#pragma alloc_text(PAGE, RxPurgeChangeBufferingStateRequestsForSrvOpen)
#pragma alloc_text(PAGE, RxProcessChangeBufferingStateRequestsForSrvOpen)
#pragma alloc_text(PAGE, RxInitiateSrvOpenKeyAssociation)
#pragma alloc_text(PAGE, RxpLookupSrvOpenForRequestLite)
#pragma alloc_text(PAGE, RxChangeBufferingState)
#pragma alloc_text(PAGE, RxFlushFcbInSystemCache)
#pragma alloc_text(PAGE, RxPurgeFcbInSystemCache)
#endif

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CACHESUP)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_CACHESUP)

//
//  Forward declarations
//

NTSTATUS
RxRegisterChangeBufferingStateRequest (
    PSRV_CALL SrvCall,
    PSRV_OPEN SrvOpen,
    PVOID SrvOpenKey,
    PVOID MRxContext
    );

VOID
RxDispatchChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    );

VOID
RxpDispatchChangeBufferingStateRequests (
    IN OUT PSRV_CALL SrvCall,
    IN OUT PSRV_OPEN SrvOpen,
    OUT PLIST_ENTRY DiscardedRequests
    );

VOID
RxpDiscardChangeBufferingStateRequests (
    IN OUT PLIST_ENTRY DiscardedRequests
    );

VOID
RxLastChanceHandlerForChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    );

NTSTATUS
RxpLookupSrvOpenForRequestLite (
    IN PSRV_CALL SrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxGatherRequestsForSrvOpen (
    IN OUT PSRV_CALL SrvCall,
    IN PSRV_OPEN SrvOpen,
    IN OUT PLIST_ENTRY RequestsListHead
    );

NTSTATUS
RxInitializeBufferingManager (
    PSRV_CALL SrvCall
    )
/*++

Routine Description:

    This routine initializes the buffering manager associated with a SRV_CALL
    instance.

Arguments:

    SrvCall    - the SRV_CALL instance

Return Value:

    STATUS_SUCCESS if successful

Notes:

    The buffering manager consists of three lists .....

        1) the dispatcher list which contains all the requests that need to be
        processed.

        2) the handler list contains all the requests for which the SRV_OPEN
        instance has been found and referenced.

        3) the last chance handler list contains all the requests for which
        an unsuccessful attempt to process the request was made, i.e., the
        FCB could not be acquired exclusively.

    The manipulation of these lists are done under the control of the spin lock
    associated with the buffering manager. A Mutex will not suffice since these
    lists are manipulated at DPC level.

    All buffering manager operations at non DPC level are serialized using the
    Mutex associated with the buffering manager.

--*/
{
    PRX_BUFFERING_MANAGER BufferingManager;

    BufferingManager = &SrvCall->BufferingManager;

    KeInitializeSpinLock( &BufferingManager->SpinLock );

    InitializeListHead( &BufferingManager->HandlerList );
    InitializeListHead( &BufferingManager->LastChanceHandlerList );
    InitializeListHead( &BufferingManager->DispatcherList );

    BufferingManager->HandlerInactive = FALSE;
    BufferingManager->LastChanceHandlerActive = FALSE;
    BufferingManager->DispatcherActive = FALSE;

    BufferingManager->NumberOfOutstandingOpens = 0;

    InitializeListHead( &BufferingManager->SrvOpenLists[0] );
    ExInitializeFastMutex( &BufferingManager->Mutex );

    return STATUS_SUCCESS;
}

NTSTATUS
RxTearDownBufferingManager (
    PSRV_CALL SrvCall
    )
/*++

Routine Description:

    This routine tears down the buffering manager associated with a SRV_CALL
    instance.

Arguments:

    SrvCall    - the SRV_CALL instance

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PAGED_CODE();

    //
    //  Note: All the work items in the buffering manager should not be in use.
    //

    return STATUS_SUCCESS;
}

VOID
RxIndicateChangeOfBufferingState (
    PMRX_SRV_CALL SrvCall,
    PVOID SrvOpenKey,
    PVOID MRxContext
    )
/*++

Routine Description:

    This routine registers an oplock break indication.

Arguments:

    SrvCall    - the SRV_CALL instance

    SrvOpenKey  - the key for the SRV_OPEN instance.

    MRxContext - the context to be passed back to the mini rdr during callbacks for
                  processing the oplock break.

Return Value:

    none.

Notes:

    This is an instance in which the buffering state change request from the
    server identifies the SRV_OPEN instance using the key generated by the server

    This implies that the key needs to be mapped onto the SRV_OPEN instance locally.

--*/
{
    RxRegisterChangeBufferingStateRequest( (PSRV_CALL)SrvCall,
                                           NULL,
                                           SrvOpenKey,
                                           MRxContext );
}


VOID
RxIndicateChangeOfBufferingStateForSrvOpen (
    PMRX_SRV_CALL SrvCall,
    PMRX_SRV_OPEN MRxSrvOpen,
    PVOID SrvOpenKey,
    PVOID MRxContext
    )
/*++

Routine Description:

    This routine registers an oplock break indication. If the necessary preconditions
    are satisfied the oplock is processed further.

Arguments:

    SrvCall    - the SRV_CALL instance

    MRxSrvOpen    - the SRV_OPEN instance.

    MRxContext - the context to be passed back to the mini rdr during callbacks for
                  processing the oplock break.

Return Value:

    none.

Notes:

    This is an instance where in the buffering state change indications from the server
    use the key generated by the client. ( the SRV_OPEN address in itself is the best
    key that can be used ). This implies that no further lookup is required.

    However if this routine is called at DPC level, the indication is processed as if
    the lookup needs to be done.

--*/
{
    PAGED_CODE();

    if (KeGetCurrentIrql() <= APC_LEVEL) {

        PSRV_OPEN SrvOpen = (PSRV_OPEN)MRxSrvOpen;

        //
        //  If the resource for the FCB has already been accquired by this thread
        //  the buffering state change indication can be processed immediately
        //  without further delay.
        //

        if (ExIsResourceAcquiredExclusiveLite( SrvOpen->Fcb->Header.Resource )) {

            RxChangeBufferingState( SrvOpen, MRxContext, TRUE );

        } else {

            RxRegisterChangeBufferingStateRequest( (PSRV_CALL)SrvCall,
                                                   SrvOpen,
                                                   SrvOpen->Key,
                                                   MRxContext );
        }
    } else {

        RxRegisterChangeBufferingStateRequest( (PSRV_CALL)SrvCall,
                                               NULL,
                                               SrvOpenKey,
                                               MRxContext );
    }
}

NTSTATUS
RxRegisterChangeBufferingStateRequest (
    PSRV_CALL SrvCall,
    PSRV_OPEN SrvOpen OPTIONAL,
    PVOID SrvOpenKey,
    PVOID MRxContext
    )
/*++

Routine Description:

    This routine registers a change buffering state requests. If necessary the worker thread
    routines for further processing are activated.

Arguments:

    SrvCall -

    SrvOpen -

    SrvOpenKey -

    MRxContext -


Return Value:

    STATUS_SUCCESS if successful.

Notes:

    This routine registers the change buffering state request by either inserting it in the
    registration list (DPC Level processing ) or the appropriate(dispatcher/handler list).

    This is the common routine for processing both kinds of callbacks, i.e, the ones in
    which the SRV_OPEN instance has been located and the ones in which only the SRV_OPEN
    key is available.

--*/
{
    NTSTATUS Status;

    KIRQL SavedIrql;

    PCHANGE_BUFFERING_STATE_REQUEST Request;
    PRX_BUFFERING_MANAGER BufferingManager = &SrvCall->BufferingManager;

    //
    //  Ensure that either the SRV_OPEN instance for this request has not been
    //  passed in or the call is not at DPC level.
    //

    ASSERT( (SrvOpen == NULL) || (KeGetCurrentIrql() <= APC_LEVEL) );

    Request = RxAllocatePoolWithTag( NonPagedPool, sizeof( CHANGE_BUFFERING_STATE_REQUEST ), RX_BUFFERING_MANAGER_POOLTAG );

    if (Request != NULL) {

        BOOLEAN ActivateHandler = FALSE;
        BOOLEAN ActivateDispatcher = FALSE;

        Request->Flags = 0;

        Request->SrvOpen = SrvOpen;
        Request->SrvOpenKey = SrvOpenKey;
        Request->MRxContext = MRxContext;

        //
        //  If the SRV_OPEN instance for the request is known apriori the request can
        //  be directly inserted into the buffering manager's HandlerList as opposed
        //  to the DispatcherList for those instances in which only the SRV_OPEN key
        //  is available. The insertion into the HandlerList ust be accompanied by an
        //  additional reference to prevent finalization of the instance while a request
        //  is still active.
        //

        if (SrvOpen != NULL) {
            RxReferenceSrvOpen( (PSRV_OPEN)SrvOpen );
        }

        KeAcquireSpinLock( &SrvCall->BufferingManager.SpinLock, &SavedIrql );

        if (Request->SrvOpen != NULL) {

            InsertTailList( &BufferingManager->HandlerList, &Request->ListEntry );

            if (!BufferingManager->HandlerInactive) {

                BufferingManager->HandlerInactive = TRUE;
                ActivateHandler = TRUE;
            }

            RxLog(( "Req %lx SrvOpenKey %lx in Handler List\n", Request, Request->SrvOpen ));
            RxWmiLog( LOG,
                      RxRegisterChangeBufferingStateRequest_1,
                      LOGPTR( Request )
                      LOGPTR( Request->SrvOpen ) );
        } else {

            InsertTailList( &BufferingManager->DispatcherList, &Request->ListEntry );

            if (!BufferingManager->DispatcherActive) {
                BufferingManager->DispatcherActive = TRUE;
                ActivateDispatcher = TRUE;
            }

            RxDbgTrace( 0, Dbg, ("Request %lx SrvOpenKey %lx in Registartion List\n", Request, Request->SrvOpenKey) );
            RxLog(( "Req %lx SrvOpenKey %lx in Reg. List\n", Request, Request->SrvOpenKey ));
            RxWmiLog( LOG,
                      RxRegisterChangeBufferingStateRequest_2,
                      LOGPTR( Request )
                      LOGPTR( Request->SrvOpenKey ) );
        }

        KeReleaseSpinLock( &SrvCall->BufferingManager.SpinLock, SavedIrql );

        InterlockedIncrement( &SrvCall->BufferingManager.CumulativeNumberOfBufferingChangeRequests );

        if (ActivateHandler) {

            //
            //  Reference the SRV_CALL instance to ensure that it will not be
            //  finalized while the worker thread request is in the scheduler
            //

            RxReferenceSrvCallAtDpc( SrvCall );

            RxPostToWorkerThread( RxFileSystemDeviceObject,
                                  HyperCriticalWorkQueue,
                                  &BufferingManager->HandlerWorkItem,
                                  RxProcessChangeBufferingStateRequests,
                                  SrvCall );
        }

        if (ActivateDispatcher) {

            //
            //  Reference the SRV_CALL instance to ensure that it will not be
            //  finalized while the worker thread request is in the scheduler
            //

            RxReferenceSrvCallAtDpc( SrvCall );

            RxPostToWorkerThread( RxFileSystemDeviceObject,
                                  HyperCriticalWorkQueue,
                                  &BufferingManager->DispatcherWorkItem,
                                  RxDispatchChangeBufferingStateRequests,
                                  SrvCall );
        }

        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;

        RxLog(( "!!CBSReq. %lx %lx %lx %lx %lx\n", SrvCall, SrvOpen, SrvOpenKey, MRxContext, Status ));
        RxWmiLogError( Status,
                       LOG,
                       RxRegisterChangeBufferingStateRequest_3,
                       LOGPTR( SrvCall )
                       LOGPTR( SrvOpen )
                       LOGPTR( SrvOpenKey )
                       LOGPTR( MRxContext )
                       LOGULONG( Status ) );
        RxDbgTrace( 0, Dbg, ("Change Buffering State Request Ignored %lx %lx %lx\n", SrvCall,SrvOpen,SrvOpenKey,MRxContext,Status) );
    }

    RxDbgTrace( 0, Dbg, ("Register SrvCall(%lx) SrvOpen (%lx) Key(%lx) Status(%lx)\n", SrvCall, SrvOpen, SrvOpenKey, Status) );

    return Status;
}

NTSTATUS
RxPrepareRequestForHandling (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    )
/*++

Routine Description:

    This routine preprocesses the request before initiating buffering state change
    processing. In addition to obtaining the references on the FCB abd the associated
    SRV_OPEN, an event is allocated as part of the FCB. This helps establish a priority
    mechanism for servicing buffering state change requests.

    The FCB accquisition is a two step process, i.e, wait for this event to be set followed
    by a wait for the resource.

Arguments:

    Request - the buffering state change request

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

Notes:

    Not all the FCB's have the space for the buffering state change event allocated when the
    FCB instance is created. The upside is that space is conserved and the downside is that
    a separate allocation needs to be made when it is required.

    This event associated with the FCB provides a two step mechanism for accelerating the
    processing of buffering state change requests. Ordinary operations get delayed in favour
    of the buffering state change requests. The details are in resrcsup.c

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PKEVENT Event;
    PSRV_OPEN SrvOpen = Request->SrvOpen;

    PAGED_CODE();

    if (!FlagOn( Request->Flags,RX_REQUEST_PREPARED_FOR_HANDLING )) {

        SetFlag( Request->Flags, RX_REQUEST_PREPARED_FOR_HANDLING );

        RxAcquireSerializationMutex();

        Event = SrvOpen->Fcb->pBufferingStateChangeCompletedEvent;

        if (Event == NULL) {

            Event = RxAllocatePoolWithTag( NonPagedPool, sizeof( KEVENT ), RX_BUFFERING_MANAGER_POOLTAG );

            if (Event != NULL) {

                SrvOpen->Fcb->pBufferingStateChangeCompletedEvent = Event;
                KeInitializeEvent( Event, NotificationEvent, FALSE );
            }
        } else {
            KeResetEvent( Event );
        }

        if (Event != NULL) {

            SetFlag( SrvOpen->Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );
            SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING | SRVOPEN_FLAG_COLLAPSING_DISABLED );

            RxDbgTrace( 0,Dbg,("3333 Request %lx SrvOpenKey %lx in Handler List\n",Request,Request->SrvOpenKey) );
            RxLog(( "3333 Req %lx SrvOpenKey %lx in Hndlr List\n",Request,Request->SrvOpenKey ));
            RxWmiLog( LOG,
                      RxPrepareRequestForHandling_1,
                      LOGPTR( Request )
                      LOGPTR( Request->SrvOpenKey ) );
        } else {

            RxDbgTrace( 0, Dbg, ("4444 Ignoring Request %lx SrvOpenKey %lx \n", Request, Request->SrvOpenKey) );
            RxLog(( "Chg. Buf. State Ignored %lx %lx %lx\n", Request->SrvOpenKey, Request->MRxContext, STATUS_INSUFFICIENT_RESOURCES ));
            RxWmiLog( LOG,
                      RxPrepareRequestForHandling_2,
                      LOGPTR( Request->SrvOpenKey )
                      LOGPTR( Request->MRxContext ) );
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        RxReleaseSerializationMutex();
    }

    return Status;
}

VOID
RxPrepareRequestForReuse (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    )
/*++

Routine Description:

    This routine postprocesses the request before destroying it. This involves
    dereferencing and setting the appropriate state flags.

Arguments:

    Request - the buffering state change request

Notes:

--*/
{
    PAGED_CODE();

    if (FlagOn( Request->Flags, RX_REQUEST_PREPARED_FOR_HANDLING )) {

        PFCB Fcb = Request->SrvOpen->Fcb;

        //
        //  We should never clear the SrvOpen flag unless we are also clearing the FCB flag
        //  and setting the event!
        //  ClearFlag(Request->pSrvOpen->Flags,SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING);
        //

        if (RxIsFcbAcquiredExclusive( Fcb )) {
            RxDereferenceSrvOpen( Request->SrvOpen, LHS_ExclusiveLockHeld);
        } else {
            RxDereferenceSrvOpen( Request->SrvOpen, LHS_LockNotHeld );
        }
    } else if (Request->SrvOpen != NULL) {
        RxDereferenceSrvOpen( Request->SrvOpen, LHS_LockNotHeld );
    }

    Request->SrvOpen = NULL;
}

VOID
RxpDiscardChangeBufferingStateRequests (
    PLIST_ENTRY DiscardedRequests
    )
/*++

Routine Description:

    This routine discards a list of change buffering state requests one at a time

Arguments:

    DiscardedRequests - the requests to be discarded

Notes:

--*/
{
    PAGED_CODE();

    //
    //  Process the discarded requests,i.e, free the memory
    //

    while (!IsListEmpty( DiscardedRequests )) {

        PLIST_ENTRY Entry;
        PCHANGE_BUFFERING_STATE_REQUEST Request;

        Entry = RemoveHeadList( DiscardedRequests );

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );

        RxDbgTrace( 0, Dbg, ("**** (2)Discarding Request(%lx) SrvOpenKey(%lx) \n", Request, Request->SrvOpenKey) );
        RxLog(( "**** (2)Disc Req(%lx) SOKey(%lx) \n", Request, Request->SrvOpenKey ));
        RxWmiLog( LOG,
                  RxpDiscardChangeBufferingStateRequests,
                  LOGPTR( Request)
                  LOGPTR( Request->SrvOpenKey ) );

        RxPrepareRequestForReuse( Request );
        RxFreePool( Request );
    }
}

VOID
RxpDispatchChangeBufferingStateRequests (
    PSRV_CALL SrvCall,
    PSRV_OPEN SrvOpen OPTIONAL,
    PLIST_ENTRY DiscardedRequests
    )
/*++

Routine Description:

    This routine dispatches the request before destroying it. This involves looking up
    the SRV_OPEN instance associated with a given SrvOpenKey.

Arguments:

    SrvCall - the associated SRV_CALL instance

    SrvOpen - the associated SRV_OPEN instance.

    DiscardedRequests - Returns back all the requests for which no srvopen could be found
        This will only be used if SrvOpen is null

Notes:

    There are two flavours of this routine. When SrvOpen is NULL this routine walks
    through the list of outstanding requests and establishes the mapping between the
    SrvOpenKey and the SRV_OPEN instance. On the other hand when SrvOpen is a valid
    SRV_OPEN instance it merely traverses the list to gather together the requests
    corresponding to the given SRV_OPEN and transfer them enmasse to to the handler
    list.

    The buffering manager mutex must have been accquired on entry to this routine
    and the mutex ownership will remain invariant on exit.

--*/
{
    NTSTATUS Status;

    KIRQL SavedIrql;

    PLIST_ENTRY Entry;

    LIST_ENTRY DispatcherList;
    LIST_ENTRY HandlerList;

    BOOLEAN ActivateDispatcher;

    PRX_BUFFERING_MANAGER BufferingManager = &SrvCall->BufferingManager;

    PCHANGE_BUFFERING_STATE_REQUEST Request;

    InitializeListHead( DiscardedRequests );
    InitializeListHead( &HandlerList );

    ActivateDispatcher = FALSE;

    //
    //  Since the buffering manager lists are subject to modifications while
    //  the requests on the list are being processed, the requests are transferred
    //  enmasse onto a temporary list. This prevents multiple acquisition/release of
    //  the spinlock for each individual request.
    //

    KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql );

    RxTransferList( &DispatcherList, &BufferingManager->DispatcherList );

    KeReleaseSpinLock( &BufferingManager->SpinLock, SavedIrql );

    //
    //  Process the list of requests.
    //

    Entry = DispatcherList.Flink;
    while (Entry != &DispatcherList) {

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );

        Entry = Entry->Flink;

        if (SrvOpen == NULL) {

            Status = RxpLookupSrvOpenForRequestLite( SrvCall, Request );

        } else {

            if (Request->SrvOpenKey == SrvOpen->Key) {

                Request->SrvOpen = SrvOpen;
                RxReferenceSrvOpen( SrvOpen );
                Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_PENDING;
            }
        }

        //
        //  The result of a lookup for a SRV_OPEN instance can yield
        //  either STATUS_PENDING, STATUS_SUCCESS or STATUS_NOT_FOUND.
        //

        switch (Status) {
        case STATUS_SUCCESS:

            RemoveEntryList( &Request->ListEntry );
            InsertTailList( &HandlerList, &Request->ListEntry);
            break;

        default:
            ASSERT( !"Valid Status Code from RxpLookuSrvOpenForRequestLite" );

        case STATUS_NOT_FOUND:

            RemoveEntryList( &Request->ListEntry );
            InsertTailList( DiscardedRequests, &Request->ListEntry );
            break;

        case STATUS_PENDING:
            break;
        }
    }

    //
    //  Splice back the list of requests that cannot be dispatched onto the
    //  buffering manager's list and prepare for posting to another thread
    //  to resume processing later.
    //

    KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql );

    if (!IsListEmpty( &DispatcherList )) {

        DispatcherList.Flink->Blink = BufferingManager->DispatcherList.Blink;
        BufferingManager->DispatcherList.Blink->Flink = DispatcherList.Flink;

        DispatcherList.Blink->Flink = &BufferingManager->DispatcherList;
        BufferingManager->DispatcherList.Blink = DispatcherList.Blink;

        if (ActivateDispatcher = !BufferingManager->DispatcherActive) {
            BufferingManager->DispatcherActive = ActivateDispatcher;
        }
    }

    if (!IsListEmpty( &HandlerList )) {

        HandlerList.Flink->Blink = BufferingManager->HandlerList.Blink;
        BufferingManager->HandlerList.Blink->Flink = HandlerList.Flink;

        HandlerList.Blink->Flink = &BufferingManager->HandlerList;
        BufferingManager->HandlerList.Blink = HandlerList.Blink;
    }

    KeReleaseSpinLock( &BufferingManager->SpinLock, SavedIrql );

    //
    //  if resumption at a later time is desired because of unprocessed requests
    //  post to a worker thread.
    //

    if (ActivateDispatcher) {

        //
        //  Reference the SRV_CALL to ensure that finalization will not occur
        //  while the worker thread request is in the scheduler.
        //

        RxReferenceSrvCall( SrvCall );

        RxLog(( "***** Activating Dispatcher\n" ));
        RxWmiLog( LOG,
                  RxpDispatchChangeBufferingStateRequests,
                  LOGPTR( SrvCall ) );

        RxPostToWorkerThread( RxFileSystemDeviceObject,
                              HyperCriticalWorkQueue,
                              &BufferingManager->DispatcherWorkItem,
                              RxDispatchChangeBufferingStateRequests,
                              SrvCall );
    }
}

VOID
RxDispatchChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    )
/*++

Routine Description:

    This routine dispatches the request. This involves looking up
    the SRV_OPEN instance associated with a given SrvOpenKey.

Arguments:

    SrvCall - the associated SRV_CALL instance

--*/
{
    KIRQL SavedIrql;

    BOOLEAN ActivateHandler = FALSE;

    LIST_ENTRY DiscardedRequests;

    PRX_BUFFERING_MANAGER BufferingManager;

    RxUndoScavengerFinalizationMarking( SrvCall );

    BufferingManager = &SrvCall->BufferingManager;


    KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql );
    BufferingManager->DispatcherActive = FALSE;
    KeReleaseSpinLock( &BufferingManager->SpinLock,SavedIrql );


    RxAcquireBufferingManagerMutex( BufferingManager );

    RxpDispatchChangeBufferingStateRequests( SrvCall, NULL, &DiscardedRequests );

    RxReleaseBufferingManagerMutex( BufferingManager );

    //
    //  If requests have been transferred from the dispatcher list to the handler
    //  list ensure that the handler is activated.
    //

    KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql );

    if (!IsListEmpty( &BufferingManager->HandlerList ) &&
        (ActivateHandler = !BufferingManager->HandlerInactive)) {
        BufferingManager->HandlerInactive = ActivateHandler;
    }

    KeReleaseSpinLock( &BufferingManager->SpinLock,SavedIrql );

    //
    //  Note that in this case we have a continuation of processing, from the
    //  dispatcher to the handler. The reference that was taken to protect the
    //  dispatcher is transferred to the handling routine. If continuation
    //  is not required the SRV_CALL instance is dereferenced.
    //

    if (ActivateHandler) {
        RxProcessChangeBufferingStateRequests( SrvCall );
    } else {
        RxDereferenceSrvCall( SrvCall, LHS_LockNotHeld );
    }

    //
    //  Discard the requests for which the SRV_OPEN instance cannot be located.
    //  This will cover all the instances for which a buffering change request
    //  and a close crossed on the wire.
    //

    RxpDiscardChangeBufferingStateRequests( &DiscardedRequests );
}

VOID
RxpProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall,
    BOOLEAN UpdateHandlerState
    )
/*++

Routine Description:

    This routine initiates the actual processing of change buffering state requests.

Arguments:

    SrvCall   - the SRV_CALL instance

Return Value:

    none.

Notes:

    The change buffering requests are received for different FCB's. If the attempt
    is made to handle these requests in the order they are received teh average
    response time for completing a change buffering state request can be arbitratily
    high. This is because the FCB needs to be acquired exclusively to complete
    processing the request. In order to avoid this case the buffering manager
    adopts a two pronged strategy -- a first attempt is made to acquire the FCB
    exclusively without waiting. If this attempt fails the requests are transferred
    to a last chance handler list. This combined with the processing of change
    buffering state requests on FCB acquisition/release ensures that most requests
    are processed with a very short turn around time.

--*/
{
    KIRQL SavedIrql;

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY Entry;

    PCHANGE_BUFFERING_STATE_REQUEST Request = NULL;
    PRX_BUFFERING_MANAGER BufferingManager;

    PSRV_OPEN SrvOpen;

    BOOLEAN ActivateHandler;

    RxLog(( "RPCBSR Entry SrvCall(%lx) \n", SrvCall ));
    RxWmiLog( LOG,
              RxpProcessChangeBufferingStateRequests_1,
              LOGPTR( SrvCall ) );

    BufferingManager = &SrvCall->BufferingManager;

    ListEntry = Entry = NULL;

    for (;;) {

        Entry = NULL;
        ActivateHandler = FALSE;

        RxAcquireBufferingManagerMutex( BufferingManager );

        KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql );

        //
        //  Pick a request from the handler list for change buffering state
        //  processing.
        //

        if (!IsListEmpty( &BufferingManager->HandlerList )) {
            Entry = RemoveHeadList( &BufferingManager->HandlerList );
        }

        //
        //  If the FCB for the previously picked request could not be acquired
        //  exclusively without waiting it needs to be transferred to the last
        //  chance handler list and the last chance handler activated if
        //  required.
        //

        if (ListEntry != NULL) {

            //
            //  Insert the entry into the last chance handler list.
            //

            InsertTailList( &BufferingManager->LastChanceHandlerList, ListEntry );

            //
            //  reinitialize for the next pass.
            //

            ListEntry = NULL;

            //
            //  prepare for spinning up the last chance handler.
            //

            if (!BufferingManager->LastChanceHandlerActive &&
                !IsListEmpty( &BufferingManager->LastChanceHandlerList )) {

                BufferingManager->LastChanceHandlerActive = TRUE;
                ActivateHandler = TRUE;
            }
        }

        //
        //  No more requests to be handled. Prepare for wind down.
        //

        if ((Entry == NULL) && UpdateHandlerState) {
            BufferingManager->HandlerInactive = FALSE;
        }

        KeReleaseSpinLock( &BufferingManager->SpinLock,SavedIrql );

        RxReleaseBufferingManagerMutex( BufferingManager );

        //
        //  spin up the last chance handler for processing the requests if required.
        //

        if (ActivateHandler) {

            //
            //  Reference the SRV_CALL instance to ensure that it will not be
            //  finalized while the worker thread request is in the scheduler
            //

            RxReferenceSrvCall( SrvCall );
            RxPostToWorkerThread( RxFileSystemDeviceObject,
                                  DelayedWorkQueue,
                                  &BufferingManager->LastChanceHandlerWorkItem,
                                  RxLastChanceHandlerForChangeBufferingStateRequests,
                                  SrvCall );

            ActivateHandler = FALSE;
        }

        if (Entry == NULL) {
            break;
        }

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );

        RxLog(( "Proc. Req. SrvOpen (%lx) \n", Request->SrvOpen ));
        RxWmiLog( LOG,
                  RxpProcessChangeBufferingStateRequests_2,
                  LOGPTR( Request->SrvOpen ) );

        if (RxPrepareRequestForHandling( Request ) == STATUS_SUCCESS) {

            //
            //  Try to acquire the FCB without waiting. If the FCB is currently unavailable
            //  then it is guaranteed that this request will be processed when the FCB
            //  resource is released.
            //

            ASSERT( Request->SrvOpen != NULL );

            if (RxAcquireExclusiveFcb( CHANGE_BUFFERING_STATE_CONTEXT, Request->SrvOpen->Fcb ) == STATUS_SUCCESS) {

                BOOLEAN FcbFinalized;
                PFCB Fcb;

                RxLog(( "Proc. Req. SrvOpen FCB (%lx) \n",Request->SrvOpen->Fcb ));
                RxWmiLog( LOG,
                          RxpProcessChangeBufferingStateRequests_3,
                          LOGPTR( Request->SrvOpen->Fcb ) );

                SrvOpen = Request->SrvOpen;
                Fcb = SrvOpen->Fcb;

                RxReferenceNetFcb( Fcb );

                if (!FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSED )) {

                    RxDbgTrace( 0, Dbg, ("SrvOpenKey(%lx) being processed(Last Resort)\n", Request->SrvOpenKey) );

                    RxLog(( "SOKey(%lx) processed(Last Resort)\n", Request->SrvOpenKey ));
                    RxWmiLog( LOG,
                              RxpProcessChangeBufferingStateRequests_4,
                              LOGPTR( Request->SrvOpenKey ) );

                    RxChangeBufferingState( SrvOpen, Request->MRxContext, TRUE );
                }

                RxAcquireSerializationMutex();

                ClearFlag( SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING );
                ClearFlag( SrvOpen->Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );
                KeSetEvent( SrvOpen->Fcb->pBufferingStateChangeCompletedEvent, IO_NETWORK_INCREMENT, FALSE );

                RxReleaseSerializationMutex();

                RxPrepareRequestForReuse( Request );

                FcbFinalized = RxDereferenceAndFinalizeNetFcb( Fcb,
                                                            CHANGE_BUFFERING_STATE_CONTEXT_WAIT,
                                                            FALSE,
                                                            FALSE );

                if (!FcbFinalized) {
                    RxReleaseFcb( CHANGE_BUFFERING_STATE_CONTEXT, Fcb );
                }

                RxFreePool( Request );
            } else {

                //
                //  The FCB has been currently accquired. Transfer the change buffering state
                //  request to the last chance handler list. This will ensure that the
                //  change buffering state request is processed in all cases, i.e.,
                //  accquisition of the resource in shared mode as well as the acquistion
                //  of the FCB resource by other components ( cache manager/memory manager )
                //  without going through the wrapper.
                //

                ListEntry = &Request->ListEntry;
            }
        } else {
            RxPrepareRequestForReuse( Request );
            RxFreePool( Request );
        }
    }

    //
    //  Dereference the SRV_CALL instance.
    //

    RxDereferenceSrvCall( SrvCall, LHS_LockNotHeld );

    RxLog(( "RPCBSR Exit SrvCall(%lx)\n", SrvCall ));
    RxWmiLog( LOG,
              RxpProcessChangeBufferingStateRequests_5,
              LOGPTR( SrvCall ) );
}

VOID
RxProcessChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    )
/*++

Routine Description:

    This routine is the last chance handler for processing change buffering state
    requests

Arguments:

    SrvCall -- the SrvCall instance

Notes:

    Since the reference for the srv call instance was accquired at DPC undo
    the scavenger marking if required.

--*/
{
    RxUndoScavengerFinalizationMarking( SrvCall );

    RxpProcessChangeBufferingStateRequests( SrvCall, TRUE );
}

VOID
RxLastChanceHandlerForChangeBufferingStateRequests (
    PSRV_CALL SrvCall
    )
/*++

Routine Description:

    This routine is the last chance handler for processing change buffering state
    requests

Arguments:


Return Value:

    none.

Notes:

    This routine exists because Mm/Cache manager manipulate the header resource
    associated with the FCB directly in some cases. In such cases it is not possible
    to determine whether the release is done through the wrapper. In such cases it
    is important to have a thread actually wait on the FCB resource to be released
    and subsequently process the buffering state request as a last resort mechanism.

    This also handles the case when the FCB is accquired shared. In such cases the
    change buffering state has to be completed in the context of a thread which can
    accquire it exclusively.

    The filtering of the requests must be further optimized by marking the FCB state
    during resource accquisition by the wrapper so that requests do not get downgraded
    easily. ( TO BE IMPLEMENTED )

--*/
{
    KIRQL SavedIrql;

    PLIST_ENTRY Entry;

    LIST_ENTRY FinalizationList;

    PRX_BUFFERING_MANAGER BufferingManager;
    PCHANGE_BUFFERING_STATE_REQUEST Request = NULL;

    PSRV_OPEN SrvOpen;
    BOOLEAN FcbFinalized,FcbAcquired;
    PFCB Fcb;

    RxLog(( "RLCHCBSR Entry SrvCall(%lx)\n", SrvCall ));
    RxWmiLog( LOG,
              RxLastChanceHandlerForChangeBufferingStateRequests_1,
              LOGPTR( SrvCall ) );

    InitializeListHead( &FinalizationList );

    BufferingManager = &SrvCall->BufferingManager;

    for (;;) {

        RxAcquireBufferingManagerMutex( BufferingManager );
        KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql );

        if (!IsListEmpty( &BufferingManager->LastChanceHandlerList )) {
            Entry = RemoveHeadList( &BufferingManager->LastChanceHandlerList );
        } else {
            Entry = NULL;
            BufferingManager->LastChanceHandlerActive = FALSE;
        }

        KeReleaseSpinLock( &BufferingManager->SpinLock, SavedIrql );
        RxReleaseBufferingManagerMutex( BufferingManager );

        if (Entry == NULL) {
            break;
        }

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );

        SrvOpen = Request->SrvOpen;
        Fcb = SrvOpen->Fcb;

        RxReferenceNetFcb( Fcb );

        FcbAcquired = (RxAcquireExclusiveFcb( CHANGE_BUFFERING_STATE_CONTEXT_WAIT, Request->SrvOpen->Fcb) == STATUS_SUCCESS);

        if (FcbAcquired && !FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSED )) {

            RxDbgTrace( 0, Dbg, ("SrvOpenKey(%lx) being processed(Last Resort)\n", Request->SrvOpenKey) );

            RxLog(( "SOKey(%lx) processed(Last Resort)\n", Request->SrvOpenKey ));
            RxWmiLog( LOG,
                      RxLastChanceHandlerForChangeBufferingStateRequests_2,
                      LOGPTR( Request->SrvOpenKey ) );

            RxChangeBufferingState( SrvOpen, Request->MRxContext, TRUE );
        }

        RxAcquireSerializationMutex();
        ClearFlag( SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING );
        ClearFlag( SrvOpen->Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );
        KeSetEvent( SrvOpen->Fcb->pBufferingStateChangeCompletedEvent,IO_NETWORK_INCREMENT, FALSE );
        RxReleaseSerializationMutex();

        InsertTailList( &FinalizationList, Entry );

        if (FcbAcquired) {
            RxReleaseFcb( CHANGE_BUFFERING_STATE_CONTEXT,Fcb );
        }
    }

    while (!IsListEmpty( &FinalizationList )) {

        Entry = RemoveHeadList( &FinalizationList );

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );

        SrvOpen = Request->SrvOpen;
        Fcb = SrvOpen->Fcb;

        FcbAcquired = (RxAcquireExclusiveFcb( CHANGE_BUFFERING_STATE_CONTEXT_WAIT, Request->SrvOpen->Fcb) == STATUS_SUCCESS);

        ASSERT(FcbAcquired == TRUE);

        RxPrepareRequestForReuse( Request );

        FcbFinalized = RxDereferenceAndFinalizeNetFcb( Fcb,
                                                    CHANGE_BUFFERING_STATE_CONTEXT_WAIT,
                                                    FALSE,
                                                    FALSE );

        if (!FcbFinalized && FcbAcquired) {
            RxReleaseFcb( CHANGE_BUFFERING_STATE_CONTEXT, Fcb );
        }

        RxFreePool( Request );
    }

    RxLog(( "RLCHCBSR Exit SrvCall(%lx)\n", SrvCall ));
    RxWmiLog( LOG,
              RxLastChanceHandlerForChangeBufferingStateRequests_3,
              LOGPTR( SrvCall ) );

    //
    //  Dereference the SRV_CALL instance.
    //

    RxDereferenceSrvCall( SrvCall, LHS_LockNotHeld );
}


VOID
RxProcessFcbChangeBufferingStateRequest (
    PFCB Fcb
    )
/*++

Routine Description:

    This routine processes all the outstanding change buffering state request for a
    FCB.

Arguments:

    Fcb - the FCB instance

Return Value:

    none.

Notes:

    The FCB instance must be acquired exclusively on entry to this routine and
    its ownership will remain invariant on exit.

--*/
{
    PSRV_CALL   SrvCall;

    LIST_ENTRY  FcbRequestList;
    PLIST_ENTRY Entry;

    PRX_BUFFERING_MANAGER           BufferingManager;
    PCHANGE_BUFFERING_STATE_REQUEST Request = NULL;

    PAGED_CODE();

    RxLog(( "RPFcbCBSR Entry FCB(%lx)\n", Fcb ));
    RxWmiLog( LOG,
              RxProcessFcbChangeBufferingStateRequest_1,
              LOGPTR( Fcb ) );

    SrvCall = (PSRV_CALL)Fcb->VNetRoot->NetRoot->SrvCall;
    BufferingManager = &SrvCall->BufferingManager;

    InitializeListHead( &FcbRequestList );

    //
    //  Walk through the list of SRV_OPENS associated with this FCB and pick up
    //  the requests that can be dispatched.
    //

    RxAcquireBufferingManagerMutex( BufferingManager );

    Entry = Fcb->SrvOpenList.Flink;
    while (Entry != &Fcb->SrvOpenList) {

        PSRV_OPEN SrvOpen;

        SrvOpen = (PSRV_OPEN) (CONTAINING_RECORD( Entry, SRV_OPEN, SrvOpenQLinks ));
        Entry = Entry->Flink;

        RxGatherRequestsForSrvOpen( SrvCall, SrvOpen, &FcbRequestList );
    }

    RxReleaseBufferingManagerMutex( BufferingManager );

    if (!IsListEmpty( &FcbRequestList )) {

        //
        //  Initiate buffering state change processing.
        //

        Entry = FcbRequestList.Flink;
        while (Entry != &FcbRequestList) {
            NTSTATUS Status = STATUS_SUCCESS;

            Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );

            Entry = Entry->Flink;

            if (RxPrepareRequestForHandling( Request ) == STATUS_SUCCESS) {

                if (!FlagOn( Request->SrvOpen->Flags, SRVOPEN_FLAG_CLOSED )) {

                    RxDbgTrace( 0, Dbg, ("****** SrvOpenKey(%lx) being processed\n", Request->SrvOpenKey) );
                    RxLog(( "****** SOKey(%lx) being processed\n", Request->SrvOpenKey ));
                    RxWmiLog( LOG,
                              RxProcessFcbChangeBufferingStateRequest_2,
                              LOGPTR( Request->SrvOpenKey ) );
                    RxChangeBufferingState( Request->SrvOpen, Request->MRxContext, TRUE );
                } else {

                    RxDbgTrace( 0, Dbg, ("****** 123 SrvOpenKey(%lx) being ignored\n", Request->SrvOpenKey) );
                    RxLog(( "****** 123 SOKey(%lx) ignored\n", Request->SrvOpenKey ));
                    RxWmiLog( LOG,
                              RxProcessFcbChangeBufferingStateRequest_3,
                              LOGPTR( Request->SrvOpenKey ) );
                }
            }
        }

        //
        //  Discard the requests.
        //

        RxpDiscardChangeBufferingStateRequests( &FcbRequestList );
    }

    RxLog(( "RPFcbCBSR Exit FCB(%lx)\n", Fcb ));
    RxWmiLog( LOG,
              RxProcessFcbChangeBufferingStateRequest_4,
              LOGPTR( Fcb ) );

    //
    //  All buffering state change requests have been processed, clear the flag
    //  and signal the event as necessary.
    //

    RxAcquireSerializationMutex();

    //
    //  update the FCB state.
    //

    ClearFlag( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );
    if (Fcb->pBufferingStateChangeCompletedEvent) {
        KeSetEvent( Fcb->pBufferingStateChangeCompletedEvent, IO_NETWORK_INCREMENT, FALSE );
    }

    RxReleaseSerializationMutex();
}

VOID
RxGatherRequestsForSrvOpen (
    IN OUT PSRV_CALL SrvCall,
    IN PSRV_OPEN SrvOpen,
    IN OUT PLIST_ENTRY RequestsListHead
    )
/*++

Routine Description:

    This routine gathers all the change buffering state requests associated with a SRV_OPEN.
    This routine provides the mechanism for gathering all the requests for a SRV_OPEN which
    is then used bu routines which process them

Arguments:

    SrvCall - the SRV_CALL instance

    SrvOpen - the SRV_OPEN instance

    RequestsListHead - the list of requests which is constructed by this routine

Notes:

    On Entry to thir routine the buffering manager Mutex must have been acquired
    and the ownership remains invariant on exit

--*/
{
    PLIST_ENTRY Entry;
    LIST_ENTRY DiscardedRequests;

    PCHANGE_BUFFERING_STATE_REQUEST Request;
    PRX_BUFFERING_MANAGER BufferingManager;

    PVOID SrvOpenKey;

    KIRQL SavedIrql;

    BufferingManager = &SrvCall->BufferingManager;

    SrvOpenKey = SrvOpen->Key;

    //
    //  gather all the requests from the dispatcher list
    //

    RxpDispatchChangeBufferingStateRequests( SrvCall, SrvOpen, &DiscardedRequests );

    //
    //  Since srvopen is non null in above call - we will not get back any discarded
    //  requests
    //

    ASSERTMSG( "Since srvopen is non null we shouldn't discard anything", IsListEmpty( &DiscardedRequests ) );

    KeAcquireSpinLock( &SrvCall->BufferingManager.SpinLock, &SavedIrql );

    //
    //  gather all the requests with the given SrvOpenKey in the handler list
    //

    Entry = BufferingManager->HandlerList.Flink;

    while (Entry != &BufferingManager->HandlerList) {

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );
        Entry = Entry->Flink;

        if ( (Request->SrvOpenKey == SrvOpenKey) && (Request->SrvOpen == SrvOpen) ) {
            RemoveEntryList( &Request->ListEntry );
            InsertHeadList( RequestsListHead, &Request->ListEntry);
        }
    }

    KeReleaseSpinLock( &SrvCall->BufferingManager.SpinLock, SavedIrql );

    //
    //  gather all the requests from the last chance handler list
    //

    Entry = BufferingManager->LastChanceHandlerList.Flink;
    while (Entry != &BufferingManager->LastChanceHandlerList) {

        Request = (PCHANGE_BUFFERING_STATE_REQUEST) CONTAINING_RECORD( Entry, CHANGE_BUFFERING_STATE_REQUEST, ListEntry );
        Entry = Entry->Flink;

        if ( (Request->SrvOpenKey == SrvOpen->Key) && (Request->SrvOpen == SrvOpen) ) {
            RemoveEntryList( &Request->ListEntry );
            InsertHeadList( RequestsListHead, &Request->ListEntry );
        }
    }
}

VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen (
    IN PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    The routine purges all the requests associated with a given SRV_OPEN. This will ensure
    that all buffering state change requests received while the SRV_OPEN was being closed
    will be flushed out.

Arguments:

    SrvOpen - the SRV_OPEN instance

Notes:

--*/
{
    PSRV_CALL SrvCall = (PSRV_CALL)SrvOpen->Fcb->VNetRoot->NetRoot->SrvCall;
    PRX_BUFFERING_MANAGER BufferingManager = &SrvCall->BufferingManager;

    LIST_ENTRY DiscardedRequests;

    PAGED_CODE();

    ASSERT( RxIsFcbAcquiredExclusive( SrvOpen->Fcb ) );

    InitializeListHead( &DiscardedRequests );

    RxAcquireBufferingManagerMutex( BufferingManager );

    RemoveEntryList( &SrvOpen->SrvOpenKeyList );

    InitializeListHead( &SrvOpen->SrvOpenKeyList );
    SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_REQUESTS_PURGED );

    RxGatherRequestsForSrvOpen( SrvCall, SrvOpen, &DiscardedRequests );

    RxReleaseBufferingManagerMutex( BufferingManager );

    if (!IsListEmpty( &DiscardedRequests )) {

        if (BooleanFlagOn( SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING )) {

            RxAcquireSerializationMutex();

            ClearFlag( SrvOpen->Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );

            if (SrvOpen->Fcb->pBufferingStateChangeCompletedEvent != NULL) {

                KeSetEvent( SrvOpen->Fcb->pBufferingStateChangeCompletedEvent, IO_NETWORK_INCREMENT, FALSE );
            }

            RxReleaseSerializationMutex();
        }

        RxpDiscardChangeBufferingStateRequests( &DiscardedRequests );
    }
}

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen (
    PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    The routine processes all the requests associated with a given SRV_OPEN.
    Since this routine is called from a fastio path it tries to defer lock accquistion
    till it is required

Arguments:

    SrvOpen - the SRV_OPEN instance

Notes:

--*/
{
    LONG OldBufferingToken;
    PSRV_CALL SrvCall;
    PFCB Fcb;

    SrvCall = SrvOpen->VNetRoot->NetRoot->SrvCall;
    Fcb = SrvOpen->Fcb;

    //
    //  If change buffering state requests have been received for this srvcall
    //  since the last time the request was processed ensure that we process
    //  all these requests now.
    //

    OldBufferingToken = SrvOpen->BufferingToken;

    if (InterlockedCompareExchange( &SrvOpen->BufferingToken, SrvCall->BufferingManager.CumulativeNumberOfBufferingChangeRequests, SrvCall->BufferingManager.CumulativeNumberOfBufferingChangeRequests) != OldBufferingToken) {

        if (RxAcquireExclusiveFcb( NULL, Fcb ) == STATUS_SUCCESS) {

            RxProcessFcbChangeBufferingStateRequest( Fcb );
            RxReleaseFcb( NULL, Fcb );
        }
    }
}

VOID
RxInitiateSrvOpenKeyAssociation (
    IN OUT PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    This routine prepares a SRV_OPEN instance for SrvOpenKey association.

Arguments:

    SrvOpen - the SRV_OPEN instance

Notes:

    The process of key association is a two phase protocol. In the initialization process
    a sequence number is stowed away in the SRV_OPEN. When the
    RxCompleteSrvOpenKeyAssociation routine is called the sequence number is used to
    update the data structures associated with the SRV_CALL instance. This is required
    because of the asynchronous nature of receiving buffering state change indications
    (oplock breaks in SMB terminology ) before the open is completed.

--*/
{
    KIRQL SavedIrql;

    PSRV_CALL SrvCall = SrvOpen->Fcb->VNetRoot->NetRoot->SrvCall;
    PRX_BUFFERING_MANAGER BufferingManager = &SrvCall->BufferingManager;

    PAGED_CODE();

    SrvOpen->Key = NULL;

    InterlockedIncrement( &BufferingManager->NumberOfOutstandingOpens );
    InitializeListHead( &SrvOpen->SrvOpenKeyList );
}

VOID
RxCompleteSrvOpenKeyAssociation (
    IN OUT PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    The routine associates the given key with the SRV_OPEN instance

Arguments:

    MRxSrvOpen - the SRV_OPEN instance

    SrvOpenKey  - the key to be associated with the instance

Notes:

    This routine in addition to establishing the mapping also ensures that any pending
    buffering state change requests are handled correctly. This ensures that change
    buffering state requests received during the duration of SRV_OPEN construction
    will be handled immediately.

--*/
{
    KIRQL SavedIrql;

    BOOLEAN ActivateHandler = FALSE;

    ULONG Index = 0;

    PSRV_CALL SrvCall = (PSRV_CALL)SrvOpen->Fcb->VNetRoot->NetRoot->SrvCall;
    PRX_BUFFERING_MANAGER BufferingManager = &SrvCall->BufferingManager;

    LIST_ENTRY DiscardedRequests;

    //
    // Associate the SrvOpenKey with the SRV_OPEN instance and also dispatch the
    // associated change buffering state request if any.
    //

    if (SrvOpen->Condition == Condition_Good) {

        InitializeListHead( &DiscardedRequests );

        RxAcquireBufferingManagerMutex( BufferingManager );

        InsertTailList( &BufferingManager->SrvOpenLists[Index], &SrvOpen->SrvOpenKeyList);

        InterlockedDecrement( &BufferingManager->NumberOfOutstandingOpens );

        RxpDispatchChangeBufferingStateRequests( SrvCall,
                                                 SrvOpen,
                                                 &DiscardedRequests);

        RxReleaseBufferingManagerMutex( BufferingManager );

        KeAcquireSpinLock( &BufferingManager->SpinLock, &SavedIrql);

        if (!IsListEmpty( &BufferingManager->HandlerList ) &&
            (ActivateHandler = !BufferingManager->HandlerInactive)) {
            BufferingManager->HandlerInactive = ActivateHandler;
        }

        KeReleaseSpinLock( &BufferingManager->SpinLock, SavedIrql );

        if (ActivateHandler) {

            //
            //  Reference the SRV_CALL instance to ensure that it will not be
            //  finalized while the worker thread request is in the scheduler
            //

            RxReferenceSrvCall( SrvCall );

            RxPostToWorkerThread( RxFileSystemDeviceObject,
                                  HyperCriticalWorkQueue,
                                  &BufferingManager->HandlerWorkItem,
                                  RxProcessChangeBufferingStateRequests,
                                  SrvCall);
        }

        RxpDiscardChangeBufferingStateRequests( &DiscardedRequests );

    } else {

        InterlockedDecrement( &BufferingManager->NumberOfOutstandingOpens );

    }
}

NTSTATUS
RxpLookupSrvOpenForRequestLite (
    IN PSRV_CALL SrvCall,
    IN PCHANGE_BUFFERING_STATE_REQUEST Request
    )
/*++

Routine Description:

    The routine looks up the SRV_OPEN instance associated with a buffering state change
    request.

Arguments:

    SrvCall - the SRV_CALL instance

    Request - the buffering state change request

Return Value:

    STATUS_SUCCESS - the SRV_OPEN instance was found

    STATUS_PENDING - the SRV_OPEN instance was not found but there are open requests
                     outstanding

    STATUS_NOT_FOUND - the SRV_OPEN instance was not found.

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_BUFFERING_MANAGER BufferingManager = &SrvCall->BufferingManager;

    ULONG Index = 0;

    PSRV_OPEN SrvOpen = NULL;
    PLIST_ENTRY ListHead,Entry;

    PAGED_CODE();

    ListHead = &BufferingManager->SrvOpenLists[Index];

    Entry = ListHead->Flink;
    while (Entry != ListHead) {

        SrvOpen = (PSRV_OPEN) CONTAINING_RECORD( Entry, SRV_OPEN, SrvOpenKeyList );

        if ((SrvOpen->Key == Request->SrvOpenKey) &&
            (!FlagOn( SrvOpen->Fcb->FcbState, FCB_STATE_ORPHANED ))) {

            RxReferenceSrvOpen( SrvOpen );
            break;
        }

        Entry = Entry->Flink;
    }

    if (Entry == ListHead) {

        SrvOpen = NULL;

        if (BufferingManager->NumberOfOutstandingOpens == 0) {
            Status = STATUS_NOT_FOUND;
        } else {
            Status = STATUS_PENDING;
        }
    }

    Request->SrvOpen = SrvOpen;

    return Status;
}

#define RxIsFcbOpenedExclusively(FCB) ( ((FCB)->ShareAccess.SharedRead \
                                            + (FCB)->ShareAccess.SharedWrite \
                                            + (FCB)->ShareAccess.SharedDelete) == 0 )


#define LOSING_CAPABILITY(a) ((NewBufferingState&(a))<(OldBufferingState&(a)))

NTSTATUS
RxChangeBufferingState (
    PSRV_OPEN SrvOpen,
    PVOID Context,
    BOOLEAN ComputeNewState
    )
/*++

Routine Description:

    This routine is called to process a buffering state change request.

Arguments:

    SrvOpen - the SrvOpen to be changed;

    Context - the context parameter for mini rdr callback.

    ComputeNewState - determines if the new state is to be computed.

Return Value:

Notes:

    On entry to this routine the FCB must have been accquired exclusive.

    On exit there is no change in resource ownership

--*/
{
    ULONG NewBufferingState, OldBufferingState;
    PFCB Fcb = SrvOpen->Fcb;
    NTSTATUS FlushStatus = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxChangeBufferingState   SrvOpen=%08lx, Context=%08lx\n", SrvOpen, Context) );
    RxLog(( "ChangeBufferState %lx %lx\n", SrvOpen, Context ));
    RxWmiLog( LOG,
              RxChangeBufferingState_1,
              LOGPTR( SrvOpen )
              LOGPTR( Context ) );
    ASSERT( NodeTypeIsFcb( Fcb ) );

    //
    //  this is informational for error recovery
    //

    SetFlag( Fcb->FcbState, FCB_STATE_BUFFERSTATE_CHANGING );

    try {

        if (ComputeNewState) {

            NTSTATUS Status;

            RxDbgTrace( 0, Dbg, ("RxChangeBufferingState FCB(%lx) Compute New State\n", Fcb ));

            //
            //  Compute the new buffering state with the help of the mini redirector
            //

            MINIRDR_CALL_THROUGH( Status,
                                  Fcb->MRxDispatch,
                                  MRxComputeNewBufferingState,
                                  ((PMRX_SRV_OPEN)SrvOpen,
                                  Context,
                                  &NewBufferingState ));

            if (Status != STATUS_SUCCESS) {
                NewBufferingState = 0;
            }
        } else {
            NewBufferingState = SrvOpen->BufferingFlags;
        }

        if (RxIsFcbOpenedExclusively( Fcb ) && !ComputeNewState) {

            SetFlag( NewBufferingState, (FCB_STATE_WRITECACHING_ENABLED |
                                         FCB_STATE_FILESIZECACHEING_ENABLED |
                                         FCB_STATE_FILETIMECACHEING_ENABLED |
                                         FCB_STATE_WRITEBUFFERING_ENABLED |
                                         FCB_STATE_LOCK_BUFFERING_ENABLED |
                                         FCB_STATE_READBUFFERING_ENABLED |
                                         FCB_STATE_READCACHING_ENABLED) );
        }

        if (Fcb->OutstandingLockOperationsCount != 0) {
            ClearFlag( NewBufferingState, FCB_STATE_LOCK_BUFFERING_ENABLED );
        }

        //
        //  support for disabling local buffering independent of open mode/oplock/....
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_DISABLE_LOCAL_BUFFERING )) {
            NewBufferingState = 0;
        }

        OldBufferingState = FlagOn( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_MASK );

        RxDbgTrace( 0, Dbg, ("-->   OldBS=%08lx, NewBS=%08lx, SrvOBS = %08lx\n",
                             OldBufferingState, NewBufferingState, SrvOpen->BufferingFlags ));
        RxLog( ("CBS-2 %lx %lx %lx\n", OldBufferingState, NewBufferingState, SrvOpen->BufferingFlags) );
        RxWmiLog( LOG,
                  RxChangeBufferingState_2,
                  LOGULONG( OldBufferingState )
                  LOGULONG( NewBufferingState )
                  LOGULONG( SrvOpen->BufferingFlags ) );

        RxDbgTrace( 0, Dbg, ("RxChangeBufferingState FCB(%lx) Old (%lx)  New (%lx)\n", Fcb, OldBufferingState, NewBufferingState) );

        if (LOSING_CAPABILITY( FCB_STATE_WRITECACHING_ENABLED )) {

            RxDbgTrace( 0, Dbg, ("-->flush\n", 0 ) );
            RxLog(( "CBS-Flush" ));
            RxWmiLog( LOG,
                      RxChangeBufferingState_3,
                      LOGPTR( Fcb ) );

            FlushStatus = RxFlushFcbInSystemCache( Fcb, TRUE );
        }

        //
        //  If there are no handles to this file or it the read caching capability
        //  is lost the file needs to be purged. This will force the memory
        //  manager to relinquish the additional reference on the file.
        //

        if ((Fcb->UncleanCount == 0) ||
            LOSING_CAPABILITY( FCB_STATE_READCACHING_ENABLED ) ||
            FlagOn( NewBufferingState, MINIRDR_BUFSTATE_COMMAND_FORCEPURGE )) {

            RxDbgTrace( 0, Dbg, ("-->purge\n", 0 ));
            RxLog(( "CBS-purge\n" ));
            RxWmiLog( LOG,
                      RxChangeBufferingState_4,
                      LOGPTR( Fcb ));

            if (!NT_SUCCESS( FlushStatus )) {

                RxCcLogError( (PDEVICE_OBJECT)Fcb->RxDeviceObject,
                              &Fcb->PrivateAlreadyPrefixedName,
                              IO_LOST_DELAYED_WRITE,
                              FlushStatus,
                              IRP_MJ_WRITE,
                              Fcb );
            }

            CcPurgeCacheSection( &Fcb->NonPaged->SectionObjectPointers,
                                 NULL,
                                 0,
                                 FALSE );
        }

        //
        //  the wrapper does not use these flags yet
        //

        if (LOSING_CAPABILITY( FCB_STATE_WRITEBUFFERING_ENABLED )) NOTHING;
        if (LOSING_CAPABILITY( FCB_STATE_READBUFFERING_ENABLED )) NOTHING;
        if (LOSING_CAPABILITY( FCB_STATE_OPENSHARING_ENABLED )) NOTHING;
        if (LOSING_CAPABILITY( FCB_STATE_COLLAPSING_ENABLED )) NOTHING;
        if (LOSING_CAPABILITY( FCB_STATE_FILESIZECACHEING_ENABLED )) NOTHING;
        if (LOSING_CAPABILITY( FCB_STATE_FILETIMECACHEING_ENABLED )) NOTHING;

        if (ComputeNewState &&
            FlagOn(SrvOpen->Flags, SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING ) &&
            !IsListEmpty( &SrvOpen->FobxList )) {

            NTSTATUS Status;
            PRX_CONTEXT RxContext = NULL;

            RxContext = RxCreateRxContext( NULL,
                                           SrvOpen->Fcb->RxDeviceObject,
                                           RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING );

            if (RxContext != NULL) {

                RxContext->pFcb = (PMRX_FCB)Fcb;
                RxContext->pFobx = (PMRX_FOBX) (CONTAINING_RECORD( SrvOpen->FobxList.Flink, FOBX, FobxQLinks ));
                RxContext->pRelevantSrvOpen = RxContext->pFobx->pSrvOpen;

                if (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSE_DELAYED )) {

                    RxLog(( "  ##### Oplock brk close %lx\n", RxContext->pFobx ));
                    RxWmiLog( LOG,
                              RxChangeBufferingState_4,
                              LOGPTR( RxContext->pFobx ) );
                    Status = RxCloseAssociatedSrvOpen( RxContext,
                                                       (PFOBX)RxContext->pFobx );

                } else {

                    MINIRDR_CALL_THROUGH( Status,
                                          Fcb->MRxDispatch,
                                          MRxCompleteBufferingStateChangeRequest,
                                          (RxContext,(PMRX_SRV_OPEN)SrvOpen,Context) );
                }


                RxDereferenceAndDeleteRxContext( RxContext );
            }

            RxDbgTrace( 0, Dbg, ("RxChangeBuffering State FCB(%lx) Completeing buffering state change\n", Fcb) );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_MASK );
        SetFlag( Fcb->FcbState, FlagOn( NewBufferingState, FCB_STATE_BUFFERING_STATE_MASK ) );

    } finally {

        //
        //  this is informational for error recovery
        //

        ClearFlag( Fcb->FcbState, FCB_STATE_BUFFERSTATE_CHANGING );
        ClearFlag( Fcb->FcbState, FCB_STATE_TIME_AND_SIZE_ALREADY_SET );
    }

    RxDbgTrace( -1, Dbg, ("-->exit\n") );
    RxLog(( "Exit-CBS\n" ));
    RxWmiLog( LOG,
              RxChangeBufferingState_5,
              LOGPTR( Fcb ) );
    return STATUS_SUCCESS;
}


NTSTATUS
RxFlushFcbInSystemCache (
    IN PFCB Fcb,
    IN BOOLEAN SynchronizeWithLazyWriter
    )

/*++

Routine Description:

    This routine simply flushes the data section on a file.
    Then, it does an acquire-release on the pagingIO resource in order to
    synchronize behind any other outstanding writes if such synchronization is
    desired by the caller

Arguments:

    Fcb - Supplies the file being flushed

    SynchronizeWithLazyWriter  -- set to TRUE if the flush needs to be
                                  synchronous

Return Value:

    NTSTATUS - The Status from the flush.

--*/
{
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    //
    //  Make sure that this thread owns the FCB.
    //  This assert is not valid because the flushing of the cache can be called from a routine
    //  that was posted to a worker thread.  Thus the FCB is acquired exclusively, but not by the
    //  current thread and this will fail.
    //  ASSERT  ( RxIsFcbAcquiredExclusive ( Fcb )  );
    //

    CcFlushCache( &Fcb->NonPaged->SectionObjectPointers,
                  NULL,
                  0,
                  &Iosb ); //  ok4flush

    if (SynchronizeWithLazyWriter &&
        NT_SUCCESS( Iosb.Status )) {

        RxAcquirePagingIoResource( NULL, Fcb );
        RxReleasePagingIoResource( NULL, Fcb );
    }

    RxLog(( "Flushing %lx Status %lx\n", Fcb, Iosb.Status ));
    RxWmiLogError( Iosb.Status,
                   LOG,
                   RxFlushFcbInSystemCache,
                   LOGPTR( Fcb )
                   LOGULONG( Iosb.Status ) );

    return Iosb.Status;
}

NTSTATUS
RxPurgeFcbInSystemCache(
    IN PFCB Fcb,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UninitializeCacheMaps,
    IN BOOLEAN FlushFile )

/*++

Routine Description:

    This routine purges the data section on a file. Before purging it flushes
    the file and ensures that there are no outstanding writes by
    Then, it does an acquire-release on the pagingIO resource in order to
    synchronize behind any other outstanding writes if such synchronization is
    desired by the caller

Arguments:

    Fcb - Supplies the file being flushed

    SynchronizeWithLazyWriter  -- set to TRUE if the flush needs to be
                                  synchronous

Return Value:

    NTSTATUS - The Status from the flush.

--*/
{
    BOOLEAN Result;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    //
    //  Make sure that this thread owns the FCB.
    //

    ASSERT( RxIsFcbAcquiredExclusive ( Fcb )  );

    //
    //  Flush if we need to
    //

    if (FlushFile) {

        Status = RxFlushFcbInSystemCache( Fcb, TRUE );

        if (!NT_SUCCESS( Status )) {

            PVOID p1, p2;
            RtlGetCallersAddress( &p1, &p2 );
            RxLogRetail(( "Flush failed %x %x, Purging anyway\n", Fcb, Status ));
            RxLogRetail(( "Purge Caller = %x %x\n", p1, p2 ));

            RxCcLogError( (PDEVICE_OBJECT)Fcb->RxDeviceObject,
                          &Fcb->PrivateAlreadyPrefixedName,
                          IO_LOST_DELAYED_WRITE,
                          Status,
                          IRP_MJ_WRITE,
                          Fcb );
        }
    }

    Result = CcPurgeCacheSection( &Fcb->NonPaged->SectionObjectPointers,
                                  FileOffset,
                                  Length,
                                  UninitializeCacheMaps );

    if (!Result) {

        MmFlushImageSection( &Fcb->NonPaged->SectionObjectPointers, MmFlushForWrite );
        RxReleaseFcb( NULL, Fcb );

        Result = MmForceSectionClosed( &Fcb->NonPaged->SectionObjectPointers, TRUE );

        RxAcquireExclusiveFcb( NULL, Fcb );
    }

    if (Result) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    RxLog(( "Purging %lx Status %lx\n", Fcb, Status ));
    RxWmiLogError( Status,
                   LOG,
                   RxPurgeFcbInSystemCache,
                   LOGPTR( Fcb )
                   LOGULONG( Status ) );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\calldown.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    calldown.c

Abstract:

    This module implements the calldown routines for coordinating between multiple
    calldowns/callouts.

    Calldowns refer to invocation of a mini rdr routine by the wrapper while callouts
    refer to invocations made by the wrapper to other components, e.g., TDI.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

    There are a number of instances in which the same function needs to be invoked
    on all the mini redirectors that have been registered. The RDBSS needs to be
    synchronized with the completion of the invocation of all these calls. It
    will be beneficial to invoke these calls in parallel when more than one
    mini redirectors are registered. This module provides the framework for such
    calldowns. This is provided by the routine RxCalldownMiniRedirectors.

    An instance of coordination between multiple callouts occurs when a connect
    request is initiated across multiple instances in parallel. The data structures
    corresponding to this are defined in rxcep.h for now since the usage is restricted
    to the connection engine. It would be a suitable candidate for migration if more uses
    are found later.

--*/

#include "precomp.h"
#pragma  hdrstop

#include "mrx.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeMRxCalldownContext)
#pragma alloc_text(PAGE, RxCompleteMRxCalldownRoutine)
#pragma alloc_text(PAGE, RxCalldownMRxWorkerRoutine)
#pragma alloc_text(PAGE, RxCalldownMiniRedirectors)
#endif

VOID
RxInitializeMRxCalldownContext(
   PMRX_CALLDOWN_CONTEXT    pContext,
   PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
   PMRX_CALLDOWN_ROUTINE pRoutine,
   PVOID                    pParameter)
/*++

Routine Description:

    This routine initializes a mini redirector calldown context.

Arguments:

    pContext - the MRx calldown context

Notes:

--*/
{
   PAGED_CODE();

   pContext->pMRxDeviceObject   = pMRxDeviceObject;
   pContext->pRoutine           = pRoutine;
   pContext->pParameter         = pParameter;
   pContext->pCompletionContext = NULL;
}

VOID
RxCompleteMRxCalldownRoutine(
   PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext)
/*++

Routine Description:

    This routine constitutes the tail of a mini redirector calldown completion.
    It encapsulates the synchronization mechanism for the resumption of RDBSS

Arguments:

    pCompletionContext - the MRx calldown completion context

Notes:

--*/
{
   PAGED_CODE();

   if (pCompletionContext != NULL) {
      LONG WaitCount;

      WaitCount = InterlockedDecrement(&pCompletionContext->WaitCount);
      if (WaitCount == 0) {
         KeSetEvent(
            &pCompletionContext->Event,
            IO_NO_INCREMENT,
            FALSE);
      }
   }
}

VOID
RxCalldownMRxWorkerRoutine(
   PMRX_CALLDOWN_CONTEXT pContext)
/*++

Routine Description:

    This is the calldown worker routine that invokes the appropriate mini
    redirector routine and follows it up with a call to the completion routine.

Arguments:

    pContext - the MRx calldown context

Notes:

--*/
{
    PRDBSS_DEVICE_OBJECT pMRxDeviceObject = pContext->pMRxDeviceObject;

    PAGED_CODE();

    if ( pContext->pRoutine != NULL) {
        pContext->CompletionStatus = (pContext->pRoutine)(pContext->pParameter);
    }

    RxCompleteMRxCalldownRoutine(pContext->pCompletionContext);
}

NTSTATUS
RxCalldownMiniRedirectors(
   LONG                  NumberOfMiniRdrs,
   PMRX_CALLDOWN_CONTEXT pCalldownContext,
   BOOLEAN               PostCalldowns)
/*++

Routine Description:

    This routine encapsulates the multiple mini redirector calldown.

Arguments:

    NumberOfMiniRdrs  - the number of mini redirectors

    pCalldownContext  - the MRx calldown context array for the mini redirectors

    PostCalldowns     - if TRUE the calldown employs multiple threads

Notes:

    The three parameters for this routine constitute an effort to provide
    maximum flexibility. The values should be carefully specified for
    utmost efficiency.

    Since the different calldowns can choose to employ a subset of the
    mini redirectors registered at any time the calldown mechanism accepts an
    array of calldown contexts and the appropriate number.

    In most cases when there is only one mini redirector registered it is
    necessary that the context switches be minimized. The routine provides
    for this by having an explicit specification (PostCalldowns ) parameter.

--*/
{
   LONG     Index;
   PMRX_CALLDOWN_CONTEXT pContext;

   MRX_CALLDOWN_COMPLETION_CONTEXT CompletionContext;

   PAGED_CODE();

   if (NumberOfMiniRdrs == 0) {
      return STATUS_SUCCESS;
   }

   pContext = pCalldownContext;

   CompletionContext.WaitCount = NumberOfMiniRdrs;
   KeInitializeEvent(
         &CompletionContext.Event,
         NotificationEvent,
         FALSE);

   for (Index = 0,pContext = pCalldownContext;
        Index < NumberOfMiniRdrs;
        Index++,pContext++) {
      pContext->pCompletionContext = &CompletionContext;
   }

   if (PostCalldowns) {
      for (Index = 0, pContext = pCalldownContext;
           Index < NumberOfMiniRdrs;
           Index++,pContext++) {
         RxPostToWorkerThread(
               RxFileSystemDeviceObject,
               CriticalWorkQueue,
               &pContext->WorkQueueItem,
               RxCalldownMRxWorkerRoutine,
               pContext);
      }
   } else {
      for (Index = 0, pContext = pCalldownContext;
           Index < NumberOfMiniRdrs;
           Index++,pContext++) {
         RxCalldownMRxWorkerRoutine(&pCalldownContext[Index]);
      }
   }

   KeWaitForSingleObject(
      &CompletionContext.Event,
      Executive,
      KernelMode,
      FALSE,
      NULL);

   return STATUS_SUCCESS;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\midatlsp.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the private data structures used in mapping MIDS
    to the corresponding requests/contexts associated with them. it's
    separated from the .c portion so the debugger extension can see it.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/


#ifndef _MIDATLAS_PRIVATE_H_
#define _MIDATLAS_PRIVATE_H_

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;

#endif //_MIDATLAX_PRIVATE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\fcbstruc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FcbStruc.c

Abstract:

    This module implements functions for to create and dereference fcbs
    and all of the surrounding paraphenalia. Please read the abstract in
    fcb.h. Please see the note about what locks to need to call what.
    There are asserts to enforce these conventions.


Author:

    Joe Linn (JoeLinn)    8-8-94

Revision History:

    Balan Sethu Raman --

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#ifdef RDBSSLOG
#include <stdio.h>
#endif
#include <dfsfsctl.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDereference)
#pragma alloc_text(PAGE, RxReference)
#pragma alloc_text(PAGE, RxpReferenceNetFcb)
#pragma alloc_text(PAGE, RxpDereferenceNetFcb)
#pragma alloc_text(PAGE, RxpDereferenceAndFinalizeNetFcb)
#pragma alloc_text(PAGE, RxWaitForStableCondition)
#pragma alloc_text(PAGE, RxUpdateCondition)
#pragma alloc_text(PAGE, RxAllocateObject)
#pragma alloc_text(PAGE, RxFreeObject)
#pragma alloc_text(PAGE, RxFinalizeNetTable)
#pragma alloc_text(PAGE, RxFinalizeConnection)
#pragma alloc_text(PAGE, RxInitializeSrvCallParameters)
#pragma alloc_text(PAGE, RxCreateSrvCall)
#pragma alloc_text(PAGE, RxSetSrvCallDomainName)
#pragma alloc_text(PAGE, RxFinalizeSrvCall)
#pragma alloc_text(PAGE, RxCreateNetRoot)
#pragma alloc_text(PAGE, RxFinalizeNetRoot)
#pragma alloc_text(PAGE, RxAddVirtualNetRootToNetRoot)
#pragma alloc_text(PAGE, RxRemoveVirtualNetRootFromNetRoot)
#pragma alloc_text(PAGE, RxInitializeVNetRootParameters)
#pragma alloc_text(PAGE, RxUninitializeVNetRootParameters)
#pragma alloc_text(PAGE, RxCreateVNetRoot)
#pragma alloc_text(PAGE, RxOrphanSrvOpens)
#pragma alloc_text(PAGE, RxFinalizeVNetRoot)
#pragma alloc_text(PAGE, RxAllocateFcbObject)
#pragma alloc_text(PAGE, RxFreeFcbObject)
#pragma alloc_text(PAGE, RxCreateNetFcb)
#pragma alloc_text(PAGE, RxInferFileType)
#pragma alloc_text(PAGE, RxFinishFcbInitialization)
#pragma alloc_text(PAGE, RxRemoveNameNetFcb)
#pragma alloc_text(PAGE, RxPurgeFcb)
#pragma alloc_text(PAGE, RxFinalizeNetFcb)
#pragma alloc_text(PAGE, RxSetFileSizeWithLock)
#pragma alloc_text(PAGE, RxGetFileSizeWithLock)
#pragma alloc_text(PAGE, RxCreateSrvOpen)
#pragma alloc_text(PAGE, RxFinalizeSrvOpen)
#pragma alloc_text(PAGE, RxCreateNetFobx)
#pragma alloc_text(PAGE, RxFinalizeNetFobx)
#pragma alloc_text(PAGE, RxCheckFcbStructuresForAlignment)
#pragma alloc_text(PAGE, RxOrphanThisFcb)
#pragma alloc_text(PAGE, RxOrphanSrvOpensForThisFcb)
#pragma alloc_text(PAGE, RxForceFinalizeAllVNetRoots)
#endif


//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_FCBSTRUC)


//
//  zero doesn't work!!!
//

ULONG SerialNumber = 1;

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FCBSTRUCTS)


//
//  SRV_CALL,NET_ROOT,VNET_ROOT,FCB,SRV_OPEN,FOBX are the six key data structures in the RDBSS
//  They are organized in the following hierarchy
//
//       SRV_CALL
//          NET_ROOT
//             VNET_ROOT
//                FCB
//                   SRV_OPEN
//                      FOBX
//
//  All these data structures are reference counted. The reference count associated with
//  any data structure is atleast 1 + the number of instances of the data structure at the next
//  level associated with it, e.g., the reference count associated with a SRV_CALL which
//  has two NET_ROOT's associated with it is atleast 3. In addition to the references held
//  by the NameTable and the data structure at the next level there are additional references
//  acquired as and when required.
//
//  These restrictions ensure that a data structure at any given level cannot be finalized till
//  all the data structures at the next level have been finalized or have released their
//  references, i.e., if a reference to a FCB is held, then it is safe to access the VNET_ROOT,
//  NET_ROOT and SRV_CALL associated with it.
//
//  The SRV_CALL,NET_ROOT and VNET_ROOT creation/finalization are governed by the acquistion/
//  release of the RxNetNameTable lock.
//
//  The FCB creation/finalization is governed by the acquistion/release of the NetNameTable
//  lock associated with the NET_ROOT.
//
//  The FOBX/SRVOPEN creation/finalization is governed by the acquistion/release of the FCB
//  resource.
//
//  The following table summarizes the locks and the modes in which they need to be acquired
//  for creation/finalization of the various data structures.
//
//
//                    L O C K I N G   R E Q U I R E M E N T S
//
//  Locking requirements are as follows:
//
//  where Xy means Exclusive-on-Y, Sy mean at least Shared-on-Y
//  and  NNT means global NetNameTable, TL means NetRoot TableLock, and FCB means FCBlock
//
//
//
//                            SRVCALL NETROOT   FCB   SRVOPEN   FOBX
//
//                Create      XNNT    XNNT      XTL    XFCB     XFCB
//                Finalize    XNNT    XNNT      XFCB   XFCB     XFCB
//                                              & XTL
//
//  Referencing and Dereferencing these data structures need to adhere to certain conventions
//  as well.
//
//  When the reference count associated with any of these data structures drops to 1 ( the sole
//  reference being held by the name table in most cases) the data structure is a potential
//  candidate for finalization. The data structure can be either finalized immediately or it
//  can be marked for scavenging. Both of these methods are implemented. When the locking
//  requirements are met during dereferencing the data structures are finalized immediately
//  ( the one exception being that when delayed operation optimization is implemented, e.g., FCB)
//  otherwise the data structure is marked for scavenging.
//
//
//    You are supposed to have the tablelock exclusive to be calling this routine.......I can't
//    take it here because you are already supposed to have it. To do a create, you should
//    done something like
//
//         getshared();lookup();
//         if (failed) {
//             release(); getexclusive(); lookup();
//             if ((failed) { create(); }
//         }
//         deref();
//         release();
//
//    so you will already have the lock. what you do is to insert the node into the table, release
//    the lock, and then go and see if the server's there. if so, set up the rest of the stuff and unblock
//    anyone who's waiting on the same server (or netroot)...i guess i could enforce this by releasing here
//    but i do not.
//


VOID
RxDereference (
    IN OUT PVOID Instance,
    IN LOCK_HOLDING_STATE LockHoldingState
    )
/*++

Routine Description:

    The routine adjust the reference count on an instance of the reference counted data
    structures in RDBSS exlcuding the FCB.

Arguments:

    Instance        - the instance being dereferenced

    LockHoldingState - the mode in which the appropriate lock is held.

Return Value:

    none.

--*/
{
    LONG FinalRefCount;
    PNODE_TYPE_CODE_AND_SIZE Node = (PNODE_TYPE_CODE_AND_SIZE)Instance;
    BOOLEAN FinalizeInstance = FALSE;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    ASSERT( (NodeType( Instance ) == RDBSS_NTC_SRVCALL) ||
            (NodeType( Instance ) == RDBSS_NTC_NETROOT) ||
            (NodeType( Instance ) == RDBSS_NTC_V_NETROOT) ||
            (NodeType( Instance ) == RDBSS_NTC_SRVOPEN) ||
            (NodeType( Instance ) == RDBSS_NTC_FOBX) );

    FinalRefCount = InterlockedDecrement( &Node->NodeReferenceCount );

    ASSERT( FinalRefCount >= 0 );


#if DBG

    switch (NodeType( Instance )) {

    case RDBSS_NTC_SRVCALL :
        {
            PSRV_CALL ThisSrvCall = (PSRV_CALL)Instance;

            PRINT_REF_COUNT(SRVCALL,ThisSrvCall->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxDereferenceSrvCall %08lx  %wZ RefCount=%lx\n", ThisSrvCall
                               , &ThisSrvCall->PrefixEntry.Prefix
                               , ThisSrvCall->NodeReferenceCount));
        }
        break;

    case RDBSS_NTC_NETROOT :
        {
            PNET_ROOT ThisNetRoot = (PNET_ROOT)Instance;

            PRINT_REF_COUNT(NETROOT,ThisNetRoot->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxDereferenceNetRoot %08lx  %wZ RefCount=%lx\n", ThisNetRoot
                              , &ThisNetRoot->PrefixEntry.Prefix
                              , ThisNetRoot->NodeReferenceCount));
        }
        break;

    case RDBSS_NTC_V_NETROOT:
        {
            PV_NET_ROOT ThisVNetRoot = (PV_NET_ROOT)Instance;

            PRINT_REF_COUNT(VNETROOT,ThisVNetRoot->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxDereferenceVNetRoot %08lx  %wZ RefCount=%lx\n", ThisVNetRoot
                              , &ThisVNetRoot->PrefixEntry.Prefix
                              , ThisVNetRoot->NodeReferenceCount));
        }
        break;

    case RDBSS_NTC_SRVOPEN :
        {
            PSRV_OPEN ThisSrvOpen = (PSRV_OPEN)Instance;

            PRINT_REF_COUNT(SRVOPEN,ThisSrvOpen->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxDereferenceSrvOpen %08lx  %wZ RefCount=%lx\n", ThisSrvOpen
                              , &ThisSrvOpen->Fcb->FcbTableEntry.Path
                              , ThisSrvOpen->NodeReferenceCount));
        }
        break;

    case RDBSS_NTC_FOBX:
        {
            PFOBX ThisFobx = (PFOBX)Instance;

            PRINT_REF_COUNT(NETFOBX,ThisFobx->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxDereferenceFobx %08lx  %wZ RefCount=%lx\n", ThisFobx
                              , &ThisFobx->SrvOpen->Fcb->FcbTableEntry.Path
                              , ThisFobx->NodeReferenceCount));
        }
        break;

    default:
        break;
    }
#endif

    //
    //  if the final reference count was greater then one no finalization is required.
    //

    if (FinalRefCount <= 1) {

        if (LockHoldingState == LHS_ExclusiveLockHeld) {

            //
            //  if the reference count was 1 and the lock modes were satisfactory,
            //  the instance can be finalized immediately.
            //

            FinalizeInstance = TRUE;

            if (FlagOn( Node->NodeTypeCode, RX_SCAVENGER_MASK ) != 0) {
                RxpUndoScavengerFinalizationMarking( Instance );
            }

        } else {
            switch (NodeType( Instance )) {

            case RDBSS_NTC_FOBX:
                if (FinalRefCount != 0) {
                    break;
                }
                //
                //  fall thru intentional if refcount == 1 for FOBXs
                //

            case RDBSS_NTC_SRVCALL:
            case RDBSS_NTC_NETROOT:
            case RDBSS_NTC_V_NETROOT:

                //
                //  the data structure cannot be freed at this time owing to the mode in which
                //  the lock has been acquired ( or not having the lock at all ).
                //

                RxpMarkInstanceForScavengedFinalization( Instance );
                break;
            default:
                break;
            }
        }
    }

    RxReleaseScavengerMutex();

    if (FinalizeInstance) {

        switch (NodeType( Instance )) {
        case RDBSS_NTC_SRVCALL:

#if DBG
            {
                PRDBSS_DEVICE_OBJECT RxDeviceObject = ((PSRV_CALL)Instance)->RxDeviceObject;
                ASSERT( RxDeviceObject != NULL );
                ASSERT( RxIsPrefixTableLockAcquired( RxDeviceObject->pRxNetNameTable ));
            }
#endif

            RxFinalizeSrvCall( (PSRV_CALL)Instance, TRUE );
            break;

        case RDBSS_NTC_NETROOT:

#if DBG
            {
                PSRV_CALL SrvCall =  ((PNET_ROOT)Instance)->SrvCall;
                PRDBSS_DEVICE_OBJECT RxDeviceObject = SrvCall->RxDeviceObject;
                ASSERT( RxDeviceObject != NULL );
                ASSERT( RxIsPrefixTableLockAcquired( RxDeviceObject->pRxNetNameTable ) );
            }
#endif

            RxFinalizeNetRoot( (PNET_ROOT)Instance, TRUE, TRUE );
            break;

        case RDBSS_NTC_V_NETROOT:

#if DBG
            {
                PSRV_CALL SrvCall =  ((PV_NET_ROOT)Instance)->NetRoot->SrvCall;
                PRDBSS_DEVICE_OBJECT RxDeviceObject = SrvCall->RxDeviceObject;

                ASSERT( RxDeviceObject != NULL );
                ASSERT( RxIsPrefixTableLockAcquired( RxDeviceObject->pRxNetNameTable ) );
            }
#endif

            RxFinalizeVNetRoot( (PV_NET_ROOT)Instance, TRUE, TRUE );
            break;

        case RDBSS_NTC_SRVOPEN:
            {
                PSRV_OPEN SrvOpen = (PSRV_OPEN)Instance;

                ASSERT( RxIsFcbAcquired( SrvOpen->Fcb ) );
                if (SrvOpen->OpenCount == 0) {
                    RxFinalizeSrvOpen( SrvOpen, FALSE, FALSE );
                }
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX Fobx = (PFOBX)Instance;

                ASSERT( RxIsFcbAcquired( Fobx->SrvOpen->Fcb ) );
                RxFinalizeNetFobx( Fobx, TRUE, FALSE );
            }
            break;

        default:
            break;
        }
    }
}

VOID
RxReference (
    OUT PVOID Instance
    )
/*++

Routine Description:

    The routine adjusts the reference count on the instance.

Arguments:

    Instance - the instance being referenced

Return Value:

    RxStatus(SUCESS) is successful

    RxStatus(UNSUCCESSFUL) otherwise.

--*/
{
    LONG FinalRefCount;
    PNODE_TYPE_CODE_AND_SIZE Node = (PNODE_TYPE_CODE_AND_SIZE)Instance;
    USHORT InstanceType;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    InstanceType = FlagOn( Node->NodeTypeCode, ~RX_SCAVENGER_MASK );

    ASSERT( (InstanceType == RDBSS_NTC_SRVCALL) ||
            (InstanceType == RDBSS_NTC_NETROOT) ||
            (InstanceType == RDBSS_NTC_V_NETROOT) ||
            (InstanceType == RDBSS_NTC_SRVOPEN) ||
            (InstanceType == RDBSS_NTC_FOBX) );

    FinalRefCount = InterlockedIncrement( &Node->NodeReferenceCount );

#if DBG
    if (FlagOn( Node->NodeTypeCode, RX_SCAVENGER_MASK )) {
        RxDbgTrace( 0, Dbg, ("Referencing Scavenged instance -- Type %lx\n", InstanceType) );
    }

    switch (InstanceType) {

    case RDBSS_NTC_SRVCALL :
        {
            PSRV_CALL ThisSrvCall = (PSRV_CALL)Instance;

            PRINT_REF_COUNT( SRVCALL, ThisSrvCall->NodeReferenceCount );
            RxDbgTrace( 0, Dbg, (" RxReferenceSrvCall %08lx  %wZ RefCount=%lx\n", ThisSrvCall
                               , &ThisSrvCall->PrefixEntry.Prefix
                               , ThisSrvCall->NodeReferenceCount));
        }
        break;

    case RDBSS_NTC_NETROOT :
        {
            PNET_ROOT ThisNetRoot = (PNET_ROOT)Instance;

            PRINT_REF_COUNT( NETROOT, ThisNetRoot->NodeReferenceCount );
            RxDbgTrace( 0, Dbg, (" RxReferenceNetRoot %08lx  %wZ RefCount=%lx\n", ThisNetRoot,
                                 &ThisNetRoot->PrefixEntry.Prefix,
                                 ThisNetRoot->NodeReferenceCount) );
        }
        break;

    case RDBSS_NTC_V_NETROOT:
        {
            PV_NET_ROOT ThisVNetRoot = (PV_NET_ROOT)Instance;

            PRINT_REF_COUNT( VNETROOT, ThisVNetRoot->NodeReferenceCount );
            RxDbgTrace( 0, Dbg, (" RxReferenceVNetRoot %08lx  %wZ RefCount=%lx\n", ThisVNetRoot,
                                 &ThisVNetRoot->PrefixEntry.Prefix,
                                 ThisVNetRoot->NodeReferenceCount) );
        }
        break;

    case RDBSS_NTC_SRVOPEN :
        {
            PSRV_OPEN ThisSrvOpen = (PSRV_OPEN)Instance;

            PRINT_REF_COUNT(SRVOPEN,ThisSrvOpen->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxReferenceSrvOpen %08lx  %wZ RefCount=%lx\n", ThisSrvOpen,
                                 &ThisSrvOpen->Fcb->FcbTableEntry.Path
                                 , ThisSrvOpen->NodeReferenceCount) );
        }
        break;

    case RDBSS_NTC_FOBX:
        {
            PFOBX ThisFobx = (PFOBX)Instance;

            PRINT_REF_COUNT(NETFOBX,ThisFobx->NodeReferenceCount);
            RxDbgTrace( 0, Dbg, (" RxReferenceFobx %08lx  %wZ RefCount=%lx\n", ThisFobx,
                                 &ThisFobx->SrvOpen->Fcb->FcbTableEntry.Path,
                                 ThisFobx->NodeReferenceCount));
        }
        break;

    default:
        ASSERT( !"Valid node type for referencing" );
        break;
    }
#endif

    RxpUndoScavengerFinalizationMarking( Instance );
    RxReleaseScavengerMutex();
}

VOID
RxpReferenceNetFcb (
    PFCB Fcb
    )
/*++

Routine Description:

    The routine adjusts the reference count on the FCB.

Arguments:

    Fcb  - the SrvCall being referenced

Return Value:

    RxStatus(SUCESS) is successful

    RxStatus(UNSUCCESSFUL) otherwise.

--*/
{
    LONG FinalRefCount;

    PAGED_CODE();

    ASSERT( NodeTypeIsFcb( Fcb ) );

    FinalRefCount = InterlockedIncrement( &Fcb->NodeReferenceCount );

#if DBG
    PRINT_REF_COUNT( NETFCB, Fcb->NodeReferenceCount );
    RxDbgTrace( 0, Dbg, (" RxReferenceNetFcb %08lx  %wZ RefCount=%lx\n", Fcb, &Fcb->FcbTableEntry.Path, Fcb->NodeReferenceCount) );
#endif

}

LONG
RxpDereferenceNetFcb (
    PFCB Fcb
    )
/*++

Routine Description:

    The routine adjust the reference count on an instance of the reference counted data
    structures in RDBSS exlcuding the FCB.

Arguments:

    Fcb                         -- the FCB being dereferenced

Return Value:

    none.

Notes:

    The referencing and dereferencing of FCB's is different from those of the other data
    structures because of the embedded resource in the FCB. This implies that the caller
    requires information regarding the status of the FCB ( whether it was finalized or not )

    In order to finalize the FCB two locks need to be held, the NET_ROOT's name table lock as
    well as the FCB resource.

    These considerations lead us to adopt a different approach in dereferencing FCB's. The
    dereferencing routine does not even attempt to finalize the FCB

--*/
{
    LONG FinalRefCount;

    PAGED_CODE();

    ASSERT( NodeTypeIsFcb( Fcb ) );

    FinalRefCount = InterlockedDecrement( &Fcb->NodeReferenceCount );

    ASSERT( FinalRefCount >= 0 );

#if DBG
    PRINT_REF_COUNT( NETFCB, Fcb->NodeReferenceCount );
    RxDbgTrace( 0, Dbg, (" RxDereferenceNetFcb %08lx  %wZ RefCount=%lx\n", Fcb, &Fcb->FcbTableEntry.Path, Fcb->NodeReferenceCount) );
#endif

    return FinalRefCount;
}

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    PFCB Fcb,
    PRX_CONTEXT RxContext,
    BOOLEAN RecursiveFinalize,
    BOOLEAN ForceFinalize
    )
/*++

Routine Description:

    The routine adjust the reference count aw well as finalizes the FCB if required

Arguments:

    Fcb                         -- the FCB being dereferenced

    RxContext                    -- the context for releasing/acquiring FCB.

    RecursiveFinalize            -- recursive finalization

    ForceFinalize                -- force finalization

Return Value:

    TRUE if the node was finalized

Notes:

    The referencing and dereferencing of FCB's is different from those of the other data
    structures because of the embedded resource in the FCB. This implies that the caller
    requires information regarding the status of the FCB ( whether it was finalized or not )

    In order to finalize the FCB two locks need to be held, the NET_ROOT's name table lock as
    well as the FCB resource.

    This routine acquires the additional lock if required.

--*/
{
    BOOLEAN NodeActuallyFinalized   = FALSE;

    LONG    FinalRefCount;

    PAGED_CODE();

    ASSERT( !ForceFinalize );
    ASSERT( NodeTypeIsFcb( Fcb ) );
    ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

    FinalRefCount = InterlockedDecrement(&Fcb->NodeReferenceCount);

    if (ForceFinalize ||
        RecursiveFinalize ||
        ((Fcb->OpenCount == 0) &&
         (Fcb->UncleanCount == 0) &&
         (FinalRefCount <= 1))) {

        BOOLEAN PrefixTableLockAcquired = FALSE;
        PNET_ROOT NetRoot;
        NTSTATUS Status = STATUS_SUCCESS;

        if (!FlagOn( Fcb->FcbState, FCB_STATE_ORPHANED )) {

            NetRoot = Fcb->VNetRoot->NetRoot;

            //
            //  An insurance reference to ensure that the NET ROOT does not dissapear
            //

            RxReferenceNetRoot( NetRoot );

            //
            //  In all these cases the FCB is likely to be finalized
            //

            if (!RxIsFcbTableLockExclusive( &NetRoot->FcbTable )) {

                //
                //  get ready to refresh the finalrefcount after we get the tablelock
                //

                RxReferenceNetFcb( Fcb );
                if (!RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, FALSE )) {

                    if ((RxContext != NULL) &&
                        (RxContext != CHANGE_BUFFERING_STATE_CONTEXT) &&
                        (RxContext != CHANGE_BUFFERING_STATE_CONTEXT_WAIT)) {

                        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK );
                    }

                    RxReleaseFcb( RxContext,Fcb );

                    (VOID)RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );

                    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
                }

                FinalRefCount = RxDereferenceNetFcb( Fcb );
                PrefixTableLockAcquired = TRUE;
            }
        } else {
            NetRoot = NULL;
        }

        if (Status == STATUS_SUCCESS) {
            NodeActuallyFinalized = RxFinalizeNetFcb( Fcb, RecursiveFinalize, ForceFinalize, FinalRefCount );
        }

        if (PrefixTableLockAcquired) {
            RxReleaseFcbTableLock( &NetRoot->FcbTable );
        }

        if (NetRoot != NULL) {
            RxDereferenceNetRoot( NetRoot, LHS_LockNotHeld );
        }
    }

    return NodeActuallyFinalized;
}

VOID
RxWaitForStableCondition(
    IN PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList,
    IN OUT PRX_CONTEXT RxContext,
    OUT NTSTATUS *AsyncStatus OPTIONAL
    )
/*++

Routine Description:

    The routine checks to see if the condition is stable. If not, it
    is suspended till a stable condition is attained. when a stable condition is
    obtained, either the rxcontext sync event is set or the context is posted...depending
    on the POST_ON_STABLE_CONDITION context flag. the flag is cleared on a post.

Arguments:

    Condition - the condition variable we're waiting on

    Resource - the resrouce used to control access to the containing block

    RxContext - the RX context

Return Value:

    RXSTATUS - PENDING if notstable and the context will be posted
               SUCCESS otherwise

--*/
{
    NTSTATUS DummyStatus;
    BOOLEAN Wait = FALSE;

    PAGED_CODE();

    if (AsyncStatus == NULL) {
        AsyncStatus = &DummyStatus;
    }

    *AsyncStatus = STATUS_SUCCESS;

    if (StableCondition( *Condition ))
        return; //  early out could macroize

    RxAcquireSerializationMutex();

    if (!StableCondition( *Condition )) {

        RxInsertContextInSerializationQueue( TransitionWaitList, RxContext );
        if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION )){
            Wait = TRUE;
        } else {
            *AsyncStatus = STATUS_PENDING;
        }
    }

    RxReleaseSerializationMutex();

    if (Wait) {
        RxWaitSync( RxContext );
    }

    return;
}

VOID
RxUpdateCondition (
    IN RX_BLOCK_CONDITION  NewCondition,
    OUT PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList
    )
/*++

Routine Description:

    The routine unwaits the guys waiting on the transition event and the condition is set
    according to the parameter passed.

Arguments:

    NewConditionValue - the new value of the condition variable

    Condition - variable (i.e. a ptr) to the transitioning condition

    TransitionWaitList - list of contexts waiting for the transition.

Notes:

    The resource associated with the data structure instance being modified must have been
    acquired exclusively before invoking this routine, i.e., for SRV_CALL,NET_ROOT and V_NET_ROOT
    the net name table lock must be acquired and for FCB's the associated resource.

--*/
{
    LIST_ENTRY  TargetListHead;
    PRX_CONTEXT RxContext;

    PAGED_CODE();

    RxAcquireSerializationMutex();

    ASSERT( NewCondition != Condition_InTransition );

    *Condition = NewCondition;
    RxTransferList( &TargetListHead, TransitionWaitList );

    RxReleaseSerializationMutex();

    while (RxContext = RxRemoveFirstContextFromSerializationQueue( &TargetListHead )) {

        if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION )) {
            RxSignalSynchronousWaiter( RxContext );
        } else {
            ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION );
            RxFsdPostRequest( RxContext );
        }
    }
}

PVOID
RxAllocateObject (
    NODE_TYPE_CODE NodeType,
    PMINIRDR_DISPATCH MRxDispatch,
    ULONG NameLength
    )
/*++

Routine Description:

    The routine allocates and constructs the skeleton of a SRV_CALL/NET_ROOT/V_NET_ROOT
    instance.

Arguments:

    NodeType     - the node type

    MRxDispatch - the Mini redirector dispatch vector

    NameLength   - name size.

Notes:

    The reasons as to why the allocation/freeing of these data structures have been
    centralized are as follows

      1) The construction of these three data types have a lot in common with the exception
      of the initial computation of sizes. Therefore centralization minimizes the footprint.

      2) It allows us to experiment with different clustering/allocation strategies.

      3) It allows the incorporation of debug support in an easy way.

    There are two special cases of interest in the allocation strategy ...

    1) The data structures for the wrapper as well as the corresponding mini redirector
    are allocated adjacent to each other. This ensures spatial locality.

    2) The one exception to the above rule is the SRV_CALL data structure. This is because
    of the bootstrapping problem. A SRV_CALL skeleton needs to be created which is then passed
    around to each of the mini redirectors. Therefore adoption of rule (1) is not possible.

    Further there can be more than one mini redirector laying claim to a particular server. In
    consideration of these things SRV_CALL's need to be treated as an exception to (1). However
    once a particular mini redirector has been selected as the winner it would be advantageous
    to colocate the data structure to derive the associated performance benefits. This has not
    been implemented as yet.

--*/
{
    ULONG PoolTag;
    ULONG RdbssNodeSize;
    ULONG MRxNodeSize;
    BOOLEAN InitContextFields = FALSE;

    PNODE_TYPE_CODE_AND_SIZE Node;

    PAGED_CODE();

    RdbssNodeSize = MRxNodeSize = 0;

    switch (NodeType) {
    case RDBSS_NTC_SRVCALL :

        PoolTag = RX_SRVCALL_POOLTAG;
        RdbssNodeSize = QuadAlign( sizeof( SRV_CALL ) );

        if (MRxDispatch != NULL) {
            if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_SRV_CALL_EXTENSION )) {
                MRxNodeSize = QuadAlign( MRxDispatch->MRxSrvCallSize );
            }
        }
        break;

    case RDBSS_NTC_NETROOT:

        PoolTag = RX_NETROOT_POOLTAG;
        RdbssNodeSize = QuadAlign( sizeof( NET_ROOT ) );

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_NET_ROOT_EXTENSION )) {
            MRxNodeSize = QuadAlign( MRxDispatch->MRxNetRootSize );
        }
        break;

    case RDBSS_NTC_V_NETROOT:

        PoolTag = RX_V_NETROOT_POOLTAG;
        RdbssNodeSize = QuadAlign( sizeof( V_NET_ROOT ) );

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_V_NET_ROOT_EXTENSION )) {
            MRxNodeSize = QuadAlign( MRxDispatch->MRxVNetRootSize );
        }
        break;

    default:
        ASSERT( !"Invalid Node Type for allocation/Initialization" );
        return NULL;
    }

    Node = RxAllocatePoolWithTag( NonPagedPool, (RdbssNodeSize + MRxNodeSize + NameLength), PoolTag );

    if (Node != NULL) {

        ULONG NodeSize;
        PVOID *Context;
        PRX_PREFIX_ENTRY PrefixEntry = NULL;

        NodeSize = RdbssNodeSize + MRxNodeSize;
        ZeroAndInitializeNodeType( Node, NodeType, (NodeSize + NameLength) );

        switch (NodeType) {
        case RDBSS_NTC_SRVCALL:
            {
                PSRV_CALL SrvCall = (PSRV_CALL)Node;

                Context = &SrvCall->Context;
                PrefixEntry = &SrvCall->PrefixEntry;

                //
                //  Set up the name pointer in the MRX_SRV_CALL structure ..
                //

                SrvCall->pSrvCallName = &SrvCall->PrefixEntry.Prefix;
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                PNET_ROOT NetRoot = (PNET_ROOT)Node;

                Context = &NetRoot->Context;
                PrefixEntry = &NetRoot->PrefixEntry;

                //
                //  Set up the net root name pointer in the MRX_NET_ROOT structure
                //

                NetRoot->pNetRootName = &NetRoot->PrefixEntry.Prefix;
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT VNetRoot = (PV_NET_ROOT)Node;

                Context = &VNetRoot->Context;
                PrefixEntry = &VNetRoot->PrefixEntry;
            }
            break;

        default:
            break;
        }

        if (PrefixEntry != NULL) {

            ZeroAndInitializeNodeType( PrefixEntry, RDBSS_NTC_PREFIX_ENTRY, sizeof( RX_PREFIX_ENTRY ) );

            PrefixEntry->Prefix.Buffer = (PWCH)Add2Ptr(Node, NodeSize );
            PrefixEntry->Prefix.Length = (USHORT)NameLength;
            PrefixEntry->Prefix.MaximumLength = (USHORT)NameLength;
        }

        if (MRxNodeSize > 0) {
            *Context = Add2Ptr( Node, RdbssNodeSize );
        }
    }

    return Node;
}

VOID
RxFreeObject (
    PVOID Object
    )
/*++

Routine Description:

    The routine frees a SRV_CALL/V_NET_ROOT/NET_ROOT instance

Arguments:

    Object - the instance to be freed

Notes:

--*/
{
    PAGED_CODE();

    IF_DEBUG {
        switch (NodeType(Object)) {
        case RDBSS_NTC_SRVCALL :
            {
                PSRV_CALL SrvCall = (PSRV_CALL)Object;

                if (SrvCall->RxDeviceObject != NULL) {

                    ASSERT( FlagOn( SrvCall->RxDeviceObject->Dispatch->MRxFlags, RDBSS_MANAGE_SRV_CALL_EXTENSION ) ||
                            (SrvCall->Context == NULL) );
                    ASSERT( SrvCall->Context2 == NULL );

                    SrvCall->RxDeviceObject = NULL;
                }
            }
            break;

        case RDBSS_NTC_NETROOT :
            {
                PNET_ROOT NetRoot = (PNET_ROOT)Object;

                NetRoot->SrvCall = NULL;
                SetFlag( NetRoot->NodeTypeCode, 0xf000 );
            }
            break;

        case RDBSS_NTC_V_NETROOT :
            break;

        default:
            break;
        }
    }

    RxFreePool( Object );
}

VOID
RxFinalizeNetTable (
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    BOOLEAN ForceFinalization
    )
/*++
Routine Description:

   This routine finalizes the net table.

--*/
{
    BOOLEAN MorePassesRequired = TRUE;
    PLIST_ENTRY ListEntry;
    NODE_TYPE_CODE DesiredNodeType;
    PRX_PREFIX_TABLE RxNetNameTable = RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxForceNetTableFinalization at the TOP\n") );
    RxLog(( "FINALNETT\n" ));
    RxWmiLog( LOG,
              RxFinalizeNetTable_1,
              LOGPTR( RxDeviceObject ) );

    RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE ); //  could be hosed if rogue!

    DesiredNodeType = RDBSS_NTC_V_NETROOT;

    RxAcquireScavengerMutex();

    while (MorePassesRequired) {

        for (ListEntry = RxNetNameTable->MemberQueue.Flink;
             ListEntry !=  &(RxNetNameTable->MemberQueue); ) {

            BOOLEAN NodeFinalized;
            PVOID Container;
            PRX_PREFIX_ENTRY PrefixEntry;
            PLIST_ENTRY PrevEntry;

            PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, MemberQLinks );
            ASSERT( NodeType( PrefixEntry ) == RDBSS_NTC_PREFIX_ENTRY );
            Container = PrefixEntry->ContainingRecord;

            RxDbgTrace( 0, Dbg, ("RxForceNetTableFinalization ListEntry PrefixEntry Container"
                              "=-->     %08lx %08lx %08lx\n", ListEntry, PrefixEntry, Container) );
            RxLog(( "FINALNETT: %lx %wZ\n", Container, &PrefixEntry->Prefix ));
            RxWmiLog( LOG,
                      RxFinalizeNetTable_2,
                      LOGPTR( Container )
                      LOGUSTR( PrefixEntry->Prefix ) );

            ListEntry = ListEntry->Flink;

            if (Container != NULL) {

                RxpUndoScavengerFinalizationMarking( Container );

                if (NodeType( Container ) == DesiredNodeType) {
                    switch (NodeType( Container )) {

                    case RDBSS_NTC_SRVCALL :
                        NodeFinalized = RxFinalizeSrvCall( (PSRV_CALL)Container, ForceFinalization );
                        break;

                    case RDBSS_NTC_NETROOT :
                        NodeFinalized = RxFinalizeNetRoot( (PNET_ROOT)Container, TRUE, ForceFinalization );
                        break;

                    case RDBSS_NTC_V_NETROOT :
                        {
                            PV_NET_ROOT VNetRoot = (PV_NET_ROOT)Container;
                            ULONG AdditionalReferenceTaken;

                            AdditionalReferenceTaken = InterlockedCompareExchange( &VNetRoot->AdditionalReferenceForDeleteFsctlTaken, 0, 1);

                            if (AdditionalReferenceTaken) {
                               RxDereferenceVNetRoot( VNetRoot, LHS_ExclusiveLockHeld );
                               NodeFinalized = TRUE;
                            } else {
                                NodeFinalized = RxFinalizeVNetRoot( (PV_NET_ROOT)Container,TRUE, ForceFinalization );
                            }
                        }

                        break;
                    }
                }
            }
        }

        switch (DesiredNodeType) {

        case RDBSS_NTC_SRVCALL :
            MorePassesRequired = FALSE;
            break;

        case RDBSS_NTC_NETROOT :
            DesiredNodeType = RDBSS_NTC_SRVCALL;
            break;

        case RDBSS_NTC_V_NETROOT :
            DesiredNodeType = RDBSS_NTC_NETROOT;
            break;
        }
    }

    RxDbgTrace( -1, Dbg, ("RxFinalizeNetTable -- Done\n") );

    RxReleaseScavengerMutex();

    RxReleasePrefixTableLock( RxNetNameTable );
}

NTSTATUS
RxFinalizeConnection (
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot,
    IN LOGICAL Level
    )
/*++

Routine Description:

    The routine deletes a connection FROM THE USER's PERSPECTIVE. It doesn't disconnect
    but it does (with force) close open files. disconnecting is handled either by timeout or by
    srvcall finalization.

Arguments:

    NetRoot      - the NetRoot being finalized

    VNetRoot     - the VNetRoot being finalized

    Level        - This is a tri-state
                    FALSE - fail if files or changenotifications are open
                    TRUE  - succeed no matter what. orphan files and remove change notifies forcefully
                    0xff  - take away extra reference on the vnetroot due to add_connection
                            but otherwise act like FALSE
Return Value:

    RxStatus(SUCCESS) if successful.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NumberOfOpenDirectories = 0;
    ULONG NumberOfOpenNonDirectories = 0;
    ULONG NumberOfFobxs = 0;
    LONG  AdditionalReferenceForDeleteFsctlTaken = 0;
    PLIST_ENTRY ListEntry, NextListEntry;
    PRX_PREFIX_TABLE  RxNetNameTable;

    BOOLEAN PrefixTableLockAcquired;
    BOOLEAN FcbTableLockAcquired;
    BOOLEAN ForceFilesClosed = FALSE;

    if (Level == TRUE) {
        ForceFilesClosed = TRUE;
    }

    PAGED_CODE();

    ASSERT( NodeType( NetRoot ) == RDBSS_NTC_NETROOT );
    RxNetNameTable = NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;

    Status = RxCancelNotifyChangeDirectoryRequestsForVNetRoot( VNetRoot, ForceFilesClosed );

    //
    //  either changenotifications were cancelled, or they weren't but we still want to
    //  go through in order to either forceclose the files or atleast deref the vnetroot
    //  of the extra ref taken during ADD_CONNECTION
    //

    if ((Status == STATUS_SUCCESS) || (Level != FALSE)) {

        //
        //  reset the status
        //

        Status = STATUS_SUCCESS;

        PrefixTableLockAcquired = RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );

        //
        //  don't let the netroot be finalized yet.......
        //

        RxReferenceNetRoot( NetRoot );

        FcbTableLockAcquired = RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );

        try {

            if ((Status == STATUS_SUCCESS) && (!VNetRoot->ConnectionFinalizationDone)) {
                USHORT BucketNumber;

                RxDbgTrace( +1, Dbg, ("RxFinalizeConnection<+> NR= %08lx VNR= %08lx %wZ\n",
                                       NetRoot, VNetRoot, &NetRoot->PrefixEntry.Prefix) );
                RxLog(( "FINALCONN: %lx  %wZ\n", NetRoot, &NetRoot->PrefixEntry.Prefix ));
                RxWmiLog( LOG,
                          RxFinalizeConnection,
                          LOGPTR( NetRoot )
                          LOGUSTR( NetRoot->PrefixEntry.Prefix ) );

                for (BucketNumber = 0;
                     (BucketNumber < NetRoot->FcbTable.NumberOfBuckets);
                     BucketNumber++) {

                    PLIST_ENTRY ListHeader;

                    ListHeader = &NetRoot->FcbTable.HashBuckets[BucketNumber];

                    for (ListEntry = ListHeader->Flink;
                         ListEntry != ListHeader;
                         ListEntry = NextListEntry ) {

                        PFCB Fcb;
                        PRX_FCB_TABLE_ENTRY FcbTableEntry;

                        NextListEntry = ListEntry->Flink;
                        FcbTableEntry = CONTAINING_RECORD( ListEntry, RX_FCB_TABLE_ENTRY, HashLinks );
                        Fcb = CONTAINING_RECORD( FcbTableEntry, FCB, FcbTableEntry );

                        if (Fcb->VNetRoot != VNetRoot) {
                            continue;
                        }

                        if ((Fcb->UncleanCount > 0) && !ForceFilesClosed) {

                            //
                            //  this is changed later
                            //

                            Status = STATUS_CONNECTION_IN_USE;
                            if (NodeType( Fcb ) == RDBSS_NTC_STORAGE_TYPE_DIRECTORY ) {
                                NumberOfOpenDirectories += 1;
                            } else {
                                NumberOfOpenNonDirectories += 1;
                            }
                            continue;
                        }

                        ASSERT( NodeTypeIsFcb( Fcb ) );
                        RxDbgTrace( 0, Dbg, ("                    AcquiringFcbLock%c!!\n", '!') );

                        Status = RxAcquireExclusiveFcb( NULL, Fcb );
                        ASSERT( Status == STATUS_SUCCESS );
                        RxDbgTrace( 0, Dbg, ("                    AcquiredFcbLock%c!!\n", '!') );

                        //
                        //  Ensure that no more file objects will be marked for a delayed close
                        //  on this FCB.
                        //

                        ClearFlag( Fcb->FcbState, FCB_STATE_COLLAPSING_ENABLED );

                        RxScavengeRelatedFobxs( Fcb );

                        //
                        //  a small complication here is that this fcb MAY have an open
                        //  section against it caused by our cacheing the file. if so,
                        //  we need to purge to get to the close
                        //

                        RxPurgeFcb( Fcb );
                    }
                }

                if (VNetRoot->NumberOfFobxs == 0) {
                    VNetRoot->ConnectionFinalizationDone = TRUE;
                }
            }

            NumberOfFobxs = VNetRoot->NumberOfFobxs;
            AdditionalReferenceForDeleteFsctlTaken = VNetRoot->AdditionalReferenceForDeleteFsctlTaken;

            if (ForceFilesClosed) {
                RxFinalizeVNetRoot( VNetRoot, FALSE, TRUE );
            }
        } finally {
            if (FcbTableLockAcquired) {
                RxReleaseFcbTableLock( &NetRoot->FcbTable );
            }

            //
            //  We should not delete the remote connection with the file opened.
            //
            if (!ForceFilesClosed && (Status == STATUS_SUCCESS) && (NumberOfFobxs > 0)) {
                Status = STATUS_FILES_OPEN;
            }

            if (Status != STATUS_SUCCESS) {
                if (NumberOfOpenNonDirectories) {
                    Status = STATUS_FILES_OPEN;
                }
            }

            if ((Status == STATUS_SUCCESS) || (Level==0xff)) {

                //
                //  the corresponding reference for this is in RxCreateTreeConnect...
                //  please see the comment there...
                //

                if (AdditionalReferenceForDeleteFsctlTaken != 0) {
                    VNetRoot->AdditionalReferenceForDeleteFsctlTaken = 0;
                    RxDereferenceVNetRoot( VNetRoot, LHS_ExclusiveLockHeld );
                }
            }

            if (PrefixTableLockAcquired) {
                RxDereferenceNetRoot( NetRoot, LHS_ExclusiveLockHeld );
                RxReleasePrefixTableLock( RxNetNameTable );
            }
        }

        RxDbgTrace( -1, Dbg, ("RxFinalizeConnection<-> Status=%08lx\n", Status) );
    }
    return Status;
}

NTSTATUS
RxInitializeSrvCallParameters (
    IN PRX_CONTEXT RxContext,
    IN OUT PSRV_CALL SrvCall
    )
/*++

Routine Description:

    This routine initializes the server call parameters passed in through EA's
    Currently this routine initializes the Server principal name which is passed
    in by the DFS driver.

Arguments:

    RxContext  -- the associated context

    SrvCall    -- the Srv Call Instance

Return Value:

    RxStatus(SUCCESS) if successfull

Notes:

    The current implementation maps out of memory situations into an error and
    passes it back. If the global strategy is to raise an exception this
    redundant step can be avoided.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG EaInformationLength;

    PAGED_CODE();

    SrvCall->pPrincipalName = NULL;

    if (RxContext->MajorFunction != IRP_MJ_CREATE) {
        return STATUS_SUCCESS;
    }

    EaInformationLength = RxContext->Create.EaLength;

    if (EaInformationLength > 0) {
        PFILE_FULL_EA_INFORMATION EaEntry;

        EaEntry = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        ASSERT( EaEntry != NULL );

        for(;;) {

            RxDbgTrace( 0, Dbg, ("RxExtractSrvCallParams: Processing EA name %s\n", EaEntry->EaName) );

            if (strcmp( EaEntry->EaName, EA_NAME_PRINCIPAL ) == 0) {
                if (EaEntry->EaValueLength > 0) {
                    SrvCall->pPrincipalName = (PUNICODE_STRING) RxAllocatePoolWithTag( NonPagedPool, (sizeof(UNICODE_STRING) + EaEntry->EaValueLength), RX_SRVCALL_PARAMS_POOLTAG );

                    if (SrvCall->pPrincipalName != NULL) {

                        SrvCall->pPrincipalName->Length = EaEntry->EaValueLength;
                        SrvCall->pPrincipalName->MaximumLength = EaEntry->EaValueLength;
                        SrvCall->pPrincipalName->Buffer = (PWCHAR)Add2Ptr(SrvCall->pPrincipalName, sizeof( UNICODE_STRING ) );

                        RtlCopyMemory( SrvCall->pPrincipalName->Buffer,
                                       EaEntry->EaName + EaEntry->EaNameLength + 1,
                                       SrvCall->pPrincipalName->Length );
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;
            }

            if (EaEntry->NextEntryOffset == 0) {
                break;
            } else {
                EaEntry = (PFILE_FULL_EA_INFORMATION)Add2Ptr( EaEntry, EaEntry->NextEntryOffset );
            }
        }
    }

    return Status;
}

PSRV_CALL
RxCreateSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING InnerNamePrefix OPTIONAL,
    IN PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine builds a node representing a server call context and inserts the name into the net
    name table. Optionally, it "co-allocates" a netroot structure as well. Appropriate alignment is
    respected for the enclosed netroot. The name(s) is(are) allocated at the end of the block. The
    reference count on the block is set to 1 (2 if enclosed netroot) on this create to account for
    ptr returned.

Arguments:

    RxContext - the RDBSS context
    Name      - the name to be inserted
    Dispatch  - pointer to the minirdr dispatch table

Return Value:

    Ptr to the created srvcall.

--*/
{
    PSRV_CALL ThisSrvCall;
    PRX_PREFIX_ENTRY ThisEntry;

    ULONG NameSize;
    ULONG PrefixNameSize;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxSrvCallCreate-->     Name = %wZ\n", Name) );

    ASSERT( RxIsPrefixTableLockExclusive ( RxContext->RxDeviceObject->pRxNetNameTable ) );

    NameSize = Name->Length + sizeof( WCHAR ) * 2;

    if (InnerNamePrefix) {
        PrefixNameSize = InnerNamePrefix->Length;
    } else {
        PrefixNameSize = 0;
    }

    ThisSrvCall = RxAllocateObject( RDBSS_NTC_SRVCALL,NULL, (NameSize + PrefixNameSize) );
    if (ThisSrvCall != NULL) {

        ThisSrvCall->SerialNumberForEnum = SerialNumber;
        SerialNumber += 1;
        ThisSrvCall->RxDeviceObject = RxContext->RxDeviceObject;

        RxInitializeBufferingManager( ThisSrvCall );

        InitializeListHead( &ThisSrvCall->ScavengerFinalizationList );
        InitializeListHead( &ThisSrvCall->TransitionWaitList );

        RxInitializePurgeSyncronizationContext( &ThisSrvCall->PurgeSyncronizationContext );

        RxInitializeSrvCallParameters( RxContext, ThisSrvCall );

        RtlMoveMemory( ThisSrvCall->PrefixEntry.Prefix.Buffer,
                       Name->Buffer,
                       Name->Length );

        ThisEntry = &ThisSrvCall->PrefixEntry;
        ThisEntry->Prefix.MaximumLength = (USHORT)NameSize;
        ThisEntry->Prefix.Length = Name->Length;

        RxPrefixTableInsertName( RxContext->RxDeviceObject->pRxNetNameTable,
                                 ThisEntry,
                                 (PVOID)ThisSrvCall,
                                 &ThisSrvCall->NodeReferenceCount,
                                 Name->Length,
                                 RxConnectionId  ); //  make the whole srvcallname case insensitive

        RxDbgTrace( -1, Dbg, ("RxSrvCallCreate -> RefCount = %08lx\n", ThisSrvCall->NodeReferenceCount) );
    }

    return ThisSrvCall;
}

NTSTATUS
RxSetSrvCallDomainName (
    IN PMRX_SRV_CALL SrvCall,
    IN PUNICODE_STRING DomainName
    )
/*++

Routine Description:

    The routine sets the domain name associated with any given server.

Arguments:

    SrvCall - the SrvCall

    DomainName - the DOMAIN to which the server belongs.

Return Value:

    RxStatus(SUCCESS) if successful

Notes:

    This is one of the callback routines provided in the wrapper for the mini redirectors.
    Since the Domain name is not often known at the beginning this mechanism has to be
    adopted once it is found.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (SrvCall->pDomainName != NULL) {
        RxFreePool( SrvCall->pDomainName );
    }

    if ((DomainName != NULL) && (DomainName->Length > 0)) {

        SrvCall->pDomainName = (PUNICODE_STRING) RxAllocatePoolWithTag( NonPagedPool, sizeof(UNICODE_STRING) + DomainName->Length + sizeof( WCHAR ), RX_SRVCALL_PARAMS_POOLTAG );

        if (SrvCall->pDomainName != NULL) {

            SrvCall->pDomainName->Buffer = (PWCHAR)Add2Ptr( SrvCall->pDomainName, sizeof( UNICODE_STRING ) );
            SrvCall->pDomainName->Length = DomainName->Length;
            SrvCall->pDomainName->MaximumLength = DomainName->Length;

            *SrvCall->pDomainName->Buffer = 0;

            if (SrvCall->pDomainName->Length > 0) {

                RtlCopyMemory( SrvCall->pDomainName->Buffer, DomainName->Buffer, DomainName->Length );
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        SrvCall->pDomainName = NULL;
    }

    return Status;
}

VOID
RxpDestroySrvCall (
    PSRV_CALL ThisSrvCall
    )
/*++

Routine Description:

    This routine is used to tear down a SRV_CALL entry. This code is offloaded
    from the RxFinalizeCall routine to avoid having to hold the Name Table Lock
    for extended periods of time while the mini redirector is finalizing its
    data structures.

Arguments:

    ThisSrvCall      - the SrvCall being finalized

Notes:

    there is no recursive part because i don't have a list of srvcalls and a list
    of netroots i only have a combined list. thus, recursive finalization of
    netroots is directly from the top level. however, all netroots should already
    have been done when i get here..

--*/
{
    NTSTATUS Status;
    BOOLEAN  ForceFinalize;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = ThisSrvCall->RxDeviceObject;
    PRX_PREFIX_TABLE RxNetNameTable = RxDeviceObject->pRxNetNameTable;

    ASSERT( ThisSrvCall->UpperFinalizationDone );

    ForceFinalize = BooleanFlagOn( ThisSrvCall->Flags, SRVCALL_FLAG_FORCE_FINALIZED );

    //
    //  we have to protect this call since the srvcall may never have been claimed
    //

    MINIRDR_CALL_THROUGH( Status,
                          RxDeviceObject->Dispatch,
                          MRxFinalizeSrvCall,
                          ((PMRX_SRV_CALL)ThisSrvCall, ForceFinalize) );


    RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE);

    InterlockedDecrement( &ThisSrvCall->NodeReferenceCount );

    RxFinalizeSrvCall( ThisSrvCall,
                       ForceFinalize );

    RxReleasePrefixTableLock( RxNetNameTable );
}

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN BOOLEAN ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given netroot. You should have exclusive on
    the netname tablelock.

Arguments:

    ThisSrvCall      - the SrvCall being finalized

    ForceFinalize -  Whether to force finalization regardless or reference count

Return Value:

    BOOLEAN - tells whether finalization actually occured

Notes:

    there is no recursive part because i don't have a list of srvcalls and a list
    of netroots i only have a combined list. thus, recursive finalization of
    netroots is directly from the top level. however, all netroots should already
    have been done when i get here..

--*/
{
    BOOLEAN NodeActuallyFinalized = FALSE;
    PRX_PREFIX_TABLE RxNetNameTable;

    PAGED_CODE();

    ASSERT( NodeType( ThisSrvCall ) == RDBSS_NTC_SRVCALL );
    RxNetNameTable = ThisSrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT( RxIsPrefixTableLockExclusive( RxNetNameTable ) );

    RxDbgTrace( +1, Dbg, ("RxFinalizeSrvCall<+> %08lx %wZ RefC=%ld\n",
                               ThisSrvCall,&ThisSrvCall->PrefixEntry.Prefix,
                               ThisSrvCall->NodeReferenceCount) );

    if (ThisSrvCall->NodeReferenceCount == 1 || ForceFinalize) {

        BOOLEAN DeferFinalizationToWorkerThread = FALSE;

        RxLog(( "FINALSRVC: %lx  %wZ\n", ThisSrvCall, &ThisSrvCall->PrefixEntry.Prefix ));
        RxWmiLog( LOG,
                  RxFinalizeSrvCall,
                  LOGPTR( ThisSrvCall )
                  LOGUSTR( ThisSrvCall->PrefixEntry.Prefix ) );

        if (!ThisSrvCall->UpperFinalizationDone) {

            NTSTATUS Status;

            RxRemovePrefixTableEntry ( RxNetNameTable, &ThisSrvCall->PrefixEntry );

            if (ForceFinalize) {
                SetFlag( ThisSrvCall->Flags, SRVCALL_FLAG_FORCE_FINALIZED );
            }

            ThisSrvCall->UpperFinalizationDone = TRUE;

            if (ThisSrvCall->NodeReferenceCount == 1) {
                NodeActuallyFinalized = TRUE;
            }

            if (ThisSrvCall->RxDeviceObject != NULL) {
                if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {

                    InterlockedIncrement( &ThisSrvCall->NodeReferenceCount );

                    RxDispatchToWorkerThread( ThisSrvCall->RxDeviceObject,
                                              DelayedWorkQueue,
                                              RxpDestroySrvCall,
                                              ThisSrvCall );

                    DeferFinalizationToWorkerThread = TRUE;

                } else {
                    MINIRDR_CALL_THROUGH( Status,
                                          ThisSrvCall->RxDeviceObject->Dispatch,
                                          MRxFinalizeSrvCall,
                                          ((PMRX_SRV_CALL)ThisSrvCall,ForceFinalize) );
                }
            }
        }

        if (!DeferFinalizationToWorkerThread) {
            if( ThisSrvCall->NodeReferenceCount == 1 ) {
                if (ThisSrvCall->pDomainName != NULL) {
                   RxFreePool( ThisSrvCall->pDomainName );
                }

                RxTearDownBufferingManager( ThisSrvCall );
                RxFreeObject( ThisSrvCall );
                NodeActuallyFinalized = TRUE;
            }
        }
    } else {
        RxDbgTrace( 0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!') );
    }

    RxDbgTrace( -1, Dbg, ("RxFinalizeSrvCall<-> %08lx\n", ThisSrvCall, NodeActuallyFinalized) );

    return NodeActuallyFinalized;
}

PNET_ROOT
RxCreateNetRoot (
    IN PSRV_CALL SrvCall,
    IN PUNICODE_STRING Name,
    IN ULONG NetRootFlags,
    IN PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine builds a node representing a netroot  and inserts the name into the net
    name table. The name is allocated at the end of the block. The reference count on the block
    is set to 1 on this create....

Arguments:

    SrvCall - the associated server call context; may be NULL!!  (but not right now.........)
    Dispatch - the minirdr dispatch table
    Name - the name to be inserted

Return Value:

    Ptr to the created net root.

--*/
{
    PNET_ROOT ThisNetRoot;
    PRX_PREFIX_TABLE RxNetNameTable;

    ULONG NameSize;
    ULONG SrvCallNameSize;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxNetRootCreate-->     Name = %wZ\n", Name) );

    ASSERT( SrvCall != NULL );
    RxNetNameTable = SrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT( RxIsPrefixTableLockExclusive ( RxNetNameTable ) );

    SrvCallNameSize = SrvCall->PrefixEntry.Prefix.Length;
    NameSize = Name->Length + SrvCallNameSize;

    ThisNetRoot = RxAllocateObject( RDBSS_NTC_NETROOT,
                                    SrvCall->RxDeviceObject->Dispatch,
                                    NameSize );

    if (ThisNetRoot != NULL) {

        USHORT CaseInsensitiveLength;

        RtlMoveMemory( Add2Ptr( ThisNetRoot->PrefixEntry.Prefix.Buffer,  SrvCallNameSize ),
                       Name->Buffer,
                       Name->Length );

        if (SrvCallNameSize) {

            RtlMoveMemory( ThisNetRoot->PrefixEntry.Prefix.Buffer,
                           SrvCall->PrefixEntry.Prefix.Buffer,
                           SrvCallNameSize );
        }

        if (FlagOn( SrvCall->Flags, SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS )) {
            CaseInsensitiveLength = (USHORT)NameSize;
        } else {
            CaseInsensitiveLength = SrvCall->PrefixEntry.CaseInsensitiveLength;
        }

        RxPrefixTableInsertName ( RxNetNameTable,
                                  &ThisNetRoot->PrefixEntry,
                                  (PVOID)ThisNetRoot,
                                  &ThisNetRoot->NodeReferenceCount,
                                  CaseInsensitiveLength,
                                  RxConnectionId );

        RxInitializeFcbTable( &ThisNetRoot->FcbTable, TRUE );

        InitializeListHead( &ThisNetRoot->VirtualNetRoots );
        InitializeListHead( &ThisNetRoot->TransitionWaitList );
        InitializeListHead( &ThisNetRoot->ScavengerFinalizationList );

        RxInitializePurgeSyncronizationContext( &ThisNetRoot->PurgeSyncronizationContext );

        ThisNetRoot->SerialNumberForEnum = SerialNumber;
        SerialNumber += 1;
        SetFlag( ThisNetRoot->Flags, NetRootFlags );
        ThisNetRoot->DiskParameters.ClusterSize = 1;
        ThisNetRoot->DiskParameters.ReadAheadGranularity = DEFAULT_READ_AHEAD_GRANULARITY;

        ThisNetRoot->SrvCall = SrvCall;

        //
        //  already have the lock
        //

        RxReferenceSrvCall( (PSRV_CALL)ThisNetRoot->SrvCall );
    }

    return ThisNetRoot;
}

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given netroot. You must be exclusive on
    the NetName tablelock.

Arguments:

    ThisNetRoot      - the NetRoot being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

--*/
{
    NTSTATUS Status;
    BOOLEAN NodeActuallyFinalized = FALSE;
    PRX_PREFIX_TABLE RxNetNameTable;

    PAGED_CODE();

    ASSERT( NodeType( ThisNetRoot ) == RDBSS_NTC_NETROOT );
    RxNetNameTable = ThisNetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT( RxIsPrefixTableLockExclusive ( RxNetNameTable ) );

    if (FlagOn( ThisNetRoot->Flags, NETROOT_FLAG_FINALIZATION_IN_PROGRESS )) {
        return FALSE;
    }

    //
    //  Since the table lock has been acquired exclusive the flags can be modified
    //  without any further synchronization since the protection is against recursive
    //  invocations.
    //

    SetFlag( ThisNetRoot->Flags, NETROOT_FLAG_FINALIZATION_IN_PROGRESS );

    RxDbgTrace( +1, Dbg, ("RxFinalizeNetRoot<+> %08lx %wZ RefC=%ld\n",
                          ThisNetRoot,&ThisNetRoot->PrefixEntry.Prefix,
                          ThisNetRoot->NodeReferenceCount) );

    if (RecursiveFinalize) {

        PLIST_ENTRY ListEntry;
        USHORT BucketNumber;

        RxAcquireFcbTableLockExclusive( &ThisNetRoot->FcbTable, TRUE );

#if 0
        if (ThisNetRoot->NodeReferenceCount) {
            RxDbgTrace( 0, Dbg, ("     BAD!!!!!ReferenceCount = %08lx\n", ThisNetRoot->NodeReferenceCount) );
        }
#endif


        for (BucketNumber = 0;
             (BucketNumber < ThisNetRoot->FcbTable.NumberOfBuckets);
             BucketNumber += 1) {

            PLIST_ENTRY ListHeader;

            ListHeader = &ThisNetRoot->FcbTable.HashBuckets[BucketNumber];

            for (ListEntry = ListHeader->Flink; ListEntry != ListHeader; ) {

                PFCB Fcb;
                PRX_FCB_TABLE_ENTRY FcbTableEntry;

                FcbTableEntry = CONTAINING_RECORD( ListEntry, RX_FCB_TABLE_ENTRY, HashLinks );
                Fcb = CONTAINING_RECORD( FcbTableEntry, FCB, FcbTableEntry );

                ListEntry = ListEntry->Flink;

                ASSERT( NodeTypeIsFcb( Fcb ) );

                if (!FlagOn( Fcb->FcbState,FCB_STATE_ORPHANED )) {

                    Status = RxAcquireExclusiveFcb( NULL, Fcb );
                    ASSERT( Status == STATUS_SUCCESS );

                    //
                    //  a small complication here is that this fcb MAY have an open section against it caused
                    //  by our caching the file. if so, we need to purge to get to the close
                    //

                    RxPurgeFcb( Fcb );
                }
            }
        }

        RxReleaseFcbTableLock( &ThisNetRoot->FcbTable );
    }

    if ((ThisNetRoot->NodeReferenceCount == 1) || ForceFinalize ){

        RxLog(( "FINALNETROOT: %lx  %wZ\n", ThisNetRoot, &ThisNetRoot->PrefixEntry.Prefix ));
        RxWmiLog( LOG,
                  RxFinalizeNetRoot,
                  LOGPTR( ThisNetRoot )
                  LOGUSTR( ThisNetRoot->PrefixEntry.Prefix ) );

        if (ThisNetRoot->NodeReferenceCount == 1) {

            PSRV_CALL SrvCall = (PSRV_CALL)ThisNetRoot->SrvCall;
            RxFinalizeFcbTable( &ThisNetRoot->FcbTable );

            if (!FlagOn( ThisNetRoot->Flags, NETROOT_FLAG_NAME_ALREADY_REMOVED )) {
                RxRemovePrefixTableEntry( RxNetNameTable, &ThisNetRoot->PrefixEntry );
            }

            RxFreeObject( ThisNetRoot );

            if (SrvCall != NULL) {
                RxDereferenceSrvCall( SrvCall, LHS_ExclusiveLockHeld );   //  already have the lock
            }

            NodeActuallyFinalized = TRUE;
        }
    } else {
        RxDbgTrace(0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!'));
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeNetRoot<-> %08lx\n", ThisNetRoot, NodeActuallyFinalized));

    return NodeActuallyFinalized;
}

VOID
RxAddVirtualNetRootToNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    )
/*++

Routine Description:

    The routine adds a VNetRoot to the list of VNetRoot's associated with a NetRoot

Arguments:

    NetRoot   - the NetRoot

    VNetRoot  - the new VNetRoot to be added to the list.

Notes:

    The reference count associated with a NetRoot will be equal to the number of VNetRoot's
    associated with it plus 1. the last one being for the prefix name table. This ensures
    that a NetRoot cannot be finalized till all the VNetRoots associated with it have been
    finalized.

--*/
{
    PAGED_CODE();

    ASSERT( RxIsPrefixTableLockExclusive( NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable ) );

    VNetRoot->NetRoot = NetRoot;
    NetRoot->NumberOfVirtualNetRoots += 1;

    InsertTailList( &NetRoot->VirtualNetRoots, &VNetRoot->NetRootListEntry );
}

VOID
RxRemoveVirtualNetRootFromNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    )
/*++

Routine Description:

    The routine removes a VNetRoot to the list of VNetRoot's associated with a NetRoot

Arguments:

    NetRoot   - the NetRoot

    VNetRoot  - the VNetRoot to be removed from the list.

Notes:

    The reference count associated with a NetRoot will be equal to the number of VNetRoot's
    associated with it plus 1. the last one being for the prefix name table. This ensures
    that a NetRoot cannot be finalized till all the VNetRoots associated with it have been
    finalized.

--*/
{
    PRX_PREFIX_TABLE RxNetNameTable = NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;
    PAGED_CODE();

    ASSERT( RxIsPrefixTableLockExclusive( RxNetNameTable ) );

    NetRoot->NumberOfVirtualNetRoots -= 1;
    RemoveEntryList( &VNetRoot->NetRootListEntry );

    if (NetRoot->DefaultVNetRoot == VNetRoot) {

        if (!IsListEmpty( &NetRoot->VirtualNetRoots )) {

            //
            //  Traverse the list and pick another default net root.
            //

            PV_NET_ROOT VNetRoot;

            VNetRoot = (PV_NET_ROOT) CONTAINING_RECORD( NetRoot->VirtualNetRoots.Flink, V_NET_ROOT, NetRootListEntry );
            NetRoot->DefaultVNetRoot = VNetRoot;

        } else {
            NetRoot->DefaultVNetRoot = NULL;
        }
    }

    if (IsListEmpty( &NetRoot->VirtualNetRoots )) {

        NTSTATUS Status;

        if (!FlagOn( NetRoot->Flags, NETROOT_FLAG_NAME_ALREADY_REMOVED )) {

            RxRemovePrefixTableEntry( RxNetNameTable, &NetRoot->PrefixEntry );
            SetFlag( NetRoot->Flags, NETROOT_FLAG_NAME_ALREADY_REMOVED );
        }

        if ((NetRoot->SrvCall != NULL) && (NetRoot->SrvCall->RxDeviceObject != NULL)) {
            MINIRDR_CALL_THROUGH( Status,
                                  NetRoot->SrvCall->RxDeviceObject->Dispatch,
                                  MRxFinalizeNetRoot,
                                  ((PMRX_NET_ROOT)NetRoot,NULL) );
        }
    }
}

NTSTATUS
RxInitializeVNetRootParameters (
    IN PRX_CONTEXT RxContext,
    OUT PLUID LogonId,
    OUT PULONG SessionId,
    OUT PUNICODE_STRING *UserName,
    OUT PUNICODE_STRING *UserDomain,
    OUT PUNICODE_STRING *Password,
    OUT PULONG Flags
    )
/*++

Routine Description:

    This routine extracts the ea parameters specified

Arguments:

    RxContext      - the RxContext

    LogonId        - the logon Id.

    SessionId      -

    UserName       - pointer to the User Name

    UserDomain     - pointer to the user domain name

    Password       - the password.

    Flags          -

Return Value:

    STATUS_SUCCESS -- successful,

    appropriate NTSTATUS code otherwise

Notes:



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_SECURITY_CONTEXT SecurityContext;
    PACCESS_TOKEN AccessToken;

    PAGED_CODE();

    SecurityContext = RxContext->Create.NtCreateParameters.SecurityContext;
    AccessToken = SeQuerySubjectContextToken( &SecurityContext->AccessState->SubjectSecurityContext );

    *Password = NULL;
    *UserDomain = NULL;
    *UserName = NULL;
    ClearFlag( *Flags, VNETROOT_FLAG_CSCAGENT_INSTANCE );

    if (!SeTokenIsRestricted( AccessToken)) {

        Status = SeQueryAuthenticationIdToken( AccessToken, LogonId );

        if (Status == STATUS_SUCCESS) {
            Status = SeQuerySessionIdToken( AccessToken, SessionId );
        }

        if ((Status == STATUS_SUCCESS) &&
            (RxContext->Create.UserName.Buffer != NULL)) {

            PUNICODE_STRING TargetString;

            TargetString = RxAllocatePoolWithTag( NonPagedPool, (sizeof( UNICODE_STRING ) + RxContext->Create.UserName.Length), RX_SRVCALL_PARAMS_POOLTAG );

            if (TargetString != NULL) {
                TargetString->Length = RxContext->Create.UserName.Length;
                TargetString->MaximumLength = RxContext->Create.UserName.MaximumLength;

                if (TargetString->Length > 0) {
                    TargetString->Buffer = (PWCHAR)((PCHAR)TargetString + sizeof(UNICODE_STRING));
                    RtlCopyMemory( TargetString->Buffer, RxContext->Create.UserName.Buffer, TargetString->Length );
                } else {
                    TargetString->Buffer = NULL;
                }

                *UserName = TargetString;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ((RxContext->Create.UserDomainName.Buffer != NULL) && (Status == STATUS_SUCCESS)) {

            PUNICODE_STRING TargetString;

            TargetString = RxAllocatePoolWithTag( NonPagedPool, (sizeof( UNICODE_STRING ) + RxContext->Create.UserDomainName.Length + sizeof( WCHAR )), RX_SRVCALL_PARAMS_POOLTAG );

            if (TargetString != NULL) {
                TargetString->Length = RxContext->Create.UserDomainName.Length;
                TargetString->MaximumLength = RxContext->Create.UserDomainName.MaximumLength;

                TargetString->Buffer = (PWCHAR)Add2Ptr(TargetString, sizeof( UNICODE_STRING) );

                //
                //  in case of UPN name, domain name will be a NULL string
                //

                *TargetString->Buffer = 0;

                if (TargetString->Length > 0) {
                    RtlCopyMemory( TargetString->Buffer, RxContext->Create.UserDomainName.Buffer, TargetString->Length );
                }

                *UserDomain = TargetString;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ((RxContext->Create.Password.Buffer != NULL) && (Status == STATUS_SUCCESS)) {
            PUNICODE_STRING TargetString;

            TargetString = RxAllocatePoolWithTag( NonPagedPool, (sizeof( UNICODE_STRING ) + RxContext->Create.Password.Length), RX_SRVCALL_PARAMS_POOLTAG );

            if (TargetString != NULL) {
                TargetString->Length = RxContext->Create.Password.Length;
                TargetString->MaximumLength = RxContext->Create.Password.MaximumLength;

                if (TargetString->Length > 0) {
                    TargetString->Buffer = (PWCHAR)Add2Ptr( TargetString, sizeof( UNICODE_STRING ) );
                    RtlCopyMemory( TargetString->Buffer, RxContext->Create.Password.Buffer, TargetString->Length );
                } else {
                    TargetString->Buffer = NULL;
                }

                *Password = TargetString;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS) {
            if(RxIsThisACscAgentOpen( RxContext )) {
                SetFlag( *Flags,  VNETROOT_FLAG_CSCAGENT_INSTANCE );
            }
        }

        if (Status != STATUS_SUCCESS) {
            if (*UserName != NULL) {
                RxFreePool( *UserName );
                *UserName = NULL;
            }
            if (*UserDomain != NULL) {
                RxFreePool( *UserDomain );
                *UserDomain = NULL;
            }
            if (*Password != NULL) {
                RxFreePool( *Password );
                *Password = NULL;
            }
        }
    } else {
        Status = STATUS_ACCESS_DENIED;
    }

    return Status;
}

VOID
RxUninitializeVNetRootParameters (
    IN OUT PUNICODE_STRING UserName,
    IN OUT PUNICODE_STRING UserDomain,
    IN OUT PUNICODE_STRING Password,
    IN OUT PULONG Flags
    )
/*++

Routine Description:

    This routine unintializes the parameters ( logon ) associated with  a VNetRoot

Arguments:

    VNetRoot -- the VNetRoot

--*/
{
    PAGED_CODE();

    if (UserName != NULL) {
        RxFreePool( UserName );
    }

    if (UserDomain != NULL) {
        RxFreePool( UserDomain );
    }

    if (Password != NULL) {
        RxFreePool( Password );
    }

    if (Flags) {
        ClearFlag( *Flags, VNETROOT_FLAG_CSCAGENT_INSTANCE );
    }
}

PV_NET_ROOT
RxCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PNET_ROOT NetRoot,
    IN PUNICODE_STRING CanonicalName,
    IN PUNICODE_STRING LocalNetRootName,
    IN PUNICODE_STRING FilePath,
    IN PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine builds a node representing a virtual netroot  and inserts the name into
    the net name table. The name is allocated at the end of the block. The reference
    count on the block is set to 1 on this create....

    Virtual netroots provide a mechanism for mapping "into" a share....i.e. having a
    user drive that points not at the root of the associated share point.  The format
    of a name is either

        \server\share\d1\d2.....
    or
        \;m:\server\share\d1\d2.....

    depending on whether there is a local device ("m:") associated with this vnetroot.
    In the latter case is that \d1\d2.. gets prefixed onto each createfile that is
    opened on this vnetroot.

    vnetroot's are also used to supply alternate credentials. the point of the former
    kind of vnetroot is to propagate the credentials into the netroot as the default.
    for this to work, there must be no other references.

    You need to have the lock exclusive to call....see RxCreateSrvCall.......

Arguments:

    RxContext - the RDBSS context

    NetRoot - the associated net root context

    Name - the name to be inserted

    NamePrefixOffsetInBytes - offset into the name where the prefix starts

Return Value:

    Ptr to the created v net root.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PV_NET_ROOT ThisVNetRoot;
    UNICODE_STRING VNetRootName;
    PUNICODE_STRING ThisNamePrefix;
    ULONG NameSize;
    BOOLEAN CscAgent = FALSE;

    PRX_PREFIX_ENTRY ThisEntry;

    PAGED_CODE();

    ASSERT( RxIsPrefixTableLockExclusive( RxContext->RxDeviceObject->pRxNetNameTable ) );

    NameSize = NetRoot->PrefixEntry.Prefix.Length + LocalNetRootName->Length;

    ThisVNetRoot = RxAllocateObject( RDBSS_NTC_V_NETROOT, NetRoot->SrvCall->RxDeviceObject->Dispatch,NameSize );
    if (ThisVNetRoot != NULL) {
        USHORT CaseInsensitiveLength;
        PMRX_SRV_CALL SrvCall;

        if (Status == STATUS_SUCCESS) {

            //
            //  Initialize the Create Parameters
            //

            Status = RxInitializeVNetRootParameters( RxContext,
                                                     &ThisVNetRoot->LogonId,
                                                     &ThisVNetRoot->SessionId,
                                                     &ThisVNetRoot->pUserName,
                                                     &ThisVNetRoot->pUserDomainName,
                                                     &ThisVNetRoot->pPassword,
                                                     &ThisVNetRoot->Flags );
        }

        if (Status == STATUS_SUCCESS) {

            VNetRootName = ThisVNetRoot->PrefixEntry.Prefix;

            RtlMoveMemory( VNetRootName.Buffer, CanonicalName->Buffer, VNetRootName.Length );

            ThisVNetRoot->PrefixOffsetInBytes = LocalNetRootName->Length + NetRoot->PrefixEntry.Prefix.Length;

            RxDbgTrace( +1, Dbg, ("RxVNetRootCreate-->     Name = <%wZ>, offs=%08lx\n", CanonicalName, ThisVNetRoot->PrefixOffsetInBytes) );

            ThisNamePrefix = &ThisVNetRoot->NamePrefix;
            ThisNamePrefix->Buffer = (PWCH)Add2Ptr( VNetRootName.Buffer, ThisVNetRoot->PrefixOffsetInBytes );
            ThisNamePrefix->Length =
            ThisNamePrefix->MaximumLength = VNetRootName.Length - (USHORT)ThisVNetRoot->PrefixOffsetInBytes;

            InitializeListHead( &ThisVNetRoot->TransitionWaitList );
            InitializeListHead( &ThisVNetRoot->ScavengerFinalizationList );

            //
            //  Now, insert into the netrootQ and the net name table
            //

            ThisEntry = &ThisVNetRoot->PrefixEntry;
            SrvCall = NetRoot->pSrvCall;
            if (FlagOn( SrvCall->Flags, SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES )) {

                //
                //  here is insensitive length  is the whole thing
                //

                CaseInsensitiveLength = (USHORT)NameSize;

            } else {

                //
                //  here is insensitive length is determined by the netroot or srvcall
                //  plus we have to account for the device, if present
                //

                ULONG ComponentsToUpcase;
                ULONG Length;
                ULONG i;

                if (FlagOn( SrvCall->Flags, SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS )) {
                    CaseInsensitiveLength = NetRoot->PrefixEntry.CaseInsensitiveLength;
                } else {
                    CaseInsensitiveLength = ((PSRV_CALL)SrvCall)->PrefixEntry.CaseInsensitiveLength;
                }

                Length = CanonicalName->Length / sizeof( WCHAR );

                //
                //  note: don't start at zero
                //

                for (i=1;;i++) {

                    if (i >= Length)
                        break;
                    if (CanonicalName->Buffer[i] != OBJ_NAME_PATH_SEPARATOR)
                        break;
                }
                CaseInsensitiveLength += (USHORT)(i*sizeof( WCHAR ));
            }

            RxPrefixTableInsertName( RxContext->RxDeviceObject->pRxNetNameTable,
                                     ThisEntry,
                                     (PVOID)ThisVNetRoot,
                                     &ThisVNetRoot->NodeReferenceCount,
                                     CaseInsensitiveLength,
                                     RxConnectionId );

            RxReferenceNetRoot( NetRoot );

            RxAddVirtualNetRootToNetRoot( NetRoot, ThisVNetRoot );

            ThisVNetRoot->SerialNumberForEnum = SerialNumber;
            SerialNumber += 1;
            ThisVNetRoot->UpperFinalizationDone = FALSE;
            ThisVNetRoot->ConnectionFinalizationDone = FALSE;
            ThisVNetRoot->AdditionalReferenceForDeleteFsctlTaken = 0;

            RxDbgTrace( -1, Dbg, ("RxVNetRootCreate -> RefCount = %08lx\n", ThisVNetRoot->NodeReferenceCount) );
        }

        if (Status != STATUS_SUCCESS) {
            RxUninitializeVNetRootParameters( ThisVNetRoot->pUserName,
                                              ThisVNetRoot->pUserDomainName,
                                              ThisVNetRoot->pPassword,
                                              &ThisVNetRoot->Flags );

            RxFreeObject( ThisVNetRoot );
            ThisVNetRoot = NULL;
        }
    }

    return ThisVNetRoot;
}

VOID
RxOrphanSrvOpens (
    IN PV_NET_ROOT ThisVNetRoot
    )
/*++

Routine Description:

    The routine iterates through all the FCBs that belong to the netroot to which this VNetRoot
    belongs and orphans all SrvOpens that belong to the VNetRoot. The caller must have acquired
    the NetName tablelock.

Arguments:

    ThisVNetRoot      - the VNetRoot

Return Value:
    None

Notes:

    On Entry -- RxNetNameTable lock must be acquired exclusive.

    On Exit  -- no change in lock ownership.

--*/
{
    PLIST_ENTRY ListEntry;
    USHORT BucketNumber;
    PNET_ROOT NetRoot = (PNET_ROOT)(ThisVNetRoot->NetRoot);
    PRX_PREFIX_TABLE  RxNetNameTable = NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;


    PAGED_CODE();

    //
    //  MAILSLOT FCBs don't have SrvOpens
    //

    if(NetRoot->Type == NET_ROOT_MAILSLOT) return;

    ASSERT( RxIsPrefixTableLockExclusive( RxNetNameTable ) );

    RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );

    try {
        for (BucketNumber = 0;
             (BucketNumber < NetRoot->FcbTable.NumberOfBuckets);
             BucketNumber++) {

            PLIST_ENTRY ListHead;

            ListHead = &NetRoot->FcbTable.HashBuckets[BucketNumber];

            ListEntry = ListHead->Flink;

            while (ListEntry != ListHead) {

                PFCB Fcb;
                PRX_FCB_TABLE_ENTRY FcbTableEntry;

                FcbTableEntry = CONTAINING_RECORD( ListEntry, RX_FCB_TABLE_ENTRY, HashLinks );
                Fcb = CONTAINING_RECORD( FcbTableEntry, FCB, FcbTableEntry );

                ASSERT( NodeTypeIsFcb( Fcb ) );

                //
                //  don't force orphan the FCB
                //  orphan only those srvopens
                //  that belong to this VNetRoot
                //

                ListEntry = ListEntry->Flink;

                RxOrphanSrvOpensForThisFcb( Fcb, ThisVNetRoot, FALSE );
            }
        }

        if (NetRoot->FcbTable.TableEntryForNull) {
            PFCB Fcb;

            Fcb = CONTAINING_RECORD( NetRoot->FcbTable.TableEntryForNull, FCB, FcbTableEntry );
            ASSERT( NodeTypeIsFcb( Fcb ) );

            RxOrphanSrvOpensForThisFcb( Fcb, ThisVNetRoot, FALSE );
        }
    } finally {
        RxReleaseFcbTableLock( &NetRoot->FcbTable );
    }
}



BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given netroot. You must be exclusive on
    the NetName tablelock.

Arguments:

    ThisVNetRoot      - the VNetRoot being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN NodeActuallyFinalized = FALSE;
    PRX_PREFIX_TABLE RxNetNameTable;

    PAGED_CODE();

    ASSERT( NodeType( ThisVNetRoot ) == RDBSS_NTC_V_NETROOT );
    RxNetNameTable = ThisVNetRoot->NetRoot->SrvCall->RxDeviceObject->pRxNetNameTable;
    ASSERT( RxIsPrefixTableLockExclusive ( RxNetNameTable ) );

    RxDbgTrace( +1, Dbg, ("RxFinalizeVNetRoot<+> %08lx %wZ RefC=%ld\n", ThisVNetRoot,&ThisVNetRoot->PrefixEntry.Prefix, ThisVNetRoot->NodeReferenceCount) );

    //
    //  The actual finalization is divided into two parts:
    //    1) if we're at the end (refcount==1) or being forced, we do the one-time only stuff
    //    2) if the refcount goes to zero, we actually do the free
    //

    if ((ThisVNetRoot->NodeReferenceCount == 1)  || ForceFinalize) {

        PNET_ROOT NetRoot = (PNET_ROOT)ThisVNetRoot->NetRoot;

        RxLog(( "*FINALVNETROOT: %lx  %wZ\n", ThisVNetRoot, &ThisVNetRoot->PrefixEntry.Prefix ));
        RxWmiLog( LOG,
                  RxFinalizeVNetRoot,
                  LOGPTR( ThisVNetRoot )
                  LOGUSTR( ThisVNetRoot->PrefixEntry.Prefix ) );

        if (!ThisVNetRoot->UpperFinalizationDone) {

            ASSERT( NodeType( NetRoot ) == RDBSS_NTC_NETROOT );

            RxReferenceNetRoot( NetRoot );
            RxOrphanSrvOpens( ThisVNetRoot );
            RxRemoveVirtualNetRootFromNetRoot( NetRoot, ThisVNetRoot );

            RxDereferenceNetRoot( NetRoot, LHS_ExclusiveLockHeld );

            RxDbgTrace( 0, Dbg, ("Mini Rdr VNetRoot finalization returned %lx\n", Status) );

            RxRemovePrefixTableEntry ( RxNetNameTable, &ThisVNetRoot->PrefixEntry );
            ThisVNetRoot->UpperFinalizationDone = TRUE;
        }

        if (ThisVNetRoot->NodeReferenceCount == 1) {
            if (NetRoot->SrvCall->RxDeviceObject != NULL) {
                MINIRDR_CALL_THROUGH( Status,
                                      NetRoot->SrvCall->RxDeviceObject->Dispatch,
                                      MRxFinalizeVNetRoot,((PMRX_V_NET_ROOT)ThisVNetRoot, NULL) );
            }

            RxUninitializeVNetRootParameters( ThisVNetRoot->pUserName,
                                              ThisVNetRoot->pUserDomainName,
                                              ThisVNetRoot->pPassword,
                                              &ThisVNetRoot->Flags );
            RxDereferenceNetRoot( NetRoot, LHS_ExclusiveLockHeld );
            RxFreePool( ThisVNetRoot );
            NodeActuallyFinalized = TRUE;
        }
    } else {
        RxDbgTrace( 0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!') );
    }

    RxDbgTrace( -1, Dbg, ("RxFinalizeVNetRoot<-> %08lx\n", ThisVNetRoot, NodeActuallyFinalized) );
    return NodeActuallyFinalized;
}

PVOID
RxAllocateFcbObject (
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE NodeType,
    POOL_TYPE PoolType,
    ULONG NameSize,
    PVOID Object OPTIONAL
    )
/*++

Routine Description:

    The routine allocates and constructs the skeleton of a FCB/SRV_OPEN and FOBX instance

Arguments:

    MRxDispatch - the Mini redirector dispatch vector

    NodeType     - the node type

    PoolType     - the pool type to be used ( for paging file data structures NonPagedPool is
                   used.

    NameLength   - name size.

    Object       - if non null a preallocated fcb/srvopen etc which just needs to be initialized

Notes:

    The reasons as to why the allocation/freeing of these data structures have been
    centralized are as follows

      1) The construction of these three data types have a lot in common with the exception
      of the initial computation of sizes. Therefore centralization minimizes the footprint.

      2) It allows us to experiment with different clustering/allocation strategies.

      3) It allows the incorporation of debug support in an easy way.

--*/
{
    ULONG FcbSize = 0;
    ULONG NonPagedFcbSize = 0;
    ULONG SrvOpenSize = 0;
    ULONG FobxSize = 0;

    PMINIRDR_DISPATCH MRxDispatch = RxDeviceObject->Dispatch;

    PNON_PAGED_FCB NonPagedFcb = NULL;
    PFCB Fcb  = NULL;
    PSRV_OPEN SrvOpen = NULL;
    PFOBX Fobx = NULL;
    PWCH Name = NULL;

    PAGED_CODE();

    switch (NodeType) {

    default:

        FcbSize = QuadAlign( sizeof( FCB ) );

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_FCB_EXTENSION )) {
            FcbSize += QuadAlign( MRxDispatch->MRxFcbSize );
        }

        if (PoolType == NonPagedPool) {
            NonPagedFcbSize = QuadAlign( sizeof( NON_PAGED_FCB ) );
        }

        if (NodeType == RDBSS_NTC_OPENTARGETDIR_FCB) {
            break;
        }

        //
        //  lack of break intentional
        //

    case RDBSS_NTC_SRVOPEN:
    case RDBSS_NTC_INTERNAL_SRVOPEN:

        SrvOpenSize = QuadAlign( sizeof( SRV_OPEN ) );

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_SRV_OPEN_EXTENSION )) {
            SrvOpenSize += QuadAlign( MRxDispatch->MRxSrvOpenSize );
        }

        //
        //  lack of break intentional
        //

    case RDBSS_NTC_FOBX:

        FobxSize = QuadAlign( sizeof( FOBX ) );

        if (FlagOn( MRxDispatch->MRxFlags,  RDBSS_MANAGE_FOBX_EXTENSION )) {
            FobxSize += QuadAlign( MRxDispatch->MRxFobxSize );
        }
    }

    if (Object == NULL) {

        Object = RxAllocatePoolWithTag( PoolType, (FcbSize + SrvOpenSize + FobxSize + NonPagedFcbSize + NameSize), RX_FCB_POOLTAG );
        if (Object == NULL) {
            return NULL;
        }
    }

    switch (NodeType) {

    case RDBSS_NTC_FOBX:
        Fobx = (PFOBX)Object;
        break;

    case RDBSS_NTC_SRVOPEN:

        SrvOpen = (PSRV_OPEN)Object;
        Fobx = (PFOBX)Add2Ptr( SrvOpen, SrvOpenSize );
        break;

    case RDBSS_NTC_INTERNAL_SRVOPEN:

        SrvOpen = (PSRV_OPEN)Object;
        break;

    default :

        Fcb = (PFCB)Object;
        if (NodeType != RDBSS_NTC_OPENTARGETDIR_FCB) {
            SrvOpen = (PSRV_OPEN)Add2Ptr( Fcb, FcbSize );
            Fobx = (PFOBX)Add2Ptr( SrvOpen, SrvOpenSize );
        }

        if (PoolType == NonPagedPool) {

            NonPagedFcb = (PNON_PAGED_FCB)Add2Ptr( Fobx, FobxSize );
            Name = (PWCH)Add2Ptr( NonPagedFcb, NonPagedFcbSize );
        } else {
            Name = (PWCH)Add2Ptr( Fcb, FcbSize + SrvOpenSize + FobxSize );
            NonPagedFcb = RxAllocatePoolWithTag( NonPagedPool, sizeof( NON_PAGED_FCB ), RX_NONPAGEDFCB_POOLTAG );

            if (NonPagedFcb == NULL) {
                RxFreePool( Fcb );
                return NULL;
            }
        }
        break;
    }

    if (Fcb != NULL) {

        ZeroAndInitializeNodeType( Fcb, RDBSS_NTC_STORAGE_TYPE_UNKNOWN, (NODE_BYTE_SIZE) FcbSize );

        Fcb->NonPaged = NonPagedFcb;
        ZeroAndInitializeNodeType( Fcb->NonPaged, RDBSS_NTC_NONPAGED_FCB, ((NODE_BYTE_SIZE) sizeof( NON_PAGED_FCB )) );


#if DBG

        //
        //  For debugging make a copy of NonPaged so we can zap the real pointer and still find it
        //

        Fcb->CopyOfNonPaged = NonPagedFcb;
        NonPagedFcb->FcbBackPointer = Fcb;

#endif

        //
        //  Set up  the pointers to the preallocated SRV_OPEN and FOBX if required
        //

        Fcb->InternalSrvOpen = SrvOpen;
        Fcb->InternalFobx = Fobx;

        Fcb->PrivateAlreadyPrefixedName.Buffer = Name;
        Fcb->PrivateAlreadyPrefixedName.Length = (USHORT)NameSize;
        Fcb->PrivateAlreadyPrefixedName.MaximumLength = Fcb->PrivateAlreadyPrefixedName.Length;

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_FCB_EXTENSION )) {
            Fcb->Context = Add2Ptr( Fcb, QuadAlign( sizeof( FCB ) ) );
        }

        ZeroAndInitializeNodeType( &Fcb->FcbTableEntry, RDBSS_NTC_FCB_TABLE_ENTRY, sizeof( RX_FCB_TABLE_ENTRY ) );

        InterlockedIncrement( &RxNumberOfActiveFcbs );
        InterlockedIncrement( &RxDeviceObject->NumberOfActiveFcbs );

        //
        //  Initialize the Advanced FCB header
        //

        ExInitializeFastMutex( &NonPagedFcb->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &Fcb->Header, &NonPagedFcb->AdvancedFcbHeaderMutex );
    }

    if (SrvOpen != NULL) {

        ZeroAndInitializeNodeType( SrvOpen, RDBSS_NTC_SRVOPEN, (NODE_BYTE_SIZE)SrvOpenSize );

        if (NodeType != RDBSS_NTC_SRVOPEN) {

            //
            //  here the srvopen has no internal fobx....set the "used" flag
            //

            SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_FOBX_USED );
            SrvOpen->InternalFobx = NULL;

        } else {
            SrvOpen->InternalFobx = Fobx;
        }

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_SRV_OPEN_EXTENSION )) {
            SrvOpen->Context = Add2Ptr( SrvOpen, QuadAlign( sizeof( SRV_OPEN )) );
        }

        InitializeListHead( &SrvOpen->SrvOpenQLinks );
    }

    if (Fobx != NULL) {

        ZeroAndInitializeNodeType( Fobx, RDBSS_NTC_FOBX, (NODE_BYTE_SIZE)FobxSize );

        if (FlagOn( MRxDispatch->MRxFlags, RDBSS_MANAGE_FOBX_EXTENSION )) {
            Fobx->Context = Add2Ptr( Fobx, QuadAlign( sizeof( FOBX )) );
        }
    }

    return Object;
}



VOID
RxFreeFcbObject (
    PVOID Object
    )
/*++

Routine Description:

    The routine frees  a FCB/SRV_OPEN and FOBX instance

Arguments:

    Object      - the instance to be freed

Notes:

--*/
{
    PAGED_CODE();

    switch (NodeType( Object )) {

    case RDBSS_NTC_FOBX:
    case RDBSS_NTC_SRVOPEN:

        RxFreePool(Object);
        break;

    default:
        if (NodeTypeIsFcb( Object )) {

            PFCB Fcb = (PFCB)Object;
            PRDBSS_DEVICE_OBJECT RxDeviceObject = Fcb->RxDeviceObject;

            //
            //  Release any Filter Context structures associated with this structure
            //

            if (RxTeardownPerStreamContexts) {
                RxTeardownPerStreamContexts( &Fcb->Header );
            }

#if DBG
            SetFlag( Fcb->Header.NodeTypeCode, 0x1000 );
#endif

            if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
                RxFreePool( Fcb->NonPaged );
            }
            RxFreePool( Fcb );

            InterlockedDecrement( &RxNumberOfActiveFcbs );
            InterlockedDecrement( &RxDeviceObject->NumberOfActiveFcbs );
        }
    }
}

PFCB
RxCreateNetFcb (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PV_NET_ROOT VNetRoot,
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures. The structure allocated has space for a srvopen
    and a fobx. The size for all these things comes from the net root; they have
    already been aligned.

    An additional complication is that i use the same routine to initialize a
    fake fcb for renames. in this case, i don't want it inserted into the tree.
    You get a fake FCB with IrpSp->Flags|SL_OPEN_TAGET_DIRECTORY.

Arguments:

    RxContext - an RxContext describing a create............

    NetRoot - the net root that this FCB is being opened on

    Name - The name of the FCB. the netroot MAY contain a nameprefix that is to be prepended here.

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/
{
    PFCB Fcb;

    POOL_TYPE PoolType;
    NODE_TYPE_CODE NodeType;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    BOOLEAN IsPagingFile;
    BOOLEAN FakeFcb;

    PNET_ROOT NetRoot;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PRX_FCB_TABLE_ENTRY ThisEntry;

    ULONG NameSize;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCreateNetFcb\n", 0) );

    ASSERT( VNetRoot && (NodeType( VNetRoot ) == RDBSS_NTC_V_NETROOT) );
    NetRoot = VNetRoot->NetRoot;
    ASSERT( NodeType( NetRoot ) == RDBSS_NTC_NETROOT );
    ASSERT( ((PMRX_NET_ROOT)NetRoot) == RxContext->Create.pNetRoot );

    RxDeviceObject = NetRoot->SrvCall->RxDeviceObject;
    ASSERT( RxDeviceObject == RxContext->RxDeviceObject );

    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    IsPagingFile = BooleanFlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE );
    FakeFcb = (BooleanFlagOn( IrpSp->Flags,SL_OPEN_TARGET_DIRECTORY) &&
               !BooleanFlagOn(NetRoot->Flags,NETROOT_FLAG_SUPPORTS_SYMBOLIC_LINKS));

    ASSERT( FakeFcb || RxIsFcbTableLockExclusive ( &NetRoot->FcbTable ) );

    if (FakeFcb) {
        NodeType = RDBSS_NTC_OPENTARGETDIR_FCB;
    } else {
        NodeType = RDBSS_NTC_STORAGE_TYPE_UNKNOWN;
    }

    if (IsPagingFile) {
        PoolType = NonPagedPool;
    } else {
        PoolType = PagedPool;
    }

    NameSize = Name->Length + NetRoot->InnerNamePrefix.Length;

    Fcb = RxAllocateFcbObject( RxDeviceObject, NodeType, PoolType, NameSize, NULL );

    if (Fcb != NULL) {

        Fcb->CachedNetRootType = NetRoot->Type;
        Fcb->RxDeviceObject = RxDeviceObject;
        Fcb->MRxDispatch    = RxDeviceObject->Dispatch;
        Fcb->MRxFastIoDispatch = NULL;

        Fcb->VNetRoot = VNetRoot;
        Fcb->NetRoot = VNetRoot->NetRoot;

        InitializeListHead( &Fcb->SrvOpenList );

        Fcb->SrvOpenListVersion = 0;

        Fcb->FcbTableEntry.Path.Buffer = (PWCH)Add2Ptr( Fcb->PrivateAlreadyPrefixedName.Buffer, NetRoot->InnerNamePrefix.Length );

        Fcb->FcbTableEntry.Path.Length = Name->Length;
        Fcb->FcbTableEntry.Path.MaximumLength = Name->Length;

        //
        //  finally, copy in the name, including the netroot prefix
        //

        ThisEntry = &Fcb->FcbTableEntry;

        RxDbgTrace( 0, Dbg, ("RxCreateNetFcb name buffer/length %08lx/%08lx\n",
                        ThisEntry->Path.Buffer, ThisEntry->Path.Length) );
        RxDbgTrace( 0, Dbg, ("RxCreateNetFcb  prefix/name %wZ/%wZ\n",
                        &NetRoot->InnerNamePrefix, Name) );

        RtlMoveMemory( Fcb->PrivateAlreadyPrefixedName.Buffer,
                       NetRoot->InnerNamePrefix.Buffer,
                       NetRoot->InnerNamePrefix.Length );

        RtlMoveMemory( ThisEntry->Path.Buffer,
                       Name->Buffer,
                       Name->Length );

        RxDbgTrace( 0, Dbg, ("RxCreateNetFcb  apname %wZ\n", &Fcb->PrivateAlreadyPrefixedName) );
        RxDbgTrace( 0, Dbg, ("RxCreateNetFcb  finalname %wZ\n", &Fcb->FcbTableEntry.Path) );

        if (FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH )) {
            SetFlag( Fcb->FcbState,FCB_STATE_ADDEDBACKSLASH );
        }

        InitializeListHead( &Fcb->NonPaged->TransitionWaitList );

        //
        //  Check to see if we need to set the Fcb state to indicate that this
        //  is a paging file
        //

        if (IsPagingFile) {
            SetFlag( Fcb->FcbState, FCB_STATE_PAGING_FILE );
        }

        //
        //  Check to see whether this was marked for reparse
        //

        if (FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_SPECIAL_PATH )) {
            SetFlag( Fcb->FcbState, FCB_STATE_SPECIAL_PATH );
        }

        ///
        //  The initial state, open count, and segment objects fields are already
        //  zero so we can skip setting them
        //

        //
        //  Initialize the resources
        //

        Fcb->Header.Resource = &Fcb->NonPaged->HeaderResource;
        ExInitializeResourceLite( Fcb->Header.Resource );
        Fcb->Header.PagingIoResource = &Fcb->NonPaged->PagingIoResource;
        ExInitializeResourceLite( Fcb->Header.PagingIoResource );

        //
        //  Initialize the filesize lock
        //

#ifdef USE_FILESIZE_LOCK

        Fcb->FileSizeLock = &Fcb->NonPaged->FileSizeLock;
        ExInitializeFastMutex( Fcb->FileSizeLock );

#endif

        if (!FakeFcb) {

            //
            //  everything worked.... insert into netroot table
            //

            RxFcbTableInsertFcb( &NetRoot->FcbTable, Fcb );

        } else {

            SetFlag( Fcb->FcbState, FCB_STATE_FAKEFCB | FCB_STATE_NAME_ALREADY_REMOVED );
            InitializeListHead( &Fcb->FcbTableEntry.HashLinks );
            RxLog(( "FakeFinally %lx\n", RxContext ));
            RxWmiLog( LOG,
                      RxCreateNetFcb_1,
                      LOGPTR( RxContext ) );
            RxDbgTrace( 0, Dbg, ("FakeFcb !!!!!!! Irpc=%08lx\n", RxContext) );
        }

        RxReferenceVNetRoot( VNetRoot );
        InterlockedIncrement( &Fcb->NetRoot->NumberOfFcbs );
        Fcb->ulFileSizeVersion=0;

#ifdef RDBSSLOG
        RxLog(("Fcb nm %lx %wZ",Fcb,&(Fcb->FcbTableEntry.Path)));
        RxWmiLog(LOG,
                 RxCreateNetFcb_2,
                 LOGPTR(Fcb)
                 LOGUSTR(Fcb->FcbTableEntry.Path));
        {
            char buffer[20];
            ULONG len,remaining;
            UNICODE_STRING jPrefix,jSuffix;
            sprintf(buffer,"Fxx nm %p ",Fcb);
            len = strlen(buffer);
            remaining = MAX_RX_LOG_ENTRY_SIZE -1 - len;
            if (remaining<Fcb->FcbTableEntry.Path.Length) {
                jPrefix.Buffer = Fcb->FcbTableEntry.Path.Buffer;
                jPrefix.Length = (USHORT)(sizeof(WCHAR)*(remaining-17));
                jSuffix.Buffer = Fcb->FcbTableEntry.Path.Buffer-15+(Fcb->FcbTableEntry.Path.Length/sizeof(WCHAR));
                jSuffix.Length = sizeof(WCHAR)*15;
                RxLog(("%s%wZ..%wZ",buffer,&jPrefix,&jSuffix));
                RxWmiLog(LOG,
                         RxCreateNetFcb_3,
                         LOGARSTR(buffer)
                         LOGUSTR(jPrefix)
                         LOGUSTR(jSuffix));
            }
        }
#endif

        RxLoudFcbMsg( "Create: ", &(Fcb->FcbTableEntry.Path) );
        RxDbgTrace( 0, Dbg, ("RxCreateNetFcb nm.iso.ifox  %08lx  %08lx %08lx\n",
                        Fcb->FcbTableEntry.Path.Buffer, Fcb->InternalSrvOpen, Fcb->InternalFobx) );
        RxDbgTrace( -1, Dbg, ("RxCreateNetFcb  %08lx  %wZ\n", Fcb, &(Fcb->FcbTableEntry.Path)) );
    }

    if (Fcb != NULL) {
        RxReferenceNetFcb( Fcb );

#ifdef RX_WJ_DBG_SUPPORT
        RxdInitializeFcbWriteJournalDebugSupport( Fcb );
#endif
    }

    return Fcb;
}

RX_FILE_TYPE
RxInferFileType (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine tries to infer the filetype from the createoptions.

Arguments:

    RxContext      - the context of the Open

Return Value:

    the storagetype implied by the open.

--*/
{
    ULONG CreateOptions = RxContext->Create.NtCreateParameters.CreateOptions;

    PAGED_CODE();

    switch (FlagOn( CreateOptions, (FILE_DIRECTORY_FILE|FILE_NON_DIRECTORY_FILE ) )) {

    case FILE_DIRECTORY_FILE:
        return FileTypeDirectory;

    case FILE_NON_DIRECTORY_FILE:
        return FileTypeFile;

    default:
    case 0:
        return FileTypeNotYetKnown;  //0 => i don't know the storage type
    }
}

VOID
RxFinishFcbInitialization (
    IN OUT PMRX_FCB MrxFcb,
    IN RDBSS_STORAGE_TYPE_CODES RdbssStorageType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    )
/*++

Routine Description:

    This routine is used to finish initializing an FCB after
    we find out what kind it is.

Arguments:

    Fcb      - the Fcb being initialzed

    StorageType - the type of entity that the FCB refers to

    InitPacket - extra data that is required depending on the type of entity

Return Value:

    none.

--*/
{
    PFCB Fcb = (PFCB)MrxFcb;
    USHORT OldStorageType;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxFcbInit %x  %08lx  %wZ\n", RdbssStorageType, Fcb, &(Fcb->FcbTableEntry.Path)) );
    OldStorageType = Fcb->Header.NodeTypeCode;
    Fcb->Header.NodeTypeCode =  (CSHORT)RdbssStorageType;

    //
    //  only update the information in the Fcb if it's not already set
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_TIME_AND_SIZE_ALREADY_SET )) {

        if (InitPacket != NULL) {

            Fcb->Attributes = *(InitPacket->pAttributes);
            Fcb->NumberOfLinks = *(InitPacket->pNumLinks);
            Fcb->CreationTime = *(InitPacket-> pCreationTime);
            Fcb->LastAccessTime  = *(InitPacket->pLastAccessTime);
            Fcb->LastWriteTime  = *(InitPacket->pLastWriteTime);
            Fcb->LastChangeTime  = *(InitPacket->pLastChangeTime);
            Fcb->ActualAllocationLength  = InitPacket->pAllocationSize->QuadPart;
            Fcb->Header.AllocationSize  = *(InitPacket->pAllocationSize);
            Fcb->Header.FileSize  = *(InitPacket->pFileSize);
            Fcb->Header.ValidDataLength  = *(InitPacket->pValidDataLength);

            SetFlag( Fcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET );
        }
    } else {

        if (RdbssStorageType == RDBSS_NTC_MAILSLOT){

            Fcb->Attributes = 0;
            Fcb->NumberOfLinks = 0;
            Fcb->CreationTime.QuadPart =  0;
            Fcb->LastAccessTime.QuadPart  = 0;
            Fcb->LastWriteTime.QuadPart  = 0;
            Fcb->LastChangeTime.QuadPart  = 0;
            Fcb->ActualAllocationLength  = 0;
            Fcb->Header.AllocationSize.QuadPart  = 0;
            Fcb->Header.FileSize.QuadPart  = 0;
            Fcb->Header.ValidDataLength.QuadPart  = 0;

            SetFlag( Fcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET );
        }
    }

    switch (RdbssStorageType) {
    case RDBSS_NTC_MAILSLOT:
    case RDBSS_NTC_SPOOLFILE:
        break;

    case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
    case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        break;

    case RDBSS_NTC_STORAGE_TYPE_FILE:

        if (OldStorageType == RDBSS_NTC_STORAGE_TYPE_FILE) break;

        RxInitializeLowIoPerFcbInfo( &Fcb->LowIoPerFcbInfo );

        FsRtlInitializeFileLock( &Fcb->FileLock,
                                 RxLockOperationCompletion,
                                 RxUnlockOperation );

        //
        //  Indicate that we want to be consulted on whether Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FastIoIsQuestionable;
        break;


    default:
        ASSERT( FALSE );
        break;
    }

    return;
}

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    )
/*++

Routine Description:

    The routine removes the name from the table and sets a flag indicateing
    that it has done so. You must have already acquired the netroot
    tablelock and have the fcblock as well.

Arguments:

    ThisFcb      - the Fcb being dereferenced

Return Value:

    none.

--*/
{
    PNET_ROOT NetRoot;

    PAGED_CODE();
    RxDbgTrace( +1, Dbg, ("RxRemoveNameNetFcb<+> %08lx %wZ RefC=%ld\n", ThisFcb, &ThisFcb->FcbTableEntry.Path, ThisFcb->NodeReferenceCount) );

    ASSERT( NodeTypeIsFcb( ThisFcb ) );

    NetRoot = ThisFcb->VNetRoot->NetRoot;

    ASSERT( RxIsFcbTableLockExclusive( &NetRoot->FcbTable ) );
    ASSERT( RxIsFcbAcquiredExclusive( ThisFcb ) );

    RxFcbTableRemoveFcb( &NetRoot->FcbTable, ThisFcb );

    RxLoudFcbMsg( "RemoveName: ", &(ThisFcb->FcbTableEntry.Path) );

    SetFlag( ThisFcb->FcbState, FCB_STATE_NAME_ALREADY_REMOVED );

    RxDbgTrace( -1, Dbg, ("RxRemoveNameNetFcb<-> %08lx\n", ThisFcb) );
}

VOID
RxPurgeFcb (
    PFCB Fcb
    )
/*++

Routine Description:

    The routine purges a given FCB instance. If the FCB has an open section
    against it caused by cacheing the file then we need to purge to get
    the close

Arguments:

    Fcb      - the Fcb being dereferenced

Notes:

    On Entry to this routine the FCB must be accquired exclusive.

    On Exit the FCB resource will be released and the FCB finalized if possible

--*/
{
    PAGED_CODE();

    ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

    //
    //  make sure that it doesn't disappear
    //

    RxReferenceNetFcb( Fcb );

    if (Fcb->OpenCount) {

        RxPurgeFcbInSystemCache( Fcb,
                                 NULL,
                                 0,
                                 TRUE,
                                 TRUE );
    }

    if (!RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE )) {

        //
        //  if it remains then release the fcb
        //

        RxReleaseFcb( NULL, Fcb );
    }
}

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize,
    IN LONG ReferenceCount
    )
/*++

Routine Description:

    The routine finalizes the given Fcb. This routine needs
    the netroot tablelock; get it beforehand.

Arguments:

    ThisFcb      - the Fcb being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

--*/
{
    BOOLEAN NodeActuallyFinalized = FALSE;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxFinalizeNetFcb<+> %08lx %wZ RefC=%ld\n", ThisFcb,&ThisFcb->FcbTableEntry.Path, ReferenceCount) );
    RxLoudFcbMsg( "Finalize: ",&(ThisFcb->FcbTableEntry.Path) );

    ASSERT_CORRECT_FCB_STRUCTURE( ThisFcb );

    ASSERT( RxIsFcbAcquiredExclusive( ThisFcb ) );
    ASSERT( !ForceFinalize );

    if (!RecursiveFinalize) {

        if ((ThisFcb->OpenCount != 0) || (ThisFcb->UncleanCount != 0)) {

            //
            //  The FCB cannot be finalized because there are outstanding refrences to it.
            //

            ASSERT( ReferenceCount > 0 );
            return NodeActuallyFinalized;
        }
    } else {
        PSRV_OPEN SrvOpen;
        PLIST_ENTRY ListEntry;

#if 0
        if (ReferenceCount) {
            RxDbgTrace( 0, Dbg, ("    BAD!!!!!ReferenceCount = %08lx\n", ReferenceCount) );
        }
#endif

        ListEntry = ThisFcb->SrvOpenList.Flink;
        while (ListEntry != &ThisFcb->SrvOpenList) {
            SrvOpen = CONTAINING_RECORD( ListEntry, SRV_OPEN, SrvOpenQLinks );
            ListEntry = ListEntry->Flink;
            RxFinalizeSrvOpen( SrvOpen, TRUE, ForceFinalize );
        }
    }

    RxDbgTrace( 0, Dbg, ("   After Recursive Part, REfC=%lx\n", ReferenceCount) );

    //
    //  After the recursive finalization the reference count associated with the FCB
    //  could be atmost 1 for further finalization to occur. This final reference count
    //  belongs to the prefix name table of the NetRoot.
    //

    //
    //  The actual finalization is divided into two parts:
    //    1) if we're at the end (refcount==1) or being forced, we do the one-time only stuff
    //    2) if the refcount goes to zero, we actually do the free
    //

    ASSERT( ReferenceCount >= 1 );
    if ((ReferenceCount == 1) || ForceFinalize ) {

        PV_NET_ROOT VNetRoot = ThisFcb->VNetRoot;

        ASSERT( ForceFinalize ||
                (ThisFcb->OpenCount == 0) && (ThisFcb->UncleanCount == 0));

        RxLog(( "FinalFcb %lx %lx %lx %lx", ThisFcb, ForceFinalize, ReferenceCount, ThisFcb->OpenCount ));
        RxWmiLog( LOG,
                  RxFinalizeNetFcb,
                  LOGPTR( ThisFcb )
                  LOGUCHAR( ForceFinalize )
                  LOGULONG( ReferenceCount )
                  LOGULONG( ThisFcb->OpenCount ) );

        RxDbgTrace( 0, Dbg, ("   Before Phase 1, REfC=%lx\n", ReferenceCount) );
        if (!ThisFcb->UpperFinalizationDone) {

            switch (NodeType( ThisFcb )) {

            case RDBSS_NTC_STORAGE_TYPE_FILE:
                FsRtlUninitializeFileLock( &ThisFcb->FileLock );
                break;

            default:
                break;
            }

            if (!FlagOn( ThisFcb->FcbState,FCB_STATE_ORPHANED )) {

                PNET_ROOT NetRoot = VNetRoot->NetRoot;

                ASSERT( RxIsFcbTableLockExclusive ( &NetRoot->FcbTable ) );

                if (!FlagOn( ThisFcb->FcbState, FCB_STATE_NAME_ALREADY_REMOVED )){
                    RxFcbTableRemoveFcb( &NetRoot->FcbTable, ThisFcb );
                }
            }

            RxDbgTrace( 0, Dbg, ("   EndOf  Phase 1, REfC=%lx\n", ReferenceCount) );
            ThisFcb->UpperFinalizationDone = TRUE;
        }

        RxDbgTrace( 0, Dbg, ("   After  Phase 1, REfC=%lx\n", ReferenceCount) );
        ASSERT( ReferenceCount >= 1 );
        if (ReferenceCount == 1) {

            if (ThisFcb->pBufferingStateChangeCompletedEvent != NULL) {
                RxFreePool( ThisFcb->pBufferingStateChangeCompletedEvent );
            }

            if (ThisFcb->MRxDispatch != NULL) {
                ThisFcb->MRxDispatch->MRxDeallocateForFcb( (PMRX_FCB)ThisFcb );
            }

#if DBG
            ClearFlag( ThisFcb->NonPaged->NodeTypeCode, 0x4000 );
#endif

            ExDeleteResourceLite( ThisFcb->Header.Resource );
            ExDeleteResourceLite( ThisFcb->Header.PagingIoResource );

            InterlockedDecrement( &ThisFcb->NetRoot->NumberOfFcbs );
            RxDereferenceVNetRoot( VNetRoot,LHS_LockNotHeld );

            ASSERT( IsListEmpty( &ThisFcb->FcbTableEntry.HashLinks ) );

#ifdef RX_WJ_DBG_SUPPORT
            RxdTearDownFcbWriteJournalDebugSupport( ThisFcb );
#endif

            NodeActuallyFinalized = TRUE;
            ASSERT( !ThisFcb->fMiniInited );
            RxFreeFcbObject( ThisFcb );
        }


    } else {
        RxDbgTrace( 0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!') );
    }

    RxDbgTrace( -1, Dbg, ("RxFinalizeNetFcb<-> %08lx\n", ThisFcb, NodeActuallyFinalized) );

    return NodeActuallyFinalized;
}

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN PLONGLONG FileSize
    )
/*++

Routine Description:

    This routine sets the filesize in the fcb header, taking a lock to ensure
    that the 64-bit value is set and read consistently.

Arguments:

    Fcb        - the associated fcb

    FileSize   - ptr to the new filesize

Return Value:

    none

Notes:

--*/
{
    PAGED_CODE();

#ifdef USE_FILESIZE_LOCK
    RxAcquireFileSizeLock( Fcb );
#endif

    Fcb->Header.FileSize.QuadPart = *FileSize;
    Fcb->ulFileSizeVersion += 1;

#ifdef USE_FILESIZE_LOCK
    RxReleaseFileSizeLock( Fcb );
#endif

}


VOID
RxGetFileSizeWithLock (
    IN     PFCB Fcb,
    OUT    PLONGLONG FileSize
    )
/*++

Routine Description:

    This routine gets the filesize in the fcb header, taking a lock to ensure
    that the 64-bit value is set and read consistently.

Arguments:

    Fcb        - the associated fcb

    FileSize   - ptr to the new filesize

Return Value:

    none

Notes:

--*/
{
    PAGED_CODE();

#ifdef USE_FILESIZE_LOCK
    RxAcquireFileSizeLock( Fcb );
#endif

    *FileSize = Fcb->Header.FileSize.QuadPart;

#ifdef USE_FILESIZE_LOCK
    RxReleaseFileSizeLock( Fcb );
#endif
}



PSRV_OPEN
RxCreateSrvOpen (
    IN PV_NET_ROOT VNetRoot,
    IN OUT PFCB Fcb
    )
/*++

Routine Description:

    This routine allocates, initializes, and inserts a new srv_open record into
    the in memory data structures. If a new structure has to be allocated, it
    has space for a fobx. This routine sets the refcount to 1 and leaves the
    srv_open in Condition_InTransition.

Arguments:

    VNetRoot  - the V_NET_ROOT instance

    Fcb        - the associated fcb

Return Value:

    the new SRV_OPEN instance

Notes:

    On Entry : The FCB associated with the SRV_OPEN must have been acquired exclusive

    On Exit  : No change in resource ownership

--*/
{
    PSRV_OPEN SrvOpen = NULL;
    PNET_ROOT NetRoot;
    POOL_TYPE PoolType;
    ULONG SrvOpenFlags;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCreateNetSrvOpen\n", 0) );

    ASSERT( NodeTypeIsFcb( Fcb ) );
    ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

    NetRoot = Fcb->VNetRoot->NetRoot;

    try {

        if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
            PoolType = NonPagedPool;
        } else {
            PoolType = PagedPool;
        }
        SrvOpen = Fcb->InternalSrvOpen;

        //
        //  Check if we need to allocate a new structure
        //

        if ((SrvOpen != NULL) &&
            !(FlagOn( Fcb->FcbState, FCB_STATE_SRVOPEN_USED )) &&
            !(FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_ENCLOSED_ALLOCATED )) &&
            IsListEmpty( &SrvOpen->SrvOpenQLinks )) {

            //
            //  this call just initializes the already allocated SrvOpen
            //

            RxAllocateFcbObject( NetRoot->SrvCall->RxDeviceObject,
                                 RDBSS_NTC_INTERNAL_SRVOPEN,
                                 PoolType,
                                 0,
                                 SrvOpen );

            SetFlag( Fcb->FcbState,FCB_STATE_SRVOPEN_USED );
            SrvOpenFlags = SRVOPEN_FLAG_FOBX_USED | SRVOPEN_FLAG_ENCLOSED_ALLOCATED;

        } else {

            SrvOpen  = RxAllocateFcbObject( NetRoot->SrvCall->RxDeviceObject,
                                            RDBSS_NTC_SRVOPEN,
                                            PoolType,
                                            0,
                                            NULL );
            SrvOpenFlags = 0;
        }

        if (SrvOpen != NULL) {

            SrvOpen->Flags = SrvOpenFlags;
            SrvOpen->Fcb = Fcb;
            SrvOpen->pAlreadyPrefixedName = &Fcb->PrivateAlreadyPrefixedName;

            SrvOpen->VNetRoot = VNetRoot;
            SrvOpen->ulFileSizeVersion = Fcb->ulFileSizeVersion;

            RxReferenceVNetRoot( VNetRoot );
            InterlockedIncrement( &VNetRoot->NetRoot->NumberOfSrvOpens );

            SrvOpen->NodeReferenceCount = 1;

            RxReferenceNetFcb( Fcb ); //  already have the lock
            InsertTailList( &Fcb->SrvOpenList,&SrvOpen->SrvOpenQLinks );
            Fcb->SrvOpenListVersion += 1;

            InitializeListHead( &SrvOpen->FobxList );
            InitializeListHead( &SrvOpen->TransitionWaitList );
            InitializeListHead( &SrvOpen->ScavengerFinalizationList );
            InitializeListHead( &SrvOpen->SrvOpenKeyList );
        }
    } finally {

       DebugUnwind( RxCreateNetFcb );

       if (AbnormalTermination()) {

           //
           //  If this is an abnormal termination then undo our work; this is
           //  one of those happy times when the existing code will work
           //

           if (SrvOpen != NULL) {
               RxFinalizeSrvOpen( SrvOpen, TRUE, TRUE );
           }
       } else {

           if (SrvOpen != NULL) {
               RxLog(( "SrvOp %lx %lx\n", SrvOpen, SrvOpen->Fcb ));
               RxWmiLog( LOG,
                         RxCreateSrvOpen,
                         LOGPTR( SrvOpen )
                         LOGPTR( SrvOpen->Fcb ) );
           }
       }
   }

   RxDbgTrace( -1, Dbg, ("RxCreateNetSrvOpen -> %08lx\n", SrvOpen) );

   return SrvOpen;
}

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given SrvOpen.

Arguments:

    ThisSrvOpen      - the SrvOpen being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

Notes:

    On Entry : 1) The FCB associated with the SRV_OPEN must have been acquired exclusive
               2) The tablelock associated with FCB's NET_ROOT instance must have been
                  acquired shared(atleast)

    On Exit  : No change in resource ownership

--*/
{
    NTSTATUS Status;
    BOOLEAN NodeActuallyFinalized = FALSE;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxFinalizeSrvOpen<+> %08lx %wZ RefC=%ld\n", ThisSrvOpen,&ThisSrvOpen->Fcb->FcbTableEntry.Path, ThisSrvOpen->NodeReferenceCount) );

    ASSERT( NodeType( ThisSrvOpen ) == RDBSS_NTC_SRVOPEN );

    if (RecursiveFinalize) {
        PFOBX Fobx;
        PLIST_ENTRY ListEntry;

#if 0
        if (ThisSrvOpen->NodeReferenceCount) {
            RxDbgTrace( 0, Dbg, ("    BAD!!!!!ReferenceCount = %08lx\n", ThisSrvOpen->NodeReferenceCount) );
        }
#endif

        ListEntry = ThisSrvOpen->FobxList.Flink;
        while (ListEntry != &ThisSrvOpen->FobxList) {
            Fobx = CONTAINING_RECORD( ListEntry, FOBX, FobxQLinks );
            ListEntry = ListEntry->Flink;
            RxFinalizeNetFobx( Fobx, TRUE, ForceFinalize );
        }
    }

    if ((ThisSrvOpen->NodeReferenceCount == 0) || ForceFinalize) {

        BOOLEAN FreeSrvOpen;
        PFCB Fcb;

        Fcb = ThisSrvOpen->Fcb;

        RxLog(( "FinalSrvOp %lx %lx %lx", ThisSrvOpen, ForceFinalize, ThisSrvOpen->NodeReferenceCount ));
        RxWmiLog( LOG,
                  RxFinalizeSrvOpen,
                  LOGPTR( ThisSrvOpen )
                  LOGUCHAR( ForceFinalize )
                  LOGULONG( ThisSrvOpen->NodeReferenceCount ) );

        FreeSrvOpen = !FlagOn( ThisSrvOpen->Flags, SRVOPEN_FLAG_ENCLOSED_ALLOCATED );

        if ((!ThisSrvOpen->UpperFinalizationDone) &&
            ((ThisSrvOpen->Condition != Condition_Good) ||
             (FlagOn( ThisSrvOpen->Flags, SRVOPEN_FLAG_CLOSED )))) {

            ASSERT( NodeType( Fcb ) != RDBSS_NTC_OPENTARGETDIR_FCB );
            ASSERT( RxIsFcbAcquiredExclusive ( Fcb ) );

            RxPurgeChangeBufferingStateRequestsForSrvOpen( ThisSrvOpen );

            if (!FlagOn( Fcb->FcbState, FCB_STATE_ORPHANED )) {

                //
                //  close the file.
                //

                MINIRDR_CALL_THROUGH( Status,
                                      Fcb->MRxDispatch,
                                      MRxForceClosed,
                                      ((PMRX_SRV_OPEN)ThisSrvOpen) );
            }

            RemoveEntryList ( &ThisSrvOpen->SrvOpenQLinks );
            InitializeListHead( &ThisSrvOpen->SrvOpenQLinks );

            Fcb->SrvOpenListVersion += 1;

            if (ThisSrvOpen->VNetRoot != NULL) {

                InterlockedDecrement( &ThisSrvOpen->VNetRoot->NetRoot->NumberOfSrvOpens );
                RxDereferenceVNetRoot( ThisSrvOpen->VNetRoot, LHS_LockNotHeld );
                ThisSrvOpen->VNetRoot = NULL;
            }

            ThisSrvOpen->UpperFinalizationDone = TRUE;
        }

        if (ThisSrvOpen->NodeReferenceCount == 0) {

            ASSERT( IsListEmpty( &ThisSrvOpen->SrvOpenKeyList ) );

            if (!IsListEmpty(&ThisSrvOpen->SrvOpenQLinks)) {
                RemoveEntryList( &ThisSrvOpen->SrvOpenQLinks );
                InitializeListHead( &ThisSrvOpen->SrvOpenQLinks );
            }

            if (FreeSrvOpen ) {
                RxFreeFcbObject( ThisSrvOpen );
            }

            if (!FreeSrvOpen){
               ClearFlag( Fcb->FcbState,FCB_STATE_SRVOPEN_USED );
            }

            RxDereferenceNetFcb( Fcb );
        }

        NodeActuallyFinalized = TRUE;
    } else {
        RxDbgTrace( 0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!') );
    }

    RxDbgTrace( -1, Dbg, ("RxFinalizeSrvOpen<-> %08lx\n", ThisSrvOpen, NodeActuallyFinalized) );

    return NodeActuallyFinalized;
}

ULONG RxPreviousFobxSerialNumber = 0;

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT RxContext,
    IN  PMRX_SRV_OPEN MrxSrvOpen
    )
/*++

Routine Description:

    This routine allocates, initializes, and inserts a new file object extension instance.

Arguments:

    RxContext - an RxContext describing a create............

    pSrvOpen - the associated SrvOpen

Return Value:

    none

Notes:

    On Entry : FCB associated with the FOBX instance have been acquired exclusive.

    On Exit  : No change in resource ownership

--*/
{
    PFCB Fcb;
    PFOBX Fobx;
    PSRV_OPEN SrvOpen = (PSRV_OPEN)MrxSrvOpen;

    ULONG FobxFlags;
    POOL_TYPE PoolType;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxCreateFobx<+>\n", 0) );

    ASSERT( NodeType( SrvOpen ) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeTypeIsFcb( SrvOpen->Fcb ) );
    ASSERT( RxIsFcbAcquiredExclusive( SrvOpen->Fcb ) );

    Fcb = SrvOpen->Fcb;

    if (FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {
        PoolType = NonPagedPool;
    } else {
        PoolType = PagedPool;
    }

    if (!(FlagOn( Fcb->FcbState, FCB_STATE_FOBX_USED )) &&
        (SrvOpen == Fcb->InternalSrvOpen)) {

        //
        //  Try and use the FOBX allocated as part of the FCB if it is available
        //

        Fobx = Fcb->InternalFobx;

        //
        //  just initialize the Fobx
        //

        RxAllocateFcbObject( Fcb->RxDeviceObject, RDBSS_NTC_FOBX, PoolType, 0, Fobx);

        SetFlag( Fcb->FcbState, FCB_STATE_FOBX_USED );
        FobxFlags = FOBX_FLAG_ENCLOSED_ALLOCATED;

    } else if (!(FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_FOBX_USED ))) {

        //
        //  Try and use the FOBX allocated as part of the SRV_OPEN if it is available
        //

        Fobx = SrvOpen->InternalFobx;

        //
        //  just initialize the Fobx
        //

        RxAllocateFcbObject( Fcb->RxDeviceObject, RDBSS_NTC_FOBX, PoolType, 0, Fobx );
        SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_FOBX_USED );
        FobxFlags = FOBX_FLAG_ENCLOSED_ALLOCATED;

    } else {

        Fobx = RxAllocateFcbObject( Fcb->RxDeviceObject, RDBSS_NTC_FOBX, PoolType, 0, NULL );
        FobxFlags = 0;
    }

    if (Fobx != NULL) {
        PMRX_NET_ROOT NetRoot;
        Fobx->Flags = FobxFlags;

        if ((NetRoot = RxContext->Create.pNetRoot) != NULL) {

            switch (NetRoot->DeviceType) {

            case FILE_DEVICE_NAMED_PIPE:

                RxInitializeThrottlingState( &Fobx->Specific.NamedPipe.ThrottlingState,
                                             NetRoot->NamedPipeParameters.PipeReadThrottlingParameters.Increment,
                                             NetRoot->NamedPipeParameters.PipeReadThrottlingParameters.MaximumDelay );
                break;

            case FILE_DEVICE_DISK:

                RxInitializeThrottlingState( &Fobx->Specific.DiskFile.LockThrottlingState,
                                             NetRoot->DiskParameters.LockThrottlingParameters.Increment,
                                             NetRoot->DiskParameters.LockThrottlingParameters.MaximumDelay );
                break;
            }
        }

        if (FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME )) {
            SetFlag( Fobx->Flags, FOBX_FLAG_UNC_NAME );
        }

        if (FlagOn( RxContext->Create.NtCreateParameters.CreateOptions, FILE_OPEN_FOR_BACKUP_INTENT )) {
            SetFlag( Fobx->Flags, FOBX_FLAG_BACKUP_INTENT );
        }

        Fobx->FobxSerialNumber = 0;
        Fobx->SrvOpen = SrvOpen;
        Fobx->NodeReferenceCount = 1;
        Fobx->fOpenCountDecremented = FALSE;
        RxReferenceSrvOpen( SrvOpen );
        InterlockedIncrement( &SrvOpen->VNetRoot->NumberOfFobxs );
        InsertTailList( &SrvOpen->FobxList, &Fobx->FobxQLinks );

        InitializeListHead( &Fobx->ClosePendingList );
        InitializeListHead( &Fobx->ScavengerFinalizationList );
        RxLog(( "Fobx %lx %lx %lx\n", Fobx, Fobx->SrvOpen, Fobx->SrvOpen->Fcb ));
        RxWmiLog( LOG,
                  RxCreateNetFobx,
                  LOGPTR( Fobx )
                  LOGPTR( Fobx->SrvOpen )
                  LOGPTR( Fobx->SrvOpen->Fcb ) );
    }

    RxDbgTrace( -1, Dbg, ("RxCreateNetFobx<-> %08lx\n", Fobx) );
    return (PMRX_FOBX)Fobx;
}

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    )
/*++

Routine Description:

    The routine finalizes the given Fobx. you need exclusive fcblock.

Arguments:

    ThisFobx - the Fobx being dereferenced

Return Value:

    BOOLEAN - tells whether finalization actually occured

Notes:

    On Entry : FCB associated with the FOBX instance must have been acquired exclusive.

    On Exit  : No change in resource ownership

--*/
{
    BOOLEAN NodeActuallyFinalized = FALSE;

    PAGED_CODE();
    RxDbgTrace( +1, Dbg, ("RxFinalizeFobx<+> %08lx %wZ RefC=%ld\n", ThisFobx,&ThisFobx->SrvOpen->Fcb->FcbTableEntry.Path, ThisFobx->NodeReferenceCount) );

    ASSERT( NodeType( ThisFobx ) == RDBSS_NTC_FOBX );

    if ((ThisFobx->NodeReferenceCount == 0) || ForceFinalize) {

        NTSTATUS  Status;
        PSRV_OPEN SrvOpen = ThisFobx->SrvOpen;
        PFCB Fcb = SrvOpen->Fcb;
        BOOLEAN FreeFobx = !FlagOn( ThisFobx->Flags, FOBX_FLAG_ENCLOSED_ALLOCATED );

        RxLog(( "FinalFobx %lx %lx %lx", ThisFobx, ForceFinalize, ThisFobx->NodeReferenceCount ));
        RxWmiLog( LOG,
                  RxFinalizeNetFobx_1,
                  LOGPTR( ThisFobx )
                  LOGUCHAR( ForceFinalize )
                  LOGULONG( ThisFobx->NodeReferenceCount ) );

        if (!ThisFobx->UpperFinalizationDone) {

            ASSERT( NodeType( ThisFobx->SrvOpen->Fcb ) != RDBSS_NTC_OPENTARGETDIR_FCB );
            ASSERT( RxIsFcbAcquiredExclusive ( ThisFobx->SrvOpen->Fcb ) );

            RemoveEntryList( &ThisFobx->FobxQLinks );

            if (FlagOn( ThisFobx->Flags, FOBX_FLAG_FREE_UNICODE )) {
                RxFreePool( ThisFobx->UnicodeQueryTemplate.Buffer );
            }

            if ((Fcb->MRxDispatch != NULL) && (Fcb->MRxDispatch->MRxDeallocateForFobx != NULL)) {
                Fcb->MRxDispatch->MRxDeallocateForFobx( (PMRX_FOBX)ThisFobx );
            }

            if (!FlagOn( ThisFobx->Flags, FOBX_FLAG_SRVOPEN_CLOSED )) {

                Status = RxCloseAssociatedSrvOpen( NULL, ThisFobx );
                RxLog(( "$$ScCl FOBX %lx SrvOp %lx %lx\n", ThisFobx, ThisFobx->SrvOpen, Status ));
                RxWmiLog( LOG,
                          RxFinalizeNetFobx_2,
                          LOGPTR( ThisFobx )
                          LOGPTR( ThisFobx->SrvOpen )
                          LOGULONG( Status ) );
            }

            ThisFobx->UpperFinalizationDone = TRUE;
        }

        if (ThisFobx->NodeReferenceCount == 0) {

            ASSERT( IsListEmpty( &ThisFobx->ClosePendingList ) );

            if (ThisFobx == Fcb->InternalFobx) {
                ClearFlag( Fcb->FcbState, FCB_STATE_FOBX_USED );
            } else if (ThisFobx == SrvOpen->InternalFobx) {
                ClearFlag( SrvOpen->Flags, SRVOPEN_FLAG_FOBX_USED );
            }

            if (SrvOpen != NULL) {
                ThisFobx->SrvOpen = NULL;
                InterlockedDecrement( &SrvOpen->VNetRoot->NumberOfFobxs );
                RxDereferenceSrvOpen( SrvOpen, LHS_ExclusiveLockHeld );
            }

            if (FreeFobx) {
                RxFreeFcbObject( ThisFobx );
            }

            NodeActuallyFinalized = TRUE;
        }

    } else {
        RxDbgTrace( 0, Dbg, ("   NODE NOT ACTUALLY FINALIZED!!!%C\n", '!') );
    }

    RxDbgTrace( -1, Dbg, ("RxFinalizeFobx<-> %08lx\n", ThisFobx, NodeActuallyFinalized) );

    return NodeActuallyFinalized;

}

#if DBG
#ifdef RDBSS_ENABLELOUDFCBOPSBYDEFAULT
BOOLEAN RxLoudFcbOpsOnExes = TRUE;
#else
BOOLEAN RxLoudFcbOpsOnExes = FALSE;
#endif // RDBSS_ENABLELOUDFCBOPSBYDEFAULT
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING Name
    )
{
    PWCHAR Buffer;
    ULONG Length;

    if (!RxLoudFcbOpsOnExes) {
        return FALSE;
    }

    Length = (Name->Length) / sizeof( WCHAR );
    Buffer = Name->Buffer + Length;

    if ((Length < 4) ||
        ((Buffer[-1] & 'E') != 'E') ||
        ((Buffer[-2] & 'X') != 'X') ||
        ((Buffer[-3] & 'E') != 'E') ||
        ((Buffer[-4] & '.') != '.')) {

        return FALSE;
     }

    DbgPrint( "--->%s %wZ\n", msg, Name );
    return TRUE;
}
#endif


VOID
RxCheckFcbStructuresForAlignment(
    VOID
    )
{
    ULONG StructureId;

    PAGED_CODE();

    if (FIELD_OFFSET( NET_ROOT, SrvCall ) != FIELD_OFFSET( NET_ROOT, pSrvCall )) {
        StructureId = 'RN'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET( V_NET_ROOT, NetRoot ) != FIELD_OFFSET( V_NET_ROOT, pNetRoot )) {
        StructureId = 'RNV'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET( SRV_OPEN, Fcb ) != FIELD_OFFSET( SRV_OPEN, pFcb )) {
        StructureId = 'NPOS'; goto DO_A_BUGCHECK;
    }
    if (FIELD_OFFSET( FOBX, SrvOpen ) != FIELD_OFFSET( FOBX, pSrvOpen )) {
        StructureId = 'XBOF'; goto DO_A_BUGCHECK;
    }

    return;
DO_A_BUGCHECK:
    RxBugCheck( StructureId, 0, 0 );
}

BOOLEAN
RxIsThisACscAgentOpen (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the open was made by the user mode CSC agent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    TRUE - if it is an agent open, FALSE otherwise

Notes:

    The agent opens are always satisfied by going to the server. They are never
    satisfied from the cached copies. This enables reintegration using snapshots
    even when the files are being currently used.

--*/
{
    BOOLEAN AgentOpen = FALSE;
    ULONG EaInformationLength;

    PDFS_NAME_CONTEXT DfsNameContext;

    if (RxContext->Create.EaLength > 0) {
        PFILE_FULL_EA_INFORMATION EaEntry;

        EaEntry = (PFILE_FULL_EA_INFORMATION)RxContext->Create.EaBuffer;
        ASSERT(EaEntry != NULL);

        for(;;) {
            if (strcmp( EaEntry->EaName, EA_NAME_CSCAGENT ) == 0) {
                AgentOpen = TRUE;
                break;
            }

            if (EaEntry->NextEntryOffset == 0) {
                 break;
            } else {
                EaEntry = (PFILE_FULL_EA_INFORMATION)Add2Ptr( EaEntry, EaEntry->NextEntryOffset );
            }
        }
    }

    DfsNameContext = RxContext->Create.NtCreateParameters.DfsNameContext;

    if ((DfsNameContext != NULL) &&
        (DfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT)) {

        AgentOpen = TRUE;
    }

    return AgentOpen;
}

VOID
RxOrphanThisFcb (
    PFCB Fcb
    )
/*++

Routine Description:

    This routine orphans an FCB. Assumption is that fcbtablelock is held when called

Arguments:

    Fcb - the fcb to be orphaned

Return Value:

    None

Notes:


--*/
{
    //
    //  force orphan all SrvOpens for this FCB and orphan the FCB itself
    //

    RxOrphanSrvOpensForThisFcb( Fcb, NULL, TRUE );
}

VOID
RxOrphanSrvOpensForThisFcb (
    PFCB Fcb,
    IN PV_NET_ROOT ThisVNetRoot,
    BOOLEAN OrphanAll
    )
/*++

Routine Description:

    This routine orphans all srvopens for a file belonging to a particular VNetRoot. The
    SrvOpen collapsing routine elsewhere makes sure that srvopens for different vnetroots
    are not collapsed.

Arguments:

    Fcb            - the fcb whose srvopens need to be orphaned

    ThisVNetRoot    - the VNetRoot for which the SrvOpens have to be orphaned

    OrphanAll      - Orphan all SrvOpens, ie ignore the ThisVNetRoot parameter

Return Value:

    None

Notes:



--*/
{

    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    BOOLEAN AllSrvOpensOrphaned = TRUE;

    Status = RxAcquireExclusiveFcb( CHANGE_BUFFERING_STATE_CONTEXT_WAIT, Fcb );
    ASSERT( Status == STATUS_SUCCESS );
    RxReferenceNetFcb(  Fcb );

    ListEntry = Fcb->SrvOpenList.Flink;
    while (ListEntry != &Fcb->SrvOpenList) {

        PSRV_OPEN SrvOpen;

        SrvOpen = (PSRV_OPEN)CONTAINING_RECORD( ListEntry, SRV_OPEN, SrvOpenQLinks );

        ListEntry = SrvOpen->SrvOpenQLinks.Flink;
        if (!FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_ORPHANED )) {

            //
            //  NB check OrphanAll first as if it is TRUE, the ThisVNetRoot
            //  parameter maybe NULL
            //

            if (OrphanAll || (SrvOpen->VNetRoot == ThisVNetRoot)) {
                PLIST_ENTRY Entry;
                PFOBX Fobx;

                SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_ORPHANED );

                RxAcquireScavengerMutex();

                Entry = SrvOpen->FobxList.Flink;

                while (Entry != &SrvOpen->FobxList) {
                    Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, FobxQLinks );

                    if (!Fobx->fOpenCountDecremented) {
                        InterlockedDecrement( &Fcb->OpenCount );
                        Fobx->fOpenCountDecremented = TRUE;
                    }

                    Entry =Entry->Flink;
                }

                RxReleaseScavengerMutex();

                if (!FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_CLOSED ) &&
                    !IsListEmpty( &SrvOpen->FobxList )) {

                    PLIST_ENTRY Entry;
                    NTSTATUS Status;
                    PFOBX Fobx;

                    Entry = SrvOpen->FobxList.Flink;

                    Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, FobxQLinks );

                    RxReferenceNetFobx( Fobx );

                    RxPurgeChangeBufferingStateRequestsForSrvOpen( SrvOpen );

                    Status = RxCloseAssociatedSrvOpen( NULL, Fobx );

                    RxDereferenceNetFobx( Fobx, LHS_ExclusiveLockHeld );

                    ListEntry = Fcb->SrvOpenList.Flink;
                }

            } else {

                //
                //  we found atleast one SrvOpen which is a) Not Orphaned and
                //  b) doesn't belong to this VNetRoot
                //  hence we cannot orphan this FCB
                //

                AllSrvOpensOrphaned = FALSE;
            }
        }
    }

    //
    //  if all srvopens for this FCB are in orphaned state, orphan the FCB as well.
    //

    if (AllSrvOpensOrphaned) {

        //
        //  remove the FCB from the netname table
        //  so that any new opens/creates for this file will create a new FCB.
        //

        RxRemoveNameNetFcb( Fcb );
        SetFlag( Fcb->FcbState, FCB_STATE_ORPHANED );
        ClearFlag( Fcb->FcbState, FCB_STATE_WRITECACHING_ENABLED );

        if (!RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE )) {
            RxReleaseFcb( NULL, Fcb );
        }
    } else {

        //
        //  some srvopens are still active, just remove the refcount and release the FCB
        //

        RxDereferenceNetFcb( Fcb );
        RxReleaseFcb( NULL, Fcb );
    }

}

VOID
RxForceFinalizeAllVNetRoots (
    PNET_ROOT NetRoot
    )
/*++

Routine Description:

    The routine foce finalizes all the vnetroots from the given netroot. You must be exclusive on
    the NetName tablelock.

Arguments:

    NetRoot      - the NetRoot

Return Value:

    VOID

--*/
{
    PLIST_ENTRY ListEntry;


    ListEntry = NetRoot->VirtualNetRoots.Flink;

    while (ListEntry != &NetRoot->VirtualNetRoots) {

        PV_NET_ROOT VNetRoot;

        VNetRoot = (PV_NET_ROOT) CONTAINING_RECORD( ListEntry, V_NET_ROOT, NetRootListEntry );

        if (NodeType( VNetRoot ) == RDBSS_NTC_V_NETROOT) {
            RxFinalizeVNetRoot( VNetRoot, TRUE, TRUE );
        }

        ListEntry = ListEntry->Flink;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\midatlas.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "midatlsp.h"

VOID
RxInitializeMidMapFreeList (
    struct _MID_MAP_ *pMidMap
    );

VOID
RxUninitializeMidMap (
    struct _MID_MAP_    *pMidMap,
    PCONTEXT_DESTRUCTOR pContextDestructor
    );



#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeMidMapFreeList)
#pragma alloc_text(PAGE, RxCreateMidAtlas)
#pragma alloc_text(PAGE, RxUninitializeMidMap)
#pragma alloc_text(PAGE, RxDestroyMidAtlas)
#endif

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)


//INLINE ULONG _GetEntryType(PVOID pEntry)

#define _GetEntryType(pEntry)                               \
        ((ULONG)((ULONG_PTR)(pEntry)) & ENTRY_TYPE_MASK)

//INLINE PVOID _GetEntryPointer(PVOID pEntry)

#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG_PTR)(pEntry) & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG_PTR)(pContext) | (EntryType))

//INLINE PMID_MAP _GetFirstMidMap()
/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
RxInitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i;

   PVOID  *pEntryValue     = (PVOID *)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;

   PAGED_CODE();

   //DbgPrint("RxInitializeMidMapFreeList .. Entry\n");

   if (pMidMap->MaximumNumberOfMids > 0) {
       pMidMap->pFreeMidListHead = pMidMap->Entries;
       for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
          *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
       }

       *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);
   }

   //DbgPrint("RxInitializeMidMapFreeList .. Exit\n");
}


PRX_MID_ATLAS
RxCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
    PRX_MID_ATLAS pMidAtlas;
    PMID_MAP   pMidMap;
    ULONG      AtlasSize;
    USHORT     MidsAllocatedRoundedToPowerOf2;
    USHORT     MaximumMidsRoundedToPowerOf2;
    UCHAR      MidFieldWidth,MaximumMidFieldWidth;

    PAGED_CODE();

    // Round off the Mids allocated at Start to a power of two
    MaximumMidsRoundedToPowerOf2 = 0x100;
    MaximumMidFieldWidth = 8;

    if (MaximumMidsRoundedToPowerOf2 != MaximumNumberOfMids) {
        if (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
            while (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
                MaximumMidFieldWidth++;
            }
        } else {
            while (MaximumNumberOfMids < MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> 1;
                MaximumMidFieldWidth--;
            }

            MaximumMidFieldWidth++;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
        }
    }

    MidsAllocatedRoundedToPowerOf2 = 0x100;
    MidFieldWidth = 8;

    if (MidsAllocatedRoundedToPowerOf2 != MidsAllocatedAtStart) {
        if (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
            while (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
                MidFieldWidth++;
            }
        } else {
            while (MidsAllocatedAtStart < MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 >> 1;
                MidFieldWidth--;
            }

            MidFieldWidth++;
            MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
        }
    }

    AtlasSize = sizeof(RX_MID_ATLAS) +
                FIELD_OFFSET(MID_MAP,Entries);

    if (MaximumNumberOfMids == MidsAllocatedAtStart) {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
    } else {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedRoundedToPowerOf2);
    }

    pMidAtlas = (PRX_MID_ATLAS)RxAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              RXCE_MIDATLAS_POOLTAG);
    if (pMidAtlas != NULL) {
        pMidMap = (PMID_MAP)(pMidAtlas + 1);

        pMidMap->Flags                 = 0;
        pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
        pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
        pMidAtlas->NumberOfMidsInUse = 0;
        pMidAtlas->NumberOfMidsDiscarded = 0;
        pMidAtlas->MaximumMidFieldWidth = MaximumMidFieldWidth;

        pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
        pMidMap->NumberOfMidsInUse   = 0;
        pMidMap->BaseMid             = 0;
        pMidMap->IndexMask           = MidsAllocatedRoundedToPowerOf2 - 1;
        pMidMap->IndexAlignmentCount = 0;
        pMidMap->IndexFieldWidth     = MidFieldWidth;
        pMidMap->Level               = 1;

        InitializeListHead(&pMidAtlas->MidMapFreeList);
        InitializeListHead(&pMidAtlas->MidMapExpansionList);
        RxInitializeMidMapFreeList(pMidMap);

        _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
        pMidAtlas->pRootMidMap = pMidMap;

        if (MaximumNumberOfMids > MidsAllocatedAtStart) {
            // Round off the maximum number of MIDS to determine the level and the
            // size of the quantum ( allocation increments)

            pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

            pMidAtlas->MidQuantum           = 32;
            pMidAtlas->MidQuantumFieldWidth = 5;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);

            if (MaximumMidsRoundedToPowerOf2 > 0) {
                pMidAtlas->NumberOfLevels = 3;
            } else {
                pMidAtlas->NumberOfLevels = 2;
            }
        } else {
            pMidAtlas->MidQuantum     = 0;
            pMidAtlas->NumberOfLevels = 1;
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
        }
    }

    //DbgPrint("RxAllocatMidAtlas .. Exit (pMidAtlas) %lx\n",pMidAtlas);
    return pMidAtlas;
}

VOID
RxUninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //DbgPrint("RxUninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));
   RxWmiLog(LOG,
            RxUninitializeMidMap,
            LOGXSHORT(pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            RxUninitializeMidMap(pChildMidMap,pContextDestructor);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);

               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      RxFreePool(pMidMap);
   }

   //DbgPrint("RxUninitializeMidMap .. Exit\n");
}

VOID
RxDestroyMidAtlas(
   PRX_MID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   PAGED_CODE();

   //DbgPrint("RxFreeMidAtlas .. Entry\n");
   RxUninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   RxFreePool(pMidAtlas);
   //DbgPrint("RxFreeMidAtlas .. Exit\n");
}

PVOID
RxMapMidToContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   ULONG     Index;

   //DbgPrint("RxMapMidToContext Mid %lx ",Mid);

   for (;;) {
      Index = (Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount;

      if( Index >= pMidMap->MaximumNumberOfMids ) {
          pContext = NULL;
          break;
      }

      pContext = pMidMap->Entries[Index];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      } else {
         pContext = NULL;
         break;
      }
   }

   //DbgPrint("Context %lx \n",pContext);

   return pContext;
}

NTSTATUS
RxMapAndDissociateMidFromContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   //DbgPrint("RxMapAndDissociateMidFromContext Mid %lx ",Mid);

   for (;;) {
      pEntry    = &pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
            _RemoveMidMap(pMidMap);
            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;


         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   //DbgPrint("Context %lx\n",pContext);
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
RxReassociateMid(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("RxReassociateMid Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("New COntext  %lx\n",pNewContext);

   return STATUS_SUCCESS;
}

NTSTATUS
RxAssociateContextWithMid(
      PRX_MID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status;
   PMID_MAP pMidMap;
   PVOID    *pContextPointer;

   // Reject requests that exceed our MID limit
   if( pMidAtlas->NumberOfMidsInUse >= pMidAtlas->MaximumNumberOfMids )
   {
       return STATUS_UNSUCCESSFUL;
   }

   //DbgPrint("RxAssociateContextWithMid Context %lx ",pContext);

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((USHORT)
                                   (pContextPointer - (PVOID *)&pMidMap->Entries)
                                    << pMidMap->IndexAlignmentCount) |
                                    pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }

         // The smallest MIDMAP we can do is 3 given the MIDMAP logic
         if ( (NumberOfEntriesInMap > 0) && (NumberOfEntriesInMap < 3) ) {
            NumberOfEntriesInMap = 3;
         }

         if (NumberOfEntriesInMap > 0) {
             NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                             NumberOfEntriesInMap * sizeof(PVOID);
             pNewMidMap = (PMID_MAP)RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        NewMidMapSize,
                                        RXCE_MIDATLAS_POOLTAG);

             if (pNewMidMap != NULL) {
                 pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
                 pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
                 pNewMidMap->NumberOfMidsInUse   = 0;
                 pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                                    i << pMidMap->IndexAlignmentCount);
                 pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                                   pMidMap->IndexFieldWidth;

                 pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
                 pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

                 RxInitializeMidMapFreeList(pNewMidMap);

                 //
                 // After the RxInitializeMidMapFreeList call above the
                 // pFreeMidListHead points to Entries[0]. We will be storing
                 // the value pMidMap->Entries[i] at this location so we need
                 // to make pFreeMidListHead point to Entries[1].
                 //
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));

                 //
                 // Set up the mid map appropriately.
                 //
                 pNewMidMap->NumberOfMidsInUse = 1;
                 pNewMidMap->Entries[0] = pMidMap->Entries[i];
                 pNewMidMap->Level = pMidMap->Level + 1;

                 //
                 // The new MinMap is stored at the pMidMap->Entries[i] location.
                 //
                 pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

                 //
                 // Update the free list and the expansion list respectively.
                 //
                 _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

                 pNewMidMap->NumberOfMidsInUse++;
                 pContextPointer = pNewMidMap->pFreeMidListHead;
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));
                 *pContextPointer = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
                 *pNewMid = ((USHORT)
                             (pContextPointer - (PVOID *)&pNewMidMap->Entries)
                             << pNewMidMap->IndexAlignmentCount) |
                             pNewMidMap->BaseMid;

                 Status = STATUS_SUCCESS;
             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
         } else {
             Status = STATUS_UNSUCCESSFUL;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == (STATUS_SUCCESS)) {
      pMidAtlas->NumberOfMidsInUse++;
   }

   //DbgPrint("Mid %lx\n",*pNewMid);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\prefix.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.c

Abstract:

    This module implements table functions for the net name prefix table and the per-netroot fcb table.


Author:

    Joe Linn (JoeLinn)    8-8-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxTableComputeHashValue)

#if 0
#pragma alloc_text(PAGE, RxpAcquirePrefixTableLockShared)
#pragma alloc_text(PAGE, RxpAcquirePrefixTableLockExclusive)
#pragma alloc_text(PAGE, RxpReleasePrefixTableLock)
#endif

#pragma alloc_text(PAGE, RxExclusivePrefixTableLockToShared)
#pragma alloc_text(PAGE, RxIsPrefixTableEmpty)
#pragma alloc_text(PAGE, RxPrefixTableLookupName)
#pragma alloc_text(PAGE, RxTableLookupName_ExactLengthMatch)
#pragma alloc_text(PAGE, RxTableLookupName)
#pragma alloc_text(PAGE, RxPrefixTableInsertName)
#pragma alloc_text(PAGE, RxRemovePrefixTableEntry)
#pragma alloc_text(PAGE, RxInitializePrefixTable)
#pragma alloc_text(PAGE, RxFinalizePrefixTable)
#endif

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_PREFIX)

PUNICODE_PREFIX_TABLE_ENTRY
RxTrivialPrefixFind (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            Flags
    );

VOID
RxCheckTableConsistency_actual (
    IN PRX_PREFIX_TABLE Table,
    IN ULONG Tag
    );

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID RxConnectionId
    );

PRX_PREFIX_ENTRY
RxTableInsertEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

VOID
RxTableRemoveEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, RxPrefixTableLookupName )
#pragma alloc_text( PAGE, RxPrefixTableInsertName )
#pragma alloc_text( PAGE, RxRemovePrefixTableEntry )
#pragma alloc_text( PAGE, RxInitializePrefixTable )
#pragma alloc_text( PAGE, RxFinalizePrefixTable )
#endif

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING  Name
    )
/*++

Routine Description:

   here, we compute a caseinsensitive hashvalue.  we want to avoid a call/char to
   the unicodeupcase routine but we want to still have some reasonable spread on
   the hashvalues.  many rules just dont work for known important cases.  for
   example, the (use the first k and the last n) rule that old c compilers used
   doesn't pickup the difference among \nt\private\......\slm.ini and that would be
   nice.  note that the underlying comparison used already takes cognizance of the
   length before comparing.

   the rule we have selected is to use the 2nd, the last 4, and three selected
   at 1/4 points

Arguments:

    Name      - the name to be hashed

Return Value:

    ULONG which is a hashvalue for the name given.

--*/
{
    ULONG HashValue;
    LONG i,j;
    LONG length = Name->Length/sizeof(WCHAR);
    PWCHAR Buffer = Name->Buffer;
    LONG Probe[8];

    PAGED_CODE();

    HashValue = 0;

    Probe[0] = 1;
    Probe[1] = length - 1;
    Probe[2] = length - 2;
    Probe[3] = length - 3;
    Probe[4] = length - 4;
    Probe[5] = length >> 2;
    Probe[6] = (2 * length) >> 2;
    Probe[7] = (3 * length) >> 2;

    for (i = 0; i < 8; i++) {
        j = Probe[i];
        if ((j < 0) || (j >= length)) {
            continue;
        }
        HashValue = (HashValue << 3) + RtlUpcaseUnicodeChar(Buffer[j]);
    }

    RxDbgTrace(0, Dbg, ("RxTableComputeHashValue Hashv=%ld Name=%wZ\n",
                       HashValue, Name));
    return(HashValue);
}


#define HASH_BUCKET(TABLE,HASHVALUE) &((TABLE)->HashBuckets[(HASHVALUE) % (TABLE)->TableSize])

//#if DBG
//#define RxCheckTableConsistency(_xx,_yy) RxCheckTableConsistency_actual(_xx,_yy)
//#else
//#define RxCheckTableConsistency(_xx,_yy)
//#endif
#define RxCheckTableConsistency(_xx,_yy)

#if 0
ULONG RxLoudPrefixTableOperations = 0; //1;
#define RxLoudPrefixTableOperation(x) {              \
    if (RxLoudPrefixTableOperations) {               \
        DbgPrint("rdr2:%s on %08lx from %d:%s\n",    \
              x,pTable,LineNumber,FileName);         \
    }}
#else
#define RxLoudPrefixTableOperation(x) {NOTHING;}
#endif


#if 0

BOOLEAN
RxpAcquirePrefixTableLockShared (
    PRX_PREFIX_TABLE Table,
    BOOLEAN Wait,
    BOOLEAN ProcessBufferingStateChangeRequests,
    PSZ FileName,
    ULONG LineNumber
    )
{
    BOOLEAN fResult;

    PAGED_CODE();

    RxLoudPrefixTableOperation( "RxpAcquirePrefixTableLockShared" );
    fResult = ExAcquireResourceSharedLite( &Table->TableLock, Wait );

    return fResult;
}

BOOLEAN
RxpAcquirePrefixTableLockExclusive (
    PRX_PREFIX_TABLE Table,
    BOOLEAN Wait,
    BOOLEAN ProcessBufferingStateChangeRequests,
    PSZ FileName,
    ULONG LineNumber
    )
{
    BOOLEAN fResult;

    PAGED_CODE();

    RxLoudPrefixTableOperation( "RxpAcquirePrefixTableLockExclusive" );
    fResult = ExAcquireResourceExclusiveLite( &Table->TableLock, Wait );

    return fResult;
}

VOID
RxpReleasePrefixTableLock (
    PRX_PREFIX_TABLE Table,
    BOOLEAN ProcessBufferingStateChangeRequests,
    PSZ FileName,
    ULONG LineNumber
    )
{
    PAGED_CODE();

    RxLoudPrefixTableOperation( "RxpReleasePrefixTableLock" );
    ExReleaseResourceLite( &Table->TableLock );
}


#endif 

VOID
RxExclusivePrefixTableLockToShared (
    PRX_PREFIX_TABLE pTable
    )
{
    PAGED_CODE();

    ExConvertExclusiveToSharedLite(&pTable->TableLock);
}



BOOLEAN
RxIsPrefixTableEmpty(
    IN PRX_PREFIX_TABLE   ThisTable)
{
    BOOLEAN IsEmpty;

    PAGED_CODE();
    ASSERT  ( RxIsPrefixTableLockAcquired ( ThisTable )  );

    RxCheckTableConsistency(ThisTable,' kue');

    IsEmpty = IsListEmpty(&ThisTable->MemberQueue);

    return IsEmpty;
}

PVOID
RxPrefixTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    )
/*++

Routine Description:

    The routine looks up a name in a prefix table and converts from the underlying pointer to the containing
    record. The table lock should be held AT LEAST shared for this operation.

Arguments:

    ThisTable      - the table to be looked in.

    CanonicalName  - the name to be looked up

    RemainingName  - the portion of the name unmatched.

Return Value:

    Ptr to the found node or NULL. The found node will be referenced.

--*/
{
    PVOID pContainer = NULL;
    PRX_PREFIX_ENTRY ThisEntry;

    PAGED_CODE();
    ASSERT  ( RxIsPrefixTableLockAcquired ( ThisTable )  );

    RxDbgTrace( +1, Dbg, ("RxPrefixTableLookupName  Name = %wZ \n", CanonicalName));
    RxCheckTableConsistency(ThisTable,' kul');

    ASSERT(CanonicalName->Length > 0);

    pContainer = RxTableLookupName(ThisTable, CanonicalName,RemainingName, RxConnectionId);

    if (pContainer ==  NULL){
        RxDbgTrace(-1, Dbg, ("RxPrefixTableLookupName  Name = %wZ   F A I L E D  !!\n", CanonicalName));
        return NULL;
    } else {
        IF_DEBUG {
           if (RdbssReferenceTracingValue != 0) {
              switch (NodeType(pContainer) & ~RX_SCAVENGER_MASK) {
              case RDBSS_NTC_SRVCALL :
                 {
                    RxpTrackReference(RDBSS_REF_TRACK_SRVCALL,__FILE__,__LINE__,pContainer);
                 }
                 break;
              case RDBSS_NTC_NETROOT :
                 {
                    RxpTrackReference(RDBSS_REF_TRACK_NETROOT,__FILE__,__LINE__,pContainer);
                 }
                 break;
              case RDBSS_NTC_V_NETROOT:
                 {
                    RxpTrackReference(RDBSS_REF_TRACK_VNETROOT,__FILE__,__LINE__,pContainer);
                 }
                 break;
              default:
                 {
                    ASSERT(!"Valid node type for referencing");
                 }
                 break;
              }
           }
        }

        RxReference(pContainer);

        RxDbgTrace(-1, Dbg, ("RxPrefixTableLookupName  Name = %wZ Container = 0x%8lx\n", CanonicalName, pContainer));
    }

    return pContainer;
}


PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            HashValue,
    IN  PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    The routine looks up a name in a rxtable; whether or not to do case insensitive is a property
    of the table. The table lock should be held AT LEAST
    shared for this operation; the routine may boost itself to exclusive on the lock if it wants to rearrange the table.

Arguments:

    ThisTable - the table to be looked in.
    Name      - the name to be looked up
    HashValue - the precomputed hashvalue

Return Value:

    Ptr to the found node or NULL.

--*/
{
    PLIST_ENTRY HashBucket, ListEntry;
    BOOLEAN CaseInsensitiveMatch = ThisTable->CaseInsensitiveMatch;

    PAGED_CODE();

    ASSERT( RxConnectionId );

    HashBucket = HASH_BUCKET(ThisTable,HashValue);

    for (ListEntry = HashBucket->Flink;
         ListEntry != HashBucket;
         ListEntry = ListEntry->Flink
        ) {
        PRX_PREFIX_ENTRY PrefixEntry;
        PVOID Container;

        ASSERT(ListEntry!=NULL);
        PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, HashLinks );

        RxDbgTrace(0,Dbg,("Considering <%wZ> hashv=%d \n",&PrefixEntry->Prefix,PrefixEntry->SavedHashValue));
        DbgDoit(ThisTable->Considers++);

        ASSERT(HashBucket == HASH_BUCKET(ThisTable,PrefixEntry->SavedHashValue));

        ASSERT(PrefixEntry!=NULL);
        Container = PrefixEntry->ContainingRecord;

        ASSERT(Container!=NULL);

        if ( (PrefixEntry->SavedHashValue == HashValue)
             && (PrefixEntry->Prefix.Length==Name->Length) ){
            USHORT CaseInsensitiveLength = PrefixEntry->CaseInsensitiveLength;
            DbgDoit(ThisTable->Compares++);
            if (CaseInsensitiveLength == 0) {
                RxDbgTrace(0,Dbg,("Comparing <%wZ> with <%wZ>, ins=%x\n",Name,&PrefixEntry->Prefix,CaseInsensitiveMatch));
                if (RtlEqualUnicodeString(Name,&PrefixEntry->Prefix,CaseInsensitiveMatch) ) {
                    if( !ThisTable->IsNetNameTable || RxEqualConnectionId( RxConnectionId, &PrefixEntry->ConnectionId ) )
                    {
                        return PrefixEntry;
                    }
                }
            } else {
                //part of the compare will be case insensitive and part controlled by the flag
                UNICODE_STRING PartOfName,PartOfPrefix;
                ASSERT( CaseInsensitiveLength <= Name->Length );
                PartOfName.Buffer = Name->Buffer;
                PartOfName.Length = CaseInsensitiveLength;
                PartOfPrefix.Buffer = PrefixEntry->Prefix.Buffer;
                PartOfPrefix.Length = CaseInsensitiveLength;
                RxDbgTrace(0,Dbg,("InsensitiveComparing <%wZ> with <%wZ>\n",&PartOfName,&PartOfPrefix));
                if (RtlEqualUnicodeString(&PartOfName,&PartOfPrefix,TRUE) ) {
                    if (Name->Length == CaseInsensitiveLength ) {
                        if( !ThisTable->IsNetNameTable || RxEqualConnectionId( RxConnectionId, &PrefixEntry->ConnectionId ) )
                        {
                            return PrefixEntry;
                        }
                    }
                    PartOfName.Buffer = (PWCHAR)(((PCHAR)PartOfName.Buffer)+CaseInsensitiveLength);
                    PartOfName.Length = Name->Length - CaseInsensitiveLength;
                    PartOfPrefix.Buffer = (PWCHAR)(((PCHAR)PartOfPrefix.Buffer)+CaseInsensitiveLength);
                    PartOfPrefix.Length = PrefixEntry->Prefix.Length - CaseInsensitiveLength;
                    RxDbgTrace(0,Dbg,("AndthenComparing <%wZ> with <%wZ>\n",&PartOfName,&PartOfPrefix));
                    if (RtlEqualUnicodeString(&PartOfName,&PartOfPrefix,FALSE) ) {
                        if( !ThisTable->IsNetNameTable || RxEqualConnectionId( RxConnectionId, &PrefixEntry->ConnectionId ) )
                        {
                            return PrefixEntry;
                        }
                    }
                }
            }
        }
    }

    return NULL;
}

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    )
/*++

Routine Description:

    The routine looks up a name in a prefix table. The table lock should be held AT LEAST shared for this operation; the routine
    may boost itself to exclusive on the lock if it wants to rearrange the table.

    This routine conducts itself differently depending on whether the table is the netroot table. if so, it actually does
    a prefix match; if not, it actually does an exact match and fails immediately if the exact match fails. Eventually, we may want
    to actually point to different routines...what a concept.

Arguments:

    ThisTable - the table to be looked in.
    Name      - the name to be looked up

Return Value:

    Ptr to the found node or NULL.

--*/
{
    ULONG HashValue;

    UNICODE_STRING Prefix;

    PRX_PREFIX_ENTRY pFoundPrefixEntry;
    PVOID            pContainer = NULL;

    ULONG i,length;

    PRX_PREFIX_ENTRY pPrefixEntry;

    RX_CONNECTION_ID LocalId;

    PAGED_CODE();

    if( ThisTable->IsNetNameTable && !RxConnectionId )
    {
        RtlZeroMemory( &LocalId, sizeof(RX_CONNECTION_ID) );
        RxConnectionId = &LocalId;
    }

    ASSERT(Name->Buffer[0]==L'\\');

    RxDbgTrace(+1, Dbg, ("RxTableLookupName\n"));

    //
    //the code below takes cognizance of what it knows is stored in the netname table,
    //i.e. netroots and vnetroots cause an immediate return, and srvcalls which require that we continue looking
    //to see if we will find a netroot/vnetroot that is longer.  so, we go down the table looking at each possible
    //prefix. if we exhaust the list w/o finding a hit, it's a failure. if we find a v/netroot, instant out. if
    //we find a srvcall we keep looking
    //

    length = Name->Length / sizeof(WCHAR);
    Prefix.Buffer = Name->Buffer;
    pFoundPrefixEntry = NULL;

    for (i=1;;i++) {
        if ((i>=length) ||
            (Prefix.Buffer[i]==OBJ_NAME_PATH_SEPARATOR) ||
            (Prefix.Buffer[i]==L':')) {

            //we have a prefix...lookit up
            Prefix.Length=(USHORT)(i*sizeof(WCHAR));
            HashValue = RxTableComputeHashValue(&Prefix);
            pPrefixEntry = RxTableLookupName_ExactLengthMatch(ThisTable, (&Prefix), HashValue, RxConnectionId);
            DbgDoit(ThisTable->Lookups++);

            if (pPrefixEntry!=NULL) {
                pFoundPrefixEntry = pPrefixEntry;
                pContainer = pFoundPrefixEntry->ContainingRecord;

                ASSERT (pPrefixEntry->ContainingRecord != NULL);
                if ((NodeType(pPrefixEntry->ContainingRecord) & ~RX_SCAVENGER_MASK)
                     == RDBSS_NTC_V_NETROOT) {
                    break;
                }

                if ((NodeType(pPrefixEntry->ContainingRecord) & ~RX_SCAVENGER_MASK)
                     == RDBSS_NTC_NETROOT) {
                    PNET_ROOT pNetRoot = (PNET_ROOT)pPrefixEntry->ContainingRecord;
                    if (pNetRoot->DefaultVNetRoot != NULL) {
                        pContainer = pNetRoot->DefaultVNetRoot;
                    } else if (!IsListEmpty(&pNetRoot->VirtualNetRoots)) {
                        pContainer = CONTAINING_RECORD(
                                         pNetRoot->VirtualNetRoots.Flink,
                                         V_NET_ROOT,
                                         NetRootListEntry);
                    } else {
                        ASSERT(!"Invalid Net Root Entry in Prefix Table");
                        pFoundPrefixEntry = NULL;
                        pContainer = NULL;
                    }
                    break;
                }

                ASSERT ((NodeType(pPrefixEntry->ContainingRecord) & ~RX_SCAVENGER_MASK)
                        == RDBSS_NTC_SRVCALL );

                //in this case we have to go around again to try to extend to the netroot
            } else {
                DbgDoit(ThisTable->FailedLookups++);
            }

            //dont do this because of long netroots
            //if ((pPrefixEntry == NULL) && (pFoundPrefixEntry != NULL)) {
            //    break;
            //}
        }

        if (i>=length) {
            break;
        }
    }


    // Update the remaining Name
    if (pFoundPrefixEntry != NULL) {
        RxDbgTrace(0,Dbg,("Found Container(%lx) Node Type(%lx) Length Matched (%ld)",
                         pFoundPrefixEntry,
                         NodeType(pFoundPrefixEntry->ContainingRecord),
                         pFoundPrefixEntry->Prefix.Length));
        ASSERT(Name->Length >= pFoundPrefixEntry->Prefix.Length);

        RemainingName->Buffer = (PWCH)((PCHAR)Name->Buffer + pFoundPrefixEntry->Prefix.Length);
        RemainingName->Length = Name->Length - pFoundPrefixEntry->Prefix.Length;
        RemainingName->MaximumLength = RemainingName->Length;
    } else {
        *RemainingName = *Name;
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return pContainer;
}


PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN     PVOID            Container,
    IN     PULONG           ContainerRefCount,
    IN     USHORT           CaseInsensitiveLength,
    IN     PRX_CONNECTION_ID RxConnectionId
    )

/*++

Routine Description:

    The routine inserts the name into the table. The tablelock should be held
    exclusive for this operation.

Arguments:

    ThisTable - the table to be looked in.
    ThisEntry - the prefixtable entry to use for the insertion.
    Container - is a backptr to the enclosing structure. (can't use CONTAINING_RECORD....sigh)
    ContainerRefCount - is a backptr to the refcount.....a different offset for fcbs from netroots
    Name      - the name to be inserted

Return Value:

    Ptr to the inserted node.

--*/
{
    ULONG HashValue;
    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("RxPrefixTableInsert Name = %wZ(%x/%x)\n", &ThisEntry->Prefix,
                             CaseInsensitiveLength,ThisEntry->Prefix.Length));
    RxLoudFcbMsg("Insert: ",&ThisEntry->Prefix);

    ASSERT  ( RxIsPrefixTableLockExclusive ( ThisTable )  );
    ASSERT( CaseInsensitiveLength <= ThisEntry->Prefix.Length );

    ThisEntry->ContainingRecord = Container;
    ThisEntry->ContainerRefCount = ContainerRefCount;
    ThisEntry->CaseInsensitiveLength = CaseInsensitiveLength;

    InterlockedIncrement(ContainerRefCount); //note: not set =1. should already be zero

    HashValue = RxTableComputeHashValue(&ThisEntry->Prefix);
    ThisEntry->SavedHashValue = HashValue;

    if (ThisEntry->Prefix.Length){
        ULONG HashValue = ThisEntry->SavedHashValue;
        PLIST_ENTRY HashBucket;

        HashBucket = HASH_BUCKET(ThisTable,HashValue);
        RxDbgTrace(0,Dbg,("RxTableInsertEntry %wZ hashv=%d\n",&ThisEntry->Prefix,ThisEntry->SavedHashValue));
        InsertHeadList(HashBucket,&ThisEntry->HashLinks);
    } else {
        ThisTable->TableEntryForNull = ThisEntry;
    }

    if( RxConnectionId )
    {
        RtlCopyMemory( &ThisEntry->ConnectionId, RxConnectionId, sizeof(RX_CONNECTION_ID) );
    }
    else
    {
        RtlZeroMemory( &ThisEntry->ConnectionId, sizeof(RX_CONNECTION_ID) );
    }

    InsertTailList(&ThisTable->MemberQueue,&ThisEntry->MemberQLinks);
    ThisTable->Version++;

    RxCheckTableConsistency(ThisTable,' tup');

    RxDbgTrace(-1, Dbg, ("RxPrefixTableInsert  Entry = %08lx Container = %08lx\n",
                             ThisEntry, ThisEntry->ContainingRecord));

    return ThisEntry;

}

VOID
RxRemovePrefixTableEntry(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    )

/*++

Routine Description:

    The routine to remove entry from the table. The table lock should be held exclusive during
    this operation. Please note that we do NOT dereference the node; this may seem strange since we
    ref the node in lookup and insert. The reason is that people are supposed to deref themselves after
    a lookup/insert.

Arguments:

    ThisTable - the table associated with the entry.
    ThisEntry - the entry being removed.

Return Value:

    None.

--*/
{
    PAGED_CODE();
    RxDbgTrace( 0, Dbg, (" RxRemovePrefixTableEntry, Name = %wZ\n", &ThisEntry->Prefix));
    RxLoudFcbMsg("Remove: ",&ThisEntry->Prefix);

    ASSERT( NodeType(ThisEntry) == RDBSS_NTC_PREFIX_ENTRY );
    ASSERT  ( RxIsPrefixTableLockExclusive ( ThisTable )  );

    if (ThisEntry->Prefix.Length) {
        RemoveEntryList(&ThisEntry->HashLinks);
    } else {
        ThisTable->TableEntryForNull = NULL;
    }

    ThisEntry->ContainingRecord = NULL;
    RemoveEntryList( &ThisEntry->MemberQLinks );
    ThisTable->Version++;

    RxCheckTableConsistency(ThisTable,' mer');

    return;
}

VOID
RxInitializePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN ULONG TableSize OPTIONAL, 
    IN BOOLEAN CaseInsensitiveMatch
    )

/*++

Routine Description:

    The routine initializes the inner table linkage and the corresponding lock.

Arguments:

    ThisTable - the table to be initialized.
    
    TableSize - 0=>use default

Return Value:

    None.

--*/

{
    ULONG i;

    PAGED_CODE();

    if (TableSize == 0) {
        TableSize = RX_PREFIX_TABLE_DEFAULT_LENGTH;
    }

    //
    //  this is not zero'd so you have to be careful to init everything
    //

    ThisTable->NodeTypeCode = RDBSS_NTC_PREFIX_TABLE;
    ThisTable->NodeByteSize = sizeof( RX_PREFIX_TABLE );

    InitializeListHead( &ThisTable->MemberQueue );
    ExInitializeResourceLite( &ThisTable->TableLock );
    ThisTable->Version = 0;
    ThisTable->TableEntryForNull = NULL;
    ThisTable->IsNetNameTable = FALSE;

    ThisTable->CaseInsensitiveMatch = CaseInsensitiveMatch;

    ThisTable->TableSize = TableSize;
    for (i=0;i<TableSize;i++) {
        InitializeListHead(&ThisTable->HashBuckets[i]);
    }

#if DBG
    ThisTable->Lookups = 0;
    ThisTable->FailedLookups = 0;
    ThisTable->Considers = 0;
    ThisTable->Compares = 0;
#endif
}

VOID
RxFinalizePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable
    )

/*++

Routine Description:

    The routine deinitializes a prefix table.

Arguments:

    ThisTable - the table to be finalized.

Return Value:

    None.

--*/

{
    ExDeleteResourceLite( &ThisTable->TableLock );
}


//#if DBG
#if 0
//the purpose of this routine is to catch errors in table manipulation; apparently, stuff is being deleted
//and not removed from the table. what we do is to keep a log of all the entries that we pass; if one of the
//entries is bad then it should be straightforward to compare this log with the previous log to see who did what.
//it probably happens on a failure case or something
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#define RX_PCTC_ENTRY_LENGTH 64
#define RX_PCTC_LOG_LENGTH (128*RX_PCTC_ENTRY_LENGTH)
#define RX_PCTC_LOG_LENGTH_PLUS (RX_PCTC_LOG_LENGTH+100) //the slop is 16 for the ----- and the rest for protection
UCHAR RxPCTC1[RX_PCTC_LOG_LENGTH_PLUS];
UCHAR RxPCTC2[RX_PCTC_LOG_LENGTH_PLUS];
PUCHAR RxPCTCCurrentLog = NULL;
VOID
RxCheckTableConsistency_actual (
    IN PRX_PREFIX_TABLE Table,
    IN ULONG Tag
    )
{
    ULONG i;
    PLIST_ENTRY ListEntry, NextListEntry;

    PAGED_CODE();

    if (Table->IsNetNameTable) { return; }

    ExAcquireResourceExclusiveLite(&Table->LoggingLock,TRUE);

    if (RxPCTCCurrentLog==&RxPCTC2[0]) {
        RxPCTCCurrentLog = &RxPCTC1[0];
    } else {
        RxPCTCCurrentLog = &RxPCTC2[0];
    }

    sprintf(RxPCTCCurrentLog,"----------");

    for (i=0,ListEntry = Table->MemberQueue.Flink;
         ListEntry != &Table->MemberQueue;
         i+=RX_PCTC_ENTRY_LENGTH,ListEntry = NextListEntry
        ) {
        PRX_PREFIX_ENTRY PrefixEntry;
        PVOID Container;

        ASSERT(ListEntry!=NULL);

        NextListEntry = ListEntry->Flink;
        PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, MemberQLinks );

        ASSERT(PrefixEntry!=NULL);
        Container = PrefixEntry->ContainingRecord;

        ASSERT(Container!=NULL);
        ASSERT(NodeTypeIsFcb(Container));

        if (i>=RX_PCTC_LOG_LENGTH ) { continue; }

        sprintf(&RxPCTCCurrentLog[i],"%4s %4s>> %-32.32wZ!!",&Tag,&Container,&PrefixEntry->Prefix);
        sprintf(&RxPCTCCurrentLog[i+16],"----------");

    }

    RxDbgTrace(0, Dbg, ("RxCheckTableConsistency_actual %d entries\n", i/RX_PCTC_ENTRY_LENGTH));
    ExReleaseResourceLite(&Table->LoggingLock);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\lowio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LowIo.c

Abstract:

    This module implements buffer locking and mapping; also synchronous waiting for a lowlevelIO.

Author:

    JoeLinn     [JoeLinn]    12-Oct-94

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOWIO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxLockUserBuffer)
#pragma alloc_text(PAGE, RxMapUserBuffer)
#pragma alloc_text(PAGE, RxMapSystemBuffer)
#pragma alloc_text(PAGE, RxInitializeLowIoContext)
#pragma alloc_text(PAGE, RxLowIoGetBufferAddress)
#pragma alloc_text(PAGE, RxLowIoSubmitRETRY)
#pragma alloc_text(PAGE, RxLowIoPopulateFsctlInfo)
#pragma alloc_text(PAGE, RxLowIoSubmit)
#pragma alloc_text(PAGE, RxInitializeLowIoPerFcbInfo)
#pragma alloc_text(PAGE, RxInitializeLowIoPerFcbInfo)
#endif

//
//  this is a crude implementation of the insertion, deletion, and coverup operations for wimp lowio
//  we'll just use a linked list for now.........
//

#define RxInsertIntoOutStandingPagingOperationsList(RxContext,Operation) {     \
    PLIST_ENTRY WhichList = (Operation==LOWIO_OP_READ)                        \
                               ?&Fcb->PagingIoReadsOutstanding  \
                               :&Fcb->PagingIoWritesOutstanding;\
    InsertTailList(WhichList,&RxContext->RxContextSerializationQLinks);      \
}
#define RxRemoveFromOutStandingPagingOperationsList(RxContext) { \
    RemoveEntryList(&RxContext->RxContextSerializationQLinks);      \
    RxContext->RxContextSerializationQLinks.Flink = NULL;        \
    RxContext->RxContextSerializationQLinks.Blink = NULL;        \
}


FAST_MUTEX RxLowIoPagingIoSyncMutex;

//
//  here we hiding the IO access flags
//

INLINE
NTSTATUS
RxLockAndMapUserBufferForLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PLOWIO_CONTEXT LowIoContext,
    IN ULONG Operation
    )
{
    RxLockUserBuffer( RxContext,
                      Irp,
                      (Operation == LOWIO_OP_READ) ? IoWriteAccess : IoReadAccess,
                      LowIoContext->ParamsFor.ReadWrite.ByteCount );        
    if (RxMapUserBuffer( RxContext, Irp ) == NULL)  {
        return STATUS_INSUFFICIENT_RESOURCES; 
    } else {
        LowIoContext->ParamsFor.ReadWrite.Buffer = Irp->MdlAddress; 
        return STATUS_SUCCESS;
    }
}

//
//  NT specific routines
//

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )
/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

Arguments:

    RxContext - Pointer to the pointer Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/
{
    PMDL Mdl = NULL;

    PAGED_CODE();

    if (Irp->MdlAddress == NULL) {

        ASSERT( !FlagOn( Irp->Flags, IRP_INPUT_OPERATION ) );

        //
        //  Allocate the Mdl, and Raise if we fail.
        //

        if (BufferLength > 0) {
            Mdl = IoAllocateMdl( Irp->UserBuffer,
                                 BufferLength,
                                 FALSE,
                                 FALSE,
                                 Irp );

            if (Mdl == NULL) {
                
                RxRaiseStatus( RxContext, STATUS_INSUFFICIENT_RESOURCES );
            
            } else {

                //
                //  Now probe the buffer described by the Irp.  If we get an exception,
                //  deallocate the Mdl and return the appropriate "expected" status.
                //

                try {
                    MmProbeAndLockPages( Mdl,
                                         Irp->RequestorMode,
                                         Operation );
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NTSTATUS Status;

                    Status = GetExceptionCode();

                    IoFreeMdl( Mdl );
                    Irp->MdlAddress = NULL;

                    if (!FsRtlIsNtstatusExpected( Status )) {
                        Status = STATUS_INVALID_USER_BUFFER;
                    }

                    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );

                    RxRaiseStatus( RxContext, Status );
                }
            }
        }
    } else {
        Mdl = Irp->MdlAddress;
        ASSERT( RxLowIoIsMdlLocked( Mdl ) );
    }
}

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine returns the system buffer address from the irp. the way that the code is written
    it may also decide to get the buffer address from the mdl. that is wrong because the systembuffer is
    always nonpaged so no locking/mapping is needed. thus, the mdl path now contains an assert.

Arguments:

    RxContext - Pointer to the IrpC for the request.

Return Value:

    Mapped address

--*/
{
    PAGED_CODE();

    if (Irp->MdlAddress == NULL) {
       return Irp->AssociatedIrp.SystemBuffer;
    } else {
       ASSERT (!"there should not be an MDL in this irp!!!!!");
       return MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
    }
}

PVOID
RxMapUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine returns the address of the userbuffer. if an MDL exists then the assumption is that
    the mdl describes the userbuffer and the system address for the mdl is returned. otherwise, the userbuffer
    is returned directly.

Arguments:

    RxContext - Pointer to the IrpC for the request.

Return Value:

    Mapped address

--*/
{
    PAGED_CODE();

    if (Irp->MdlAddress == NULL) {
       return Irp->UserBuffer;
    } else {
       return MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  from here down (except for fsctl buffer determination), everything is available for either wrapper. we may
//  decide that the fsctl stuff should be moved as well
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

VOID
RxInitializeLowIoContext (
    PRX_CONTEXT RxContext,
    ULONG Operation,
    PLOWIO_CONTEXT LowIoContext
    )
/*++

Routine Description:

    This routine initializes the LowIO context in the RxContext.

Arguments:

    RxContext - context of irp being processed.

Return Value:

    none

--*/
{
    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    PAGED_CODE();

    ASSERT( LowIoContext == &RxContext->LowIoContext );

    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );

    //
    //  this ID is used to release the resource on behalf of another thread....
    //  e.g. it is used when an async routine completes to release the thread
    //       acquired by the first acquirer.
    //

    LowIoContext->ResourceThreadId = ExGetCurrentResourceThread();

    LowIoContext->Operation = (USHORT)Operation;

    switch (Operation) {
    case LOWIO_OP_READ:
    case LOWIO_OP_WRITE:

#if DBG
        LowIoContext->ParamsFor.ReadWrite.ByteOffset = 0xffffffee; //  no operation should start there!
        LowIoContext->ParamsFor.ReadWrite.ByteCount = 0xeeeeeeee;  //  no operation should start there!
#endif
        
        ASSERT( &IrpSp->Parameters.Read.Length == &IrpSp->Parameters.Write.Length );
        ASSERT( &IrpSp->Parameters.Read.Key == &IrpSp->Parameters.Write.Key );
        
        LowIoContext->ParamsFor.ReadWrite.Key = IrpSp->Parameters.Read.Key;
        LowIoContext->ParamsFor.ReadWrite.Flags = (FlagOn( Irp->Flags, IRP_PAGING_IO ) ? LOWIO_READWRITEFLAG_PAGING_IO : 0);
        break;

    case LOWIO_OP_FSCTL:
    case LOWIO_OP_IOCTL:
        LowIoContext->ParamsFor.FsCtl.Flags = 0;
        LowIoContext->ParamsFor.FsCtl.InputBufferLength = 0;
        LowIoContext->ParamsFor.FsCtl.pInputBuffer = NULL;
        LowIoContext->ParamsFor.FsCtl.OutputBufferLength = 0;
        LowIoContext->ParamsFor.FsCtl.pOutputBuffer = NULL;
        LowIoContext->ParamsFor.FsCtl.MinorFunction = 0;
        break;

    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
    case LOWIO_OP_UNLOCK_MULTIPLE:
    case LOWIO_OP_CLEAROUT:
    case LOWIO_OP_NOTIFY_CHANGE_DIRECTORY:
        break;
    default:
        ASSERT( FALSE );
    }
}

PVOID
RxLowIoGetBufferAddress (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine gets the buffer corresponding to the Mdl in the LowIoContext.

Arguments:

    RxContext - context for the request.

Return Value:

    Mapped address

--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    if (LowIoContext->ParamsFor.ReadWrite.ByteCount > 0) {
        
        ASSERT( LowIoContext->ParamsFor.ReadWrite.Buffer );
        return MmGetSystemAddressForMdlSafe( LowIoContext->ParamsFor.ReadWrite.Buffer, NormalPagePriority );
    } else {
        return NULL;
    }
}

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine just calls LowIoSubmit; the completion routine was previously
    stored so we just extract it and pass it in. This is called out of the Fsp
    dispatcher for retrying at the low level.


Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/
{
    PFCB Fcb = (PFCB)RxContext->pFcb;

    PAGED_CODE();

    return RxLowIoSubmit( RxContext, Irp, Fcb, RxContext->LowIoContext.CompletionRoutine );
}

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called by lowio routines at the very end...i.e. after the individual completion
    routines are called.


Arguments:

    RxContext - the RDBSS context

Return Value:

    whatever value supplied by the caller.

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG Operation = LowIoContext->Operation;
    BOOLEAN  SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    RxDbgTrace( +1, Dbg, ("RxLowIoCompletionTail, Operation=%08lx\n",LowIoContext->Operation) );

    if ((KeGetCurrentIrql() < DISPATCH_LEVEL ) || 
        (FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_CAN_COMPLETE_AT_DPC_LEVEL ))) {
    
        Status = RxContext->LowIoContext.CompletionRoutine( RxContext );

    } else {
        
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if ((Status == STATUS_MORE_PROCESSING_REQUIRED) || (Status == STATUS_RETRY)) {
        
        RxDbgTrace( -1, Dbg, ("RxLowIoCompletionTail wierdstatus, Status=%08lx\n", Status) );
        return Status;
    }

    switch (Operation) {
    case LOWIO_OP_READ:
    case LOWIO_OP_WRITE:
        
        if (FlagOn( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO )) {
            
            RxDbgTrace( 0, Dbg, ("RxLowIoCompletionTail pagingio unblock\n") );

            ExAcquireFastMutexUnsafe( &RxLowIoPagingIoSyncMutex );
            RxRemoveFromOutStandingPagingOperationsList( RxContext );
            ExReleaseFastMutexUnsafe( &RxLowIoPagingIoSyncMutex );

            RxResumeBlockedOperations_ALL( RxContext );
        }
        break;

    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
    case LOWIO_OP_UNLOCK_MULTIPLE:
    case LOWIO_OP_CLEAROUT:
        break;

    case LOWIO_OP_FSCTL:
    case LOWIO_OP_IOCTL:
    case LOWIO_OP_NOTIFY_CHANGE_DIRECTORY:
        break;

    default:
        ASSERT( !"Valid Low Io Op Code" );
    }

    if (!FlagOn( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SYNCCALL )) {

        //
        //  if we're being called from lowiosubmit then just get out otherwise...do the completion
        //

        RxCompleteAsynchronousRequest( RxContext, Status );
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoCompletionTail, Status=%08lx\n",Status));
    return(Status);
}

NTSTATUS
RxLowIoCompletion (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine must be called by the MiniRdr LowIo routines when they complete,
    IF THEY HAVE INITIALLY RETURNED PENDING.

    It behaves a bit differently depending on whether it's sync or async IO.
    For sync, we just get back into the user's thread. For async, we first try
    the completion routine directly. If we get MORE_PROCESSING, then we flip to
    a thread and the routine will be recalled.

Arguments:

    RxContext - the RDBSS context

Return Value:

    Whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).
    The value M_P_R is very handy if this is being called for a Irp completion.
    M_P_R causes the Irp completion guy to stop processing which is good since
    the called completion routine may complete the packet.

--*/
{
    NTSTATUS Status;
    BOOLEAN SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    if (SynchronousIo) {
        
        RxSignalSynchronousWaiter( RxContext );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    RxDbgTrace( 0, Dbg, ("RxLowIoCompletion ASYNC\n") );
    
    ASSERT( RxLowIoIsBufferLocked( &RxContext->LowIoContext ) );

    Status = RxLowIoCompletionTail( RxContext );

    //
    //  The called routine makes the decision as to whether it can continue. Many
    //  will ask for a post if we're at DPC level. Some will not.
    //


    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        
        RxPostToWorkerThread( RxFileSystemDeviceObject,  
                              HyperCriticalWorkQueue,
                              &RxContext->WorkQueueItem,
                              RxLowIoCompletion,
                              RxContext );
        
        
    } else if (Status == STATUS_RETRY) {

        //
        //  I'm not too sure about this.
        //
        
        RxFsdPostRequestWithResume( RxContext, RxLowIoSubmitRETRY );
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    return Status;
}


#if DBG
VOID
RxAssertFsctlIsLikeIoctl ()
{
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.OutputBufferLength)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.OutputBufferLength) );
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.InputBufferLength)
             == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.InputBufferLength) );
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.FsControlCode)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.IoControlCode) );
    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION,Parameters.FileSystemControl.Type3InputBuffer)
            == FIELD_OFFSET(IO_STACK_LOCATION,Parameters.DeviceIoControl.Type3InputBuffer) );
}
#else
#define RxAssertFsctlIsLikeIoctl()
#endif //if DBG


NTSTATUS
NTAPI
RxLowIoPopulateFsctlInfo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PAGED_CODE();

    RxAssertFsctlIsLikeIoctl();

    LowIoContext->ParamsFor.FsCtl.FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;
    LowIoContext->ParamsFor.FsCtl.InputBufferLength =  IrpSp->Parameters.FileSystemControl.InputBufferLength;
    LowIoContext->ParamsFor.FsCtl.OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    LowIoContext->ParamsFor.FsCtl.MinorFunction = IrpSp->MinorFunction;

    switch (LowIoContext->ParamsFor.FsCtl.FsControlCode & 3) {
    
    case METHOD_BUFFERED:
                
        LowIoContext->ParamsFor.FsCtl.pInputBuffer = Irp->AssociatedIrp.SystemBuffer;
        LowIoContext->ParamsFor.FsCtl.pOutputBuffer = Irp->AssociatedIrp.SystemBuffer;
        break;

    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:
        
        LowIoContext->ParamsFor.FsCtl.pInputBuffer = Irp->AssociatedIrp.SystemBuffer;
        if (Irp->MdlAddress != NULL) {
            
            LowIoContext->ParamsFor.FsCtl.pOutputBuffer = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );
            if (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {
            LowIoContext->ParamsFor.FsCtl.pOutputBuffer = NULL;
        }
        break;

    case METHOD_NEITHER:
        
        LowIoContext->ParamsFor.FsCtl.pInputBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
        LowIoContext->ParamsFor.FsCtl.pOutputBuffer = Irp->UserBuffer;
        break;

    default:
        
        ASSERT(!"Valid Method for Fs Control");
        break;
    }

    return Status;
}

NTSTATUS
RxLowIoSubmit (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    PLOWIO_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    This routine passes the request to the minirdr after setting up for completion. it then waits
    or pends as appropriate.

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIoCompletion.

--*/
{
    IN PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    IN PFILE_OBJECT FileObject = IrpSp->FileObject;

    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG Operation = LowIoContext->Operation;
    BOOLEAN SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    PAGED_CODE();

    LowIoContext->CompletionRoutine = CompletionRoutine;

    RxDbgTrace(+1, Dbg, ("RxLowIoSubmit, Operation=%08lx\n",LowIoContext->Operation));

    //
    //  if fcb is shadowed and user buffer are not already locked then try fast path
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_SHADOWED ) &&
        !FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED )) {

        RxContext->InformationToReturn = 0;
        Status = RxShadowFastLowIo( RxContext, Irp );

        if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
            return Status;
        }
    
        Status = STATUS_SUCCESS;
    }

    switch (Operation) {
    case LOWIO_OP_READ:
    case LOWIO_OP_WRITE:
        
        ASSERT( LowIoContext->ParamsFor.ReadWrite.ByteOffset != 0xffffffee );
        ASSERT (LowIoContext->ParamsFor.ReadWrite.ByteCount != 0xeeeeeeee );
        Status = RxLockAndMapUserBufferForLowIo( RxContext, Irp, LowIoContext, Operation);
    
        //
        //  NT paging IO is different from WIN9X so this may be different
        //
        
        if (FlagOn( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO )) {
            
            ExAcquireFastMutexUnsafe( &RxLowIoPagingIoSyncMutex );
            RxContext->BlockedOpsMutex = &RxLowIoPagingIoSyncMutex;
            RxInsertIntoOutStandingPagingOperationsList( RxContext, Operation );
            ExReleaseFastMutexUnsafe( &RxLowIoPagingIoSyncMutex );

        }
        break;

    case LOWIO_OP_FSCTL:
    case LOWIO_OP_IOCTL:

        Status = RxLowIoPopulateFsctlInfo( RxContext, Irp );

        if (Status == STATUS_SUCCESS) {
            if ((LowIoContext->ParamsFor.FsCtl.InputBufferLength > 0) &&
                (LowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL)) {
                
                Status = STATUS_INVALID_PARAMETER;
            }
    
            if ((LowIoContext->ParamsFor.FsCtl.OutputBufferLength > 0) &&
                (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL)) {
                
                Status = STATUS_INVALID_PARAMETER;
            }
        }

        break;

    case LOWIO_OP_NOTIFY_CHANGE_DIRECTORY:
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
    case LOWIO_OP_UNLOCK:
    case LOWIO_OP_UNLOCK_MULTIPLE:
    case LOWIO_OP_CLEAROUT:
        break;

    default:
        ASSERTMSG( "Invalid Low Io Op Code", FALSE );
        Status = STATUS_INVALID_PARAMETER;
    }

    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED );

    if (Status == STATUS_SUCCESS) {
        
        PMINIRDR_DISPATCH MiniRdrDispatch;

        if (!SynchronousIo) {

            //
            //  get ready for any arbitrary finish order...assume return of pending
            //

            InterlockedIncrement( &RxContext->ReferenceCount );

            if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP )) {
                IoMarkIrpPending( Irp );
            }

            RxDbgTrace( 0, Dbg, ("RxLowIoSubmit, Operation is ASYNC!\n"));
        }

        MiniRdrDispatch = RxContext->RxDeviceObject->Dispatch;

        if (MiniRdrDispatch != NULL) {

            //
            //  Use private dispatch if lwio is enabled on this file
            //
            
            if (FlagOn( Fcb->FcbState, FCB_STATE_LWIO_ENABLED ) &&
                (Fcb->MRxDispatch != NULL)) {
            
                MiniRdrDispatch = Fcb->MRxDispatch;
            }

            do {
                
                RxContext->InformationToReturn = 0;
        
                Status = STATUS_MORE_PROCESSING_REQUIRED;
        
                //
                //  handle shadowed fcb
                //
        
                if (FlagOn( Fcb->FcbState, FCB_STATE_FILE_IS_SHADOWED )) {
                    Status = RxShadowLowIo( RxContext, Irp, Fcb );
                }

                //
                //  call underlying mini-rdr if more processing is needed
                //

                if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                    
                    MINIRDR_CALL( Status,
                                  RxContext,
                                  MiniRdrDispatch,
                                  MRxLowIOSubmit[LowIoContext->Operation],
                                  (RxContext) );
                }

                if (Status == STATUS_PENDING){
                    
                    if (!SynchronousIo) {
                        goto FINALLY;
                    }
                    RxWaitSync( RxContext );
                    Status = RxContext->StoredStatus;
                
                } else {
                    
                    if (!SynchronousIo && (Status != STATUS_RETRY)) {
                        
                        //
                        //  we were wrong about pending..so clear the bit and deref
                        //

                        if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP )) {

                            ClearFlag( IrpSp->Control, SL_PENDING_RETURNED );
                        }
                        InterlockedDecrement( &RxContext->ReferenceCount );
                    }
                }
            } while (Status == STATUS_RETRY);
        
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  you do not come here for pended,async IO
    //

    RxContext->StoredStatus = Status;
    SetFlag( LowIoContext->Flags, LOWIO_CONTEXT_FLAG_SYNCCALL );
    Status = RxLowIoCompletionTail( RxContext );

FINALLY:
    
RxDbgTrace( -1, Dbg, ("RxLowIoSubmit, Status=%08lx\n",Status) );
    return Status;
}


VOID
RxInitializeLowIoPerFcbInfo(
    PLOWIO_PER_FCB_INFO LowIoPerFcbInfo
    )
/*++

Routine Description:

    This routine is called in FcbInitialization to initialize the LowIo part of the structure.



Arguments:

    LowIoPerFcbInfo - the struct to be initialized

Return Value:


--*/
{
    PAGED_CODE();

    InitializeListHead( &LowIoPerFcbInfo->PagingIoReadsOutstanding );
    InitializeListHead( &LowIoPerFcbInfo->PagingIoWritesOutstanding );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\fcbtable.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.c

Abstract:

    This module implements the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:

    Balan Sethu Raman (SethuR)    10/17/96

Revision History:

    This was derived from the original implementation of prefix tables done
    by Joe Linn.

--*/


#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxTableComputePathHashValue)
#pragma alloc_text(PAGE, RxInitializeFcbTable)
#pragma alloc_text(PAGE, RxFinalizeFcbTable)
#pragma alloc_text(PAGE, RxFcbTableLookupFcb)
#pragma alloc_text(PAGE, RxFcbTableInsertFcb)
#pragma alloc_text(PAGE, RxFcbTableRemoveFcb)
#endif

//
// The debug trace level
//

#define Dbg              (DEBUG_TRACE_PREFIX)

ULONG
RxTableComputePathHashValue (
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

   here, we compute a caseinsensitive hashvalue.  we want to avoid a call/char to
   the unicodeupcase routine but we want to still have some reasonable spread on
   the hashvalues.  many rules just dont work for known important cases.  for
   example, the (use the first k and the last n) rule that old c compilers used
   doesn't pickup the difference among \nt\private\......\slm.ini and that would be
   nice.  note that the underlying comparison used already takes cognizance of the
   length before comparing.

   the rule we have selected is to use the 2nd, the last 4, and three selected
   at 1/4 points

Arguments:

    Name      - the name to be hashed

Return Value:

    ULONG which is a hashvalue for the name given.

--*/
{
    ULONG HashValue;
    LONG i,j;   
    LONG Length = Name->Length / sizeof( WCHAR );
    PWCHAR Buffer = Name->Buffer;
    LONG Probe[8];

    PAGED_CODE();

    HashValue = 0;

    Probe[0] = 1;
    Probe[1] = Length - 1;
    Probe[2] = Length - 2;
    Probe[3] = Length - 3;
    Probe[4] = Length - 4;
    Probe[5] = Length >> 2;
    Probe[6] = (2 * Length) >> 2;
    Probe[7] = (3 * Length) >> 2;

    for (i = 0; i < 8; i++) {
        j = Probe[i];
        if ((j < 0) || (j >= Length)) {
            continue;
        }
        HashValue = (HashValue << 3) + RtlUpcaseUnicodeChar( Buffer[j] );
    }

    RxDbgTrace( 0, Dbg, ("RxTableComputeHashValue Hashv=%ld Name=%wZ\n", HashValue, Name ));
    return HashValue;
}


#define HASH_BUCKET(TABLE,HASHVALUE) &((TABLE)->HashBuckets[(HASHVALUE) % (TABLE)->NumberOfBuckets])

VOID
RxInitializeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN BOOLEAN CaseInsensitiveMatch
    )
/*++

Routine Description:

    The routine initializes the RX_FCB_TABLE data structure

Arguments:

    pFcbTable - the table instance to be initialized.

    CaseInsensitiveMatch - indicates if all the lookups will be case
                           insensitive

--*/

{
    ULONG i;

    PAGED_CODE();

    // 
    //  this is not zero'd so you have to be careful to init everything
    //

    FcbTable->NodeTypeCode = RDBSS_NTC_FCB_TABLE;
    FcbTable->NodeByteSize = sizeof( RX_PREFIX_TABLE );

    ExInitializeResourceLite( &FcbTable->TableLock );

    FcbTable->Version = 0;
    FcbTable->TableEntryForNull = NULL;

    FcbTable->CaseInsensitiveMatch = CaseInsensitiveMatch;

    FcbTable->NumberOfBuckets = RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS;
    for (i=0; i < FcbTable->NumberOfBuckets; i++) {
        InitializeListHead( &FcbTable->HashBuckets[i] );
    }

    FcbTable->Lookups = 0;
    FcbTable->FailedLookups = 0;
    FcbTable->Compares = 0;
}

VOID
RxFinalizeFcbTable (
    IN OUT PRX_FCB_TABLE FcbTable
    )
/*++

Routine Description:

    The routine deinitializes a prefix table.

Arguments:

    FcbTable - the table to be finalized.

Return Value:

    None.

--*/
{
    ULONG i;

    PAGED_CODE();

    ExDeleteResourceLite( &FcbTable->TableLock );

#if DBG
    for (i=0; i < FcbTable->NumberOfBuckets; i++) {
        ASSERT( IsListEmpty( &FcbTable->HashBuckets[i] ) );
    }
#endif
}

PFCB
RxFcbTableLookupFcb (
    IN  PRX_FCB_TABLE FcbTable,
    IN  PUNICODE_STRING Path
    )
/*++

Routine Description:

    The routine looks up a path in the RX_FCB_TABLE instance.

Arguments:

    FcbTable - the table to be looked in.

    Path    - the name to be looked up

Return Value:

    a pointer to an FCB instance if successful, otherwise NULL

--*/
{
    ULONG HashValue;
    PLIST_ENTRY HashBucket, ListEntry;
    PRX_FCB_TABLE_ENTRY FcbTableEntry;
    PFCB Fcb = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFcbTableLookupName %lx %\n",FcbTable));

    if (Path->Length == 0) {
        FcbTableEntry = FcbTable->TableEntryForNull;
    } else {
        
        HashValue = RxTableComputePathHashValue( Path );
        HashBucket = HASH_BUCKET( FcbTable, HashValue );

        for (ListEntry =  HashBucket->Flink;
             ListEntry != HashBucket;
             ListEntry =  ListEntry->Flink) {


            FcbTableEntry = (PRX_FCB_TABLE_ENTRY)CONTAINING_RECORD( ListEntry, RX_FCB_TABLE_ENTRY, HashLinks );

            InterlockedIncrement( &FcbTable->Compares );

            if ((FcbTableEntry->HashValue == HashValue) &&
                (FcbTableEntry->Path.Length == Path->Length) &&
                (RtlEqualUnicodeString( Path, &FcbTableEntry->Path, FcbTable->CaseInsensitiveMatch ))) {

                break;
            }
        }

        if (ListEntry == HashBucket) {
            FcbTableEntry = NULL;
        }
    }

    InterlockedIncrement( &FcbTable->Lookups );

    if (FcbTableEntry == NULL) {
        InterlockedIncrement( &FcbTable->FailedLookups );
    } else {
        Fcb = (PFCB)CONTAINING_RECORD( FcbTableEntry, FCB, FcbTableEntry );

        RxReferenceNetFcb( Fcb );
    }

    RxDbgTraceUnIndent( -1,Dbg );

    return Fcb;
}

NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    )
/*++

Routine Description:

    This routine inserts a FCB  in the RX_FCB_TABLE instance.

Arguments:

    FcbTable - the table to be looked in.

    Fcb      - the FCB instance to be inserted

Return Value:

    STATUS_SUCCESS if successful

Notes:

    The insertion routine combines the semantics of an insertion followed by
    lookup. This is the reason for the additional reference. Otherwise an
    additional call to reference the FCB inserted in the table needs to
    be made

--*/
{
    PRX_FCB_TABLE_ENTRY FcbTableEntry;
    ULONG HashValue;
    PLIST_ENTRY ListEntry, HashBucket;

    PAGED_CODE();

    ASSERT( RxIsFcbTableLockExclusive( FcbTable ) );

    FcbTableEntry = &Fcb->FcbTableEntry;
    FcbTableEntry->HashValue = RxTableComputePathHashValue( &FcbTableEntry->Path );
    HashBucket = HASH_BUCKET( FcbTable, FcbTableEntry->HashValue );

    RxReferenceNetFcb( Fcb );

    if (FcbTableEntry->Path.Length){
        InsertHeadList( HashBucket, &FcbTableEntry->HashLinks );
    } else {
        FcbTable->TableEntryForNull = FcbTableEntry;
    }

    InterlockedIncrement( &FcbTable->Version );

    return STATUS_SUCCESS;
}

NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE FcbTable,
    IN OUT PFCB Fcb
    )
/*++

Routine Description:

    This routine deletes an instance from the table

Arguments:

    FcbTable - the table to be looked in.

    Fcb      - the FCB instance to be inserted

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    PRX_FCB_TABLE_ENTRY FcbTableEntry;

    PAGED_CODE();

    ASSERT( RxIsPrefixTableLockExclusive( FcbTable ) );

    FcbTableEntry = &Fcb->FcbTableEntry;

    if (FcbTableEntry->Path.Length) {
        RemoveEntryList( &FcbTableEntry->HashLinks );
    } else {
        FcbTable->TableEntryForNull = NULL;
    }

    InitializeListHead( &FcbTableEntry->HashLinks );
    InterlockedIncrement( &FcbTable->Version );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\resrcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Rx Resource acquisition routines

Author:

    Joe Linn    [JoeLi]    22-Mar-1995

Revision History:

    Balan Sethu Raman [SethuR] 7-June-95

      Modified return value of resource acquistion routines to RXSTATUS to incorporate
      aborts of cancelled requests.

    Balan Sethu Raman [SethuR] 8-Nov-95

      Unified FCB resource acquistion routines and incorporated the two step process
      for handling change buffering state requests in progress.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  no special bug check id for this module
//

#define BugCheckFileId                   (0)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESRCSUP)

#ifdef RDBSS_TRACKER
#define TRACKER_Doit(XXX__) XXX__
#define TRACKER_ONLY_DECL(XXX__) XXX__

VOID RxTrackerUpdateHistory (
    PRX_CONTEXT RxContext,
    IN OUT PMRX_FCB MrxFcb,
    IN ULONG Operation,
    IN ULONG LineNumber,
    IN PSZ FileName,
    IN ULONG SerialNumber
    )
{
    PFCB Fcb = (PFCB)MrxFcb;
    ULONG i;
    RX_FCBTRACKER_CASES TrackerType;

    //
    //  boy this is some great code!
    //

    if (RxContext == NULL) {
        TrackerType = (RX_FCBTRACKER_CASE_NULLCONTEXT);
    } else if (RxContext == CHANGE_BUFFERING_STATE_CONTEXT) {
        TrackerType = (RX_FCBTRACKER_CASE_CBS_CONTEXT);
    }  else if (RxContext == CHANGE_BUFFERING_STATE_CONTEXT_WAIT) {
        TrackerType = (RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT);
    }  else {
        
        ASSERT( NodeType( RxContext ) == RDBSS_NTC_RX_CONTEXT );
        TrackerType = (RX_FCBTRACKER_CASE_NORMAL);
    }

    if (Fcb != NULL) {
        
        ASSERT( NodeTypeIsFcb( Fcb ) );
        
        if (Operation == 'aaaa') {
            Fcb->FcbAcquires[TrackerType] += 1;
        } else {
            Fcb->FcbReleases[TrackerType] += 1;
        }
    }

    if (TrackerType != RX_FCBTRACKER_CASE_NORMAL) {
        return;
    }

    if (Operation == 'aaaa') {
        InterlockedIncrement( &RxContext->AcquireReleaseFcbTrackerX );
    } else {
        InterlockedDecrement( &RxContext->AcquireReleaseFcbTrackerX );
    }

    i = InterlockedIncrement( &RxContext->TrackerHistoryPointer ) - 1;
    
    if (i < RDBSS_TRACKER_HISTORY_SIZE) {
        
        RxContext->TrackerHistory[i].AcquireRelease = Operation;
        RxContext->TrackerHistory[i].LineNumber = (USHORT)LineNumber;
        RxContext->TrackerHistory[i].FileName = FileName;
        RxContext->TrackerHistory[i].SavedTrackerValue = (USHORT)(RxContext->AcquireReleaseFcbTrackerX);
        RxContext->TrackerHistory[i].Flags = (ULONG)(RxContext->Flags);
    }

    ASSERT( RxContext->AcquireReleaseFcbTrackerX >= 0 );

}
#else

#define TRACKER_Doit(XXX__)
#define TRACKER_ONLY_DECL(XXX__)

#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxAcquireExclusiveFcbResourceInMRx)
#pragma alloc_text(PAGE, RxAcquireSharedFcbResourceInMRx)
#pragma alloc_text(PAGE, RxReleaseFcbResourceInMRx)
#pragma alloc_text(PAGE, __RxAcquireFcb)
#pragma alloc_text(PAGE, RxAcquireFcbForLazyWrite)
#pragma alloc_text(PAGE, RxAcquireFcbForReadAhead)
#pragma alloc_text(PAGE, RxNoOpAcquire)
#pragma alloc_text(PAGE, RxNoOpRelease)
#pragma alloc_text(PAGE, RxReleaseFcbFromLazyWrite)
#pragma alloc_text(PAGE, RxReleaseFcbFromReadAhead)
#pragma alloc_text(PAGE, RxVerifyOperationIsLegal)
#pragma alloc_text(PAGE, RxAcquireFileForNtCreateSection)
#pragma alloc_text(PAGE, RxReleaseFileForNtCreateSection)
#endif

NTSTATUS
RxAcquireExclusiveFcbResourceInMRx (
    PMRX_FCB Fcb
    )
{
    return RxAcquireExclusiveFcb( NULL, (PFCB)Fcb );
}

NTSTATUS
RxAcquireSharedFcbResourceInMRx (
    PMRX_FCB Fcb
    )
{
    return RxAcquireSharedFcb( NULL, (PFCB)Fcb );
}

VOID
RxReleaseFcbResourceInMRx (
    PMRX_FCB Fcb
    )
{
    RxReleaseFcb( NULL, Fcb );
}

NTSTATUS
__RxAcquireFcb(
    IN OUT PFCB Fcb,
    IN PRX_CONTEXT RxContext OPTIONAL, 
    IN ULONG Mode
     
#ifdef RDBSS_TRACKER
    ,ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
#endif
    
    )
/*++

Routine Description:

    This routine acquires the Fcb in the specified mode and ensures that the desired
    operation is legal. If it is not legal the resource is released and the
    appropriate error code is returned.

Arguments:

    Fcb      - the FCB

    RxContext - supplies the context of the operation for special treatement
                particularly of async, noncached writes. if NULL, you don't do
                the special treatment.

    Mode      - the mode in which the FCB is to be acquired.

Return Value:

    STATUS_SUCCESS          -- the Fcb was acquired
    STATUS_LOCK_NOT_GRANTED -- the resource was not acquired
    STATUS_CANCELLED        -- the associated RxContext was cancelled.

Notes:

    There are three kinds of resource acquistion patterns folded into this routine.
    These are all dependent upon the context passed in.

    1) When the context parameter is NULL the resource acquistion routines wait for the
    the FCB resource to be free, i.e., this routine does not return control till the
    resource has been accquired.

    2) When the context is CHANGE_BUFFERING_STATE_CONTEXT the resource acquistion routines
    do not wait for the resource to become free. The control is returned if the resource is not
    available immmediately.

    2) When the context is CHANGE_BUFFERING_STATE_CONTEXT_WAIT the resource acquistion routines
    wait for the resource to become free but bypass the wait for the buffering state change

    3) When the context parameter represents a valid context the behaviour is dictated
    by the flags associated with the context. If the context was cancelled while
    waiting the control is returned immediately with the appropriate erroc code
    (STATUS_CANCELLED). If not the waiting behaviour is dictated by the wait flag in
    the context.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN  ResourceAcquired;
    BOOLEAN  UncachedAsyncWrite;
    BOOLEAN  Wait;
    BOOLEAN  ValidContext = FALSE;
    BOOLEAN  RecursiveAcquire;
    BOOLEAN  ChangeBufferingStateContext;


    PAGED_CODE();

    ChangeBufferingStateContext = (RxContext == CHANGE_BUFFERING_STATE_CONTEXT) ||
                                 (RxContext == CHANGE_BUFFERING_STATE_CONTEXT_WAIT);

    RecursiveAcquire = RxIsFcbAcquiredExclusive( Fcb ) || (RxIsFcbAcquiredShared( Fcb ) > 0);

    if (!RecursiveAcquire && !ChangeBufferingStateContext) {

        //
        //  Ensure that no change buffering requests are currently being processed
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING )) {
                     
            BOOLEAN WaitForChangeBufferingStateProcessing; 

            //
            //  A buffering change state request is pending which gets priority
            //  over all other FCB resource acquistion requests. Hold this request
            //  till the buffering state change request has been completed.
            //

            RxAcquireSerializationMutex();

            WaitForChangeBufferingStateProcessing = BooleanFlagOn( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );

            RxReleaseSerializationMutex();

            if (WaitForChangeBufferingStateProcessing) {
                
                RxLog(( "_RxAcquireFcb CBS wait %lx\n", Fcb ));
                RxWmiLog( LOG,
                          RxAcquireFcb_1,
                          LOGPTR( Fcb ) );
            
                ASSERT( Fcb->pBufferingStateChangeCompletedEvent != NULL );
                KeWaitForSingleObject( Fcb->pBufferingStateChangeCompletedEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PLARGE_INTEGER)NULL );
                RxLog(( "_RxAcquireFcb CBS wait over %lx\n", Fcb ));
                RxWmiLog( LOG,
                          RxAcquireFcb_2,
                          LOGPTR( Fcb ) );
            }
        }
    }
    
    //
    //  Set up the parameters for acquiring the resource.
    //
    
    if (ChangeBufferingStateContext) {

        //
        //  An acquisition operation initiated for changing the buffering state will
        //  not wait.
        //

        Wait = (RxContext == CHANGE_BUFFERING_STATE_CONTEXT_WAIT);
        UncachedAsyncWrite = FALSE;

    } else if (RxContext == NULL) {
      
        Wait = TRUE;
        UncachedAsyncWrite = FALSE;
    
    } else {

        ValidContext = TRUE;
            
        Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
        
        UncachedAsyncWrite = (RxContext->MajorFunction == IRP_MJ_WRITE) &&
                             FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION ) &&
                             (FlagOn( RxContext->CurrentIrp->Flags, IRP_NOCACHE ) ||
                              !RxWriteCachingAllowed( Fcb, ((PFOBX)(RxContext->pFobx))->SrvOpen ));
        
        if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {
            Status = STATUS_CANCELLED;
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    if (Status == STATUS_SUCCESS) {
      
        do {
            
            Status = STATUS_LOCK_NOT_GRANTED;

            switch (Mode) {
            
            case FCB_MODE_EXCLUSIVE:
                
                ResourceAcquired = ExAcquireResourceExclusiveLite( Fcb->Header.Resource, Wait );
                break;
         
            case FCB_MODE_SHARED:
                
                ResourceAcquired = ExAcquireResourceSharedLite( Fcb->Header.Resource, Wait );
                break;

            case FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE:
                
                ResourceAcquired = ExAcquireSharedWaitForExclusive( Fcb->Header.Resource, Wait );
                break;                                                                         
         
            case FCB_MODE_SHARED_STARVE_EXCLUSIVE:
            
                ResourceAcquired = ExAcquireSharedStarveExclusive( Fcb->Header.Resource, Wait );
                break;
         
            default:
                
                ASSERTMSG( "Valid Mode for acquiring FCB resource", FALSE );
                ResourceAcquired = FALSE;
                break;
            }

            
            if (ResourceAcquired) {
            
                Status = STATUS_SUCCESS;

                //
                //  If the resource was acquired and it is an async. uncached write operation
                //  if the number of outstanding writes operations are greater than zero and there
                //  are outstanding waiters,
                //
                
                ASSERT_CORRECT_FCB_STRUCTURE( Fcb );
                
                if ((Fcb->NonPaged->OutstandingAsyncWrites != 0) &&
                    (!UncachedAsyncWrite ||
                     (Fcb->Header.Resource->NumberOfSharedWaiters != 0) ||
                     (Fcb->Header.Resource->NumberOfExclusiveWaiters != 0))) {
                
                    KeWaitForSingleObject( Fcb->NonPaged->OutstandingAsyncEvent,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           (PLARGE_INTEGER)NULL );
                
                    ASSERT_CORRECT_FCB_STRUCTURE(Fcb);
                
                    RxReleaseFcb( NULL, Fcb );    //  this is not a contextful release;
                    
#ifdef RDBSS_TRACKER
                    
                    //
                    //  in fact, this doesn't count as a release at all; dec the count
                    //
                
                    Fcb->FcbReleases[RX_FCBTRACKER_CASE_NULLCONTEXT] -= 1;
#endif
                
                    ResourceAcquired = FALSE;
                
                    if (ValidContext) {
                    
                        ASSERT(( NodeType( RxContext ) == RDBSS_NTC_RX_CONTEXT) );

                        //
                        //  if the context is still valid, i.e., it has not been cancelled
                        //
                   
                        if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED)) {
                            Status = STATUS_CANCELLED;
                        } else {
                            Status = STATUS_SUCCESS;
                        }
                    }   
                }
            }
        } while (!ResourceAcquired && (Status == STATUS_SUCCESS));

        if (ResourceAcquired &&
            ValidContext &&
            !FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK )) {

            try {

                 RxVerifyOperationIsLegal( RxContext );

            } finally {
                 
                 if ( AbnormalTermination() ) {
                    
                    ExReleaseResourceLite( Fcb->Header.Resource );
                    Status = STATUS_LOCK_NOT_GRANTED;
                }
            }
        }
    }

#ifdef RDBSS_TRACKER
   if (Status == STATUS_SUCCESS) {
       RxTrackerUpdateHistory( RxContext, (PMRX_FCB)Fcb, 'aaaa', LineNumber, FileName, SerialNumber );
   }
#endif

   return Status;
}

VOID
__RxReleaseFcb(
    IN PRX_CONTEXT RxContext,
    IN OUT PMRX_FCB MrxFcb
    
#ifdef RDBSS_TRACKER
    ,IN ULONG LineNumber,
    IN PSZ FileName,
    IN ULONG SerialNumber
#endif

    )
{
    PFCB Fcb = (PFCB)MrxFcb;
    BOOLEAN ChangeBufferingStateRequestsPending;
    BOOLEAN ResourceExclusivelyOwned;

    RxAcquireSerializationMutex();

    ChangeBufferingStateRequestsPending =  BooleanFlagOn( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );
    ResourceExclusivelyOwned = RxIsResourceOwnershipStateExclusive( Fcb->Header.Resource );

    if (!ChangeBufferingStateRequestsPending) {
        
        RxTrackerUpdateHistory( RxContext, MrxFcb, 'rrrr', LineNumber, FileName, SerialNumber );
        ExReleaseResourceLite( Fcb->Header.Resource );

    } else if (!ResourceExclusivelyOwned) {
        
        RxTrackerUpdateHistory( RxContext, MrxFcb, 'rrr0', LineNumber, FileName, SerialNumber );
        ExReleaseResourceLite( Fcb->Header.Resource );
    }

    RxReleaseSerializationMutex();

    if (ChangeBufferingStateRequestsPending) {
        if (ResourceExclusivelyOwned) {
          
            ASSERT( RxIsFcbAcquiredExclusive( Fcb ) );

            //
            //  If there are any buffering state change requests process them.
            //
          
            RxProcessFcbChangeBufferingStateRequest( Fcb );

            RxTrackerUpdateHistory( RxContext, MrxFcb, 'rrr1', LineNumber, FileName, SerialNumber );
            ExReleaseResourceLite( Fcb->Header.Resource );
        }
    }
}


VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT      RxContext,
    IN OUT PMRX_FCB MrxFcb,
    IN ERESOURCE_THREAD ResourceThreadId
    
#ifdef RDBSS_TRACKER
    ,IN ULONG LineNumber,
    IN PSZ FileName,
    IN ULONG SerialNumber
#endif

    )
{
    PFCB Fcb = (PFCB)MrxFcb;
    BOOLEAN BufferingInTransistion;
    BOOLEAN ExclusivelyOwned;

    RxAcquireSerializationMutex();

    BufferingInTransistion = BooleanFlagOn( Fcb->FcbState, FCB_STATE_BUFFERING_STATE_CHANGE_PENDING );

    RxReleaseSerializationMutex();

    ExclusivelyOwned = RxIsResourceOwnershipStateExclusive( Fcb->Header.Resource );

    if (!BufferingInTransistion) {
       
        RxTrackerUpdateHistory( RxContext, MrxFcb, 'rrtt', LineNumber, FileName, SerialNumber );
        
    } else if (!ExclusivelyOwned) {
       
        RxTrackerUpdateHistory( RxContext, MrxFcb, 'rrt0', LineNumber, FileName, SerialNumber );
    
    } else  {

        //
        //  If there are any buffering state change requests process them.
        //
          
        RxTrackerUpdateHistory( RxContext,MrxFcb, 'rrt1', LineNumber, FileName, SerialNumber );
        
        RxProcessFcbChangeBufferingStateRequest( Fcb );
    }

    ExReleaseResourceForThreadLite( Fcb->Header.Resource, ResourceThreadId );
}

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Fcb has been acquired

--*/
{
    PFCB ThisFcb = (PFCB)Fcb;
    BOOLEAN AcquiredFile;
    
    //
    //  We assume the Lazy Writer only acquires this Fcb once.
    //  Therefore, it should be guaranteed that this flag is currently
    //  clear and then we will set this flag, to insure
    //  that the Lazy Writer will never try to advance Valid Data, and
    //  also not deadlock by trying to get the Fcb exclusive.
    //


    PAGED_CODE();

    ASSERT_CORRECT_FCB_STRUCTURE( ThisFcb );
    
    AcquiredFile = RxAcquirePagingIoResourceShared( NULL, ThisFcb, Wait );

    if (AcquiredFile) {

        //
        //  This is a kludge because Cc is really the top level.  When it
        //  enters the file system, we will think it is a resursive call
        //  and complete the request with hard errors or verify.  It will
        //  then have to deal with them, somehow....
        //

        ASSERT( RxIsThisTheTopLevelIrp( NULL ) );
        
        AcquiredFile = RxTryToBecomeTheTopLevelIrp( NULL,
                                                    (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP,
                                                    ((PFCB)Fcb)->RxDeviceObject,
                                                    TRUE ); //  force

        if (!AcquiredFile) {
            RxReleasePagingIoResource( NULL, ThisFcb );
        }
    }

    return AcquiredFile;
}

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Fcb
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/
{
    PFCB ThisFcb = (PFCB)Fcb;

    PAGED_CODE();

    ASSERT_CORRECT_FCB_STRUCTURE( ThisFcb );

    //
    //  Clear the kludge at this point.
    //

    //
    //  NTBUG #61902 this is a paged pool leak if the test fails....in fastfat, they assert
    //  that the condition is true.
    //
    
    if(RxGetTopIrpIfRdbssIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP) {
        RxUnwindTopLevelIrp( NULL );
    }

    RxReleasePagingIoResource( NULL, ThisFcb );
    return;
}


BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing read ahead to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Fcb has been acquired

--*/
{
    PFCB ThisFcb = (PFCB)Fcb;
    BOOLEAN AcquiredFile;

    PAGED_CODE();

    ASSERT_CORRECT_FCB_STRUCTURE( ThisFcb );
    
    //
    //  We acquire the normal file resource shared here to synchronize
    //  correctly with purges.
    //

    if (!ExAcquireResourceSharedLite( ThisFcb->Header.Resource, Wait )) {
        return FALSE;
    }

    //
    //  This is a kludge because Cc is really the top level.  We it
    //  enters the file system, we will think it is a resursive call
    //  and complete the request with hard errors or verify.  It will
    //  have to deal with them, somehow....
    //

    ASSERT( RxIsThisTheTopLevelIrp( NULL ) );
    AcquiredFile = RxTryToBecomeTheTopLevelIrp( NULL,
                                                (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP,
                                                ((PFCB)Fcb)->RxDeviceObject,
                                                TRUE ); //  force

    if (!AcquiredFile) {
        ExReleaseResourceLite( ThisFcb->Header.Resource );
    }

    return AcquiredFile;
}


VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Fcb
    )
/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    read ahead.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/
{
    PFCB ThisFcb = (PFCB)Fcb;

    PAGED_CODE();

    ASSERT_CORRECT_FCB_STRUCTURE( ThisFcb );
    
    //
    //  Clear the kludge at this point.
    //

    ASSERT( RxGetTopIrpIfRdbssIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP );
    RxUnwindTopLevelIrp( NULL );

    ExReleaseResourceLite( ThisFcb->Header.Resource );

    return;
}

VOID
RxVerifyOperationIsLegal ( 
    IN PRX_CONTEXT RxContext 
    )
/*++

Routine Description:

    This routine determines is the requested operation should be allowed to
    continue.  It either returns to the user if the request is Okay, or
    raises an appropriate status.

Arguments:

    Irp - Supplies the Irp to check

Return Value:

    None.

--*/
{
    PIRP Irp = RxContext->CurrentIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PFOBX Fobx = (PFOBX)RxContext->pFobx;

#if DBG
    ULONG SaveExceptionFlag;   //to save the state of breakpoint-on-exception for this context
#endif

    PAGED_CODE();

    //
    //  If the Irp is not present, then we got here via close. If there isn't a fileobject
    //  we also can't continue
    //

    if ((Irp == NULL) || (FileObject == NULL)) {
        return;
    }

    RxSaveAndSetExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );

    if (Fobx) {
       
        PSRV_OPEN SrvOpen = (PSRV_OPEN)Fobx->SrvOpen;

        
        //
        //  If we are trying to do any other operation than close on a file
        //  object that has been renamed, raise RxStatus(FILE_RENAMED).
        //
        
        if ((SrvOpen != NULL) && 
            (RxContext->MajorFunction != IRP_MJ_CLEANUP) &&
            (RxContext->MajorFunction != IRP_MJ_CLOSE) &&
            (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_FILE_RENAMED ))) {
        
            RxRaiseStatus( RxContext, STATUS_FILE_RENAMED );
        }
        
        //
        //  If we are trying to do any other operation than close on a file
        //  object that has been deleted, raise RxStatus(FILE_DELETED).
        //
        
        if ((SrvOpen != NULL) &&
            (RxContext->MajorFunction != IRP_MJ_CLEANUP) &&
            (RxContext->MajorFunction != IRP_MJ_CLOSE) &&
            (FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_FILE_DELETED ))) {
        
           RxRaiseStatus( RxContext, STATUS_FILE_DELETED );
        }
    }

    //
    //  If we are doing a create, and there is a related file object, and
    //  it it is marked for delete, raise RxStatus(DELETE_PENDING).
    //

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {

        PFILE_OBJECT RelatedFileObject;

        RelatedFileObject = FileObject->RelatedFileObject;

        if ((RelatedFileObject != NULL) &&
             FlagOn( ((PFCB)RelatedFileObject->FsContext)->FcbState, FCB_STATE_DELETE_ON_CLOSE ) )  {

            RxRaiseStatus( RxContext, STATUS_DELETE_PENDING );
        }
    }

    //
    //  If the file object has already been cleaned up, and
    //
    //  A) This request is a paging io read or write, or
    //  B) This request is a close operation, or
    //  C) This request is a set or query info call (for Lou)
    //  D) This is an MDL complete
    //
    //  let it pass, otherwise return RxStatus(FILE_CLOSED).
    //

    if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

        if ((FlagOn( Irp->Flags, IRP_PAGING_IO )) ||
            (IrpSp->MajorFunction == IRP_MJ_CLEANUP) ||
            (IrpSp->MajorFunction == IRP_MJ_CLOSE) ||
            (IrpSp->MajorFunction == IRP_MJ_SET_INFORMATION) ||
            (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
            (((IrpSp->MajorFunction == IRP_MJ_READ) ||
              (IrpSp->MajorFunction == IRP_MJ_WRITE)) &&
             FlagOn( IrpSp->MinorFunction, IRP_MN_COMPLETE ))) {

            NOTHING;

        } else {

            RxRaiseStatus( RxContext, STATUS_FILE_CLOSED );
        }
    }

    RxRestoreExceptionNoBreakpointFlag( RxContext, SaveExceptionFlag );
    return;
}

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    NTSTATUS Status;
    PFCB Fcb = (PFCB)FileObject->FsContext;

    PAGED_CODE();

    Status = RxAcquireExclusiveFcb( NULL, Fcb );

#if DBG
    if (Status != STATUS_SUCCESS) {
        RxBugCheck( (ULONG_PTR)Fcb, 0, 0 );
    }
#endif

    //
    //  Inform lwio rdr of this call after we get the lock.
    //  It would be nice if we could fail the create section
    //  call the same way filter drivers can.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_LWIO_ENABLED )) {
    
        PFAST_IO_DISPATCH FastIoDispatch = Fcb->MRxFastIoDispatch;
        if (FastIoDispatch &&
            FastIoDispatch->AcquireFileForNtCreateSection) {
            FastIoDispatch->AcquireFileForNtCreateSection( FileObject );
        }
    }
}

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    )

{
    PMRX_FCB Fcb = (PMRX_FCB)FileObject->FsContext;

    PAGED_CODE();

    //
    //  Inform lwio rdr of this call before we drop the lock
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_LWIO_ENABLED )) {
        PFAST_IO_DISPATCH FastIoDispatch = ((PFCB)Fcb)->MRxFastIoDispatch;
        
        if (FastIoDispatch &&
            FastIoDispatch->AcquireFileForNtCreateSection) {
            
            FastIoDispatch->AcquireFileForNtCreateSection( FileObject );
        }
    }

    RxReleaseFcb( NULL, Fcb );

}

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}

VOID 
RxTrackPagingIoResource (
    PVOID Instance,
    ULONG Type,
    ULONG Line,
    PCHAR File)
{
    PFCB Fcb = (PFCB)Instance;

    switch(Type) {
    case 1:
    case 2:
        Fcb->PagingIoResourceFile = File;
        Fcb->PagingIoResourceLine = Line;
        break;
    case 3:
        Fcb->PagingIoResourceFile = NULL;
        Fcb->PagingIoResourceLine = 0;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\namcache.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    namcache.c

Abstract:

The following functions are provided to support name cache management in
mini-rdrs.  See namcache.h for a more complete description of how a mini-rdr
could use name caches to help eliminate trips to the server.


Author:

    David Orbits          [davidor]   9-Sep-1996

Revision History:


--*/


#include "precomp.h"
#pragma hdrstop


#include "prefix.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxNameCacheInitialize)
#pragma alloc_text(PAGE, RxNameCacheCreateEntry)
#pragma alloc_text(PAGE, RxNameCacheFetchEntry)
#pragma alloc_text(PAGE, RxNameCacheCheckEntry)
#pragma alloc_text(PAGE, RxNameCacheActivateEntry)
#pragma alloc_text(PAGE, RxNameCacheExpireEntry)
#pragma alloc_text(PAGE, RxNameCacheFreeEntry)
#pragma alloc_text(PAGE, RxNameCacheFinalize)
#pragma alloc_text(PAGE, RxNameCacheExpireEntryWithShortName)
#endif

#define Dbg (DEBUG_TRACE_NAMECACHE)


VOID
RxNameCacheInitialize(
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN ULONG MRxNameCacheSize,
    IN ULONG MaximumEntries
    )

/*++

Routine Description:

    This routine initializes a NAME_CACHE structure.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL from which to
                          allocate the entry.

    MRxNameCacheSize    - The size in bytes of the mini-rdr portion of the name
                          cache entry.

    MaximumEntries      - The maximum number of entries that will ever be
                          allocated.  E.g. This prevents an errant program which
                          opens tons of files with bad names from chewing up
                          paged pool.

Return Value:

    None.

--*/
{

    PAGED_CODE();

    ExInitializeFastMutex(&NameCacheCtl->NameCacheLock);

    InitializeListHead(&NameCacheCtl->ActiveList);
    InitializeListHead(&NameCacheCtl->FreeList);

    NameCacheCtl->NumberActivates = 0;
    NameCacheCtl->NumberChecks = 0;
    NameCacheCtl->NumberNameHits = 0;
    NameCacheCtl->NumberNetOpsSaved = 0;
    NameCacheCtl->EntryCount = 0;
    NameCacheCtl->MaximumEntries = MaximumEntries;
    NameCacheCtl->MRxNameCacheSize = MRxNameCacheSize;

    return;
}


PNAME_CACHE
RxNameCacheCreateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name,
    IN BOOLEAN CaseInsensitive
    )
/*++

Routine Description:

    This routine allocates and initializes a NAME_CACHE structure with the
    given name string, Lifetime (in seconds) and MRxContext.
    It returns a pointer to the name cache structure or NULL if no entry was
    available.  It is expected that the caller will then initialize any
    additional mini-rdr portion of the name cache context and then put the
    entry on the name cache active list by calling RxNameCacheActivateEntry().

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL from which to
                          allocate the entry.

    Name                - A pointer to the unicode name string to initialize the
                          the entry with.

    CaseInsensitive     - True if need case insensitive compare on name.

Return Value:

    PNAME_CACHE - returns a pointer to the newly allocated NAME_CACHE struct
                  or NULL if allocation fails.


--*/
{
    LONG i;
    PNAME_CACHE *NameCacheArray;
    PNAME_CACHE NameCache;
    ULONG NameCacheSize;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxNameCacheCreateEntry: %wZ\n", Name ));
    //
    // Grab an entry off the free list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);

    if (!IsListEmpty(&NameCacheCtl->FreeList)) {
        NameCache = (PNAME_CACHE) RemoveHeadList(&NameCacheCtl->FreeList);
    } else {
        NameCache = NULL;
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    if (NameCache != NULL) {
        NameCache = CONTAINING_RECORD(NameCache, NAME_CACHE, Link);
        RxDbgTrace(0, Dbg, ("took from free list\n"));

    } else {
        //
        // Didn't get an entry off the free list, allocate one.
        // Don't exceed Max but we could go over a little if multiple threads
        // are allocating.
        //
        if (NameCacheCtl->EntryCount < NameCacheCtl->MaximumEntries) {

            NameCacheSize = QuadAlign(sizeof(NAME_CACHE)) +
                            QuadAlign(NameCacheCtl->MRxNameCacheSize);
            NameCache = RxAllocatePoolWithTag(
                            PagedPool,
                            NameCacheSize,
                            RX_NAME_CACHE_POOLTAG);

            if (NameCache != NULL) {
                //
                // Init standard header fields, bump entry count & setup
                // mini-rdr context extension.
                //
                ZeroAndInitializeNodeType(
                    NameCache,
                    RDBSS_NTC_STORAGE_TYPE_UNKNOWN,
                    (NODE_BYTE_SIZE) NameCacheSize);

                InterlockedIncrement(&NameCacheCtl->EntryCount);

                NameCache->Name.Buffer = NULL;
                NameCache->Name.Length = 0;
                NameCache->Name.MaximumLength = 0;

                if (NameCacheCtl->MRxNameCacheSize > 0) {
                    NameCache->ContextExtension = (PBYTE)NameCache +
                                         QuadAlign(sizeof(NAME_CACHE));
                RxDbgTrace(0, Dbg, ("allocated new entry\n"));
                }
            }
        }

        //
        // If still no entry then bag it.
        //
        if (NameCache == NULL) {
            RxDbgTrace(-1, Dbg, ("Fail no entry allocated!\n"));
            return NULL;
        }

    }

    //
    // If name won't fit in current string, free it and allocate new string.
    //
    if (Name->Length > NameCache->Name.MaximumLength) {
        if (NameCache->Name.Buffer != NULL) {
            RxFreePool(NameCache->Name.Buffer);
        }

        if (Name->Length > 0) {
            NameCache->Name.Buffer = RxAllocatePoolWithTag(
                                         PagedPool,
                                         (ULONG) Name->Length,
                                         RX_NAME_CACHE_POOLTAG);

        } else {
            NameCache->Name.Buffer = NULL;
        }

        if (Name->Length > 0 &&
            NameCache->Name.Buffer == NULL) {
            //
            // if didn't get the storage.  Zero the string length and put entry
            // back on the free list.  Otherwise save allocation in max length.
            //
            NameCache->Name.Length = 0;
            NameCache->Name.MaximumLength = 0;

            ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);
            InsertHeadList(&NameCacheCtl->FreeList, &NameCache->Link);
            ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

            RxDbgTrace(-1, Dbg, ("Fail no pool for name!\n"));
            return NULL;
        } else {
            NameCache->Name.MaximumLength = Name->Length;
        }
    }

    //
    // Save the name & length.  Set the case matching flag.  Set the hash field.
    //
    NameCache->Name.Length = Name->Length;
    NameCache->CaseInsensitive = CaseInsensitive;

    if (Name->Length > 0) {
        RtlMoveMemory(NameCache->Name.Buffer, Name->Buffer, Name->Length);
        NameCache->HashValue = RxTableComputeHashValue(&NameCache->Name);
    }else {
        NameCache->HashValue = 0;
    }

    RxDbgTrace(-1, Dbg, ("Success!\n"));
    return NameCache;

}


PNAME_CACHE
RxNameCacheFetchEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine looks for a match in the name cache for Name.
    If found the entry is removed from the Name Cache active list and
    a pointer to the NAME_CACHE struct is returned.  Otherwise NULL is returned.
    The entry is removed to avoid problems with another thread trying to
    update the same entry or observing that it expired and putting it on the
    free list.  We could get multiple entries with the same name by different
    threads but eventually they will expire.

    If a matching entry is found no check is made for expiration.  That is left
    to the caller since it is likely the caller would want to take a special
    action.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL to scan.

    Name                - A pointer to the unicode name string to scan for.

Return Value:

    PNAME_CACHE - returns a pointer to the NAME_CACHE struct if found or NULL.

Side Effects:

    As the active list is scanned any non-matching entries that have expired are
    put on the free list.

--*/
{
    PNAME_CACHE NameCache = NULL;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY ExpiredEntry;
    ULONG HashValue;
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Lookup %wZ\n", Name ));

    if (Name->Length > 0) {
        HashValue = RxTableComputeHashValue(Name);
    } else {
        HashValue = 0;
    }

    KeQueryTickCount( &CurrentTime );

    NameCacheCtl->NumberChecks += 1;
    //
    // Get the lock and scan the active list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);

    pListEntry = NameCacheCtl->ActiveList.Flink;

    while (pListEntry != &NameCacheCtl->ActiveList) {

        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);
        //
        // Do initial match on the hash value and the length.  Then do full string.
        //
        if ((NameCache->HashValue == HashValue) &&
            (Name->Length == NameCache->Name.Length)) {

            if (Name->Length == 0 ||
                RtlEqualUnicodeString(
                    Name,
                    &NameCache->Name,
                    NameCache->CaseInsensitive) ) {
                //
                // Found a match.
                //
                NameCacheCtl->NumberNameHits += 1;
                break;
            }
        }
        //
        // No match. If the entry is expired, put it on the free list.
        //
        ExpiredEntry = pListEntry;
        pListEntry = pListEntry->Flink;

        if (CurrentTime.QuadPart >= NameCache->ExpireTime.QuadPart) {
            RemoveEntryList(ExpiredEntry);
            InsertHeadList(&NameCacheCtl->FreeList, ExpiredEntry);
            RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Entry expired %wZ\n", &NameCache->Name ));
        }

        NameCache = NULL;
    }
    //
    // If we found something pull it off the active list and give it to caller.
    //
    if (NameCache != NULL) {
        RemoveEntryList(pListEntry);
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);


    if (NameCache != NULL) {
        RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Entry found %wZ\n", &NameCache->Name ));
    }

    return NameCache;

}


RX_NC_CHECK_STATUS
RxNameCacheCheckEntry (
    IN PNAME_CACHE NameCache,
    IN ULONG MRxContext
    )
/*++

Routine Description:

    This routine checks a name cache entry for validity.  A valid entry
    means that the lifetime has not expired and the MRxContext passes
    the equality check.

Arguments:

    NameCache           - pointer to NAME_CACHE struct to check.

    MRxContext          - A ULONG worth of mini-rdr supplied context for
                          equality checking when making a valid entry check.

Return Value:

    RX_NC_CHECK_STATUS:  RX_NC_SUCCESS - The entry is valid
                         RX_NC_TIME_EXPIRED - The Lifetime on the entry expired
                         RX_NC_MRXCTX_FAIL - The MRxContext equality test failed


--*/
{

    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    //
    // Check for Mini-rdr context equality.
    //
    if (NameCache->Context != MRxContext) {
        RxDbgTrace( 0, Dbg, ("RxNameCacheCheckEntry: MRxContext_Fail %08lx,%08lx %wZ\n",
           NameCache->Context,
           MRxContext,
           &NameCache->Name ));

        return RX_NC_MRXCTX_FAIL;
    }

    //
    // Check for lifetime expired.
    //
    KeQueryTickCount( &CurrentTime );
    if (CurrentTime.QuadPart >= NameCache->ExpireTime.QuadPart) {
        RxDbgTrace( 0, Dbg, ("RxNameCacheCheckEntry: Expired %wZ\n", &NameCache->Name ));
        return RX_NC_TIME_EXPIRED;
    }

    RxDbgTrace( 0, Dbg, ("RxNameCacheCheckEntry: Success %wZ\n", &NameCache->Name ));
    return RX_NC_SUCCESS;

}

VOID
RxNameCacheExpireEntry(
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    )
/*++

Routine Description:

    This routine puts the entry on the free list.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL on which to
                          activate the entry.

    NameCache           - pointer to NAME_CACHE struct to activate.


Return Value:

    None.

Assumes:

    The name cache entry is not on either the free or active list.

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheExpireEntry: %wZ\n", &NameCache->Name ));

    //
    // Put the entry on free list for recycle.
    //
    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);
    InsertHeadList(&NameCacheCtl->FreeList, &NameCache->Link);
    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    //
    // Update stats.
    //
    NameCacheCtl->NumberActivates -= 1;

    return;
}


VOID
RxNameCacheExpireEntryWithShortName (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine expires all the name cache whose name prefix matches the given short file name.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL to scan.

    Name                - A pointer to the unicode name string to scan for.

Return Value:

    PNAME_CACHE - returns a pointer to the NAME_CACHE struct if found or NULL.

Side Effects:

    As the active list is scanned any non-matching entries that have expired are
    put on the free list.

--*/
{
    PNAME_CACHE NameCache = NULL;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY ExpiredEntry;
    ULONG HashValue;
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheFetchEntry: Lookup %wZ\n", Name ));

    KeQueryTickCount( &CurrentTime );

    NameCacheCtl->NumberChecks += 1;
    //
    // Get the lock and scan the active list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);

    pListEntry = NameCacheCtl->ActiveList.Flink;

    while (pListEntry != &NameCacheCtl->ActiveList) {
        USHORT SavedNameLength;

        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);

        ExpiredEntry = pListEntry;
        pListEntry = pListEntry->Flink;

        //
        // Do initial match on the hash value and the length.  Then do full string.
        //
        if (Name->Length <= NameCache->Name.Length) {
            SavedNameLength = NameCache->Name.Length;
            NameCache->Name.Length = Name->Length;

            if (Name->Length == 0 ||
                RtlEqualUnicodeString(
                    Name,
                    &NameCache->Name,
                    NameCache->CaseInsensitive) ) {
                //
                // Found a match.
                //
                RemoveEntryList(ExpiredEntry);
                InsertHeadList(&NameCacheCtl->FreeList, ExpiredEntry);
                RxDbgTrace( 0, Dbg, ("RxNameCacheExpireEntryWithShortName: Entry expired %wZ\n", &NameCache->Name ));

                continue;
            }

            NameCache->Name.Length = SavedNameLength;
        }
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);
}

VOID
RxNameCacheActivateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache,
    IN ULONG LifeTime,
    IN ULONG MRxContext
    )
/*++

Routine Description:

    This routine takes a name cache entry and updates the expiration time and
    the mini rdr context.  It then puts the entry on the active list.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL on which to
                          activate the entry.

    NameCache           - pointer to NAME_CACHE struct to activate.

    LifeTime            - The valid lifetime of the cache entry (in seconds).
                          A lifetime of zero means leave current value unchanged.
                          This is for reactivations after a match where you
                          want the original lifetime preserved.

    MRxContext          - A ULONG worth of mini-rdr supplied context for
                          equality checking when making a valid entry check.
                          An MRxContext of zero means leave current value unchanged.
                          This is for reactivations after a match where you
                          want the original MRxContext preserved.

Return Value:

    None.

Assumes:

    The name cache entry is not on either the free or active list.

--*/
{
    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheActivateEntry: %wZ\n", &NameCache->Name ));
    //
    // Set new expiration time on the entry and save the mini-rdr context.
    // A lifetime of zero or a MRxContext of zero implies leave value unchanged.
    //
    if (LifeTime != 0) {
        KeQueryTickCount( &CurrentTime );
        NameCache->ExpireTime.QuadPart = CurrentTime.QuadPart +
            (LONGLONG) ((LifeTime * 10*1000*1000) / KeQueryTimeIncrement());
    }

    if (MRxContext != 0) {
        NameCache->Context = MRxContext;
    }

    //
    // Put the entry on active list.
    //
    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);
    InsertHeadList(&NameCacheCtl->ActiveList, &NameCache->Link);
    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    //
    // Update stats.
    //
    NameCacheCtl->NumberActivates += 1;

    return;
}

VOID
RxNameCacheFreeEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    )
/*++

Routine Description:

    This routine releases the storage for a name cache entry and decrements the
    count of name cache entries for this name cache.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL for the name cache.

    NameCache           - pointer to the NAME_CACHE struct to free.

Return Value:

    None.

Assumes:

    The name cache entry is not on either the free or active list.

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxNameCacheFreeEntry: %wZ\n", &NameCache->Name ));
    //
    // Release storage for name
    //
    if (NameCache->Name.Buffer != NULL) {
        RxFreePool(NameCache->Name.Buffer);
    }
    //
    // Release storage for NAME_CACHE entry (includes context ext., if any)
    //
    RxFreePool(NameCache);

    InterlockedDecrement(&NameCacheCtl->EntryCount);


    return;
}

VOID
RxNameCacheFinalize (
    IN PNAME_CACHE_CONTROL NameCacheCtl
    )
/*++

Routine Description:

    This routine releases the storage for all the name cache entries.

Arguments:

    NameCacheCtl        - pointer to the NAME_CACHE_CONTROL for the name cache.

Return Value:

    None.


--*/
{
    PNAME_CACHE NameCache;
    PLIST_ENTRY pListEntry;

    PAGED_CODE();

    //
    // Get the lock and remove entries from the active list.
    //

    ExAcquireFastMutex(&NameCacheCtl->NameCacheLock);


    while (!IsListEmpty(&NameCacheCtl->ActiveList)) {

        pListEntry = RemoveHeadList(&NameCacheCtl->ActiveList);
        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);

        RxNameCacheFreeEntry(NameCacheCtl, NameCache);
    }
    //
    // scan free list and remove entries.
    //
    while (!IsListEmpty(&NameCacheCtl->FreeList)) {

        pListEntry = RemoveHeadList(&NameCacheCtl->FreeList);
        NameCache = (PNAME_CACHE) CONTAINING_RECORD(pListEntry, NAME_CACHE, Link);

        RxNameCacheFreeEntry(NameCacheCtl, NameCache);
    }

    ExReleaseFastMutex(&NameCacheCtl->NameCacheLock);

    //
    // At this point the entry count should be zero.  If not then there is
    // a memory leak since someone didn't call free.
    //
    ASSERT(NameCacheCtl->EntryCount == 0);

    return;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxcecnct.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcemgmt.c

Abstract:

    This module implements the RXCE routines related to connection management.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCepInitializeVC)
#pragma alloc_text(PAGE, RxCeBuildVC)
#pragma alloc_text(PAGE, RxCeTearDownVC)
#pragma alloc_text(PAGE, RxCeInitiateVCDisconnect)
#pragma alloc_text(PAGE, DuplicateConnectionInformation)
#pragma alloc_text(PAGE, RxCepInitializeConnection)
#pragma alloc_text(PAGE, RxCeBuildConnection)
#pragma alloc_text(PAGE, RxCeCleanupConnectCallOutContext)
#pragma alloc_text(PAGE, RxCeBuildConnectionOverMultipleTransports)
#pragma alloc_text(PAGE, RxCeTearDownConnection)
#pragma alloc_text(PAGE, RxCeCancelConnectRequest)
#pragma alloc_text(PAGE, RxCeQueryInformation)
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCEMANAGEMENT)

NTSTATUS
RxCepInitializeVC(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection)
/*++

Routine Description:

    This routine initializes a VCdata structure

Arguments:

    pVc            - the VC instance.

    pConnection    - the connection.

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    PAGED_CODE();

    ASSERT(RxCeIsConnectionValid(pConnection));

    RtlZeroMemory(
        pVc,
        sizeof(RXCE_VC));

    pVc->Signature   = RXCE_VC_SIGNATURE;
    pVc->pConnection = pConnection;
    pVc->hEndpoint   = INVALID_HANDLE_VALUE;
    pVc->State       = RXCE_VC_DISCONNECTED;

    return STATUS_SUCCESS;
}

NTSTATUS
RxCeBuildVC(
    IN OUT PRXCE_VC            pVc,
    IN     PRXCE_CONNECTION    pConnection)
/*++

Routine Description:

    This routine adds a virtual circuit to a specified connection

Arguments:

    pConnection  - the connection for which a VC is to be added

    pVcPointer    - the handle of the new virtual circuit

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_INVALID_PARAMETER;

    PRXCE_TRANSPORT  pTransport = NULL;
    PRXCE_ADDRESS    pAddress   = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeBuildVc);

    try {
        pAddress = pConnection->pAddress;
        pTransport = pAddress->pTransport;

        if (RxCeIsConnectionValid(pConnection) &&
            RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {

            Status = RxCepInitializeVC(
                         pVc,
                         pConnection);

            if (NT_SUCCESS(Status)) {
                Status = RxTdiConnect(
                             pTransport,    // the associated transport
                             pAddress,      // the RxCe address
                             pConnection,   // the RxCe connection
                             pVc);          // the RxCe virtual circuit associated with the connection

                if (Status == STATUS_SUCCESS) {
                    pVc->State       = RXCE_VC_ACTIVE;
                }
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeAddVC: VC: %lx Status %lx\n",pVc,Status));
            RxWmiLog(LOG,
                     RxCeBuildVC,
                     LOGPTR(pVc)
                     LOGULONG(Status));
        }
    }

    return Status;
}


NTSTATUS
RxCeInitiateVCDisconnect(
    IN PRXCE_VC pVc)
/*++

Routine Description:

    This routine initiates a disconnect on the VC.

Arguments:

    pVc - the VC instance to be disconnected

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT  pTransport  = NULL;
    PRXCE_ADDRESS    pAddress    = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeTearDownVc);

    try {
        if ((pVc->pEndpointFileObject != NULL)  &&
            (pVc->hEndpoint != INVALID_HANDLE_VALUE)) {
            pConnection = pVc->pConnection;
            pAddress = pConnection->pAddress;
            pTransport = pAddress->pTransport;

            if (RxCeIsVcValid(pVc) &&
                RxCeIsConnectionValid(pConnection) &&
                RxCeIsAddressValid(pAddress) &&
                RxCeIsTransportValid(pTransport)) {

                LONG VcState = InterlockedExchange(
                                   &pVc->State,
                                   RXCE_VC_TEARDOWN);

                if (VcState != RXCE_VC_TEARDOWN) {
                    Status = RxTdiDisconnect(
                                 pTransport,    // the associated transport
                                 pAddress,      // the RxCe address
                                 pConnection,   // the RxCe connection
                                 pVc,           // the RxCe virtual circuit associated with the connection
                                 RXCE_DISCONNECT_ABORT); // disconnect options

                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace(0, Dbg,("RxCeTearDownVC returned %lx\n",Status));
                    }
                } else {
                    Status = STATUS_SUCCESS;
                }
            } else {
                RxDbgTrace(0, Dbg,("RxCeTearDownVC -- Invalid VC %lx\n",pVc));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeInitiateVCDisconnect: VC: %lx Status %lx\n",pVc,Status));
            RxWmiLog(LOG,
                     RxCeInitiateVCDisconnect,
                     LOGPTR(pVc)
                     LOGULONG(Status));
        }
    }

    return Status;
}

NTSTATUS
RxCeTearDownVC(
    IN PRXCE_VC pVc)
/*++

Routine Description:

    This routine tears down the VC instance.

Arguments:

    pVc - the VC instance to be torn down

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT  pTransport  = NULL;
    PRXCE_ADDRESS    pAddress    = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeTearDownVc);

    try {
        if (pVc->pCleanUpEvent != NULL) {
            // wait for the clean up of connections over other transports to be completed
            KeWaitForSingleObject(
                       pVc->pCleanUpEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       NULL);

            RxFreePool(pVc->pCleanUpEvent);
            pVc->pCleanUpEvent = NULL;
        }

        if ((pVc->pEndpointFileObject != NULL)  &&
            (pVc->hEndpoint != INVALID_HANDLE_VALUE)) {
            pConnection = pVc->pConnection;
            pAddress = pConnection->pAddress;
            pTransport = pAddress->pTransport;

            if (RxCeIsVcValid(pVc) &&
                RxCeIsConnectionValid(pConnection) &&
                RxCeIsAddressValid(pAddress) &&
                RxCeIsTransportValid(pTransport)) {

                LONG VcState = InterlockedExchange(
                                   &pVc->State,
                                   RXCE_VC_TEARDOWN);

                if (VcState != RXCE_VC_TEARDOWN) {
                    Status = RxTdiDisconnect(
                                 pTransport,    // the associated transport
                                 pAddress,      // the RxCe address
                                 pConnection,   // the RxCe connection
                                 pVc,           // the RxCe virtual circuit associated with the connection
                                 RXCE_DISCONNECT_ABORT); // disconnect options

                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace(0, Dbg,("RxCeTearDownVC returned %lx\n",Status));
                    }
                } else {
                    Status = STATUS_SUCCESS;
                }
            } else {
                RxDbgTrace(0, Dbg,("RxCeTearDownVC -- Invalid VC %lx\n",pVc));
            }

            // Dereference the endpoint file object.
            ObDereferenceObject(pVc->pEndpointFileObject);

            // Close the endpoint file object handle
            Status = ZwClose(pVc->hEndpoint);

            ASSERT(Status == STATUS_SUCCESS);

            pVc->hEndpoint = INVALID_HANDLE_VALUE;
            pVc->pEndpointFileObject = NULL;
        }

        RtlZeroMemory(pVc,sizeof(RXCE_VC));
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeTearDownVC: VC: %lx Status %lx\n",pVc,Status));
            RxWmiLog(LOG,
                     RxCeTearDownVC,
                     LOGPTR(pVc)
                     LOGULONG(Status));
        }
    }
    
    return Status;
}


NTSTATUS
DuplicateConnectionInformation(
    PRXCE_CONNECTION_INFORMATION *pCopy,
    PRXCE_CONNECTION_INFORMATION pOriginal,
    POOL_TYPE                    PoolType)
/*++

Routine Description:

    This routine duplicates a connection information addresses.

Arguments:

    pCopy  - the pointer to the new copy

    pOriginal - the original.

    PoolType - type of pool for memory allocation

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    PVOID pUserData = NULL;
    PVOID pRemoteAddress = NULL;
    PVOID pOptions = NULL;
    PRXCE_CONNECTION_INFORMATION pConnectionInformation = NULL;
    BOOLEAN fFailed = FALSE;

    PAGED_CODE();

    pConnectionInformation = RxAllocatePoolWithTag(
                                 PoolType,
                                 sizeof(RXCE_CONNECTION_INFORMATION),
                                 RXCE_CONNECTION_POOLTAG);
    if (pConnectionInformation != NULL) {
        RtlCopyMemory(
            pConnectionInformation,
            pOriginal,
            sizeof(RXCE_CONNECTION_INFORMATION));
    } else
        fFailed = TRUE;

    if (!fFailed && pOriginal->UserDataLength > 0) {
        pUserData = RxAllocatePoolWithTag(
                        PoolType,
                        pOriginal->UserDataLength,
                        RXCE_CONNECTION_POOLTAG);
        if (pUserData != NULL) {
            RtlCopyMemory(
                pUserData,
                pOriginal->UserData,
                pOriginal->UserDataLength);
        } else
            fFailed = TRUE;
    }

    if (!fFailed && pOriginal->RemoteAddressLength > 0) {
        pRemoteAddress = RxAllocatePoolWithTag(
                             PoolType,
                             pOriginal->RemoteAddressLength,
                             RXCE_CONNECTION_POOLTAG);
        if (pRemoteAddress != NULL) {
            PTA_ADDRESS pTaAdress;
            PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)pRemoteAddress;
            LONG NoOfAddress;

            RtlCopyMemory(
                pRemoteAddress,
                pOriginal->RemoteAddress,
                pOriginal->RemoteAddressLength);

            pTaAdress = &pTransportAddress->Address[0];

            for (NoOfAddress=0; NoOfAddress<pTransportAddress->TAAddressCount;NoOfAddress++) {
                if (pTaAdress->AddressType == TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX) {
                    PTDI_ADDRESS_NETBIOS_UNICODE_EX pTdiNetbiosUnicodeExAddress;

                    pTdiNetbiosUnicodeExAddress = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pTaAdress->Address;
                    pTdiNetbiosUnicodeExAddress->EndpointName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->EndpointBuffer;
                    pTdiNetbiosUnicodeExAddress->RemoteName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->RemoteNameBuffer;

                    //DbgPrint("Rdbss copy NETBIOS_UNICODE_EX on TA %lx UA %lx %wZ %wZ\n",
                    //         pTaAdress,
                    //         pTdiNetbiosUnicodeExAddress,
                    //         &pTdiNetbiosUnicodeExAddress->EndpointName,
                    //         &pTdiNetbiosUnicodeExAddress->RemoteName);
                    break;
                } else {
                    pTaAdress = (PTA_ADDRESS)((PCHAR)pTaAdress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    pTaAdress->AddressLength);
                }
            }
        } else
            fFailed = TRUE;
    }

    if (!fFailed && pOriginal->OptionsLength > 0) {
        pOptions = RxAllocatePoolWithTag(
                       PoolType,
                       pOriginal->OptionsLength,
                       RXCE_CONNECTION_POOLTAG);

        if (pOptions != NULL) {
            RtlCopyMemory(
                pOptions,
                pOriginal->Options,
                pOriginal->OptionsLength);
        } else
            fFailed = TRUE;
    }

    if (!fFailed) {
        pConnectionInformation->UserData = pUserData;
        pConnectionInformation->RemoteAddress = pRemoteAddress;
        pConnectionInformation->Options = pOptions;
        *pCopy = pConnectionInformation;
        return STATUS_SUCCESS;
    } else {
        if (pOptions != NULL) {
            RxFreePool(pOptions);
        }

        if (pRemoteAddress != NULL) {
            RxFreePool(pRemoteAddress);
        }

        if (pUserData != NULL) {
            RxFreePool(pUserData);
        }

        if (pConnectionInformation != NULL) {
            RxFreePool(pConnectionInformation);
        }

        *pCopy = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

NTSTATUS
RxCepInitializeConnection(
    IN OUT PRXCE_CONNECTION             pConnection,
    IN     PRXCE_ADDRESS                pAddress,
    IN     PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext)
/*++

Routine Description:

    This routine initializes a connection data structure

Arguments:

    pConnection    - the newly created connection.

    pAddress       - the local address

    pConnectionInformation - the connection information specifying the remote address.

    pHandler       - the handler for processing receive indications

    pEventContext  - the context to be used for indications

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // Initialize the new connection
    RtlZeroMemory(
        pConnection,
        sizeof(RXCE_CONNECTION));

    pConnection->Signature = RXCE_CONNECTION_SIGNATURE;
    pConnection->pAddress = pAddress;

    // Duplicate the connection information if successful
    if (pConnectionInformation != NULL) {
        Status = DuplicateConnectionInformation(
                     &pConnection->pConnectionInformation,
                     pConnectionInformation,
                     NonPagedPool);
    }

    if (NT_SUCCESS(Status) &&
        (pHandler != NULL)) {
        pConnection->pHandler = (PRXCE_CONNECTION_EVENT_HANDLER)
                                 RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(RXCE_CONNECTION_EVENT_HANDLER),
                                     RXCE_CONNECTION_POOLTAG);

        if (pConnection->pHandler != NULL) {
            RtlZeroMemory(
                pConnection->pHandler,
                sizeof(RXCE_CONNECTION_EVENT_HANDLER));

            *(pConnection->pHandler) = *pHandler;
            pConnection->pContext    = pEventContext;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

NTSTATUS
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                  pAddress,
    IN  PRXCE_CONNECTION_INFORMATION   pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER pHandler,
    IN  PVOID                          pEventContext,
    IN OUT PRXCE_CONNECTION            pConnection,
    IN OUT PRXCE_VC                    pVc)
/*++

Routine Description:

    This routine establishes a connection between a local RxCe address and a given remote address

Arguments:

    pAddress       - the local address

    pConnectionInformation - the connection information specifying the remote address.

    pHandler       - the handler for processing receive indications

    pEventContext  - the context to be used for indications

    pConnection    - the newly created connection.

    pVc            - the VC associated with the connection.

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS          Status;

    PRXCE_TRANSPORT   pTransport     = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeBuildConnection);

    try {
        pTransport = pAddress->pTransport;

        if (RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {

            Status = RxCepInitializeConnection(
                         pConnection,
                         pAddress,
                         pConnectionInformation,
                         pHandler,
                         pEventContext);

            if (NT_SUCCESS(Status)) {
                Status = RxCeBuildVC(pVc,pConnection);
            }

            if (!NT_SUCCESS(Status)) {
                RxCeTearDownVC(pVc);
                RxCeTearDownConnection(pConnection);
                RxDbgTrace(0, Dbg,("RxCeOpenConnection returned %lx\n",Status));
            } else {
                // NetBT may return the DNS name on Remote Address
                RtlCopyMemory(pConnectionInformation->RemoteAddress,
                              pConnection->pConnectionInformation->RemoteAddress,
                              pConnection->pConnectionInformation->RemoteAddressLength);
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeCreateConnection %lx \n",pAddress));
            RxWmiLog(LOG,
                     RxCeBuildConnection,
                     LOGPTR(pAddress));
        }
    }

    return Status;
}

extern
NTSTATUS
RxCeCompleteConnectRequest(
    PRX_CALLOUT_PARAMETERS_BLOCK pParameterBlock);

NTSTATUS
RxCeInitiateConnectRequest(
    PRX_CALLOUT_PARAMETERS_BLOCK pParameterBlock)
/*++

Routine Description:

    This routine initiates a connection callout request to a particular transport

Arguments:

    pParameterBlock  - the parameter block for initaiting the connection.

Notes:

--*/
{
    NTSTATUS Status;

    KIRQL   OldIrql;

    BOOLEAN InitiateConnectionRequest;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT   pCreateConnectionContext;

    pCreateConnectionContext =  (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)
                                pParameterBlock->pCallOutContext;

    KeAcquireSpinLock(&pCreateConnectionContext->SpinLock,&OldIrql);

    InitiateConnectionRequest = (!pCreateConnectionContext->WinnerFound);

    KeReleaseSpinLock(&pCreateConnectionContext->SpinLock,OldIrql);

    if (InitiateConnectionRequest) {
        Status = RxTdiInitiateAsynchronousConnect(
                     (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)pParameterBlock);
    } else {
        Status = STATUS_CANCELLED;
    }

    if (Status != STATUS_PENDING) {
        pParameterBlock->CallOutStatus = Status;

        RxCeCompleteConnectRequest(pParameterBlock);
    }
    return Status;
}

VOID
RxCeCleanupConnectCallOutContext(
    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT pCreateConnectionContext)
/*++

Routine Description:

    This routine cleansup a connection callout request. This cannot be done in
    the context of any of the transport callback routines because of environmental
    constraints, i.e., Transports can callback at DPC level.

Arguments:

    pCreateConnectionContext - the connection context.

Notes:

--*/
{
    NTSTATUS Status;

    // Walk through the list of parameter blocks associated with this
    // callout context and initiate the appropriate tear down action.

    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pTempParameterBlock;
    PRDBSS_DEVICE_OBJECT pRxDeviceObject = NULL;

    
    PAGED_CODE();
    
    pRxDeviceObject = pCreateConnectionContext->pRxDeviceObject;

    pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                          pCreateConnectionContext->pCallOutParameterBlock;

    while (pTempParameterBlock != NULL) {
        if (pTempParameterBlock->CallOutId != pCreateConnectionContext->WinnerCallOutId) {
            RxTdiCleanupAsynchronousConnect(
                pTempParameterBlock);
        }

        RxCeTearDownVC(
            &pTempParameterBlock->Vc);

        RxCeTearDownConnection(
            &pTempParameterBlock->Connection);

        pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                              pTempParameterBlock->pNextCallOutParameterBlock;
    }

    if (pCreateConnectionContext->pCallOutParameterBlock != NULL) {
        RxLog(("Freeparamblock %x, %x\n",
                pCreateConnectionContext->pCallOutParameterBlock, KeGetCurrentThread()));
        RxWmiLog(LOG,
                 RxCeCleanupConnectCallOutContext,
                 LOGPTR(pCreateConnectionContext->pCallOutParameterBlock));
        RxFreePool(pCreateConnectionContext->pCallOutParameterBlock);
    }

    if (pCreateConnectionContext->pCleanUpEvent != NULL) {
        RxFreePool(pCreateConnectionContext->pCleanUpEvent);
    } else {
        PRXCE_VC pVc = pCreateConnectionContext->pConnectionContext;
        
        KeSetEvent(pVc->pCleanUpEvent, 0, FALSE);
    }

    RxFreePool(pCreateConnectionContext);

    if (pRxDeviceObject != NULL) {
        RxDeregisterAsynchronousRequest(pRxDeviceObject);
    }
}

NTSTATUS
RxCeCompleteConnectRequest(
    PRX_CALLOUT_PARAMETERS_BLOCK pParameterBlock)
/*++

Routine Description:

    This routine completes a connection callout request

Arguments:

    pParameterBlock - the parameter block instance.

Notes:

--*/
{
    BOOLEAN  AllCallOutsCompleted = FALSE;
    BOOLEAN  AllCallOutsInitiated = FALSE;
    BOOLEAN  InvokeCompletionRoutine = FALSE;
    BOOLEAN  WinnerFound          = FALSE;
    NTSTATUS    Status = STATUS_SUCCESS;

    KIRQL OldIrql;

    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pWinningParameterBlock;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT   pCreateConnectionContext;
    PRXCE_CONNECTION_COMPLETION_CONTEXT     pCompletionContext;
    PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine;

    pCreateConnectionContext =  (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)
                                pParameterBlock->pCallOutContext;

    // save the two values below as the pCreateConnectionContext may be freed

    pCompletionContext = pCreateConnectionContext->pCompletionContext;
    pCompletionRoutine = pCreateConnectionContext->pCompletionRoutine;

    pWinningParameterBlock = NULL;

    KeAcquireSpinLock(&pCreateConnectionContext->SpinLock,&OldIrql);

    if (!pCreateConnectionContext->WinnerFound) {
        if (pParameterBlock->CallOutStatus == STATUS_SUCCESS) {
            // This instance of the call out was successful. Determine if this
            // instance is the winner.

            // In those cases in which the option was to select the best possible transport
            // the callout id of this instance must be less than the previously recorded
            // winner for the expectations to be revised.

            switch (pCreateConnectionContext->CreateOptions) {
            case RxCeSelectBestSuccessfulTransport:
                if (pParameterBlock->CallOutId != pCreateConnectionContext->BestPossibleWinner) {
                    break;
                }
                // lack of break intentional. The processing for the winner in the best transport case
                // and the first transport case is identical and have been folded together
            case RxCeSelectFirstSuccessfulTransport:
                {
                    pWinningParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                             pParameterBlock;
                }
                break;

            case RxCeSelectAllSuccessfulTransports:
            default:
                ASSERT(!"RXCE connection create option not yet implemented");
                break;
            }
        } else {
            switch (pCreateConnectionContext->CreateOptions) {
            case RxCeSelectBestSuccessfulTransport:
                {
                    // This instance was not successful. This implies one of two things
                    // -- a previously completed transport can be the winner or we can
                    // adjust our expectations as regards the eventual winner.

                    if (pParameterBlock->CallOutId == pCreateConnectionContext->BestPossibleWinner) {
                        // The transport that was regarded as the best transport has reported
                        // failure. Revise our expectations as regards the best transport.

                        PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pTempParameterBlock;

                        pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                              pCreateConnectionContext->pCallOutParameterBlock;

                        while (pTempParameterBlock != NULL) {
                            PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pNextParameterBlock;

                            pNextParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                                  pTempParameterBlock->pNextCallOutParameterBlock;

                            if (pTempParameterBlock->CallOutId < pCreateConnectionContext->BestPossibleWinner) {
                                ASSERT(pTempParameterBlock->CallOutStatus != STATUS_SUCCESS);
                            } else {
                                if (pNextParameterBlock != NULL) {
                                    if (pNextParameterBlock->CallOutStatus
                                         == STATUS_PENDING) {
                                        pCreateConnectionContext->BestPossibleWinner =
                                            pNextParameterBlock->CallOutId;
                                        break;
                                    } else if (pNextParameterBlock->CallOutStatus
                                         == STATUS_SUCCESS ) {
                                        pWinningParameterBlock = pNextParameterBlock;
                                        break;
                                    }
                                }
                            }

                            pTempParameterBlock = pNextParameterBlock;
                        }
                    }

                }
                break;

            case RxCeSelectAllSuccessfulTransports:
            case RxCeSelectFirstSuccessfulTransport:
            default:
                break;
            }
        }

        if (pWinningParameterBlock != NULL) {
            // Transfer the parameters associated with the winning parameter block
            // onto the original connection and prepare the call out parameter block
            // for cleanup.

            pCreateConnectionContext->WinnerFound = TRUE;
            pCreateConnectionContext->WinnerCallOutId = pWinningParameterBlock->CallOutId;

            pCompletionContext->Status = STATUS_SUCCESS;
            pCompletionContext->AddressIndex = pWinningParameterBlock->CallOutId;

            pCompletionContext->pConnection->pAddress =
                pWinningParameterBlock->Connection.pAddress;

            pCompletionContext->pVc->hEndpoint =
                pWinningParameterBlock->Vc.hEndpoint;

            pCompletionContext->pVc->pEndpointFileObject =
                pWinningParameterBlock->Vc.pEndpointFileObject;

            pCompletionContext->pVc->State = RXCE_VC_ACTIVE;

            pCompletionContext->pVc->pCleanUpEvent = pCreateConnectionContext->pCleanUpEvent;
            pCreateConnectionContext->pCleanUpEvent = NULL;

            pWinningParameterBlock->Vc.hEndpoint = INVALID_HANDLE_VALUE;
            pWinningParameterBlock->Vc.pEndpointFileObject = NULL;

            //DbgPrint("Remote address src %lx target %lx\n",
            //         pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddress,
            //         pCompletionContext->pConnectionInformation->RemoteAddress);

            if (pCompletionContext->pConnectionInformation)
            {
                // Copy the buffer which may contain the DNS name returned back from TDI
                RtlCopyMemory(pCompletionContext->pConnectionInformation->RemoteAddress,
                              pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddress,
                              pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddressLength);
            }
                    
           //{
           //    PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)pWinningParameterBlock->Connection.pConnectionInformation->RemoteAddress;
           //    DbgPrint("Number of TA returned %d %lx\n",pTransportAddress->TAAddressCount,pTransportAddress->Address); 
           //}
        }
    }

    AllCallOutsInitiated = (pCreateConnectionContext->NumberOfCallOutsInitiated
                            == pCreateConnectionContext->NumberOfCallOuts);

    ((PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)pParameterBlock)->pConnectIrp = NULL;
    
    KeReleaseSpinLock(&pCreateConnectionContext->SpinLock,OldIrql);

    // The winning transport has been located. Cancel all the other requests.
    if (pWinningParameterBlock != NULL) {
        PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pTempParameterBlock, pNextTempBlock;

        pTempParameterBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                              pCreateConnectionContext->pCallOutParameterBlock;

        RxLog(("Use paramblock %x %x\n", pTempParameterBlock, KeGetCurrentThread()));
        RxWmiLog(LOG,
                 RxCeCompleteConnectRequest,
                 LOGPTR(pTempParameterBlock));
        while (pTempParameterBlock != NULL) {

            pNextTempBlock = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                                      pTempParameterBlock->pNextCallOutParameterBlock;

            if (pTempParameterBlock->CallOutStatus == STATUS_PENDING) {

                // get the next block becfore we do the cancel and set the
                // current guys status to cacncelled
                // Don't touch it after cancellation as he may have gone away
                // by then

                pTempParameterBlock->CallOutStatus = STATUS_CANCELLED;

                RxTdiCancelAsynchronousConnect(pTempParameterBlock);
            }

            pTempParameterBlock = pNextTempBlock;
        }
    }

    KeAcquireSpinLock(&pCreateConnectionContext->SpinLock,&OldIrql);
    
    AllCallOutsCompleted =
        (InterlockedIncrement(&pCreateConnectionContext->NumberOfCallOutsCompleted) ==
         pCreateConnectionContext->NumberOfCallOuts);

    if (AllCallOutsCompleted) {
        if (!pCreateConnectionContext->WinnerFound) {
            pCompletionContext->Status = pParameterBlock->CallOutStatus;
        }
    }

    if (AllCallOutsInitiated &&
        (AllCallOutsCompleted || pCreateConnectionContext->WinnerFound) &&
        !pCreateConnectionContext->CompletionRoutineInvoked) {
        InvokeCompletionRoutine = TRUE;
        pCreateConnectionContext->CompletionRoutineInvoked = TRUE;
    } 
    
    KeReleaseSpinLock(&pCreateConnectionContext->SpinLock,OldIrql);

    if ((Status == STATUS_SUCCESS) && AllCallOutsCompleted) {
        Status = RxPostToWorkerThread(
            RxFileSystemDeviceObject,
            HyperCriticalWorkQueue,
            &pCreateConnectionContext->WorkQueueItem,
            RxCeCleanupConnectCallOutContext,
            pCreateConnectionContext);
    }

    if (InvokeCompletionRoutine) {
        if ((IoGetCurrentProcess() == RxGetRDBSSProcess()) &&
            !RxShouldPostCompletion()) {
            (pCompletionRoutine)(pCompletionContext);
        } else {
            Status = RxPostToWorkerThread(
                RxFileSystemDeviceObject,
                CriticalWorkQueue,
                &pCompletionContext->WorkQueueItem,
                pCompletionRoutine,
                pCompletionContext);
        }
    }
    
    return Status;
}

NTSTATUS
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOptions,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext)
/*++

Routine Description:

    This routine establishes a connection between a local RxCe address and a given remote address

Arguments:

    pMiniRedirectorDeviceObject - the mini redriector device object

    CreateOptions          - the create options

    NumberOfAddresses      - the number of local addresses(transports)

    pLocalAddressPointers  - the local address handles

    pServerName            - the name of the server ( for connection enumeration )

    pConnectionInformation - the connection information specifying the remote address.

    pHandler               - the connection handler

    pEventContext          - the connection handler context

    pLocalAddressHandleIndex - the index of the successful address/transport

    pConnectionHandle      - the handle to the newly created connection.

    pVcHandle              - the handle to the VC associated with the connection.

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;

    NTSTATUS Status;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT  pCallOutContext=NULL;
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameterBlocks=NULL;

    ULONG   NumberOfCallOuts,i;
    BOOLEAN InitiateCleanup = FALSE;
    BOOLEAN AsynchronousRequestRegistered = FALSE;

    KEVENT  CompletionEvent;
    BOOLEAN     fCompletionContextFreed = FALSE;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    pConnection = pCompletionContext->pConnection;
    pVc         = pCompletionContext->pVc;

    pCallOutContext = (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)
                      RxAllocatePoolWithTag(
                          NonPagedPool,
                          sizeof(RX_CREATE_CONNECTION_CALLOUT_CONTEXT),
                          RXCE_CONNECTION_POOLTAG);

    if (pCallOutContext != NULL) {
        // Allocate one more parameter block then the number of addresses.
        // This sentinel block is used in completing the connect request
        // after ensuring that all of them have been initiated. This
        // ensures that race conditions when a transport completes before
        // the requests have been initiated on some transports are avoided.

        pCallOutContext->pCleanUpEvent = (PKEVENT)RxAllocatePoolWithTag(
                                            NonPagedPool,
                                            sizeof(KEVENT),
                                            RXCE_CONNECTION_POOLTAG);

        pParameterBlocks = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)
                           RxAllocatePoolWithTag(
                               NonPagedPool,
                               sizeof(RX_CREATE_CONNECTION_PARAMETERS_BLOCK) *
                               (NumberOfAddresses + 1),
                               RXCE_CONNECTION_POOLTAG);
    }


    if ((pParameterBlocks == NULL) ||
        (pCallOutContext ==  NULL) ||
        (pCallOutContext->pCleanUpEvent == NULL)) {
        if (pCallOutContext != NULL) {
            if (pCallOutContext->pCleanUpEvent != NULL) {
                RxFreePool(pCallOutContext->pCleanUpEvent);
            }

            RxFreePool(pCallOutContext);
            pCallOutContext = NULL;
        }
        if (pParameterBlocks)
        {
            RxFreePool(pParameterBlocks);
            pParameterBlocks = NULL;
        }
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto bailout;
    }

    // Before initiating the callouts ensure that the asynchronous
    // request is registered. this will ensure that the mini
    // redirector cannot be unloaded till the asynchronous request
    // has been completed.
    Status = RxRegisterAsynchronousRequest(pMiniRedirectorDeviceObject);
    
    if (Status == STATUS_SUCCESS) {
        AsynchronousRequestRegistered = TRUE;
    }

    KeInitializeEvent(
        pCallOutContext->pCleanUpEvent,
        SynchronizationEvent,
        FALSE);

    if (Status == STATUS_SUCCESS) {
        Status = RxCepInitializeConnection(
                     pConnection,
                     NULL,
                     pConnectionInformation,
                     pHandler,
                     pEventContext);

        if (Status == STATUS_SUCCESS) {
            Status = RxCepInitializeVC(
                         pVc,
                         pConnection);
        }
    }

    if (Status == STATUS_SUCCESS) {
        try {
            NumberOfCallOuts = 0;

            // Fill up each of the parameter blocks
            for (i = 0; i < NumberOfAddresses; i++) {
                PRXCE_TRANSPORT pTransport;
                PRXCE_ADDRESS pAddress;

                pAddress = pLocalAddressPointers[i];
                pTransport = pAddress->pTransport;

                if (RxCeIsAddressValid(pAddress) &&
                    RxCeIsTransportValid(pTransport)) {

                    Status = RxCepInitializeConnection(
                                 &pParameterBlocks[NumberOfCallOuts].Connection,
                                 pAddress,
                                 pConnectionInformation,
                                 NULL,
                                 NULL);

                    if (Status == STATUS_SUCCESS) {
                        Status = RxCepInitializeVC(
                                     &pParameterBlocks[NumberOfCallOuts].Vc,
                                     &pParameterBlocks[NumberOfCallOuts].Connection);

                        if (Status != STATUS_SUCCESS) {
                            RxCeTearDownConnection(
                                &pParameterBlocks[NumberOfCallOuts].Connection);
                        }
                    }

                    if (Status == STATUS_SUCCESS) {
                        pParameterBlocks[NumberOfCallOuts].pConnectIrp = NULL;
                        pParameterBlocks[NumberOfCallOuts].IrpRefCount = NULL;
                        pParameterBlocks[NumberOfCallOuts].CallOutId = i;
                        pParameterBlocks[NumberOfCallOuts].pCallOutContext =
                            (PRX_CALLOUT_CONTEXT)pCallOutContext;
                        pParameterBlocks[NumberOfCallOuts].CallOutStatus = STATUS_PENDING;
                        NumberOfCallOuts++;
                    }
                }
            }

            if (NumberOfCallOuts > 0) {
                NTSTATUS LocalStatus = STATUS_SUCCESS;

                // Increment the number of callouts for the sentinel callout to
                // ensure that all initiation is completed before we complete
                // the connect request. Notice that the sentinel is not the very
                // last one but the one after the number of callouts.
                NumberOfCallOuts++;

                // Also exclude the sentinel from the list
                for (i = 0;  i < NumberOfCallOuts - 1; i++) {
                    pParameterBlocks[i].pNextCallOutParameterBlock =
                        (PRX_CALLOUT_PARAMETERS_BLOCK)&pParameterBlocks[i + 1];
                }

                pParameterBlocks[NumberOfCallOuts - 2].pNextCallOutParameterBlock = NULL;
                pParameterBlocks[NumberOfCallOuts - 1].pNextCallOutParameterBlock = NULL;

                // Initialize the callout context.
                pCallOutContext->CreateOptions   = CreateOptions;
                pCallOutContext->WinnerCallOutId = NumberOfCallOuts + 1;
                pCallOutContext->BestPossibleWinner = 0;
                pCallOutContext->NumberOfCallOuts = NumberOfCallOuts;
                pCallOutContext->NumberOfCallOutsInitiated = 0;
                pCallOutContext->NumberOfCallOutsCompleted = 0;
                pCallOutContext->pRxCallOutInitiation = RxCeInitiateConnectRequest;
                pCallOutContext->pRxCallOutCompletion = RxCeCompleteConnectRequest;
                pCallOutContext->WinnerFound = FALSE;
                pCallOutContext->CompletionRoutineInvoked = FALSE;
                pCallOutContext->pCallOutParameterBlock =
                    (PRX_CALLOUT_PARAMETERS_BLOCK)pParameterBlocks;

                pCompletionContext->AddressIndex =  NumberOfCallOuts + 1;

                pCallOutContext->pCompletionContext = pCompletionContext;
                pCallOutContext->pCompletionRoutine = pCompletionRoutine;
                pCallOutContext->pConnectionContext = pCompletionContext->pVc;
                 
                pCallOutContext->pRxDeviceObject = pMiniRedirectorDeviceObject;

                KeInitializeSpinLock(
                    &pCallOutContext->SpinLock);

                // Exclude the sentinel from the chain of parameter blocks
                for (i = 0; i < NumberOfCallOuts - 1; i++) {
                    pCallOutContext->pRxCallOutInitiation(
                                 (PRX_CALLOUT_PARAMETERS_BLOCK)&pParameterBlocks[i]);
                }

                pParameterBlocks[NumberOfCallOuts - 1].pConnectIrp = NULL;
                pParameterBlocks[NumberOfCallOuts - 1].CallOutId = NumberOfCallOuts;
                pParameterBlocks[NumberOfCallOuts - 1].pCallOutContext =
                    (PRX_CALLOUT_CONTEXT)pCallOutContext;
                pParameterBlocks[NumberOfCallOuts - 1].CallOutStatus = STATUS_NETWORK_UNREACHABLE;

                pCallOutContext->NumberOfCallOutsInitiated = NumberOfCallOuts;


                if((LocalStatus = RxCeCompleteConnectRequest(
                    (PRX_CALLOUT_PARAMETERS_BLOCK)&pParameterBlocks[NumberOfCallOuts - 1])) != STATUS_SUCCESS)
                {
                    InitiateCleanup = TRUE;
                    Status = LocalStatus;
                    RxLog(("LocalStatus %x\n", LocalStatus));
                    RxWmiLog(LOG,
                             RxCeBuildConnectionOverMultipleTransports_1,
                             LOGULONG(LocalStatus));
                }
                else
                {
                    Status = STATUS_PENDING;
                }

                fCompletionContextFreed = TRUE;
            } else {
                InitiateCleanup = TRUE;
                Status = STATUS_INVALID_HANDLE;
            }
        } finally {
            if (AbnormalTermination()) {
                InitiateCleanup = TRUE;
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    if (InitiateCleanup) {
        RxFreePool(pParameterBlocks);
        RxFreePool(pCallOutContext);
    }

    if (Status != STATUS_PENDING) {
        NTSTATUS LocalStatus;

        ASSERT(Status != STATUS_SUCCESS);

        LocalStatus = RxCeTearDownVC(pVc);
        ASSERT(LocalStatus == STATUS_SUCCESS);

        LocalStatus = RxCeTearDownConnection(pConnection);
        ASSERT(LocalStatus == STATUS_SUCCESS);

        if (!fCompletionContextFreed)
        {
            pCompletionContext->Status = Status;

            if ((IoGetCurrentProcess() == RxGetRDBSSProcess()) &&
                !RxShouldPostCompletion()) {
                (pCompletionRoutine)(pCompletionContext);
            } else {
                LocalStatus = RxPostToWorkerThread(
                    RxFileSystemDeviceObject,
                    CriticalWorkQueue,
                    &pCompletionContext->WorkQueueItem,
                    pCompletionRoutine,
                    pCompletionContext);

            }
        }

        if (LocalStatus == STATUS_SUCCESS)
        {
            if (AsynchronousRequestRegistered) {
                RxDeregisterAsynchronousRequest(pMiniRedirectorDeviceObject);
            }

            Status = STATUS_PENDING;
        }
        else
        {
            Status = LocalStatus;
            RxLog(("RxCeBldOvrMult: Failed Status %lx\n", Status));
            RxWmiLog(LOG,
                     RxCeBuildConnectionOverMultipleTransports_2,
                     LOGULONG(Status));
        }
    }
bailout:

    return Status;
}

NTSTATUS
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection)
/*++

Routine Description:

    This routine tears down a given connection

Arguments:

    pConnection - the connection to be torn down

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeTearDownConnection);

    try {
        if (RxCeIsConnectionValid(pConnection)) {
            if (pConnection->pConnectionInformation != NULL) {
                if (pConnection->pConnectionInformation->UserDataLength > 0) {
                    RxFreePool(pConnection->pConnectionInformation->UserData);
                }

                if (pConnection->pConnectionInformation->RemoteAddressLength > 0) {
                    RxFreePool(pConnection->pConnectionInformation->RemoteAddress);
                }

                if (pConnection->pConnectionInformation->OptionsLength > 0) {
                    RxFreePool(pConnection->pConnectionInformation->Options);
                }

                RxFreePool(pConnection->pConnectionInformation);
            }

            // free the memory allocated for the handler
            if (pConnection->pHandler != NULL) {
                RxFreePool(pConnection->pHandler);
            }

            RtlZeroMemory(
                pConnection,
                sizeof(RXCE_CONNECTION));
        }

    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeTearDownConnection: C: %lx\n",pConnection));
            RxWmiLog(LOG,
                     RxCeTearDownConnection,
                     LOGPTR(pConnection));
        }
    }

    return Status;
}

NTSTATUS
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation)
/*++

Routine Description:

    This routine cancels a previously issued connection request.

Arguments:

    pConnectionInformation - the connection information pertaining to a previsouly issued
                             connection request

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length)
/*++

Routine Description:

    This routine queries information pertaining to a connection

Arguments:

    pConnection - the connection for which the information is desired

    InformationClass - the desired information class.

    pInformation - the buffer for returning the information

    Length       - the length of the buffer.

Return Value:

    STATUS_SUCCESS if successfull.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PRXCE_TRANSPORT  pTransport  = NULL;
    PRXCE_ADDRESS    pAddress    = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeQueryInformation);

    try {
        pConnection = pVc->pConnection;
        pAddress = pConnection->pAddress;
        pTransport = pAddress->pTransport;

        if (RxCeIsVcValid(pVc)                 &&
            RxCeIsConnectionValid(pConnection) &&
            RxCeIsAddressValid(pAddress)       &&
            RxCeIsTransportValid(pTransport)) {

            switch (InformationClass) {
            case RxCeTransportProviderInformation:
                if (sizeof(RXCE_TRANSPORT_PROVIDER_INFO) <= Length) {
                    // Copy the necessary provider information.
                    RtlCopyMemory(
                        pInformation,
                        pTransport->pProviderInfo,
                        sizeof(RXCE_TRANSPORT_PROVIDER_INFO));

                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

            case RxCeConnectionInformation:
                if (sizeof(RXCE_CONNECTION_INFORMATION) <= Length) {
                    RtlCopyMemory(
                        pInformation,
                        pConnection->pConnectionInformation,
                        sizeof(RXCE_CONNECTION_INFORMATION));

                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

            case RxCeConnectionEndpointInformation:
                if (sizeof(RXCE_CONNECTION_INFO) <= Length) {
                    Status = RxTdiQueryInformation(
                                 pTransport,
                                 pAddress,
                                 pConnection,
                                 pVc,
                                 RXCE_QUERY_CONNECTION_INFO,
                                 pInformation,
                                 Length);
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

            case RxCeRemoteAddressInformation:
                {
                    Status = RxTdiQueryInformation(
                                 pTransport,
                                 pAddress,
                                 pConnection,
                                 pVc,
                                 RXCE_QUERY_ADDRESS_INFO,
                                 pInformation,
                                 Length);
                }
                break;

            default:
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxcontx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxContx.c

Abstract:

    This module implements routine to allocate/initialize and to delete an Irp
    Context. These structures are very important because they link Irps with the
    RDBSS. They encapsulate all the context required to process an IRP.

Author:

    Joe Linn          [JoeLinn]  21-aug-1994

Revision History:

    Balan Sethu Raman [SethuR]   07-June-1995  Included support for cancelling
                                               requests

--*/

#include "precomp.h"
#pragma hdrstop

#include <dfsfsctl.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeContext)
#pragma alloc_text(PAGE, RxReinitializeContext)
#pragma alloc_text(PAGE, RxPrepareContextForReuse)
#pragma alloc_text(PAGE, RxCompleteRequest)
#pragma alloc_text(PAGE, __RxSynchronizeBlockingOperations)
#pragma alloc_text(PAGE, RxResumeBlockedOperations_Serially)
#pragma alloc_text(PAGE, RxResumeBlockedOperations_ALL)
#pragma alloc_text(PAGE, RxCancelBlockingOperation)
#pragma alloc_text(PAGE, RxRemoveOperationFromBlockingQueue)
#endif

BOOLEAN RxSmallContextLogEntry = FALSE;

FAST_MUTEX RxContextPerFileSerializationMutex;

//
//  The debug trace level
//

#define Dbg (DEBUG_TRACE_RXCONTX)

ULONG RxContextSerialNumberCounter = 0;

#ifdef RDBSSLOG

//
//  this stuff must be in nonpaged memory
//

                             ////       1 2 3 4 5 6 7 8 9
char RxInitContext_SurrogateFormat[] = "%S%S%N%N%N%N%N%N%N";
                             ////             2  3   4         5        6   7   8    9
char RxInitContext_ActualFormat[]    = "Irp++ %s/%lx %08lx irp %lx thrd %lx %lx:%lx #%lx";

#endif //  ifdef RDBSSLOG

VOID
ValidateBlockingIoQ (
    PLIST_ENTRY BlockingIoQ
);

VOID
RxInitializeContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext
    )
{
    PDEVICE_OBJECT TopLevelDeviceObject;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxInitializeContext\n"));

    //
    //  some asserts that we need. This ensures that the two values that are
    //  packaged together as an IoStatusBlock can be manipulated independently
    //  as well as together.
    //

    ASSERT( FIELD_OFFSET( RX_CONTEXT, StoredStatus ) == FIELD_OFFSET( RX_CONTEXT, IoStatusBlock.Status ) );

    ASSERT( FIELD_OFFSET( RX_CONTEXT, InformationToReturn ) == FIELD_OFFSET( RX_CONTEXT, IoStatusBlock.Information ) );

    //
    //  Set the proper node type code, node byte size and the flags
    //

    RxContext->NodeTypeCode = RDBSS_NTC_RX_CONTEXT;
    RxContext->NodeByteSize = sizeof( RX_CONTEXT );
    RxContext->ReferenceCount = 1;
    RxContext->SerialNumber = InterlockedIncrement( &RxContextSerialNumberCounter );
    RxContext->RxDeviceObject = RxDeviceObject;

    //
    //  Initialize the Sync Event.
    //

    KeInitializeEvent( &RxContext->SyncEvent, SynchronizationEvent, FALSE );

    //
    //  Initialize the associated scavenger entry
    //

    RxInitializeScavengerEntry( &RxContext->ScavengerEntry );

    //
    //  Initialize the list entry of blocked operations
    //

    InitializeListHead( &RxContext->BlockedOperations );

    RxContext->MRxCancelRoutine = NULL;
    RxContext->ResumeRoutine = NULL;

    SetFlag( RxContext->Flags, InitialContextFlags );

    //
    //  Set the Irp fields....for cacheing and hiding
    //

    RxContext->CurrentIrp = Irp;
    RxContext->OriginalThread = RxContext->LastExecutionThread = PsGetCurrentThread();

    if (Irp != NULL) {

        PIO_STACK_LOCATION IrpSp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );  //  ok4ioget

        //
        //  There are certain operations that are open ended in the redirector.
        //  The change notification mechanism is one of them. On a synchronous
        //  operation if the wait is in the redirector then we will not be able
        //  to cancel because FsRtlEnterFileSystem disables APC's. Therefore
        //  we convert the synchronous operation into an asynchronous one and
        //  let the I/O system do the waiting.
        //


        if (IrpSp->FileObject != NULL) {
            if (!IoIsOperationSynchronous( Irp )) {
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
            } else {

                PFCB Fcb;

                Fcb  = (PFCB)IrpSp->FileObject->FsContext;

                if ((Fcb != NULL) && NodeTypeIsFcb( Fcb )) {

                    if (((IrpSp->MajorFunction == IRP_MJ_READ)  ||
                         (IrpSp->MajorFunction == IRP_MJ_WRITE) ||
                         (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)) &&
                        (Fcb->NetRoot != NULL) &&
                        (Fcb->NetRoot->Type == NET_ROOT_PIPE))  {

                        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
                    }
                }
            }
        }

        if ((IrpSp->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
            (IrpSp->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY)) {

            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        }

        //
        //  JOYC: make all device io control async
        //

        if (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        }

        //
        //  Set the recursive file system call parameter.  We set it true if
        //  the TopLevelIrp field in the thread local storage is not the current
        //  irp, otherwise we leave it as FALSE.
        //

        if (!RxIsThisTheTopLevelIrp( Irp )) {
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_RECURSIVE_CALL );
        }
        if (RxGetTopDeviceObjectIfRdbssIrp() == RxDeviceObject) {
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL );
        }

        //
        //  Major/Minor Function codes
        //

        RxContext->MajorFunction = IrpSp->MajorFunction;
        RxContext->MinorFunction = IrpSp->MinorFunction;

        ASSERT( RxContext->MajorFunction <= IRP_MJ_MAXIMUM_FUNCTION );

        RxContext->CurrentIrpSp = IrpSp;

        if (IrpSp->FileObject) {

            PFOBX Fobx;
            PFCB Fcb;

            Fcb  = (PFCB)IrpSp->FileObject->FsContext;
            Fobx = (PFOBX)IrpSp->FileObject->FsContext2;

            RxContext->pFcb = (PMRX_FCB)Fcb;
            if (Fcb && NodeTypeIsFcb( Fcb )) {
                RxContext->NonPagedFcb = Fcb->NonPaged;
            }

            if (Fobx &&
                (Fobx != (PFOBX)UIntToPtr( DFS_OPEN_CONTEXT )) &&
                (Fobx != (PFOBX)UIntToPtr( DFS_DOWNLEVEL_OPEN_CONTEXT ))) {

                RxContext->pFobx = (PMRX_FOBX)Fobx;
                RxContext->pRelevantSrvOpen = Fobx->pSrvOpen;
                if (NodeType( Fobx ) == RDBSS_NTC_FOBX) {
                    RxContext->FobxSerialNumber = InterlockedIncrement( &Fobx->FobxSerialNumber );
                }
            } else {
                RxContext->pFobx = NULL;
            }

            //
            //  Copy IRP specific parameters.
            //

            if ((RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
                (RxContext->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY)) {

                if (Fobx != NULL) {
                    if (NodeType( Fobx ) == RDBSS_NTC_FOBX) {
                        RxContext->NotifyChangeDirectory.pVNetRoot = (PMRX_V_NET_ROOT)Fcb->VNetRoot;
                    } else if (NodeType( Fobx ) == RDBSS_NTC_V_NETROOT) {
                        RxContext->NotifyChangeDirectory.pVNetRoot = (PMRX_V_NET_ROOT)Fobx;
                    }
                }
            }

            //
            //  Copy RealDevice for workque algorithms,
            //

            RxContext->RealDevice = IrpSp->FileObject->DeviceObject;
            if (FlagOn( IrpSp->FileObject->Flags,FO_WRITE_THROUGH )) {
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH );
            }
        }
    } else {

        RxContext->CurrentIrpSp = NULL;

        //
        //  Major/Minor Function codes
        //

        RxContext->MajorFunction = IRP_MJ_MAXIMUM_FUNCTION + 1;
        RxContext->MinorFunction = 0;
    }

    if (RxContext->MajorFunction != IRP_MJ_DEVICE_CONTROL) {

        PETHREAD Thread = PsGetCurrentThread();
        UCHAR Pad = 0;

        RxLog(( RxInitContext_SurrogateFormat,
                RxInitContext_ActualFormat,
                RXCONTX_OPERATION_NAME( RxContext->MajorFunction, BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT )),
                RxContext->MinorFunction,
                RxContext,
                Irp,
                Thread,
                RxContext->pFcb,
                RxContext->pFobx,
                RxContext->SerialNumber ));

        RxWmiLog( LOG,
                  RxInitializeContext,
                  LOGPTR( RxContext )
                  LOGPTR( Irp )
                  LOGPTR( Thread )
                  LOGPTR( RxContext->pFcb )
                  LOGPTR( RxContext->pFobx )
                  LOGULONG( RxContext->SerialNumber )
                  LOGUCHAR( RxContext->MinorFunction )
                  LOGARSTR( RXCONTX_OPERATION_NAME( RxContext->MajorFunction, BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT ) )) );
    }

    RxDbgTrace( -1, Dbg, ("RxInitializeContext -> %08lx %08lx %08lx\n", RxContext, RxContext->pFcb, RxContext->pFobx ));
}


PRX_CONTEXT
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    )
/*++

Routine Description:

    This routine creates a new RX_CONTEXT record

Arguments:

    Irp                 - Supplies the originating Irp.

    RxDeviceObject      - the deviceobject that applies

    InitialContextFlags - Supplies the wait value to store in the context;
                          also, the must_succeed value

Return Value:

    PRX_CONTEXT - returns a pointer to the newly allocate RX_CONTEXT Record

--*/
{
    KIRQL SavedIrql;
    PRX_CONTEXT RxContext = NULL;
    ULONG RxContextFlags = 0;
    UCHAR MustSucceedDescriptorNumber = 0;

#if DBG
    InterlockedIncrement( &RxFsdEntryCount );
#endif

    ASSERT( RxDeviceObject != NULL );

    InterlockedIncrement( &RxDeviceObject->NumberOfActiveContexts );

    if (RxContext == NULL) {

        RxContext = ExAllocateFromNPagedLookasideList( &RxContextLookasideList );

        if (RxContext != NULL) {
            SetFlag( RxContextFlags, RX_CONTEXT_FLAG_FROM_POOL );
        }
    }

    if (RxContext == NULL) {
        return NULL;
    }

    RtlZeroMemory( RxContext, sizeof( RX_CONTEXT ) );

    RxContext->Flags = RxContextFlags;
    RxContext->MustSucceedDescriptorNumber = MustSucceedDescriptorNumber;

    RxInitializeContext( Irp, RxDeviceObject, InitialContextFlags, RxContext );

    ASSERT( (RxContext->MajorFunction!=IRP_MJ_CREATE) ||
            !FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED ) );

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    InsertTailList(&RxActiveContexts,&RxContext->ContextListEntry);

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    return RxContext;
}

VOID
RxReinitializeContext(
   IN OUT PRX_CONTEXT RxContext
   )
{
   PIRP Irp  = RxContext->CurrentIrp;
   PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

   ULONG PreservedContextFlags = FlagOn( RxContext->Flags, RX_CONTEXT_PRESERVED_FLAGS );
   ULONG InitialContextFlags = FlagOn( RxContext->Flags, RX_CONTEXT_INITIALIZATION_FLAGS );

   PAGED_CODE();

   RxPrepareContextForReuse( RxContext );

   RtlZeroMemory( (PCHAR)(&RxContext->ContextListEntry + 1), sizeof( RX_CONTEXT ) - FIELD_OFFSET( RX_CONTEXT, MajorFunction ) );

   RxContext->Flags = PreservedContextFlags;

   RxInitializeContext( Irp, RxDeviceObject, InitialContextFlags, RxContext );
}

VOID
RxPrepareContextForReuse (
   IN OUT PRX_CONTEXT RxContext
   )
/*++

Routine Description:

    This routine prepares a context for reuse by resetting all operation specific
    allocations/acquistions that have been made. The parameters that have been
    obtained from the IRP are not modified.

Arguments:

    RxContext - Supplies the RX_CONTEXT to remove

Return Value:

    None

--*/
{
    PAGED_CODE();

    //
    //  Clean up the operation specific stuff
    //

    switch (RxContext->MajorFunction) {

    case IRP_MJ_CREATE:
        ASSERT( RxContext->Create.CanonicalNameBuffer == NULL );
        break;

    case IRP_MJ_READ :
    case IRP_MJ_WRITE :

        ASSERT( RxContext->RxContextSerializationQLinks.Flink == NULL );
        ASSERT( RxContext->RxContextSerializationQLinks.Blink == NULL );

        break;

    default:
        NOTHING;
    }

    RxContext->ReferenceCount = 0;
}


VOID
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine dereferences an RxContexts and if the refcount goes to zero
    then it deallocates and removes the specified RX_CONTEXT record from the
    Rx in-memory data structures. IT is called by routines other than
    RxCompleteRequest async requests touch the RxContext "last" in either the
    initiating thread or in some other thread. Thus, we refcount the structure
    and finalize on the last dereference.

Arguments:

    RxContext - Supplies the RX_CONTEXT to remove

Return Value:

    None

--*/
{
    KIRQL SavedIrql;
    BOOLEAN RxContextIsFromPool;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT StopContext = NULL;
    LONG FinalRefCount;

    RxDbgTraceLV( +1, Dbg, 1500, ("RxDereferenceAndDeleteRxContext, RxContext = %08lx (%lu)\n", RxContext,RxContext->SerialNumber) );

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    ASSERT( RxContext->NodeTypeCode == RDBSS_NTC_RX_CONTEXT );

    FinalRefCount = InterlockedDecrement( &RxContext->ReferenceCount );

    if (FinalRefCount == 0) {

        RxDeviceObject = RxContext->RxDeviceObject;
        RxContextIsFromPool = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_FROM_POOL );

        if (RxContext == RxDeviceObject->StartStopContext.pStopContext) {
            RxDeviceObject->StartStopContext.pStopContext = NULL;
        } else {

            ASSERT((RxContext->ContextListEntry.Flink->Blink == &RxContext->ContextListEntry) &&
                   (RxContext->ContextListEntry.Blink->Flink == &RxContext->ContextListEntry));

            RemoveEntryList( &RxContext->ContextListEntry );

            if ((InterlockedDecrement( &RxDeviceObject->NumberOfActiveContexts) == 0) &&
                (RxDeviceObject->StartStopContext.pStopContext != NULL)) {

                StopContext = RxDeviceObject->StartStopContext.pStopContext;
            }
        }
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (FinalRefCount > 0) {

        RxDbgTraceLV( -1, Dbg, 1500, ("RxDereferenceAndDeleteRxContext, RxContext not final!!! = %08lx (%lu)\n", RxContext,RxContext->SerialNumber) );
        return;
    }

    ASSERT( RxContext->ReferenceCount == 0 );

    //
    //  Clean up the operation specific stuff
    //

    RxPrepareContextForReuse( RxContext );

    ASSERT( RxContext->AcquireReleaseFcbTrackerX == 0 );

    if (StopContext != NULL) {

        //
        //  Signal the event.
        //

        RxSignalSynchronousWaiter( StopContext );
    }

#if DBG
    if (RxContext->ShadowCritOwner) {
        DbgPrint( "RxDereferenceAndDeleteRxContext:shdowcrit still owned by %x\n", RxContext->ShadowCritOwner );
        ASSERT( FALSE );
    }
#endif
    if (RxContextIsFromPool) {

        ExFreeToNPagedLookasideList( &RxContextLookasideList, RxContext );
    }

    RxDbgTraceLV( -1, Dbg, 1500, ("RxDereferenceAndDeleteRxContext -> VOID\n", 0) );

    return;
}

ULONG RxStopOnLoudCompletion = TRUE;

NTSTATUS
RxCompleteRequest (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine complete the request associated with the RX_CONTEXT

Arguments:

    RxContext  -  Contains an irp to be completed

    Status -  Status to complete request with

Return Value:



--*/
{
    PIRP Irp = RxContext->CurrentIrp;

    PAGED_CODE();

    ASSERT( RxContext );
    ASSERT( RxContext->CurrentIrp );

    if ((RxContext->LoudCompletionString)) {

        DbgPrint( "LoudCompletion %08lx/%08lx on %wZ\n", Status, Irp->IoStatus.Information, RxContext->LoudCompletionString );
        if ((Status != STATUS_SUCCESS) && RxStopOnLoudCompletion) {

            DbgPrint( "FAILURE!!!!! %08lx/%08lx on %wZ\n", Status, Irp->IoStatus.Information, RxContext->LoudCompletionString );
            //  DbgBreakPoint();
        }
    }

    RxCompleteRequest_Real( RxContext, Irp, Status );

    return Status;
}

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                                  ////      1 2 3 4 5 6 7 8 9
char RxCompleteContext_SurrogateFormat[] = "%S%S%S%N%N%N%N%N%N";
                                  ////            2 3  4   5       6        7   8    9
char RxCompleteContext_ActualFormat[]    = "Irp-- %s%s/%lx %lx irp %lx iosb %lx,%lx #%lx";

#endif //ifdef RDBSSLOG


VOID
RxCompleteRequest_Real (
    IN OPTIONAL PRX_CONTEXT RxContext,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine completes a Irp

Arguments:

    Irp - Supplies the Irp being processed

    Status - Supplies the status to complete the Irp with

--*/
{
    //
    //  If we have an Irp then complete the irp.
    //

    if (Irp != NULL) {

        CCHAR PriorityBoost;
        PIO_STACK_LOCATION IrpSp;

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        RxSetCancelRoutine( Irp, NULL );

        //
        //  For an error, zero out the information field before
        //  completing the request if this was an input operation.
        //  Otherwise IopCompleteRequest will try to copy to the user's buffer.
        //  Also, no boost for an error.
        //

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
            PriorityBoost = IO_NO_INCREMENT;

        } else {
            PriorityBoost = IO_DISK_INCREMENT;
        }

        Irp->IoStatus.Status = Status;

        RxDbgTrace( 0, (DEBUG_TRACE_DISPATCH),
                       ("RxCompleteRequest_real ----------   Irp(code) = %08lx(%02lx) %08lx %08lx\n",
                                      Irp, IoGetCurrentIrpStackLocation( Irp )->MajorFunction,
                                      Status, Irp->IoStatus.Information));

        if (RxContext != NULL) {

            ASSERT( RxContext->MajorFunction <= IRP_MJ_MAXIMUM_FUNCTION );

            if (RxContext->MajorFunction != IRP_MJ_DEVICE_CONTROL) {
                RxLog(( RxCompleteContext_SurrogateFormat,
                        RxCompleteContext_ActualFormat,
                        (RxContext->OriginalThread == PsGetCurrentThread())?"":"*",
                        RXCONTX_OPERATION_NAME( RxContext->MajorFunction ,TRUE) ,
                        RxContext->MinorFunction,
                        RxContext,
                        Irp,
                        Status,
                        Irp->IoStatus.Information,
                        RxContext->SerialNumber ));

                RxWmiLog( LOG,
                          RxCompleteRequest,
                          LOGPTR( RxContext )
                          LOGPTR( Irp )
                          LOGULONG( Status )
                          LOGPTR( Irp->IoStatus.Information )
                          LOGULONG( RxContext->SerialNumber )
                          LOGUCHAR( RxContext->MinorFunction )
                          LOGARSTR( RXCONTX_OPERATION_NAME( RxContext->MajorFunction, TRUE )) );
            }
        }

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
            (Status != STATUS_PENDING) &&
            (RxContext != NULL)) {

            if (FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH )) {
                IrpSp->FileObject->FileName.Length += sizeof( WCHAR );
            }

            RxpPrepareCreateContextForReuse( RxContext );

            ASSERT ( RxContext->Create.CanonicalNameBuffer == NULL );
        }

        //
        //  Check information returned  on successfull writes is no more than requested
        //

        ASSERT( (IrpSp->MajorFunction != IRP_MJ_WRITE) ||
                (Irp->IoStatus.Status != STATUS_SUCCESS) ||
                (Irp->IoStatus.Information <= IrpSp->Parameters.Write.Length) );

        //
        //  Check that pending returned is in sync with the irp itself
        //

        ASSERT( (RxContext == NULL) ||
                (!RxContext->PendingReturned) ||
                FlagOn( IrpSp->Control, SL_PENDING_RETURNED ) );


        if( RxContext != NULL ) RxContext->CurrentIrp = NULL;
        IoCompleteRequest( Irp, PriorityBoost );

    } else {

        //
        //  a call with a null irp..........
        //

        RxLog(( "Irp00 %lx\n", RxContext ));
        RxWmiLog( LOG,
                  RxCompleteRequest_NI,
                  LOGPTR( RxContext ) );
    }

    //
    //  Delete the Irp context.
    //

    if (RxContext != NULL) {
        RxDereferenceAndDeleteRxContext( RxContext );
    }

    return;
}

NTSTATUS
__RxSynchronizeBlockingOperations (
    IN OUT PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN BOOLEAN DropFcbLock
    )
/*++

Routine Description:

    This routine is used to synchronize among blocking IOs to the same Q.
    Currently, the routine is only used to synchronize block pipe operations and
    the Q is the one in the file object extension (Fobx). What happens is that
    the operation joins the queue. If it is now the front of the queue, the
    operation continues; otherwise it waits on the sync event in the RxContext
    or just returns pending (if async).

    We may have been cancelled while we slept, check for that and
    return an error if it happens.

    The event must have been reset before the call. The fcb lock must be held;
    it is dropped after we get on the Q.

Arguments:

    RxContext    The context of the operation being synchronized

    BlockingIoQ  The queue to get on.

--*/
{
    NTSTATUS Status;

    PIRP Irp = RxContext->CurrentIrp;

    BOOLEAN FcbLockDropped = FALSE;
    BOOLEAN SerializationMutexReleased = FALSE;

    PRX_CONTEXT FrontRxContext;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock, rxc=%08lx, fobx=%08lx\n", RxContext, RxContext->pFobx) );

    //
    //  do this early since a cleanup could come through and change it
    //

    RxContext->StoredStatus = STATUS_SUCCESS;

    ExAcquireFastMutex( &RxContextPerFileSerializationMutex );

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {

        SetFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

        InsertTailList( BlockingIoQ, &RxContext->RxContextSerializationQLinks );
        FrontRxContext = CONTAINING_RECORD( BlockingIoQ->Flink, RX_CONTEXT, RxContextSerializationQLinks );

        if (RxContext != FrontRxContext) {
            if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
                if (!SerializationMutexReleased) {
                    SerializationMutexReleased = TRUE;
                    ExReleaseFastMutex( &RxContextPerFileSerializationMutex );
                }

                if (DropFcbLock && !FcbLockDropped) {
                    RxContext->FcbResourceAcquired = FALSE;
                    FcbLockDropped = TRUE;
                    RxReleaseFcb( RxContext, Fcb );
                }

                RxDbgTrace( 0, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock waiting, rxc=%08lx\n", RxContext) );

                RxWaitSync( RxContext );

                RxDbgTrace( 0, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock ubblocked, rxc=%08lx\n", RxContext) );

            } else {

                RxContext->StoredStatus = STATUS_PENDING;
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME );

                try {
                    RxPrePostIrp( RxContext, Irp );
                } finally {
                    if (AbnormalTermination()) {
                        RxLog(( "!!!!! RxContext %lx Status %lx\n", RxContext, RxContext->StoredStatus ));
                        RxWmiLog( LOG,
                                  RxSynchronizeBlockingOperationsMaybeDroppingFcbLock,
                                  LOGPTR( RxContext )
                                  LOGULONG( Status ));

                        RemoveEntryList(&RxContext->RxContextSerializationQLinks);

                        RxContext->RxContextSerializationQLinks.Flink = NULL;
                        RxContext->RxContextSerializationQLinks.Blink = NULL;

                        ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

                        if (!SerializationMutexReleased) {
                            SerializationMutexReleased = TRUE;
                            ExReleaseFastMutex( &RxContextPerFileSerializationMutex );
                        }
                    } else {
                        InterlockedIncrement( &RxContext->ReferenceCount );
                    }
                }

                RxDbgTrace( -1, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock asyncreturn, rxc=%08lx\n", RxContext) );
            }
        }

        if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {
            Status = STATUS_CANCELLED;
        } else {
            Status = RxContext->StoredStatus;
        }
    } else {
        Status = STATUS_CANCELLED;
    }

    if (!SerializationMutexReleased) {
        SerializationMutexReleased = TRUE;
        ExReleaseFastMutex( &RxContextPerFileSerializationMutex );
    }

    if (DropFcbLock && !FcbLockDropped) {
        RxContext->FcbResourceAcquired = FALSE;
        FcbLockDropped = TRUE;
        RxReleaseFcb( RxContext, Fcb );
    }

    RxDbgTrace( -1, Dbg, ("RxSynchronizeBlockingOperationsAndDropFcbLock returning, rxc=%08lx, status=%08lx\n", RxContext, Status) );

    return Status;
}

VOID
RxRemoveOperationFromBlockingQueue (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine removes the context from the blocking queue if it is on it

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    PAGED_CODE();

    ExAcquireFastMutex( &RxContextPerFileSerializationMutex );

    if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION )) {

        ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

        RemoveEntryList( &RxContext->RxContextSerializationQLinks );

        RxContext->RxContextSerializationQLinks.Flink = NULL;
        RxContext->RxContextSerializationQLinks.Blink = NULL;
    }

    ExReleaseFastMutex( &RxContextPerFileSerializationMutex );

    RxDbgTrace( -1, Dbg, ("RxRemoveOperationFromBlockingQueue, rxc=%08lx\n", RxContext ));
    return;
}

VOID
RxCancelBlockingOperation (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine cancels the operation in the blocking queue

Arguments:

    RxContext -  The context of the operation being synchronized

Return:

    None

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PFCB Fcb;
    PFOBX Fobx;
    BOOLEAN CompleteRequest = FALSE;

    PAGED_CODE();

    ExAcquireFastMutex( &RxContextPerFileSerializationMutex );

    if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION ) &&
        (RxContext->RxContextSerializationQLinks.Flink != NULL)) {

        //
        //  Now its safe to get the fobx - since we know the irp is still active
        //  we will cancel the request if it isn't on the front of the list
        //

        IrpSp = IoGetCurrentIrpStackLocation( Irp );
        RxDecodeFileObject( IrpSp->FileObject, &Fcb, &Fobx );

        if ((RxContext != CONTAINING_RECORD( Fobx->Specific.NamedPipe.ReadSerializationQueue.Flink, RX_CONTEXT, RxContextSerializationQLinks) ) &&
            (RxContext != CONTAINING_RECORD( Fobx->Specific.NamedPipe.WriteSerializationQueue.Flink, RX_CONTEXT, RxContextSerializationQLinks) )) {

            ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

            RemoveEntryList( &RxContext->RxContextSerializationQLinks );

            RxContext->RxContextSerializationQLinks.Flink = NULL;
            RxContext->RxContextSerializationQLinks.Blink = NULL;
            RxContext->StoredStatus = STATUS_CANCELLED;

            if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
                RxSignalSynchronousWaiter( RxContext );
            } else {

                CompleteRequest = TRUE;
            }
        }
    }

    ExReleaseFastMutex( &RxContextPerFileSerializationMutex );

    if (CompleteRequest) {

        RxFsdPostRequest( RxContext );
    }

    RxDbgTrace( -1, Dbg, ("RxCancelBlockedOperations, rxc=%08lx\n", RxContext ));
    return;
}

VOID
RxResumeBlockedOperations_Serially (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    )
/*++

Routine Description:

    This routine wakes up the next guy, if any, on the serialized blockingioQ. We know that the fcb must still be valid because
    of the reference that is being held by the IO system on the file object thereby preventing a close.

Arguments:

    RxContext    The context of the operation being synchronized
    BlockingIoQ  The queue to get on.

--*/
{
    PLIST_ENTRY ListEntry;
    BOOLEAN FcbLockHeld = FALSE;
    PRX_CONTEXT FrontRxContext = NULL;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxResumeBlockedOperations_Serially, rxc=%08lx, fobx=%08lx\n", RxContext, RxContext->pFobx ));

    //
    //  remove myself from the queue and check for someone else
    //

    ExAcquireFastMutex( &RxContextPerFileSerializationMutex );

    if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION )) {
        ClearFlag( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION );

        //  ValidateBlockingIoQ(BlockingIoQ);

        RemoveEntryList( &RxContext->RxContextSerializationQLinks );

        //  ValidateBlockingIoQ(BlockingIoQ);

        RxContext->RxContextSerializationQLinks.Flink = NULL;
        RxContext->RxContextSerializationQLinks.Blink = NULL;

        ListEntry = BlockingIoQ->Flink;

        if (BlockingIoQ != ListEntry) {
            FrontRxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, RxContextSerializationQLinks );
            RxDbgTrace( -1, Dbg, ("RxResumeBlockedOperations unwaiting the next guy and returning, rxc=%08lx\n", RxContext ));
        } else {
            FrontRxContext = NULL;
        }

        if (FrontRxContext != NULL) {
            if (!FlagOn( FrontRxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
                RxSignalSynchronousWaiter( FrontRxContext );
            } else {

                //
                //  The reference taken in the synchronization routine is derefernced
                //  by the post completion routine,
                //

                RxFsdPostRequest( FrontRxContext );
            }
        }
    }

    ExReleaseFastMutex( &RxContextPerFileSerializationMutex );

    RxDbgTrace( -1, Dbg, ("RxResumeBlockedOperations_Serially returning, rxc=%08lx\n", RxContext ) );
    return;
}

VOID
RxResumeBlockedOperations_ALL (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine wakes up all of the guys on the blocked operations queue. The controlling mutex is also
    stored in the RxContext block. the current implementation is that all of the guys must be waiting
    on the sync events.

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    LIST_ENTRY CopyOfQueue;
    PLIST_ENTRY ListEntry;

    PAGED_CODE();

    RxDbgTrace( +1, Dbg, ("RxResumeBlockedOperations_ALL, rxc=%08lx\n", RxContext) );

    RxTransferListWithMutex( &CopyOfQueue, &RxContext->BlockedOperations, RxContext->BlockedOpsMutex );

    for (ListEntry = CopyOfQueue.Flink; ListEntry != &CopyOfQueue;) {

        PRX_CONTEXT FrontRxContext = CONTAINING_RECORD( ListEntry, RX_CONTEXT, RxContextSerializationQLinks );

        RxSignalSynchronousWaiter( FrontRxContext );

        IF_DEBUG {
            PLIST_ENTRY PrevListEntry = ListEntry;
            ListEntry = ListEntry->Flink;
            PrevListEntry->Flink = PrevListEntry->Blink = NULL;
        } else {
            ListEntry = ListEntry->Flink;
        }
    }

    RxDbgTrace( -1, Dbg, ("RxResumeBlockedOperations_ALL returning, rxc=%08lx\n", RxContext) );
    return;
}


VOID
__RxItsTheSameContext (
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    )
{
    if ((NodeType( RxContext ) != RDBSS_NTC_RX_CONTEXT) ||
         (RxContext->SerialNumber != CapturedRxContextSerialNumber)) {

        RxLog(( "NotSame!!!! %lx", RxContext ));
        RxWmiLog( LOG,
                  RxItsTheSameContext,
                  LOGPTR( RxContext ) );

        DbgPrint( "NOT THE SAME CONTEXT %08lx at Line %d in %s\n", RxContext, Line, File );
    }
}

#if 0
VOID
ValidateBlockingIoQ(
    PLIST_ENTRY BlockingIoQ
)
{
    PLIST_ENTRY ListEntry;
    ULONG cntFlink, cntBlink;

    cntFlink = cntBlink = 0;

    ListEntry = BlockingIoQ->Flink;

    while (ListEntry != BlockingIoQ) {

        PRX_CONTEXT RxContext;

        RxContext = (PRX_CONTEXT)CONTAINING_RECORD( ListEntry, RX_CONTEXT, RxContextSerializationQLinks );

        if (!RxContext || (NodeType( RxContext ) != RDBSS_NTC_RX_CONTEXT)) {

            DbgPrint("ValidateBlockingIO:Invalid RxContext %x on Q %x\n", RxContext, BlockingIoQ );
            //DbgBreakPoint();
        }

        cntFlink += 1;
        ListEntry = ListEntry->Flink;
    }

    //
    //  check backward list validity
    //

    ListEntry = BlockingIoQ->Blink;

    while (ListEntry != BlockingIoQ) {
        PRX_CONTEXT RxContext;

        RxContext = (PRX_CONTEXT)CONTAINING_RECORD( ListEntry, RX_CONTEXT, RxContextSerializationQLinks );


        if (!RxContext || (NodeType( RxContext ) != RDBSS_NTC_RX_CONTEXT)) {

            DbgPrint("ValidateBlockingIO:Invalid RxContext %x on Q %x\n",
                     RxContext, BlockingIoQ);
            //DbgBreakPoint();
        }

        cntBlink += 1;
        ListEntry = ListEntry->Blink;
    }

    //
    //  both counts should be the same
    //

    if(cntFlink != cntBlink) {
        DbgPrint( "ValidateBlockingIO: cntFlink %d cntBlink %d\n", cntFlink, cntBlink );
        //DbgBreakPoint();
    }
}

#endif

#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG RxContextField_##x = FIELD_OFFSET(RX_CONTEXT,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG RxContextField_##x##y = FIELD_OFFSET(RX_CONTEXT,x.y);

DECLARE_FIELD_HLPR(MajorFunction);
DECLARE_FIELD_HLPR(CurrentIrp);
DECLARE_FIELD_HLPR(pFcb);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(MRxContext);
DECLARE_FIELD_HLPR(MRxCancelRoutine);
DECLARE_FIELD_HLPR(SyncEvent);
DECLARE_FIELD_HLPR(BlockedOperations);
DECLARE_FIELD_HLPR(FlagsForLowIo);
DECLARE_FIELD_HLPR2(Create,CanonicalNameBuffer);
DECLARE_FIELD_HLPR2(Create,pSrvCall);
DECLARE_FIELD_HLPR2(Create,pNetRoot);
DECLARE_FIELD_HLPR2(Create,pVNetRoot);
DECLARE_FIELD_HLPR2(QueryDirectory,FileIndex);
DECLARE_FIELD_HLPR2(QueryEa,UserEaList);
DECLARE_FIELD_HLPR2(QuerySecurity,SecurityInformation);
DECLARE_FIELD_HLPR2(QuerySecurity,Length);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxcep.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcep.h

Abstract:

    This is the include file that defines all constants and types for
    implementing the redirector file system connection engine.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:
    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

--*/

#ifndef _RXCEP_H_
#define _RXCEP_H_

//
//  The following definition provide a rudimentary profiling mechanism by having a counter
//  associated with each of the procedure definitions. This counter is incremented for every
//  invocation.
//
//  Notes: we should think about some means of sorting all the counts so as to provide a global
//  picture of the redirector.
//

#define RxProfile(CATEGORY,ProcName)  {\
        RxDbgTrace(0,(DEBUG_TRACE_ALWAYS), ("%s@IRQL %d\n", #ProcName , KeGetCurrentIrql() )); \
        }

#include <rxworkq.h>
#include <rxce.h>       // Rx Connection Engine
#include <rxcehdlr.h>   // Rx Connection engine handler definitions
#include <mrx.h>        // RDBSS related definitions

//
// The following data structures are related to coordination between multiple callout
// ( calls by wrappers to other components ) made by the wrapper.

typedef struct _RX_CALLOUT_PARAMETERS_BLOCK_ {
    struct _RX_CALLOUT_PARAMETERS_BLOCK_ *pNextCallOutParameterBlock;
    struct _RX_CALLOUT_CONTEXT_ *pCallOutContext;

    NTSTATUS    CallOutStatus;
    ULONG       CallOutId;
} RX_CALLOUT_PARAMETERS_BLOCK,
 *PRX_CALLOUT_PARAMETERS_BLOCK;


typedef
VOID
(NTAPI *PRX_CALLOUT_ROUTINE) (
    IN OUT PRX_CALLOUT_PARAMETERS_BLOCK pParametersBlock);

typedef struct _RX_CALLOUT_CONTEXT_ {
    PRX_CALLOUT_ROUTINE pRxCallOutInitiation;
    PRX_CALLOUT_ROUTINE pRxCallOutCompletion;

    LONG  NumberOfCallOuts;
    LONG  NumberOfCallOutsInitiated;
    LONG  NumberOfCallOutsCompleted;

    KSPIN_LOCK  SpinLock;

    PRDBSS_DEVICE_OBJECT pRxDeviceObject;

    PRX_CALLOUT_PARAMETERS_BLOCK pCallOutParameterBlock;
} RX_CALLOUT_CONTEXT,
  *PRX_CALLOUT_CONTEXT;


// The following data structures implement the mechanism for initiating callouts to
// multiple transports for setting up a connection. The mini redirectors specify
// a number of local address handles for which they want to initiate a connection
// setup request to a remote server. They are in the desired order of importance.
//
// This mechanism allows for initiating all the callouts asynchronously and waiting
// for the best one to complete. Once it is done the connect request is completed
//
// This mechanism also provides the necessary infrastructure to cleanup the
// connection engine data structures after a connect request was completed. In other
// words the mini redirector need not wait for all the transports to complete, it
// merely waits for the best one to complete.
//
// These data structures are based on the generic Callout data structures defined in
// rxcep.h

typedef struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ {
    RX_CALLOUT_CONTEXT;

    RXCE_CONNECTION_CREATE_OPTIONS CreateOptions;

    // Results to be passed back to the original callout request
    PRXCE_CONNECTION_COMPLETION_ROUTINE  pCompletionRoutine;
    PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext;

    // TDI Connection context
    PRXCE_VC  pConnectionContext;

    // Callout id of the desired winner. It is originally set to the callout Id
    // associated with the first address and later modified depending upon the
    // completion status.
    ULONG   BestPossibleWinner;

    // The callout that was selected as the winner.
    ULONG   WinnerCallOutId;

    // The winner was found and the Completion event was signalled. This enables the
    // hystersis between the completion of the callout request and cleanup.
    BOOLEAN WinnerFound;

    // Once the winner is found we ensure that all callouts have been properly
    // initiated before the request is completed.
    BOOLEAN CompletionRoutineInvoked;

    RX_WORK_QUEUE_ITEM  WorkQueueItem;

    PKEVENT pCleanUpEvent;

} RX_CREATE_CONNECTION_CALLOUT_CONTEXT,
  *PRX_CREATE_CONNECTION_CALLOUT_CONTEXT;

typedef struct _RX_CREATE_CONNECTION_PARAMETERS_BLOCK_ {
    RX_CALLOUT_PARAMETERS_BLOCK;

    RXCE_CONNECTION     Connection;
    RXCE_VC             Vc;

    // TDI context for async continuation
    PIRP                pConnectIrp;
    PULONG              IrpRefCount;
} RX_CREATE_CONNECTION_PARAMETERS_BLOCK,
  *PRX_CREATE_CONNECTION_PARAMETERS_BLOCK;

//
// Miscellanous routines to support constuction/destruction of connection engine
// data structures
//

extern NTSTATUS
NTAPI
RxCeInit();

extern VOID
NTAPI
RxCeTearDown();


#endif  // _RXCEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxdebug.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.c

Abstract:

    This module implements functions supporting read/write tracking for help in
    tracking down data corruption problems.

    Currently it is only implemented for files that are created of drive
    letter X:. For each file that is created there are three additional bitmaps
    are created. The first one marks the ranges of fileoffset, length for which
    write were submitted to rdbss. The second  bitmap marks the ranges of the
    file for which write requests were passed onto the mini redirector
    (initiation of Lowio). The third bitmap marks the ranges for which the I/O
    was successfully completed.

    Each bit map kas 8k bits long enough to accomodate files upto ( 8K * PAGE_SIZE)
    bytes. The FCB contains a pointer to this data structure. The data structure
    is independent of FCB's and a new one is created everytime a new FCB instance
    is created.

Author:

    Balan Sethu Raman --

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#ifdef RDBSSLOG
#include <stdio.h>
#endif

VOID
RxInitializeDebugSupport()
{
#ifdef RX_WJ_DBG_SUPPORT
    RxdInitializeWriteJournalSupport();
#endif
}

VOID
RxTearDownDebugSupport()
{
#ifdef RX_WJ_DBG_SUPPORT
    RxdTearDownWriteJournalSupport();
#endif
}

#ifdef RX_WJ_DBG_SUPPORT

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxdInitializeWriteJournalSupport)
#pragma alloc_text(PAGE, RxdTearDownWriteJournalSupport)
#pragma alloc_text(PAGE, RxdInitializeFcbWriteJournalDebugSupport)
#pragma alloc_text(PAGE, RxdTearDownFcbWriteJournalDebugSupport)
#pragma alloc_text(PAGE, RxdUpdateJournalOnWriteInitiation)
#pragma alloc_text(PAGE, RxdUpdateJournalOnLowIoWriteInitiation)
#pragma alloc_text(PAGE, RxdUpdateJournalOnLowIoWriteCompletion)
#pragma alloc_text(PAGE, RxdFindWriteJournal)
#pragma alloc_text(PAGE, UpdateBitmap)
#endif

LIST_ENTRY OldWriteJournals;
LIST_ENTRY ActiveWriteJournals;
ERESOURCE  WriteJournalsResource;

extern VOID
UpdateBitmap(
    PBYTE           pBitmap,
    LARGE_INTEGER   Offset,
    ULONG           Length);

extern PFCB_WRITE_JOURNAL
RxdFindWriteJournal(
    PFCB pFcb);

VOID
RxdInitializeWriteJournalSupport()
{
    PAGED_CODE();

    InitializeListHead(&ActiveWriteJournals);
    InitializeListHead(&OldWriteJournals);

    ExInitializeResource(&WriteJournalsResource);
}

VOID
RxdTearDownWriteJournalSupport()
{
    PLIST_ENTRY pJournalEntry;

    PFCB_WRITE_JOURNAL pJournal;

    PAGED_CODE();

    ExAcquireResourceExclusive(&WriteJournalsResource,TRUE);

    while (ActiveWriteJournals.Flink != &ActiveWriteJournals) {
        pJournalEntry = RemoveHeadList(&ActiveWriteJournals);

        pJournal = (PFCB_WRITE_JOURNAL)
                   CONTAINING_RECORD(
                       pJournalEntry,
                       FCB_WRITE_JOURNAL,
                       JournalsList);

        RxFreePool(pJournal);
    }

    while (OldWriteJournals.Flink != &OldWriteJournals) {
        pJournalEntry = RemoveHeadList(&OldWriteJournals);

        pJournal = (PFCB_WRITE_JOURNAL)
                   CONTAINING_RECORD(
                       pJournalEntry,
                       FCB_WRITE_JOURNAL,
                       JournalsList);

        RxFreePool(pJournal);
    }

    ExReleaseResource(&WriteJournalsResource);

    ExDeleteResource(&WriteJournalsResource);
}

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb)
{
    PFCB_WRITE_JOURNAL pJournal;

    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        pJournal = RxAllocatePoolWithTag(
                       PagedPool | POOL_COLD_ALLOCATION,
                       sizeof(FCB_WRITE_JOURNAL),
                       RX_MISC_POOLTAG);

        if (pJournal != NULL) {
            ULONG PathLength;

            RtlZeroMemory(
                pJournal,
                sizeof(FCB_WRITE_JOURNAL));

            pJournal->pName = &pJournal->Path[0];

            if (pFcb->AlreadyPrefixedName.Length > (MAX_PATH * sizeof(WCHAR))) {
                PathLength = MAX_PATH * sizeof(WCHAR);
            } else {
                PathLength = pFcb->AlreadyPrefixedName.Length;
            }

            RtlCopyMemory(
                pJournal->pName,
                pFcb->AlreadyPrefixedName.Buffer,
                PathLength);

            pJournal->pFcb = pFcb;

            pJournal->pWriteInitiationBitmap = pJournal->WriteInitiationBitmap;
            pJournal->pLowIoWriteInitiationBitmap = pJournal->LowIoWriteInitiationBitmap;
            pJournal->pLowIoWriteCompletionBitmap = pJournal->LowIoWriteCompletionBitmap;

            ExAcquireResourceExclusive(&WriteJournalsResource,TRUE);

            InsertHeadList(
                &ActiveWriteJournals,
                &pJournal->JournalsList);

            ExReleaseResource(&WriteJournalsResource);
        }
    }
}

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource,TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            RemoveEntryList(&pJournal->JournalsList);

//            InsertHeadList(
//                &OldWriteJournals,
//                &pJournal->JournalsList);

            RxFreePool(pJournal);
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource, TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            UpdateBitmap(
                pJournal->WriteInitiationBitmap,
                Offset,
                Length);

            pJournal->WritesInitiated++;
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {

        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource, TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            UpdateBitmap(
                pJournal->LowIoWriteInitiationBitmap,
                Offset,
                Length);

            pJournal->LowIoWritesInitiated++;
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length)
{
    PAGED_CODE();

    if (pFcb->pNetRoot->DeviceType == RxDeviceType(DISK)) {
        PFCB_WRITE_JOURNAL pJournal;
        PLIST_ENTRY        pJournalEntry;

        ExAcquireResourceExclusive(&WriteJournalsResource, TRUE);

        pJournal = RxdFindWriteJournal(pFcb);

        if (pJournal != NULL) {
            UpdateBitmap(
                pJournal->LowIoWriteCompletionBitmap,
                Offset,
                Length);

            pJournal->LowIoWritesCompleted++;
        }

        ExReleaseResource(&WriteJournalsResource);
    }
}

PFCB_WRITE_JOURNAL
RxdFindWriteJournal(
    PFCB pFcb)
{
    PFCB_WRITE_JOURNAL pJournal;
    PLIST_ENTRY pJournalEntry;

    PAGED_CODE();

    pJournalEntry = ActiveWriteJournals.Flink;
    while (pJournalEntry != &ActiveWriteJournals) {
        pJournal = (PFCB_WRITE_JOURNAL)
                   CONTAINING_RECORD(
                       pJournalEntry,
                       FCB_WRITE_JOURNAL,
                       JournalsList);

        if (pJournal->pFcb == pFcb) {
            break;
        } else {
            pJournalEntry = pJournalEntry->Flink;
        }
    }

    if (pJournalEntry == &ActiveWriteJournals) {
        pJournal = NULL;
    }

    return pJournal;
}

CHAR PageMask[8] = { 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};

VOID
UpdateBitmap(
    PBYTE           pBitmap,
    LARGE_INTEGER   Offset,
    ULONG           Length)
{
    LONG    OffsetIn4kChunks;
    LONG    OffsetIn32kChunks;
    LONG    NumberOf4kChunks,Starting4kChunk;

    PAGED_CODE();

    // Each byte in the bit map represents a 32k region since each bit represents
    // a 4k region in the file.
    // we ignore the offset's high part for now because the bitmap's max size is
    // far less than what can be accomodated in the low part.

    OffsetIn4kChunks  = Offset.LowPart / (0x1000);
    OffsetIn32kChunks = Offset.LowPart / (0x8000);

    Starting4kChunk = ((Offset.LowPart & ~0xfff) - (Offset.LowPart & ~0x7fff)) / 0x1000;
    NumberOf4kChunks = Length / 0x1000;

    if (NumberOf4kChunks > (8 - Starting4kChunk)) {
        pBitmap[OffsetIn32kChunks++] |= (PageMask[7] & ~PageMask[Starting4kChunk]);
        Length -= (8 - Starting4kChunk) * 0x1000;
    }

    if (Length > 0x8000) {
        while (Length > (0x8000)) {
            pBitmap[OffsetIn32kChunks++] = PageMask[7];
            Length -= (0x8000);
        }

        Starting4kChunk = 0;
    }

    // The final chunk is less then 32k. The byte in the bitmao needs to be
    // updated accordingly.

    if (Length > 0) {
        NumberOf4kChunks = Length / (0x1000);
        pBitmap[OffsetIn32kChunks] |= PageMask[NumberOf4kChunks + Starting4kChunk];
    }
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxce.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxce.c

Abstract:

    This module implements the RXCE routines related to binding/unbinding, dynamic
    enabling/disabling of transports.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

    The number of transport bindings are in all probability very few ( mostly one or two).

--*/

#include "precomp.h"
#pragma  hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCeBuildTransport)
#pragma alloc_text(PAGE, RxCeTearDownTransport)
#pragma alloc_text(PAGE, RxCeQueryAdapterStatus)
#pragma alloc_text(PAGE, RxCeQueryTransportInformation)
#pragma alloc_text(PAGE, DuplicateTransportAddress)
#pragma alloc_text(PAGE, RxCeBuildAddress)
#pragma alloc_text(PAGE, RxCeTearDownAddress)
#endif

//
//  The debug trace level
//

#define Dbg  (DEBUG_TRACE_RXCEBINDING)


NTSTATUS
RxCeBuildTransport(
    IN  OUT PRXCE_TRANSPORT pTransport,
    IN      PUNICODE_STRING pTransportName,
    IN      ULONG           QualityOfService)
/*++

Routine Description:

    This routine binds to the transport specified.

Arguments:


    pTransportName - the binding string for the desired transport

    QualityOfService - the quality of service desired from the transport.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

     The RDBSS or RXCE do not paticipate in the computation of quality
     of service. They essentially use it as a magic number that needs
     to be passed to the underlying transport provider.

     At present we ignore the QualityOfService parameter. How should a request for
     binding to a transport that has been currently bound to with a lower quality of
     service be handled?

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeBinding,RxCeBindToTransport);

    try {
        pTransport->Signature = RXCE_TRANSPORT_SIGNATURE;

        pTransport->ConnectionCount = 0;
        pTransport->VirtualCircuitCount = 0;
        pTransport->pDeviceObject = NULL;
        pTransport->ControlChannel = INVALID_HANDLE_VALUE;
        pTransport->pControlChannelFileObject = NULL;

        pTransport->Name.MaximumLength = pTransportName->Length;
        pTransport->Name.Length = pTransportName->Length;

        pTransport->pProviderInfo
            = RxAllocatePoolWithTag(
                  PagedPool,
                  sizeof(RXCE_TRANSPORT_PROVIDER_INFO),
                  RXCE_TRANSPORT_POOLTAG);


        pTransport->Name.Buffer = RxAllocatePoolWithTag(
                                      NonPagedPool,
                                      pTransport->Name.Length,
                                      RXCE_TRANSPORT_POOLTAG);

        if ((pTransport->pProviderInfo != NULL) &&
            (pTransport->Name.Buffer != NULL)) {
            RtlCopyMemory(
                pTransport->Name.Buffer,
                pTransportName->Buffer,
                pTransport->Name.Length);

            // Initialize the transport information.
            Status = RxTdiBindToTransport(
                         pTransport);

            // Ensure that the quality of service criterion is met.

            // Cleanup if the operation was not successfull.
            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg, ("RxTdiBindToTransport returned %lx\n",Status));
                RxCeTearDownTransport(pTransport);
            } else {
                pTransport->QualityOfService = QualityOfService;
            }
        } else {
            RxCeTearDownTransport(pTransport);

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeBindToTransport T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeBuildTransport,
                     LOGPTR(pTransport));
        }
    }

    return Status;
}

NTSTATUS
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine unbinds from the transport specified.

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

    if a transport that has not been bound to is specified no error is
    returned. The operation trivially succeeds.

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeBinding,RxCeUnbindFromTransport);

    try {
        if (RxCeIsTransportValid(pTransport)) {
            if (pTransport->pDeviceObject != NULL) {
                Status = RxTdiUnbindFromTransport(pTransport);
            }

            RxDbgTrace(0, Dbg,("RxTdiUnbindFromTransport returned %lx\n",Status));

            if (pTransport->Name.Buffer != NULL) {
                RxFreePool(pTransport->Name.Buffer);
            }

            if (pTransport->pProviderInfo != NULL ) {
                RxFreePool(pTransport->pProviderInfo);
            }

            pTransport->ConnectionCount = 0;
            pTransport->VirtualCircuitCount = 0;
            pTransport->pProviderInfo = NULL;
            pTransport->pDeviceObject = NULL;
            pTransport->ControlChannel = INVALID_HANDLE_VALUE;
            pTransport->pControlChannelFileObject = NULL;

            Status = STATUS_SUCCESS;
        }
    } finally {
        if (AbnormalTermination()) {
            RxLog(("RxCeTdT: T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeTearDownTransport,
                     LOGPTR(pTransport));
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT pTransport,
    PADAPTER_STATUS pAdapterStatus)
/*++

Routine Description:

    This routine returns the name of a given transport in a caller allocated buffer

Arguments:

    pTransport     - the RXCE_TRANSPORT instance

    pAdapterStatus - the adapter status of the transport

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PAGED_CODE();

    try {
        if (RxCeIsTransportValid(pTransport)) {
            Status = RxTdiQueryAdapterStatus(pTransport,pAdapterStatus);
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RXCeQAS: T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeQueryAdapterStatus,
                     LOGPTR(pTransport));
        }
    }

    return Status;
}

NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation)
/*++

Routine Description:

    This routine returns the transport information for a given transport

Arguments:

    pTransport            - the RXCE_TRANSPORT

    pTransportInformation - the information for the transport

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    PAGED_CODE();

    try {
        if (RxCeIsTransportValid(pTransport)) {
            pProviderInfo = (PRXCE_TRANSPORT_PROVIDER_INFO)pTransportInformation;

            *pProviderInfo = *(pTransport->pProviderInfo);
            pTransportInformation->ConnectionCount  = pTransport->ConnectionCount;
            pTransportInformation->QualityOfService = pTransport->QualityOfService;

            Status = STATUS_SUCCESS;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RXCeQTI: T: %lx\n",pTransport));
            RxWmiLog(LOG,
                     RxCeQueryTransportInformation,
                     LOGPTR(pTransport));
        }
    }

    return Status;
}

NTSTATUS
DuplicateTransportAddress(
    PTRANSPORT_ADDRESS *pCopy,
    PTRANSPORT_ADDRESS pOriginal,
    POOL_TYPE          PoolType)
/*++

Routine Description:

    This routine duplicates a transport addresses.

Arguments:

    pCopy  - the pointer to the new copy

    pOriginal - the original.

    PoolType - type of pool for memory allocation

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    ULONG Size = ComputeTransportAddressLength(pOriginal);

    PAGED_CODE();

    *pCopy = (PTRANSPORT_ADDRESS)
             RxAllocatePoolWithTag(
                 PoolType,
                 Size,
                 RXCE_TRANSPORT_POOLTAG);

    if (*pCopy != NULL) {

        RtlCopyMemory(*pCopy,pOriginal,Size);

        return STATUS_SUCCESS;
    } else
        return STATUS_INSUFFICIENT_RESOURCES;
}

NTSTATUS
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS               pAddress,
    IN     PRXCE_TRANSPORT             pTransport,
    IN     PTRANSPORT_ADDRESS          pTransportAddress,
    IN     PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN     PVOID                       pEventContext)
/*++

Routine Description:

    This routine associated a transport address with a transport binding.

Arguments:

    pAddress           - the address instance

    pTransport         - the transport with whihc this address is to be associated

    pTransportAddress  - the transport address to be associated with the binding

    pHandler           - the event handler associated with the registration.

    pEventContext      - the context parameter to be passed back to the event handler

Return Value:

    STATUS_SUCCESS if successfull.

Notes:

--*/
{
    NTSTATUS        Status       = STATUS_INVALID_PARAMETER;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeRegisterClientAddress);

    try {
        if (RxCeIsTransportValid(pTransport)) {
            pAddress->Signature = RXCE_ADDRESS_SIGNATURE;

            pAddress->pTransport = pTransport;
            pAddress->hAddress = INVALID_HANDLE_VALUE;
            pAddress->pFileObject = NULL;
            pAddress->pHandler = NULL;
            pAddress->pTransportAddress = NULL;
            pAddress->pReceiveMdl = NULL;

            // Allocate the mmeory for the event handling dispatch vector
            pAddress->pHandler = (PRXCE_ADDRESS_EVENT_HANDLER)
                                 RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(RXCE_ADDRESS_EVENT_HANDLER),
                                     RXCE_ADDRESS_POOLTAG);

            if (pAddress->pHandler != NULL) {
                RtlZeroMemory(
                    pAddress->pHandler,
                    sizeof(RXCE_ADDRESS_EVENT_HANDLER));

                // Duplicate the transport address for future searches
                Status = DuplicateTransportAddress(
                             &pAddress->pTransportAddress,
                             pTransportAddress,
                             PagedPool);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(Status)) {
                // Open the address w.r.t a transport provider
                Status = RxTdiOpenAddress(
                             pTransport,
                             pTransportAddress,
                             pAddress);

                if (NT_SUCCESS(Status)) {
                    // Initialize the handler and the associated context
                    if (pHandler != NULL) {
                        *(pAddress->pHandler) = *pHandler;
                        pAddress->pContext = pEventContext;
                    }
                } else {
                    RxCeTearDownAddress(pAddress);
                    RxDbgTrace(0, Dbg,("RxTdiOpenAddress returned %lx\n",Status));
                }
            } else {
                RxDbgTrace(0, Dbg,("RxCeOpenAddress returned %lx\n",Status));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
            RxLog(("RxCeBA: T: %lx A: %lx\n",pTransport,pAddress));
            RxWmiLog(LOG,
                     RxCeBuildAddress,
                     LOGPTR(pTransport)
                     LOGPTR(pAddress));
        }
    }

    return Status;
}

NTSTATUS
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress)
/*++

Routine Description:

    This routine deregisters a transport address from a transport binding

Arguments:

    pAddress - the RxCe address denoting the transport binding/Transport address
               tuple.

Return Value:

    STATUS_SUCCESS if successful.

Notes:

--*/
{
    NTSTATUS        Status = STATUS_INVALID_PARAMETER;
    PRXCE_TRANSPORT pTransport;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeManagement,RxCeDeregisterClientAddress);

    try {
        pTransport = pAddress->pTransport;

        if (RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {
            // close the address object.

            if (pAddress->hAddress != INVALID_HANDLE_VALUE) {
                Status = RxTdiCloseAddress(pAddress);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg,("RxTdiCloseAddress returned %lx\n",Status));
                }
            }

            if (pAddress->pHandler != NULL) {
                RxFreePool(pAddress->pHandler);
            }

            if (pAddress->pTransportAddress != NULL) {
                RxFreePool(pAddress->pTransportAddress);
            }

            pAddress->pTransport = pTransport;
            pAddress->hAddress = INVALID_HANDLE_VALUE;
            pAddress->pFileObject = NULL;
            pAddress->pHandler = NULL;
            pAddress->pTransportAddress = NULL;
            pAddress->pReceiveMdl = NULL;
        }
    } finally {
        if (AbnormalTermination()) {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

   return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxcexmit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcexmit.c

Abstract:

    This module implements the data transmission routines along a connection as well as
    datagram transmissions

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCeSend)
#pragma alloc_text(PAGE, RxCeSendDatagram)
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCEXMIT)


NTSTATUS
RxCeSend(
    IN PRXCE_VC pVc,
    IN ULONG    SendOptions,
    IN PMDL     pMdl,
    IN ULONG    SendLength,
    IN PVOID    pCompletionContext)
/*++

Routine Description:

    This routine sends a TSDU along the specified connection.

Arguments:

    hConnection - the connection on which the TSDU is to be sent

    hVc         - the virtual circuit Id. along which the TSDU is to be sent

    SendOptions - the options for the send operation

    pMdl        - the buffer to be sent.

    SendLength  - length of data to be sent

    pCompletionContext - the context passed back to the caller during SendCompletion

Return Value:

    STATUS_SUCCESS if successfull

Notes:

--*/
{
    NTSTATUS Status;

    PRXCE_TRANSPORT  pTransport = NULL;
    PRXCE_ADDRESS    pAddress = NULL;
    PRXCE_CONNECTION pConnection = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeXmit,RxCeSend);

    try {
        Status = STATUS_CONNECTION_DISCONNECTED;

        // reference the objects
        pConnection = pVc->pConnection;
        pAddress    = pConnection->pAddress;
        pTransport  = pAddress->pTransport;

        if (RxCeIsVcValid(pVc) &&
            RxCeIsConnectionValid(pConnection) &&
            RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {

            if (pVc->State == RXCE_VC_ACTIVE) {
                Status = RxTdiSend(
                             pTransport,
                             pAddress,
                             pConnection,
                             pVc,
                             SendOptions,
                             pMdl,
                             SendLength,
                             pCompletionContext);
            }

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg,("RxTdiSend returned %lx\n",Status));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            RxLog(("RxCeSend: T: %lx A: %lx C: %lx VC: %lx\n",pTransport,pAddress,pConnection,pVc));
            RxWmiLog(LOG,
                     RxCeSend,
                     LOGPTR(pTransport)
                     LOGPTR(pAddress)
                     LOGPTR(pConnection)
                     LOGPTR(pVc));
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    return Status;
}

NTSTATUS
RxCeSendDatagram(
    IN PRXCE_ADDRESS                pAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext)
/*++

Routine Description:

    This routine sends a TSDU to a specified transport address.

Arguments:

    pLocalAddress  - the local address

    pConnectionInformation - the remote address

    SendOptions    - the options for the send operation

    pMdl           - the buffer to be sent.

    SendLength     - length of data to be sent

    pCompletionContext - the context passed back to the caller during Send completion.

Return Value:

    STATUS_SUCCESS if successfull

Notes:

--*/
{
    NTSTATUS Status;

    PRXCE_TRANSPORT  pTransport = NULL;

    PAGED_CODE();

    // Update profiling info.
    RxProfile(RxCeXmit,RxCeSendDatagram);

    try {
        Status = STATUS_CONNECTION_DISCONNECTED;

        pTransport = pAddress->pTransport;

        if (RxCeIsAddressValid(pAddress) &&
            RxCeIsTransportValid(pTransport)) {
            Status = RxTdiSendDatagram(
                         pTransport,
                         pAddress,
                         pConnectionInformation,
                         SendOptions,
                         pMdl,
                         SendLength,
                         pCompletionContext);

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg,("RxTdiSendDatagram returned %lx\n",Status));
            }
        }
    } finally {
        if (AbnormalTermination()) {
            RxLog(("RxCeSendDg: T: %lx A: %lx\n",pTransport,pAddress));
            RxWmiLog(LOG,
                     RxCeSendDatagram,
                     LOGPTR(pTransport)
                     LOGPTR(pAddress));
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxconnct.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxConnct.c

Abstract:

    This module implements the nt version of the high level routines dealing with
    connections including both the routines for establishing connections and the
    winnet connection apis.

Author:

    Joe Linn     [JoeLinn]   1-mar-95

Revision History:

    Balan Sethu Raman [SethuR] --

--*/

#include "precomp.h"
#pragma hdrstop
#include "prefix.h"
#include "secext.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxExtractServerName)
#pragma alloc_text(PAGE, RxFindOrCreateConnections)
#pragma alloc_text(PAGE, RxCreateNetRootCallBack)
#pragma alloc_text(PAGE, RxConstructSrvCall)
#pragma alloc_text(PAGE, RxConstructNetRoot)
#pragma alloc_text(PAGE, RxConstructVirtualNetRoot)
#pragma alloc_text(PAGE, RxFindOrConstructVirtualNetRoot)
#endif

//
//  The local trace mask for this part of the module
//

#define Dbg                              (DEBUG_TRACE_CONNECT)


BOOLEAN RxSrvCallConstructionDispatcherActive = FALSE;

//
//  Internal helper functions for establishing connections through mini redirectors
//

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT Context
    );

VOID
RxCreateSrvCallCallBack (
    IN PMRX_SRVCALL_CALLBACK_CONTEXT Context
    );

VOID
RxExtractServerName (
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into the srv call name and the
    rest. any of the output can be null

Arguments:

    FilePathName -- the given file name

    SrvCallName  -- the srv call name

    RestOfName   -- the remaining portion of the name

--*/
{
    ULONG Length = FilePathName->Length;
    PWCH Buffer = FilePathName->Buffer;
    PWCH Limit = (PWCH)Add2Ptr( Buffer, Length );
    
    PAGED_CODE();

    ASSERT( SrvCallName );

    
    for (SrvCallName->Buffer = Buffer; 
         (Buffer < Limit) && ((*Buffer != OBJ_NAME_PATH_SEPARATOR) || (Buffer == FilePathName->Buffer));  
         Buffer++) {
    }
    
    SrvCallName->Length = SrvCallName->MaximumLength = (USHORT)((PCHAR)Buffer - (PCHAR)FilePathName->Buffer);

    if (ARGUMENT_PRESENT( RestOfName )) {
         
        RestOfName->Buffer = Buffer;
        RestOfName->Length = RestOfName->MaximumLength
                           = (USHORT)((PCHAR)Limit - (PCHAR)Buffer);
    }

    RxDbgTrace( 0, Dbg, ("  RxExtractServerName FilePath=%wZ\n", FilePathName) );
    RxDbgTrace( 0, Dbg, ("         Srv=%wZ,Rest=%wZ\n", SrvCallName, RestOfName) );

    return;
}

NTSTATUS
RxFindOrCreateConnections (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PUNICODE_STRING LocalNetRootName,
    OUT PUNICODE_STRING FilePathName,
    IN OUT PLOCK_HOLDING_STATE LockState,
    IN PRX_CONNECTION_ID RxConnectionId
    )
/*++

Routine Description:

    This routine handles the call down from the MUP to claim a name or from the
    create path. If we don't find the name in the netname table, we pass the name
    down to the minirdrs to be connected. in the few places where it matters, we use
    the majorcode to distinguish between in MUP and create cases. there are a million
    cases depending on what we find on the initial lookup.

    these are the cases:

          found nothing                                        (1)
          found intransition srvcall                           (2)
          found stable/nongood srvcall                         (3)
          found good srvcall                                   (4&0)
          found good netroot          on good srvcall          (0)
          found intransition netroot  on good srvcall          (5)
          found bad netroot           on good srvcall          (6)
          found good netroot          on bad  srvcall          (3)
          found intransition netroot  on bad  srvcall          (3)
          found bad netroot           on bad  srvcall          (3)
          found good netroot          on intransition srvcall  (2)
          found intransition netroot  on intransition srvcall  (2)
          found bad netroot           on intransition srvcall  (2)

          (x) means that the code to handle that case has a marker
          like "case (x)". could be a comment....could be a debugout.

Arguments:

        RxContext         --
    
        CanonicalName     --
    
        NetRootType       --
    
        LocalNetRootName  --
    
        FilePathName      --
    
        LockHoldingState  --

Return Value:

    RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    UNICODE_STRING UnmatchedName;

    PVOID Container = NULL;
    PSRV_CALL SrvCall = NULL;
    PNET_ROOT NetRoot = NULL;
    PV_NET_ROOT VNetRoot = NULL;

    PRX_PREFIX_TABLE NameTable = RxContext->RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxFindOrCreateConnections -> %08lx\n", RxContext));

    //
    //  Parse the canonical name into the local net root name and file path name
    //

    *FilePathName = *CanonicalName;
    LocalNetRootName->Length = 0;
    LocalNetRootName->MaximumLength = 0;
    LocalNetRootName->Buffer = CanonicalName->Buffer;

    if (FilePathName->Buffer[1] == L';') {
        
        PWCHAR FilePath = &FilePathName->Buffer[2];
        BOOLEAN SeparatorFound = FALSE;
        ULONG PathLength = 0;

        if (FilePathName->Length > sizeof( WCHAR ) * 2) {
            PathLength = FilePathName->Length - sizeof( WCHAR ) * 2;
        }

        while (PathLength > 0) {
            if (*FilePath == L'\\') {
                SeparatorFound = TRUE;
                break;
            }

            PathLength -= sizeof( WCHAR );
            FilePath += 1;
        }

        if (!SeparatorFound) {
            return STATUS_OBJECT_NAME_INVALID;
        }

        FilePathName->Buffer = FilePath;
        LocalNetRootName->Length = (USHORT)((PCHAR)FilePath - (PCHAR)CanonicalName->Buffer);

        LocalNetRootName->MaximumLength = LocalNetRootName->Length;
        FilePathName->Length -= LocalNetRootName->Length;
    }

    RxDbgTrace( 0, Dbg, ("RxFindOrCreateConnections Path     = %wZ\n", FilePathName) );

    try {
        
        UNICODE_STRING SrvCallName;
        UNICODE_STRING NetRootName;

  RETRY_LOOKUP:
        
        ASSERT( *LockState != LHS_LockNotHeld );
  
        if (Container != NULL) {

            //
            //  This is the subsequent pass of a lookup after waiting for the transition
            //  to the stable state of a previous lookup.
            //  Dereference the result of the earlier lookup.
            //
            
            switch (NodeType( Container )) {
            
            case RDBSS_NTC_V_NETROOT:
            
                RxDereferenceVNetRoot( (PV_NET_ROOT)Container, *LockState );
                break;
            
            case RDBSS_NTC_SRVCALL:
                
                RxDereferenceSrvCall( (PSRV_CALL)Container, *LockState );
                break;
            
            case RDBSS_NTC_NETROOT:
            
                RxDereferenceNetRoot( (PNET_ROOT)Container, *LockState );
                break;
            
            default:
                
                DbgPrint( "RxFindOrCreateConnections -- Invalid Container Type\n" );
                break;
            }
        }

        Container = RxPrefixTableLookupName( NameTable,
                                             FilePathName,
                                             &UnmatchedName,
                                             RxConnectionId );
        RxLog(( "FOrCC1 %x %x %wZ \n", RxContext, Container, FilePathName ));
        RxWmiLog( LOG,
                  RxFindOrCreateConnections_1,
                  LOGPTR( RxContext )
                  LOGPTR( Container )
                  LOGUSTR( *FilePathName ) );

RETRY_AFTER_LOOKUP:
        
        NetRoot = NULL;
        SrvCall = NULL;
        VNetRoot = NULL;

        RxContext->Create.pVNetRoot = NULL;
        RxContext->Create.pNetRoot  = NULL;
        RxContext->Create.pSrvCall  = NULL;
        RxContext->Create.Type     = NetRootType;

        if (Container) {
            
            if (NodeType( Container ) == RDBSS_NTC_V_NETROOT) {
                
                VNetRoot = (PV_NET_ROOT)Container;
                NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
                SrvCall = (PSRV_CALL)NetRoot->SrvCall;

                if (NetRoot->Condition == Condition_InTransition) {
                   
                    RxReleasePrefixTableLock( NameTable );
                    RxWaitForStableNetRoot( NetRoot, RxContext );

                    RxAcquirePrefixTableLockExclusive( NameTable, TRUE );
                    *LockState = LHS_ExclusiveLockHeld;

                    //
                    //  Since we had to drop the table lock and reacquire it,
                    //  our NetRoot pointer may be stale.  Look it up again before
                    //  using it.
                    //
                    //  NOTE:  The NetRoot is still referenced, so it is safe to
                    //         look at its condition.
                    //
                    
                    if (NetRoot->Condition == Condition_Good) {
                        goto RETRY_LOOKUP;
                    }
                }

                if ((NetRoot->Condition == Condition_Good) &&
                    (SrvCall->Condition == Condition_Good) &&
                    (SrvCall->RxDeviceObject == RxContext->RxDeviceObject)   ) {

                    //
                    //  case (0)...the good case...see comments below
                    //

                    RxContext->Create.pVNetRoot = (PMRX_V_NET_ROOT)VNetRoot;
                    RxContext->Create.pNetRoot = (PMRX_NET_ROOT)NetRoot;
                    RxContext->Create.pSrvCall = (PMRX_SRV_CALL)SrvCall;

                    try_return( Status = STATUS_CONNECTION_ACTIVE );
                
                } else {
                    
                    if (VNetRoot->ConstructionStatus == STATUS_SUCCESS) {
                        Status = STATUS_BAD_NETWORK_PATH;
                    } else {
                        Status = VNetRoot->ConstructionStatus;
                    }
                    RxDereferenceVNetRoot( VNetRoot, *LockState );
                    try_return ( Status );
                }
            } else {
                
                ASSERT( NodeType( Container ) == RDBSS_NTC_SRVCALL );
                SrvCall = (PSRV_CALL)Container;

                //
                //  The associated SRV_CALL is in the process of construction.
                //  await the result.
                //


                if (SrvCall->Condition == Condition_InTransition) {
                    
                    RxDbgTrace( 0, Dbg, ("   Case(3)\n", 0) );
                    RxReleasePrefixTableLock( NameTable );

                    RxWaitForStableSrvCall( SrvCall, RxContext );

                    RxAcquirePrefixTableLockExclusive( NameTable, TRUE );
                    *LockState = LHS_ExclusiveLockHeld;

                    if (SrvCall->Condition == Condition_Good) {
                       goto RETRY_LOOKUP;
                    }
                }

                if (SrvCall->Condition != Condition_Good) {
                    
                    if (SrvCall->Status == STATUS_SUCCESS) {
                        Status = STATUS_BAD_NETWORK_PATH;
                    } else {
                        Status = SrvCall->Status;
                    }

                    //
                    //  in changing this...remember precious servers.......
                    //  
                    RxDereferenceSrvCall( SrvCall, *LockState );
                    try_return( Status );
                }
            }
        }

        if ((SrvCall != NULL) && 
            (SrvCall->Condition == Condition_Good) && 
            (SrvCall->RxDeviceObject != RxContext->RxDeviceObject) ) {
           
            RxDereferenceSrvCall( SrvCall, *LockState );
            try_return( Status = STATUS_BAD_NETWORK_NAME );
        }

        if (*LockState == LHS_SharedLockHeld) {

            //
            // Upgrade the lock to an exclusive lock
            //

            if (!RxAcquirePrefixTableLockExclusive( NameTable, FALSE )) {
              
                RxReleasePrefixTableLock( NameTable );
                RxAcquirePrefixTableLockExclusive( NameTable, TRUE );
                *LockState = LHS_ExclusiveLockHeld;
                
                goto RETRY_LOOKUP;
           } else {
                *LockState = LHS_ExclusiveLockHeld;
           }
        }

        ASSERT( *LockState == LHS_ExclusiveLockHeld );

        //
        //  A prefix table entry was found. Further construction is required
        //  if either a SRV_CALL was found or a SRV_CALL/NET_ROOT/V_NET_ROOT
        //  in a bad state was found.
        //
        
        if (Container) {
           
            RxDbgTrace( 0, Dbg, ("   SrvCall=%08lx\n", SrvCall) );
            ASSERT( (NodeType( SrvCall ) == RDBSS_NTC_SRVCALL) &&
                    (SrvCall->Condition == Condition_Good) );
            ASSERT( (NetRoot == NULL) && (VNetRoot == NULL) );

            RxDbgTrace( 0, Dbg, ("   Case(4)\n", 0) );
            ASSERT( SrvCall->RxDeviceObject == RxContext->RxDeviceObject );
           
            SrvCall->RxDeviceObject->Dispatch->MRxExtractNetRootName( FilePathName,
                                                                      (PMRX_SRV_CALL)SrvCall,
                                                                      &NetRootName,
                                                                      NULL );

            NetRoot = RxCreateNetRoot( SrvCall,
                                       &NetRootName,
                                       0,
                                       RxConnectionId );

            if (NetRoot == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                try_return( Status );
            }

            NetRoot->Type = NetRootType;

            //
            //  Decrement the reference created by lookup. Since the newly created
            //  netroot holds onto a reference it is safe to do so.
            //
           
            RxDereferenceSrvCall( SrvCall, *LockState );

            //
            //  Also create the associated default virtual net root
            //

            VNetRoot = RxCreateVNetRoot( RxContext,
                                         NetRoot,
                                         CanonicalName,
                                         LocalNetRootName,
                                         FilePathName,
                                         RxConnectionId );

            if (VNetRoot == NULL) {
                RxFinalizeNetRoot( NetRoot, TRUE, TRUE );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                try_return( Status );
            }

            //
            //  Reference the VNetRoot
            //
           
            RxReferenceVNetRoot( VNetRoot );

            NetRoot->Condition = Condition_InTransition;

            RxContext->Create.pSrvCall  = (PMRX_SRV_CALL)SrvCall;
            RxContext->Create.pNetRoot  = (PMRX_NET_ROOT)NetRoot;
            RxContext->Create.pVNetRoot = (PMRX_V_NET_ROOT)VNetRoot;
            
            Status = RxConstructNetRoot( RxContext,
                                         SrvCall,
                                         NetRoot,
                                         VNetRoot,
                                         LockState );
            
            if (Status == STATUS_SUCCESS) {
              
                ASSERT( *LockState == LHS_ExclusiveLockHeld );
              
                if (!TreeConnect) {
                 
                    //
                    //  do not release the lock acquired by the callback routine ....
                    //
                    
                    RxExclusivePrefixTableLockToShared( NameTable );
                    *LockState = LHS_SharedLockHeld;
                }
            } else {

                //
                //  Dereference the Virtual net root
                //
              
                RxTransitionVNetRoot( VNetRoot, Condition_Bad );
                RxLog(( "FOrCC %x %x Failed %x VNRc %d \n", RxContext, VNetRoot, Status, VNetRoot->Condition ));
                RxWmiLog( LOG,
                          RxFindOrCreateConnections_2,
                          LOGPTR( RxContext )
                          LOGPTR( VNetRoot )
                          LOGULONG( Status )
                          LOGULONG( VNetRoot->Condition ) );
            
                RxDereferenceVNetRoot( VNetRoot, *LockState );
            
                RxContext->Create.pNetRoot = NULL;
                RxContext->Create.pVNetRoot = NULL;
            }
            
            try_return( Status );
        }

        //
        //  No prefix table entry was found. A new SRV_CALL instance needs to be
        //  constructed.
        //

        ASSERT( Container == NULL );

        RxExtractServerName( FilePathName, &SrvCallName, NULL );
        SrvCall = RxCreateSrvCall( RxContext, &SrvCallName, NULL, RxConnectionId );
        if (SrvCall == NULL) {
           
            Status = STATUS_INSUFFICIENT_RESOURCES;
            try_return( Status );
        }

        RxReferenceSrvCall( SrvCall );

        RxContext->Create.Type = NetRootType;
        RxContext->Create.pSrvCall = NULL;
        RxContext->Create.pNetRoot = NULL;
        RxContext->Create.pVNetRoot = NULL;

        Status = RxConstructSrvCall( RxContext,
                                     Irp,
                                     SrvCall,
                                     LockState );

        ASSERT( (Status != STATUS_SUCCESS) || RxIsPrefixTableLockAcquired( NameTable ) );

        if (Status != STATUS_SUCCESS) {
            
            if (SrvCall != NULL) {
                
                RxAcquirePrefixTableLockExclusive( NameTable, TRUE );
                RxDereferenceSrvCall( SrvCall, LHS_ExclusiveLockHeld );
                RxReleasePrefixTableLock( NameTable );               
            }

           try_return( Status );
        
        } else {
           
            Container = SrvCall;
            goto RETRY_AFTER_LOOKUP;

        }

try_exit: NOTHING;

    } finally {
        if ((Status != (STATUS_SUCCESS)) &&
            (Status != (STATUS_CONNECTION_ACTIVE))) {
           
            if (*LockState != LHS_LockNotHeld) {
                RxReleasePrefixTableLock( NameTable );
                *LockState = LHS_LockNotHeld;
            }
        }
    }

    ASSERT( (Status != STATUS_SUCCESS) || RxIsPrefixTableLockAcquired( NameTable ) );

    return Status;
}

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT Context
    )
/*++

Routine Description:

    This routine gets called when the minirdr has finished processing on
    a CreateNetRoot calldown. It's exact function depends on whether the context
    describes IRP_MJ_CREATE or an IRP_MJ_IOCTL.

Arguments:

    NetRoot   - describes the Net_Root.

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("RxCreateNetRootCallBack Context = %08lx\n", Context) );
    KeSetEvent( &Context->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
}


NTSTATUS
RxFinishSrvCallConstruction (
    IN OUT PMRX_SRVCALLDOWN_STRUCTURE CalldownStructure
    )
/*++

Routine Description:

    This routine completes the construction of the srv call instance in an
    asynchronous manner

Arguments:

   SCCBC -- Call back structure

--*/
{
    PRX_CONTEXT RxContext;
    RX_BLOCK_CONDITION SrvCallCondition;
    NTSTATUS Status;
    PSRV_CALL SrvCall;
    PRX_PREFIX_TABLE NameTable;

    RxContext = CalldownStructure->RxContext;
    NameTable = RxContext->RxDeviceObject->pRxNetNameTable;
    SrvCall = (PSRV_CALL)CalldownStructure->SrvCall;

    if (CalldownStructure->BestFinisher == NULL) {
        
        SrvCallCondition = Condition_Bad;
        Status = CalldownStructure->CallbackContexts[0].Status;

    } else {
        
        PMRX_SRVCALL_CALLBACK_CONTEXT CallbackContext;

        //
        //  Notify the Winner
        //

        CallbackContext = &(CalldownStructure->CallbackContexts[CalldownStructure->BestFinisherOrdinal]);
        
        RxLog(( "WINNER %x %wZ\n", CallbackContext, &CalldownStructure->BestFinisher->DeviceName) );
        RxWmiLog( LOG,
                  RxFinishSrvCallConstruction,
                  LOGPTR( CallbackContext )
                  LOGUSTR( CalldownStructure->BestFinisher->DeviceName ) );
        ASSERT( SrvCall->RxDeviceObject == CalldownStructure->BestFinisher );
        
        MINIRDR_CALL_THROUGH( Status,
                              CalldownStructure->BestFinisher->Dispatch,
                              MRxSrvCallWinnerNotify,
                              ((PMRX_SRV_CALL)SrvCall,
                               TRUE,
                               CallbackContext->RecommunicateContext) );

        if (STATUS_SUCCESS != Status) {
            SrvCallCondition = Condition_Bad;
        } else {
            SrvCallCondition = Condition_Good;
        }
    }

    //
    //  Transition the SrvCall instance ...
    //

    RxAcquirePrefixTableLockExclusive( NameTable, TRUE );

    RxTransitionSrvCall( SrvCall, SrvCallCondition );

    RxFreePool( CalldownStructure );

    if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
        
        RxReleasePrefixTableLock( NameTable );

        //
        //  Resume the request that triggered the construction of the SrvCall ...
        //

        if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {
            Status = STATUS_CANCELLED;
        }

        if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            RxpPrepareCreateContextForReuse( RxContext );
        }

        if (Status == STATUS_SUCCESS) {
            Status = RxContext->ResumeRoutine( RxContext, RxContext->CurrentIrp );

            if (Status != STATUS_PENDING) {
                RxCompleteRequest( RxContext, Status );
            }
        } else {

            PIRP Irp = RxContext->CurrentIrp;
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
            
            RxContext->MajorFunction = IrpSp->MajorFunction;

            if (RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
                
                if (RxContext->PrefixClaim.SuppliedPathName.Buffer != NULL) {

                    RxFreePool( RxContext->PrefixClaim.SuppliedPathName.Buffer );
                    RxContext->PrefixClaim.SuppliedPathName.Buffer = NULL;

                }
            }

            Irp->IoStatus.Status = Status;
            Irp->IoStatus.Information = 0;

            RxCompleteRequest( RxContext, Status );
        }
    }

    RxDereferenceSrvCall( SrvCall, LHS_LockNotHeld );

    return Status;
}

VOID
RxFinishSrvCallConstructionDispatcher (
    PVOID Context
    )
/*++

Routine Description:

    This routine provides us with a throttling mechanism for controlling
    the number of threads that can be consumed by srv call construction in the
    thread pool. Currently this limit is set at 1.
    gets called when a minirdr has finished processing on

--*/
{
    KIRQL SavedIrql;
    BOOLEAN RemainingRequestsForProcessing;
    BOOLEAN ResumeRequestsOnDispatchError;

    ResumeRequestsOnDispatchError = (Context == NULL);

    for (;;) {
        PLIST_ENTRY Entry;
        PMRX_SRVCALLDOWN_STRUCTURE CalldownStructure;

        KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

        Entry = RemoveHeadList( &RxSrvCalldownList );

        if (Entry != &RxSrvCalldownList) {
            RemainingRequestsForProcessing = TRUE;
        } else {
            RemainingRequestsForProcessing = FALSE;
            RxSrvCallConstructionDispatcherActive = FALSE;
        }

        KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

        if (!RemainingRequestsForProcessing) {
            break;
        }

        CalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE) CONTAINING_RECORD( Entry, MRX_SRVCALLDOWN_STRUCTURE, SrvCalldownList );

        if (ResumeRequestsOnDispatchError) {
            CalldownStructure->BestFinisher = NULL;
        }

        RxFinishSrvCallConstruction( CalldownStructure );
    }
}

VOID
RxCreateSrvCallCallBack (
    IN PMRX_SRVCALL_CALLBACK_CONTEXT CallbackContext
    )
/*++

Routine Description:

    This routine gets called when a minirdr has finished processing on
    a CreateSrvCall calldown. The minirdr will have set the status in the passed
    context to indicate success or failure. what we have to do is
       1) decrease the number of outstanding requests and set the event
          if this is the last one.
       2) determine whether this guy is the winner of the call.

   the minirdr must get the strucsupspinlock in order to call this routine; this routine
   must NOT be called if the minirdr's call was successfully canceled.


Arguments:

   CallbackContext -- Call back structure

--*/
{
    KIRQL SavedIrql;
    PMRX_SRVCALLDOWN_STRUCTURE CalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(CallbackContext->SrvCalldownStructure);
    PSRV_CALL SrvCall = (PSRV_CALL)CalldownStructure->SrvCall;

    ULONG MiniRedirectorsRemaining;
    BOOLEAN Cancelled;

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    RxDbgTrace(0, Dbg, ("  RxCreateSrvCallCallBack SrvCall = %08lx\n", SrvCall) );

    if (CallbackContext->Status == STATUS_SUCCESS) {
        CalldownStructure->BestFinisher = CallbackContext->RxDeviceObject;
        CalldownStructure->BestFinisherOrdinal = CallbackContext->CallbackContextOrdinal;
    }

    CalldownStructure->NumberRemaining -= 1;
    MiniRedirectorsRemaining = CalldownStructure->NumberRemaining;
    SrvCall->Status = CallbackContext->Status;

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (MiniRedirectorsRemaining == 0) {
        
        if (!FlagOn( CalldownStructure->RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
            
            KeSetEvent( &CalldownStructure->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
        
        } else if (FlagOn( CalldownStructure->RxContext->Flags, RX_CONTEXT_FLAG_CREATE_MAILSLOT )) {
            
            RxFinishSrvCallConstruction( CalldownStructure );

        } else {
            
            KIRQL SavedIrql;
            BOOLEAN DispatchRequest;

            KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

            InsertTailList( &RxSrvCalldownList, &CalldownStructure->SrvCalldownList );

            DispatchRequest = !RxSrvCallConstructionDispatcherActive;

            if (!RxSrvCallConstructionDispatcherActive) {
                RxSrvCallConstructionDispatcherActive = TRUE;
            }

            KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

            if (DispatchRequest) {
                NTSTATUS DispatchStatus;
                
                DispatchStatus = RxDispatchToWorkerThread( RxFileSystemDeviceObject,
                                                           CriticalWorkQueue,
                                                           RxFinishSrvCallConstructionDispatcher,
                                                           &RxSrvCalldownList );

                if (DispatchStatus != STATUS_SUCCESS) {
                    RxFinishSrvCallConstructionDispatcher( NULL );
                }
            }
        }
    }
}


NTSTATUS
RxConstructSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PSRV_CALL SrvCall,
    OUT PLOCK_HOLDING_STATE LockState
    )
/*++

Routine Description:

    This routine constructs a srv call by invoking the registered mini redirectors

Arguments:

    SrvCall -- the server call whose construction is to be completed

    LockState -- the prefix table lock holding status

Return Value:

    the appropriate status value

--*/
{
    NTSTATUS Status;

    PMRX_SRVCALLDOWN_STRUCTURE CalldownCtx;
    BOOLEAN Wait;

    PMRX_SRVCALL_CALLBACK_CONTEXT CallbackCtx;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;
    PRX_PREFIX_TABLE NameTable = RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    ASSERT( *LockState == LHS_ExclusiveLockHeld );

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION )) {
        Wait = TRUE;
    } else {
        Wait = FALSE;
    }

    CalldownCtx = RxAllocatePoolWithTag( NonPagedPool, 
                                         sizeof( MRX_SRVCALLDOWN_STRUCTURE ) + (sizeof(MRX_SRVCALL_CALLBACK_CONTEXT) * 1), //  one minirdr in this call
                                         'CSxR' );

    if (CalldownCtx == NULL) {
        
        SrvCall->Condition = Condition_Bad;
        SrvCall->Context = NULL;
        RxReleasePrefixTableLock( NameTable );
        *LockState = LHS_LockNotHeld;

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( CalldownCtx, sizeof( MRX_SRVCALLDOWN_STRUCTURE ) + sizeof( MRX_SRVCALL_CALLBACK_CONTEXT ) * 1 );

    SrvCall->Condition = Condition_InTransition;
    SrvCall->Context = NULL;

    //
    //  Drop the prefix table lock before calling the mini redirectors.
    //

    RxReleasePrefixTableLock( NameTable );
    *LockState = LHS_LockNotHeld;
    
    //
    //  use the first and only context
    //

    CallbackCtx = &(CalldownCtx->CallbackContexts[0]); 
    RxLog(( "Calldwn %lx %wZ", CallbackCtx, &RxDeviceObject->DeviceName ));
    RxWmiLog( LOG,
              RxConstructSrvCall,
              LOGPTR( CallbackCtx )
              LOGUSTR( RxDeviceObject->DeviceName ) );

    CallbackCtx->SrvCalldownStructure = CalldownCtx;
    CallbackCtx->CallbackContextOrdinal = 0;
    CallbackCtx->RxDeviceObject = RxDeviceObject;

    //
    //  This reference is taken away by the RxFinishSrvCallConstruction routine.
    //  This reference enables us to deal with synchronous/asynchronous processing
    //  of srv call construction requests in an identical manner.
    //

    RxReferenceSrvCall( SrvCall );
    
    if (!Wait) {
        RxPrePostIrp( RxContext, Irp );
    } else {
        KeInitializeEvent( &CalldownCtx->FinishEvent, SynchronizationEvent, FALSE );
    }
    
    CalldownCtx->NumberToWait = 1;
    CalldownCtx->NumberRemaining = CalldownCtx->NumberToWait;
    CalldownCtx->SrvCall = (PMRX_SRV_CALL)SrvCall;
    CalldownCtx->CallBack = RxCreateSrvCallCallBack;
    CalldownCtx->BestFinisher = NULL;
    CalldownCtx->RxContext = RxContext;
    CallbackCtx->Status = STATUS_BAD_NETWORK_PATH;
    
    InitializeListHead( &CalldownCtx->SrvCalldownList );
    
    MINIRDR_CALL_THROUGH( Status,
                          RxDeviceObject->Dispatch,
                          MRxCreateSrvCall,
                          ((PMRX_SRV_CALL)SrvCall, CallbackCtx) );
    ASSERT( Status == STATUS_PENDING );
    
    if (Wait) {
        
        KeWaitForSingleObject( &CalldownCtx->FinishEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    
        Status = RxFinishSrvCallConstruction( CalldownCtx );
    
        if (Status != STATUS_SUCCESS) {
            RxReleasePrefixTableLock( NameTable );
            *LockState = LHS_LockNotHeld;
        } else {
            ASSERT( RxIsPrefixTableLockAcquired( NameTable ) );
            *LockState = LHS_ExclusiveLockHeld;
        }
    } else {
       Status = STATUS_PENDING;
    }
    
    return Status;
}

NTSTATUS
RxConstructNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PSRV_CALL SrvCall,
    IN PNET_ROOT NetRoot,
    IN PV_NET_ROOT VNetRoot,
    OUT PLOCK_HOLDING_STATE LockState
    )
/*++

Routine Description:

    This routine constructs a net root by invoking the registered mini redirectors

Arguments:

    RxContext         -- the RDBSS context

    SrvCall          -- the server call associated with the net root

    NetRoot          -- the net root instance to be constructed

    pVirtualNetRoot   -- the virtual net root instance to be constructed

    LockState -- the prefix table lock holding status

Return Value:

    the appropriate status value

--*/
{
    NTSTATUS Status;

    PMRX_CREATENETROOT_CONTEXT Context;

    RX_BLOCK_CONDITION NetRootCondition = Condition_Bad;
    RX_BLOCK_CONDITION VNetRootCondition = Condition_Bad;

    PRX_PREFIX_TABLE  NameTable = RxContext->RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    ASSERT( *LockState == LHS_ExclusiveLockHeld );

    Context = (PMRX_CREATENETROOT_CONTEXT) RxAllocatePoolWithTag( NonPagedPool, 
                                                                  sizeof( MRX_CREATENETROOT_CONTEXT ),
                                                                  'CSxR' );
    if (Context == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RxReleasePrefixTableLock( NameTable );
    *LockState = LHS_LockNotHeld;

    RtlZeroMemory( Context, sizeof( MRX_CREATENETROOT_CONTEXT ) );

    KeInitializeEvent( &Context->FinishEvent, SynchronizationEvent, FALSE );
    
    Context->Callback = RxCreateNetRootCallBack;
    Context->RxContext = RxContext;
    Context->pVNetRoot = VNetRoot;

    MINIRDR_CALL_THROUGH( Status,
                          SrvCall->RxDeviceObject->Dispatch,
                          MRxCreateVNetRoot,
                          (Context) );

    ASSERT( Status == STATUS_PENDING );

    KeWaitForSingleObject( &Context->FinishEvent, Executive, KernelMode, FALSE, NULL );

    if ((Context->NetRootStatus == STATUS_SUCCESS) &&
        (Context->VirtualNetRootStatus == STATUS_SUCCESS)) {
        
        RxDbgTrace( 0, Dbg, ("Return to open, good netroot...%wZ\n", &NetRoot->PrefixEntry.Prefix) );
        
        NetRootCondition = Condition_Good;
        VNetRootCondition = Condition_Good;
        Status = STATUS_SUCCESS;
    
    } else {
        
        if (Context->NetRootStatus == STATUS_SUCCESS) {
            NetRootCondition = Condition_Good;
            Status = Context->VirtualNetRootStatus;
        } else {
            Status = Context->NetRootStatus;
        }

        RxDbgTrace( 0, Dbg, ("Return to open, bad netroot...%wZ\n", &NetRoot->PrefixEntry.Prefix) );
    }

    RxAcquirePrefixTableLockExclusive( NameTable, TRUE );

    RxTransitionNetRoot( NetRoot, NetRootCondition );
    RxTransitionVNetRoot( VNetRoot, VNetRootCondition );

    *LockState = LHS_ExclusiveLockHeld;

    RxFreePool( Context );

    return Status;
}


NTSTATUS
RxConstructVirtualNetRoot (
   IN PRX_CONTEXT RxContext,
   IN PIRP Irp,
   IN PUNICODE_STRING CanonicalName,
   IN NET_ROOT_TYPE NetRootType,
   IN BOOLEAN TreeConnect,
   OUT PV_NET_ROOT *VNetRoot,
   OUT PLOCK_HOLDING_STATE LockState,
   OUT PRX_CONNECTION_ID  RxConnectionId
   )
/*++

Routine Description:

    This routine constructs a VNetRoot (View of a net root) by invoking the registered mini
    redirectors

Arguments:

    RxContext         -- the RDBSS context

    CanonicalName     -- the canonical name associated with the VNetRoot

    NetRootType       -- the type of the virtual net root

    VNetRoot   -- placeholder for the virtual net root instance to be constructed

    LockState -- the prefix table lock holding status
    
    RxConnectionId    -- The ID used for multiplex control

Return Value:

    the appropriate status value

--*/
{
    NTSTATUS Status;
    
    RX_BLOCK_CONDITION Condition = Condition_Bad;
    
    UNICODE_STRING FilePath;
    UNICODE_STRING LocalNetRootName;
    
    PV_NET_ROOT ThisVNetRoot = NULL;
    
    PAGED_CODE();
    
    RxDbgTrace( 0, Dbg, ("RxConstructVirtualNetRoot -- Entry\n") );
    
    ASSERT( *LockState != LHS_LockNotHeld );
    
    Status = RxFindOrCreateConnections( RxContext,
                                        Irp,
                                        CanonicalName,
                                        NetRootType,
                                        TreeConnect,
                                        &LocalNetRootName,
                                        &FilePath,
                                        LockState,
                                        RxConnectionId );

    if (Status == STATUS_CONNECTION_ACTIVE) {
                    
        PV_NET_ROOT ActiveVNetRoot = (PV_NET_ROOT)(RxContext->Create.pVNetRoot);
        PNET_ROOT NetRoot = (PNET_ROOT)ActiveVNetRoot->NetRoot;

        RxDbgTrace( 0, Dbg, ("  RxConstructVirtualNetRoot -- Creating new VNetRoot\n") );
        RxDbgTrace( 0, Dbg, ("RxCreateTreeConnect netroot=%wZ\n", &NetRoot->PrefixEntry.Prefix) );
        
        //
        //  The NetRoot has been previously constructed. A subsequent VNetRoot
        //  construction is required since the existing VNetRoot's do not satisfy
        //  the given criterion ( currently smae Logon Id's).
        //
        
        ThisVNetRoot = RxCreateVNetRoot( RxContext,
                                         NetRoot,
                                         CanonicalName,
                                         &LocalNetRootName,
                                         &FilePath,
                                         RxConnectionId );
        
        //
        //  The skeleton VNetRoot has been constructed. ( As part of this construction
        //  the underlying NetRoot and SrvCall has been referenced).
        //
        
        if (ThisVNetRoot != NULL) {
            RxReferenceVNetRoot( ThisVNetRoot );
        }
        
        //
        //  Dereference the VNetRoot returned as part of the lookup.
        //

        RxDereferenceVNetRoot( ActiveVNetRoot, LHS_LockNotHeld );
        
        RxContext->Create.pVNetRoot = NULL;
        RxContext->Create.pNetRoot  = NULL;
        RxContext->Create.pSrvCall  = NULL;
        
        if (ThisVNetRoot != NULL) {
            Status = RxConstructNetRoot( RxContext,
                                         (PSRV_CALL)ThisVNetRoot->NetRoot->SrvCall,
                                         (PNET_ROOT)ThisVNetRoot->NetRoot,
                                         ThisVNetRoot,
                                         LockState );
        
            if (Status == STATUS_SUCCESS) {
                Condition = Condition_Good;
            } else {
                Condition = Condition_Bad;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else if (Status == STATUS_SUCCESS) {
      
        *LockState = LHS_ExclusiveLockHeld;
        Condition = Condition_Good;
        ThisVNetRoot = (PV_NET_ROOT)(RxContext->Create.pVNetRoot);
    
    } else {
      
        RxDbgTrace( 0, Dbg, ("RxConstructVirtualNetRoot -- RxFindOrCreateConnections Status %lx\n", Status) );
    }
    
    if ((ThisVNetRoot != NULL) &&
        !StableCondition( ThisVNetRoot->Condition )) {
        
        RxTransitionVNetRoot( ThisVNetRoot, Condition );
    }
    
    if (Status != STATUS_SUCCESS) {
      
        if (ThisVNetRoot != NULL) {
            
            ASSERT( *LockState  != LHS_LockNotHeld );
            RxDereferenceVNetRoot( ThisVNetRoot, *LockState );
            ThisVNetRoot = NULL;
        }
    
        if (*LockState != LHS_LockNotHeld) {
            RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
            *LockState = LHS_LockNotHeld;
        }
    }
    
    *VNetRoot = ThisVNetRoot;
    
    RxDbgTrace( 0, Dbg, ("RxConstructVirtualNetRoot -- Exit Status %lx\n", Status) );
    return Status;
}

NTSTATUS
RxCheckVNetRootCredentials (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PV_NET_ROOT VNetRoot,
    IN PLUID Luid,     
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password,
    IN ULONG Flags
    )
/*++

Routine Description:

    This routine checks a given vnetroot and sees if it has matching credentials i.e
    its a connection for the same user

Arguments:

    RxContext         -- the RDBSS context


Return Value:

    the appropriate status value

--*/

{
    NTSTATUS Status;
    BOOLEAN UNCName;
    BOOLEAN TreeConnect;
    PSECURITY_USER_DATA SecurityData = NULL;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    UNCName = BooleanFlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME );
    TreeConnect = BooleanFlagOn( IrpSp->Parameters.Create.Options, FILE_CREATE_TREE_CONNECTION );

    //
    //  only for UNC names do we do the logic below
    //

    if (FlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME ) &&
        (FlagOn( VNetRoot->Flags, VNETROOT_FLAG_CSCAGENT_INSTANCE ) != FlagOn( Flags, VNETROOT_FLAG_CSCAGENT_INSTANCE ))) {
            
        //
        //  mismatched csc agent flags, not collapsing
        //

        return Status;
    }

    //
    //  The for loop is a scoping construct to join together the
    //  multitiude of failure cases in comparing the EA parameters
    //  with the original parameters supplied in the create request.
    //

    for (;;) {
        
        if (RtlCompareMemory( &VNetRoot->LogonId, Luid, sizeof( LUID ) ) == sizeof( LUID )) {
            
            PUNICODE_STRING TempUserName;
            PUNICODE_STRING TempDomainName;

            //
            //  If no EA parameters are specified by the user, the existing
            //  V_NET_ROOT instance as used. This is the common case when
            //  the user specifies the credentials for establishing a
            //  persistent connection across processes and reuses them.
            //

            if ((UserName == NULL) &&
                (DomainName == NULL) &&
                (Password == NULL)) {

                Status = STATUS_SUCCESS;
                break;
            }

            TempUserName = VNetRoot->pUserName;
            TempDomainName = VNetRoot->pUserDomainName;

            if (TempUserName == NULL ||
                TempDomainName == NULL) {
                
                Status = GetSecurityUserInfo( Luid,
                                              UNDERSTANDS_LONG_NAMES,
                                              &SecurityData );

                if (NT_SUCCESS(Status)) {
                    if (TempUserName == NULL) {
                        TempUserName = &SecurityData->UserName;
                    }

                    if (TempDomainName == NULL) {
                        TempDomainName = &SecurityData->LogonDomainName;
                    }
                } else {
                    break;
                }
            }

            //
            //  The logon ids match. The user has supplied EA parameters
            //  which can either match with the existing credentials or
            //  result in a conflict with the existing credentials. In all
            //  such cases the outcome will either be a reuse of the
            //  existing V_NET_ROOT instance or a refusal of the new connection
            //  attempt.
            //  The only exception to the above rule is in the case of
            //  regular opens (FILE_CREATE_TREE_CONNECTION is not
            //  specified for UNC names. In such cases the construction of a
            //  new V_NET_ROOT is initiated which will be torn down
            //  when the associated file is closed
            //
            
            if (UNCName && !TreeConnect) {
                Status = STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
            }

            if ((UserName != NULL) &&
                (TempUserName != NULL) &&
                !RtlEqualUnicodeString( TempUserName, UserName, TRUE )) {
                break;
            }

            if ((DomainName != NULL) &&
                !RtlEqualUnicodeString( TempDomainName, DomainName, TRUE )) {
                break;
            }

            if ((VNetRoot->pPassword != NULL) &&
                (Password != NULL)) {
                
                if (!RtlEqualUnicodeString( VNetRoot->pPassword, Password, FALSE )) {
                    break;
                }
            }

            //
            //  We use existing session if either the stored or new password is NULL.
            //  Later, a new security API will be created for verify the password based
            //  on the logon ID.
            //

            Status = STATUS_SUCCESS;
            break;
        } else {
            break;
        }
    }

    if (SecurityData != NULL) {
        LsaFreeReturnBuffer( SecurityData );
    }

    return Status;
}

NTSTATUS
RxFindOrConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine finds or constructs a VNetRoot (View of a net root)

Arguments:

    RxContext         -- the RDBSS context

    CanonicalName     -- the canonical name associated with the VNetRoot

    NetRootType       -- the type of the virtual net root

    RemainingName     -- the portion of the name that was not found in the prefix table

Return Value:

    the appropriate status value

--*/
{
    NTSTATUS Status;
    LOCK_HOLDING_STATE LockState;

    BOOLEAN Wait = BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
    BOOLEAN InFSD = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP );

    BOOLEAN UNCName;
    BOOLEAN TreeConnect;

    PVOID Container;

    PV_NET_ROOT VNetRoot;
    PRX_PREFIX_TABLE RxNetNameTable = RxContext->RxDeviceObject->pRxNetNameTable;
    ULONG Flags = 0;
    RX_CONNECTION_ID RxConnectionId;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    
    PAGED_CODE();

    MINIRDR_CALL_THROUGH( Status,
                          RxDeviceObject->Dispatch,
                          MRxGetConnectionId,
                          (RxContext,&RxConnectionId) );
    
    if (Status == STATUS_NOT_IMPLEMENTED) {
        
        RtlZeroMemory( &RxConnectionId, sizeof( RX_CONNECTION_ID ) );
    
    } else if(!NT_SUCCESS( Status )) {
        
        DbgPrint( "MRXSMB: Failed to initialize Connection ID\n" );
        ASSERT( FALSE );
        RtlZeroMemory( &RxConnectionId, sizeof( RX_CONNECTION_ID ) );
    }

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    UNCName = BooleanFlagOn( RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_UNC_NAME );
    TreeConnect = BooleanFlagOn( IrpSp->Parameters.Create.Options, FILE_CREATE_TREE_CONNECTION );

    //
    //  deleterxcontext stuff will deref wherever this points.......
    //

    RxContext->Create.NetNamePrefixEntry = NULL;

    RxAcquirePrefixTableLockShared( RxNetNameTable, TRUE );
    LockState = LHS_SharedLockHeld;

    for(;;) {
        
        //
        //  This for loop actually serves as a simple scoping construct for executing
        //  the same piece of code twice, once with a shared lock and once with an
        //  exclusive lock. In the interests of maximal concurrency a shared lock is
        //  accquired for the first pass and subsequently upgraded. If the search
        //  succeeds with a shared lock the second pass is skipped.
        //

        Container = RxPrefixTableLookupName( RxNetNameTable, CanonicalName, RemainingName, &RxConnectionId );

        if (Container != NULL ) {
            if (NodeType( Container ) == RDBSS_NTC_V_NETROOT) {
                
                PV_NET_ROOT TempVNetRoot = NULL;
                PNET_ROOT NetRoot;
                ULONG SessionId;

                VNetRoot = (PV_NET_ROOT)Container;
                NetRoot = (PNET_ROOT)VNetRoot->NetRoot;

                //
                //  Determine if a virtual net root with the same logon id. already exists.
                //  If not a new virtual net root has to be constructed.
                //  traverse the list of virtual net roots associated with a net root.
                //  Note that the list of virtual net roots associated with a net root cannot be empty
                //  since the construction of the default virtual net root coincides with the creation
                //  of the net root.
                //

                if (((NetRoot->Condition == Condition_Good) ||
                     (NetRoot->Condition == Condition_InTransition)) &&
                    (NetRoot->SrvCall->RxDeviceObject == RxContext->RxDeviceObject)) {
                    
                    LUID LogonId;
                    PUNICODE_STRING UserName;
                    PUNICODE_STRING UserDomainName;
                    PUNICODE_STRING Password;

                    //
                    //  Extract the VNetRoot parameters from the IRP to map one of
                    //  the existing VNetRoots if possible. The algorithm for
                    //  determining this mapping is very simplistic. If no Ea
                    //  parameters are specified a VNetRoot with a matching Logon
                    //  id. is choosen. if Ea parameters are specified then a
                    //  VNetRoot with identical parameters is choosen. The idea
                    //  behind this simplistic algorithm is to let the mini redirectors
                    //  determine the mapping policy and not prefer one mini
                    //  redirectors policy over another.
                    //

                    Status = RxInitializeVNetRootParameters( RxContext, 
                                                             &LogonId,
                                                             &SessionId,
                                                             &UserName,
                                                             &UserDomainName,
                                                             &Password,
                                                             &Flags );

                    //
                    //  Walk list of vnetroots and check for a match starting 
                    //  optimistically with the one found
                    //

                    if (Status == STATUS_SUCCESS) {
                        TempVNetRoot = VNetRoot;
                    
                        do {

                            Status = RxCheckVNetRootCredentials( RxContext,
                                                                 Irp,
                                                                 TempVNetRoot,
                                                                 &LogonId,
                                                                 UserName,
                                                                 UserDomainName,
                                                                 Password,
                                                                 Flags );

                            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                                    
                                TempVNetRoot = (PV_NET_ROOT)CONTAINING_RECORD( TempVNetRoot->NetRootListEntry.Flink,
                                                                               V_NET_ROOT,
                                                                               NetRootListEntry);
                            }
                        
                        } while ((Status == STATUS_MORE_PROCESSING_REQUIRED) && (TempVNetRoot != VNetRoot));


                        if (Status != STATUS_SUCCESS) {
                            TempVNetRoot = NULL;
                        } else {

                            //
                            //  Reference the found vnetroot on success
                            //  

                            RxReferenceVNetRoot( TempVNetRoot );
                        }

                        RxUninitializeVNetRootParameters( UserName, UserDomainName, Password, &Flags );
                    }
                
                } else {
                    
                    Status = STATUS_BAD_NETWORK_PATH;
                    TempVNetRoot = NULL;
                }

                RxDereferenceVNetRoot( VNetRoot, LockState );
                VNetRoot = TempVNetRoot;

            } else {
                
                ASSERT( NodeType( Container ) == RDBSS_NTC_SRVCALL );
                RxDereferenceSrvCall( (PSRV_CALL)Container, LockState );
            }
        }

        if ((Status == STATUS_MORE_PROCESSING_REQUIRED) && (LockState == LHS_SharedLockHeld)) {
            
            //
            //  Release the shared lock and acquire it in an exclusive mode.
            //  Upgrade the lock to an exclusive lock
            //

            if (!RxAcquirePrefixTableLockExclusive( RxNetNameTable, FALSE )) {
                
                RxReleasePrefixTableLock( RxNetNameTable );
                RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );
                LockState = LHS_ExclusiveLockHeld;

            } else {
                
                //
                //  The lock was upgraded from a shared mode to an exclusive mode without
                //  losing it. Therefore there is no need to search the table again. The
                //  construction of the new V_NET_ROOT can proceed.
                
                LockState = LHS_ExclusiveLockHeld;
                break;
            }
        } else {
            break;
        }
    }

    //
    //  At this point either the lookup was successful ( with a shared/exclusive lock )
    //  or exclusive lock has been obtained.
    //  No virtual net root was found in the prefix table or the net root that was found is bad.
    //  The construction of a new virtual netroot needs to be undertaken.
    //

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        
        ASSERT( LockState == LHS_ExclusiveLockHeld );
        Status = RxConstructVirtualNetRoot( RxContext,
                                            Irp,
                                            CanonicalName,
                                            NetRootType,
                                            TreeConnect,
                                            &VNetRoot,
                                            &LockState,
                                            &RxConnectionId );

        ASSERT( (Status != STATUS_SUCCESS) || (LockState != LHS_LockNotHeld) );

        if (Status == STATUS_SUCCESS) {
            
            ASSERT( CanonicalName->Length >= VNetRoot->PrefixEntry.Prefix.Length );
            
            RemainingName->Buffer = (PWCH)Add2Ptr( CanonicalName->Buffer, VNetRoot->PrefixEntry.Prefix.Length );
            RemainingName->Length = CanonicalName->Length - VNetRoot->PrefixEntry.Prefix.Length;
            RemainingName->MaximumLength = RemainingName->Length;

            if (FlagOn( Flags, VNETROOT_FLAG_CSCAGENT_INSTANCE )) {
                RxLog(( "FOrCVNR CSC instance %x\n", VNetRoot ));
                RxWmiLog( LOG,
                          RxFindOrConstructVirtualNetRoot,
                          LOGPTR( VNetRoot ) );
            }
            SetFlag( VNetRoot->Flags, Flags );
        }
    }

    if (LockState != LHS_LockNotHeld) {
        RxReleasePrefixTableLock( RxNetNameTable );
    }

    if (Status == STATUS_SUCCESS) {
        RxWaitForStableVNetRoot( VNetRoot, RxContext );

        if (VNetRoot->Condition == Condition_Good) {
            
            RxContext->Create.pVNetRoot = (PMRX_V_NET_ROOT)VNetRoot;
            RxContext->Create.pNetRoot  = (PMRX_NET_ROOT)VNetRoot->NetRoot;
            RxContext->Create.pSrvCall  = (PMRX_SRV_CALL)VNetRoot->NetRoot->SrvCall;
        
        } else {
            RxDereferenceVNetRoot( VNetRoot, LHS_LockNotHeld );
            RxContext->Create.pVNetRoot = NULL;
            Status = STATUS_BAD_NETWORK_PATH;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.c

Abstract:

    This module declares the global data used by the Rx file system.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "prefix.h"

//
//  The global fsd data record, and zero large integer
//

RX_DISPATCHER RxDispatcher;
RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

LIST_ENTRY    RxSrvCalldownList;
LIST_ENTRY    RxActiveContexts;
PRX_CONTEXT   RxStopContext = NULL;

//
// the debugger extension needs to know the target architecture. sacrifice one ulong....
// the highorder 0xabc is just for consistency..........

ULONG           RxProcessorArchitecture = 0xabc0000 |
#if defined(_X86_)
                                                RX_PROCESSOR_ARCHITECTURE_INTEL;
#elif defined(_MIPS_)
                                                RX_PROCESSOR_ARCHITECTURE_MIPS;
#elif defined(_ALPHA_)
                                                RX_PROCESSOR_ARCHITECTURE_ALPHA;
#elif defined(_PPC_)
                                                RX_PROCESSOR_ARCHITECTURE_PPC;
#else
                                                RX_PROCESSOR_ARCHITECTURE_UNKNOWN;
#endif

#ifdef EXPLODE_POOLTAGS
ULONG RxExplodePoolTags = 1;
#else
ULONG RxExplodePoolTags = 0;
#endif

KMUTEX       RxSerializationMutex;

RDBSS_DATA      RxData;
RDBSS_EXPORTS   RxExports;
ULONG           RxElapsedSecondsSinceStart;

KSPIN_LOCK      RxStrucSupSpinLock = {0};      //  used to synchronize access to zones/structures

PRDBSS_DEVICE_OBJECT  RxFileSystemDeviceObject;
NTSTATUS        RxStubStatus = (STATUS_NOT_IMPLEMENTED);
FCB             RxDeviceFCB;

LARGE_INTEGER RxLargeZero = {0,0};
LARGE_INTEGER RxMaxLarge = {MAXULONG,MAXLONG};
LARGE_INTEGER Rx30Milliseconds = {(ULONG)(-30 * 1000 * 10), -1};
LARGE_INTEGER RxOneSecond = {10000000,0};
LARGE_INTEGER RxOneDay = {0x2a69c000, 0xc9};
LARGE_INTEGER RxJanOne1980 = {0xe1d58000,0x01a8e79f};
LARGE_INTEGER RxDecThirtyOne1979 = {0xb76bc000,0x01a8e6d6};


ULONG RxFsdEntryCount = 0;
ULONG RxFspEntryCount = 0;
ULONG RxIoCallDriverCount = 0;

LONG RxPerformanceTimerLevel = 0x00000000;

ULONG RxTotalTicks[32] = { 0 };

//
//  I need this because C can't support conditional compilation within
//  a macro.
//

PVOID RxNull = NULL;


extern LONG           RxNumberOfActiveFcbs = 0;

// Reference Tracing mask value .. Turn it on by default for DBG builds

#ifdef DBG
ULONG RdbssReferenceTracingValue = 0x8000003f;
#else
ULONG RdbssReferenceTracingValue = 0;
#endif


UNICODE_STRING s_PipeShareName = { 10, 10, L"\\PIPE" };
UNICODE_STRING s_MailSlotShareName = { 18, 18, L"\\MAILSLOT" };
UNICODE_STRING s_MailSlotServerPrefix = {8,8,L";$:\\"};
UNICODE_STRING s_IpcShareName  = { 10, 10, L"\\IPC$" };

UNICODE_STRING s_PrimaryDomainName = {0,0,NULL};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxtimer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtTimer.c

Abstract:

    This module implements the nt version of the timer and worker thread management routines.
    These services are provided to all mini redirector writers. The timer service comes in two
    flavours - a periodic trigger and a one shot notification.

Author:

    Joe Linn     [JoeLinn]   2-mar-95

Revision History:

    Balan Sethu Raman [SethuR] 7-Mar-95
         Included one shot, periodic notification for work queue items.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeRxTimer)
#pragma alloc_text(PAGE, RxTearDownRxTimer)
#pragma alloc_text(PAGE, RxPostRecurrentTimerRequest)
#pragma alloc_text(PAGE, RxRecurrentTimerWorkItemDispatcher)
#endif

typedef struct _RX_RECURRENT_WORK_ITEM_ {
   RX_WORK_ITEM               WorkItem;
   LIST_ENTRY                 RecurrentWorkItemsList;
   LARGE_INTEGER              TimeInterval;
   PRX_WORKERTHREAD_ROUTINE   Routine;
   PVOID                      pContext;
} RX_RECURRENT_WORK_ITEM, *PRX_RECURRENT_WORK_ITEM;

//
// Forward declarations of routines
//

extern VOID
RxTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

extern VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );


//  The Bug check file id for this module
#define BugCheckFileId  (RDBSS_BUG_CHECK_NTTIMER)


//  The local trace mask for this part of the module
#define Dbg                              (DEBUG_TRACE_NTTIMER)

LARGE_INTEGER s_RxTimerInterval;
KSPIN_LOCK    s_RxTimerLock;
KDPC          s_RxTimerDpc;
LIST_ENTRY    s_RxTimerQueueHead;  // queue of the list of timer calls
LIST_ENTRY    s_RxRecurrentWorkItemsList;
KTIMER        s_RxTimer;
ULONG         s_RxTimerTickCount;

#define NoOf100nsTicksIn1ms  (10 * 1000)
#define NoOf100nsTicksIn55ms (10 * 1000 * 55)

NTSTATUS
RxInitializeRxTimer()
/*++

Routine Description:

    The routine initializes everything having to do with the timer stuff.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    s_RxTimerInterval.LowPart = (ULONG)(-((LONG)NoOf100nsTicksIn55ms));
    s_RxTimerInterval.HighPart = -1;

    KeInitializeSpinLock( &s_RxTimerLock );

    InitializeListHead( &s_RxTimerQueueHead );
    InitializeListHead( &s_RxRecurrentWorkItemsList );

    KeInitializeDpc( &s_RxTimerDpc, RxTimerDispatch, NULL );
    KeInitializeTimer( &s_RxTimer );

    s_RxTimerTickCount = 0;

    return Status;
}


VOID
RxTearDownRxTimer(
    void)
/*++

Routine Description:

    This routine is used by drivers to initialize a timer entry for a device
    object.

Arguments:

    TimerEntry - Pointer to a timer entry to be used.

    TimerRoutine - Driver routine to be executed when timer expires.

    Context - Context parameter that is passed to the driver routine.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/

{
    PRX_RECURRENT_WORK_ITEM pWorkItem;
    PLIST_ENTRY             pListEntry;

    PAGED_CODE();

    KeCancelTimer( &s_RxTimer );

    // Walk down the list freeing up the recurrent requests since the memory was
    // allocated by us.
    while (!IsListEmpty(&s_RxRecurrentWorkItemsList)) {
        pListEntry = RemoveHeadList(&s_RxRecurrentWorkItemsList);
        pWorkItem  = (PRX_RECURRENT_WORK_ITEM)
                     CONTAINING_RECORD(
                         pListEntry,
                         RX_RECURRENT_WORK_ITEM,
                         RecurrentWorkItemsList);
        RxFreePool(pWorkItem);
    }
}

VOID
RxTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine scans the  timer database and posts a work item for all those requests
    whose temporal constraints have been satisfied.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Optional deferred context;  not used.

    SystemArgument1 - Optional argument 1;  not used.

    SystemArgument2 - Optional argument 2;  not used.

Return Value:

    None.

--*/
{
    PLIST_ENTRY      pListEntry;
    LIST_ENTRY       ExpiredList;

    //KIRQL            Irql;
    BOOLEAN          ContinueTimer = FALSE;

    PRX_WORK_QUEUE_ITEM pWorkQueueItem;
    PRX_WORK_ITEM       pWorkItem;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( DeferredContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    InitializeListHead(&ExpiredList);

    KeAcquireSpinLockAtDpcLevel( &s_RxTimerLock );

    s_RxTimerTickCount++;

    pListEntry = s_RxTimerQueueHead.Flink;

    while (pListEntry != &s_RxTimerQueueHead) {
        pWorkQueueItem = CONTAINING_RECORD(
                             pListEntry,
                             RX_WORK_QUEUE_ITEM,
                             List );
        pWorkItem      = CONTAINING_RECORD(
                             pWorkQueueItem,
                             RX_WORK_ITEM,
                             WorkQueueItem);

        if (pWorkItem->LastTick == s_RxTimerTickCount) {
           PLIST_ENTRY pExpiredEntry = pListEntry;
           pListEntry = pListEntry->Flink;

           RemoveEntryList(pExpiredEntry);
           InsertTailList(&ExpiredList,pExpiredEntry);
        } else {
           pListEntry = pListEntry->Flink;
        }
    }

    ContinueTimer = !(IsListEmpty(&s_RxTimerQueueHead));
    KeReleaseSpinLockFromDpcLevel( &s_RxTimerLock );

    // Resubmit the timer queue dispatch routine so that it will be reinvoked.
    if (ContinueTimer)
        KeSetTimer( &s_RxTimer, s_RxTimerInterval, &s_RxTimerDpc );

    // Queue all the expired entries on the worker threads.
    while (!IsListEmpty(&ExpiredList)) {
        pListEntry = RemoveHeadList(&ExpiredList);
        pListEntry->Flink = pListEntry->Blink = NULL;

        pWorkQueueItem = CONTAINING_RECORD(
                             pListEntry,
                             RX_WORK_QUEUE_ITEM,
                             List );

        // Post the work item to a worker thread
        RxPostToWorkerThread(
            pWorkQueueItem->pDeviceObject,
            CriticalWorkQueue,
            pWorkQueueItem,
            pWorkQueueItem->WorkerRoutine,
            pWorkQueueItem->Parameter);
    }
}

NTSTATUS
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval)
/*++

Routine Description:

    This routine is used by drivers to initialize a timer entry for a device
    object.

Arguments:

    pDeviceObject - the device object

    pWorkItem - the work item

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

    TimeInterval   - the time interval in 100 ns ticks.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/

{
    BOOLEAN       StartTimer;
    //NTSTATUS      Status;
    ULONG         NumberOf55msIntervals;
    KIRQL         Irql;
    LARGE_INTEGER StrobeInterval;

    ASSERT(pWorkItem != NULL);

    // Initialize the work queue item.
    ExInitializeWorkItem(
        (PWORK_QUEUE_ITEM)&pWorkItem->WorkQueueItem,
        Routine,
        pContext );

    pWorkItem->WorkQueueItem.pDeviceObject = pDeviceObject;

    // Compute the time interval in number of ticks.
    StrobeInterval.QuadPart= NoOf100nsTicksIn55ms;
    NumberOf55msIntervals = (ULONG)(TimeInterval.QuadPart / StrobeInterval.QuadPart);
    NumberOf55msIntervals += 1; // Take the ceiling to be conservative
    RxDbgTraceLV( 0, Dbg, 1500, ("Timer will expire after %ld 55ms intervals\n",NumberOf55msIntervals));

    // Insert the entry in the timer queue.
    KeAcquireSpinLock( &s_RxTimerLock, &Irql );

    // Update the tick relative to the current tick.
    pWorkItem->LastTick = s_RxTimerTickCount + NumberOf55msIntervals;

    StartTimer = IsListEmpty(&s_RxTimerQueueHead);
    InsertTailList( &s_RxTimerQueueHead,&pWorkItem->WorkQueueItem.List);

    KeReleaseSpinLock( &s_RxTimerLock, Irql );

    if (StartTimer) {
        KeSetTimer( &s_RxTimer, s_RxTimerInterval, &s_RxTimerDpc );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval)
/*++

Routine Description:

    This routine is used to post a recurrent timer request. The passed in routine once every
    (TimeInterval) milli seconds.

Arguments:

    pDeviceObject  - the device object

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

    TimeInterval   - the time interval in 100ns ticks.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/
{
    PRX_RECURRENT_WORK_ITEM pRecurrentWorkItem;
    NTSTATUS      Status;

    PAGED_CODE();

    // Allocate a work item.
    pRecurrentWorkItem = (PRX_RECURRENT_WORK_ITEM)
                        RxAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(RX_RECURRENT_WORK_ITEM),
                            RX_TIMER_POOLTAG);

    if (pRecurrentWorkItem != NULL) {
        InsertTailList(
            &s_RxRecurrentWorkItemsList,
            &pRecurrentWorkItem->RecurrentWorkItemsList);

        pRecurrentWorkItem->Routine = Routine;
        pRecurrentWorkItem->pContext = pContext;
        pRecurrentWorkItem->TimeInterval = TimeInterval;
        pRecurrentWorkItem->WorkItem.WorkQueueItem.pDeviceObject = pDeviceObject;

        Status = RxPostOneShotTimerRequest(
                     pRecurrentWorkItem->WorkItem.WorkQueueItem.pDeviceObject,
                     &pRecurrentWorkItem->WorkItem,
                     RxRecurrentTimerWorkItemDispatcher,
                     pRecurrentWorkItem,
                     TimeInterval);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT       pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE   Routine,
    IN PVOID                      pContext)
/*++

Routine Description:

    This routine cancels a  timer request. The request to be cancelled is identified
    by the routine and context.

Arguments:

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

--*/
{
    NTSTATUS                Status = STATUS_NOT_FOUND;
    PLIST_ENTRY             pListEntry;
    PWORK_QUEUE_ITEM     pWorkQueueItem;
    PRX_WORK_ITEM           pWorkItem;
    PRX_RECURRENT_WORK_ITEM pRecurrentWorkItem = NULL;
    KIRQL Irql;

    KeAcquireSpinLock( &s_RxTimerLock, &Irql );

    // Walk through the list of entries
    for (pListEntry = s_RxTimerQueueHead.Flink;
         (pListEntry != &s_RxTimerQueueHead);
         pListEntry = pListEntry->Flink ) {
        pWorkQueueItem = CONTAINING_RECORD( pListEntry, WORK_QUEUE_ITEM, List );
        pWorkItem      = CONTAINING_RECORD( pWorkQueueItem, RX_WORK_ITEM, WorkQueueItem);

        if ((pWorkItem->WorkQueueItem.pDeviceObject == pDeviceObject) &&
            (pWorkItem->WorkQueueItem.WorkerRoutine == Routine) &&
            (pWorkItem->WorkQueueItem.Parameter == pContext)) {
            RemoveEntryList(pListEntry);
            Status = STATUS_SUCCESS;
            pRecurrentWorkItem = NULL;
            break;
        } else if (pWorkItem->WorkQueueItem.WorkerRoutine == RxRecurrentTimerWorkItemDispatcher) {
            pRecurrentWorkItem = (PRX_RECURRENT_WORK_ITEM)pWorkItem->WorkQueueItem.Parameter;

            if ((pRecurrentWorkItem->Routine == Routine) &&
                (pRecurrentWorkItem->pContext == pContext)) {
                RemoveEntryList(pListEntry);
                RemoveEntryList(&pRecurrentWorkItem->RecurrentWorkItemsList);
                Status = STATUS_SUCCESS;
            } else {
                pRecurrentWorkItem = NULL;
            }
        }
    }

    KeReleaseSpinLock( &s_RxTimerLock, Irql );

    if (pRecurrentWorkItem != NULL) {
        RxFreePool(pRecurrentWorkItem);
    }

    return Status;
}

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    )
/*++

Routine Description:

    This routine dispatches a recurrent timer request. On completion of the invocation of the
    associated routine the request s requeued.

Arguments:

    Routine        - the routine to be invoked on timeout

    pContext       - the Context parameter that is passed to the driver routine.

--*/
{
    PRX_RECURRENT_WORK_ITEM  pPeriodicWorkItem = (PRX_RECURRENT_WORK_ITEM)Context;
    PRX_WORKERTHREAD_ROUTINE Routine  = pPeriodicWorkItem->Routine;
    PVOID                    pContext = pPeriodicWorkItem->pContext;

    PAGED_CODE();

    //KIRQL  Irql;

    // Invoke the routine.
    Routine(pContext);

    // enqueue the item if necessary.
    RxPostOneShotTimerRequest(
        pPeriodicWorkItem->WorkItem.WorkQueueItem.pDeviceObject,
        &pPeriodicWorkItem->WorkItem,
        RxRecurrentTimerWorkItemDispatcher,
        pPeriodicWorkItem,
        pPeriodicWorkItem->TimeInterval);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxtrace.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.c

Abstract:

    This module declares the global data used by the Rx file system.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "prefix.h"

#if DBG

LONG RxDebugTraceIndent = 0;

#endif

#if RDBSSTRACE

BOOLEAN RxGlobalTraceSuppress = FALSE;
BOOLEAN RxNextGlobalTraceSuppress = FALSE;

#define MAXIMUM_DEBUGTRACE_CONTROLS 200
ULONG RxMaximumTraceControl;
RX_DEBUG_TRACE_CONTROL RxDebugTraceControl[MAXIMUM_DEBUGTRACE_CONTROLS];

#define DEBUGTRACE_NAMEBUFFERSIZE 800
CHAR RxDebugTraceNameBuffer[DEBUGTRACE_NAMEBUFFERSIZE];
ULONG RxDTNMptr = 0;
BOOLEAN RxDTNMCopy = FALSE;


PCHAR RxStorageTypeNames[256];
PCHAR RxIrpCodeToName[IRP_MJ_MAXIMUM_FUNCTION+1];
ULONG RxIrpCodeCount[IRP_MJ_MAXIMUM_FUNCTION+1];

#endif // RDBSSTRACE


#if RDBSSTRACE

//we declare controlpoints differently in the rdbss than in a minirdr. at some point,
//         minirdrs may come and go. for this reason we have to save the name text in
//         a nontransient rdbss storage. for rdbss controlpoints, we just use the name
//         pointer we're given since it is just as persistent as the copy. whether we copy
//         or just point is controlled

#define RXDT_Declare(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
RXDT_Declare(ERROR);
RXDT_Declare(HOOKS);
RXDT_Declare(CATCH_EXCEPTIONS);
RXDT_Declare(UNWIND);
RXDT_Declare(CLEANUP);
RXDT_Declare(CLOSE);
RXDT_Declare(CREATE);
RXDT_Declare(DIRCTRL);
RXDT_Declare(EA);
RXDT_Declare(FILEINFO);
RXDT_Declare(FSCTRL);
RXDT_Declare(LOCKCTRL);
RXDT_Declare(READ);
RXDT_Declare(VOLINFO);
RXDT_Declare(WRITE);
RXDT_Declare(FLUSH);
RXDT_Declare(DEVCTRL);
RXDT_Declare(SHUTDOWN);
RXDT_Declare(PREFIX);
RXDT_Declare(DEVFCB);
RXDT_Declare(ACCHKSUP);
RXDT_Declare(ALLOCSUP);
RXDT_Declare(DIRSUP);
RXDT_Declare(FILOBSUP);
RXDT_Declare(NAMESUP);
RXDT_Declare(VERFYSUP);
RXDT_Declare(CACHESUP);
RXDT_Declare(SPLAYSUP);
RXDT_Declare(DEVIOSUP);
RXDT_Declare(FCBSTRUCTS);
RXDT_Declare(STRUCSUP);
RXDT_Declare(FSP_DISPATCHER);
RXDT_Declare(FSP_DUMP);
RXDT_Declare(RXCONTX);
RXDT_Declare(DISPATCH);
RXDT_Declare(NTFASTIO);
RXDT_Declare(LOWIO);
RXDT_Declare(MINIRDR);
RXDT_Declare(DISCCODE);  //for the browser interface stuff
RXDT_Declare(BROWSER);
RXDT_Declare(CONNECT);
RXDT_Declare(NTTIMER);
RXDT_Declare(SCAVTHRD);
RXDT_Declare(SCAVENGER);
RXDT_Declare(SHAREACCESS);
RXDT_Declare(NAMECACHE);

// connection engine stuff
RXDT_Declare(RXCEBINDING);
RXDT_Declare(RXCEDBIMPLEMENTATION);
RXDT_Declare(RXCEMANAGEMENT);
RXDT_Declare(RXCEXMIT);
RXDT_Declare(RXCEPOOL);
RXDT_Declare(RXCETDI);


VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
{
    ULONG i;

    RxMaximumTraceControl++;
    i = RxMaximumTraceControl;
    ASSERT(i<MAXIMUM_DEBUGTRACE_CONTROLS);
    RxDebugTraceControl[i].PrintLevel = 1000;
    RxDebugTraceControl[i].BreakMask = 0xf0000000;
    if (RxDTNMCopy) {
        ULONG len = strlen(Name)+1;
        ASSERT (RxDTNMptr+len<DEBUGTRACE_NAMEBUFFERSIZE);
        RxDebugTraceControl[i].Name= &RxDebugTraceNameBuffer[RxDTNMptr];
        RtlCopyMemory(RxDebugTraceControl[i].Name,Name,len);
        RxDTNMptr += len;
    } else {
        RxDebugTraceControl[i].Name=Name;
    }
    RxDebugTraceControl[i+1].Name=NULL;
    ControlPoint->Name=RxDebugTraceControl[i].Name;
    ControlPoint->ControlPointNumber = i;
}


#ifdef RxInitializeDebugTrace
#undef RxInitializeDebugTrace
#endif
VOID RxInitializeDebugTrace(void){
    int i;

    RxDebugTraceIndent = 0;
    RxGlobalTraceSuppress = TRUE;
    RxNextGlobalTraceSuppress = TRUE;
    RxExports.pRxDebugTraceIndent = &RxDebugTraceIndent;


    for (i=0;i<=IRP_MJ_MAXIMUM_FUNCTION;i++) {
        RxIrpCodeCount[i] = 0;
    }

#if RDBSSTRACE
#define OneName(x) { RxInitializeDebugTraceControlPoint(#x, &RX_DEBUG_TRACE_##x); }
    RxMaximumTraceControl=0;
    OneName(ACCHKSUP);
    OneName(ALLOCSUP);
    OneName(BROWSER);
    OneName(CACHESUP);
    OneName(CATCH_EXCEPTIONS);
    OneName(CLEANUP);
    OneName(CLOSE);
    OneName(CONNECT);
    OneName(CREATE);
    OneName(HOOKS);
    OneName(DEVCTRL);
    OneName(DEVFCB);
    OneName(DEVIOSUP);
    OneName(DIRCTRL);
    OneName(DIRSUP);
    OneName(DISCCODE);
    OneName(DISPATCH);
    OneName(EA);
    OneName(ERROR);
    OneName(FCBSTRUCTS);
    OneName(FILEINFO);
    OneName(FILOBSUP);
    OneName(FLUSH);
    OneName(FSCTRL);
    OneName(FSP_DISPATCHER);
    OneName(FSP_DUMP);
    OneName(RXCONTX);
    OneName(LOCKCTRL);
    OneName(LOWIO);
    OneName(MINIRDR);
    OneName(NAMESUP);
    OneName(NTFASTIO);
    OneName(NTTIMER);
    OneName(PREFIX);
    OneName(READ);
    OneName(SCAVTHRD);
    OneName(SHUTDOWN);
    OneName(SPLAYSUP);
    OneName(STRUCSUP);
    OneName(UNWIND);
    OneName(VERFYSUP);
    OneName(VOLINFO);
    OneName(WRITE);
    OneName(SCAVENGER);
    OneName(SHAREACCESS);
    OneName(NAMECACHE);
    OneName(RXCEBINDING);       //connection engine
    OneName(RXCEDBIMPLEMENTATION);
    OneName(RXCEMANAGEMENT);
    OneName(RXCEXMIT);
    OneName(RXCEPOOL);
    OneName(RXCETDI);

    RxDTNMCopy = FALSE;  // from now on, copy the name

    RxDebugTraceControl[RX_DEBUG_TRACE_ALLOCSUP.ControlPointNumber].PrintLevel = 0;   //get rid of annoying logof msg
    RxDebugTraceControl[RX_DEBUG_TRACE_DISCCODE.ControlPointNumber].PrintLevel = 0;   //it's just too much
    RxDebugTraceControl[RX_DEBUG_TRACE_BROWSER.ControlPointNumber].PrintLevel = 0;   //it's just too much
    //RxDebugTraceControl[RX_DEBUG_TRACE_CREATE.ControlPointNumber].PrintLevel = 0;
#endif //rdbsstrace


    RxIrpCodeToName[IRP_MJ_CREATE] = "CREATE";
    RxIrpCodeToName[IRP_MJ_CREATE_NAMED_PIPE] = "CREATE_NAMED_PIPE";
    RxIrpCodeToName[IRP_MJ_CLOSE] = "CLOSE";
    RxIrpCodeToName[IRP_MJ_READ] = "READ";
    RxIrpCodeToName[IRP_MJ_WRITE] = "WRITE";
    RxIrpCodeToName[IRP_MJ_QUERY_INFORMATION] = "QUERY_INFORMATION";
    RxIrpCodeToName[IRP_MJ_SET_INFORMATION] = "SET_INFORMATION";
    RxIrpCodeToName[IRP_MJ_QUERY_EA] = "QUERY_EA";
    RxIrpCodeToName[IRP_MJ_SET_EA] = "SET_EA";
    RxIrpCodeToName[IRP_MJ_FLUSH_BUFFERS] = "FLUSH_BUFFERS";
    RxIrpCodeToName[IRP_MJ_QUERY_VOLUME_INFORMATION] = "QUERY_VOLUME_INFORMATION";
    RxIrpCodeToName[IRP_MJ_SET_VOLUME_INFORMATION] = "SET_VOLUME_INFORMATION";
    RxIrpCodeToName[IRP_MJ_DIRECTORY_CONTROL] = "DIRECTORY_CONTROL";
    RxIrpCodeToName[IRP_MJ_FILE_SYSTEM_CONTROL] = "FILE_SYSTEM_CONTROL";
    RxIrpCodeToName[IRP_MJ_DEVICE_CONTROL] = "DEVICE_CONTROL";
    RxIrpCodeToName[IRP_MJ_INTERNAL_DEVICE_CONTROL] = "INTERNAL_DEVICE_CONTROL";
    RxIrpCodeToName[IRP_MJ_SHUTDOWN] = "SHUTDOWN";
    RxIrpCodeToName[IRP_MJ_LOCK_CONTROL] = "LOCK_CONTROL";
    RxIrpCodeToName[IRP_MJ_CLEANUP] = "CLEANUP";
    RxIrpCodeToName[IRP_MJ_CREATE_MAILSLOT] = "CREATE_MAILSLOT";
    RxIrpCodeToName[IRP_MJ_QUERY_SECURITY] = "QUERY_SECURITY";
    RxIrpCodeToName[IRP_MJ_SET_SECURITY] = "SET_SECURITY";
    RxIrpCodeToName[IRP_MJ_POWER] = "POWER";
    RxIrpCodeToName[IRP_MJ_SYSTEM_CONTROL] = "SYSTEM_CONTROL";
    RxIrpCodeToName[IRP_MJ_DEVICE_CHANGE] = "DEVICE_CHANGE";
    RxIrpCodeToName[IRP_MJ_QUERY_QUOTA] = "QUERY_QUOTA";
    RxIrpCodeToName[IRP_MJ_SET_QUOTA] = "SET_QUOTA";
    RxIrpCodeToName[IRP_MJ_PNP_POWER] = "PNP";

}

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    )
{
    ULONG i,mask;


    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("name/num/!c %s/%lu/%lu!!\n", name, level, pointcount));

    for (i=1;i<RxMaximumTraceControl;i++) {
        PRX_DEBUG_TRACE_CONTROL control = &RxDebugTraceControl[i];
        ULONG l = strlen(name);
        //RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("----->checking %s\n",control->Name));
        if (strncmp(name,control->Name,l)) continue;
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---> got it %s/%lu/%lu !!\n", control->Name, level, pointcount));
        if (pointcount==0) {
            control->PrintLevel = level;
        } else if (pointcount <= 2) {
            if (level==0) {
                mask = 0xffffffff;
            } else {
                mask = 1 << (level-1);
            }
            if (pointcount==1) {
                control->BreakMask |= mask;
            } else {
                control->BreakMask &= ~mask;
            }
        }
    }
}

#ifdef RxDbgTraceDisableGlobally
#undef RxDbgTraceDisableGlobally
#endif
BOOLEAN
RxDbgTraceDisableGlobally(void)
{
    BOOLEAN flag = RxGlobalTraceSuppress;
    RxGlobalTraceSuppress = TRUE;
    return  flag;
}

#ifdef RxDbgTraceEnableGlobally
#undef RxDbgTraceEnableGlobally
#endif
VOID
RxDbgTraceEnableGlobally(BOOLEAN flag)
{
    RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  flag;
}


VOID
RxDebugTraceZeroAllPrintLevels(
    void
    )
{
    ULONG i;

    for (i=1;i<RxMaximumTraceControl;i++) {
        PRX_DEBUG_TRACE_CONTROL control = &RxDebugTraceControl[i];
        control->PrintLevel = 0;    // disable output
    }
}


BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
{
/*
This routine has the responsibility to determine if a particular dbgprint is going to be printed and ifso to
fiddle with the indent. so the return value is whether to print; it is also used for just fiddling with the indent
by setting the highoredr bit of the mask.

The Mask is now very complicated owing to the large number of dbgprints i'm trying to control...sigh.
The low order byte is the controlpoint....usually the file. each controlpoint has a current level associated
with it. if the level of a a debugtrace is less that then current control level then the debug is printed.
The next byte is the level of this particular call; again if the level is <= the current level for the control
you get printed. The next byte is the indent. indents are only processed if printing is done.
*/
    LONG Indent = ((NewMask>>RxDT_INDENT_SHIFT)&RxDT_INDENT_MASK) - RxDT_INDENT_EXCESS;
    LONG LevelOfThisWrite = (NewMask) & RxDT_LEVEL_MASK;
    BOOLEAN PrintIt = (NewMask&RxDT_SUPPRESS_PRINT)==0;
    BOOLEAN OverrideReturn = (NewMask&RxDT_OVERRIDE_RETURN)!=0;
    LONG _i;

    ASSERT (Indent==1 || Indent==0 || (Indent==-1));

    if (RxGlobalTraceSuppress) return FALSE;

#if 0
    if (ControlPoint!=NULL){
        ULONG ControlPointNumber = ControlPoint->ControlPointNumber;
        if (ControlPointNumber==0) {
            if (!RxDbgTraceFindControlPointActual(ControlPoint)){
                //couldnt find or initialize the control point text.....hmmmmmmmmmmm
                ASSERT(!"bad return from findcontrolpoint");
                return(FALSE);
            }
            ControlPointNumber = ControlPoint->ControlPointNumber;
        }

        ASSERT(ControlPointNumber && ControlPointNumber<=RxMaximumTraceControl);

        if (LevelOfThisWrite > RxDebugTraceControl[ControlPointNumber].PrintLevel  ) return FALSE;
    }
#else
    PrintIt = TRUE;
#endif


    if ((Indent) > 0) {
        RxDebugTraceIndent += (Indent);
    }

    if (PrintIt) {
        _i = (ULONG)((ULONG_PTR)PsGetCurrentThread());

        if (RxDebugTraceIndent < 0) {
            RxDebugTraceIndent = 0;
        }
        DbgPrint("%08lx:%-*s",_i,(int)(RxDebugTraceIndent),"");
    }

    if (Indent < 0) {
        RxDebugTraceIndent += (Indent);
    }

    ASSERT (RxDebugTraceIndent <= 0x40);

    return PrintIt||OverrideReturn;
}

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
{
    ULONG i,ControlPointNumber;
    PUCHAR name;

    ASSERT (ControlPoint);
    ControlPointNumber = ControlPoint->ControlPointNumber;

    if (ControlPointNumber) return (&RxDebugTraceControl[ControlPointNumber]);

    //otherwise, we have to look it up..........
    name = ControlPoint->Name;
    for (i=1;i<RxMaximumTraceControl;i++) {
        PRX_DEBUG_TRACE_CONTROL control = &RxDebugTraceControl[i];
        ULONG l = strlen(name);
        //RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("----->checking %s\n",control->Name));
        if (strncmp(name,control->Name,l)) continue;
        DbgPrint("Controlpointlookup=%08lx<%s> to %08lx\n",
                         ControlPoint,ControlPoint->Name,i);
        ControlPoint->ControlPointNumber = i;
        return(control);
    }
    DbgPrint("Couldn't find ControlPointName=%s...inserting\n",name);
    RxInitializeDebugTraceControlPoint(name,ControlPoint); //actually copies the name
    return (&RxDebugTraceControl[ControlPoint->ControlPointNumber]);
}

#endif // RDBSSTRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxlog.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.c

Abstract:

    This module implements the logging system used by the Rx file system.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

    Balan Sethu Raman [SethuR] 24-April-95
         Revised to conform to new log record layout.

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "prefix.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxUninitializeLog)
#pragma alloc_text(PAGE, RxInitializeLog)
#pragma alloc_text(PAGE, RxPrintLog)
#pragma alloc_text(PAGE, RxpTrackDereference)
#endif

#if !DBG
#undef RDBSSTRACE
#endif

//
//  The debug trace level
//

#define Dbg                              (0)

#define RDBSSHUGELOG

#if DBG
#define RX_LOG_BUFFER_SIZE 5000
#else
#if RDBSSLOG
#define RX_LOG_BUFFER_SIZE 500
#else
#define RX_LOG_BUFFER_SIZE 0
#endif
#endif

#define MAX_RX_LOG_BUFFER_ALLOC   (256*1024)
#define RX_LOG_MAX_MDLLIST_LENGTH 100

RX_LOG s_RxLog = {0,RX_LOG_UNINITIALIZED,NULL,NULL,NULL,0,0,0,0};

PUCHAR RxContxOperationNames[] = {
      RDBSSLOG_ASYNC_NAME_PREFIX "CREATE",    //#define IRP_MJ_CREATE                   0x00
      RDBSSLOG_ASYNC_NAME_PREFIX "CR_NMPIPE", //#define IRP_MJ_CREATE_NAMED_PIPE        0x01
      RDBSSLOG_ASYNC_NAME_PREFIX "CLOSE",     //#define IRP_MJ_CLOSE                    0x02
      RDBSSLOG_ASYNC_NAME_PREFIX "READ",      //#define IRP_MJ_READ                     0x03
      RDBSSLOG_ASYNC_NAME_PREFIX "WRITE",     //#define IRP_MJ_WRITE                    0x04
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYINFO", //#define IRP_MJ_QUERY_INFORMATION        0x05
      RDBSSLOG_ASYNC_NAME_PREFIX "SETINFO",   //#define IRP_MJ_SET_INFORMATION          0x06
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYEA",   //#define IRP_MJ_QUERY_EA                 0x07
      RDBSSLOG_ASYNC_NAME_PREFIX "SETEA",     //#define IRP_MJ_SET_EA                   0x08
      RDBSSLOG_ASYNC_NAME_PREFIX "FLUSH",     //#define IRP_MJ_FLUSH_BUFFERS            0x09
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYVOL",  //#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
      RDBSSLOG_ASYNC_NAME_PREFIX "SETVOL",    //#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
      RDBSSLOG_ASYNC_NAME_PREFIX "DIRCTRL",   //#define IRP_MJ_DIRECTORY_CONTROL        0x0c
      RDBSSLOG_ASYNC_NAME_PREFIX "FSCTL",     //#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
      RDBSSLOG_ASYNC_NAME_PREFIX "IOCTL",     //#define IRP_MJ_DEVICE_CONTROL           0x0e
      RDBSSLOG_ASYNC_NAME_PREFIX "xIOCTL",    //#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
      RDBSSLOG_ASYNC_NAME_PREFIX "SHUTDWN",   //#define IRP_MJ_SHUTDOWN                 0x10
      RDBSSLOG_ASYNC_NAME_PREFIX "LOCKCTRL",  //#define IRP_MJ_LOCK_CONTROL             0x11
      RDBSSLOG_ASYNC_NAME_PREFIX "CLEANUP",   //#define IRP_MJ_CLEANUP                  0x12
      RDBSSLOG_ASYNC_NAME_PREFIX "CR_MLSLOT", //#define IRP_MJ_CREATE_MAILSLOT          0x13
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYSCRTY",//#define IRP_MJ_QUERY_SECURITY           0x14
      RDBSSLOG_ASYNC_NAME_PREFIX "SETSCRTY",  //#define IRP_MJ_SET_SECURITY             0x15
      RDBSSLOG_ASYNC_NAME_PREFIX "QUERYPWR",  //#define IRP_MJ_QUERY_POWER              0x16
      RDBSSLOG_ASYNC_NAME_PREFIX "NOTDEFND",  //#define IRP_MJ_NOT_DEFINED              0x17
      RDBSSLOG_ASYNC_NAME_PREFIX "DVCHANGE",  //#define IRP_MJ_DEVICE_CHANGE            0x18
      RDBSSLOG_ASYNC_NAME_PREFIX "QRYQUOTA",  //#define IRP_MJ_QUERY_QUOTA              0x19
      RDBSSLOG_ASYNC_NAME_PREFIX "SETQUOTA",  //#define IRP_MJ_SET_QUOTA                0x1a
      RDBSSLOG_ASYNC_NAME_PREFIX "PNPPOWER",  //#define IRP_MJ_PNP_POWER                0x1b
      RDBSSLOG_ASYNC_NAME_PREFIX "********",  //internal init            0x1c
        "XX"
         //#define IRP_MJ_MAXIMUM_FUNCTION         0x1b
         };

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry(void)
{
    PRX_LOG_ENTRY_HEADER pEntry;
    // you have to hold the spinlock for this....

    pEntry = s_RxLog.CurrentEntry + 1;
    if (pEntry == s_RxLog.EntryLimit){
        s_RxLog.NumberOfLogWraps++;
        pEntry = s_RxLog.BaseEntry;
    }

    s_RxLog.CurrentEntry = pEntry;
    return pEntry;
}

VOID
RxUninitializeLog ()
{
    PRX_LOG_ENTRY_HEADER EntryLimit = s_RxLog.EntryLimit;
    PMDL *MdlList = (PMDL *)(EntryLimit+1);

    PAGED_CODE();

    //NOTE: none of this is happening under spinlock!
    //DbgPrint("UninitLog: mdllist=%08lx,*mdllist=%08lx\n",MdlList,*MdlList);
    //DbgBreakPoint();

    if ((s_RxLog.State == RX_LOG_UNINITIALIZED) ||
        (s_RxLog.State == RX_LOG_ERROR)) {
        return;
    }

    s_RxLog.State = RX_LOG_UNINITIALIZED;

    for (;;) {
        PMDL Mdl = *MdlList;
        PUCHAR Buffer;
        if (Mdl == NULL) break;
        Buffer = MmGetMdlVirtualAddress(Mdl);
        //DbgPrint("UninitLog: buffer=%08lx,mdl=%08lx\n",Buffer,Mdl);
        MmUnlockPages(Mdl);
        IoFreeMdl(Mdl);
        RxFreePool(Buffer);
        MdlList++;
    }

    RxFreePool(s_RxLog.BaseEntry);
    return;
};



NTSTATUS
RxInitializeLog ()
{
    ULONG NumEntries = RX_LOG_BUFFER_SIZE;
    ULONG NumEntriesLeft;
    ULONG LogSize = (NumEntries+1)*sizeof(RX_LOG_ENTRY_HEADER);
    PRX_LOG_ENTRY_HEADER BaseEntry=NULL,EntryLimit=NULL;
    PRX_LOG_ENTRY_HEADER p;
    PUCHAR NextBuffer;
    PMDL *MdlList;
    ULONG MdlListLength = RX_LOG_MAX_MDLLIST_LENGTH*sizeof(PMDL);
    ULONG MdlsLeft = RX_LOG_MAX_MDLLIST_LENGTH;
    ULONG SpaceLeft;

    PAGED_CODE();

    if (s_RxLog.State != RX_LOG_UNINITIALIZED) {
        return (STATUS_SUCCESS);
    }
    //only do this stuff once
    KeInitializeSpinLock( &s_RxLog.SpinLock );
    s_RxLog.LogBufferSizeInEntries = NumEntries;

    //first allocate the marginal index array
    BaseEntry = RxAllocatePoolWithTag(NonPagedPool,LogSize+MdlListLength,'xr');
    if (BaseEntry==NULL) {
        s_RxLog.State = RX_LOG_ERROR;
        DbgPrint("Couldn't initialize log1");
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    s_RxLog.BaseEntry = BaseEntry;
    EntryLimit = s_RxLog.EntryLimit = BaseEntry+NumEntries;
    MdlList = (PMDL *)(EntryLimit+1);
    *MdlList = 0;
    //DbgPrint("InitLog: mdllist=%08lx,*mdllist=%08lx\n",MdlList,*MdlList);

    //now allocate wspace for the actual buffers...since we may be asking for a lot
    // we allocate from pages pool and lock down.

    SpaceLeft = 0;
    for (   p=BaseEntry,NumEntriesLeft=NumEntries;
            NumEntriesLeft>0;
            p++,NumEntriesLeft--  ) {

        if (SpaceLeft<sizeof(RX_LOG_ENTRY_HEADER)) {
            PMDL Mdl = NULL;
            PUCHAR Buffer=NULL;
            NTSTATUS Status;
            ULONG AllocLength = min(MAX_RX_LOG_BUFFER_ALLOC,
                                    NumEntriesLeft*MAX_RX_LOG_ENTRY_SIZE);
            for (;;) {
                Buffer = RxAllocatePoolWithTag(PagedPool,AllocLength,'xr');
                if (Buffer) break;
                DbgPrint("InitLog: failed alloc at %08lx",AllocLength);
                if (AllocLength<PAGE_SIZE) break;
                AllocLength >>= 3;
                NumEntriesLeft = AllocLength / MAX_RX_LOG_ENTRY_SIZE;
            }
            if (Buffer==NULL) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log2");
                RxFreePool(BaseEntry);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            if (MdlsLeft==0) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log3");
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }
            Mdl = RxAllocateMdl(Buffer,AllocLength);
            if (Mdl==NULL) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log4");
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            RxProbeAndLockPages(Mdl,KernelMode,IoModifyAccess,Status);
            if (Status!=(STATUS_SUCCESS)) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log5");
                RxFreePool(Mdl);
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return Status;
            }
            //DbgPrint("InitLog: newbuf=%08lx,mdl=%08lx,alloc=%08lx\n",Buffer,Mdl,AllocLength);
            MdlsLeft--;
            *MdlList = Mdl;
            MdlList++;
            *MdlList = NULL;

            NextBuffer = MmGetSystemAddressForMdlSafe(Mdl, LowPagePriority);

            if (NextBuffer == NULL) {
                s_RxLog.State = RX_LOG_ERROR;
                DbgPrint("Couldn't initialize log5");
                MmUnlockPages(Mdl);
                RxFreePool(Mdl);
                RxFreePool(Buffer);
                RxFreePool(BaseEntry);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            SpaceLeft = AllocLength;
        }

        p->Buffer = NextBuffer;
        *((PULONG)NextBuffer) = '###';
        NextBuffer += MAX_RX_LOG_ENTRY_SIZE;
        SpaceLeft -= MAX_RX_LOG_ENTRY_SIZE;
    }

    //DbgPrint("Init Log: numeleft,nummleft=%d,%d\n",NumEntriesLeft,MdlsLeft);
    p->Buffer = (PUCHAR)IntToPtr(0xf00df00d);
    s_RxLog.State = RX_LOG_ENABLED;
    s_RxLog.CurrentEntry = EntryLimit-1;

    //DbgPrint("Init Log: exit\n");
    return((STATUS_SUCCESS));

}

VOID
_RxPauseLog ()
{
    KIRQL oldIrql;

    KeAcquireSpinLock( &s_RxLog.SpinLock, &oldIrql );

    if (s_RxLog.State == RX_LOG_ENABLED) {
       s_RxLog.State = RX_LOG_DISABLED;
    }

    KeReleaseSpinLock( &s_RxLog.SpinLock, oldIrql );
}

VOID
_RxResumeLog()
{
    KIRQL oldIrql;

    KeAcquireSpinLock( &s_RxLog.SpinLock, &oldIrql );

    if (s_RxLog.State == RX_LOG_DISABLED) {
       s_RxLog.State = RX_LOG_ENABLED;
    }

    KeReleaseSpinLock( &s_RxLog.SpinLock, oldIrql );
}

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    )
{
    //KIRQL oldIrql;
    PRX_LOG_ENTRY_HEADER LogEntry,EntryLimit;
    ULONG i=0;

    PAGED_CODE();

    RxPauseLog();

    if (EntriesToPrint==0) {
        EntriesToPrint =  RX_LOG_BUFFER_SIZE;
    }
    DbgPrint("\n\n\nLog Print: Entries = %lu \n", EntriesToPrint);

    LogEntry = s_RxLog.CurrentEntry-1;
    EntryLimit = s_RxLog.EntryLimit;
    for (;EntriesToPrint>0;EntriesToPrint--) {
        LogEntry++;
        if (LogEntry>=EntryLimit) {
            LogEntry = s_RxLog.BaseEntry;
        }
        DbgPrint("%0ld: %s\n",i++,LogEntry->Buffer);
    }

    RxResumeLog();
}


VOID
_RxLog(char *Format, ...)
{
   va_list arglist;
   KIRQL   oldIrql;
   CLONG   LogEntryLength = 0;
   BOOLEAN fLogNewEntry = TRUE;
   PRX_LOG_ENTRY_HEADER LogEntry;
   CHAR    EntryString[MAX_RX_LOG_ENTRY_SIZE];
   PCHAR   pEntryString;
   CHAR    FormatChar;
   CHAR    FieldString[MAX_RX_LOG_ENTRY_SIZE];
   ULONG   FieldLength;
   char *OriginalFormat = Format;
   ULONG BinaryArgs = 0;
   ULONG BinaryStringMask = 1;  //the first arg is always a string!!!!

   //DbgPrint("RxLog: entry\n");
   if (s_RxLog.State != RX_LOG_ENABLED) {
      return;
   }

   pEntryString = EntryString;

   va_start(arglist, Format);
   //DbgBreakPoint();

   for (;;) {
      // Copy the format string
      while ((LogEntryLength < MAX_RX_LOG_ENTRY_SIZE) &&
             ((FormatChar = *Format++) != '\0') &&
             (FormatChar != '%')) {
         if (FormatChar != '\n'){
             pEntryString[LogEntryLength++] = FormatChar;
         }
      }

      if ((LogEntryLength < MAX_RX_LOG_ENTRY_SIZE) &&
          (FormatChar == '%')) {
         if ( (*Format == 'l') || (*Format == 'w') ) {
            Format++;
         }
         switch (*Format++) {
         case 'N': //binary placement -- don't try to make it foolproof
            {
                BinaryArgs++;
                *((PULONG)(&EntryString[sizeof(ULONG)])+BinaryArgs) = (ULONG)va_arg(arglist,ULONG);
            }
            break;
         case 'S': //binary placement -- don't try to make it foolproof
            {
                BinaryArgs++;
                BinaryStringMask |= 1<<(BinaryArgs-1);
                //DbgPrint("BSM %08lx\n",BinaryStringMask);
                *((PULONG)(&EntryString[sizeof(ULONG)])+BinaryArgs) = (ULONG)va_arg(arglist,ULONG);
            }
            break;
         case 'd':
            {
              // _itoa((LONG)va_arg(arglist,LONG),FieldString,10);
              // FieldLength = strlen(FieldString);// + 1;
              // if ((LogEntryLength + FieldLength) < MAX_RX_LOG_ENTRY_SIZE) {
              //    strcpy(&pEntryString[LogEntryLength],FieldString);
              //    LogEntryLength += FieldLength;
              //    //pEntryString[LogEntryLength - 1] = ' ';
              // }
                LONG l = (LONG)va_arg(arglist,LONG);
                if ((LogEntryLength + 5) < MAX_RX_LOG_ENTRY_SIZE) {
                    pEntryString[LogEntryLength++] = 0x5;
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>0));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>8));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>16));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>24));
                }
            }
            break;
         case 'c':
            pEntryString[LogEntryLength++] = (CHAR)va_arg(arglist,char);
            break;
         case 'x':
            {
              // _itoa((LONG)va_arg(arglist,LONG),FieldString,16);
              // FieldLength = strlen(FieldString);// + 1;
              // if ((LogEntryLength + FieldLength) < MAX_RX_LOG_ENTRY_SIZE) {
              //    strcpy(&pEntryString[LogEntryLength],FieldString);
              //    LogEntryLength += FieldLength;
              //    //pEntryString[LogEntryLength - 1] = ' ';
              // }
                LONG l = (LONG)va_arg(arglist,LONG);
                if ((LogEntryLength + 5) < MAX_RX_LOG_ENTRY_SIZE) {
                    pEntryString[LogEntryLength++] = 0x4;
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>0));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>8));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>16));
                    pEntryString[LogEntryLength++] = (UCHAR)(0xff&(l>>24));
                }
            }
            break;
         case 's':
            {
               PCHAR pString = &pEntryString[LogEntryLength];
               PCHAR pArg    = (PCHAR)va_arg(arglist, PCHAR);

               ASSERT(pArg!=NULL);
               FieldLength = strlen(pArg);// + 1;
               if ((LogEntryLength + FieldLength) < MAX_RX_LOG_ENTRY_SIZE) {
                  strcpy(pString,pArg);
                  LogEntryLength += FieldLength;
                  //pEntryString[LogEntryLength - 1] = ' ';
               }
            }
            break;
         case 'Z':
            {
               PCHAR pString = &pEntryString[LogEntryLength];
               PUNICODE_STRING pArg    = (PUNICODE_STRING)va_arg(arglist, PUNICODE_STRING);
               PWCHAR Buffer;
               ULONG Length;

               //this really only works for ascii strings in unicode......
               ASSERT(pArg!=NULL);
               Buffer = pArg->Buffer;
               // Make sure the length is WCHAR aligned
               Length = (pArg->Length & ~(sizeof(WCHAR)-1));
               //DbgPrint("yaya=%08lx,%08lx,%08lx\n",pArg,Buffer,Length);
               for (;Length>0;Length-=sizeof(WCHAR)) {
                   if (LogEntryLength < MAX_RX_LOG_ENTRY_SIZE) {
                       pEntryString[LogEntryLength++] = (UCHAR)(*Buffer++);
                   } else {
                       break;
                   }
               }
               //DbgBreakPoint();
            }
            break;
         default:
            fLogNewEntry = FALSE;
            break;
         }
      } else {
         break;
      }
   }

   va_end(arglist);

   if (BinaryArgs) {
       EntryString[0] = '#';
       EntryString[1] = '>';
       EntryString[2] = '0'+(UCHAR)BinaryArgs;
       EntryString[3] = 0;
       *((PULONG)(&EntryString[sizeof(ULONG)])) = BinaryStringMask;
       LogEntryLength = MAX_RX_LOG_ENTRY_SIZE;
   }

   KeAcquireSpinLock( &s_RxLog.SpinLock, &oldIrql );

   if (fLogNewEntry) {
      s_RxLog.NumberOfLogWriteAttempts++;
      LogEntry = RxGetNextLogEntry();
   } else {
      s_RxLog.NumberOfEntriesIgnored++;
      DbgPrint("RxLog: Entry exceeds max size, not recorded <%s>\n",OriginalFormat);
      if (s_RxLog.NumberOfEntriesIgnored==1) {
          //DbgBreakPoint();
      }
   }

   KeReleaseSpinLock( &s_RxLog.SpinLock, oldIrql );

   if (fLogNewEntry) {
        BOOLEAN OutOfBounds = ((LogEntry<s_RxLog.BaseEntry) || (LogEntry>=s_RxLog.EntryLimit));
        if (OutOfBounds) {
          DbgPrint("RxLog: wrap logic has fail.....log disabled\n");
          s_RxLog.State = RX_LOG_DISABLED;
        } else {
            if (LogEntryLength >= MAX_RX_LOG_ENTRY_SIZE) {
                LogEntryLength = MAX_RX_LOG_ENTRY_SIZE;
                if (BinaryArgs == 0) {
                    pEntryString[MAX_RX_LOG_ENTRY_SIZE-1] = 0;
                }
            } else {
                pEntryString[LogEntryLength++] = 0;
            }
            RtlCopyMemory(LogEntry->Buffer,pEntryString,LogEntryLength);
        }
   }
}

#define RxToUpper(CH) ((CH)&~('A'^'a'))
#define RxIsLetter(CH) ((RxToUpper(CH)>='A') && (RxToUpper(CH)<='Z'))
#define RxIsDigit(CH) (((CH)>='0')&&((CH)<='9'))

VOID
RxDebugControlCommand (
    IN char *ControlString
    )
/*
    This routine manipulates the print and log levels and the breakpoint masks. the format is

          AAAAA+AAAAA+AAAAA+AAAAA.....

     where each AAAAA == <+-!>*<Letter>*<digit>*.

     <letter>* designates a control name.....only enuff to disambiguate is needed.

     any + turns on  tracing globally
     any % turns on  tracing globally RIGHT NOW!
     any - turns off tracing globally

     for 0 !s, it means:  for the control <letter>*, set the printlevel to <digit>*
     for 1 !s, it means:  for the control <letter>* set breakmask bit <digit>*. 0 means all bits
     for 2 !s, it means:  for the control <letter>* clear breakmask bit <digit>*. 0 means all bits
         THIS STUFF (I.E. THE ! STUFF)  IS ACTUALLY IMPLEMENTED IN RXTRACE.C

     @ means  printlog
     @@ means   pauselog
     @@@ means resumelog
     @@@@ means initialize
     @@@@@ means setup to debug by turning off printing
     more than @@@@@ means  banner


     E.G. cle0+clo0+cre1000+!devf3 sets disables printing for cleanup and close, sets the printlevel
          for create to 1000, and enables the third bit of the breakmask for devfcb.

     the letter string is upcased automatically.

     There is usually one control for each file but some controls control stuff from multiple
     files (like dispatch)
*/
{
    char namebuf[16], numbuf[16], *p, *q, *c;
    //long i;
    long level,pointcount,atsigncount;
    //DEBUG_TRACE_CONTROLS control;

    //ASSERTMSG("Here in debug command parser!\n",FALSE);
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxDebugTraceControl %s!!\n", ControlString));

    if (!ControlString)
    {
        return;
    }

    for (c = ControlString;;) {
        if (*c == 0) break;
        p=namebuf;q=numbuf; atsigncount=pointcount = 0;
        for (;(*c!=0)&&!RxIsLetter(*c)&&!RxIsDigit(*c); c++){     //skip to a letter or digit
            if (*c == '!') {
                pointcount++;
            }
            if (*c == '@') {
                atsigncount++;
            }
#if RDBSSTRACE
            if (*c == '+') {
                RxNextGlobalTraceSuppress = FALSE;
            }
            if (*c == '%') {
                RxGlobalTraceSuppress = FALSE;
            }
            if (*c == '-') {
                RxNextGlobalTraceSuppress = TRUE;
            }
#endif //RDBSSTRACE
        }
        for (p=namebuf;(*c!=0)&&RxIsLetter(*c); *p++=RxToUpper(*c++) ) ;    //copy letters
        for (level=0,q=numbuf;(*c!=0)&&RxIsDigit(*c); *q++=*c++){           //copy digits
            level = 10*level+((*c)-'0');
        }
        *p = *q = (char)0;
        {if (atsigncount>0) {
            if (atsigncount==1) {
                RxPrintLog(level);
            } else if (atsigncount == 2) {
                RxPauseLog();
            } else if (atsigncount == 3) {
                RxResumeLog();
            } else if (atsigncount == 4) {
                RxInitializeLog();
            } else if (atsigncount == 5){
#if RDBSSTRACE
                RxDebugTraceZeroAllPrintLevels();
                RxDbgTraceFindControlPoint((DEBUG_TRACE_UNWIND))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_READ))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_RXCONTX))->PrintLevel = 1000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_DISPATCH))->PrintLevel = 1000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_CREATE))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_CLEANUP))->PrintLevel = 10000;
                RxDbgTraceFindControlPoint((DEBUG_TRACE_CLOSE))->PrintLevel = 10000;
#endif
            } else {
#if RDBSSTRACE
                RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("\n\n\n\n\n %s %s\n\n\n\n\n", namebuf, numbuf));
#endif
            }
            continue;
        }}
#if RDBSSTRACE
        if (((*namebuf)==0||(*numbuf)==0)) {
            continue;
        }
        RxDebugTraceDebugCommand(namebuf,level,pointcount);
#endif
    }
    return;
}

#ifdef DBG
VOID
RxpTrackReference(
      ULONG   TraceType,
      PCHAR   FileName,
      ULONG   Line,
      PVOID   pInstance)
{
   if (REF_TRACING_ON(TraceType)) {
      ULONG RefCount;
      PCHAR pTypeName,pLogTypeName;

      switch (TraceType) {
      case RDBSS_REF_TRACK_SRVCALL :
         pTypeName    = "SrvCall";
         pLogTypeName = "SC";
         RefCount     = ((PSRV_CALL)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVCALL,RxRefSrvcall,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETROOT :
         pTypeName = "NetRoot";
         pLogTypeName = "NR";
         RefCount     = ((PNET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(NETROOT,RxRefNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_VNETROOT:
         pTypeName = "VNetRoot";
         pLogTypeName = "VN";
         RefCount     = ((PV_NET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(VNETROOT,RxRefVNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFOBX :
         pTypeName = "NetFobx";
         pLogTypeName = "FO";
         RefCount     = ((PFOBX)pInstance)->NodeReferenceCount;
         RxWmiLog(FOBX,RxRefFobx,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFCB  :
         pTypeName = "NetFcb";
         pLogTypeName = "FC";
         RefCount     = ((PFCB)pInstance)->NodeReferenceCount;
         RxWmiLog(FCB,RxRefFcb,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_SRVOPEN :
         pTypeName = "SrvOpen";
         pLogTypeName = "SO";
         RefCount     = ((PSRV_OPEN)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVOPEN,RxRefSrvOpen,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      default:
         DbgPrint("Invalid Node Type for referencing\n");
         //DbgBreakPoint();
         return;
      }

      if (RdbssReferenceTracingValue & RX_LOG_REF_TRACKING) {
         RxLog(("Ref.%s %lx %ld %lx %ld->%ld",pLogTypeName,pInstance,Line,FileName,RefCount,RefCount+1));
      }

      if (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING) {
         DbgPrint("Reference %s  %lx %ld %s\n",pTypeName,pInstance,Line,FileName);
      }
   }
}

BOOLEAN
RxpTrackDereference(
      ULONG   TraceType,
      PCHAR   FileName,
      ULONG   Line,
      PVOID   pInstance)
{
   PAGED_CODE();

   if (REF_TRACING_ON(TraceType)) {
      PCHAR pTypeName,pLogTypeName;
      ULONG RefCount;

      switch (TraceType) {
      case RDBSS_REF_TRACK_SRVCALL :
         pTypeName    = "SrvCall";
         pLogTypeName = "SC";
         RefCount     = ((PSRV_CALL)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVCALL,RxDerefSrvcall,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETROOT :
         pTypeName = "NetRoot";
         pLogTypeName = "NR";
         RefCount     = ((PNET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(NETROOT,RxDerefNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_VNETROOT:
         pTypeName = "VNetRoot";
         pLogTypeName = "VN";
         RefCount     = ((PV_NET_ROOT)pInstance)->NodeReferenceCount;
         RxWmiLog(VNETROOT,RxDerefVNetRoot,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFOBX :
         pTypeName = "NetFobx";
         pLogTypeName = "FO";
         RefCount     = ((PFOBX)pInstance)->NodeReferenceCount;
         RxWmiLog(FOBX,RxDerefFobx,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_NETFCB  :
         pTypeName = "NetFcb";
         pLogTypeName = "FC";
         RefCount     = ((PFCB)pInstance)->NodeReferenceCount;
         RxWmiLog(FCB,RxDerefFcb,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      case RDBSS_REF_TRACK_SRVOPEN :
         pTypeName = "SrvOpen";
         pLogTypeName = "SO";
         RefCount     = ((PSRV_OPEN)pInstance)->NodeReferenceCount;
         RxWmiLog(SRVOPEN,RxDerefSrvOpen,LOGPTR(pInstance)LOGULONG(RefCount)LOGULONG(Line)LOGARSTR(FileName));
         break;
      default:
         DbgPrint("Invalid Node Type for referencing\n");
         //DbgBreakPoint();
         return TRUE;
      }

      if (RdbssReferenceTracingValue & RX_LOG_REF_TRACKING) {
         RxLog(("Deref.%s %lx %ld %lx %ld->%ld",pLogTypeName,pInstance,Line,FileName,RefCount,RefCount-1));
      }

      if (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING) {
         DbgPrint("Dereference %s %lx %ld %s\n",pTypeName,pInstance,Line,FileName);
      }
   }
   return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxworkq.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxworkq.c

Abstract:

    This module implements the Work queue routines for the Rx File system.

Author:

    JoeLinn           [JoeLinn]    8-8-94   Initial Implementation

    Balan Sethu Raman [SethuR]     22-11-95 Implemented dispatch support for mini rdrs

    Balan Sethu Raman [SethuR]     20-03-96 Delinked from executive worker threads

Notes:

    There are two kinds of support for asynchronous resumption provided in the RDBSS.
    The I/O requests that cannot be completed in the context of the thread in which
    the request was made are posted to a file system process for completion.

    The mini redirectors also require support for asynchronously completing requests as
    well as post requests that cannot be completed at DPC level.

    The requests for posting from the mini redirectors are classified into Critical(blocking and
    non blocking requests. In order to ensure progress these requests are handled through
    separate resources. There is no well known mechanism to ensure that the hyper critical
    requests will not block.

    The two functions that are available to all mini redirector writers are

         RxDispatchToWorkerThread
         RxPostToWorkerThread.

    These two routines enable the mini redirector writer to make the appropriate space
    time tradeoffs. The RxDispatchToWorkerThread trades time for reduction in space by
    dynamically allocating the work item as and when required, while RxPostToWorkerThread
    trades space for time by pre allocating a work item.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeDispatcher)
#pragma alloc_text(PAGE, RxInitializeMRxDispatcher)
#pragma alloc_text(PAGE, RxSpinDownMRxDispatcher)
#pragma alloc_text(PAGE, RxInitializeWorkQueueDispatcher)
#pragma alloc_text(PAGE, RxInitializeWorkQueue)
#pragma alloc_text(PAGE, RxTearDownDispatcher)
#pragma alloc_text(PAGE, RxTearDownWorkQueueDispatcher)
#pragma alloc_text(PAGE, RxpSpinUpWorkerThreads)
#pragma alloc_text(PAGE, RxBootstrapWorkerThreadDispatcher)
#pragma alloc_text(PAGE, RxWorkerThreadDispatcher)
#endif

//
// The local debug trace level
//

#define Dbg (DEBUG_TRACE_FSP_DISPATCHER)

//
// We got the following structure from ntexapi.h. This should be moved to a 
// common header at some point.
//

#if defined(_IA64_)
typedef ULONG SYSINF_PAGE_COUNT;
#else
typedef SIZE_T SYSINF_PAGE_COUNT;
#endif

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    SYSINF_PAGE_COUNT NumberOfPhysicalPages;
    SYSINF_PAGE_COUNT LowestPhysicalPageNumber;
    SYSINF_PAGE_COUNT HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

//
// We got the following definition from zwapi.h. This should be moved to a
//  common header at some point.
//
NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation (
    IN ULONG SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

//
// had to steal this from ntifs.h in order to use ntsrv.h
//
extern POBJECT_TYPE *PsThreadType;

//
// Prototype forward declarations.
//

extern NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

extern
VOID
RxInitializeWorkQueue(
   PRX_WORK_QUEUE  pWorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG           MaximumNumberOfWorkerThreads,
   ULONG           MinimumNumberOfWorkerThreads);

extern VOID
RxTearDownWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

extern VOID
RxTearDownWorkQueue(
   PRX_WORK_QUEUE pWorkQueue);

extern NTSTATUS
RxSpinUpWorkerThread(
   PRX_WORK_QUEUE           pWorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID                    Parameter);

extern VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue);

extern VOID
RxSpinDownWorkerThreads(
   PRX_WORK_QUEUE    pWorkQueue);

extern VOID
RxpWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue,
   IN PLARGE_INTEGER pWaitInterval);

VOID
RxBootstrapWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

extern VOID
RxWorkItemDispatcher(
   PVOID    pContext);

extern VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher);

// The spin up requests thread

PETHREAD RxSpinUpRequestsThread = NULL;

//
// The delay parameter for KQUEUE wait requests in the RX_WORK_QUEUE implemenation
//

LARGE_INTEGER RxWorkQueueWaitInterval[MaximumWorkQueue];
LARGE_INTEGER RxSpinUpDispatcherWaitInterval;

//
// Currently the levels correspond to the three levels defined in ex.h
// Delayed,Critical and HyperCritical. As regards mini redirectors if any work
// is not dependent on any mini redirector/RDBSS resource, i.e., it will not wait
// it can be classified as a hypercritical1 work item. There is no good way to
// enforce this, therefore one should exercise great caution before classifying
// something as hypercritical.
//

NTSTATUS
RxInitializeDispatcher()
/*++

Routine Description:

    This routine initializes the work queues dispatcher

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

    The dispatching mechanism is implemented as a two tiered approach. Each
    processor in the system is associated with a set of work queues. A best
    effort is made to schedule all work emanating from a processor onto the
    same processor. This prevents excessive sloshing of state information from
    one processor cache to another.

    For a given processor there are three work queues corresponding to three
    levels of classification -- Delayed Work items, Critical Work items and
    Hyper Critical work items. Each of these levels is associated with a
    Kernel Queue (KQUEUE). The number of threads associated with each of these
    queues can be independently controlled.

    Currently the tuning parameters for the dispatcher are all hard coded. A
    mechanism to intialize them from the registry needs to be implemented.

    The following parameters associated with the dispatcher can be tuned ...

    1) the wait time intervals associated with the kernel queue for each level.

    2) the minimum and amximum number of worker threads associated with each
    level.

--*/
{
    ULONG    ProcessorIndex,NumberOfProcessors;
    NTSTATUS Status;

    PAGED_CODE();

    // Currently we set the number of processors to 1. In future the
    // dispatcher can be tailored to multi processor implementation
    // by appropriately initializing it as follows
    // NumberOfProcessors = KeNumberProcessors;

    NumberOfProcessors = 1;

    RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads = 0;
    RxFileSystemDeviceObject->DispatcherContext.pTearDownEvent = NULL;

    // Currently the default values for the wait intervals are set as
    // 10 seconds ( expressed in system time units of 100 ns ticks ).
    RxWorkQueueWaitInterval[DelayedWorkQueue].QuadPart       = -10 * TICKS_PER_SECOND;
    RxWorkQueueWaitInterval[CriticalWorkQueue].QuadPart      = -10 * TICKS_PER_SECOND;
    RxWorkQueueWaitInterval[HyperCriticalWorkQueue].QuadPart = -10 * TICKS_PER_SECOND;

    RxSpinUpDispatcherWaitInterval.QuadPart = -60 * TICKS_PER_SECOND;

    RxDispatcher.NumberOfProcessors = NumberOfProcessors;
    RxDispatcher.OwnerProcess       = IoGetCurrentProcess();
    RxDispatcher.pWorkQueueDispatcher = &RxDispatcherWorkQueues;

    if (RxDispatcher.pWorkQueueDispatcher != NULL) {
        for (
             ProcessorIndex = 0;
             ProcessorIndex < NumberOfProcessors;
             ProcessorIndex++
            ) {
            Status = RxInitializeWorkQueueDispatcher(
                         &RxDispatcher.pWorkQueueDispatcher[ProcessorIndex]);

            if (Status != STATUS_SUCCESS) {
                break;
            }
        }

        if (Status == STATUS_SUCCESS) {
            Status = RxInitializeMRxDispatcher(RxFileSystemDeviceObject);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        HANDLE   ThreadHandle;

        KeInitializeEvent(
            &RxDispatcher.SpinUpRequestsEvent,
            NotificationEvent,
            FALSE);

        KeInitializeEvent(
            &RxDispatcher.SpinUpRequestsTearDownEvent,
            NotificationEvent,
            FALSE);

        InitializeListHead(
            &RxDispatcher.SpinUpRequests);

        RxDispatcher.State = RxDispatcherActive;

        KeInitializeSpinLock(&RxDispatcher.SpinUpRequestsLock);

        Status = PsCreateSystemThread(
                     &ThreadHandle,
                     PROCESS_ALL_ACCESS,
                     NULL,
                     NULL,
                     NULL,
                     RxSpinUpRequestsDispatcher,
                     &RxDispatcher);

        if (NT_SUCCESS(Status)) {
            // Close the handle so the thread can die when needed
            ZwClose(ThreadHandle);
        }
    }

    return Status;
}


NTSTATUS
RxInitializeMRxDispatcher(PRDBSS_DEVICE_OBJECT pMRxDeviceObject)
/*++

Routine Description:

    This routine initializes the dispatcher context for a mini rdr

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

--*/
{
    PAGED_CODE();

    pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads = 0;
    pMRxDeviceObject->DispatcherContext.pTearDownEvent = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RxSpinDownMRxDispatcher(PRDBSS_DEVICE_OBJECT pMRxDeviceObject)
/*++

Routine Description:

    This routine tears down the dispatcher context for a mini rdr

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

--*/
{
    LONG     FinalRefCount;
    KEVENT   TearDownEvent;
    KIRQL    SavedIrql;

    PAGED_CODE();

    KeInitializeEvent(
        &TearDownEvent,
        NotificationEvent,
        FALSE);


    InterlockedIncrement(&pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads);

    pMRxDeviceObject->DispatcherContext.pTearDownEvent = &TearDownEvent;

    FinalRefCount = InterlockedDecrement(&pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads);

    if (FinalRefCount > 0) {
        KeWaitForSingleObject(
            &TearDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    } else {
        InterlockedExchangePointer(
            &pMRxDeviceObject->DispatcherContext.pTearDownEvent,
            NULL);
    }

    ASSERT(pMRxDeviceObject->DispatcherContext.pTearDownEvent == NULL);

    return STATUS_SUCCESS;
}

NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher)
/*++

Routine Description:

    This routine initializes the work queue dispatcher for a particular processor

Arguments:

    pDispatcher - Work Queue Dispatcher

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

Notes:

   For each of the work queues associated with a processor the minimum number of
   worker threads and maximum number of worker threads can be independently
   specified and tuned.

   The two factors that influence these decision are (1) the cost of spinnning up/
   spinning down worker threads and (2) the amount of resources consumed by an
   idle worker thread.

   Currently these numbers are hard coded, a desirable extension would be a mechanism
   to initialize them from a registry setting. This will enable us to tune the
   parameters easily. This has to be implemented.

--*/
{
    NTSTATUS Status;
    MM_SYSTEMSIZE SystemSize;
    ULONG MaxNumberOfCriticalWorkerThreads;
    ULONG MinNumberOfCriticalWorkerThreads;
    RTL_OSVERSIONINFOEXW OsVersion;
    SYSTEM_BASIC_INFORMATION SystemBasicInfo;
    ULONGLONG SystemMemorySize = 0;

    PAGED_CODE();

    RxInitializeWorkQueue(&pDispatcher->WorkQueue[DelayedWorkQueue],
                          DelayedWorkQueue,
                          2,
                          1);

    SystemSize = MmQuerySystemSize();

    Status = ZwQuerySystemInformation(0, // SystemBasicInformation,
                                      &SystemBasicInfo,
                                      sizeof(SystemBasicInfo),
                                      NULL);

    if (Status == STATUS_SUCCESS) {
        SystemMemorySize = ( (ULONGLONG)SystemBasicInfo.NumberOfPhysicalPages * (ULONGLONG)SystemBasicInfo.PageSize );
    }

    OsVersion.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);

    Status = RtlGetVersion( (PRTL_OSVERSIONINFOW)&(OsVersion) );

    if (Status == STATUS_SUCCESS) {

        if (SystemMemorySize == 0) {
            //
            // If we could not query the SystemMemorySize then we launch 5
            // CriticalQueue threads if this machine is a SERVER and an
            // MmLargeSystem. 
            //
            if (SystemSize == MmLargeSystem && OsVersion.wProductType == VER_NT_SERVER) {
                MaxNumberOfCriticalWorkerThreads = 10;
                MinNumberOfCriticalWorkerThreads = 5;
            } else {
                MaxNumberOfCriticalWorkerThreads = 5;
                MinNumberOfCriticalWorkerThreads = 1;
            }
        } else {
            //
            // If the SystemMemorySize (physical memory) is more than 512MB
            // and the machine is a SERVER, we launch 5 and keep a minimum
            // of 5 CriticalQueue threads. 512MB is 0x1E848000 bytes.
            //
            if ( (SystemMemorySize >= (ULONGLONG)0x1E848000) && OsVersion.wProductType == VER_NT_SERVER) {
                MaxNumberOfCriticalWorkerThreads = 10;
                MinNumberOfCriticalWorkerThreads = 5;
            } else {
                MaxNumberOfCriticalWorkerThreads = 5;
                MinNumberOfCriticalWorkerThreads = 1;
            }
        }

        RxInitializeWorkQueue(&pDispatcher->WorkQueue[CriticalWorkQueue],
                              CriticalWorkQueue,
                              MaxNumberOfCriticalWorkerThreads,
                              MinNumberOfCriticalWorkerThreads);

        RxInitializeWorkQueue(&pDispatcher->WorkQueue[HyperCriticalWorkQueue],
                              HyperCriticalWorkQueue,
                              5,
                              1);

        Status = RxSpinUpWorkerThread(&pDispatcher->WorkQueue[HyperCriticalWorkQueue],
                                      RxBootstrapWorkerThreadDispatcher,
                                      &pDispatcher->WorkQueue[HyperCriticalWorkQueue]);

    }

    if (Status == STATUS_SUCCESS) {
        for ( ; ; ) {
            if (MinNumberOfCriticalWorkerThreads == 0 || Status != STATUS_SUCCESS) {
                break;
            }
            Status = RxSpinUpWorkerThread(&pDispatcher->WorkQueue[CriticalWorkQueue],
                                          RxBootstrapWorkerThreadDispatcher,
                                          &pDispatcher->WorkQueue[CriticalWorkQueue]);
            MinNumberOfCriticalWorkerThreads--;
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = RxSpinUpWorkerThread(&pDispatcher->WorkQueue[DelayedWorkQueue],
                                      RxBootstrapWorkerThreadDispatcher,
                                      &pDispatcher->WorkQueue[DelayedWorkQueue]);
    }

    return Status;
}

VOID
RxInitializeWorkQueue(
    PRX_WORK_QUEUE   pWorkQueue,
    WORK_QUEUE_TYPE  WorkQueueType,
    ULONG            MaximumNumberOfWorkerThreads,
    ULONG            MinimumNumberOfWorkerThreads)
/*++

Routine Description:

    This routine initializes a work queue

Arguments:

    pWorkQueue - Work Queue Dispatcher

    MaximumNumberOfWorkerThreads - the upper bound on worker threads

    MinimumNumberOfWorkerThreads - the lower bound on the threads.

--*/
{
    PAGED_CODE();

    pWorkQueue->Type                  = (UCHAR)WorkQueueType;
    pWorkQueue->State                 = RxWorkQueueActive;
    pWorkQueue->SpinUpRequestPending  = FALSE;
    pWorkQueue->pRundownContext       = NULL;

    pWorkQueue->NumberOfWorkItemsDispatched     = 0;
    pWorkQueue->NumberOfWorkItemsToBeDispatched = 0;
    pWorkQueue->CumulativeQueueLength           = 0;

    pWorkQueue->NumberOfSpinUpRequests       = 0;
    pWorkQueue->MaximumNumberOfWorkerThreads = MaximumNumberOfWorkerThreads;
    pWorkQueue->MinimumNumberOfWorkerThreads = MinimumNumberOfWorkerThreads;
    pWorkQueue->NumberOfActiveWorkerThreads  = 0;
    pWorkQueue->NumberOfIdleWorkerThreads    = 0;
    pWorkQueue->NumberOfFailedSpinUpRequests = 0;
    pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse = 0;

    ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForTearDownWorkQueue,NULL,NULL);
    ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForSpinUpWorkerThread,NULL,NULL);
    ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForSpinDownWorkerThread,NULL,NULL);
    pWorkQueue->WorkQueueItemForSpinDownWorkerThread.pDeviceObject = NULL;
    pWorkQueue->WorkQueueItemForSpinUpWorkerThread.pDeviceObject = NULL;
    pWorkQueue->WorkQueueItemForTearDownWorkQueue.pDeviceObject = NULL;

    KeInitializeQueue(&pWorkQueue->Queue,MaximumNumberOfWorkerThreads);
    KeInitializeSpinLock(&pWorkQueue->SpinLock);
}

NTSTATUS
RxTearDownDispatcher()
/*++

Routine Description:

    This routine tears down the dispatcher

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate failure to initialize

--*/
{
    LONG    ProcessorIndex;
    NTSTATUS Status;

    PAGED_CODE();

    if (RxDispatcher.pWorkQueueDispatcher != NULL) {
        RxDispatcher.State = RxDispatcherInactive;

        KeSetEvent(
            &RxDispatcher.SpinUpRequestsEvent,
            IO_NO_INCREMENT,
            FALSE);

        KeWaitForSingleObject(
            &RxDispatcher.SpinUpRequestsTearDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);

        if (RxSpinUpRequestsThread != NULL) {
            if (!PsIsThreadTerminating(RxSpinUpRequestsThread)) {
                // Wait for the thread to terminate.
                KeWaitForSingleObject(
                    RxSpinUpRequestsThread,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

                ASSERT(PsIsThreadTerminating(RxSpinUpRequestsThread));
            }

            ObDereferenceObject(RxSpinUpRequestsThread);
        }

        for (
             ProcessorIndex = 0;
             ProcessorIndex < RxDispatcher.NumberOfProcessors;
             ProcessorIndex++
            ) {
            RxTearDownWorkQueueDispatcher(&RxDispatcher.pWorkQueueDispatcher[ProcessorIndex]);
        }

        //RxFreePool(RxDispatcher.pWorkQueueDispatcher);
    }

    return STATUS_SUCCESS;
}

VOID
RxTearDownWorkQueueDispatcher(
    PRX_WORK_QUEUE_DISPATCHER pDispatcher)
/*++

Routine Description:

    This routine tears dwon the work queue dispatcher for a particular processor

Arguments:

    pDispatcher - Work Queue Dispatcher

--*/
{
    PAGED_CODE();

    RxTearDownWorkQueue(
        &pDispatcher->WorkQueue[DelayedWorkQueue]);

    RxTearDownWorkQueue(
        &pDispatcher->WorkQueue[CriticalWorkQueue]);

    RxTearDownWorkQueue(
        &pDispatcher->WorkQueue[HyperCriticalWorkQueue]);
}

VOID
RxTearDownWorkQueue(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine tears down a work queue

Arguments:

    pWorkQueue - Work Queue

Notes:

   Tearing down a work queue is a more complex process when compared to initializing
   a work queue. This is because of the threads associated with the queue. In order
   to ensure that the work queue can be torn down correctly each of the threads
   associated with the queue must be spun down correctly.

   This is accomplished by changing the state of the work queue from
   RxWorkQueueActive to RxWorkQueueRundownInProgress. This prevents further requests
   from being inserted into the queue. Having done that the currently active threads
   must be spundown.

   The spinning down process is accelerated by posting a dummy work item onto the
   work queue so that the waits are immediately satisfied.

--*/
{
    KIRQL       SavedIrql;
    ULONG       NumberOfActiveThreads;
    PLIST_ENTRY pFirstListEntry,pNextListEntry;

    PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

    pRundownContext = (PRX_WORK_QUEUE_RUNDOWN_CONTEXT)
                     RxAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(RX_WORK_QUEUE_RUNDOWN_CONTEXT) +
                        pWorkQueue->MaximumNumberOfWorkerThreads * sizeof(PETHREAD),
                        RX_WORKQ_POOLTAG);

    if (pRundownContext != NULL) {
        KeInitializeEvent(
            &pRundownContext->RundownCompletionEvent,
            NotificationEvent,
            FALSE);

        pRundownContext->NumberOfThreadsSpunDown = 0;
        pRundownContext->ThreadPointers = (PETHREAD *)(pRundownContext + 1);

        KeAcquireSpinLock(&pWorkQueue->SpinLock,&SavedIrql);

        ASSERT((pWorkQueue->pRundownContext == NULL) &&
               (pWorkQueue->State == RxWorkQueueActive));

        pWorkQueue->pRundownContext = pRundownContext;
        pWorkQueue->State = RxWorkQueueRundownInProgress;

        NumberOfActiveThreads = pWorkQueue->NumberOfActiveWorkerThreads;

        KeReleaseSpinLock(&pWorkQueue->SpinLock,SavedIrql);

        if (NumberOfActiveThreads > 0) {
            pWorkQueue->WorkQueueItemForTearDownWorkQueue.pDeviceObject = RxFileSystemDeviceObject;
            InterlockedIncrement(&RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);
            ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForTearDownWorkQueue,RxSpinDownWorkerThreads,pWorkQueue);
            KeInsertQueue(&pWorkQueue->Queue,&pWorkQueue->WorkQueueItemForTearDownWorkQueue.List);

            KeWaitForSingleObject(
                &pWorkQueue->pRundownContext->RundownCompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }

        if (pRundownContext->NumberOfThreadsSpunDown > 0) {
            LONG Index = 0;

            for (
                 Index = pRundownContext->NumberOfThreadsSpunDown - 1;
                 Index >= 0;
                 Index--
                ) {
                PETHREAD pThread;

                pThread = pRundownContext->ThreadPointers[Index];

                ASSERT(pThread != NULL);

                if (!PsIsThreadTerminating(pThread)) {
                    // Wait for the thread to terminate.
                    KeWaitForSingleObject(
                        pThread,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL);

                    ASSERT(PsIsThreadTerminating(pThread));
                }

                ObDereferenceObject(pThread);
            }
        }

        RxFreePool(pRundownContext);
    }

    ASSERT(pWorkQueue->NumberOfActiveWorkerThreads == 0);

    pFirstListEntry = KeRundownQueue(&pWorkQueue->Queue);
    if (pFirstListEntry != NULL) {
        pNextListEntry = pFirstListEntry;

        do {
            PWORK_QUEUE_ITEM pWorkQueueItem;

            pWorkQueueItem = (PWORK_QUEUE_ITEM)
                             CONTAINING_RECORD(
                                 pNextListEntry,
                                 WORK_QUEUE_ITEM,
                                 List);

            pNextListEntry = pNextListEntry->Flink;

            if (pWorkQueueItem->WorkerRoutine == RxWorkItemDispatcher) {
                RxFreePool(pWorkQueueItem);
            }
        } while (pNextListEntry != pFirstListEntry);
    }
}

NTSTATUS
RxSpinUpWorkerThread(
    PRX_WORK_QUEUE             pWorkQueue,
    PRX_WORKERTHREAD_ROUTINE   Routine,
    PVOID                      Parameter)
/*++

Routine Description:

    This routine spins up a worker thread associated with the given queue.

Arguments:

    pWorkQueue - the WorkQueue instance.

    Routine    - the thread routine

    Parameter  - the thread routine parameter

Return Value:

    STATUS_SUCCESS if successful,

    otherwise appropriate error code

--*/
{
    NTSTATUS Status;
    HANDLE   ThreadHandle;
    KIRQL    SavedIrql;

    PAGED_CODE();

    KeAcquireSpinLock(&pWorkQueue->SpinLock,&SavedIrql);

    if( pWorkQueue->State == RxWorkQueueActive )
    {
        pWorkQueue->NumberOfActiveWorkerThreads++;
        Status = STATUS_SUCCESS;
        //RxLogRetail(("SpinUpWT %x %d %d\n", pWorkQueue, pWorkQueue->State, pWorkQueue->NumberOfActiveWorkerThreads ));
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
        RxLogRetail(("SpinUpWT Fail %x %d %d\n", pWorkQueue, pWorkQueue->State, pWorkQueue->NumberOfActiveWorkerThreads ));
        //DbgPrint("[dkruse] RDBSS would have crashed here without this fix!\n");
    }

    KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql );

    if( NT_SUCCESS(Status) )
    {
        Status = PsCreateSystemThread(
                     &ThreadHandle,
                     PROCESS_ALL_ACCESS,
                     NULL,
                     NULL,
                     NULL,
                     Routine,
                     Parameter);

        if (NT_SUCCESS(Status)) {
            // Close the handle so the thread can die when needed
            ZwClose(ThreadHandle);
        } else {

            // Log the inability to create a worker thread.
            RxLog(("WorkQ: %lx SpinUpStat %lx\n",pWorkQueue,Status));
            RxWmiLogError(Status,
                          LOG,
                          RxSpinUpWorkerThread,
                          LOGPTR(pWorkQueue)
                          LOGULONG(Status));


            // Change the thread count back, and set the rundown completion event if necessary
            KeAcquireSpinLock( &pWorkQueue->SpinLock, &SavedIrql );

            pWorkQueue->NumberOfActiveWorkerThreads--;
            pWorkQueue->NumberOfFailedSpinUpRequests++;

            if( (pWorkQueue->NumberOfActiveWorkerThreads == 0) &&
                (pWorkQueue->State == RxWorkQueueRundownInProgress) )
            {
                KeSetEvent(
                    &pWorkQueue->pRundownContext->RundownCompletionEvent,
                    IO_NO_INCREMENT,
                    FALSE);
            }

            RxLogRetail(("SpinUpWT Fail2 %x %d %d\n", pWorkQueue, pWorkQueue->State, pWorkQueue->NumberOfActiveWorkerThreads ));

            KeReleaseSpinLock( &pWorkQueue->SpinLock, SavedIrql );

        }
    }


    return Status;
}

VOID
RxpSpinUpWorkerThreads(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine ensures that the dispatcher is not torn down while requests
    are pending in the kernel worker threads for spin ups

Arguments:

    pWorkQueue - the WorkQueue instance.

Notes:

    There is implicit reliance on the fact that the RxDispatcher owner process
    is the same as the system process. If this is not TRUE then an alternate
    way needs to be implemented for ensuring that spinup requests are not stuck
    behind other requests.

--*/
{
    LONG NumberOfWorkerThreads;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxDispatcher.OwnerProcess);

    RxSpinUpWorkerThreads(pWorkQueue);

    NumberOfWorkerThreads = InterlockedDecrement(
                                &RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);

    if (NumberOfWorkerThreads == 0) {
        PKEVENT pTearDownEvent;

        pTearDownEvent = (PKEVENT)
                         InterlockedExchangePointer(
                             &RxFileSystemDeviceObject->DispatcherContext.pTearDownEvent,
                             NULL);

        if (pTearDownEvent != NULL) {
            KeSetEvent(
                pTearDownEvent,
                IO_NO_INCREMENT,
                FALSE);
        }
    }
}

VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher)
/*++

Routine Description:

    This routine ensures that there is an independent thread to handle spinup
    requests for all types of threads. This routine will be active as long as
    the dispatcher is active

Arguments:

    pDispatcher - the dispatcher instance.

Notes:

    There is implicit reliance on the fact that the RxDispatcher owner process
    is the same as the system process. If this is not TRUE then an alternate
    way needs to be implemented for ensuring that spinup requests are not stuck
    behind other requests.

--*/
{
    PETHREAD ThisThread;
    NTSTATUS Status;

    RxDbgTrace(0,Dbg,("+++++ Worker SpinUp Requests Thread Startup %lx\n",PsGetCurrentThread()));

    ThisThread = PsGetCurrentThread();
    Status     = ObReferenceObjectByPointer(
                     ThisThread,
                     THREAD_ALL_ACCESS,
                     *PsThreadType,
                     KernelMode);

    if (Status == STATUS_SUCCESS) {
        RxSpinUpRequestsThread = ThisThread;

        for (;;) {
            NTSTATUS            Status;
            RX_DISPATCHER_STATE State;
            KIRQL               SavedIrql;
            LIST_ENTRY          SpinUpRequests;
            PLIST_ENTRY         pListEntry;

            InitializeListHead(&SpinUpRequests);

            Status = KeWaitForSingleObject(
                         &pDispatcher->SpinUpRequestsEvent,
                         Executive,
                         KernelMode,
                         FALSE,
                         &RxSpinUpDispatcherWaitInterval);

            ASSERT((Status == STATUS_SUCCESS) || (Status == STATUS_TIMEOUT));

            KeAcquireSpinLock(
                &pDispatcher->SpinUpRequestsLock,
                &SavedIrql);

            RxTransferList(
                &SpinUpRequests,
                &pDispatcher->SpinUpRequests);

            State = pDispatcher->State;

            KeResetEvent(
                &pDispatcher->SpinUpRequestsEvent);

            KeReleaseSpinLock(
                &pDispatcher->SpinUpRequestsLock,
                SavedIrql);

            // Process the spin up requests

            while (!IsListEmpty(&SpinUpRequests)) {
                PRX_WORKERTHREAD_ROUTINE Routine;
                PVOID                    pParameter;
                PWORK_QUEUE_ITEM         pWorkQueueItem;
                PRX_WORK_QUEUE           pWorkQueue;
                LONG ItemInUse;

                pListEntry = RemoveHeadList(&SpinUpRequests);

                pWorkQueueItem = (PWORK_QUEUE_ITEM)
                                 CONTAINING_RECORD(
                                     pListEntry,
                                     WORK_QUEUE_ITEM,
                                     List);

                Routine       = pWorkQueueItem->WorkerRoutine;
                pParameter    = pWorkQueueItem->Parameter;
                pWorkQueue    = (PRX_WORK_QUEUE)pParameter;

                ItemInUse = InterlockedDecrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);

                RxLog(("WORKQ:SR %lx %lx\n", Routine, pParameter ));
                RxWmiLog(LOG,
                         RxSpinUpRequestsDispatcher,
                         LOGPTR(Routine)
                         LOGPTR(pParameter));

                Routine(pParameter);
            }

            if (State != RxDispatcherActive) {
                KeSetEvent(
                    &pDispatcher->SpinUpRequestsTearDownEvent,
                    IO_NO_INCREMENT,
                    FALSE);

                break;
            }
        }
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine spins up one or more worker thread associated with the given queue.

Arguments:

    pWorkQueue - the WorkQueue instance.

Return Value:

    STATUS_SUCCESS if successful,

    otherwise appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    HANDLE   ThreadHandle;

    LONG     NumberOfThreads;
    KIRQL    SavedIrql;
    LONG     ItemInUse;

    if ((IoGetCurrentProcess() != RxDispatcher.OwnerProcess) ||
        (KeGetCurrentIrql() != PASSIVE_LEVEL)) {

        ItemInUse = InterlockedIncrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);

        if (ItemInUse > 1) {
            // A work queue item is already on the SpinUpRequests waiting to be processed.
            // No need to post another one.
            InterlockedDecrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);
            return;
        }

        InterlockedIncrement(
            &RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);

        ExInitializeWorkItem(
            (PWORK_QUEUE_ITEM)&pWorkQueue->WorkQueueItemForSpinUpWorkerThread,
            RxpSpinUpWorkerThreads,
            pWorkQueue);

        KeAcquireSpinLock(&RxDispatcher.SpinUpRequestsLock, &SavedIrql);

        InsertTailList(
            &RxDispatcher.SpinUpRequests,
            &pWorkQueue->WorkQueueItemForSpinUpWorkerThread.List);

        KeSetEvent(
            &RxDispatcher.SpinUpRequestsEvent,
            IO_NO_INCREMENT,
            FALSE);

        KeReleaseSpinLock(&RxDispatcher.SpinUpRequestsLock,SavedIrql);
    } else {
        // Decide on the number of worker threads that need to be spun up.
        KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

        if( pWorkQueue->State != RxWorkQueueRundownInProgress )
        {
            NumberOfThreads = pWorkQueue->MaximumNumberOfWorkerThreads -
                              pWorkQueue->NumberOfActiveWorkerThreads;

            if (NumberOfThreads > pWorkQueue->NumberOfWorkItemsToBeDispatched) {
                NumberOfThreads = pWorkQueue->NumberOfWorkItemsToBeDispatched;
            }
        }
        else
        {
            // We're running down, so don't increment
            NumberOfThreads = 0;
            //DbgPrint( "[dkruse] Preventing rundown!\n" );
        }

        pWorkQueue->SpinUpRequestPending  = FALSE;

        KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

        while (NumberOfThreads-- > 0) {
            Status = RxSpinUpWorkerThread(
                         pWorkQueue,
                         RxWorkerThreadDispatcher,
                         pWorkQueue);

            if (Status != STATUS_SUCCESS) {
                break;
            }
        }

        if (Status != STATUS_SUCCESS) {
            ItemInUse = InterlockedIncrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);

            if (ItemInUse > 1) {
                // A work queue item is already on the SpinUpRequests waiting to be processed.
                // No need to post another one.
                InterlockedDecrement(&pWorkQueue->WorkQueueItemForSpinUpWorkerThreadInUse);
                return;
            }

            ExInitializeWorkItem(
                (PWORK_QUEUE_ITEM)&pWorkQueue->WorkQueueItemForSpinUpWorkerThread,
                RxpSpinUpWorkerThreads,
                pWorkQueue);

            KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

            pWorkQueue->SpinUpRequestPending  = TRUE;

            KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

            KeAcquireSpinLock(&RxDispatcher.SpinUpRequestsLock, &SavedIrql);

            // An attempt to spin up a worker thread failed. Reschedule the
            // requests to attempt this operation later.

            InterlockedIncrement(
                &RxFileSystemDeviceObject->DispatcherContext.NumberOfWorkerThreads);

            InsertTailList(
                &RxDispatcher.SpinUpRequests,
                &pWorkQueue->WorkQueueItemForSpinUpWorkerThread.List);

            KeReleaseSpinLock(&RxDispatcher.SpinUpRequestsLock,SavedIrql);
        }
    }
}

VOID
RxSpinDownWorkerThreads(
    PRX_WORK_QUEUE    pWorkQueue)
/*++

Routine Description:

    This routine spins down one or more worker thread associated with the given queue.

Arguments:

    pWorkQueue - the WorkQueue instance.

--*/
{
    KIRQL    SavedIrql;
    BOOLEAN  RepostSpinDownRequest = FALSE;

    // Decide on the number of worker threads that need to be spun up.
    KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

    if (pWorkQueue->NumberOfActiveWorkerThreads > 1) {
        RepostSpinDownRequest = TRUE;
    }

    KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

    if (RepostSpinDownRequest) {
        if (pWorkQueue->WorkQueueItemForSpinDownWorkerThread.pDeviceObject == NULL) {
            pWorkQueue->WorkQueueItemForSpinDownWorkerThread.pDeviceObject = RxFileSystemDeviceObject;
        }

        ExInitializeWorkItem(&pWorkQueue->WorkQueueItemForSpinDownWorkerThread,RxSpinDownWorkerThreads,pWorkQueue);
        KeInsertQueue(&pWorkQueue->Queue,&pWorkQueue->WorkQueueItemForSpinDownWorkerThread.List);
    }
}

BOOLEAN DumpDispatchRoutine = FALSE;

VOID
RxpWorkerThreadDispatcher(
    IN PRX_WORK_QUEUE pWorkQueue,
    IN PLARGE_INTEGER pWaitInterval)
/*++

Routine Description:

    This routine dispatches a work item and frees the associated work item

Arguments:

     pWorkQueue - the WorkQueue instance.

     pWaitInterval - the interval for waiting on the KQUEUE.

--*/
{
    NTSTATUS                 Status;
    PLIST_ENTRY              pListEntry;
    PRX_WORK_QUEUE_ITEM      pWorkQueueItem;
    PRX_WORKERTHREAD_ROUTINE Routine;
    PVOID                    pParameter;
    BOOLEAN                  SpindownThread,DereferenceThread;
    KIRQL                    SavedIrql;
    PETHREAD                 ThisThread;

    RxDbgTrace(0,Dbg,("+++++ Worker Thread Startup %lx\n",PsGetCurrentThread()));

    InterlockedIncrement(&pWorkQueue->NumberOfIdleWorkerThreads);

    ThisThread = PsGetCurrentThread();
    Status     = ObReferenceObjectByPointer(
                     ThisThread,
                     THREAD_ALL_ACCESS,
                     *PsThreadType,
                     KernelMode);

    ASSERT(Status == STATUS_SUCCESS);

    SpindownThread    = FALSE;
    DereferenceThread = FALSE;

    for (;;) {
        pListEntry = KeRemoveQueue(
                         &pWorkQueue->Queue,
                         KernelMode,
                         pWaitInterval);

        if ((NTSTATUS)(ULONG_PTR)pListEntry != STATUS_TIMEOUT) {
            LONG                 FinalRefCount;
            PRDBSS_DEVICE_OBJECT pMRxDeviceObject;

            InterlockedIncrement(&pWorkQueue->NumberOfWorkItemsDispatched);
            InterlockedDecrement(&pWorkQueue->NumberOfWorkItemsToBeDispatched);
            InterlockedDecrement(&pWorkQueue->NumberOfIdleWorkerThreads);

            InitializeListHead(pListEntry);

            pWorkQueueItem = (PRX_WORK_QUEUE_ITEM)
                              CONTAINING_RECORD(
                                  pListEntry,
                                  RX_WORK_QUEUE_ITEM,
                                  List);

            pMRxDeviceObject = pWorkQueueItem->pDeviceObject;

            // This is a regular work item. Invoke the routine in the context of
            // a try catch block.

            Routine       = pWorkQueueItem->WorkerRoutine;
            pParameter    = pWorkQueueItem->Parameter;

            // Reset the fields in the Work item.

            ExInitializeWorkItem(pWorkQueueItem,NULL,NULL);
            pWorkQueueItem->pDeviceObject = NULL;

            RxDbgTrace(0, Dbg, ("RxWorkerThreadDispatcher Routine(%lx) Parameter(%lx)\n",Routine,pParameter));
            //RxLog(("WORKQ:Ex Dev(%lx) %lx %lx\n", pMRxDeviceObject,Routine, pParameter ));
            //RxWmiLog(LOG,
            //         RxpWorkerThreadDispatcher,
            //         LOGPTR(pMRxDeviceObject)
            //         LOGPTR(Routine)
            //         LOGPTR(pParameter));

            Routine(pParameter);

            FinalRefCount = InterlockedDecrement(&pMRxDeviceObject->DispatcherContext.NumberOfWorkerThreads);

            if (FinalRefCount == 0) {
                PKEVENT pTearDownEvent;

                pTearDownEvent = (PKEVENT)
                                 InterlockedExchangePointer(
                                     &pMRxDeviceObject->DispatcherContext.pTearDownEvent,
                                     NULL);

                if (pTearDownEvent != NULL) {
                    KeSetEvent(
                        pTearDownEvent,
                        IO_NO_INCREMENT,
                        FALSE);
                }
            }

            InterlockedIncrement(&pWorkQueue->NumberOfIdleWorkerThreads);
        }

        KeAcquireSpinLock(&pWorkQueue->SpinLock,&SavedIrql);

        switch (pWorkQueue->State) {
        case RxWorkQueueActive:
            {
                if (pWorkQueue->NumberOfWorkItemsToBeDispatched > 0) {
                    // Delay spinning down a worker thread till the existing work
                    // items have been dispatched.
                    break;
                }
            }
            // lack of break intentional.
            // Ensure that the number of idle threads is not more than the
            // minimum number of worker threads permitted for the work queue
        case RxWorkQueueInactive:
            {
                ASSERT(pWorkQueue->NumberOfActiveWorkerThreads > 0);

                if (pWorkQueue->NumberOfActiveWorkerThreads >
                    pWorkQueue->MinimumNumberOfWorkerThreads) {
                    SpindownThread = TRUE;
                    DereferenceThread = TRUE;
                    InterlockedDecrement(&pWorkQueue->NumberOfActiveWorkerThreads);
                }
            }
            break;

        case RxWorkQueueRundownInProgress:
            {
                PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

                pRundownContext = pWorkQueue->pRundownContext;

                // The work queue is no longer active. Spin down all the worker
                // threads associated with the work queue.

                ASSERT(pRundownContext != NULL);

                pRundownContext->ThreadPointers[pRundownContext->NumberOfThreadsSpunDown++] = ThisThread;

                InterlockedDecrement(&pWorkQueue->NumberOfActiveWorkerThreads);

                SpindownThread    = TRUE;
                DereferenceThread = FALSE;

                if (pWorkQueue->NumberOfActiveWorkerThreads == 0) {
                    KeSetEvent(
                        &pWorkQueue->pRundownContext->RundownCompletionEvent,
                        IO_NO_INCREMENT,
                        FALSE);
                }
            }
            break;

        default:
            ASSERT(!"Valid State For Work Queue");
        }

        if (SpindownThread) {
            InterlockedDecrement(&pWorkQueue->NumberOfIdleWorkerThreads);
        }

        KeReleaseSpinLock(&pWorkQueue->SpinLock,SavedIrql);

        if (SpindownThread) {
            RxDbgTrace(0,Dbg,("----- Worker Thread Exit %lx\n",PsGetCurrentThread()));
            break;
        }
    }

    if (DereferenceThread) {
        ObDereferenceObject(ThisThread);
    }

    if (DumpDispatchRoutine) {
        // just to keep them around on free build for debug purpose
        DbgPrint("Dispatch routine %lx %lx %lx\n",Routine,pParameter,pWorkQueueItem);
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

VOID
RxBootstrapWorkerThreadDispatcher(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine is for worker threads that use a infinite time interval
    for waiting on the KQUEUE data structure. These threads cannot be throtled
    back and are used for ensuring that the bare minimum number of threads
    are always active ( primarily startup purposes )

Arguments:

     pWorkQueue - the WorkQueue instance.

--*/
{
    PAGED_CODE();

    RxpWorkerThreadDispatcher(pWorkQueue,NULL);
}

VOID
RxWorkerThreadDispatcher(
    PRX_WORK_QUEUE pWorkQueue)
/*++

Routine Description:

    This routine is for worker threads that use a finite time interval to wait
    on the KQUEUE data structure. Such threads have a self regulatory mechanism
    built in which causes them to spin down if the work load eases off. The
    time interval is based on the type of the work queue

Arguments:

     pWorkQueue - the WorkQueue instance.

--*/
{
    PAGED_CODE();

    RxpWorkerThreadDispatcher(
        pWorkQueue,
        &RxWorkQueueWaitInterval[pWorkQueue->Type]);
}

NTSTATUS
RxInsertWorkQueueItem(
    PRDBSS_DEVICE_OBJECT pDeviceObject,
    WORK_QUEUE_TYPE      WorkQueueType,
    PRX_WORK_QUEUE_ITEM  pWorkQueueItem)
/*++

Routine Description:

    This routine inserts a work item into the appropriate queue.

Arguments:

     pDeviceObject  - the device object

     WorkQueueType  - the type of work item

     pWorkQueueItem - the work queue item

Return Value:

     STATUS_SUCCESS                -- successful

     other status codes indicate error conditions

         STATUS_INSUFFICIENT_RESOURCES -- could not dispatch

Notes:

    This routine inserts the work item into the appropriate queue and spins
    up a worker thread if required.

    There are some extensions to this routine that needs to be implemented. These
    have been delayed in order to get an idea of the costs and the benefits of
    the various tradeoffs involved.

    The current implementation follows a very simple logic in queueing work
    from the various sources onto the same processor from which it originated.
    The benefits associated with this approach are the prevention of cache/state
    sloshing as the work is moved around from one processor to another. The
    undesirable charecterstic is the skewing of work load on the various processors.

    The important question that needs to be answered is when is it beneficial to
    sacrifice the affinity to a processor. This depends upon the workload associated
    with the current processor and the amount of information associated with the
    given processor. The later is more difficult to determine.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    KIRQL    SavedIrql;

    BOOLEAN  SpinUpWorkerThread = FALSE;
    ULONG    ProcessorNumber;

    // If the dispatcher were on a per processor basis the ProcessorNumber
    // would be indx for accessing the dispatcher data structure
    // ProcessorNumber = KeGetCurrentProcessorNumber();

    PRX_WORK_QUEUE_DISPATCHER pWorkQueueDispatcher;
    PRX_WORK_QUEUE            pWorkQueue;

    ProcessorNumber = 0;

    pWorkQueueDispatcher = &RxDispatcher.pWorkQueueDispatcher[ProcessorNumber];
    pWorkQueue           = &pWorkQueueDispatcher->WorkQueue[WorkQueueType];

    if (RxDispatcher.State != RxDispatcherActive)
    {
        return STATUS_UNSUCCESSFUL;
    }

    KeAcquireSpinLock(&pWorkQueue->SpinLock, &SavedIrql);

    if ((pWorkQueue->State == RxWorkQueueActive) &&
        (pDeviceObject->DispatcherContext.pTearDownEvent == NULL)) {
        pWorkQueueItem->pDeviceObject = pDeviceObject;
        InterlockedIncrement(&pDeviceObject->DispatcherContext.NumberOfWorkerThreads);

        pWorkQueue->CumulativeQueueLength += pWorkQueue->NumberOfWorkItemsToBeDispatched;
        InterlockedIncrement(&pWorkQueue->NumberOfWorkItemsToBeDispatched);

        if ((pWorkQueue->NumberOfIdleWorkerThreads < pWorkQueue->NumberOfWorkItemsToBeDispatched) &&
            (pWorkQueue->NumberOfActiveWorkerThreads < pWorkQueue->MaximumNumberOfWorkerThreads) &&
            (!pWorkQueue->SpinUpRequestPending)) {
            pWorkQueue->SpinUpRequestPending = TRUE;
            SpinUpWorkerThread = TRUE;
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    KeReleaseSpinLock(&pWorkQueue->SpinLock, SavedIrql);

    if (Status == STATUS_SUCCESS) {
        KeInsertQueue(&pWorkQueue->Queue,&pWorkQueueItem->List);

        if (SpinUpWorkerThread) {
            RxSpinUpWorkerThreads(
                pWorkQueue);
        }
    } else {
        RxWmiLogError(Status,
                      LOG,
                      RxInsertWorkQueueItem,
                      LOGPTR(pDeviceObject)
                      LOGULONG(WorkQueueType)
                      LOGPTR(pWorkQueueItem)
                      LOGUSTR(pDeviceObject->DeviceName));
    }

    return Status;
}

VOID
RxWorkItemDispatcher(
    PVOID    pContext)
/*++

Routine Description:

    This routine serves as a wrapper for dispatching a work item and for
    performing the related cleanup actions

Arguments:

     pContext   - the Context parameter that is passed to the driver routine.

Notes:

    There are two cases of dispatching to worker threads. When an instance is going to
    be repeatedly dispatched time is conserved by allocating the WORK_QUEUE_ITEM as
    part of the data structure to be dispatched. On the other hand if it is a very
    infrequent operation space can be conserved by dynamically allocating and freeing
    memory for the work queue item. This tradesoff time for space.

    This routine implements a wrapper for those instances in which time was traded
    off for space. It invokes the desired routine and frees the memory.

--*/
{
    PRX_WORK_DISPATCH_ITEM   pDispatchItem;
    PRX_WORKERTHREAD_ROUTINE Routine;
    PVOID                    Parameter;

    pDispatchItem = (PRX_WORK_DISPATCH_ITEM)pContext;

    Routine   = pDispatchItem->DispatchRoutine;
    Parameter = pDispatchItem->DispatchRoutineParameter;

    //RxLog(("WORKQ:Ds %lx %lx\n", Routine, Parameter ));
    //RxWmiLog(LOG,
    //         RxWorkItemDispatcher,
    //         LOGPTR(Routine)
    //         LOGPTR(Parameter));

    Routine(Parameter);

    RxFreePool(pDispatchItem);
}

NTSTATUS
RxDispatchToWorkerThread(
    IN OUT PRDBSS_DEVICE_OBJECT       pMRxDeviceObject,
    IN     WORK_QUEUE_TYPE            WorkQueueType,
    IN     PRX_WORKERTHREAD_ROUTINE   Routine,
    IN     PVOID                      pContext)
/*++

Routine Description:

    This routine invokes the routine in the context of a worker thread.

Arguments:

     pMRxDeviceObject - the device object of the corresponding mini redirector

     WorkQueueType    - the type of the work queue

     Routine          - routine to be invoked

     pContext         - the Context parameter that is passed to the driver routine.

Return Value:

     STATUS_SUCCESS                -- successful

     STATUS_INSUFFICIENT_RESOURCES -- could not dispatch

Notes:

    There are two cases of dispatching to worker threads. When an instance is going to
    be repeatedly dispatched time is conserved by allocating the WORK_QUEUE_ITEM as
    part of the data structure to be dispatched. On the other hand if it is a very
    infrequent operation space can be conserved by dynamically allocating and freeing
    memory for the work queue item. This tradesoff time for space.

--*/
{
    NTSTATUS               Status;
    PRX_WORK_DISPATCH_ITEM pDispatchItem;
    KIRQL                  SavedIrql;

    pDispatchItem = RxAllocatePoolWithTag(
                        NonPagedPool,
                        sizeof(RX_WORK_DISPATCH_ITEM),
                        RX_WORKQ_POOLTAG);

    if (pDispatchItem != NULL) {
        pDispatchItem->DispatchRoutine          = Routine;
        pDispatchItem->DispatchRoutineParameter = pContext;

        ExInitializeWorkItem(
            &pDispatchItem->WorkQueueItem,
            RxWorkItemDispatcher,
            pDispatchItem);

        Status = RxInsertWorkQueueItem(pMRxDeviceObject,WorkQueueType,&pDispatchItem->WorkQueueItem);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status != STATUS_SUCCESS) {
        if (pDispatchItem != NULL) {
            RxFreePool(pDispatchItem);
        }

        RxLog(("WORKQ:Queue(D) %ld %lx %lx %lx\n", WorkQueueType,Routine,pContext,Status));
        RxWmiLogError(Status,
                      LOG,
                      RxDispatchToWorkerThread,
                      LOGULONG(WorkQueueType)
                      LOGPTR(Routine)
                      LOGPTR(pContext)
                      LOGULONG(Status));
    }

    return Status;
}

NTSTATUS
RxPostToWorkerThread(
    IN OUT PRDBSS_DEVICE_OBJECT       pMRxDeviceObject,
    IN     WORK_QUEUE_TYPE            WorkQueueType,
    IN OUT PRX_WORK_QUEUE_ITEM        pWorkQueueItem,
    IN     PRX_WORKERTHREAD_ROUTINE   Routine,
    IN     PVOID                      pContext)
/*++

Routine Description:

    This routine invokes the routine in the context of a worker thread.

Arguments:

     WorkQueueType - the priority of the task at hand.

     WorkQueueItem - the work queue item

     Routine       - routine to be invoked

     pContext      - the Context parameter that is passed to the driver routine.

Return Value:

     STATUS_SUCCESS                -- successful

     STATUS_INSUFFICIENT_RESOURCES -- could not dispatch

Notes:

    There are two cases of dispatching to worker threads. When an instance is going to
    be repeatedly dispatched time is conserved by allocating the WORK_QUEUE_ITEM as
    part of the data structure to be dispatched. On the other hand if it is a very
    infrequent operation space can be conserved by dynamically allocating and freeing
    memory for the work queue item. This tradesoff time for space.

--*/
{
    NTSTATUS Status;

    ExInitializeWorkItem( pWorkQueueItem,Routine,pContext );
    Status = RxInsertWorkQueueItem(pMRxDeviceObject,WorkQueueType,pWorkQueueItem);

    if (Status != STATUS_SUCCESS) {
        RxLog(("WORKQ:Queue(P) %ld %lx %lx %lx\n", WorkQueueType,Routine,pContext,Status));
        RxWmiLogError(Status,
                      LOG,
                      RxPostToWorkerThread,
                      LOGULONG(WorkQueueType)
                      LOGPTR(Routine)
                      LOGPTR(pContext)
                      LOGULONG(Status));
    }

    return Status;
}


PEPROCESS
RxGetRDBSSProcess()
{
   return RxData.OurProcess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\rxtdi.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxtdi.h

Abstract:

    This is the include file that defines all the Transport driver related
    functions that the rest of the connection engine relies on. these have to
    be implemented across all OS platforms.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

--*/

#ifndef _RXTDI_H_
#define _RXTDI_H_

#include "nb30.h" // NETBIOS specific data structures

//
// Some of these routines should be made inlines. The number of them that need to be made
// inline is a space/time tradeoff that could very well be different across OS platforms.
// As a first cut in order to facilitate debugging all of these routines have not been inlined.
//

extern ULONG
ComputeTransportAddressLength(
    PTRANSPORT_ADDRESS pTransportAddress);

extern NTSTATUS
RxTdiBindToTransport(
    IN OUT PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxTdiUnbindFromTransport(
    IN OUT PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxTdiOpenAddress(
    IN     PRXCE_TRANSPORT    pTransport,
    IN     PTRANSPORT_ADDRESS pTransportAddress,
    IN OUT PRXCE_ADDRESS      pAddress);

extern NTSTATUS
RxTdiCloseAddress(
    IN OUT PRXCE_ADDRESS   pAddress);

extern NTSTATUS
RxTdiSetEventHandlers(
    IN PRXCE_TRANSPORT pTransport,
    IN PRXCE_ADDRESS   pAddress);


#define RXCE_QUERY_BROADCAST_ADDRESS        TDI_QUERY_BROADCAST_ADDRESS
#define RXCE_QUERY_PROVIDER_INFORMATION     TDI_QUERY_PROVIDER_INFORMATION
#define RXCE_QUERY_PROVIDER_INFO            TDI_QUERY_PROVIDER_INFO
#define RXCE_QUERY_ADDRESS_INFO             TDI_QUERY_ADDRESS_INFO
#define RXCE_QUERY_CONNECTION_INFO          TDI_QUERY_CONNECTION_INFO
#define RXCE_QUERY_PROVIDER_STATISTICS      TDI_QUERY_PROVIDER_STATISTICS
#define RXCE_QUERY_DATAGRAM_INFO            TDI_QUERY_DATAGRAM_INFO
#define RXCE_QUERY_DATA_LINK_ADDRESS        TDI_QUERY_DATA_LINK_ADDRESS
#define RXCE_QUERY_NETWORK_ADDRESS          TDI_QUERY_NETWORK_ADDRESS
#define RXCE_QUERY_MAX_DATAGRAM_INFO        TDI_QUERY_MAX_DATAGRAM_INFO

extern NTSTATUS
RxTdiQueryInformation(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection,
    IN PRXCE_VC         pVc,
    IN ULONG            QueryType,
    IN PVOID            QueryBuffer,
    IN ULONG            QueryBufferLength);

extern NTSTATUS
RxTdiQueryAdapterStatus(
    IN     PRXCE_TRANSPORT pTransport,
    IN OUT PADAPTER_STATUS pAdapterStatus);

extern NTSTATUS
RxTdiConnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN     PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc);

extern NTSTATUS
RxTdiInitiateAsynchronousConnect(
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters);

extern NTSTATUS
RxTdiCancelAsynchronousConnect(
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters);

extern NTSTATUS
RxTdiCleanupAsynchronousConnect(
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters);

extern NTSTATUS
RxTdiReconnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN     PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc);

//
// Disconnect options
//

#define RXCE_DISCONNECT_ABORT   TDI_DISCONNECT_ABORT
#define RXCE_DISCONNECT_RELEASE TDI_DISCONNECT_RELEASE
#define RXCE_DISCONNECT_WAIT    TDI_DISCONNECT_WAIT
#define RXCE_DISCONNECT_ASYNC   TDI_DISCONNECT_ASYNC

extern NTSTATUS
RxTdiDisconnect(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection,
    IN PRXCE_VC         pVc,
    IN ULONG            DisconnectFlags);

extern NTSTATUS
RxTdiCancelConnect(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection);

extern NTSTATUS
RxTdiSend(
    IN PRXCE_TRANSPORT   pTransport,
    IN PRXCE_ADDRESS     pAddress,
    IN PRXCE_CONNECTION  pConnection,
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
RxTdiSendDatagram(
    IN PRXCE_TRANSPORT              pTransport,
    IN PRXCE_ADDRESS                pAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

#endif // _RXTDI_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\shadow.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    shadow.c

Abstract:

    This module contains the code that implements local read/write operations for shadow
    FCB

Author:

    Ahmed Mohamed (ahmedm) 15-Dec-2001

Environment:

    Kernel mode

Revision History:


--*/
#include "precomp.h"
#pragma hdrstop

//
//  define this so that rdbsstrace flag works, just use the lowio one since shadow is part of it
//

#define Dbg                              (DEBUG_TRACE_LOWIO)

#define RxGetShadowSrvOpenContext(SrvOpen) ((PMRXSHADOW_SRV_OPEN) (SrvOpen)->ShadowContext)

#define RxShadowLockKeyLock(LowIoContext, ShadowCtx)    (LowIoContext->ParamsFor.Locks.Key)
#define RxShadowLockKey(LowIoContext, ShadowCtx)        (LowIoContext->ParamsFor.ReadWrite.Key)

typedef struct {
    PIRP Irp;
    BOOLEAN Cancelable;
    LONG Refcnt;
} RX_SHADOW_CONTEXT, *PRX_SHADOW_CONTEXT;

extern PETHREAD RxSpinUpRequestsThread;

NTSTATUS
RxShadowVerifyIoParameters(
    PDEVICE_OBJECT DeviceObject,
    PFILE_OBJECT FileObject,
    PVOID Buffer,
    ULONG Length,
    PLARGE_INTEGER FileOffset
    )
{

    if (!FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {
        return STATUS_SUCCESS;
    }

    //
    //  The file was opened without intermediate buffering enabled.
    //  Check that the Buffer is properly aligned, and that the
    //  length is an integral number of the block size.
    //

    if ((DeviceObject->SectorSize &&
         (Length & (DeviceObject->SectorSize - 1))) ||
        ((ULONG_PTR)Buffer & DeviceObject->AlignmentRequirement)) {

        //
        // Check for sector sizes that are not a power of two.
        //

        if ((DeviceObject->SectorSize && (Length % DeviceObject->SectorSize)) ||
            ((ULONG_PTR)Buffer & DeviceObject->AlignmentRequirement)) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  If a ByteOffset parameter was specified, ensure that it is
    //  is of the proper type.
    //

    if ((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
        (FileOffset->HighPart == -1)) {

        NOTHING;

    } else if ((FileOffset->LowPart == FILE_USE_FILE_POINTER_POSITION) &&
               (FileOffset->HighPart == -1) &&
               FlagOn( FileObject->Flags,  FO_SYNCHRONOUS_IO )) {

        NOTHING;

    } else if (DeviceObject->SectorSize &&
               (FileOffset->LowPart & (DeviceObject->SectorSize - 1))) {

        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RxShadowBuildAsynchronousRequest (
    IN PIRP OriginalIrp,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN PRX_CONTEXT RxContext,
    IN PMRXSHADOW_SRV_OPEN LocalSrvOpen,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Arg,
    OUT PIRP *Irp
    )
/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request (RxContext->MajorFunction) must be one of the following request
    codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_DIRECTORY_CONTROL
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN (not yet implemented)


Arguments:

    RxContext - The RDBSS context.

    CompletionRoutine - The Irp CompletionRoutine.

Return Value:

    The return status of the operation.

--*/
{
    PIRP NewIrp;
    PIO_STACK_LOCATION IrpSp;
    ULONG MajorFunction = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    LONG Length;

    *Irp = NULL;

    if ((MajorFunction != IRP_MJ_READ) &&
        (MajorFunction != IRP_MJ_WRITE) &&
        (MajorFunction != IRP_MJ_LOCK_CONTROL)) {

        return STATUS_NOT_SUPPORTED;
    }

    IF_DEBUG {
        PFOBX Fobx = (PFOBX)RxContext->pFobx;

        ASSERT( Fobx != NULL );
        ASSERT( Fobx->pSrvOpen == RxContext->pRelevantSrvOpen );
    }

    NewIrp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!NewIrp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    NewIrp->Tail.Overlay.Thread = RxSpinUpRequestsThread; //PsGetCurrentThread();
    NewIrp->Tail.Overlay.OriginalFileObject = FileObject;
    NewIrp->RequestorMode = KernelMode;
    NewIrp->AssociatedIrp.SystemBuffer = (PVOID)NULL;

    //
    //  Get a pointer to the stack location of the first driver which will be
    //  invoked. This is where the function codes and the parameters are set.
    //

    IrpSp = IoGetNextIrpStackLocation( NewIrp );
    IrpSp->MajorFunction = (UCHAR) MajorFunction;
    IrpSp->MinorFunction = 0;
    IrpSp->FileObject = FileObject;
    IrpSp->DeviceObject = DeviceObject;

    if (CompletionRoutine != NULL) {

        IoSetCompletionRoutine( NewIrp,
                                CompletionRoutine,
                                Arg,
                                TRUE,
                                TRUE,
                                TRUE );
    }

    NewIrp->Flags = 0;
    SetFlag( NewIrp->Flags, FlagOn( OriginalIrp->Flags, IRP_SYNCHRONOUS_API | IRP_NOCACHE ) );

    if (MajorFunction == IRP_MJ_LOCK_CONTROL) {

        //
        //  We need to tag the lock flag
        //

        FileObject->LockOperation = TRUE;

        IrpSp->MinorFunction = RxContext->MinorFunction;
        IrpSp->Flags = (UCHAR)LowIoContext->ParamsFor.Locks.Flags;
        IrpSp->Parameters.LockControl.Length = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
        IrpSp->Parameters.LockControl.Key = RxShadowLockKeyLock( LowIoContext, LocalSrvOpen );
        IrpSp->Parameters.LockControl.ByteOffset.QuadPart = LowIoContext->ParamsFor.Locks.ByteOffset;
        NewIrp->Tail.Overlay.AuxiliaryBuffer = OriginalIrp->Tail.Overlay.AuxiliaryBuffer;

        *Irp = NewIrp;

        return STATUS_SUCCESS;
    }
    //
    //  if file is opened with no intermediate bufffering then set no cache flag
    //

    if (FlagOn( FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {
        SetFlag( NewIrp->Flags, IRP_NOCACHE );
    }

    Length = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    if (MajorFunction == IRP_MJ_WRITE) {

        if (FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {
            IrpSp->Flags = SL_WRITE_THROUGH;
        }

        IrpSp->Parameters.Write.ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
        IrpSp->Parameters.Write.Length = Length;
        IrpSp->Parameters.Write.Key = RxShadowLockKey( LowIoContext, LocalSrvOpen );

    } else {

        IrpSp->Parameters.Read.ByteOffset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
        IrpSp->Parameters.Read.Length = Length;
        IrpSp->Parameters.Read.Key = RxShadowLockKey( LowIoContext, LocalSrvOpen );
    }

    NewIrp->UserBuffer = OriginalIrp->UserBuffer;
    NewIrp->MdlAddress = RxContext->LowIoContext.ParamsFor.ReadWrite.Buffer;
    if (NewIrp->MdlAddress != NULL) {

        NewIrp->UserBuffer = MmGetMdlVirtualAddress( NewIrp->MdlAddress );

        if (FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP )) {

            //
            //  we must map the mdl into system address space and use the system address instead
            //

            NewIrp->UserBuffer = MmGetSystemAddressForMdlSafe( NewIrp->MdlAddress, NormalPagePriority );

            //
            //  we need to zap out the mdl address, otherwise the filesystem complains that the
            //  userbuffer and the mdl startva are not the same
            //

            NewIrp->MdlAddress = NULL;
        }
    }

    //
    //  Finally, return a pointer to the IRP.
    //

    *Irp = NewIrp;

    return STATUS_SUCCESS;
}

NTSTATUS
RxShadowCommonCompletion (
    PRX_CONTEXT RxContext,
    PIRP Irp,
    NTSTATUS Status,
    ULONG_PTR Information
    )
{
    PRX_SHADOW_CONTEXT Context;
    BOOLEAN SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    //
    // Clear the MDL address from the IRP if it is a re-use of our own.  Do this before completion
    // so we can successfully read the Buffer MDL from the LOWIO_CONTEXT
    //
    if ( (Irp->MdlAddress == RxContext->LowIoContext.ParamsFor.ReadWrite.Buffer) &&     
         ( (RxContext->MajorFunction == IRP_MJ_READ) ||
           (RxContext->MajorFunction == IRP_MJ_WRITE) ) ) {
        Irp->MdlAddress = NULL;
    }

    //
    //  we need to synch with cancel
    //

    Context = (PRX_SHADOW_CONTEXT)RxContext->MRxContext;
    if (Context->Cancelable) {
        KIRQL   SavedIrql;

        KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

        Irp = Context->Irp;
        if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {

            RxContext->MRxCancelRoutine = NULL;
            Context->Irp = NULL;

        } else {

            LONG x;

            //
            //  cancel thread must have a reference on the Irp so we don't free it now but
            //  on the actual cancel call
            //

            x = InterlockedDecrement( &Context->Refcnt );
            if (x > 0) {
                Irp = NULL;
            } else {

                //
                //  we could have already got cancelled and we need to let the others we are done
                //

                Context->Irp = NULL;
            }
        }
        KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );
    }

    RxContext->StoredStatus = Status;
    RxContext->InformationToReturn += Information;

    if (SynchronousIo) {

        //
        //  Signal the thread that is waiting after queuing the workitem on the
        //  KQueue.
        //

        RxSignalSynchronousWaiter( RxContext );

    } else {

        RxLowIoCompletion( RxContext );
    }

    if (Irp != NULL) {

        if (Irp->MdlAddress) {
            PMDL mdl,nextMdl;

            for (mdl = Irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
                nextMdl = mdl->Next;
                MmUnlockPages( mdl );
            }

            for (mdl = Irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
                nextMdl = mdl->Next;
                IoFreeMdl( mdl );
            }

            Irp->MdlAddress = NULL;
        }

        //
        // We are done with this Irp, so free it.
        //

        IoFreeIrp( Irp );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
RxShadowIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp OPTIONAL,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownIrp is completed.

Arguments:

    DeviceObject - The device object in play.

    CalldownIrp -

    Context -

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;

    RxShadowCommonCompletion( RxContext,
                              CalldownIrp,
                              CalldownIrp->IoStatus.Status,
                              CalldownIrp->IoStatus.Information );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
RxShadowCancelRoutine(
    PRX_CONTEXT RxContext
    )
{

    KIRQL SavedIrql;
    PIRP Irp;
    LONG x;
    PRX_SHADOW_CONTEXT Context;

    Irp = NULL;

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    Context = (RX_SHADOW_CONTEXT *) RxContext->MRxContext;
    Irp = Context->Irp;
    if (Irp != NULL) {

        //
        //  io hasn't completed yet
        //

        InterlockedIncrement( &Context->Refcnt );

        //
        //  need to clear the Irp field
        //

        Context->Irp = NULL;
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (Irp != NULL) {

        IoCancelIrp(Irp);
        x = InterlockedDecrement( &Context->Refcnt );
        if (x == 0) {

            if (Irp->MdlAddress) {
                PMDL mdl,nextMdl;

                for (mdl = Irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
                    nextMdl = mdl->Next;
                    MmUnlockPages( mdl );
                }

                for (mdl = Irp->MdlAddress; mdl != NULL; mdl = nextMdl) {
                    nextMdl = mdl->Next;
                    IoFreeMdl( mdl );
                }

                Irp->MdlAddress = NULL;
            }

            IoFreeIrp( Irp );
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RxShadowIoHandler (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN BOOLEAN Cancelable
    )
/*++

Routine Description:

   This routine is common to guys who use the async context engine. It has the
   responsibility for getting a context, initing, starting and finalizing it,
   but the internal guts of the procesing is via the continuation routine
   that is passed in.

Arguments:

    RxContext  - The RDBSS context.

    Irp - The original irp

    Fcb -  The fcb io is being done on

    Cancelable -  Can the irp be cancelled


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PMRXSHADOW_SRV_OPEN LocalSrvOpen;
    PLOWIO_CONTEXT LowIoContext = &(RxContext->LowIoContext);
    PIRP TopIrp = NULL;
    BOOLEAN SynchronousIo;
    PIRP ShadowIrp = NULL;

    LocalSrvOpen = RxGetShadowSrvOpenContext( RxContext->pRelevantSrvOpen );

    //
    //  We are in, issue the I/O
    //

    SynchronousIo = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    if (LocalSrvOpen->UnderlyingFileObject != NULL) {

        PDEVICE_OBJECT DeviceObject;
        PFILE_OBJECT FileObject;

        DeviceObject = LocalSrvOpen->UnderlyingDeviceObject;
        FileObject = LocalSrvOpen->UnderlyingFileObject;


        if (SynchronousIo) {
            KeInitializeEvent( &RxContext->SyncEvent, NotificationEvent, FALSE );
        }

        Status = RxShadowBuildAsynchronousRequest( Irp,
                                                   DeviceObject,
                                                   FileObject,
                                                   Fcb,
                                                   RxContext,
                                                   LocalSrvOpen,
                                                   RxShadowIrpCompletion,
                                                   (PVOID) RxContext,
                                                   &ShadowIrp );

        if (Status == STATUS_SUCCESS) {

            PRX_SHADOW_CONTEXT Context;

            Context = (PRX_SHADOW_CONTEXT)RxContext->MRxContext;

            ASSERT( sizeof( *Context ) <= sizeof( RxContext->MRxContext ));

            //
            //  save new Irp if we want to resume later
            //

            Context->Irp = ShadowIrp;
            Context->Cancelable = Cancelable;
            Context->Refcnt = 1;

            try {

                //
                // Save the TopLevel Irp.
                //

                TopIrp = IoGetTopLevelIrp();

                //
                // Tell the underlying guy he's all clear.
                //

                IoSetTopLevelIrp( NULL );

                Status = IoCallDriver( DeviceObject, ShadowIrp );

            } finally {

                //
                // Restore my context for unwind.
                //

                IoSetTopLevelIrp( TopIrp );

            }

            if (Cancelable == TRUE) {

                KIRQL SavedIrql;

                TopIrp = NULL;

                KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );
                if ((Context->Irp != NULL) &&
                    !FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_CANCELLED )) {

                    //
                    //  io is still pending and hasn't been cancelled
                    //

                    RxContext->MRxCancelRoutine = RxShadowCancelRoutine;

                } else if (Context->Irp != NULL) {

                    //
                    //  io is already cancelled
                    //

                    TopIrp = Context->Irp;

                    //
                    //  we need to clear the Irp field
                    //
                    Context->Irp = NULL;

                    //
                    //  we need to take an extra reference
                    //

                    InterlockedIncrement( &Context->Refcnt );
                }


                KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

                if (TopIrp != NULL) {

                    LONG x;

                    IoCancelIrp( TopIrp );
                    x = InterlockedDecrement( &Context->Refcnt );
                    if (x == 0) {
                        if (TopIrp->MdlAddress) {
                            TopIrp->MdlAddress = NULL;
                        }
                        IoFreeIrp( TopIrp );
                    }
                }
            }

            if (SynchronousIo) {
                RxWaitSync( RxContext );
                Status = RxContext->StoredStatus;
            } else {
                Status = STATUS_PENDING;
            }
        }

    } else {
        Status = STATUS_VOLUME_DISMOUNTED;
    }

    return Status;
}


NTSTATUS
RxShadowFastLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    PMRXSHADOW_SRV_OPEN MrxShadowSrvOpen;
    PLOWIO_CONTEXT LowIoContext = &(RxContext->LowIoContext);
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    LARGE_INTEGER Offset;
    BOOLEAN Wait, PagingIo;
    IO_STATUS_BLOCK Ios;
    PVOID Buffer;
    PIRP TopIrp;

    //
    //  we only support read and write
    //

    if ((LowIoContext->Operation != LOWIO_OP_READ) && (LowIoContext->Operation != LOWIO_OP_WRITE)) {
        return Status;
    }

    //
    //  don't deal with name pipes
    //

    if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION )) {
        return Status;
    }

    //
    //  check for locks and take default path
    //

    if (IrpSp->FileObject && IrpSp->FileObject->LockOperation) {
        return Status;
    }

    PagingIo = BooleanFlagOn( LowIoContext->ParamsFor.ReadWrite.Flags, LOWIO_READWRITEFLAG_PAGING_IO );

    MrxShadowSrvOpen = RxGetShadowSrvOpenContext( RxContext->pRelevantSrvOpen );

    //
    // The only time we can get PagingIo write on a loopback file is if the
    // file has been memory mapped.
    //

    //
    // We don't handle PagingIo read and no-buffering handles through fast
    // path. PagingIo write is tried through the fast path and if it does
    // not succeed then we return STATUS_MORE_PROCESSING_REQUIRED.
    //

    if ((PagingIo && LowIoContext->Operation == LOWIO_OP_READ) ||
        (MrxShadowSrvOpen == NULL) ||
        (MrxShadowSrvOpen->UnderlyingFileObject == NULL ) ||
        (IrpSp->FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {

        return Status;
    }

    Offset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

    //
    //  get user buffer
    //

    if (!FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP )) {
        Buffer = Irp->UserBuffer;
    } else {
        ASSERT( LowIoContext->ParamsFor.ReadWrite.Buffer != NULL );
        Buffer = RxLowIoGetBufferAddress( RxContext );
    }

    //
    // Check shadow state and io params.
    //

    if (RxShadowVerifyIoParameters( MrxShadowSrvOpen->UnderlyingDeviceObject,
                                    IrpSp->FileObject,
                                    Buffer,
                                    LowIoContext->ParamsFor.ReadWrite.ByteCount,
                                    &Offset) != STATUS_SUCCESS) {
        return Status;
    }

    Wait = !BooleanFlagOn( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );

    if (PagingIo) {
        ASSERT(LowIoContext->Operation == LOWIO_OP_WRITE);
        Wait = FALSE;
    }

    //
    // Save the TopLevel Irp.
    //

    TopIrp = IoGetTopLevelIrp();

    //
    // Tell the underlying guy he's all clear.
    //

    IoSetTopLevelIrp( NULL );

    try {
        if ((LowIoContext->Operation == LOWIO_OP_READ) &&
            (MrxShadowSrvOpen->FastIoRead != NULL) &&
            MrxShadowSrvOpen->FastIoRead(MrxShadowSrvOpen->UnderlyingFileObject,
                         &Offset,
                         LowIoContext->ParamsFor.ReadWrite.ByteCount,
                         Wait,
                         RxShadowLockKey( LowIoContext, MrxShadowSrvOpen ),
                         Buffer,
                         &Ios,
                         MrxShadowSrvOpen->UnderlyingDeviceObject )) {

            //
            //  the fast io path worked
            //

            Irp->IoStatus = Ios;
            RxContext->StoredStatus = Ios.Status;
            RxContext->InformationToReturn += Ios.Information;
            Status = Ios.Status;

        } else if ((LowIoContext->Operation == LOWIO_OP_WRITE) &&
                   (MrxShadowSrvOpen->FastIoWrite != NULL) &&
                   MrxShadowSrvOpen->FastIoWrite(MrxShadowSrvOpen->UnderlyingFileObject,
                            &Offset,
                            LowIoContext->ParamsFor.ReadWrite.ByteCount,
                            Wait,
                            RxShadowLockKey(LowIoContext, MrxShadowSrvOpen),
                            Buffer,
                            &Ios,
                            MrxShadowSrvOpen->UnderlyingDeviceObject )) {

            //
            // The fast io path worked.
            //

            Irp->IoStatus = Ios;
            RxContext->StoredStatus = Ios.Status;
            RxContext->InformationToReturn += Ios.Information;
            Status = Ios.Status;
        }
    }  except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // TODO: Should we fall through to the slow path on an exception?
        //

        Status = GetExceptionCode();
    }

    if (Status != STATUS_SUCCESS && PagingIo) {
        ASSERT(LowIoContext->Operation == LOWIO_OP_WRITE);
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    //  Restore my context for unwind.
    //
    IoSetTopLevelIrp( TopIrp );

    return Status;
}

NTSTATUS
RxShadowLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    PMRXSHADOW_SRV_OPEN MrxShadowSrvOpen;
    PLOWIO_CONTEXT LowIoContext = &(RxContext->LowIoContext);
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    LARGE_INTEGER   Offset;
    PVOID Buffer;

    //
    //  we only support read and write and lock
    //

    if ((LowIoContext->Operation != LOWIO_OP_READ) &&
        (LowIoContext->Operation != LOWIO_OP_WRITE) &&
        (RxContext->MajorFunction != IRP_MJ_LOCK_CONTROL)) {

        return Status;
    }

    //
    //  don't deal with name pipes
    //

    if (FlagOn( RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION )) {
        return Status;
    }

    MrxShadowSrvOpen = RxGetShadowSrvOpenContext( RxContext->pRelevantSrvOpen );

    if ((MrxShadowSrvOpen == NULL) ||
        (MrxShadowSrvOpen->UnderlyingFileObject == NULL)) {

        return Status;
    }

    //
    //  if min-rdr wants to handle shadow io then pass call down
    //

    if (MrxShadowSrvOpen->DispatchRoutine) {
        return MrxShadowSrvOpen->DispatchRoutine( RxContext );
    }

    if ((LowIoContext->Operation == LOWIO_OP_READ) ||
        (LowIoContext->Operation == LOWIO_OP_WRITE)) {

        Offset.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;

        //
        //  if we have no mdl then use the user buffer directly
        //

        if (!LowIoContext->ParamsFor.ReadWrite.Buffer) {
            Buffer = Irp->UserBuffer;
        } else {
            Buffer = RxLowIoGetBufferAddress( RxContext );
        }

        //
        //  check shadow state and io params
        //

        Status = RxShadowVerifyIoParameters( MrxShadowSrvOpen->UnderlyingDeviceObject,
                                             IrpSp->FileObject,
                                             Buffer,
                                             LowIoContext->ParamsFor.ReadWrite.ByteCount,
                                             &Offset );
        if (Status != STATUS_SUCCESS) {

            //
            //  don't return status more processing required here in order to enforce proper
            //  alignment. Note, if the user has the file locked the server can't help it anyway.
            //
            return Status;
        }
    }

    Status = RxShadowIoHandler( RxContext, Irp, Fcb, RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL ? TRUE : FALSE );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\scavengr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    scavengr.c

Abstract:

    This module implements the scavenging routines in RDBSS.


Author:

    Balan Sethu Raman     [SethuR]    9-sep-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  only one of these!
//

KMUTEX RxScavengerMutex;  

VOID
RxScavengerFinalizeEntries (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

PRDBSS_DEVICE_OBJECT
RxGetDeviceObjectOfInstance (
    PVOID pInstance
    );

VOID
RxScavengerTimerRoutine (
    PVOID Context
    ); 


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxPurgeFobxFromCache)
#pragma alloc_text(PAGE, RxMarkFobxOnCleanup)
#pragma alloc_text(PAGE, RxMarkFobxOnClose)
#pragma alloc_text(PAGE, RxPurgeFobx)
#pragma alloc_text(PAGE, RxInitializePurgeSyncronizationContext)
#pragma alloc_text(PAGE, RxPurgeRelatedFobxs)
#pragma alloc_text(PAGE, RxPurgeAllFobxs)
#pragma alloc_text(PAGE, RxGetDeviceObjectOfInstance)
#pragma alloc_text(PAGE, RxpMarkInstanceForScavengedFinalization)
#pragma alloc_text(PAGE, RxpUndoScavengerFinalizationMarking)
#pragma alloc_text(PAGE, RxScavengeVNetRoots)
#pragma alloc_text(PAGE, RxScavengeRelatedFobxs)
#pragma alloc_text(PAGE, RxScavengeAllFobxs)
#pragma alloc_text(PAGE, RxScavengerFinalizeEntries)
#pragma alloc_text(PAGE, RxScavengerTimerRoutine)
#pragma alloc_text(PAGE, RxTerminateScavenging)
#endif

//
//  Local debug trace level
//

#define Dbg  (DEBUG_TRACE_SCAVENGER)

#define RxAcquireFcbScavengerMutex(FcbScavenger)               \
        RxAcquireScavengerMutex();                              \
        SetFlag((FcbScavenger)->State, RX_SCAVENGER_MUTEX_ACQUIRED )

#define RxReleaseFcbScavengerMutex(FcbScavenger)                  \
        ClearFlag((FcbScavenger)->State, RX_SCAVENGER_MUTEX_ACQUIRED ); \
        RxReleaseScavengerMutex()

#define RX_SCAVENGER_FINALIZATION_TIME_INTERVAL (10 * 1000 * 1000 * 10)

NTSTATUS
RxPurgeFobxFromCache (
    PFOBX Fobx
    )
/*++

Routine Description:

    This routine purges an FOBX for which a close is pending

Arguments:

    Fobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    This routine unlike the one that follows does not attempt to force the
    operations from the memory manager. It merely purges the underlying FCB
    from the cache

    The FOBX must have been referenced on entry to this routine and it will
    lose that reference on exit.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PFCB Fcb = Fobx->SrvOpen->Fcb;

    PAGED_CODE();

    ASSERT( Fcb != NULL );
    Status = RxAcquireExclusiveFcb( NULL, Fcb );

    if (Status == STATUS_SUCCESS) {
        
        BOOLEAN Result;

        RxReferenceNetFcb( Fcb );

        if (!FlagOn( Fobx->Flags, FOBX_FLAG_SRVOPEN_CLOSED ) &&
            (Fobx->SrvOpen->UncleanFobxCount == 0))  {

            Status = RxPurgeFcbInSystemCache( Fcb,
                                              NULL,
                                              0,
                                              FALSE,
                                              TRUE );

        } else {
            
            RxLog(( "Skipping Purging %lx\n", Fobx ));
            RxWmiLog( LOG,
                      RxPurgeFobxFromCache,
                      LOGPTR( Fobx ) );
        }

        RxDereferenceNetFobx( Fobx, LHS_ExclusiveLockHeld );

        if (!RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE )) {
            RxReleaseFcb( NULL, Fcb );
        }
    } else {
        RxDereferenceNetFobx( Fobx, LHS_LockNotHeld );
    }

    return Status;
}

VOID
RxMarkFobxOnCleanup (
    PFOBX Fobx,
    PBOOLEAN NeedPurge
    )
/*++

Routine Description:

    Thie routine marks a FOBX for special processing on cleanup

Arguments:

    Fobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.

    Only diskfile type fobxs are placed on the delayed-close list.

--*/
{
    PAGED_CODE();

    if (Fobx != NULL) {
        
        PFCB Fcb = (PFCB)Fobx->SrvOpen->Fcb;
        PLIST_ENTRY ListEntry;
        PRDBSS_DEVICE_OBJECT RxDeviceObject;
        PRDBSS_SCAVENGER RxScavenger;

        PFOBX FobxToBePurged = NULL;

        ASSERT( NodeTypeIsFcb( Fcb ));
        
        RxDeviceObject = Fcb->RxDeviceObject;
        RxScavenger = RxDeviceObject->pRdbssScavenger;

        RxAcquireScavengerMutex();

        if ((NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) || 
            (Fcb->VNetRoot->NetRoot->DeviceType != FILE_DEVICE_DISK)) {

            //
            //  the markfobxatclose will want to remove this from a list. just fix up
            //  the list pointers and get out
            //

            SetFlag( Fobx->Flags, FOBX_FLAG_MARKED_AS_DORMANT );
            InitializeListHead( &Fobx->ClosePendingList );
            RxScavenger->NumberOfDormantFiles += 1;
        
        } else {

            // 
            //  Ensure that the limit of dormant files specified for the given server is
            //  not exceeded. If the limit will be exceeded pick an entry from the
            //  list of files that are currently dormant and purge it.
            //

            ASSERT( RxScavenger->NumberOfDormantFiles >= 0 );
            
            if (RxScavenger->NumberOfDormantFiles >= RxScavenger->MaximumNumberOfDormantFiles) {

                //
                //  If the number of dormant files exceeds the limit specified for the
                //  given server a currently dormant file needs to be picked up for
                //  purging.
                //

                ListEntry = RxScavenger->ClosePendingFobxsList.Flink;
                if (ListEntry != &RxScavenger->ClosePendingFobxsList) {
                    
                    FobxToBePurged = (PFOBX)(CONTAINING_RECORD( ListEntry,
                                                                FOBX,
                                                                ClosePendingList ));

                    if ((FobxToBePurged->SrvOpen != NULL) &&
                        (FobxToBePurged->SrvOpen->Fcb == Fcb)) {

                        //
                        //  The first FOBX in the close pending list and the one about to be
                        //  inserted share the same FCB. Instaed of removing the first one
                        //  a purge is forced on the current FOBX. This avoids the resource
                        //  release/acquire that would have been required otherwise
                        //

                        *NeedPurge = TRUE;
                        FobxToBePurged = NULL;
                    
                    } else {
                        
                        RxReferenceNetFobx( FobxToBePurged );
                    }
                }
            }

            SetFlag( Fobx->Flags, FOBX_FLAG_MARKED_AS_DORMANT );

            InsertTailList( &RxScavenger->ClosePendingFobxsList, &Fobx->ClosePendingList);

            if (RxScavenger->NumberOfDormantFiles == 0) {
                BOOLEAN PostTimerRequest;

                if (RxScavenger->State == RDBSS_SCAVENGER_INACTIVE) {
                    
                    RxScavenger->State = RDBSS_SCAVENGER_DORMANT;
                    PostTimerRequest  = TRUE;

                } else {
                    
                    PostTimerRequest = FALSE;
                }

                if (PostTimerRequest) {
                    
                    LARGE_INTEGER TimeInterval;

                    //
                    //  Post a one shot timer request for scheduling the scavenger after a
                    //  predetermined amount of time.
                    //

                    TimeInterval.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;

                    RxPostOneShotTimerRequest( RxFileSystemDeviceObject,
                                               &RxScavenger->WorkItem,
                                               RxScavengerTimerRoutine,
                                               RxDeviceObject,
                                               TimeInterval );
                }
            }

            RxScavenger->NumberOfDormantFiles += 1;
        }

        RxReleaseScavengerMutex();

        if (FobxToBePurged != NULL) {
            
            NTSTATUS Status;

            Status = RxPurgeFobxFromCache( FobxToBePurged );

            if (Status != STATUS_SUCCESS) {
                *NeedPurge = TRUE;
            }
        }
    }
}

VOID
RxMarkFobxOnClose (
    PFOBX Fobx
    )
/*++

Routine Description:

    This routine undoes the marking done on cleanup

Arguments:

    Fobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.


--*/
{
    PAGED_CODE();

    if (Fobx != NULL) {
        
        PFCB Fcb = Fobx->SrvOpen->Fcb;
        PRDBSS_DEVICE_OBJECT RxDeviceObject;
        PRDBSS_SCAVENGER RxScavenger;

        ASSERT( NodeTypeIsFcb( Fcb ));
        
        RxDeviceObject = Fcb->RxDeviceObject;
        RxScavenger = RxDeviceObject->pRdbssScavenger;

        RxAcquireScavengerMutex();

        if (FlagOn( Fobx->Flags, FOBX_FLAG_MARKED_AS_DORMANT )) {
            
            if (!Fobx->fOpenCountDecremented) {
                
                InterlockedDecrement( &Fcb->OpenCount );
                Fobx->fOpenCountDecremented = TRUE;
            }

            InterlockedDecrement( &RxScavenger->NumberOfDormantFiles );
            ClearFlag( Fobx->Flags, FOBX_FLAG_MARKED_AS_DORMANT );
        }

        if (!IsListEmpty( &Fobx->ClosePendingList )) {
            
            RemoveEntryList( &Fobx->ClosePendingList );
            InitializeListHead( &Fobx->ClosePendingList );
        }

        RxReleaseScavengerMutex();
    }
}

BOOLEAN
RxPurgeFobx (
   PFOBX Fobx
   )
/*++

Routine Description:

    This routine purges an FOBX for which a close is pending

Arguments:

    Fobx -- the FOBX instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.


--*/
{
    NTSTATUS Status;
    PFCB Fcb = Fobx->SrvOpen->Fcb;

    PAGED_CODE();

    Status = RxAcquireExclusiveFcb( NULL, Fcb );

    ASSERT( Status == STATUS_SUCCESS );

    //
    //  Carry out the purge operation
    //

    Status = RxPurgeFcbInSystemCache( Fcb,
                                      NULL,
                                      0,
                                      FALSE,
                                      TRUE );

    RxReleaseFcb( NULL, Fcb );

    if (Status != STATUS_SUCCESS) {
        
        RxLog(( "PurgeFobxCCFail %lx %lx %lx", Fobx, Fcb, FALSE ));
        RxWmiLog( LOG,
                  RxPurgeFobx_1,
                  LOGPTR( Fobx )
                  LOGPTR( Fcb ) );
        return FALSE;
    }

    //
    //  try to flush the image section....it may fail
    //

    if (!MmFlushImageSection( &Fcb->NonPaged->SectionObjectPointers, MmFlushForWrite )) {
        
        RxLog(( "PurgeFobxImFail %lx %lx %lx", Fobx, Fcb, FALSE ));
        RxWmiLog( LOG,
                  RxPurgeFobx_2,
                  LOGPTR( Fobx )
                  LOGPTR( Fcb ) );
        return FALSE;
    }

    //
    //  try to flush the user data sections section....it may fail
    //

    if (!MmForceSectionClosed( &Fcb->NonPaged->SectionObjectPointers, TRUE )) {
        
        RxLog(( "PurgeFobxUsFail %lx %lx %lx", Fobx, Fcb, FALSE ));
        RxWmiLog( LOG,
                  RxPurgeFobx_3,
                  LOGPTR( Fobx )
                  LOGPTR( Fcb ) );
        return FALSE;
    }

    RxLog(( "PurgeFobx %lx %lx %lx", Fobx, Fcb, TRUE ));
    RxWmiLog( LOG,
              RxPurgeFobx_4,
              LOGPTR( Fobx )
              LOGPTR( Fcb ) );
    return TRUE;
}

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT Context
    )
/*++

Routine Description:

    This routine inits a purge synchronization context

Arguments:

    Context - synchronization context

Notes:

--*/

{
    PAGED_CODE();

    InitializeListHead( &Context->ContextsAwaitingPurgeCompletion );
    Context->PurgeInProgress = FALSE;
}

VOID
RxSynchronizeWithScavenger (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )
/*++

Routine Description:

    This routine synchronizes the current thread with any scavenger finalization
    occuring on the current fcb 

Arguments:

    RxContext - 

Notes:

--*/
{
    NTSTATUS Status;
    BOOLEAN ReacquireFcbLock = FALSE;

    PRDBSS_SCAVENGER RxScavenger = Fcb->RxDeviceObject->pRdbssScavenger;

    RxAcquireScavengerMutex();

    if ((RxScavenger->CurrentScavengerThread != PsGetCurrentThread()) &&
        (RxScavenger->CurrentFcbForClosePendingProcessing == Fcb)) {

        ReacquireFcbLock = TRUE;
        RxReleaseFcb( RxContext, Fcb );

        while (RxScavenger->CurrentFcbForClosePendingProcessing == Fcb) {
            
            RxReleaseScavengerMutex();

            KeWaitForSingleObject( &(RxScavenger->ClosePendingProcessingSyncEvent),
                                   Executive,
                                   KernelMode,
                                   TRUE,
                                   NULL);

            RxAcquireScavengerMutex();
        }
    }

    RxReleaseScavengerMutex();

    if (ReacquireFcbLock) {
        Status = RxAcquireExclusiveFcb( RxContext, Fcb );
        ASSERT( Status == STATUS_SUCCESS );
    }
}

NTSTATUS
RxPurgeRelatedFobxs (
    PNET_ROOT NetRoot,
    PRX_CONTEXT RxContext,
    BOOLEAN AttemptFinalize,
    PFCB PurgingFcb
    )
/*++

Routine Description:

    This routine purges all the FOBX's associated with a NET_ROOT

Arguments:

    NetRoot -- the NET_ROOT for which the FOBX's need to be purged

    RxContext -- the RX_CONTEXT instance

Notes:

    At cleanup there are no more user handles associated with the file object.
    In such cases the time window between close and clanup is dictated by the
    additional references maintained by the memory manager / cache manager.

    On cleanup the FOBX is put on a close pending list and removed from it
    when the corresponding list when a close operation is received. In the interim
    if an OPEN is failing with ACCESS_DENIED status then the RDBSS can force a
    purge.

    This is a synchronous operation.

--*/
{
    BOOLEAN  ScavengerMutexAcquired = FALSE;
    NTSTATUS Status;
    ULONG FobxsSuccessfullyPurged = 0;
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeContext;
    LIST_ENTRY FailedToPurgeFobxList;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;
    PLIST_ENTRY ListEntry = NULL;

    PAGED_CODE();

    PurgeContext = &NetRoot->PurgeSyncronizationContext;
    InitializeListHead( &FailedToPurgeFobxList );

    RxAcquireScavengerMutex();

    //
    //  If the purge operation for this net root is currently under way hold
    //  this request till it completes else initiate the operation after
    //  updating the state of the net root.
    //

    if (PurgeContext->PurgeInProgress) {
        
        InsertTailList( &PurgeContext->ContextsAwaitingPurgeCompletion, 
                        &RxContext->RxContextSerializationQLinks );

        RxReleaseScavengerMutex();

        RxWaitSync( RxContext );

        RxAcquireScavengerMutex();
    }

    PurgeContext->PurgeInProgress = TRUE;
    RxWmiLog( LOG,
              RxPurgeRelatedFobxs_3,
              LOGPTR( RxContext )
              LOGPTR( NetRoot ) );

    while (RxScavenger->CurrentNetRootForClosePendingProcessing == NetRoot) {
        
        RxReleaseScavengerMutex();

        KeWaitForSingleObject( &(RxScavenger->ClosePendingProcessingSyncEvent),
                               Executive,
                               KernelMode,
                               TRUE,
                               NULL );

        RxAcquireScavengerMutex();
    }

    ScavengerMutexAcquired = TRUE;

    //
    //  An attempt should be made to purge all the FOBX's that had a close
    //  pending before the purge request was received.
    //
    
    for (;;) {
        PFOBX Fobx;
        PFCB Fcb;
        BOOLEAN PurgeResult;

        Fobx = NULL;
        ListEntry = RxScavenger->ClosePendingFobxsList.Flink;

        while (ListEntry != &RxScavenger->ClosePendingFobxsList) {
            
            PFOBX TempFobx;

            TempFobx = (PFOBX)(CONTAINING_RECORD( ListEntry, FOBX, ClosePendingList ));

            RxLog(( "TempFobx=%lx", TempFobx ));
            RxWmiLog( LOG,
                      RxPurgeRelatedFobxs_1,
                      LOGPTR( TempFobx ) );

            if ((TempFobx->SrvOpen != NULL) &&
                (TempFobx->SrvOpen->Fcb != NULL) &&
                (TempFobx->SrvOpen->Fcb->VNetRoot != NULL) &&
                ((PNET_ROOT)TempFobx->SrvOpen->Fcb->VNetRoot->NetRoot == NetRoot)) {
                NTSTATUS PurgeStatus = STATUS_MORE_PROCESSING_REQUIRED;

                if ((PurgingFcb != NULL) &&
                    (TempFobx->SrvOpen->Fcb != PurgingFcb)) {
                    
                    MINIRDR_CALL_THROUGH( PurgeStatus,
                                          RxDeviceObject->Dispatch,
                                          MRxAreFilesAliased,
                                          (TempFobx->SrvOpen->Fcb,PurgingFcb) );
                }

                if (PurgeStatus != STATUS_SUCCESS) {
                    RemoveEntryList( ListEntry );
                    InitializeListHead( ListEntry );

                    Fobx = TempFobx;
                    break;

                } else {
                    ListEntry = ListEntry->Flink;
                }
            } else {
                ListEntry = ListEntry->Flink;
            }
        }

        if (Fobx != NULL) {
            RxReferenceNetFobx( Fobx );
        } else {
            
            //
            //  Try to wake up the next waiter if any.
            //
            
            if (!IsListEmpty(&PurgeContext->ContextsAwaitingPurgeCompletion)) {
                
                PRX_CONTEXT NextContext;

                ListEntry = PurgeContext->ContextsAwaitingPurgeCompletion.Flink;
                
                RemoveEntryList( ListEntry );

                NextContext = (PRX_CONTEXT)(CONTAINING_RECORD( ListEntry,
                                                               RX_CONTEXT,
                                                               RxContextSerializationQLinks ));

                RxSignalSynchronousWaiter( NextContext );
            } else {
                PurgeContext->PurgeInProgress = FALSE;
            }
        }

        ScavengerMutexAcquired = FALSE;
        RxReleaseScavengerMutex();

        if (Fobx == NULL) {
            break;
        }

        //
        //  Purge the FOBX.
        //

        PurgeResult = RxPurgeFobx( Fobx );

        if (PurgeResult) {
            FobxsSuccessfullyPurged += 1;
        }

        Fcb = Fobx->SrvOpen->Fcb;

        if (AttemptFinalize && 
            (RxAcquireExclusiveFcb(NULL,Fcb) == STATUS_SUCCESS)) {
            
            RxReferenceNetFcb( Fcb );
            RxDereferenceNetFobx( Fobx, LHS_ExclusiveLockHeld );
            if (!RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE )) {
                RxReleaseFcb( NULL, Fcb );
            }
        } else {
            RxDereferenceNetFobx( Fobx, LHS_LockNotHeld );
        }

        if (!PurgeResult) {
            RxLog(( "SCVNGR:FailedToPurge %lx\n", Fcb ));
            RxWmiLog( LOG,
                      RxPurgeRelatedFobxs_2,
                      LOGPTR( Fcb ) );
        }

        RxAcquireScavengerMutex();
        ScavengerMutexAcquired = TRUE;
    }

    if (ScavengerMutexAcquired) {
        RxReleaseScavengerMutex();
    }

    if (FobxsSuccessfullyPurged > 0) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

VOID
RxPurgeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine purges all the FOBX's while stopping the scavenger

Arguments:

    RxDeviceObject -- the mini redirector device for which the purge should be done

--*/
{
    PLIST_ENTRY ListEntry = NULL;
    PFOBX Fobx;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    for (;;) {
        PFCB Fcb;

        RxAcquireScavengerMutex();

        ListEntry = RxScavenger->ClosePendingFobxsList.Flink;
        ASSERT( ListEntry != NULL );

        if (ListEntry != &RxScavenger->ClosePendingFobxsList) {
            
            Fobx = (PFOBX)(CONTAINING_RECORD( ListEntry, FOBX, ClosePendingList ));

            ASSERT( FlagOn( Fobx->NodeTypeCode, ~RX_SCAVENGER_MASK ) == RDBSS_NTC_FOBX );
            ASSERT( ListEntry->Flink != NULL );
            ASSERT( ListEntry->Blink != NULL );
            
            RemoveEntryList( ListEntry );
            InitializeListHead( ListEntry );

            RxReferenceNetFobx( Fobx );
        } else {
            Fobx = NULL;
        }

        RxReleaseScavengerMutex();

        if (Fobx == NULL) {
            break;
        }

        Fcb = Fobx->SrvOpen->Fcb;
        RxPurgeFobx( Fobx );

        if (RxAcquireExclusiveFcb( NULL, Fcb ) == STATUS_SUCCESS) {
            
            RxReferenceNetFcb( Fcb );
            RxDereferenceNetFobx( Fobx, LHS_ExclusiveLockHeld );
            if ( !RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE )) {
                RxReleaseFcb( NULL, Fcb );
            }
        } else {
            
            RxLog(( "RxPurgeAllFobxs: FCB %lx not accqd.\n", Fcb ));
            RxWmiLog( LOG,
                      RxPurgeAllFobxs,
                      LOGPTR( Fcb ) );
            RxDereferenceNetFobx( Fobx, LHS_LockNotHeld );
        }
    }
}


PRDBSS_DEVICE_OBJECT
RxGetDeviceObjectOfInstance (
    PVOID Instance
    )
/*++

Routine Description:

    The routine finds out the device object of an upper structure.

Arguments:

    Instance        - the instance

Return Value:

    none.

--*/
{
    ULONG NodeTypeCode = NodeType( Instance ) & ~RX_SCAVENGER_MASK;
    PAGED_CODE();

    ASSERT( (NodeTypeCode == RDBSS_NTC_SRVCALL) ||
            (NodeTypeCode == RDBSS_NTC_NETROOT) ||
            (NodeTypeCode == RDBSS_NTC_V_NETROOT) ||
            (NodeTypeCode == RDBSS_NTC_SRVOPEN) ||
            (NodeTypeCode == RDBSS_NTC_FOBX) );

    switch ( NodeTypeCode ) {

    case RDBSS_NTC_SRVCALL:
        return ((PSRV_CALL)Instance)->RxDeviceObject;
        //  no break;

    case RDBSS_NTC_NETROOT:
        return ((PNET_ROOT)Instance)->SrvCall->RxDeviceObject;
        //  no break;

    case RDBSS_NTC_V_NETROOT:
        return ((PV_NET_ROOT)Instance)->NetRoot->SrvCall->RxDeviceObject;
        //  no break;

    case RDBSS_NTC_SRVOPEN:
        return ((PSRV_OPEN)Instance)->Fcb->RxDeviceObject;
        //  no break;

    case RDBSS_NTC_FOBX:
        return ((PFOBX)Instance)->SrvOpen->Fcb->RxDeviceObject;
        //  no break;

    default:
        return NULL;
    }
}


VOID
RxpMarkInstanceForScavengedFinalization (
    PVOID Instance
    )
/*++

Routine Description:

    Thie routine marks a reference counted instance for scavenging

Arguments:

    Instance -- the instance to be marked for finalization by the scavenger

Notes:

    Currently scavenging has been implemented for SRV_CALL,NET_ROOT and V_NET_ROOT.
    The FCB scavenging is handled separately. The FOBX can and should always be
    synchronously finalized. The only data structure that will have to be potentially
    enabled for scavenged finalization are SRV_OPEN's.

    The Scavenger as it is implemented currently will not consume any system resources
    till there is a need for scavenged finalization. The first entry to be marked for
    scavenged finalization results in a timer request being posted for the scavenger.

    In the current implementation the timer requests are posted as one shot timer requests.
    This implies that there are no guarantess as regards the time interval within which
    the entries will be finalized. The scavenger activation mechanism is a potential
    candidate for fine tuning at a later stage.

    On Entry -- Scavenger Mutex must have been accquired

    On Exit  -- no change in resource ownership.

--*/
{
    BOOLEAN PostTimerRequest = FALSE;

    PLIST_ENTRY ListHead  = NULL;
    PLIST_ENTRY ListEntry = NULL;

    PNODE_TYPE_CODE_AND_SIZE Node = (PNODE_TYPE_CODE_AND_SIZE)Instance;

    USHORT InstanceType;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxGetDeviceObjectOfInstance( Instance );
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Marking %lx of type %lx for scavenged finalization\n", Instance, NodeType( Instance )) );

    InstanceType = Node->NodeTypeCode;

    if (Node->NodeReferenceCount <= 1) {

        //
        //  Mark the entry for scavenging.
        //

        SetFlag( Node->NodeTypeCode, RX_SCAVENGER_MASK ); 
        RxLog(( "Marked for scavenging %lx", Node ));
        RxWmiLog( LOG,
                  RxpMarkInstanceForScavengedFinalization,
                  LOGPTR( Node ) );

        switch (InstanceType) {
        case RDBSS_NTC_SRVCALL:
            {
                PSRV_CALL SrvCall = (PSRV_CALL)Instance;

                RxScavenger->SrvCallsToBeFinalized += 1;
                ListHead = &RxScavenger->SrvCallFinalizationList;
                ListEntry = &SrvCall->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                PNET_ROOT NetRoot = (PNET_ROOT)Instance;

                RxScavenger->NetRootsToBeFinalized += 1;
                ListHead  = &RxScavenger->NetRootFinalizationList;
                ListEntry = &NetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT VNetRoot = (PV_NET_ROOT)Instance;

                RxScavenger->VNetRootsToBeFinalized += 1;
                ListHead  = &RxScavenger->VNetRootFinalizationList;
                ListEntry = &VNetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_SRVOPEN:
            {
                PSRV_OPEN SrvOpen = (PSRV_OPEN)Instance;

                RxScavenger->SrvOpensToBeFinalized += 1;
                ListHead  = &RxScavenger->SrvOpenFinalizationList;
                ListEntry = &SrvOpen->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX Fobx = (PFOBX)Instance;

                RxScavenger->FobxsToBeFinalized += 1;
                ListHead  = &RxScavenger->FobxFinalizationList;
                ListEntry = &Fobx->ScavengerFinalizationList;
            }
            break;

        default:
            break;
        }

        InterlockedIncrement( &Node->NodeReferenceCount );
    }

    if (ListHead != NULL) {
        
        InsertTailList( ListHead, ListEntry );

        if (RxScavenger->State == RDBSS_SCAVENGER_INACTIVE) {
            RxScavenger->State = RDBSS_SCAVENGER_DORMANT;
            PostTimerRequest  = TRUE;
        } else {
            PostTimerRequest = FALSE;
        }
    }

    if (PostTimerRequest) {
        LARGE_INTEGER TimeInterval;

        //
        //  Post a one shot timer request for scheduling the scavenger after a
        //  predetermined amount of time.
        //
        
        TimeInterval.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;

        RxPostOneShotTimerRequest( RxFileSystemDeviceObject,
                                   &RxScavenger->WorkItem,
                                   RxScavengerTimerRoutine,
                                   RxDeviceObject,
                                   TimeInterval );
    }
}

VOID
RxpUndoScavengerFinalizationMarking (
    PVOID Instance
    )
/*++

Routine Description:

    This routine undoes the marking for scavenged finalization

Arguments:

    Instance -- the instance to be unmarked

Notes:

    This routine is typically invoked when a reference is made to an entry that has
    been marked for scavenging. Since the scavenger routine that does the finalization
    needs to acquire the exclusive lock this routine should be called with the
    appropriate lock held in a shared mode atleast. This routine removes it from the list
    of entries marked for scavenging and rips off the scavenger mask from the node type.

--*/
{
    PLIST_ENTRY ListEntry;

    PNODE_TYPE_CODE_AND_SIZE Node = (PNODE_TYPE_CODE_AND_SIZE)Instance;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxGetDeviceObjectOfInstance( Instance );
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("SCAVENGER -- undoing the marking for %lx of type %lx\n", Node, Node->NodeTypeCode) );

    if (FlagOn( Node->NodeTypeCode, RX_SCAVENGER_MASK )) {
        
        ClearFlag( Node->NodeTypeCode, RX_SCAVENGER_MASK );

        switch (Node->NodeTypeCode) {
        case RDBSS_NTC_SRVCALL:
            {
                PSRV_CALL SrvCall = (PSRV_CALL)Instance;

                RxScavenger->SrvCallsToBeFinalized -= 1;
                ListEntry = &SrvCall->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_NETROOT:
            {
                PNET_ROOT NetRoot = (PNET_ROOT)Instance;

                RxScavenger->NetRootsToBeFinalized -= 1;
                ListEntry = &NetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_V_NETROOT:
            {
                PV_NET_ROOT VNetRoot = (PV_NET_ROOT)Instance;

                RxScavenger->VNetRootsToBeFinalized -= 1;
                ListEntry = &VNetRoot->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_SRVOPEN:
            {
                PSRV_OPEN SrvOpen = (PSRV_OPEN)Instance;

                RxScavenger->SrvOpensToBeFinalized -= 1;
                ListEntry = &SrvOpen->ScavengerFinalizationList;
            }
            break;

        case RDBSS_NTC_FOBX:
            {
                PFOBX Fobx = (PFOBX)Instance;

                RxScavenger->FobxsToBeFinalized -= 1;
                ListEntry = &Fobx->ScavengerFinalizationList;
            }
            break;

        default:
            return;
        }

        RemoveEntryList( ListEntry );
        InitializeListHead( ListEntry );

        InterlockedDecrement( &Node->NodeReferenceCount );
    }
}

VOID
RxUndoScavengerFinalizationMarking (
    PVOID Instance
    )
/*++

Routine Description:

    This routine undoes the marking for scavenged finalization

Arguments:

    Instance -- the instance to be unmarked

--*/
{
    RxAcquireScavengerMutex();

    RxpUndoScavengerFinalizationMarking( Instance );

    RxReleaseScavengerMutex();
}

BOOLEAN
RxScavengeRelatedFobxs (
    PFCB Fcb
    )
/*++

Routine Description:

    Thie routine scavenges all the file objects pertaining to the given FCB.

Notes:

    On Entry -- FCB must have been accquired exclusive.

    On Exit  -- no change in resource acquistion.

--*/
{
    BOOLEAN ScavengerMutexAcquired  = FALSE;
    BOOLEAN AtleastOneFobxScavenged = FALSE;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = Fcb->RxDeviceObject;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxAcquireScavengerMutex();
    ScavengerMutexAcquired = TRUE;

    if (RxScavenger->FobxsToBeFinalized > 0) {
        PLIST_ENTRY Entry;
        PFOBX Fobx;
        LIST_ENTRY FobxList;

        InitializeListHead( &FobxList );


        Entry = RxScavenger->FobxFinalizationList.Flink;
        while (Entry != &RxScavenger->FobxFinalizationList) {
            Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, ScavengerFinalizationList );

            Entry = Entry->Flink;

            if (Fobx->SrvOpen != NULL &&
                Fobx->SrvOpen->Fcb == Fcb) {
                
                RxpUndoScavengerFinalizationMarking( Fobx );
                ASSERT( NodeType( Fobx ) == RDBSS_NTC_FOBX);

                InsertTailList( &FobxList, &Fobx->ScavengerFinalizationList );
            }
        }

        ScavengerMutexAcquired = FALSE;
        RxReleaseScavengerMutex();

        AtleastOneFobxScavenged = !IsListEmpty( &FobxList );

        Entry = FobxList.Flink;
        while (!IsListEmpty( &FobxList )) {
            Entry = FobxList.Flink;
            RemoveEntryList( Entry );
            Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, ScavengerFinalizationList );
            RxFinalizeNetFobx( Fobx, TRUE, TRUE );
        }
    }

    if (ScavengerMutexAcquired) {
        RxReleaseScavengerMutex();
    }

    return AtleastOneFobxScavenged;
}


VOID
RxpScavengeFobxs(
    PRDBSS_SCAVENGER RxScavenger,
    PLIST_ENTRY FobxList
    )
/*++

Routine Description:

    Thie routine scavenges all the file objects in the given list. This routine
    does the actual work of scavenging while RxScavengeFobxsForNetRoot and
    RxScavengeAllFobxs gather the file object extensions and call this routine

Notes:

--*/
{
    while (!IsListEmpty( FobxList )) {
        
        PFCB Fcb;
        PFOBX Fobx;
        NTSTATUS Status;
        PLIST_ENTRY Entry;

        Entry = FobxList->Flink;

        RemoveEntryList( Entry );

        Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, ScavengerFinalizationList );

        Fcb = Fobx->SrvOpen->Fcb;

        Status = RxAcquireExclusiveFcb( NULL, Fcb );

        if (Status == (STATUS_SUCCESS)) {
            
            RxReferenceNetFcb( Fcb );

            RxDereferenceNetFobx( Fobx, LHS_ExclusiveLockHeld );

            if (!RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE )) {
                RxReleaseFcb( NULL, Fcb );
            }

        } else {
            RxDereferenceNetFobx( Fobx, LHS_LockNotHeld );
        }
    }
}

VOID
RxScavengeFobxsForNetRoot (
    PNET_ROOT NetRoot,
    PFCB PurgingFcb
    )
/*++

Routine Description:

    Thie routine scavenges all the file objects pertaining to the given net root
    instance

Notes:

--*/
{
    BOOLEAN ScavengerMutexAcquired = FALSE;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = NetRoot->pSrvCall->RxDeviceObject;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    RxAcquireScavengerMutex();
    ScavengerMutexAcquired = TRUE;

    if (RxScavenger->FobxsToBeFinalized > 0) {
        
        PLIST_ENTRY Entry;
        PFOBX Fobx;
        LIST_ENTRY FobxList;

        InitializeListHead( &FobxList );

        Entry = RxScavenger->FobxFinalizationList.Flink;
        while (Entry != &RxScavenger->FobxFinalizationList) {
            Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, ScavengerFinalizationList );

            Entry = Entry->Flink;

            if ((Fobx->SrvOpen != NULL) &&
                (Fobx->SrvOpen->Fcb->NetRoot == NetRoot)) {
                
                NTSTATUS PurgeStatus = STATUS_MORE_PROCESSING_REQUIRED;

                if ((PurgingFcb != NULL) &&
                    (Fobx->SrvOpen->Fcb != PurgingFcb)) {
                    
                    MINIRDR_CALL_THROUGH( PurgeStatus,
                                          RxDeviceObject->Dispatch,
                                          MRxAreFilesAliased,
                                          (Fobx->SrvOpen->Fcb,PurgingFcb) );
                }

                if (PurgeStatus != STATUS_SUCCESS) {
                    
                    RxReferenceNetFobx( Fobx );

                    ASSERT(NodeType( Fobx ) == RDBSS_NTC_FOBX );

                    InsertTailList( &FobxList, &Fobx->ScavengerFinalizationList );
                }
            }
        }

        ScavengerMutexAcquired = FALSE;
        RxReleaseScavengerMutex();

        RxpScavengeFobxs( RxScavenger, &FobxList );
    }

    if (ScavengerMutexAcquired) {
        RxReleaseScavengerMutex();
    }

    return;
}

VOID
RxScavengeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    Thie routine scavenges all the file objects pertaining to the given mini
    redirector device object

Notes:


--*/
{
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    if (RxScavenger->FobxsToBeFinalized > 0) {
        
        PLIST_ENTRY Entry;
        PFOBX Fobx;
        LIST_ENTRY FobxList;

        InitializeListHead( &FobxList );

        RxAcquireScavengerMutex();

        Entry = RxScavenger->FobxFinalizationList.Flink;
        while (Entry != &RxScavenger->FobxFinalizationList) {
            
            Fobx  = (PFOBX)CONTAINING_RECORD( Entry, FOBX, ScavengerFinalizationList );

            Entry = Entry->Flink;

            RxReferenceNetFobx( Fobx );

            ASSERT( NodeType( Fobx ) == RDBSS_NTC_FOBX );

            InsertTailList( &FobxList, &Fobx->ScavengerFinalizationList );
        }

        RxReleaseScavengerMutex();

        RxpScavengeFobxs( RxScavenger, &FobxList );
    }
}

BOOLEAN
RxScavengeVNetRoots (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

Notes:

Return:

    TRUE if at least one vnetroot was scavenged

--*/
{
    BOOLEAN AtleastOneEntryScavenged = FALSE;
    PRX_PREFIX_TABLE RxNetNameTable = RxDeviceObject->pRxNetNameTable;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;
    PV_NET_ROOT VNetRoot;

    PAGED_CODE();

    do {
        PVOID Entry;

        RxDbgTrace( 0, Dbg, ("RDBSS SCAVENGER -- Scavenging VNetRoots\n") );

        RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );

        RxAcquireScavengerMutex();

        if (RxScavenger->VNetRootsToBeFinalized > 0) {
            
            Entry = RemoveHeadList( &RxScavenger->VNetRootFinalizationList );
            VNetRoot = (PV_NET_ROOT) CONTAINING_RECORD( Entry, V_NET_ROOT, ScavengerFinalizationList );

            RxpUndoScavengerFinalizationMarking( VNetRoot );
            ASSERT( NodeType( VNetRoot ) == RDBSS_NTC_V_NETROOT );

        } else {
            VNetRoot = NULL;
        }

        RxReleaseScavengerMutex();

        if (VNetRoot != NULL) {
            RxFinalizeVNetRoot( VNetRoot, TRUE, TRUE );
            AtleastOneEntryScavenged = TRUE;
        }

        RxReleasePrefixTableLock( RxNetNameTable );
    } while (VNetRoot != NULL);

    return AtleastOneEntryScavenged;
}

VOID
RxScavengerFinalizeEntries (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    Thie routine initiates the delayed finalization of entries

Notes:

    This routine must always be called only after acquiring the Scavenger Mutex.
    On return from this routine it needs to be reacquired. This is required
    to avoid redundant copying of data structures.

    The performance metric for the scavenger is different from the other routines. In
    the other routines the goal is to do as much work as possible once the lock is
    acquired without having to release it. On the other hand for the scavenger the
    goal is to hold the lock for as short a duration as possible because this
    interferes with the regular activity. This is preferred even if it entails
    frequent relaesing/acquisition of locks since it enables higher degrees of
    concurrency.

--*/
{
    BOOLEAN AtleastOneEntryScavenged;
    PRX_PREFIX_TABLE RxNetNameTable = RxDeviceObject->pRxNetNameTable;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    PAGED_CODE();

    do {
        AtleastOneEntryScavenged = FALSE;

        RxAcquireScavengerMutex();

        if (RxScavenger->NumberOfDormantFiles > 0) {
            
            PLIST_ENTRY ListEntry;
            PFOBX Fobx;

            //
            //  If the number of dormant files exceeds the limit specified for the
            //  given server a currently dormant file needs to be picked up for
            //  purging.
            //

            ListEntry = RxScavenger->ClosePendingFobxsList.Flink;
            if (ListEntry != &RxScavenger->ClosePendingFobxsList) {
                
                Fobx = (PFOBX)(CONTAINING_RECORD( ListEntry, FOBX, ClosePendingList ));

                RemoveEntryList( &Fobx->ClosePendingList );
                InitializeListHead( &Fobx->ClosePendingList );

                RxReferenceNetFobx( Fobx );

                RxScavenger->CurrentScavengerThread = PsGetCurrentThread();

                RxScavenger->CurrentFcbForClosePendingProcessing =
                    (PFCB)(Fobx->SrvOpen->Fcb);

                RxScavenger->CurrentNetRootForClosePendingProcessing =
                    (PNET_ROOT)(Fobx->SrvOpen->Fcb->NetRoot);

                KeResetEvent( &(RxScavenger->ClosePendingProcessingSyncEvent) );
            } else {
                Fobx = NULL;
            }

            if (Fobx != NULL) {
                NTSTATUS Status;

                RxReleaseScavengerMutex();

                Status = RxPurgeFobxFromCache( Fobx );

                AtleastOneEntryScavenged = (Status == STATUS_SUCCESS);

                RxAcquireScavengerMutex();

                RxScavenger->CurrentScavengerThread = NULL;
                RxScavenger->CurrentFcbForClosePendingProcessing = NULL;
                RxScavenger->CurrentNetRootForClosePendingProcessing = NULL;

                KeSetEvent( &(RxScavenger->ClosePendingProcessingSyncEvent),
                            0,
                            FALSE );
            }
        }

        if (RxScavenger->FobxsToBeFinalized > 0) {
            
            PVOID Entry;
            PFOBX Fobx = NULL;
            PFCB Fcb  = NULL;

            RxDbgTrace( 0, Dbg, ("RDBSS SCAVENGER -- Scavenging Fobxs\n") );

            if (RxScavenger->FobxsToBeFinalized > 0) {
                
                Entry = RxScavenger->FobxFinalizationList.Flink;

                Fobx  = (PFOBX) CONTAINING_RECORD( Entry, FOBX, ScavengerFinalizationList );

                Fcb = Fobx->SrvOpen->Fcb;
                RxReferenceNetFcb( Fcb );

                RxScavenger->CurrentScavengerThread = PsGetCurrentThread();

                RxScavenger->CurrentFcbForClosePendingProcessing =
                    (PFCB)(Fobx->SrvOpen->Fcb);

                RxScavenger->CurrentNetRootForClosePendingProcessing =
                    (PNET_ROOT)(Fobx->SrvOpen->Fcb->NetRoot);

                KeResetEvent( &(RxScavenger->ClosePendingProcessingSyncEvent) );
            } else {
                Fobx = NULL;
            }

            if (Fobx != NULL) {
                NTSTATUS Status;

                RxReleaseScavengerMutex();

                Status = RxAcquireExclusiveFcb( NULL, Fcb );
                
                if (Status == STATUS_SUCCESS) {
                    
                    AtleastOneEntryScavenged = RxScavengeRelatedFobxs(Fcb);

                    if (!RxDereferenceAndFinalizeNetFcb( Fcb, NULL, FALSE, FALSE ))  {
                        RxReleaseFcb( NULL, Fcb );
                    }
                } else {
                    RxLog(( "Delayed Close Failure FOBX(%lx) FCB(%lx)\n", Fobx, Fcb) );
                    RxWmiLog( LOG,
                              RxScavengerFinalizeEntries,
                              LOGPTR( Fobx )
                              LOGPTR( Fcb ) );
                }

                RxAcquireScavengerMutex();

                RxScavenger->CurrentScavengerThread = NULL;
                RxScavenger->CurrentFcbForClosePendingProcessing = NULL;
                RxScavenger->CurrentNetRootForClosePendingProcessing = NULL;

                KeSetEvent( &(RxScavenger->ClosePendingProcessingSyncEvent),
                            0,
                            FALSE );
            }
        }

        RxReleaseScavengerMutex();

        if (RxScavenger->SrvOpensToBeFinalized > 0) {

            //
            //  SRV_OPEN List should not be empty, potential memory leak
            //

            ASSERT( RxScavenger->SrvOpensToBeFinalized == 0 );
        }

        if (RxScavenger->FcbsToBeFinalized > 0) {

            //  
            //  FCB list should be empty , potential memory leak
            //

            ASSERT( RxScavenger->FcbsToBeFinalized == 0 );
        }

        if (RxScavenger->VNetRootsToBeFinalized > 0) {
            
            PVOID Entry;
            PV_NET_ROOT VNetRoot;

            RxDbgTrace( 0, Dbg, ("RDBSS SCAVENGER -- Scavenging VNetRoots\n") );

            RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );

            RxAcquireScavengerMutex();

            if (RxScavenger->VNetRootsToBeFinalized > 0) {
                Entry = RemoveHeadList( &RxScavenger->VNetRootFinalizationList );

                VNetRoot = (PV_NET_ROOT) CONTAINING_RECORD( Entry, V_NET_ROOT, ScavengerFinalizationList );

                RxpUndoScavengerFinalizationMarking( VNetRoot );
                ASSERT( NodeType( VNetRoot ) == RDBSS_NTC_V_NETROOT );
            } else {
                VNetRoot = NULL;
            }

            RxReleaseScavengerMutex();

            if (VNetRoot != NULL) {
                RxFinalizeVNetRoot( VNetRoot, TRUE, TRUE );
                AtleastOneEntryScavenged = TRUE;
            }

            RxReleasePrefixTableLock( RxNetNameTable );
        }

        if (RxScavenger->NetRootsToBeFinalized > 0) {
            PVOID Entry;
            PNET_ROOT NetRoot;

            RxDbgTrace( 0, Dbg, ("RDBSS SCAVENGER -- Scavenging NetRoots\n") );

            RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );

            RxAcquireScavengerMutex();

            if (RxScavenger->NetRootsToBeFinalized > 0) {
                Entry = RemoveHeadList(&RxScavenger->NetRootFinalizationList);

                NetRoot = (PNET_ROOT) CONTAINING_RECORD( Entry, NET_ROOT, ScavengerFinalizationList );

                RxpUndoScavengerFinalizationMarking( NetRoot );
                ASSERT( NodeType( NetRoot ) == RDBSS_NTC_NETROOT);
            } else {
                NetRoot = NULL;
            }

            RxReleaseScavengerMutex();

            if (NetRoot != NULL) {
                RxFinalizeNetRoot( NetRoot, TRUE, TRUE );
                AtleastOneEntryScavenged = TRUE;
            }

            RxReleasePrefixTableLock(RxNetNameTable);
        }

        if (RxScavenger->SrvCallsToBeFinalized > 0) {
            
            PVOID Entry;
            PSRV_CALL SrvCall;

            RxDbgTrace( 0, Dbg, ("RDBSS SCAVENGER -- Scavenging SrvCalls\n") );

            RxAcquirePrefixTableLockExclusive( RxNetNameTable, TRUE );

            RxAcquireScavengerMutex();

            if (RxScavenger->SrvCallsToBeFinalized > 0) {
                Entry = RemoveHeadList( &RxScavenger->SrvCallFinalizationList );

                SrvCall = (PSRV_CALL) CONTAINING_RECORD( Entry, SRV_CALL, ScavengerFinalizationList );

                RxpUndoScavengerFinalizationMarking( SrvCall );
                ASSERT( NodeType( SrvCall ) == RDBSS_NTC_SRVCALL );
            } else {
                SrvCall = NULL;
            }

            RxReleaseScavengerMutex();

            if (SrvCall != NULL) {
                RxFinalizeSrvCall( SrvCall, TRUE );
                AtleastOneEntryScavenged = TRUE;
            }

            RxReleasePrefixTableLock( RxNetNameTable );
        }
    } while (AtleastOneEntryScavenged);
}

VOID
RxScavengerTimerRoutine (
    PVOID Context
    )
/*++

Routine Description:

    This routine is the timer routine that periodically initiates the finalization of
    entries.

Arguments:

    Context -- the context (actually the RxDeviceObject)

Notes:

--*/
{
    PRDBSS_DEVICE_OBJECT RxDeviceObject = (PRDBSS_DEVICE_OBJECT)Context;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;
    BOOLEAN PostTimerRequest = FALSE;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    KeResetEvent( &RxScavenger->SyncEvent );

    if (RxScavenger->State == RDBSS_SCAVENGER_DORMANT) {
        
        RxScavenger->State = RDBSS_SCAVENGER_ACTIVE;

        RxReleaseScavengerMutex();

        RxScavengerFinalizeEntries( RxDeviceObject );

        RxAcquireScavengerMutex();

        if (RxScavenger->State == RDBSS_SCAVENGER_ACTIVE) {
            
            ULONG EntriesToBeFinalized;

            //
            //  Check if the scavenger needs to be activated again.
            //

            EntriesToBeFinalized = RxScavenger->SrvCallsToBeFinalized +
                                   RxScavenger->NetRootsToBeFinalized +
                                   RxScavenger->VNetRootsToBeFinalized +
                                   RxScavenger->FcbsToBeFinalized +
                                   RxScavenger->SrvOpensToBeFinalized +
                                   RxScavenger->FobxsToBeFinalized +
                                   RxScavenger->NumberOfDormantFiles;

            if (EntriesToBeFinalized > 0) {
                PostTimerRequest = TRUE;
                RxScavenger->State = RDBSS_SCAVENGER_DORMANT;
            } else {
                RxScavenger->State = RDBSS_SCAVENGER_INACTIVE;
            }
        }

        RxReleaseScavengerMutex();

        if (PostTimerRequest) {
            LARGE_INTEGER TimeInterval;

            TimeInterval.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;

            RxPostOneShotTimerRequest( RxFileSystemDeviceObject,
                                       &RxScavenger->WorkItem,
                                       RxScavengerTimerRoutine,
                                       RxDeviceObject,
                                       TimeInterval );
        }
    } else {
        RxReleaseScavengerMutex();
    }

    //
    //  Trigger the event.
    //

    KeSetEvent( &RxScavenger->SyncEvent, 0, FALSE );
}

VOID
RxTerminateScavenging (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine terminates all scavenging activities in the RDBSS. The termination is
    effected in an orderly fashion after all the entries currently marked for scavenging
    are finalized.

Arguments:

    RxContext -- the context

Notes:

    In implementing the scavenger there are two options. The scavenger can latch onto a
    thread and hold onto it from the moment RDBSS comes into existence till it is unloaded.
    Such an implementation renders a thread useless throughout the lifetime of RDBSS.

    If this is to be avoided the alternative is to trigger the scavenger as and when
    required. While this technique addresses the conservation of system resources it
    poses some tricky synchronization problems having to do with start/stop of the RDR.

    Since the RDR can be started/stopped at any time the Scavenger can be in one of three
    states when the RDR is stopped.

      1) Scavenger is active.

      2) Scavenger request is in the timer queue.

      3) Scavenger is inactive.

    Of these case (3) is the easiest since no special action is required.

    If the scavenger is active then this routine has to synchronize with the timer routine
    that is finzalizing the entries. This is achieved by allowing the termination routine to
    modify the Scavenger state under a mutex and waiting for it to signal the event on
    completion.
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;
    PRDBSS_SCAVENGER RxScavenger = RxDeviceObject->pRdbssScavenger;

    RDBSS_SCAVENGER_STATE PreviousState;

    PAGED_CODE();

    RxAcquireScavengerMutex();

    PreviousState = RxScavenger->State;
    RxScavenger->State = RDBSS_SCAVENGER_SUSPENDED;

    RxReleaseScavengerMutex();

    if (PreviousState == RDBSS_SCAVENGER_DORMANT) {
        
        //
        //  There is a timer request currently active. cancel it
        //

        Status = RxCancelTimerRequest( RxFileSystemDeviceObject, RxScavengerTimerRoutine, RxDeviceObject );
    }

    if ((PreviousState == RDBSS_SCAVENGER_ACTIVE) || (Status == STATUS_NOT_FOUND)) {
        
        //
        //  Either the timer routine was previously active or it could not be cancelled
        //  Wait for it to complete
        //

        KeWaitForSingleObject( &RxScavenger->SyncEvent, Executive, KernelMode, FALSE, NULL );
    }

    RxPurgeAllFobxs( RxContext->RxDeviceObject );

    RxScavengerFinalizeEntries( RxContext->RxDeviceObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\precomp.h ===
#include "rx.h"         // RX memory allocation macros
#include "ntddnfs2.h"   // NT network file system driver include file
#include "rxdebug.h"    // debug support

// the rest of the real connection engine stuff.........
#include "rxcep.h"      // RxCe implementation details
#include "rxtdi.h"      // RxCe transport driver interface
#include "rxwmi.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\rxpnp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpnp.c

Abstract:

    This module implements the PNP notification handling routines for RDBSS

Revision History:

    Balan Sethu Raman     [SethuR]    10-Apr-1996

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop

#include "tdikrnl.h"

HANDLE RxTdiNotificationHandle;

VOID
RxTdiBindTransportCallback(
    IN PUNICODE_STRING DeviceName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    DeviceName - the name of the newly created device object

--*/
{
   RX_BINDING_CONTEXT   BindingContext;

   BindingContext.pTransportName   = DeviceName;
   BindingContext.QualityOfService = 65534;

   //DbgPrint("$$$$$ Bind for transport %ws\n",DeviceName->Buffer);
   RxCeBindToTransport(&BindingContext);
}

VOID
RxTdiUnbindTransportCallback(
    IN PUNICODE_STRING DeviceName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport deletes a device object

Arguments:

    DeviceName = the name of the deleted device object

--*/
{
   RX_BINDING_CONTEXT   BindingContext;

   BindingContext.pTransportName   = DeviceName;

   RxCeUnbindFromTransport(&BindingContext);
}

NTSTATUS
RxRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if( RxTdiNotificationHandle == NULL ) {

        status = TdiRegisterNotificationHandler (
                                        RxTdiBindTransportCallback,
                                        RxTdiUnbindTransportCallback,
                                        &RxTdiNotificationHandle );
    }

    return status;
}

NTSTATUS
RxDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if( RxTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterNotificationHandler( RxTdiNotificationHandle );
        if( NT_SUCCESS( Status ) ) {
            RxTdiNotificationHandle = NULL;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\rxcep.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtdi.c

Abstract:

    This module implements the NT specific notification routines in the connection engine

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

    The notification of a transport binding/unbinding to the mini redirectors is done
    in a worker thread. In order to simplify the task of writing a routine the connection
    engine guarantees that not more than one  invocation of MRxTranspotrtUpdateHandler
    will be active at any instant of time for a given mini redirector.

    There is no thread dedicated to processing these notifications. A worker thread is
    used to process the notifications. In order to ensure condition (1) all the notifications
    are queued ( interlocked queue ).

--*/

#include "precomp.h"
#pragma  hdrstop

#include "mrx.h"

typedef struct _RXCE_MINIRDR_NOTIFICATION_CONTEXT_ {
    LIST_ENTRY           NotificationListEntry;
    PRXCE_TRANSPORT      pTransport;
    RXCE_TRANSPORT_EVENT TransportEvent;
} RXCE_MINIRDR_NOTIFICATION_CONTEXT,
  *PRXCE_MINIRDR_NOTIFICATION_CONTEXT;

typedef struct _RXCE_MINIRDR_NOTIFICATION_HANDLER_ {
    WORK_QUEUE_ITEM WorkQueueEntry;
    KSPIN_LOCK         Lock;
    LIST_ENTRY         ListHead;
    BOOLEAN            NotifierActive;
} RXCE_MINIRDR_NOTIFICATION_HANDLER,
 *PRXCE_MINIRDR_NOTIFICATION_HANDLER;

RXCE_MINIRDR_NOTIFICATION_HANDLER s_RxCeMinirdrNotificationHandler;

extern VOID
MiniRedirectorsNotifier(
   PVOID NotificationContext);

NTSTATUS
InitializeMiniRedirectorNotifier()
{
    s_RxCeMinirdrNotificationHandler.NotifierActive = FALSE;
    KeInitializeSpinLock(&s_RxCeMinirdrNotificationHandler.Lock);
    InitializeListHead(&s_RxCeMinirdrNotificationHandler.ListHead);
    return STATUS_SUCCESS;
}

NTSTATUS
NotifyMiniRedirectors(
    RXCE_TRANSPORT_HANDLE  hTransport,
    RXCE_TRANSPORT_EVENT   TransportEvent,
    RXCE_NOTIFICATION_MODE Mode)
{
    NTSTATUS Status;
    KIRQL    SavedIrql;

    PRXCE_MINIRDR_NOTIFICATION_CONTEXT pContext;

    pContext = RxAllocatePoolWithTag(
                   PagedPool | POOL_COLD_ALLOCATION,
                   sizeof(RXCE_MINIRDR_NOTIFICATION_CONTEXT),
                   RX_MISC_POOLTAG);

    if (pContext != NULL) {
        pContext->TransportEvent = TransportEvent;

        // Reference the transport entry
        pContext->pTransport = RxCeReferenceTransport(hTransport);

        if (Mode == RXCE_ASYNCHRONOUS_NOTIFICATION) {
            BOOLEAN DispatchNotifier;

            // Acquire the spin lock ...
            KeAcquireSpinLock(
                &s_RxCeMinirdrNotificationHandler.Lock,
                &SavedIrql);

            DispatchNotifier = (IsListEmpty(&s_RxCeMinirdrNotificationHandler.ListHead) &&
                                !s_RxCeMinirdrNotificationHandler.NotifierActive);

            InsertTailList(&s_RxCeMinirdrNotificationHandler.ListHead,&pContext->NotificationListEntry);

            if (DispatchNotifier) {
                s_RxCeMinirdrNotificationHandler.NotifierActive = TRUE;
            }

            // Release the spin lock
            KeReleaseSpinLock(
                &s_RxCeMinirdrNotificationHandler.Lock,
                SavedIrql);

            // If the notification list is empty a worker thread needs to be fired up.
            if (DispatchNotifier) {
                RxPostToWorkerThread(
                    CriticalWorkQueue,
                    &s_RxCeMinirdrNotificationHandler.WorkQueueEntry,
                    MiniRedirectorsNotifier,
                    &s_RxCeMinirdrNotificationHandler);
            }

            Status = STATUS_SUCCESS;
        } else {
            ULONG                         i;
            PMRX_TRANSPORT_UPDATE_HANDLER MRxTransportUpdateHandler;
            PLIST_ENTRY ListEntry;

            // Notify all the mini redirectors ....
            for (ListEntry = RxRegisteredMiniRdrs.Flink;
                 ListEntry!= &RxRegisteredMiniRdrs;
                 ListEntry = ListEntry->Flink) {

                PRDBSS_DEVICE_OBJECT RxDeviceObject = CONTAINING_RECORD( ListEntry, RDBSS_DEVICE_OBJECT, MiniRdrListLinks );
                MRxTransportUpdateHandler = RxDeviceObject->Dispatch->MRxTransportUpdateHandler;

                if ( MRxTransportUpdateHandler != NULL) {
                    Status = MRxTransportUpdateHandler(
                                 pContext->pTransport,
                                 pContext->TransportEvent,
                                 pContext->pTransport->pProviderInfo);
                }
            }

            // Derefrence the transport entry
            RxCeDereferenceTransport(pContext->pTransport);

            // free the notification context.
            RxFreePool(pContext);

            Status = STATUS_SUCCESS;
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
MiniRedirectorsNotifier(
    PVOID NotificationContext)
{
    NTSTATUS    Status;
    KIRQL    SavedIrql;

    PLIST_ENTRY pEntry;

    PRXCE_MINIRDR_NOTIFICATION_CONTEXT pContext;
    PMRX_TRANSPORT_UPDATE_HANDLER      MRxTransportUpdateHandler;

    for (;;) {
        PLIST_ENTRY ListEntry;

        // Acquire the spin lock ...
        KeAcquireSpinLock(
            &s_RxCeMinirdrNotificationHandler.Lock,
            &SavedIrql);

        // Remove an item from the notification list.
        if (!IsListEmpty(&s_RxCeMinirdrNotificationHandler.ListHead)) {
            pEntry = RemoveHeadList(
                         &s_RxCeMinirdrNotificationHandler.ListHead);
        } else {
            pEntry = NULL;
            s_RxCeMinirdrNotificationHandler.NotifierActive = FALSE;
        }

        // Release the spin lock
        KeReleaseSpinLock(&s_RxCeMinirdrNotificationHandler.Lock,SavedIrql);

        if (pEntry == NULL) {
            break;
        }

        pContext = (PRXCE_MINIRDR_NOTIFICATION_CONTEXT)
                   CONTAINING_RECORD(
                       pEntry,
                       RXCE_MINIRDR_NOTIFICATION_CONTEXT,
                       NotificationListEntry);

        // Notify all the mini redirectors ....
        for (ListEntry = RxRegisteredMiniRdrs.Flink;
             ListEntry!= &RxRegisteredMiniRdrs;
             ListEntry = ListEntry->Flink) {

            PRDBSS_DEVICE_OBJECT RxDeviceObject = CONTAINING_RECORD( ListEntry, RDBSS_DEVICE_OBJECT, MiniRdrListLinks );
            MRxTransportUpdateHandler = RxDeviceObject->Dispatch->MRxTransportUpdateHandler;

            if ( MRxTransportUpdateHandler != NULL) {
                Status = MRxTransportUpdateHandler(
                             pContext->pTransport,
                             pContext->TransportEvent,
                             pContext->pTransport->pProviderInfo);

                if (!NT_SUCCESS(Status)) {
                }
            }
        }

        // Derefrence the transport entry
        RxCeDereferenceTransport(pContext->pTransport);

        // free the notification context.
        RxFreePool(pContext);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\rxtdi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtdi.c

Abstract:

    This module implements the NT TDI related routines used by RXCE. The wrappers are necessary to
    ensure that all the OS dependencies can be localized to select modules like this for
    customization.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:


--*/

#include "precomp.h"
#pragma  hdrstop
#include "tdikrnl.h"
#include "rxtdip.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCETDI)

LARGE_INTEGER ConnectionTimeOut = {0,0};

#define CANCELLED_CONNECT_IRP IntToPtr(0xffffffff)

#if DBG
void
DbgDumpTransportAddress(
    PWSTR RoutineName,
    PRXCE_TRANSPORT  pTransport,
    PTRANSPORT_ADDRESS pTA
    );
#else
#define DbgDumpTransportAddress( r, t, a )
#endif

// Once a valid handle to a transport device object has been obtained subsequent
// opens to the same device object can be opened with a NULL relative name to
// this handle. This has two beneficial side effects --- one it is fast since
// we do not have to go through the object manager's logic for parsing names and
// in remote boot scenarios it minimizes the footprint that needs to be locked
// down.

UNICODE_STRING RelativeName = { 0,0,NULL};

NTSTATUS
RxTdiBindToTransport(
    IN OUT PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine binds to the transport specified.

Arguments:

    pTransport       - the transport structure to be initialized

    pRxBindingContext - the binding context containing a pointer to the
                        transport name and the quality of service for NT.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

--*/
{
    NTSTATUS          Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ChannelAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    RxProfile(RxTdi,RxTdiBindToTransport);

    InitializeObjectAttributes(
        &ChannelAttributes,       // Tdi Control Channel attributes
        &pTransport->Name,        // Name
        OBJ_CASE_INSENSITIVE,     // Attributes
        NULL,                     // RootDirectory
        NULL);                    // SecurityDescriptor

    Status = ZwCreateFile(
                 &pTransport->ControlChannel,                 // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &ChannelAttributes,                         // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 NULL,                                       // EA Buffer
                 0);                                         // EA length

    if (NT_SUCCESS(Status)) {
        //  Obtain a referenced pointer to the file object.
        Status = ObReferenceObjectByHandle(
                     pTransport->ControlChannel,                     // Object Handle
                     FILE_ANY_ACCESS,                                // Desired Access
                     NULL,                                           // Object Type
                     KernelMode,                                     // Processor mode
                     (PVOID *)&pTransport->pControlChannelFileObject,// Object pointer
                     NULL);                                          // Object Handle information

        if (NT_SUCCESS(Status)) {
            PIRP pIrp = NULL;

            // Obtain the related device object.
            pTransport->pDeviceObject = IoGetRelatedDeviceObject(pTransport->pControlChannelFileObject);

            pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

            if (pIrp != NULL) {
                PMDL pMdl;

                // Obtain the provider information from the specified transport.
                ASSERT(pTransport->pProviderInfo != NULL);
                pMdl = RxAllocateMdl(
                           pTransport->pProviderInfo,           // Virtual address for MDL construction
                           sizeof( RXCE_TRANSPORT_PROVIDER_INFO));        // size of the buffer

                if ( pMdl != NULL ) {
                    try {
                        MmProbeAndLockPages( pMdl, KernelMode, IoModifyAccess );
                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                        IoFreeMdl( pMdl );
                        Status = GetExceptionCode();
                    }

                    if (Status == STATUS_SUCCESS) {
                        TdiBuildQueryInformation(
                            pIrp,
                            pTransport->pDeviceObject,
                            pTransport->pControlChannelFileObject,
                            RxTdiRequestCompletion,                // Completion routine
                            NULL,                                  // Completion context
                            TDI_QUERY_PROVIDER_INFO,
                            pMdl);

                        Status = RxCeSubmitTdiRequest(
                                     pTransport->pDeviceObject,
                                     pIrp);

                        MmUnlockPages(pMdl);
                        IoFreeMdl(pMdl);
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                RxCeFreeIrp(pIrp);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return Status;
}

NTSTATUS
RxTdiUnbindFromTransport(
    IN OUT PRXCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine unbinds to the transport specified.

Arguments:

    pTransport - the transport structure


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS          Status = STATUS_SUCCESS;

    RxProfile(RxTdi,RxTdiUnbindFromTransport);

    // Dereference the control channel file object.
    if (pTransport->pControlChannelFileObject != NULL) {
        ObDereferenceObject(pTransport->pControlChannelFileObject);
    }

    // Close the control channel
    if (pTransport->ControlChannel != INVALID_HANDLE_VALUE) {
        Status = ZwClose(pTransport->ControlChannel);
    }

    pTransport->pControlChannelFileObject = NULL;
    pTransport->ControlChannel = INVALID_HANDLE_VALUE;

    return Status;
}


NTSTATUS
RxTdiOpenAddress(
    IN     PRXCE_TRANSPORT    pTransport,
    IN     PTRANSPORT_ADDRESS pTransportAddress,
    IN OUT PRXCE_ADDRESS      pAddress)
/*++

Routine Description:

    This routine opens an address object.

Arguments:


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS          Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES AddressAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;

    ULONG TransportAddressLength;
    ULONG TransportEaBufferLength;

    PFILE_FULL_EA_INFORMATION pTransportAddressEa;

    RxProfile(RxTdi,RxTdiOpenAddress);

    TransportAddressLength = ComputeTransportAddressLength(pTransportAddress);

    // Build an EA buffer for the specified transport address
    Status = BuildEaBuffer(
                 TDI_TRANSPORT_ADDRESS_LENGTH,
                 TdiTransportAddress,
                 TransportAddressLength,
                 pTransportAddress,
                 &pTransportAddressEa,
                 &TransportEaBufferLength);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeObjectAttributes(
        &AddressAttributes,         // OBJECT_ATTRIBUTES instance
        &RelativeName,                       // Name
        0,                          // Attributes
        pTransport->ControlChannel, // RootDirectory
        NULL);                      // SecurityDescriptor

    Status = ZwCreateFile(
                 &pAddress->hAddress,                         // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &AddressAttributes,                         // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 pTransportAddressEa,                        // EA Buffer
                 TransportEaBufferLength);                   // EA length

    if (NT_SUCCESS(Status)) {
        //  Obtain a referenced pointer to the file object.
        Status = ObReferenceObjectByHandle (
                     pAddress->hAddress,              // Object Handle
                     FILE_ANY_ACCESS,                 // Desired Access
                     NULL,                            // Object Type
                     KernelMode,                      // Processor mode
                     (PVOID *)&pAddress->pFileObject, // Object pointer
                     NULL);                           // Object Handle information

        Status = RxTdiSetEventHandlers(pTransport,pAddress);

        //DbgPrint("RDR opened address %lx\n", pAddress->hAddress);
    }

    // Free up the EA buffer allocated.
    RxFreePool(pTransportAddressEa);

    RxDbgTrace(0, Dbg,("RxTdiOpenAddress returns %lx\n",Status));
    return Status;
}

NTSTATUS
RxTdiSetEventHandlers(
    PRXCE_TRANSPORT pTransport,
    PRXCE_ADDRESS   pRxCeAddress)
/*++

Routine Description:

    This routine establishes the event handlers for a given address.

Arguments:

    pRxCeAddress - the address object


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS        Status;
    PIRP pIrp;

    RxProfile(RxTdi,RxTdiSetEventHandlers);

    pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    if (pIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // The event handlers need to be set one at a time.
    do {
        // Connect Event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_CONNECT,
            RxTdiConnectEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        // Disconnect event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_DISCONNECT,
            RxTdiDisconnectEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        // Error event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_ERROR,
            RxTdiErrorEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

        // Receive Event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_RECEIVE,
            RxTdiReceiveEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }

#if 0
        // Receive datagram event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_RECEIVE_DATAGRAM,
            RxTdiReceiveDatagramEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }
#endif

        // Receieve expedited event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_RECEIVE_EXPEDITED,
            RxTdiReceiveExpeditedEventHandler,
            pRxCeAddress);

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);

        if (!NT_SUCCESS(Status)) {
            continue;
        }
#if 0
        // Send possible event handler
        TdiBuildSetEventHandler(
            pIrp,
            pTransport->pDeviceObject,
            pRxCeAddress->pFileObject,
            NULL,
            NULL,
            TDI_EVENT_SEND_POSSIBLE,
            RxTdiSendPossibleEventHandler,
            RxCeGetAddressHandle(pRxCeAddress));

        Status = RxCeSubmitTdiRequest(pTransport->pDeviceObject,pIrp);
#endif
        if (NT_SUCCESS(Status)) {
            // All the event handlers have been successfully set.
            break;
        }
    } while (NT_SUCCESS(Status));

    // Free the Irp
    RxCeFreeIrp(pIrp);

    return Status;
}

NTSTATUS
RxTdiConnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN OUT PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc)
/*++

Routine Description:

    This routine establishes a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pTransport         - the associated transport

    pAddress           - the address object to be closed

    pConnection        - the RxCe connection instance

    pVc                - the RxCe virtual circuit instance.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS                     Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES            VcAttributes;
    IO_STATUS_BLOCK              IoStatusBlock;
    PRXCE_CONNECTION_INFORMATION pReturnConnectionInformation = NULL;

    ULONG ConnectionContextEaBufferLength;

    PFILE_FULL_EA_INFORMATION pConnectionContextEa;

    RxProfile(RxTdi,RxTdiConnect);

#if DBG
    {
        PTRANSPORT_ADDRESS pTA =
            (PTRANSPORT_ADDRESS)(pConnection->pConnectionInformation->RemoteAddress);
        RxDbgTrace(0, Dbg,("RxTdiConnect to %wZ address length %d type %d\n",
                           &(pTransport->Name),
                           pTA->Address[0].AddressLength,
                           pTA->Address[0].AddressType ));
    }
#endif

    // Build an EA buffer for the specified connection context
    Status = BuildEaBuffer(
                 TDI_CONNECTION_CONTEXT_LENGTH,
                 TdiConnectionContext,
                 sizeof(PRXCE_VC),
                 &pVc,
                 &pConnectionContextEa,
                 &ConnectionContextEaBufferLength);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    // Open the local connection endpoint.
    InitializeObjectAttributes(
        &VcAttributes,              // OBJECT_ATTRIBUTES instance
        &RelativeName,                       // Name
        0,                          // Attributes
        pTransport->ControlChannel, // RootDirectory
        NULL);                      // SecurityDescriptor

    Status = ZwCreateFile(
                 &pVc->hEndpoint,                             // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &VcAttributes,                              // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 pConnectionContextEa,                       // EA Buffer
                 ConnectionContextEaBufferLength);           // EA length

    if (NT_SUCCESS(Status)) {
        PIRP pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            //  Obtain a referenced pointer to the file object.
            Status = ObReferenceObjectByHandle (
                         pVc->hEndpoint,                  // Object Handle
                         FILE_ANY_ACCESS,                 // Desired Access
                         NULL,                            // Object Type
                         KernelMode,                      // Processor mode
                         (PVOID *)&pVc->pEndpointFileObject,  // Object pointer
                         NULL);                           // Object Handle information

            if (NT_SUCCESS(Status)) {
                // Associate the local endpoint with the address object.
                TdiBuildAssociateAddress(
                    pIrp,
                    pTransport->pDeviceObject,
                    pVc->pEndpointFileObject,
                    NULL,
                    NULL,
                    pAddress->hAddress);

                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                if (NT_SUCCESS(Status)) {
                    // issue the connect request to the underlying transport provider.
                    TdiBuildConnect(
                        pIrp,
                        pTransport->pDeviceObject,
                        pVc->pEndpointFileObject,
                        NULL,
                        NULL,
                        &ConnectionTimeOut,
                        pConnection->pConnectionInformation,
                        pReturnConnectionInformation);

                    Status = RxCeSubmitTdiRequest(
                                 pTransport->pDeviceObject,
                                 pIrp);

                    if (!NT_SUCCESS(Status)) {
                        // Disassociate address from the connection since the connect request was
                        // not successful.
                        NTSTATUS LocalStatus;

                        TdiBuildDisassociateAddress(
                            pIrp,
                            pTransport->pDeviceObject,
                            pVc->pEndpointFileObject,
                            NULL,
                            NULL);

                        LocalStatus = RxCeSubmitTdiRequest(
                                          pTransport->pDeviceObject,
                                          pIrp);
                    } else {
                        // The associate address was not successful.
                        RxDbgTrace(0, Dbg,("TDI connect returned %lx\n",Status));
                    }
                } else {
                    // The associate address was not successful.
                    RxDbgTrace(0, Dbg,("TDI associate address returned %lx\n",Status));
                }

                if (!NT_SUCCESS(Status)) {
                    // Dereference the endpoint file object.
                    ObDereferenceObject(pVc->pEndpointFileObject);
                }
            } else {
                // error obtaining the file object for the connection.
                RxDbgTrace(0, Dbg,("error referencing endpoint file object %lx\n",Status));
            }

            RxCeFreeIrp(pIrp);

            if (!NT_SUCCESS(Status)) {
                // Close the endpoint file object handle
                ZwClose(pVc->hEndpoint);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        // error creating the connection object
        RxDbgTrace(0, Dbg,("Connection object(ZwCreate) returned %lx\n",Status));
    }

    if (!NT_SUCCESS(Status)) {
        pVc->hEndpoint = INVALID_HANDLE_VALUE;
        pVc->pEndpointFileObject = NULL;
    }

    RxFreePool(pConnectionContextEa);

    return Status;
}

NTSTATUS
RxTdiDereferenceAndFreeIrp(
     IN PULONG IrpRefCount,
     IN PIRP pIrp)
/*++

Routine Description:

    This routine dereference the connect Irp and free it if ref count reaches 0

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    ULONG RefCount;

    RefCount = InterlockedDecrement(IrpRefCount);

    if (RefCount == 0) {
        RxCeFreeIrp(pIrp);
        RxFreePool(IrpRefCount);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RxTdiAsynchronousConnectCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context)
/*++

Routine Description:

    This routine completes an asynchronous connect request.

Arguments:

    pDeviceObject - the device object

    pIrp          - the IRp

    Context       - the completion context

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    PULONG IrpRefCount = NULL;
    PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters;

    RxDbgTrace(0, Dbg,("RxTdiAsynchronousConnectCompletion, irp 0x%x, status 0x%x\n",
                       pIrp, pIrp->IoStatus.Status));

    pParameters = (PRX_CREATE_CONNECTION_PARAMETERS_BLOCK)Context;

    pParameters->CallOutStatus = pIrp->IoStatus.Status;
    IrpRefCount = pParameters->IrpRefCount;

    RxWmiLogError(pParameters->CallOutStatus,
                  LOG,
                  RxTdiAsynchronousConnectCompletion,
                  LOGULONG(pParameters->CallOutStatus)
                  LOGUSTR(pParameters->Connection.pAddress->pTransport->Name));

    if (pParameters->pCallOutContext != NULL) {
        pParameters->pCallOutContext->pRxCallOutCompletion(
            (PRX_CALLOUT_PARAMETERS_BLOCK)pParameters);
    }

    // Free the IRP.
    RxTdiDereferenceAndFreeIrp(IrpRefCount,pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
RxTdiCancelAsynchronousConnect(
     IN PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters)
/*++

Routine Description:

    This routine cancels a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_CANCELLED - if the call was successfull.

--*/
{
    KIRQL OldIrql;
    PIRP pIrp = NULL;
    PULONG IrpRefCount = NULL;
    BOOLEAN ShouldCancel = FALSE;
    NTSTATUS Status = STATUS_PENDING;

    KeAcquireSpinLock(&pParameters->pCallOutContext->SpinLock,&OldIrql);

    pIrp = InterlockedExchangePointer(
           &pParameters->pConnectIrp,
           CANCELLED_CONNECT_IRP);

    if ((pIrp != NULL) && (pIrp != CANCELLED_CONNECT_IRP)) {
        IrpRefCount = pParameters->IrpRefCount;
        (*IrpRefCount) ++;
        ShouldCancel = TRUE;
    }

    KeReleaseSpinLock(&pParameters->pCallOutContext->SpinLock,OldIrql);

    if (ShouldCancel) {
        if (IoCancelIrp(pIrp)) {
            Status = STATUS_CANCELLED;
        }

        RxTdiDereferenceAndFreeIrp(IrpRefCount,pIrp);
    }

    return Status;
}

NTSTATUS
RxTdiCleanupAsynchronousConnect(
    IN PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters)
/*++

Routine Description:

    This routine disconnects all failed requests when asynchronous connection attempts
    are made.

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIRP     pIrp;

    PRXCE_CONNECTION pConnection;
    PRXCE_VC         pVc;

    RxProfile(RxTdi,RxTdiConnect);

    pConnection = &pParameters->Connection;
    pVc         = &pParameters->Vc;

    RxProfile(RxTdi,RxTdiDisconnect);

    if (pVc->pEndpointFileObject != NULL) {
        PDEVICE_OBJECT pDeviceObject;

        pDeviceObject = IoGetRelatedDeviceObject(pVc->pEndpointFileObject);

        pIrp = RxCeAllocateIrp(pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            TdiBuildDisassociateAddress(
                pIrp,
                pDeviceObject,
                pVc->pEndpointFileObject,
                NULL,
                NULL);

            Status = RxCeSubmitTdiRequest(
                         pDeviceObject,
                         pIrp);

            if (Status != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disassociate returned %lx\n",Status));
            }

            if (pParameters->CallOutStatus == STATUS_SUCCESS) {
                // Build the disconnect request to the underlying transport driver
                TdiBuildDisconnect(
                    pIrp,                                // the IRP
                    pDeviceObject,                       // the device object
                    pVc->pEndpointFileObject,            // the connection (VC) file object
                    NULL,                                // Completion routine
                    NULL,                                // completion context
                    NULL,                                // time
                    RXCE_DISCONNECT_ABORT,                     // disconnect options
                    pConnection->pConnectionInformation, // disconnect request connection information
                    NULL);                               // disconnect return connection information

                Status = RxCeSubmitTdiRequest(
                             pDeviceObject,
                             pIrp);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disconnect returned %lx\n",Status));
                }
            }

            RxCeFreeIrp(pIrp);
        }

        // Dereference the endpoint file object.
        ObDereferenceObject(pVc->pEndpointFileObject);

        // Close the endpoint file object handle
        ZwClose(pVc->hEndpoint);

        pVc->pEndpointFileObject = NULL;
        pVc->hEndpoint = INVALID_HANDLE_VALUE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RxTdiInitiateAsynchronousConnect(
     IN PRX_CREATE_CONNECTION_PARAMETERS_BLOCK pParameters)
/*++

Routine Description:

    This routine establishes a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pParameters - the connection parameters

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT     pTransport;
    PRXCE_ADDRESS       pAddress;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;

    OBJECT_ATTRIBUTES   VcAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                pIrp = NULL;

    PRXCE_CONNECTION_INFORMATION pReturnConnectionInformation = NULL;

    PFILE_FULL_EA_INFORMATION pConnectionContextEa;
    ULONG ConnectionContextEaBufferLength;

    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT pContext;

    RxProfile(RxTdi,RxTdiConnect);

    pConnection = &pParameters->Connection;
    pVc         = &pParameters->Vc;

    pVc->hEndpoint = INVALID_HANDLE_VALUE;
    pVc->pEndpointFileObject = NULL;

    if (pParameters->pConnectIrp ==  CANCELLED_CONNECT_IRP) {
        return STATUS_CANCELLED;
    }

    pParameters->IrpRefCount = (PULONG)RxAllocatePoolWithTag(
                                            NonPagedPool,
                                            sizeof(ULONG),
                                            RXCE_CONNECTION_POOLTAG);

    if (pParameters->IrpRefCount == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *(pParameters->IrpRefCount) = 1;

    pContext = (PRX_CREATE_CONNECTION_CALLOUT_CONTEXT)pParameters->pCallOutContext;

    pAddress    = pConnection->pAddress;
    pTransport  = pAddress->pTransport;

    DbgDumpTransportAddress(
        L"RxInitiateAsynchronousConnect",
        pTransport,
        (PTRANSPORT_ADDRESS)(pConnection->pConnectionInformation->RemoteAddress)
        );

    // Build an EA buffer for the specified connection context
    Status = BuildEaBuffer(
                 TDI_CONNECTION_CONTEXT_LENGTH,
                 TdiConnectionContext,
                 sizeof(PRXCE_VC),
                 &pContext->pConnectionContext,
                 &pConnectionContextEa,
                 &ConnectionContextEaBufferLength);

    if (!NT_SUCCESS(Status)) {
        if (pParameters->IrpRefCount != NULL) {
            RxFreePool(pParameters->IrpRefCount);
            pParameters->IrpRefCount = NULL;
        }

        return Status;
    }

    // Open the local connection endpoint.
    InitializeObjectAttributes(
        &VcAttributes,                  // OBJECT_ATTRIBUTES instance
        &RelativeName,                           // Name
        0,                              // Attributes
        pTransport->ControlChannel,     // RootDirectory
        NULL);                          // SecurityDescriptor

    Status = ZwCreateFile(
                 &pVc->hEndpoint,                             // Handle
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, // Desired Access
                 &VcAttributes,                              // Object Attributes
                 &IoStatusBlock,                             // Final I/O status block
                 0,                                          // Allocation Size
                 FILE_ATTRIBUTE_NORMAL,                      // Normal attributes
                 FILE_SHARE_READ,                            // Sharing attributes
                 FILE_OPEN_IF,                               // Create disposition
                 0,                                          // CreateOptions
                 pConnectionContextEa,                       // EA Buffer
                 ConnectionContextEaBufferLength);           // EA length

    // Free the connection context ea buffer.
    RxFreePool(pConnectionContextEa);

    if (NT_SUCCESS(Status)) {
        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            //  Obtain a referenced pointer to the file object.
            Status = ObReferenceObjectByHandle (
                         pVc->hEndpoint,                  // Object Handle
                         FILE_ANY_ACCESS,                 // Desired Access
                         NULL,                            // Object Type
                         KernelMode,                      // Processor mode
                         (PVOID *)&pVc->pEndpointFileObject,  // Object pointer
                         NULL);                           // Object Handle information

            if (NT_SUCCESS(Status)) {
                // Associate the local endpoint with the address object.
                TdiBuildAssociateAddress(
                    pIrp,
                    pTransport->pDeviceObject,
                    pVc->pEndpointFileObject,
                    NULL,
                    NULL,
                    pAddress->hAddress);

                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                if (NT_SUCCESS(Status)) {
                    // issue the connect request to the underlying transport provider.
                    TdiBuildConnect(
                        pIrp,
                        pTransport->pDeviceObject,
                        pVc->pEndpointFileObject,
                        NULL,
                        NULL,
                        &ConnectionTimeOut,
                        pConnection->pConnectionInformation,
                        pReturnConnectionInformation);

                    IoSetCompletionRoutine(
                        pIrp,                                // The IRP
                        RxTdiAsynchronousConnectCompletion,  // The completion routine
                        pParameters,                     // The completion context
                        TRUE,                                // Invoke On Success
                        TRUE,                                // Invoke On Error
                        TRUE);                               // Invoke On Cancel

                    InterlockedExchangePointer(
                        &pParameters->pConnectIrp,
                        pIrp);

                    //  Submit the request
                    Status = IoCallDriver(
                                 pTransport->pDeviceObject,
                                 pIrp);

                    if (!NT_SUCCESS(Status)) {
                        RxDbgTrace(0,Dbg,("RxTdiAsynchronousConnect: Connect IRP initiation failed, irp %lx, status 0x%x\n",pIrp, Status));
                    }
                    Status = STATUS_PENDING;
                } else {
                    // The associate address was not successful.
                    RxDbgTrace(0, Dbg,("TDI associate address returned %lx\n",Status));
                }
            } else {
                // error obtaining the file object for the connection.
                RxDbgTrace(0, Dbg,("error referencing endpoint file object %lx\n",Status));
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_PENDING) {
            if (pIrp != NULL) {
                RxCeFreeIrp(pIrp);
            }

            if (pParameters->IrpRefCount != NULL) {
                RxFreePool(pParameters->IrpRefCount);
            }

            if (pVc->pEndpointFileObject != NULL) {
                ObDereferenceObject(pVc->pEndpointFileObject);
                pVc->pEndpointFileObject = NULL;
            }

            if (pVc->hEndpoint != INVALID_HANDLE_VALUE) {
                // Close the endpoint file object handle
                ZwClose(pVc->hEndpoint);
                pVc->hEndpoint = INVALID_HANDLE_VALUE;
            }
        }
    } else {
        // error creating the connection object
        RxDbgTrace(0, Dbg,("Connection object(ZwCreate) returned %lx\n",Status));

        if (pParameters->IrpRefCount != NULL) {
            RxFreePool(pParameters->IrpRefCount);
            pParameters->IrpRefCount = NULL;
        }
    }

    return Status;
}

NTSTATUS
RxTdiReconnect(
    IN     PRXCE_TRANSPORT  pTransport,
    IN OUT PRXCE_ADDRESS    pAddress,
    IN OUT PRXCE_CONNECTION pConnection,
    IN OUT PRXCE_VC         pVc)
/*++

Routine Description:

    This routine establishes a connection between a local connection endpoint and
    a remote transport address.

Arguments:

    pTransport         - the associated transport

    pAddress           - the address object to be closed

    pConnection        - the RxCe connection instance

    pVc                - the RxCe virtual circuit instance.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status;

    PRXCE_CONNECTION_INFORMATION pReturnConnectionInformation = NULL;
    PIRP     pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    RxProfile(RxTdi,RxTdiReconnect);

    ASSERT(pVc->State == RXCE_VC_DISCONNECTED);

    if (pIrp != NULL) {
        // issue the connect request to the underlying transport provider.
        TdiBuildConnect(
            pIrp,
            pTransport->pDeviceObject,
            pVc->pEndpointFileObject,
            NULL,
            NULL,
            &ConnectionTimeOut,
            pConnection->pConnectionInformation,
            pReturnConnectionInformation);

        Status = RxCeSubmitTdiRequest(
                     pTransport->pDeviceObject,
                     pIrp);

        if (NT_SUCCESS(Status)) {
            InterlockedExchange(
                &pVc->State,
                RXCE_VC_ACTIVE);
        } else {
            // The reconnect request was not successful
            RxDbgTrace(0, Dbg,("RxTdiReconnect: TDI connect returned %lx\n",Status));
        }

        RxCeFreeIrp(pIrp);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxTdiDisconnect(
    IN PRXCE_TRANSPORT  pTransport,
    IN PRXCE_ADDRESS    pAddress,
    IN PRXCE_CONNECTION pConnection,
    IN PRXCE_VC         pVc,
    IN ULONG            DisconnectFlags)
/*++

Routine Description:

    This routine closes down a previously established connection.

Arguments:

    pTransport - the associated transport

    pAddress - the address object

    pConnection - the connection

    pVc    - the virtual circuit to be disconnected.

    DisconnectFlags - DisconnectOptions

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS        Status;
    PIRP pIrp;

    RxProfile(RxTdi,RxTdiDisconnect);

    pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    if (pIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TdiBuildDisassociateAddress(
        pIrp,
        pTransport->pDeviceObject,
        pVc->pEndpointFileObject,
        NULL,
        NULL);

    Status = RxCeSubmitTdiRequest(
                 pTransport->pDeviceObject,
                 pIrp);

    if (NT_SUCCESS(Status)) {
        // Build the disconnect request to the underlying transport driver
        TdiBuildDisconnect(
            pIrp,                                // the IRP
            pTransport->pDeviceObject,           // the device object
            pVc->pEndpointFileObject,            // the connection (VC) file object
            NULL,                                // Completion routine
            NULL,                                // completion context
            NULL,                                // time
            DisconnectFlags,                     // disconnect options
            pConnection->pConnectionInformation, // disconnect request connection information
            NULL);                               // disconnect return connection information

        Status = RxCeSubmitTdiRequest(
                     pTransport->pDeviceObject,
                     pIrp);

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disconnect returned %lx\n",Status));
        }
    } else {
        RxDbgTrace(0, Dbg,("RxTdiDisconnect: TDI disassociate returned %lx\n",Status));
    }

    RxCeFreeIrp(pIrp);

    return STATUS_SUCCESS;
}

NTSTATUS
RxTdiCloseAddress(
    IN OUT PRXCE_ADDRESS   pAddress)
/*++

Routine Description:

    This routine closes the address object.

Arguments:

    pRxCeAddress - the address object to be closed


Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Dereference the file object.
    if (pAddress->pFileObject != NULL) {
        ObDereferenceObject(pAddress->pFileObject);
    }

    // Close the address file object handle
    ZwClose(pAddress->hAddress);
    //DbgPrint("RDR closed address %lx\n", pAddress->hAddress);

    return Status;
}


NTSTATUS
RxTdiQueryInformation(
    IN  PRXCE_TRANSPORT  pTransport,
    IN  PRXCE_ADDRESS    pAddress,
    IN  PRXCE_CONNECTION pConnection,
    IN  PRXCE_VC         pVc,
    IN  ULONG            QueryType,
    IN  PVOID            pQueryBuffer,
    IN  ULONG            QueryBufferLength)
/*++

Routine Description:

    This routine queries the information w.r.t a connection

Arguments:

    pTransport         - the associated transport

    pAddress           - the address object to be closed

    pConnection        - the RxCe connection instance

    pVc                - the VC instance

    QueryType          - the class of information desired

    pQueryBuffer       - the buffer in whihc the data is to be returned

    QueryBufferLength  - the query buffer length.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PIRP      pIrp = NULL;

    // Obtain the related device object.
    pTransport->pDeviceObject = IoGetRelatedDeviceObject(pTransport->pControlChannelFileObject);

    pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

    if (pIrp != NULL) {
        PMDL pMdl;
        pMdl = RxAllocateMdl(
                   pQueryBuffer,                        // Virtual address for MDL construction
                   QueryBufferLength);                  // size of the buffer

        if ( pMdl != NULL ) {
            try {
                MmProbeAndLockPages( pMdl, KernelMode, IoModifyAccess );
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                IoFreeMdl( pMdl );
                Status = GetExceptionCode();
            }

            if (Status == STATUS_SUCCESS) {
                // Get the file object associated with trhe connection.

                TdiBuildQueryInformation(
                    pIrp,
                    pTransport->pDeviceObject,
                    pVc->pEndpointFileObject,
                    RxTdiRequestCompletion,           // Completion routine
                    NULL,                                  // Completion context
                    QueryType,
                    pMdl);

                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                MmUnlockPages(pMdl);
                IoFreeMdl(pMdl);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        RxCeFreeIrp(pIrp);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxTdiQueryAdapterStatus(
    IN  PRXCE_TRANSPORT  pTransport,
    IN  PADAPTER_STATUS  pAdapterStatus)
/*++

Routine Description:

    This routine queries the information w.r.t a connection

Arguments:

    pTransport         - the associated transport

    pAdapterStatus     - ADAPTER STATUS structure

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PIRP      pIrp = NULL;

    if (pTransport->pControlChannelFileObject != NULL) {
        // Obtain the related device object.
        pTransport->pDeviceObject = IoGetRelatedDeviceObject(pTransport->pControlChannelFileObject);

        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            PMDL pMdl;
            pMdl = RxAllocateMdl(
                       pAdapterStatus,                        // Virtual address for MDL construction
                       sizeof(ADAPTER_STATUS));               // size of the buffer

            if ( pMdl != NULL ) {
                try {
                    MmProbeAndLockPages( pMdl, KernelMode, IoModifyAccess );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    IoFreeMdl( pMdl );
                    Status = GetExceptionCode();
                }

                if (NT_SUCCESS(Status)) {
                    // Get the file object associated with the connection.
                    TdiBuildQueryInformation(
                        pIrp,
                        pTransport->pDeviceObject,
                        pTransport->pControlChannelFileObject,
                        NULL,                             // Completion routine
                        NULL,                             // Completion context
                        TDI_QUERY_ADAPTER_STATUS,
                        pMdl);

                    Status = RxCeSubmitTdiRequest(
                                 pTransport->pDeviceObject,
                                 pIrp);

                    MmUnlockPages(pMdl);
                    IoFreeMdl(pMdl);
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            RxCeFreeIrp(pIrp);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = STATUS_ADDRESS_NOT_ASSOCIATED;
    }

    return Status;
}

NTSTATUS
RxTdiSend(
    IN PRXCE_TRANSPORT   pTransport,
    IN PRXCE_ADDRESS     pAddress,
    IN PRXCE_CONNECTION  pConnection,
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext)
/*++

Routine Description:

    This routine closes down a previously established connection.

Arguments:

    pTransport - the associated transport

    pAddress - the address object

    pConnection - the connection

    pVc    - the virtual circuit to be disconnected.

    SendOptions - the options for transmitting the data

    pMdl        - the buffer to be transmitted.

    SendLength  - length of data to be transmitted

Return Value:

    STATUS_SUCCESS - if the call was successfull.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMDL     pPartialMdl  = NULL;
    ULONG    MdlByteCount = MmGetMdlByteCount(pMdl);
    PVOID    pMdlAddress  = MmGetMdlVirtualAddress(pMdl);

    ULONG    TdiOptions      = (~RXCE_FLAGS_MASK & SendOptions);
    BOOLEAN  SynchronousSend = ((SendOptions & RXCE_SEND_SYNCHRONOUS) != 0);

    RxProfile(RxTdi,RxTdiSend);

    ASSERT(pMdl->MdlFlags & (MDL_PAGES_LOCKED|MDL_SOURCE_IS_NONPAGED_POOL|MDL_PARTIAL));

    if (SendOptions & RXCE_SEND_PARTIAL) {
        if (MdlByteCount > SendLength) {
            pPartialMdl = IoAllocateMdl(pMdlAddress,SendLength,FALSE,FALSE,NULL);

            if (pPartialMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxBuildPartialHeaderMdl(pMdl,pPartialMdl,pMdlAddress,SendLength);
            }
        } else if (MdlByteCount == SendLength) {
            // No need to build a partial MDL, reuse the MDl
            pPartialMdl = pMdl;
        } else {
            ASSERT(!"MdlByteCount > SendLength");
            return STATUS_INVALID_PARAMETER;
        }
    } else {
        pPartialMdl = pMdl;
    }

    if (NT_SUCCESS(Status)) {
        PIRP                              pIrp = NULL;
        PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext = NULL;

        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            // Build the Send request to the underlying transport driver
            TdiBuildSend(
                pIrp,                                // the IRP
                pTransport->pDeviceObject,           // the device object
                pVc->pEndpointFileObject,            // the connection (VC) file object
                NULL,                                // Completion routine
                NULL,                                // completion context
                pPartialMdl,                         // the data buffer
                TdiOptions,                          // send flags
                SendLength);                         // send buffer length

            if (SynchronousSend) {
                // Synchronous Send Request
                Status = RxCeSubmitTdiRequest(
                             pTransport->pDeviceObject,
                             pIrp);

                if ((pConnection->pHandler != NULL) &&
                    (pConnection->pHandler->RxCeSendCompleteEventHandler != NULL)) {

                    (pConnection->pHandler->RxCeSendCompleteEventHandler)(
                        pConnection->pContext,
                        pVc,
                        pCompletionContext,
                        pIrp->IoStatus.Status);
                }
            } else {
                // Aysnchronous Send Request
                // CODE.IMPROVEMENT The assertion needs to be strengthened after
                // max command enfocement is in place.
                // (pCompletionContext != NULL) &&    // the caller provided a valid context
                ASSERT((pConnection->pHandler != NULL) && // the connection has a handler
                       (pConnection->pHandler->RxCeSendCompleteEventHandler != NULL));

                pRequestContext = (PRXTDI_REQUEST_COMPLETION_CONTEXT)
                                  RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(RXTDI_REQUEST_COMPLETION_CONTEXT),
                                     RXCE_TDI_POOLTAG);

                if (pRequestContext != NULL) {
                    if (pPartialMdl != pMdl) {
                        pRequestContext->pPartialMdl = pPartialMdl;
                    } else {
                        pRequestContext->pPartialMdl = NULL;
                    }

                    pRequestContext->pVc                = pVc;
                    pRequestContext->pCompletionContext = pCompletionContext;

                    pRequestContext->ConnectionSendCompletionHandler = pConnection->pHandler->RxCeSendCompleteEventHandler;
                    pRequestContext->pEventContext                   = pConnection->pContext;

                    Status = RxCeSubmitAsynchronousTdiRequest(
                                 pTransport->pDeviceObject,
                                 pIrp,
                                 pRequestContext);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        } else {
            // Could not allocate the IRP.
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (SynchronousSend) {
            if (pPartialMdl != pMdl) {
                IoFreeMdl( pPartialMdl );
            }

            if (pRequestContext != NULL) {
                RxFreePool(pRequestContext);
            }

            if (pIrp != NULL) {
                RxCeFreeIrp(pIrp);
            }
        } else {
            
            if( Status != STATUS_PENDING && 
                pPartialMdl != pMdl ) {

                IoFreeMdl( pPartialMdl );
            }
            
            // if (pIrp != NULL && Status != STATUS_PENDING) {
            //     DbgPrint("RDBSS AsyncSendReq returned %x %x\n", pIrp,Status);
            //     DbgBreakPoint();
            // }
        }
    }

    return Status;
}

NTSTATUS
RxTdiSendDatagram(
    IN PRXCE_TRANSPORT              pTransport,
    IN PRXCE_ADDRESS                pAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        Options,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext)
/*++

Routine Description:

    This routine closes down a previously established connection.

Arguments:

    pTransport - the associated transport

    pAddress - the address object

    pConnectionInformation - the remote address

    Options   - the send options.

    pMdl      - the send buffer

    SendLength  - length of data to be sent

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

    In the current implementation the SYNCHRONOUS flag is disregarded for sending
    datagrams because the underlying transports do not block on datagram sends.
    Submission of request and completion of request happen simultaneously.

    If a different behaviour is noted for some transports then the code for
    SendDatagrams need to be implemented along the lines of a send.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMDL     pPartialMdl = NULL;
    ULONG    MdlByteCount = MmGetMdlByteCount(pMdl);
    PVOID    pMdlAddress  = MmGetMdlVirtualAddress(pMdl);

    ULONG    TdiOptions      = (~RXCE_FLAGS_MASK & Options);

    RxProfile(RxTdi,RxTdiSendDatagram);

    ASSERT(pMdl->MdlFlags & (MDL_PAGES_LOCKED|MDL_SOURCE_IS_NONPAGED_POOL|MDL_PARTIAL));

    DbgDumpTransportAddress(
        L"RxTdiSendDatagram",
        pTransport,
        (PTRANSPORT_ADDRESS)(pConnectionInformation->RemoteAddress)
        );

    if (Options & RXCE_SEND_PARTIAL) {
        if (MdlByteCount > SendLength) {
            pPartialMdl = IoAllocateMdl(pMdlAddress,SendLength,FALSE,FALSE,NULL);

            if (pPartialMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxBuildPartialHeaderMdl(pMdl,pPartialMdl,pMdlAddress,SendLength);
            }
        } else if (MdlByteCount == SendLength) {
            // No need to build a partial MDL, reuse the MDl
            pPartialMdl = pMdl;
        } else {
            RxDbgTrace(0, Dbg,("Mdl Length - %lx Send Length %lx\n",MdlByteCount,SendLength));
            ASSERT(!"MdlByteCount > SendLength");
            Status = STATUS_INVALID_PARAMETER;
        }
    } else {
        pPartialMdl = pMdl;
    }

    if (NT_SUCCESS(Status)) {
        PIRP pIrp;

        pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);

        if (pIrp != NULL) {
            // Build the disconnect request to the underlying transport driver
            TdiBuildSendDatagram(
                pIrp,                                // the IRP
                pTransport->pDeviceObject,           // the device object
                pAddress->pFileObject,               // the connection (VC) file object
                NULL,                                // Completion routine
                NULL,                                // completion context
                pPartialMdl,                         // the send data buffer
                SendLength,                          // the send data buffer length
                pConnectionInformation);             // remote address information

            Status = RxCeSubmitTdiRequest(
                         pTransport->pDeviceObject,
                         pIrp);

        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ((pAddress->pHandler != NULL) &&
            (pAddress->pHandler->RxCeSendCompleteEventHandler != NULL)) {
            (pAddress->pHandler->RxCeSendCompleteEventHandler)(
                pAddress->pContext,
                pCompletionContext,
                Status);
        }

        if (pIrp != NULL) {
            RxCeFreeIrp(pIrp);
        }

        if ((pPartialMdl != pMdl) && (pPartialMdl != NULL)) {
            IoFreeMdl( pPartialMdl );
        }
    }

    return Status;
}

NTSTATUS
RxTdiRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the driver that it can proceed.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    RxDbgTrace(0, Dbg, ("CompletionEvent\n"));

    if (Context != NULL)
       KeSetEvent((PKEVENT )Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
}

NTSTATUS
RxCeSubmitTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PDevice_OBJECT DeviceObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    NTSTATUS Status;
    KEVENT Event;

    KeInitializeEvent (
        &Event,
        NotificationEvent,
        FALSE);

    IoSetCompletionRoutine(
        pIrp,                         // The IRP
        RxTdiRequestCompletion,  // The completion routine
        &Event,                       // The completion context
        TRUE,                         // Invoke On Success
        TRUE,                         // Invoke On Error
        TRUE);                        // Invoke On Cancel

    //
    //  Submit the request
    //

    RxDbgTrace(0, Dbg,("IoCallDriver(pDeviceObject = %lx)\n",pDeviceObject));
    Status = IoCallDriver(pDeviceObject, pIrp);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("IoCallDriver(pDeviceObject = %lx) returned %lx\n",pDeviceObject,Status));
    }

    if ((Status == STATUS_PENDING) || (Status == STATUS_SUCCESS)) {

        RxDbgTrace(0, Dbg,("Waiting for Tdi Request Completion ....\n"));

        Status = KeWaitForSingleObject(
                     &Event,     // Object to wait on.
                     Executive,  // Reason for waiting
                     KernelMode, // Processor mode
                     FALSE,      // Alertable
                     NULL);      // Timeout

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg,("RxTdiSubmitRequest could not wait Wait returned %lx\n",Status));
            return Status;
        }

        Status = pIrp->IoStatus.Status;
    } else {
        if (!KeReadStateEvent(&Event)) {
            DbgBreakPoint();
        }
    }

    RxDbgTrace(0, Dbg, ("RxCeSubmitTdiRequest returned %lx\n",Status));

    return Status;
}

NTSTATUS
RxTdiAsynchronousRequestCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
/*++

Routine Description:

   This routine completes an asynchronous send request.

Arguments:

    DeviceObject - unused.

    Irp - Supplies Irp that the transport has finished processing.

    Context - Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext;

    RxDbgTrace(0, Dbg,("RxTdiAsynchronousRequestCompletion\n"));

    pRequestContext = (PRXTDI_REQUEST_COMPLETION_CONTEXT)Context;

    if (pRequestContext->pPartialMdl != NULL) {
       // Free the partial MDL.
       IoFreeMdl(pRequestContext->pPartialMdl);
    }

    // Invoke the Completion event handler if any.
    if (pRequestContext->pVc == NULL) {
       if (pRequestContext->SendCompletionHandler != NULL) {
          (pRequestContext->SendCompletionHandler)(
                              pRequestContext->pEventContext,
                              pRequestContext->pCompletionContext,
                              pIrp->IoStatus.Status);
       }
    } else {
       if (pRequestContext->ConnectionSendCompletionHandler != NULL) {
          (pRequestContext->ConnectionSendCompletionHandler)(
                              pRequestContext->pEventContext,
                              pRequestContext->pVc,
                              pRequestContext->pCompletionContext,
                              pIrp->IoStatus.Status);
       }
    }

    // Free the IRP.
    RxCeFreeIrp(pIrp);

    // Free the request context
    RxFreePool(pRequestContext);

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
}

NTSTATUS
RxCeSubmitAsynchronousTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext
    )
/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PDevice_OBJECT DeviceObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/
{
    NTSTATUS Status;

    ASSERT(pRequestContext != NULL);

    IoSetCompletionRoutine(
        pIrp,                                // The IRP
        RxTdiAsynchronousRequestCompletion,  // The completion routine
        pRequestContext,                     // The completion context
        TRUE,                                // Invoke On Success
        TRUE,                                // Invoke On Error
        TRUE);                               // Invoke On Cancel

    //
    //  Submit the request
    //

    RxDbgTrace(0, Dbg, ("IoCallDriver(pDeviceObject = %lx)\n",pDeviceObject));

    Status = IoCallDriver(pDeviceObject, pIrp);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("IoCallDriver(pDeviceObject = %lx) returned %lx\n",pDeviceObject,Status));
    }

    RxDbgTrace(0, Dbg, ("RxCeSubmitAsynchronousTdiRequest returned %lx\n",Status));
    return Status;
}

NTSTATUS
BuildEaBuffer (
    IN  ULONG                     EaNameLength,
    IN  PVOID                     pEaName,
    IN  ULONG                     EaValueLength,
    IN  PVOID                     pEaValue,
    OUT PFILE_FULL_EA_INFORMATION *pEaBufferPointer,
    OUT PULONG                    pEaBufferLength
    )
/*++

Routine Description:

   Builds an EA buffer.

Arguments:

    EaNameLength     - Length of the Extended attribute name

    pEaName          - the extended attriute name

    EaValueLength    - Length of the Extended attribute value

    pEaValue         - the extended attribute value

    pBuffer          - the buffer for constructing the EA

--*/

{
   PFILE_FULL_EA_INFORMATION pEaBuffer;
   ULONG Length;

   RxDbgTrace(0, Dbg, ("BuildEaBuffer\n"));

   // Allocate an EA buffer for passing down the transport address
   *pEaBufferLength = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                      EaNameLength + 1 +
                      EaValueLength;

   pEaBuffer = (PFILE_FULL_EA_INFORMATION)
               RxAllocatePoolWithTag(
                    PagedPool,
                    *pEaBufferLength,
                    RXCE_TDI_POOLTAG);

   if (pEaBuffer == NULL) {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   *pEaBufferPointer = pEaBuffer;

   pEaBuffer->NextEntryOffset = 0;
   pEaBuffer->Flags           = 0;
   pEaBuffer->EaNameLength    = (UCHAR)EaNameLength;
   pEaBuffer->EaValueLength   = (USHORT)EaValueLength;

   RtlCopyMemory (
        pEaBuffer->EaName,
        pEaName,
        pEaBuffer->EaNameLength + 1);

   RtlCopyMemory(
        &pEaBuffer->EaName[EaNameLength + 1],
        pEaValue,
        EaValueLength);

   return STATUS_SUCCESS;
}

NTSTATUS
RxTdiCancelConnect(
         IN PRXCE_TRANSPORT  pTransport,
         IN PRXCE_ADDRESS    pAddress,
         IN PRXCE_CONNECTION pConnection)
{
   return STATUS_NOT_IMPLEMENTED;
}

#if DBG

void
DbgDumpTransportAddress(
    PWSTR RoutineName,
    PRXCE_TRANSPORT  pTransport,
    PTRANSPORT_ADDRESS pTA
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG i;
    PTA_ADDRESS taa;
    RxDbgTrace(0, Dbg,("%ws on %wZ, address count = %d\n",
                       RoutineName, &(pTransport->Name), pTA->TAAddressCount) );
    taa = pTA->Address;
    for( i = 0; i < (ULONG) pTA->TAAddressCount; i++ ){
        RxDbgTrace(0, Dbg, ("\t%d:Address length %d type %d: ",
                            i, taa->AddressLength, taa->AddressType ));
        switch (taa->AddressType) {
        case TDI_ADDRESS_TYPE_NETBIOS_EX: {
            PTDI_ADDRESS_NETBIOS_EX address = (PTDI_ADDRESS_NETBIOS_EX) taa->Address;
            RxDbgTrace( 0, Dbg, ("Endpoint: \"%16.16s\" type %d name \"%16.16s\"\n",
                                 address->EndpointName,
                                 address->NetbiosAddress.NetbiosNameType,
                                 address->NetbiosAddress.NetbiosName) );
            break;
        }
        case TDI_ADDRESS_TYPE_NETBIOS: {
            PTDI_ADDRESS_NETBIOS address = (PTDI_ADDRESS_NETBIOS) taa->Address;
            RxDbgTrace( 0, Dbg, ("NBType %d name \"%16.16s\"\n",
                                 address->NetbiosNameType,
                                 address->NetbiosName) );
            break;
        }
        case TDI_ADDRESS_TYPE_IP: {
            PTDI_ADDRESS_IP address = (PTDI_ADDRESS_IP) taa->Address;
            RxDbgTrace( 0, Dbg, ("IP port %d addr 0x%x\n", address->sin_port, address->in_addr ) );
            break;
        }
        default: {
            RxDbgTrace( 0, Dbg, ("Unknown!\n") );
        }
        }
        taa = (PTA_ADDRESS) (taa->Address + taa->AddressLength);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\rxcemm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxcemm.c

Abstract:

    This module contains the NT implementation of memory management for RxCe.

Notes:


--*/

#include "precomp.h"
#pragma  hdrstop
#include "rxtdip.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCEPOOL)

#define RXCE_ZONE_ALLOCATION 0x80

//
// Pool debugging data structures.
//
LIST_ENTRY s_RxMdlList;

// MDL debugging structures.

typedef struct _WRAPPED_RX_MDL {
    LIST_ENTRY  Next;
    PUCHAR      File;
    int         Line;
    PMDL        pMdl;
} WRAPPED_RX_MDL, *PWRAPPED_RX_MDL;

//
// Pool header data structure.  Ensure it is 8 byte aligned, no
// matter what members are added to the pool header
//
typedef struct _RX_POOL_HEADER {
    union {
        struct _RXH {
            BYTE  Signature[ 16 ];
            ULONG Size;
            ULONG Type;
            PSZ   AFileName;
            ULONG ALineNumber;
            PSZ   FFileName;
            ULONG FLineNumber;
        };
        UCHAR _pad[ (sizeof( struct _RXH ) + 7) & (~7) ];
    };
} RX_POOL_HEADER, *PRX_POOL_HEADER;

//
// Number of trailer bytes after a pool allocation with a known signature
//
#define TRAIL_BYTES  16

#ifdef RX_POOL_WRAPPER

PVOID
_RxAllocatePoolWithTag(
    ULONG Type,
    ULONG Size,
    ULONG Tag,
    PSZ   FileName,
    ULONG LineNumber
    )
/*++

Routine Description:

    This routine allocates the desired pool and sets up the debugging header and trailer
    to catch most instances of memory trashing

Arguments:

    Type    - type of pool to be allocated

    Size    - size of the allocation

Return Value:

    a valid pointer if successful, otherwise FALSE.

--*/
{
#if 0
    PCHAR pBuffer;
    PRX_POOL_HEADER pPoolHeader;

    ASSERT( Size != 0 );
    ASSERT(
        Type == PagedPool ||
        Type == (PagedPool | POOL_COLD_ALLOCATION) ||
        Type == NonPagedPool);

    ASSERT( (sizeof(RX_POOL_HEADER)&7) == 0  );

    pPoolHeader = ExAllocatePoolWithTagPriority(
                      Type,
                      sizeof( *pPoolHeader ) + Size + TRAIL_BYTES,
                      Tag,
                      LowPoolPriority);

    if ( pPoolHeader == NULL ) {
        RxLog(("RA:NULL %d %d %s\n", Type, LineNumber, &FileName[24]));
        return( NULL );
    }

    //
    // Fill the head so we can verify valid free's
    //
    RtlFillMemory( pPoolHeader->Signature, sizeof( pPoolHeader->Signature ), 'H' );
    pPoolHeader->Size = Size;
    pPoolHeader->Type = Type;
    pPoolHeader->AFileName = FileName;
    pPoolHeader->ALineNumber = LineNumber;
    pPoolHeader->FFileName = NULL;
    pPoolHeader->FLineNumber = 0;

    pBuffer = (PCHAR)(pPoolHeader + 1);

    //
    // Fill the memory to catch uninitialized structures, etc
    //
    RtlFillMemory( pBuffer, Size, '*' );

    //
    // Fill the tail to catch overruns
    //
    RtlFillMemory( pBuffer + Size, TRAIL_BYTES, 'T' );

    //
    // Make sure we're starting out valid
    //
    RxCheckMemoryBlock( pBuffer );

    return( pBuffer );
#endif

    return ExAllocatePoolWithTagPriority(
               Type,Size,Tag,LowPoolPriority);
}

VOID
_RxFreePool( PVOID pBuffer, PSZ FileName, ULONG LineNumber )
{
#if 0
    if( _RxCheckMemoryBlock( pBuffer, FileName, LineNumber ) ) {

        PRX_POOL_HEADER pPoolHeader = ((PRX_POOL_HEADER)pBuffer) - 1;

        //
        // Zap the block, to catch cases where we are using freed blocks
        //
        RtlFillMemory( pPoolHeader->Signature,
                      sizeof( pPoolHeader->Signature ),
                     'F' );

        pPoolHeader->FFileName = FileName;
        pPoolHeader->FLineNumber = LineNumber;
        RtlFillMemory( pPoolHeader+1,
                      pPoolHeader->Size + TRAIL_BYTES,
                     'F' );

        ExFreePool( pPoolHeader );
    }
#endif

    ExFreePool(pBuffer);
}

BOOLEAN
_RxCheckMemoryBlock(
    PVOID pBuffer,
    PSZ   FileName,
    ULONG LineNumber
    )
/*++

Routine Description:

    This routine frees up the pool allocated through RxAllocate

Arguments:

    pv       - the block to be freed

--*/
{
    PRX_POOL_HEADER pPoolHeader = ((PRX_POOL_HEADER)pBuffer) - 1;
    PCHAR pTail;
    ULONG i;

    if( pBuffer == NULL ) {
        DbgPrint( "RxCheckMemoryBlock( NULL ) at %s %d\n",
                   FileName, LineNumber );
        DbgBreakPoint();
        return FALSE;
    }

    //
    // Make sure we have a valid block
    //
    for( i=0; i < sizeof( pPoolHeader->Signature ); i++ ) {
        if( pPoolHeader->Signature[i] != 'H' ) {
            if( pPoolHeader->Signature[i] == 'F' && i == 0 ) {
                DbgPrint( "RxFreePool: Likely double free on block at %X\n", pPoolHeader );
            }

            DbgPrint( "RxCheckMemoryBlock: Invalid header signature for block %X\n", pPoolHeader );
            DbgPrint( "            Called from %s %d\n", FileName, LineNumber );
            DbgPrint( "            Originally Freed at %s %d\n",pPoolHeader->FFileName,pPoolHeader->FLineNumber);
            DbgPrint( "            Size is x%X, user part at %X\n", pPoolHeader->Size, pPoolHeader + 1 );
            DbgBreakPoint();
            return FALSE;
        }
    }

    if( pPoolHeader->Type != PagedPool && 
        pPoolHeader->Type != (PagedPool | POOL_COLD_ALLOCATION) &&
        pPoolHeader->Type != NonPagedPool) {
        DbgPrint( "RxCheckMemoryBlock:\n" );
        DbgPrint( "    Invalid PoolHeader->Type for block %X\n", pPoolHeader );
        DbgPrint( "    Called from %s %d\n", FileName, LineNumber );
        DbgBreakPoint();
        return FALSE;
    }

    if( pPoolHeader->Size == 0 ) {
        DbgPrint( "RxCheckMemoryBlock:\n" );
        DbgPrint( "     Size is 0 for block %X\n", pPoolHeader );
        DbgPrint( "    Called from %s %d\n", FileName, LineNumber );
        DbgBreakPoint();
        return FALSE;
    }

    //
    // Look to see if the buffer has been overrun
    //
    pTail = (PCHAR)pBuffer + pPoolHeader->Size;
    for( i=0; i < TRAIL_BYTES; i++ ) {
        if( *pTail++ != 'T' ) {
            DbgPrint( "RxCheckMemoryBlock: Overrun memory block at %X\n", pPoolHeader );
            DbgPrint( "            RxCheckMemoryBlock called from %s line %d\n", FileName, LineNumber );
            DbgPrint( "            Allocated at %s line %d\n", pPoolHeader->AFileName, pPoolHeader->ALineNumber );
            DbgPrint( "            Size is x%X, user part at %X\n", pPoolHeader->Size, pPoolHeader + 1 );
            DbgPrint( "            Overrun begins at %X\n", pTail-1 );
            DbgBreakPoint();
            return FALSE;
        }
    }

    return TRUE;
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\tdimisc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtdi.c

Abstract:

    This module implements the NT TDI related routines used by RXCE. The wrappers are necessary to
    ensure that all the OS dependencies can be localized to select modules like this for
    customization.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

--*/

#include "precomp.h"
#pragma  hdrstop

ULONG
ComputeTransportAddressLength(
      PTRANSPORT_ADDRESS pTransportAddress)
/*++

Routine Description:

   computes the length in bytes of a TRANSPORT_ADDRESS structure

Arguments:

    pTransportAddress - TRANSPORT_ADDRESS instance

Return Value:

    the length of the instance in bytes

Notes:

    Since this structure is packed the arithmetic has to be done using unaligned pointers.

--*/
{
   ULONG Size = 0;

   if (pTransportAddress != NULL) {
      LONG Index;

      TA_ADDRESS *pTaAddress;

      Size  = FIELD_OFFSET(TRANSPORT_ADDRESS,Address) +
              FIELD_OFFSET(TA_ADDRESS,Address) * pTransportAddress->TAAddressCount;

      pTaAddress = (TA_ADDRESS *)pTransportAddress->Address;

      for (Index = 0;Index <pTransportAddress->TAAddressCount;Index++) {
         Size += pTaAddress->AddressLength;
         pTaAddress = (TA_ADDRESS *)((PCHAR)pTaAddress +
                                               FIELD_OFFSET(TA_ADDRESS,Address) +
                                               pTaAddress->AddressLength);
      }
   }

   return Size;
}

PIRP
RxCeAllocateIrpWithMDL(
      IN CCHAR    StackSize,
      IN BOOLEAN  ChargeQuota,
      IN PMDL     Buffer)
/*++

Routine Description:

   computes the length in bytes of a TRANSPORT_ADDRESS structure

Arguments:

    pTransportAddress - TRANSPORT_ADDRESS instance

Return Value:

    the length of the instance in bytes

Notes:

    Currently the RxCeAllocateIrp and RxCeFreeIrp are implemented as wrappers around the
    IO calls. One possible optimization to consider would be to maintain a pool of IRP's
    which can be reused.

--*/
{
    PIRP pIrp = NULL;
    PRX_IRP_LIST_ITEM pListItem = NULL;

    pIrp = IoAllocateIrp(StackSize,ChargeQuota);

    if (pIrp != NULL) {
        pListItem = RxAllocatePoolWithTag(
                         NonPagedPool,
                         sizeof(RX_IRP_LIST_ITEM),
                         RX_IRPC_POOLTAG);

        if (pListItem == NULL) {
            IoFreeIrp(pIrp);
            pIrp = NULL;
        } else {
            KIRQL SavedIrql;

            pListItem->pIrp = pIrp;
            pListItem->CopyDataBuffer = Buffer;
            pListItem->Completed = 0;
            InitializeListHead(&pListItem->IrpsList);

            KeAcquireSpinLock(&RxIrpsListSpinLock,&SavedIrql);
            InsertTailList(&RxIrpsList,&pListItem->IrpsList);
            KeReleaseSpinLock(&RxIrpsListSpinLock,SavedIrql);
        }
    }

    return pIrp;
}

VOID
RxCeFreeIrp(PIRP pIrp)
/*++

Routine Description:

   frees an IRP

Arguments:

    pIrp - IRP to be freed

--*/
{
    KIRQL SavedIrql;
    PLIST_ENTRY pListEntry;
    BOOLEAN IrpFound = FALSE;
    PRX_IRP_LIST_ITEM pListItem = NULL;

    KeAcquireSpinLock(&RxIrpsListSpinLock,&SavedIrql);
    
    pListEntry = RxIrpsList.Flink;

    while (pListEntry != &RxIrpsList) {
        pListItem = CONTAINING_RECORD(
                        pListEntry,
                        RX_IRP_LIST_ITEM,
                        IrpsList);

        if (pListItem->pIrp == pIrp) {
            IrpFound = TRUE;
            //ASSERT(pListItem->Completed);
            RemoveEntryList(pListEntry);
            RxFreePool(pListItem);
            break;
        } else {
            pListEntry = pListEntry->Flink;
        }
    }

    KeReleaseSpinLock(&RxIrpsListSpinLock,SavedIrql);

    ASSERT(IrpFound);

    IoFreeIrp(pIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\wmi\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\rxtdip.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrxce.h

Abstract:

    This module contains the NT implementation related includes for the RxCe.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:


--*/

#ifndef _RXTDIP_H_
#define _RXTDIP_H_

typedef struct _RXTDI_REQUEST_COMPLETION_CONTEXT_ {
   PVOID                   pEventContext;
   PRXCE_VC                pVc;                    // VC Handle for connections
   PMDL                    pPartialMdl;            // the partial Mdl that was built for Xmit
   PVOID                   pCompletionContext;     // the callback context
   union {
      PRXCE_IND_SEND_COMPLETE            SendCompletionHandler;         // for datagrams
      PRXCE_IND_CONNECTION_SEND_COMPLETE ConnectionSendCompletionHandler; // for VC sends
   };
} RXTDI_REQUEST_COMPLETION_CONTEXT, *PRXTDI_REQUEST_COMPLETION_CONTEXT;

PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

#define RxCeAllocateIrp(StackSize,ChargeQuota) \
        RxCeAllocateIrpWithMDL(StackSize,ChargeQuota,NULL)

extern
VOID RxCeFreeIrp(PIRP pIrp);

extern
NTSTATUS RxTdiRequestCompletion(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP Irp,
               IN PVOID Context);

extern
NTSTATUS RxTdiAsynchronousRequestCompletion(
               IN PDEVICE_OBJECT DeviceObject,
               IN PIRP           Irp,
               IN PVOID          Context);

extern NTSTATUS
RxTdiSendPossibleEventHandler (
    IN PVOID EventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

extern NTSTATUS
BuildEaBuffer (
    IN  ULONG                     EaNameLength,
    IN  PVOID                     pEaName,
    IN  ULONG                     EaValueLength,
    IN  PVOID                     pEaValue,
    OUT PFILE_FULL_EA_INFORMATION *pEaBuffer,
    OUT PULONG                    pEaBufferLength
    );


extern NTSTATUS
RxCeSubmitTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

extern NTSTATUS
RxCeSubmitAsynchronousTdiRequest (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PRXTDI_REQUEST_COMPLETION_CONTEXT pRequestContext
    );

//
// TDI event handler extern definitions
//

extern
NTSTATUS
RxTdiConnectEventHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

extern NTSTATUS
RxTdiDisconnectEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG               DisconnectDataLength,
    IN PVOID              DisconnectData,
    IN LONG               DisconnectInformationLength,
    IN PVOID              DisconnectInformation,
    IN ULONG              DisconnectFlags
    );

extern NTSTATUS
RxTdiErrorEventHandler(
    IN PVOID    TdiEventContext,
    IN NTSTATUS Status                // status code indicating error type.
    );


extern NTSTATUS
RxTdiReceiveEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *BytesTaken,
    IN PVOID              Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP              *IoRequestPacket   // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

extern NTSTATUS
RxTdiReceiveDatagramEventHandler(
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *pIrp                  // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

extern NTSTATUS
RxTdiReceiveExpeditedEventHandler(
    IN PVOID               EventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG               ReceiveFlags,          //
    IN ULONG               BytesIndicated,        // number of bytes in this indication
    IN ULONG               BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG              *BytesTaken,          // number of bytes used by indication routine
    IN PVOID               Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

// Initialization routines

extern NTSTATUS
InitializeMiniRedirectorNotifier();

#endif // _RXTDIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\setup\makefile.inc ===
#
# This file is designed to be included from 1 level below
#

.SUFFIXES: .ba0 .bat .in0 .ini

{}.in0{$O)\}.ini:
    $(C_COMPILER_NAME) /EP /X $(MAKEDIR)\$< > $@
    $(BINPLACE_CMD)

{..\}.in0{$(O)\}.ini:
    $(C_COMPILER_NAME) /EP /X $(MAKEDIR)\$< > $@
    $(BINPLACE_CMD)

{}.ba0{$(O)\}.bat:

{..\}.ba0{$(O)\}.bat:
    $(C_COMPILER_NAME) /EP /X $(MAKEDIR)\$< > $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\wmi\wmltypes.inc ===
//#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType)

#define WMILIB_SIMPLE_TYPE(_TypeName, _EquivType, _FmtStr, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, FormatSimple, _MofStr, WMILIB_ALIGNEDCOPY)
   
#define WMILIB_COMPLX_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ALIGNEDCOPY)

#define WMILIB_STRING_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ASIS)

WMILIB_SIMPLE_TYPE(UBYTE, char, "u",          ItemByte)
WMILIB_SIMPLE_TYPE(SBYTE, char, "d",          ItemSByte)
WMILIB_SIMPLE_TYPE(XBYTE, char, "X",          ItemXByte)
WMILIB_SIMPLE_TYPE(OBYTE, char, "02o",        ItemOByte)
WMILIB_COMPLX_TYPE(BBYTE, char, FormatBinary, ItemXByte)

WMILIB_SIMPLE_TYPE(USHORT, short, "u",          ItemUShort)
WMILIB_SIMPLE_TYPE(SSHORT, short, "d",          ItemShort)
WMILIB_SIMPLE_TYPE(XSHORT, short, "X",          ItemXShort)
WMILIB_SIMPLE_TYPE(OSHORT, short, "o",          ItemOShort)
WMILIB_COMPLX_TYPE(BSHORT, short, FormatBinary, ItemXShort)

WMILIB_SIMPLE_TYPE(UINT, int, "u",          ItemULong)
WMILIB_SIMPLE_TYPE(SINT, int, "s",          ItemLong)
WMILIB_SIMPLE_TYPE(XINT, int, "X",          ItemULongX)
WMILIB_SIMPLE_TYPE(OINT, int, "o",          ItemULong)
WMILIB_COMPLX_TYPE(BINT, int, FormatBinary, ItemULong)

WMILIB_SIMPLE_TYPE(HANDLE, HANDLE, "x",     ItemULong)

WMILIB_SIMPLE_TYPE(ULONGLONG, _int64, "u", ItemULongLong)
WMILIB_SIMPLE_TYPE(SLONGLONG, _int64, "s", ItemLongLong)
WMILIB_SIMPLE_TYPE(XLONGLONG, _int64, "X", ItemULongLongX)
WMILIB_SIMPLE_TYPE(OLONGLONG, _int64, "o", ItemULongLong)

WMILIB_SIMPLE_TYPE(PTR,        void*, "x", ItemXPointer)

WMILIB_SIMPLE_TYPE(BOOLEAN, char, "u", ItemListByte (FALSE,TRUE) )

WMILIB_SIMPLE_TYPE(UCHAR, CHAR,  "c", ItemUChar)
WMILIB_SIMPLE_TYPE(ACHAR, CHAR,  "c", ItemChar)
WMILIB_SIMPLE_TYPE(WCHAR, WCHAR, "c", ItemShortSign)

WMILIB_STRING_TYPE(ASTR, WMILIBTYPE_STRING, FormatMisc, ItemString)
WMILIB_STRING_TYPE(WSTR, WMILIBTYPE_STRING, FormatMisc, ItemWString)
WMILIB_STRING_TYPE(USTR, WMILIBTYPE_STRING, FormatMisc, ItemPString)

WMILIB_COMPLX_TYPE(DATE,     LARGE_INTEGER, FormatMisc, ItemDate)
WMILIB_COMPLX_TYPE(TIMENT,   LARGE_INTEGER, FormatMisc, ItemTime)
WMILIB_COMPLX_TYPE(DATETIME, LARGE_INTEGER, FormatMisc, ItemDateTime)
WMILIB_COMPLX_TYPE(MILLISEC, LARGE_INTEGER, FormatMisc, ItemMillisec)
WMILIB_COMPLX_TYPE(ALETTER,  CHAR,          FormatMisc, ItemLetter)
WMILIB_COMPLX_TYPE(WLETTER,  WCHAR,         FormatMisc, ItemWLetter)
WMILIB_COMPLX_TYPE(GUID,     GUID,          FormatMisc, ItemGuid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rxce\daytona\tdihdlr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tdihdlr.c

Abstract:

    This module implements the NT TDI event handler routines.

Revision History:

    Balan Sethu Raman     [SethuR]    15-Feb-1995

Notes:

--*/

#include "precomp.h"
#pragma  hdrstop
#include "tdikrnl.h"
#include "rxtdip.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RXCETDI)


extern
NTSTATUS
ReceiveEventHandler(
    IN BOOLEAN             fExpedited,
    IN PRXCE_ADDRESS       pAddress,
    IN PRXCE_VC            pVc,
    IN ULONG               ReceiveFlags,
    IN ULONG               BytesIndicated,
    IN ULONG               BytesAvailable,
    OUT ULONG              *BytesTaken,
    IN PVOID               Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *pIrp              // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

extern NTSTATUS
ReceiveEventPostProcessing(
    PRXCE_VC          pVc,
    PRXCE_CONNECTION  pConnection,
    PMDL              pDataBuffer,
    ULONG             DataBufferSize,
    PIRP              *pIrpPointer);

extern VOID
ReceiveDatagramEventPostProcessing(
    PRXCE_ADDRESS     pAddress,
    PMDL              pDataBuffer,
    ULONG             DataBufferSize,
    PIRP              *pIrpPointer);

NTSTATUS
RxTdiConnectEventHandler(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )
/*++

Routine Description:

    This routine is called when a connect request has completed. The connection
    is fully functional when the indication occurs.

Arguments:

    TdiEventContext - the context value passed in by the user in the Set Event Handler call

    RemoteAddressLength,

    RemoteAddress,

    UserDataLength,

    UserData,

    OptionsLength,

    Options,

    ConnectionId

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (RemoteAddressLength);
    UNREFERENCED_PARAMETER (RemoteAddress);
    UNREFERENCED_PARAMETER (UserDataLength);
    UNREFERENCED_PARAMETER (UserData);
    UNREFERENCED_PARAMETER (OptionsLength);
    UNREFERENCED_PARAMETER (Options);
    UNREFERENCED_PARAMETER (ConnectionContext);

    return STATUS_INSUFFICIENT_RESOURCES;       // do nothing
}


NTSTATUS
RxTdiDisconnectEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG               DisconnectDataLength,
    IN PVOID              DisconnectData,
    IN LONG               DisconnectInformationLength,
    IN PVOID              DisconnectInformation,
    IN ULONG              DisconnectFlags
    )
/*++

Routine Description:

    This routine is used as the demultiplexing point for handling any
    connection disconnects for any address registered with the RxCe.

Arguments:

    EventContext         - the hAddress of the associated endpoint.

    ConnectionContext    - the hVc associated with the connection.

    DisconnectIndicators - Value indicating reason for disconnection indication.

Return Value:

    NTSTATUS - status of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_VC               pVc = (PRXCE_VC)ConnectionContext;
    PRXCE_ADDRESS          pAddress = (PRXCE_ADDRESS)EventContext;

    PRXCE_TRANSPORT   pTransport;
    PRXCE_CONNECTION  pConnection;

    RxProfile(RxTdi,RxTdiDisconnectEventHandler);

    try {
        if (RxCeIsVcValid(pVc) &&
            (pVc->pConnection->pAddress == pAddress)) {
            pConnection = pVc->pConnection;

            ASSERT(RxCeIsConnectionValid(pConnection));

            if (
                // There is a event handler associated with this connection
                (pConnection->pHandler != NULL) &&
                // and the disconnect event handler has been specified
                (pConnection->pHandler->RxCeDisconnectEventHandler != NULL)) {

                Status = pConnection->pHandler->RxCeDisconnectEventHandler(
                             pConnection->pContext,
                             pVc,
                             DisconnectDataLength,
                             DisconnectData,
                             DisconnectInformationLength,
                             DisconnectInformation,
                             DisconnectFlags);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg, ("Disconnect event handler notification returned %lx\n",Status));
                }
            }

            // The final action irrespective of the action taken by the handlers specified.
            if (DisconnectFlags & TDI_DISCONNECT_RELEASE) {
                // The disconnect has to be confirmed.
                //      Status = RxTdiDisconnect(
                //                        pTransport,
                //                        pAddress,
                //                        pConnection,
                //                        pVc,
                //                        RXCE_DISCONNECT_RELEASE);
            }

            // Mark the status of the local connection to prevent any subsequent sends
            // on this connection.
            InterlockedCompareExchange(
                &pVc->State,
                RXCE_VC_DISCONNECTED,
                RXCE_VC_ACTIVE);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}


NTSTATUS
RxTdiErrorEventHandler(
    IN PVOID    TdiEventContext,
    IN NTSTATUS Status                // status code indicating error type.
    )
/*++

Routine Description:

    This routine is used as the default error event handler for
    the transport endpoint.  It is pointed to by a field in the
    TP_ENDPOINT structure for an endpoint when the endpoint is
    created, and also whenever the TdiSetEventHandler request is
    submitted with a NULL EventHandler field.

Arguments:

    TransportEndpoint - Pointer to open file object.

    Status - Status code indicated by this event.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    UNREFERENCED_PARAMETER (TdiEventContext);
    UNREFERENCED_PARAMETER (Status);

    return STATUS_SUCCESS;
}


NTSTATUS
RxTdiReceiveEventHandler(
    IN PVOID              EventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *BytesTaken,
    IN PVOID              Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP              *IoRequestPacket   // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is used as the receive event handler for
    the transport endpoint.

Arguments:

    EventContext      - hAddresst.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveIndicators - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceive request, except that the ConnectionId field of
        the TdiRequest is ignored and is automatically filled in by the
        transport provider.

Return Value:

    NTSTATUS - status of operation.

--*/

{
   return ReceiveEventHandler(
              FALSE,                               // regular receive
              (PRXCE_ADDRESS)EventContext,
              (PRXCE_VC)ConnectionContext,
              ReceiveFlags,
              BytesIndicated,
              BytesAvailable,
              BytesTaken,
              Tsdu,
              IoRequestPacket);
}

NTSTATUS
RxTdiReceiveDatagramEventHandler(
    IN PVOID EventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *pIrp                  // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is used as the default receive datagram event
    handler for the transport endpoint.  It is pointed to by a
    field in the TP_ENDPOINT structure for an endpoint when the
    endpoint is created, and also whenever the TdiSetEventHandler
    request is submitted with a NULL EventHandler field.

Arguments:

    EventContext - event context ( hAddress )

    SourceAddress - Pointer to the network name of the source from which
        the datagram originated.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_ADDRESS     pAddress =  (PRXCE_ADDRESS)EventContext;
    PRXCE_TRANSPORT   pTransport;

    PMDL pDataBuffer;
    ULONG             DataBufferSize;

    RxProfile(RxTdi,RxCeReceiveDatagramEventHandler);

    ASSERT(RxCeIsAddressValid(pAddress));

    // Check if we have an event handler associated with this address
    if (
        // There is a event handler associated with this address
        (pAddress->pHandler != NULL)

        &&

        // and the expedited receive datagram handler has been specified
        (pAddress->pHandler->RxCeReceiveDatagramEventHandler != NULL)
        ) {

        Status = pAddress->pHandler->RxCeReceiveDatagramEventHandler(
                     pAddress->pContext,
                     SourceAddressLength,
                     SourceAddress,
                     OptionsLength,
                     Options,
                     ReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     &pDataBuffer,
                     &DataBufferSize);

        switch (Status) {
        case STATUS_SUCCESS:
        case STATUS_DATA_NOT_ACCEPTED:
            break;

        case STATUS_MORE_PROCESSING_REQUIRED:
            ReceiveDatagramEventPostProcessing(
                pAddress,
                pDataBuffer,
                DataBufferSize,
                pIrp);
            break;

        default:
         // log the error.
         break;
        }
    } else {
        // No handler is associated. Take the default action.
        Status = STATUS_DATA_NOT_ACCEPTED;
    }

    return Status;
}


NTSTATUS
RxTdiReceiveExpeditedEventHandler(
    IN PVOID               EventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG               ReceiveFlags,          //
    IN ULONG               BytesIndicated,        // number of bytes in this indication
    IN ULONG               BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG              *BytesTaken,          // number of bytes used by indication routine
    IN PVOID               Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

Arguments:

    EventContext - the context value passed in by the user in the Set Event Handler call

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
   return ReceiveEventHandler(
              TRUE,                               // expedited receive
              (PRXCE_ADDRESS)EventContext,
              (PRXCE_VC)ConnectionContext,
              ReceiveFlags,
              BytesIndicated,
              BytesAvailable,
              BytesTaken,
              Tsdu,
              IoRequestPacket);
}

NTSTATUS
RxTdiSendPossibleEventHandler (
    IN PVOID EventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable)
/*++

Routine Description:

Arguments:

    EventContext - the context value passed in by the user in the Set Event Handler call

    ConnectionContext - connection context of connection which can be sent on

    BytesAvailable - number of bytes which can now be sent

Return Value:

    ignored by the transport

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PRXCE_TRANSPORT   pTransport;
    PRXCE_ADDRESS     pAddress;
    PRXCE_VC          pVc;
    PRXCE_CONNECTION  pConnection;

    RxProfile(RxTdi,RxCeSendPossibleEventHandler);

    pVc = (PRXCE_VC)ConnectionContext;
    pConnection = pVc->pConnection;
    pAddress = pConnection->pAddress;
    pTransport = pAddress->pTransport;

    if (NT_SUCCESS(Status)) {
        // Check if we have an event handler associated with this connection.
        if (
            // There is a event handler associated with this connection
            (pConnection->pHandler != NULL)

            &&

            // and the expedited send possible event handler has been specified
            (pConnection->pHandler->RxCeSendPossibleEventHandler != NULL)
            ) {

            Status = pConnection->pHandler->RxCeSendPossibleEventHandler(
                         pConnection->pContext,
                         pVc,
                         BytesAvailable);
        } else {
            // No handler is associated. Take the default action.
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

NTSTATUS
ReceiveEventHandler(
    IN BOOLEAN             fExpedited,
    IN PRXCE_ADDRESS       pAddress,
    IN PRXCE_VC            pVc,
    IN ULONG               ReceiveFlags,
    IN ULONG               BytesIndicated,
    IN ULONG               BytesAvailable,
    OUT ULONG              *BytesTaken,
    IN PVOID               Tsdu,              // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP               *pIrp              // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    )
/*++

Routine Description:

    This routine is used as the receive event handler for
    the transport endpoint.

Arguments:

    fExpedited        - TRUE if it was a TDI_EXPEDITED_RECEIVE event

    EventContext      - hAddress.

    ConnectionContext - The client-supplied context associated with
        the connection on which this connection-oriented TSDU was received.

    ReceiveIndicators - Bitflags which indicate the circumstances surrounding
        this TSDU's reception.

    Tsdu - Pointer to an MDL chain that describes the (first) part of the
        (partially) received Transport Service Data Unit, less headers.

    IoRequestPacket - Pointer to a location where the event handler may
        chose to return a pointer to an I/O Request Packet (IRP) to satisfy
        the incoming data.  If returned, this IRP must be formatted as a
        valid TdiReceive request, except that the ConnectionId field of
        the TdiRequest is ignored and is automatically filled in by the
        transport provider.

Return Value:

    NTSTATUS - status of operation.

--*/

{
    NTSTATUS          Status = STATUS_UNSUCCESSFUL;

    PMDL              pDataBuffer = NULL;
    ULONG             DataBufferSize;

    PRXCE_CONNECTION  pConnection;

    RxProfile(RxTdi,ReceiveEventHandler);

    ASSERT(RxCeIsVcValid(pVc));

    if (ReceiveFlags & TDI_RECEIVE_PARTIAL) {
        // Stream mode transports always set this flag. They need to be handled in a
        // different way. The clients of RxCe need only be notified when we have
        // receieved a complete TSDU.
        Status = STATUS_DATA_NOT_ACCEPTED;
    } else {
        pConnection = pVc->pConnection;
        ASSERT(RxCeIsConnectionValid(pConnection));

        // Check if we have an event handler associated with this connection.
        if (
            // There is a event handler associated with this connection
            (pConnection->pHandler != NULL)
            ) {
            if (fExpedited) {    // Expedited receive
                // and the expedited receive event handler has been specified
                if (pConnection->pHandler->RxCeReceiveExpeditedEventHandler != NULL) {

                    Status = pConnection->pHandler->RxCeReceiveExpeditedEventHandler(
                                 pConnection->pContext,
                                 pVc,
                                 ReceiveFlags,
                                 BytesIndicated,
                                 BytesAvailable,
                                 BytesTaken,
                                 Tsdu,
                                 &pDataBuffer,
                                 &DataBufferSize);
                }
            } else if (pConnection->pHandler->RxCeReceiveEventHandler != NULL) {
                Status = pConnection->pHandler->RxCeReceiveEventHandler(
                             pConnection->pContext,
                             pVc,
                             ReceiveFlags,
                             BytesIndicated,
                             BytesAvailable,
                             BytesTaken,
                             Tsdu,
                             &pDataBuffer,
                             &DataBufferSize);
            }

            switch (Status) {
            case STATUS_SUCCESS:
            case STATUS_DATA_NOT_ACCEPTED:
                break;

            case STATUS_MORE_PROCESSING_REQUIRED:
                {
                    Status = ReceiveEventPostProcessing(
                                 pVc,
                                 pConnection,
                                 pDataBuffer,
                                 DataBufferSize,
                                 pIrp);
                }
            break;

            default:
                RxDbgTrace(0, Dbg, ("Receive Event Notification returned %lx\n",Status));
                break;
            }
        }
    }

    return Status;
}

NTSTATUS
RxTdiReceiveCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine is invoked upon completion of the reception of the desired amount of
    data.

Arguments:

    pDeviceObject - the device object

    pIrp          - the IRP

    pContext - the connection handle

--*/
{
    PRXCE_VC         pVc = (PRXCE_VC)pContext;

    if (pVc != NULL) {
        NTSTATUS Status;
        ULONG    BytesCopied = (ULONG)pIrp->IoStatus.Information;
        PRXCE_CONNECTION pConnection = pVc->pConnection;

        ASSERT(
            RxCeIsVcValid(pVc) &&
            RxCeIsConnectionValid(pConnection));

        if (pConnection->pHandler->RxCeDataReadyEventHandler != NULL) {
            Status = pConnection->pHandler->RxCeDataReadyEventHandler(
                         pConnection->pContext,
                         pVc->pReceiveMdl,
                         BytesCopied,
                         pIrp->IoStatus.Status);
        }

        pVc->pReceiveMdl = NULL;
    } else {
        ASSERT(!"Valid connection handle for receive completion");
    }

    RxCeFreeIrp(pIrp);

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ReceiveEventPostProcessing(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection,
    PMDL             pDataMdl,
    ULONG            DataBufferSize,
    PIRP             *pIrpPointer)
/*++

Routine Description:

    This routine is invoked when a recieve event notification to a connection engine client
    results in further requests for copying the data out of the transport drivers buffers

Arguments:

    pDataBuffer   - the buffer into which the data should be copied

    DataBufferSize - the size of the data

    pIrpPointer  - the IRP to the transport driver for processing the copy request.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED -- if successful
    otherwise appropriate error code

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PRXCE_ADDRESS    pAddress    = pConnection->pAddress;
    PRXCE_TRANSPORT  pTransport  = pAddress->pTransport;
    PIRP             pIrp;

    ASSERT(RxCeIsAddressValid(pAddress));
    ASSERT(RxCeIsTransportValid(pTransport));

    ASSERT(pConnection->pHandler->RxCeDataReadyEventHandler != NULL);

    pIrp = RxCeAllocateIrpWithMDL(pTransport->pDeviceObject->StackSize,FALSE,pDataMdl);
    *pIrpPointer = pIrp;
    if (pIrp != NULL) {
        pVc->pReceiveMdl = pDataMdl;

        TdiBuildReceive(
            pIrp,                                 // the IRP
            pTransport->pDeviceObject,            // the device object
            pVc->pEndpointFileObject,             // the connection (VC) file object
            RxTdiReceiveCompletion,               // Completion routine
            pVc,                                  // completion context
            pDataMdl,                             // the data buffer
            0,                                    // receive flags
            DataBufferSize);                      // receive buffer length

        //
        // Make the next stack location current.  Normally IoCallDriver would
        // do this, but for this IRP it has been bypassed.
        //

        IoSetNextIrpStackLocation(pIrp);
    } else {
        // An IRP for receiving the data was not allocated. Invoke the error handler
        // to communicate the status back.

        ASSERT(pConnection->pHandler->RxCeDataReadyEventHandler != NULL);
        
        if (pConnection->pHandler->RxCeDataReadyEventHandler != NULL) {
            Status = pConnection->pHandler->RxCeDataReadyEventHandler(
                         pConnection->pContext,
                         pDataMdl,
                         0,
                         STATUS_INSUFFICIENT_RESOURCES);
        }

        Status = STATUS_DATA_NOT_ACCEPTED;
    }

    return Status;
}

NTSTATUS
RxTdiReceiveDatagramCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine is invoked upon completion of the reception of the desired amount of
    data.

Arguments:

    pDeviceObject - the device object

    pIrp   - the IRP

    pContext - the connection handle

--*/
{
    NTSTATUS Status;
    PRXCE_ADDRESS pAddress = (PRXCE_ADDRESS)pContext;

    ASSERT(RxCeIsAddressValid(pAddress));

    if (pAddress != NULL) {
        ULONG BytesCopied = (ULONG)pIrp->IoStatus.Information;

        if (pAddress->pHandler->RxCeDataReadyEventHandler != NULL) {
            Status = pAddress->pHandler->RxCeDataReadyEventHandler(
                         pAddress->pContext,
                         pAddress->pReceiveMdl,
                         BytesCopied,
                         pIrp->IoStatus.Status);
        }

        pAddress->pReceiveMdl = NULL;
    } else {
        ASSERT(!"Valid Address handle for receive datagram completion");
    }

    RxCeFreeIrp(pIrp);

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
ReceiveDatagramEventPostProcessing(
    PRXCE_ADDRESS          pAddress,
    PMDL                   pDataMdl,
    ULONG                  DataBufferSize,
    PIRP                   *pIrpPointer)
/*++

Routine Description:

    This routine is invoked when a recieve event notification to a connection engine client
    results in further requests for copying the data out of the transport drivers buffers

Arguments:

    pDataBuffer   - the buffer into which the data should be copied

    DataBufferSize - the size of the data

    pIrpPointer  - the IRP to the transport driver for processing the copy request.

Return Value:

    a STATUS_SUCCESS returned from this routine only implies that an IRP for processing
    the request was setup correctly.

--*/
{
    PIRP            pIrp;
    PRXCE_TRANSPORT pTransport = pAddress->pTransport;

    ASSERT(RxCeIsTransportValid(pTransport));
    ASSERT(pAddress->pHandler->RxCeDataReadyEventHandler != NULL);

    *pIrpPointer = pIrp = RxCeAllocateIrp(pTransport->pDeviceObject->StackSize,FALSE);
    if (pIrp != NULL) {
        pAddress->pReceiveMdl = pDataMdl;

        TdiBuildReceive(
            pIrp,                                 // the IRP
            pTransport->pDeviceObject,            // the device object
            pAddress->pFileObject,                // the connection (VC) file object
            RxTdiReceiveDatagramCompletion,       // Completion routine
            pAddress,                             // completion context
            pDataMdl,                             // the data buffer
            0,                                    // send flags
            DataBufferSize);                      // send buffer length

        //
        // Make the next stack location current.  Normally IoCallDriver would
        // do this, but for this IRP it has been bypassed.
        //

        IoSetNextIrpStackLocation(pIrp);
    } else {
        // An IRP for receiving the data was not allocated. Invoke the error handler
        // to communicate the status back.
        if (pAddress->pHandler->RxCeErrorEventHandler != NULL) {
            pAddress->pHandler->RxCeErrorEventHandler(
                pAddress->pContext,
                STATUS_INSUFFICIENT_RESOURCES);
        } else {
            // No error handler to handle an erroneous situation.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\setup\sources.inc ===
#
# This file is designed to be included from 1 level below
#

RXOBJ = $(O)

SYNCHRONIZE_BLOCK=1

MAJORCOMP=rdr2
MINORCOMP=setup

TARGETNAME=setup
TARGETPATH=obj
TARGETTYPE=notarget

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=


NTTARGETFILE0=\
   $(RXOBJ)\rdr1.bat      \
   $(RXOBJ)\rdr2.bat      \
   $(RXOBJ)\rdr2.ini      \
   $(RXOBJ)\rdr1.ini      \
   $(RXOBJ)\mrxsmb.ini    \
   $(RXOBJ)\rdbss.ini

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
###NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\setup\daytona\makefile.inc ===
!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\wmi\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

	This code is a quick hack to enable WMI tracing in cluster drivers.
	It should eventually go away.

	WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

	WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "stdio.h"

#include <wmistr.h>
#include <evntrace.h>

#include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PWML_CONTROL_GUID_REG GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (WmiLibInfo->GuidCount == 0) || (WmiLibInfo->ControlGuids == NULL) ))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmlpFindGuid(WmiLibInfo->ControlGuids,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex) )
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PWML_CONTROL_GUID_REG guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG bufferNeeded;
            ULONG i;
            UNICODE_STRING nullRegistryPath;

            regPath = WmiLibInfo->DriverRegPath;
            guidList = WmiLibInfo->ControlGuids;
            guidCount = WmiLibInfo->GuidCount;

            if (regPath == NULL)
            {
                // No registry path specified. This is a bad thing for 
                // the device to do, but is not fatal
                nullRegistryPath.Buffer = NULL;
                nullRegistryPath.Length = 0;
                nullRegistryPath.MaximumLength = 0;
                regPath = &nullRegistryPath;
            }                
            
            registryPathOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                  guidCount * sizeof(WMIREGGUIDW);

            bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

            if (bufferNeeded <= bufferSize)
            {
                retSize = bufferNeeded;
                RtlZeroMemory(buffer, bufferNeeded);

                wmiRegInfo = (PWMIREGINFO)buffer;
                wmiRegInfo->BufferSize = bufferNeeded;
                // wmiRegInfo->NextWmiRegInfo = 0;
                // wmiRegInfo->MofResourceName = 0;
                wmiRegInfo->RegistryPath = registryPathOffset;
                wmiRegInfo->GuidCount = guidCount;

                for (i = 0; i < guidCount; i++)
                {
                    wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                    wmiRegGuid->Guid = guidList[i].Guid;
                    wmiRegGuid->Flags = WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID;
                    // wmiRegGuid->InstanceInfo = 0;
                    // wmiRegGuid->InstanceCount = 0;
                }

                stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                *stringPtr++ = regPath->Length;
                RtlCopyMemory(stringPtr,
                          regPath->Buffer,
                          regPath->Length);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
                *((PULONG)buffer) = bufferNeeded;
                retSize = sizeof(ULONG);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        {
            PWNODE_HEADER   Wnode = irpStack->Parameters.WMI.Buffer;
            PWML_CONTROL_GUID_REG Ctx = WmiLibInfo->ControlGuids + guidIndex;
            if (irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER)) {
                status = STATUS_SUCCESS;

                if (minorFunction == IRP_MN_DISABLE_EVENTS) {
                    //DbgPrint("WMI disable\n");
                    Ctx->EnableLevel = 0;
                    Ctx->EnableFlags = 0;
                    Ctx->LoggerHandle = 0;
                } else {
                    Ctx->LoggerHandle = (TRACEHANDLE)( Wnode->HistoricalContext );
                    
                    Ctx->EnableLevel = WmiGetLoggerEnableLevel(Ctx->LoggerHandle); // UCHAR
                    Ctx->EnableFlags = WmiGetLoggerEnableFlags(Ctx->LoggerHandle); // ULONG
                    //DbgPrint("WMI enable: %lx %lx\n",Ctx->EnableLevel,Ctx->EnableFlags);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        {
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_EXECUTE_METHOD:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return(status);
}

#define MAX_SCRATCH_LOG 256

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    union {
        MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
        UCHAR     ScratchPad[MAX_SCRATCH_LOG];
    };

} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    TRACE_BUFFER TraceBuffer;
    va_list ArgList;
    ULONG Length;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    va_start(ArgList, FormatString);
    Length = _vsnprintf(TraceBuffer.ScratchPad, MAX_SCRATCH_LOG, FormatString, ArgList);
    TraceBuffer.ScratchPad[Length] = 0;
    va_end(ArgList);


    TraceBuffer.Wnode.BufferSize = 
        (ULONG) ((ULONG_PTR)(TraceBuffer.ScratchPad + Length) - (ULONG_PTR)&TraceBuffer);
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\sources.inc ===
!IF 0

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sources.inc

!ENDIF


INCLUDES=.; \
         ..; \
         $(PROJECT_ROOT)\fs\remotefs\dfs\inc; \
         $(PROJECT_ROOT)\ntos\inc; \
	 $(DS_INC_PATH)\dfs


MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /W3 /WX

RUN_WPP=$(SOURCES) -ini:$(PROJECT_ROOT)\fs\remotefs\dfs\inc\tracewpp.ini

LINKER_STACKCOMMITSIZE=32768
COMPILER_WARNINGS=/FI$(PROJECT_ROOT)\fs\remotefs\dfs\inc\dfswarnings.h


PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\wmi\wmlmacro.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlmacro.h

Abstract:

    This file defines macro for an easy wmi tracing.

Author:

    gorn

Revision History:

--*/
#ifndef WMLMACRO_H
#define WMLMACRO_H 1

typedef struct {char x[418957];} WMILIBTYPE_STRING;

#undef  WMILIB_TYPEDEF
#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType) \
    typedef _EquivType WMILIBTYPE_ ## _TypeName ;
#include "wmltypes.inc"

typedef union _WMLLOCALSTRUCT {
    UCHAR    uchar;
    USHORT   ushort;
    ULONG    uint;
    WCHAR    wchar;
    LONGLONG longlong;
} WMLLOCALSTRUCT;

#define WMLLOCAL WMLLOCALSTRUCT _wmllocal

#define WMILIB_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WMILIB_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WMILIB_CHECKED_ZERO( _Value, _Type) )

#define WMILIB_LOGPAIR(_a, _b) (_a),(_b),

#define WMILIB_LOGARGVALTYPE(_value, _type) \
            WMILIB_LOGPAIR(WMILIB_CHECKED_SIZEOF(_value, _type), &(_value) )

#define LOG(_TypeName, _Value)                         \
    WMILIB_LOGARGVALTYPE( _Value, WMILIBTYPE_ ## _TypeName)

#define LOGASTR(_value) \
    WMILIB_LOGPAIR( strlen(_value) + WMILIB_CHECKED_ZERO((_value)[0],CHAR), _value )

#define LOGWSTR(_value) \
    WMILIB_LOGPAIR( wcslen(_value) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value)[0],WCHAR), _value)

#define LOGCSTR(_x) \
    WMILIB_LOGPAIR( sizeof((_x).Length) + WMILIB_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGUSTR(_x)                                                            \
    WMILIB_LOGPAIR( sizeof((_x).Length)                                        \
                    + WMILIB_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )          \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(CHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], CHAR), _x ) 

#define LOGWCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )           \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(WCHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], WCHAR), _x ) 

#define LOGTIME(_Value)    LOG(TIMENT,  _Value)
#define LOGPTR(_Value)     LOG(PTR,     _Value)
#define LOGHANDLE(_Value)  LOG(HANDLE,  _Value)
#define LOGSTATUS(_Value)  LOG(XINT,    _Value)
#define LOGBYTE(_Value)    LOG(UBYTE,   _Value)
#define LOGULONG(_Value)   LOG(UINT,    _Value)
#define LOGULONGLONG(_Value)   LOG(ULONGLONG,    _Value)
#define LOGXLONG(_Value)   LOG(XINT,    _Value)
#define LOGXSHORT(_Value)  LOG(XSHORT,  _Value)
#define LOGUCHAR(_Value)   LOG(UCHAR,   _Value)
#define LOGIRQL(_Value)    LOG(UCHAR,   _Value)
#define LOGBOOL(_Value)    LOG(BOOL,    _Value)
#define LOGBOOLEAN(_Value) LOG(BOOLEAN, _Value)
#define LOGARSTR(_Value)   LOGASTR(_Value)
#define LOGPNPMN(_Value)   LOG(UCHAR,   _Value)
#define LOGIOCTL(_Value)   LOG(ULONG,   _Value)
#define LOGGUID(_Val)      LOG(GUID, _Val)

#define LOGVAL(_val)        (sizeof(_val)), (&(_val)),

#define WML_FLAGS(_Val)  ( (ULONG)(_Val) )
#define WML_STREAM(_Val) ( (ULONG)(_Val) )

#define WML_CONTROL(_prefix, _stream) \
            ( _prefix ## ControlGuids[ WML_STREAM(_stream) ] )
            
#define WML_ENABLED(_prefix, _stream, _level, _flags) \
            (( WML_CONTROL(_prefix, _stream).EnableLevel >= (_level) ) &&   \
             ( WML_CONTROL(_prefix, _stream).EnableFlags & WML_FLAGS(_flags) ))
            
#define WML_TRACEGUID(_prefix, _stream, _id) \
            ( WML_CONTROL(_prefix, _stream).TraceGuids[ WML_GUID(_id) ] )
            
#define WML_LOG(_prefix, _stream, _level, _flags, _id, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlTrace( WML_ID(_id), \
                     &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, _arg); \
        } \
    } while (0)            

#define WML_PRINTF(_prefix, _stream, _level, _flags, _id, _fmtstr, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlPrintf( WML_ID(_id), \
                      &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, \
                      _fmtstr, _arg); \
        } \
    } while (0)            


#endif // WMLMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\referralserver\apisupport.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <lm.h>
#include <lmdfs.h>
#include <netdfs.h>
#include <DfsServerLibrary.hxx>
#include <validc.h>
#include "ReferralServerLog.hxx"
//
// logging specific includes
//

#include "apisupport.tmh"


extern ULONG Flags;
CRITICAL_SECTION DfsApiLock;
BOOL DfsLockInitialized = FALSE;
BOOL ServerListen = FALSE;


#define DFS_API_START()                          \
             EnterCriticalSection( &DfsApiLock );      \
             _try                                 \
             {



#define DFS_API_END()                                  \
             } _finally {                                 \
                LeaveCriticalSection( &DfsApiLock);         \
             }


extern
DFSSTATUS
DfsEnum(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    OUT LPBYTE *pBuffer,
    OUT LPDWORD pEntriesRead,
    IN OUT LPDWORD pResumeHandle);

NET_API_STATUS
DfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle);

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerGetVersion
//
//  Synopsis:   Returns the version of this server side implementation.
//
//  Arguments:  None.
//
//  Returns:    The version number.
//
//-----------------------------------------------------------------------------

DWORD
NetrDfsManagerGetVersion()
{
    DWORD Version = 4;

    return( Version );
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAdd 
//  Synopsis:   
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume/link to be created, or
//                      to which a replica should be added.
//              [ServerName] -- Name of server backing the volume.
//              [ShareName] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this volume, only used
//                      when DFS_ADD_VOLUME is specified.
//              [Flags] -- If DFS_ADD_VOLUME, a new volume will be created.
//                      If DFS_ADD_LINK, a new link to another Dfs will be
//                      create. If 0, a replica will be added.
//
//  Returns:    [NERR_Success] -- Operation succeeded.
// 
//              Error other wise.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAdd(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags)
{
    NET_API_STATUS Status = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs Add %ws %ws %ws\n", DfsEntryPath, ServerName, ShareName);

    DFS_API_START();

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsAdd( DfsEntryPath,
                         ServerName,
                         ShareName,
                         Comment,
                         Flags );
    }

    DFS_API_END();

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add %ws, Status 0x%x\n", DfsEntryPath, Status);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAdd2
//
//  Synopsis:   Adds a volume/replica/link to this Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume/link to be created, or
//                      to which a replica should be added.
//              [DcName] -- Name of Dc to use
//              [ServerName] -- Name of server backing the volume.
//              [ShareName] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this volume, only used
//                      when DFS_ADD_VOLUME is specified.
//              [Flags] -- If DFS_ADD_VOLUME, a new volume will be created.
//                      If DFS_ADD_LINK, a new link to another Dfs will be
//                      create. If 0, a replica will be added.
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              Erroroce otherwise.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAdd2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs Add2 %ws DC:%ws Server:%ws Share:%ws\n", DfsEntryPath, DcName, ServerName, ShareName);

    DFS_API_START();

    //
    // For now, we dont use DC name or pprootlist. We will use
    // this once we implement domain dfs.
    //
    UNREFERENCED_PARAMETER( DcName );
    UNREFERENCED_PARAMETER( ppRootList );

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsAdd( DfsEntryPath,
                         ServerName,
                         ShareName,
                         Comment,
                         Flags );
    }

    DFS_API_END();

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add2 %ws, Status 0x%x\n", DfsEntryPath, Status);
    return Status;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsGetDcAddress
//
//  Synopsis:   Gets the DC to go to so that we can create an FtDfs object for
//              this server.
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- Dc to use
//              [IsRoot] -- TRUE if this server is a Dfs root, FALSE otherwise
//              [Timeout] -- Timeout, in sec, that the server will stay with this DC
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsGetDcAddress(
    IN LPWSTR ServerName,
    IN OUT LPWSTR *DcName,
    IN OUT BOOLEAN *IsRoot,
    IN OUT ULONG *Timeout)
{
    NET_API_STATUS Status = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(ServerName);

    //
    // Currently, not supported
    //

    if(DcName == NULL)
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    *DcName = (LPWSTR)MIDL_user_allocate(4);
    if (*DcName == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    else 
    {
        (*DcName)[0] = L' ';
        (*DcName)[1] = 0;
    }

    if(IsRoot)
    {
        *IsRoot = FALSE;
    }

    if(Timeout)
    {
        *Timeout = 1000;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetDcAddress
//
//  Synopsis:   Sets the DC to go to for the dfs blob
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- Dc to use
//              [Timeout] -- Time, in sec, to stay with that DC
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetDcAddress(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN ULONG Timeout,
    IN DWORD Flags)
{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(DcName);
    UNREFERENCED_PARAMETER(Timeout);
    UNREFERENCED_PARAMETER(Flags);

    //
    // Currently, not supported
    //

    return ERROR_SUCCESS;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsFlushFtTable
//
//  Synopsis:   Flushes an FtDfs entry from the FtDfs cache
//
//  Arguments:  [DcName] -- Dc to use
//              [FtDfsName] -- Name of FtDfs
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsFlushFtTable(
    IN LPWSTR DcName,
    IN LPWSTR FtDfsName)
{
    UNREFERENCED_PARAMETER(DcName);
    UNREFERENCED_PARAMETER(FtDfsName);

    //
    // This will NEVER be supported.
    //

    return ERROR_NOT_SUPPORTED;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddStdRoot
//
//  Synopsis:   Creates a new Std Dfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this root.
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [NERR_DfsInternalCorruption] -- An internal database
//                      corruption was encountered while executing this
//                      operation.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN DWORD  ApiFlags)
{
    NET_API_STATUS Status = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs Add Std Root Server:%ws, Share:%ws\n", ServerName, RootShare);
    DFS_API_START();

    if (Flags & DFS_LOCAL_NAMESPACE)
    {
        ServerName = NULL;
    }
    //
    // Add a standalone root.
    //

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsAddStandaloneRoot( ServerName,
                                       RootShare,
                                       Comment,
                                       ApiFlags );
    }

    DFS_API_END();

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add Std Root %ws\n", RootShare);
    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddStdRootForced
//
//  Synopsis:   Creates a new Std Dfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [Comment] -- Comment associated with this root.
//              [Share] -- drive:\dir behind the share
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddStdRootForced(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN LPWSTR Share)
{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(RootShare);
    UNREFERENCED_PARAMETER(Comment);
    UNREFERENCED_PARAMETER(Share);
    //
    // This will probably be never supported.
    //
    return ERROR_NOT_SUPPORTED;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemove (Obsolete)
//
//  Synopsis:   Deletes a volume/replica/link from the Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry path of the volume to operate on.
//              [ServerName] -- If specified, indicates the replica of the
//                      volume to operate on.
//              [ShareName] -- If specified, indicates the share on the
//                      server to operate on.
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//-----------------------------------------------------------------------------


extern "C" NET_API_STATUS
NetrDfsRemove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName)
{
    NET_API_STATUS Status = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs remove %ws\n", DfsEntryPath);
    //
    // call DfsRemove to do this operation.
    //

    DFS_API_START();

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsRemove( DfsEntryPath,
                            ServerName,
                            ShareName );
    }

    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs remove %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemove2
//
//  Synopsis:   Deletes a volume/replica/link from the Dfs.
//
//  Arguments:  [DfsEntryPath] -- Entry path of the volume to operate on.
//              [DcName] -- Name of Dc to use
//              [ServerName] -- If specified, indicates the replica of the
//                      volume to operate on.
//              [ShareName] -- If specified, indicates the share on the
//                      server to operate on.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemove2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    UNREFERENCED_PARAMETER(DcName);
    UNREFERENCED_PARAMETER(ppRootList);
    
    NET_API_STATUS Status  = ERROR_SUCCESS;

    //
    // For now we ignore the DcName and rootlist, these are needed
    // when we implement dom dfs.
    //

    DFS_TRACE_HIGH( API, "Net Dfs remove2 %ws\n", DfsEntryPath);

    DFS_API_START( );

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsRemove( DfsEntryPath,
                            ServerName,
                            ShareName );
    }

    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs remove2 %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}





//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemoveStdRoot
//
//  Synopsis:   Deletes a Dfs root
//
//  Arguments:  [ServerName] -- The server to remove.
//              [RootShare] -- The Root share hosting the Dfs/FtDfs
//              [Flags] -- Flags for the operation
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemoveStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN DWORD  Flags)
{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(Flags);
    
    NET_API_STATUS Status  = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs remove std root %ws\n", RootShare);
    
    DFS_API_START( );

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsDeleteStandaloneRoot( ServerName, RootShare );
    }

    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs remove std root %ws, Status %x\n", RootShare, Status);

    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetInfo (Obsolete)
//
//  Synopsis:   Sets the comment, volume state, or replica state.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of the volume for which info is
//                      to be set.
//              [ServerName] -- If specified, the name of the server whose
//                      state is to be set.
//              [ShareName] -- If specified, the name of the share on
//                      ServerName whose state is to be set.
//              [Level] -- Level of DfsInfo
//              [DfsInfo] -- The actual Dfs info.
//
//  Returns:    [NERR_Success] -- Operation completed successfully.
//
//-----------------------------------------------------------------------------


extern "C" NET_API_STATUS
NetrDfsSetInfo(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    IN LPDFS_INFO_STRUCT pDfsInfo)
{
    NET_API_STATUS Status  = ERROR_SUCCESS;
    NET_API_STATUS AccessStatus;
    
    DFS_TRACE_HIGH( API, "Net Dfs set info %ws\n", DfsEntryPath);
    DFS_API_START( );

    //
    // we have to allow resynchronize events from every one.
    // So do the access check for all calls except the resychronize.
    //

    AccessStatus = AccessImpersonateCheckRpcClient();
    
    Status = DfsSetInfoCheckAccess( DfsEntryPath,
                                    ServerName,
                                    ShareName,
                                    Level,
                                    (LPBYTE)pDfsInfo,
                                    AccessStatus );

    DFS_API_END( );
    
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs set info %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsSetInfo2
//
//  Synopsis:   Sets the comment, volume state, or replica state.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of the volume for which info is
//                      to be set.
//              [ServerName] -- If specified, the name of the server whose
//                      state is to be set.
//              [ShareName] -- If specified, the name of the share on
//                      ServerName whose state is to be set.
//              [Level] -- Level of DfsInfo
//              [DfsInfo] -- The actual Dfs info.
//
//  Returns:    [NERR_Success] -- Operation completed successfully.
//
//              [ERROR_INVALID_LEVEL] -- Level != 100 , 101, or 102
//
//              [ERROR_INVALID_PARAMETER] -- DfsEntryPath invalid, or
//                      ShareName specified without ServerName.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to
//                      a valid Dfs volume.
//
//              [NERR_DfsNoSuchShare] -- The indicated ServerName/ShareName do
//                      not support this Dfs volume.
//
//              [NERR_DfsInternalCorruption] -- Internal database corruption
//                      encountered while executing operation.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsSetInfo2(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR DcName,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    IN LPDFS_INFO_STRUCT pDfsInfo,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status  = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(ppRootList);
    UNREFERENCED_PARAMETER(DcName);

    DFS_TRACE_HIGH( API, "Net Dfs set info2 %ws\n", DfsEntryPath);
    //
    // DcName and rootlist not supported, for now.
    //
    DFS_API_START( );


    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsSetInfo( DfsEntryPath,
                             ServerName,
                             ShareName,
                             Level,
                             (LPBYTE)pDfsInfo );
    }

    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs set info %ws, Status %x\n", DfsEntryPath, Status);

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsGetInfo
//
//  Synopsis:   Server side implementation of the NetDfsGetInfo.
//
//  Arguments:  [DfsEntryPath] -- Entry Path of volume for which info is
//                      requested.
//
//              [ServerName] -- Name of server which supports this volume
//                      and for which info is requested.
//
//              [ShareName] -- Name of share on ServerName which supports this
//                      volume.
//
//              [Level] -- Level of Info requested.
//
//              [DfsInfo] -- On successful return, contains a pointer to the
//                      requested DFS_INFO_x struct.
//
//  Returns:    [NERR_Success] -- If successfully returned requested info.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsGetInfo(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN DWORD Level,
    OUT LPDFS_INFO_STRUCT pDfsInfo)
{
    LONG BufferSize = 0;
    LONG SizeRequired = 0;
    ULONG MaxRetry = 0;
    NET_API_STATUS Status  = ERROR_SUCCESS;
    PDFS_INFO_1 pInfo1 = NULL;

    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(ShareName);

    DFS_TRACE_HIGH( API, "Net Dfs get info %ws\n", DfsEntryPath);

    MaxRetry = 5;
    BufferSize = sizeof(DFS_INFO_STRUCT);

    DFS_API_START( );

    do
    {
        pInfo1 = (PDFS_INFO_1)MIDL_user_allocate(BufferSize);
        if (pInfo1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else 
        {
            Status = DfsGetInfo( DfsEntryPath,
                                 Level,
                                 (LPBYTE)pInfo1,
                                 BufferSize,
                                 &SizeRequired );

            if (Status != ERROR_SUCCESS)
            {
                MIDL_user_free( pInfo1 );
            }

            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                BufferSize = SizeRequired;
            }
        }
    } while ( (Status == ERROR_BUFFER_OVERFLOW) && (MaxRetry--) );

    if (Status == ERROR_SUCCESS)
    {
        pDfsInfo->DfsInfo1 = pInfo1;
    }

    DFS_API_END( );
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs get info %ws, Status %x\n", DfsEntryPath, Status);
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnum
//
//  Synopsis:   The server side implementation of the NetDfsEnum public API
//
//  Arguments:  [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsEnum(
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{
    NET_API_STATUS Status  = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs enum %d\n", Level);
    DFS_API_START();
    //
    // We just call NetRDfsEnumEx with a null pathname.
    //
    Status = DfsEnumEx( NULL,
                        Level,
                        PrefMaxLen,
                        pDfsEnum,
                        pResumeHandle );

    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs enum %d, Status %x\n", Level, Status);
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsEnumEx
//
//  Synopsis:   The DC implementation of the NetDfsEnum public API
//
//  Arguments:  [DfsName] -- The Dfs to enumerate (\\domainname\ftdfsname)
//              [Level] -- The level of info struct desired.
//              [PrefMaxLen] -- Preferred maximum length of output buffer.
//                      0xffffffff means no limit.
//              [DfsEnum] -- DFS_INFO_ENUM_STRUCT pointer where the info
//                      structs will be returned.
//              [ResumeHandle] -- If 0, the enumeration will begin from the
//                      start. On return, the resume handle will be an opaque
//                      cookie that can be passed in on subsequent calls to
//                      resume the enumeration.
//
//  Returns:    [NERR_Success] -- Successfully retrieved info.
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{

    NET_API_STATUS Status = ERROR_SUCCESS;

    DFS_TRACE_HIGH( API, "Net Dfs enum ex %ws\n", DfsName);
    DFS_API_START ();

    Status = DfsEnumEx( DfsName,
                        Level,
                        PrefMaxLen,
                        pDfsEnum,
                        pResumeHandle);

    DFS_API_END( );
    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs enum ex %ws, Status %x\n", DfsName, Status);

    return Status;

}

NET_API_STATUS
DfsEnumEx(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    IN OUT LPDFS_INFO_ENUM_STRUCT pDfsEnum,
    IN OUT LPDWORD pResumeHandle)
{
    DWORD EntriesRead = 0;
    NET_API_STATUS Status = 0;
    LPDFS_INFO_1 pInfo1 = NULL;

    if ((pDfsEnum == NULL) ||
        (pDfsEnum->DfsInfoContainer.DfsInfo1Container == NULL)) {
        return ERROR_INVALID_PARAMETER;
    }

    Status = DfsEnum(DfsName, Level, PrefMaxLen, 
                     (LPBYTE *) &pInfo1, &EntriesRead, 
                     pResumeHandle); 
    if (Status == ERROR_SUCCESS)
    {
         pDfsEnum->DfsInfoContainer.DfsInfo1Container->Buffer = (LPDFS_INFO_1) pInfo1;
         pDfsEnum->DfsInfoContainer.DfsInfo1Container->EntriesRead = EntriesRead,
         pDfsEnum->Level = Level;
    }

    return Status;
}




//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerGetConfigInfo
//
//  Synopsis:   RPC Interface method that returns the config info for a
//              Dfs volume for a given server
//
//  Arguments:  [wszServer] -- Name of server requesting the info. This
//                      server is assumed to be requesting the info for
//                      verification of its local volume knowledge.
//              [wszLocalVolumeEntryPath] -- Entry path of local volume.
//              [idLocalVolume] -- The guid of the local volume.
//              [ppRelationInfo] -- The relation info is allocated and
//                      returned here.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" DWORD
NetrDfsManagerGetConfigInfo(
    IN LPWSTR wszServer,
    IN LPWSTR wszLocalVolumeEntryPath,
    IN GUID idLocalVolume,
    OUT LPDFSM_RELATION_INFO *ppRelationInfo)
{
    UNREFERENCED_PARAMETER( wszServer);
    UNREFERENCED_PARAMETER( wszLocalVolumeEntryPath);
    UNREFERENCED_PARAMETER( idLocalVolume);
    UNREFERENCED_PARAMETER( ppRelationInfo);

    //
    // This will probably be never supported.
    //
    return ERROR_NOT_SUPPORTED;
    
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerSendSiteInfo
//
//  Synopsis:   RPC Interface method that reports the site information for a
//              Dfs storage server.
//
//  Arguments:  [wszServer] -- Name of server sending the info.
//              [pSiteInfo] -- The site info is here.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" DWORD
NetrDfsManagerSendSiteInfo(
    IN LPWSTR wszServer,
    IN LPDFS_SITELIST_INFO pSiteInfo)
{
    UNREFERENCED_PARAMETER( wszServer);
    UNREFERENCED_PARAMETER( pSiteInfo);

    //
    // This will probably be never supported.
    //

    return ERROR_NOT_SUPPORTED;
    
}


//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsManagerInitialize
//
//  Synopsis:   Reinitializes the service
//
//  Arguments:  [ServerName] -- Name of server
//              [Flags] -- Flags for the operation
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsManagerInitialize(
    IN LPWSTR ServerName,
    IN DWORD  Flags)
{
    UNREFERENCED_PARAMETER( ServerName);
    UNREFERENCED_PARAMETER( Flags);
    //
    // This will probably be never supported.
    //
    return ERROR_NOT_SUPPORTED;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsMove
//
//  Synopsis:   Moves a leaf volume to a different parent.
//
//  Arguments:  [DfsEntryPath] -- Current entry path of Dfs volume.
//
//              [NewEntryPath] -- New entry path of Dfs volume.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsMove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR NewDfsEntryPath)
{
    UNREFERENCED_PARAMETER( DfsEntryPath);
    UNREFERENCED_PARAMETER( NewDfsEntryPath);
    //
    // This will definitely be never supported.
    //

    return ERROR_NOT_SUPPORTED;
}

//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRename
//
//  Synopsis:   Moves a leaf volume to a different parent.
//
//  Arguments:  [Path] -- Current path along the entry path of a Dfs volume.
//
//              [NewPath] -- New path for current path.
//
//  Returns:    STATUS_NOT_SUPPORTED
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRename(
    IN LPWSTR Path,
    IN LPWSTR NewPath)
{
    UNREFERENCED_PARAMETER( Path);
    UNREFERENCED_PARAMETER( NewPath);
    //
    // This will definitely be never supported.
    //
    return ERROR_NOT_SUPPORTED;
}



// ====================================================================
//                MIDL allocate and free
//
//  These routines are used by the RPC layer to call back into our
// code to allocate or free memory. 
//
// ====================================================================

PVOID
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

VOID
MIDL_user_free(void * ptr)
{
    free(ptr);
}


//+-------------------------------------------------------------------------
//
//  Function:   RpcInit - Initialize the RPC for this server.
//
//  Arguments:  NONE
//
//  Returns:    Status
//               ERROR_SUCCESS if we initialized without errors
//
//  Description: This routine sets up the RPC server to listen to the
//               api requests originating from the clients.
//
//--------------------------------------------------------------------------


DWORD
DfsApiInit()
{
    RPC_STATUS Status = 0;
    LPWSTR ProtocolSequence = L"ncacn_np";
    PVOID Security     = NULL; /* let the security subsystem assign appropriate SD */
    LPWSTR Endpoint    = L"\\pipe\\netdfs";
    unsigned int    cMinCalls      = 1;
    unsigned int    cMaxCalls      = RPC_C_LISTEN_MAX_CALLS_DEFAULT;
    unsigned int    fDontWait      = TRUE;
 
    DfsLockInitialized = InitializeCriticalSectionAndSpinCount( &DfsApiLock, 0 );
    if(DfsLockInitialized == FALSE)
    {
        Status = GetLastError();
        return Status;
    }

    //
    // We register our protocol, and startup a server to listen to RPC
    // requests. A new server thread is started, so that our thread 
    // can return back to the caller.
    //
    Status = RpcServerUseProtseqEpW((USHORT *)ProtocolSequence,
                                   cMaxCalls,
                                   (USHORT *)Endpoint,
                                   Security); 
 
    if (Status == ERROR_SUCCESS) 
    {
        Status = RpcServerRegisterIf(netdfs_ServerIfHandle,  
                                     NULL,   
                                     NULL); 

        if (Status == ERROR_SUCCESS) 
        {
            Status = RpcServerListen(cMinCalls,
                                     cMaxCalls,
                                     fDontWait);
            if (Status == RPC_S_OK ) 
            {
                ServerListen = TRUE;
            }
        }
    }
 
    return Status;
}


void
DfsApiShutDown(void)
{
    RPC_STATUS Status = RPC_S_OK;

    //
    // stop server listen.
    //

    if(ServerListen)
    {

        Status = RpcMgmtStopServerListening(0);

        //
        // wait for all RPC threads to go away.
        //

        if( Status == RPC_S_OK) 
         {
           Status = RpcMgmtWaitServerListen();
         }

        ServerListen = FALSE;
    }

    Status = RpcServerUnregisterIf(netdfs_ServerIfHandle,
                                   NULL,      
                                   TRUE);  // wait for calls to complete

    if(DfsLockInitialized)
    {
        DeleteCriticalSection(&DfsApiLock);
    }
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsAddFtRoot
//
//  Synopsis:   Creates a new FtDfs, or joins a Server into an FtDfs
//
//  Arguments:  [ServerName] -- Name of server backing the volume.
//              [DcName] -- DC to use
//              [RootShare] -- Name of share on ServerName backing the volume.
//              [FtDfsName] -- The Name of the FtDfs to create/join
//              [Comment] -- Comment associated with this root.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation succeeded.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsAddFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN LPWSTR Comment,
    IN LPWSTR ConfigDN,
    IN BOOLEAN NewFtDfs,
    IN DWORD  ApiFlags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status  = ERROR_SUCCESS;
    UNREFERENCED_PARAMETER( ConfigDN);

    if ( (DcName == NULL) || (DcName[0] == UNICODE_NULL) ||
         (RootShare == NULL) || (RootShare[0] == UNICODE_NULL) ||
         (FtDfsName == NULL) || (FtDfsName[0] == UNICODE_NULL) ||
         (ServerName == NULL) || (ServerName[0] == UNICODE_NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    DFS_TRACE_HIGH( API, "Net Dfs Add FT Root %ws\n", RootShare);
    DFS_API_START( );


    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {


        Status = DfsAddADBlobRoot( ServerName,
                                   DcName,
                                   RootShare,
                                   FtDfsName,
                                   Comment,
                                   NewFtDfs,
                                   ApiFlags,
                                   (PVOID)ppRootList );
    }

    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Add AD blob Root %ws\n", RootShare);
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   NetrDfsRemoveFtRoot
//
//  Synopsis:   Deletes a root from an FtDfs.
//
//  Arguments:  [ServerName] -- The server to remove.
//              [DcName] -- DC to use
//              [RootShare] -- The Root share hosting the Dfs/FtDfs
//              [FtDfsName] -- The FtDfs to remove the root from.
//              [Flags] -- Flags for the operation
//              [ppRootList] -- On success, returns a list of roots that need to be
//                              informed of the change in the DS object
//
//  Returns:    [NERR_Success] -- Operation successful.
//
//
//-----------------------------------------------------------------------------

extern "C" NET_API_STATUS
NetrDfsRemoveFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR DcName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN DWORD  ApiFlags,
    IN PDFSM_ROOT_LIST *ppRootList)
{
    NET_API_STATUS Status  = ERROR_SUCCESS;

    if ( (DcName == NULL) || (DcName[0] == UNICODE_NULL) ||
         (RootShare == NULL) || (RootShare[0] == UNICODE_NULL) ||
         (FtDfsName == NULL) || (FtDfsName[0] == UNICODE_NULL) ||
         (ServerName == NULL) || (ServerName[0] == UNICODE_NULL) )
    {
        return ERROR_INVALID_PARAMETER;
    }


    DFS_TRACE_HIGH( API, "Net Dfs Remove FT Root %ws\n", RootShare);
    DFS_API_START( );

    Status = AccessImpersonateCheckRpcClient();
    if (Status == ERROR_SUCCESS)
    {

        Status = DfsDeleteADBlobRoot( ServerName,
                                      DcName,
                                      RootShare,
                                      FtDfsName,
                                      ApiFlags,
                                      (PVOID)ppRootList );
    }
    DFS_API_END( );

    DFS_TRACE_ERROR_HIGH( Status, API, "Net Dfs Remove AD blob Root %ws\n", RootShare);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsinit\dfsinit.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       dfsinit.c
//
//  Contents:   Code to force dfs volume initialization and validation
//
//  Classes:
//
//  Functions:  main
//
//  History:    March 24, 1994          Milans Created
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <dfsfsctl.h>


//
// Get rid of this file, after we remove it from the placefil.txt
//
//

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

void _cdecl main(
    int argc,
    char *argv[])
{
    NTSTATUS Status;

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\referralserver\netdfs_s_stub.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       netdfs_s_stub.c
//
//  Contents:   This is a stub file that includes the actual RPC server
//              file generated by the idl compiler. This server file
//              generated exists in a different depot, and we unfortunately
//              have to go through this hoop to compile the RPC server.
//
//  History:    Feb. 8 2001,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "netdfs_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\klogmacros.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       kLogMacros.c
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    March 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------
       
#include "ntifs.h"
#include <windef.h>
              
#define _NTDDK_
#include "stdarg.h"
#include "wmikm.h"
#include <wmistr.h>
#include <evntrace.h>

#include <wmiumkm.h>
#include "dfswmi.h"  
   
#include "kLogMacros.h"
#include "kLogMacros.tmh"

PVOID pkUmrControl = NULL;

void SetUmrControl(WPP_CB_TYPE * Control)
{
    pkUmrControl = (PVOID)Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\midatlas.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

--*/

#include "ntifs.h"
#include <windef.h>
#include <midatlax.h>
#include <midatlsp.h>

#define RXCE_MIDATLAS_POOLTAG (ULONG)'dfsU'                         
VOID
RxInitializeMidMapFreeList (
    struct _MID_MAP_ *pMidMap
    );

VOID
RxUninitializeMidMap (
    struct _MID_MAP_    *pMidMap,
    PCONTEXT_DESTRUCTOR pContextDestructor
    );

VOID
RxIterateMidMapAndRemove (
	PRX_MID_ATLAS     pMidAtlas,
	struct _MID_MAP_ *pMidMap,
	PCONTEXT_ITERATOR pContextIterator
	);


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeMidMapFreeList)
#pragma alloc_text(PAGE, RxCreateMidAtlas)
#pragma alloc_text(PAGE, RxUninitializeMidMap)
#pragma alloc_text(PAGE, RxDestroyMidAtlas)
#pragma alloc_text(PAGE, RxIterateMidAtlasAndRemove)
#pragma alloc_text(PAGE, RxIterateMidMapAndRemove)
#endif

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)


//INLINE ULONG _GetEntryType(PVOID pEntry)

#define _GetEntryType(pEntry)                               \
        (ULONG) ((ULONG_PTR)(pEntry) & ENTRY_TYPE_MASK)

//INLINE PVOID _GetEntryPointer(PVOID pEntry)

#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG_PTR)pEntry & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG_PTR)(pContext) | (EntryType))

//INLINE PMID_MAP _GetFirstMidMap()
/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
RxInitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i = 0;

   PVOID  *pEntryValue     = (PVOID *)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;

   PAGED_CODE();

   //DbgPrint("RxInitializeMidMapFreeList .. Entry\n");

   if (pMidMap->MaximumNumberOfMids > 0) {
       pMidMap->pFreeMidListHead = pMidMap->Entries;
       for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
          *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
       }

       *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);
   }

   //DbgPrint("RxInitializeMidMapFreeList .. Exit\n");
}


PRX_MID_ATLAS
RxCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
    PRX_MID_ATLAS pMidAtlas;
    PMID_MAP   pMidMap;
    ULONG      AtlasSize;
    USHORT     MidsAllocatedRoundedToPowerOf2;
    USHORT     MaximumMidsRoundedToPowerOf2;
    UCHAR      MidFieldWidth,MaximumMidFieldWidth;

    PAGED_CODE();

    // Round off the Mids allocated at Start to a power of two
    MaximumMidsRoundedToPowerOf2 = 0x100;
    MaximumMidFieldWidth = 8;

    if (MaximumMidsRoundedToPowerOf2 != MaximumNumberOfMids) {
        if (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
            while (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
                MaximumMidFieldWidth++;
            }
        } else {
            while (MaximumNumberOfMids < MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> 1;
                MaximumMidFieldWidth--;
            }

            MaximumMidFieldWidth++;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
        }
    }

    MidsAllocatedRoundedToPowerOf2 = 0x100;
    MidFieldWidth = 8;

    if (MidsAllocatedRoundedToPowerOf2 != MidsAllocatedAtStart) {
        if (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
            while (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
                MidFieldWidth++;
            }
        } else {
            while (MidsAllocatedAtStart < MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 >> 1;
                MidFieldWidth--;
            }

            MidFieldWidth++;
            MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
        }
    }

    AtlasSize = sizeof(RX_MID_ATLAS) +
                FIELD_OFFSET(MID_MAP,Entries);

    if (MaximumNumberOfMids == MidsAllocatedAtStart) {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
    } else {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedRoundedToPowerOf2);
    }

    pMidAtlas = (PRX_MID_ATLAS)ExAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              RXCE_MIDATLAS_POOLTAG);
    if (pMidAtlas != NULL) {
        pMidMap = (PMID_MAP)(pMidAtlas + 1);

        pMidMap->Flags                 = 0;
        pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
        pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
        pMidAtlas->NumberOfMidsInUse = 0;
        pMidAtlas->NumberOfMidsDiscarded = 0;
        pMidAtlas->MaximumMidFieldWidth = MaximumMidFieldWidth;

        pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
        pMidMap->NumberOfMidsInUse   = 0;
        pMidMap->BaseMid             = 0;
        pMidMap->IndexMask           = MidsAllocatedRoundedToPowerOf2 - 1;
        pMidMap->IndexAlignmentCount = 0;
        pMidMap->IndexFieldWidth     = MidFieldWidth;
        pMidMap->Level               = 1;

        InitializeListHead(&pMidAtlas->MidMapFreeList);
        InitializeListHead(&pMidAtlas->MidMapExpansionList);
        RxInitializeMidMapFreeList(pMidMap);

        _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
        pMidAtlas->pRootMidMap = pMidMap;

        if (MaximumNumberOfMids > MidsAllocatedAtStart) {
            // Round off the maximum number of MIDS to determine the level and the
            // size of the quantum ( allocation increments)

            pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

            pMidAtlas->MidQuantum           = 32;
            pMidAtlas->MidQuantumFieldWidth = 5;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);

            if (MaximumMidsRoundedToPowerOf2 > 0) {
                pMidAtlas->NumberOfLevels = 3;
            } else {
                pMidAtlas->NumberOfLevels = 2;
            }
        } else {
            pMidAtlas->MidQuantum     = 0;
            pMidAtlas->NumberOfLevels = 1;
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
        }
    }

    //DbgPrint("RxAllocatMidAtlas .. Exit (pMidAtlas) %lx\n",pMidAtlas);
    return pMidAtlas;
}


VOID
RxIterateMidMapAndRemove(
   PRX_MID_ATLAS     pMidAtlas,
   PMID_MAP          pMidMap,
   PCONTEXT_ITERATOR pContextIterator)
{	
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //RxLog(("_IterateMidMapAndRemove .. num= %ld\n",pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            RxIterateMidMapAndRemove(pMidAtlas,pChildMidMap,pContextIterator);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
#if 0         	
         	PVOID *pEntry;

         	pMidMap->NumberOfMidsInUse--;
         	DbgPrint("RxIterateMidMapAndRemove, MidMap Mids in use: %d\n",pMidMap->NumberOfMidsInUse);
#endif // 0
            if (pContextIterator != NULL) {
               	PVOID pContext;

               	pContext = _GetEntryPointer(pMidMap->Entries[i]);

				DbgPrint("Executing ContextIterator: 0x%08x\n",pContext);

               	(pContextIterator)(pContext);
            }
#if 0            
         	if (pMidMap->pFreeMidListHead == NULL) {
				if (pMidMap->Flags & MID_MAP_FLAGS_CAN_BE_EXPANDED) {
               		_RemoveMidMap(pMidMap);
            	}

            	_AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         	}

            *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         	pMidMap->pFreeMidListHead = pEntry;
            pMidAtlas->NumberOfMidsInUse--;
         	DbgPrint("RxIterateMidMapAndRemove, MidAtlas Mids in use: %d\n",pMidAtlas->NumberOfMidsInUse);
#endif // 0         	
         }
         break;
      default:
         break;
      }
   }
}


VOID
RxIterateMidAtlasAndRemove(
		PRX_MID_ATLAS pMidAtlas,
		PCONTEXT_ITERATOR pContextIterator)
{
	PAGED_CODE();

	RxIterateMidMapAndRemove(pMidAtlas, pMidAtlas->pRootMidMap, pContextIterator);
}



VOID
RxUninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //DbgPrint("RxUninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   //RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            RxUninitializeMidMap(pChildMidMap,pContextDestructor);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);

               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      ExFreePool(pMidMap);
   }

   //DbgPrint("RxUninitializeMidMap .. Exit\n");
}

VOID
RxDestroyMidAtlas(
   PRX_MID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   PAGED_CODE();

   //DbgPrint("RxFreeMidAtlas .. Entry\n");
   RxUninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   ExFreePool(pMidAtlas);
   //DbgPrint("RxFreeMidAtlas .. Exit\n");
}

PVOID
RxMapMidToContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("RxMapMidToContext Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("Context %lx \n",pContext);

   return pContext;
}

NTSTATUS
RxMapAndDissociateMidFromContext(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   //DbgPrint("RxMapAndDissociateMidFromContext Mid %lx ",Mid);

   for (;;) {
      pEntry    = &pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
               _RemoveMidMap(pMidMap);
            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;


         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   //DbgPrint("Context %lx\n",pContext);
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
RxReassociateMid(
      PRX_MID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("RxReassociateMid Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("New COntext  %lx\n",pNewContext);

   return STATUS_SUCCESS;
}

NTSTATUS
RxAssociateContextWithMid(
      PRX_MID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;
   PMID_MAP pMidMap = NULL;
   PVOID    *pContextPointer = NULL;

   //DbgPrint("RxAssociateContextWithMid Context %lx ",pContext);

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((USHORT)
                                   (pContextPointer - (PVOID *)&pMidMap->Entries)
                                    << pMidMap->IndexAlignmentCount) |
                                    pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }

         if (NumberOfEntriesInMap > 0) {
             NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                             NumberOfEntriesInMap * sizeof(PVOID);
             pNewMidMap = (PMID_MAP)ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        NewMidMapSize,
                                        RXCE_MIDATLAS_POOLTAG);

             if (pNewMidMap != NULL) {
                 pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
                 pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
                 pNewMidMap->NumberOfMidsInUse   = 0;
                 pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                                    i << pMidMap->IndexAlignmentCount);
                 pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                                   pMidMap->IndexFieldWidth;

                 pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
                 pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

                 RxInitializeMidMapFreeList(pNewMidMap);

                 //
                 // After the RxInitializeMidMapFreeList call above the 
                 // pFreeMidListHead points to Entries[0]. We will be storing
                 // the value pMidMap->Entries[i] at this location so we need
                 // to make pFreeMidListHead point to Entries[1].
                 //
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));

                 //
                 // Set up the mid map appropriately.
                 //
                 pNewMidMap->NumberOfMidsInUse = 1;
                 pNewMidMap->Entries[0] = pMidMap->Entries[i];
                 pNewMidMap->Level = pMidMap->Level + 1;

                 //
                 // The new MinMap is stored at the pMidMap->Entries[i] location.
                 //
                 pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

                 //
                 // Update the free list and the expansion list respectively.
                 //
                 _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

                 pNewMidMap->NumberOfMidsInUse++;
                 pContextPointer = pNewMidMap->pFreeMidListHead;
                 pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));
                 *pContextPointer = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
                 *pNewMid = ((USHORT)
                             (pContextPointer - (PVOID *)&pNewMidMap->Entries)
                             << pNewMidMap->IndexAlignmentCount) |
                             pNewMidMap->BaseMid;

                 Status = STATUS_SUCCESS;
             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
         } else {
             Status = STATUS_UNSUCCESSFUL;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == (STATUS_SUCCESS)) {
      pMidAtlas->NumberOfMidsInUse++;
   }

   //DbgPrint("Mid %lx\n",*pNewMid);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\referralserver\referralserver.cxx ===
//+-------------------------------------------------------------------------
//
//  Function:   main
//
//  Arguments:  
//     argc, argv: the passed in argument list.
//
//  Description: This routine initializes the dfs server, and creates 
//               a worker thread that will be responsible for periodic
//               work (such as scavenging and refreshing). It then calls
//               into the RPC code to start processing client requests.
//
//--------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include <shellapi.h>
#include <ole2.h>
#include <activeds.h>
#include <DfsServerLibrary.hxx>
#include "ReferralServerLog.hxx"

#include "ReferralServer.tmh"

extern
void 
SetReferralControl(WPP_CB_TYPE * Control);

#define PRINTF printf



DWORD
DfsApiInit();

extern
void
DfsApiShutDown(void);

extern DFSSTATUS
DfsServerStop(
    ULONG Flags );


DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg );

VOID
ReferralServerUsage();

VOID
StartDfsService(
    DWORD dwNumServiceArgs, 
    LPWSTR *lpServiceArgs);

DFSSTATUS
DfsStartupServer();

VOID DfsSvcMsgProc(
    DWORD dwControl);

static void
UpdateServiceStatus(
    SERVICE_STATUS_HANDLE hService, 
    SERVICE_STATUS *pSStatus, 
    DWORD Status);

VOID
DfsSvcMsgProc(
    DWORD dwControl);

SERVICE_STATUS          ServiceStatus;
SERVICE_STATUS_HANDLE   hDfsService;

const PWSTR             wszDfsServiceName = L"DfsService";

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;
    
#define SWITCH(x) \
    WCHAR Switch##x[] = L"/" L#x ; \
    BOOLEAN fSwitch##x;


//
// The arguments we accept at commandline.
//
MAKEARG(Name);
SWITCH(L);
SWITCH(D);
SWITCH(M);
SWITCH(NoService);
SWITCH(Trace);

ULONG Flags = DFS_LOCAL_NAMESPACE;

#if defined (DFS_RUN_SERVICE)

//+----------------------------------------------------------------------------
//
//  Function:  WinMain
//
//  Synopsis:  This guy will set up link to service manager and install
//             ServiceMain as the service's entry point. Hopefully, the service
//             control dispatcher will call ServiceMain soon thereafter.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

int WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdLine,
    int nCmdShow)
{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpszCmdLine);
    UNREFERENCED_PARAMETER(nCmdShow);

    SERVICE_TABLE_ENTRYW        aServiceEntry[2];
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw = 0;
    int i;
    LPWSTR CommandLine;
    BOOL fConsole = TRUE;
    HANDLE StdOut = NULL;

    WPP_CB_TYPE *pLogger = NULL;

    pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];
    
    WPP_INIT_TRACING(L"DfsReferralServer");

    SetReferralControl(pLogger);

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);
        if (fArgName == TRUE && fSwitchL == TRUE)
        {
            PRINTF("/L and /Name: are mutually exclusive");
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReferralServerUsage();
            break;
        }

    }

    if (Status == ERROR_SUCCESS)
    {
        if (fSwitchNoService != TRUE)
        {
            aServiceEntry[0].lpServiceName = wszDfsServiceName;
            aServiceEntry[0].lpServiceProc = StartDfsService;
            aServiceEntry[1].lpServiceName = NULL;
            aServiceEntry[1].lpServiceProc = NULL;

            if (!StartServiceCtrlDispatcherW(aServiceEntry)) {
                return(GetLastError());
            }

            return(0);
        }
        else 
        {
            Status = DfsStartupServer();
            while (Status == ERROR_SUCCESS)
            {
                Sleep(3000000);
            }
            PRINTF("DfsServer is exiting with status %x\n", Status);
            exit(0);
        }
    }
    WPP_CLEANUP();
    exit(1);
}

#if 0
VOID
__cdecl MyPrintf(
    LPSTR lpFmt,
    ...
    )
{
    va_list base;

    va_start(base,lpFmt);

    wvsprintf(vrgchLibBuff, lpFmt, base);
    OutputDebugString(vrgchLibBuff);
}
#endif
#else
_cdecl
main(
    int argc, 
    char *argv[])
{
    LPWSTR CommandLine;
    LPWSTR *argvw;
    DFSSTATUS Status = ERROR_SUCCESS;
    int argcw,i;
    SERVICE_TABLE_ENTRYW        aServiceEntry[2];
    WPP_CB_TYPE *pLogger = NULL;

    pLogger = &WPP_CB[WPP_CTRL_NO(WPP_BIT_CLI_DRV)];
    
    WPP_INIT_TRACING(L"DfsReferralServer");

    SetReferralControl(pLogger);

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    //
    // Process each argument on the command line.
    //
    for (i = 1; i < argcw; i++) {
        Status = ProcessCommandLineArg(argvw[i]);
        if (fArgName == TRUE && fSwitchL == TRUE)
        {
            printf("/L and /Name: are mutually exclusive");
            Status = ERROR_INVALID_PARAMETER;
        }

        if (Status != ERROR_SUCCESS)
        {
            ReferralServerUsage();
            break;
        }

    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsStartupServer();

        DFS_TRACE_HIGH(REFERRAL_SERVER,"ReferralServer Initialized with error %x", Status);
        
        while (Status == ERROR_SUCCESS)
        {
            Sleep(3000000);
        }
    }

    printf("DfsServer is exiting with status %x\n", Status);
    WPP_CLEANUP();
    exit(0);

}
#endif // DFS_NO_SERVICE

DFSSTATUS
DfsStartupServer()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // Initialize the server.
    //  
    if (Flags & DFS_LOCAL_NAMESPACE)
    {
        Flags |= DFS_CREATE_DIRECTORIES;
    }

    Flags |= DFS_POST_EVENT_LOG;

    Status = DfsServerInitialize( Flags );
    if (Status == ERROR_SUCCESS) {
        //
        // initialize the DfS api.
        //

        Status = DfsApiInit();
    }

    return Status;
}

void
DfsShutdownServer(void)
{
    DfsApiShutDown();

    DfsServerStop(0);

}

//+-------------------------------------------------------------------------
//
//  Function:   ProcessCommandLineArg -  process the command line
//
//  Arguments:  Arg -  the argument to process
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine inteprets the passed in argument and 
//               sets appropriate flags with which the server should
//               be initialized.
//
//--------------------------------------------------------------------------

DFSSTATUS
ProcessCommandLineArg( LPWSTR Arg )
{
    LONG ArgLen;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR NameSpace;

    if (Arg == NULL) {
        Status = ERROR_INVALID_PARAMETER;
    }

    if (Status == ERROR_SUCCESS)
    {
        ArgLen = wcslen(Arg);

        if (_wcsnicmp(Arg, ArgName, ArgLenName) == 0)
        {
            fArgName = TRUE;
            NameSpace = &Arg[ArgLenName];
            if (wcslen(NameSpace) == 0)
            {
                Status = ERROR_INVALID_PARAMETER;
            }
            else {
                Status = DfsAddHandledNamespace( NameSpace, TRUE );
            }
        }
        else if (_wcsicmp(Arg, SwitchTrace) == 0)
        {
            fSwitchTrace = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchL) == 0)
        {
            fSwitchL = TRUE;
            Flags |= DFS_LOCAL_NAMESPACE;
        }
        else if (_wcsicmp(Arg, SwitchNoService) == 0)
        {
            fSwitchNoService = TRUE;
        }
        else if (_wcsicmp(Arg, SwitchD) == 0)
        {
            Flags |= DFS_CREATE_DIRECTORIES;
        }
        else if (_wcsicmp(Arg, SwitchM) == 0)
        {
            Flags |= DFS_MIGRATE;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    return Status;
}


//
// Function: ReferralServerUsage. Usage printout for the referral server.
//
VOID
ReferralServerUsage()
{
    printf("Usage:\n");
    printf("/D - Create directories\n");
    printf("/L - Run on the local root server\n");
    printf("/M - Migrate existing DFS to allow multiple roots\n");
    printf("/Name:<Namespace> - Handle referrals to the specified namespace\n");
    printf("/NoService - Dont start as a service\n");
    printf("/trace - enable tracing\n");

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:   StartDfsService
//
//  Synopsis:   Call back for DfsService service. This is called *once* by the
//              Service controller when the DfsService service is to be inited
//              This function is responsible for registering a message
//              handler function for the DfsService service.
//
//  Arguments:  Unused
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
StartDfsService(
    DWORD dwNumServiceArgs, 
    LPWSTR *lpServiceArgs)
{
    DFSSTATUS Status;

    UNREFERENCED_PARAMETER(dwNumServiceArgs);
    UNREFERENCED_PARAMETER(lpServiceArgs);


    hDfsService = RegisterServiceCtrlHandlerW( wszDfsServiceName,
                                               DfsSvcMsgProc);
    if (!hDfsService) {
        return;
    }
    
    ServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    ServiceStatus.dwWin32ExitCode = 0;
    ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 1000 * 30;

    UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_START_PENDING);

    Status = DfsStartupServer();
    if (Status == ERROR_SUCCESS)
    {
        UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_RUNNING);
    }
    else {
        UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_STOPPED);
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Function:  DfsSvcMsgProc
//
//  Synopsis:  Service-Message handler for DFSInit.
//
//  Arguments: [dwControl] - the message
//
//  Returns:   nothing
//
//-----------------------------------------------------------------------------

VOID
DfsSvcMsgProc(DWORD dwControl)
{
    switch(dwControl) {

    case SERVICE_CONTROL_STOP:
        //
        // dfsdev: need to do something to stop the service!
        //

        DfsShutdownServer();

        UpdateServiceStatus( hDfsService, &ServiceStatus, SERVICE_STOPPED);


        CoUninitialize();
        break;

    case SERVICE_INTERROGATE:
        UpdateServiceStatus( hDfsService, &ServiceStatus, ServiceStatus.dwCurrentState);
        break;

    default:
        break;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:  UpdateServiceStatus
//
//  Synopsis:  Pushes a ServiceStatus to the service manager.
//
//  Arguments: [hService] - handle returned from RegisterServiceCtrlHandler
//             [pSStatus] - pointer to service-status block
//             [Status] -   The status to set.
//
//  Returns:   Nothing.
//
//-----------------------------------------------------------------------------

static void
UpdateServiceStatus(
    SERVICE_STATUS_HANDLE hService, 
    SERVICE_STATUS *pSStatus, 
    DWORD Status)
{
    pSStatus->dwCurrentState = Status;

    if (Status == SERVICE_START_PENDING) {
        pSStatus->dwCheckPoint++;
        pSStatus->dwWaitHint = 1000;
    } else {
        pSStatus->dwCheckPoint = 0;
        pSStatus->dwWaitHint = 0;
    }

    SetServiceStatus(hService, pSStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\dfsumrctrl.c ===
//+----------------------------------------------------------------------------//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       dfsumr.c
//
//  Contents:   
//
//
//  Functions:  
//
//  Author - Rohan Phillips     (Rohanp)
//-----------------------------------------------------------------------------


 
#include "ntifs.h"
#include <windef.h>
#include <DfsReferralData.h>
#include <midatlax.h>
#include <rxcontx.h>
#include <dfsumr.h>
#include <umrx.h>
#include <dfsumrctrl.h>
               
#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, DfsInitializeUmrResources)
#pragma alloc_text(PAGE, DfsDeInitializeUmrResources)
#pragma alloc_text(PAGE, DfsWaitForPendingClients)
#pragma alloc_text(PAGE, DfsStartupUMRx)
#pragma alloc_text(PAGE, DfsTeardownUMRx)
#pragma alloc_text(PAGE, DfsProcessUMRxPacket)
#pragma alloc_text(PAGE, AddUmrRef)
#pragma alloc_text(PAGE, ReleaseUmrRef)
#pragma alloc_text(PAGE, IsUmrEnabled)
#pragma alloc_text(PAGE, LockUmrShared)
#pragma alloc_text(PAGE, GetUMRxEngineFromRxContext)
#endif

#define DFS_INIT_REFLOCK     0x00000001
#define DFS_INIT_UMRXENG     0x00000002
#define DFS_INIT_CONTEXT     0x00000004

//
// Number of usecs that the thread disabling the reflection should wait
//   between checks.  negative value for relative time.
//   1,000,000 usecs => 1 sec
//
#define DFS_UMR_DISABLE_DELAY  -100000

BOOL ReflectionEngineInitialized = FALSE;

ULONG cUserModeReflectionsInProgress = 0;

NTSTATUS  g_CheckStatus = 0xFFFFFFFF;

DWORD InitilizationStatus = 0;

PERESOURCE gReflectionLock = NULL;

PUMRX_ENGINE g_pUMRxEngine = NULL;


PERESOURCE 
CreateResource(void )   ;


void 
ReleaseResource(PERESOURCE  pResource )   ;

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeUmrResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Initializes all resources neder for the usermode reflector
//
//--------------------------------------------------------------------------
NTSTATUS 
DfsInitializeUmrResources(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    gReflectionLock = CreateResource();
    if(gReflectionLock != NULL)
    {
        InitilizationStatus |=  DFS_INIT_REFLOCK;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    g_pUMRxEngine = CreateUMRxEngine();
    if(g_pUMRxEngine != NULL)
    {
        InitilizationStatus |=  DFS_INIT_UMRXENG;
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    Status = DfsInitializeContextResources();
    if(Status == STATUS_SUCCESS)
    {
       InitilizationStatus |=  DFS_INIT_CONTEXT;
    }

Exit:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsDeInitializeUmrResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Releases all resources neder for the usermode reflector
//
//--------------------------------------------------------------------------
void 
DfsDeInitializeUmrResources(void)
{
    PAGED_CODE();

    if(InitilizationStatus & DFS_INIT_REFLOCK)
    {
        ReleaseResource(gReflectionLock);
        gReflectionLock = NULL;
    }

    if(InitilizationStatus & DFS_INIT_UMRXENG)
    {
        if(g_pUMRxEngine != NULL)
        {
            FinalizeUMRxEngine (g_pUMRxEngine);
            g_pUMRxEngine = NULL;
        }
    }


    if(InitilizationStatus & DFS_INIT_CONTEXT)
    {
        DfsDeInitializeContextResources();
    }

}

PERESOURCE 
CreateResource(void )   
{
    PERESOURCE  pResource = NULL;

    PAGED_CODE();

    pResource = ExAllocatePoolWithTag(  NonPagedPool,
                                        sizeof( ERESOURCE ),
                                        'DfsR');
    if( pResource ) 
    {
        if( !NT_SUCCESS( ExInitializeResourceLite( pResource ) ) ) 
        {
            ExFreePool( pResource ) ;
            pResource = NULL ;
        }
    }

    return  pResource ;
}

void 
ReleaseResource(PERESOURCE  pResource )   
{
    PAGED_CODE();

    ASSERT( pResource != 0 ) ;

    if( pResource ) 
    {
        ExDeleteResourceLite( pResource ) ;
        ExFreePool( pResource ) ;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsEnableReflectionEngine 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Changes the reflector state to stopped
//
//--------------------------------------------------------------------------
NTSTATUS
DfsEnableReflectionEngine(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ReflectionEngineInitialized = TRUE;


    if(g_pUMRxEngine)
    {
        InterlockedExchange(&g_pUMRxEngine->Q.State,
                            UMRX_ENGINE_STATE_STOPPED);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsWaitForPendingClients 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Waits for all clients to exit relector before returning
//
//--------------------------------------------------------------------------
NTSTATUS
DfsWaitForPendingClients(void)
{
    BOOLEAN fDone = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    LARGE_INTEGER liDelay;

    liDelay.QuadPart = DFS_UMR_DISABLE_DELAY;

    PAGED_CODE();

    while (!fDone)
    {   
        ExAcquireResourceExclusiveLite(&g_pUMRxEngine->Q.Lock,TRUE);
        
        if (ReflectionEngineInitialized)
        {
            if (0 == g_pUMRxEngine->cUserModeReflectionsInProgress)
            {
                fDone = TRUE;
            }
            else
            {
            }
        }
        else
        {
            fDone = TRUE;
        }
        
        ExReleaseResourceForThreadLite(&g_pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());
        
        if (!fDone)
        {
            KeDelayExecutionThread(UserMode, FALSE, &liDelay);
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsStartupUMRx 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the reflector engine
//
//--------------------------------------------------------------------------
NTSTATUS
DfsStartupUMRx(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();


    ExAcquireResourceExclusiveLite(gReflectionLock,TRUE);

    Status = UMRxEngineRestart(g_pUMRxEngine);

    if(Status == STATUS_SUCCESS)
    {
        ReflectionEngineInitialized = TRUE;
    }

    ExReleaseResourceForThreadLite(gReflectionLock,ExGetCurrentResourceThread());
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsTeardownUMRx 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Stops the reflector engine
//
//--------------------------------------------------------------------------
NTSTATUS
DfsTeardownUMRx(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(g_pUMRxEngine)
    {
      Status = UMRxEngineReleaseThreads(g_pUMRxEngine);
    }

    ReflectionEngineInitialized = FALSE;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsProcessUMRxPacket 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Processes a packet from usermode
//
//--------------------------------------------------------------------------
NTSTATUS
DfsProcessUMRxPacket(
        IN PVOID InputBuffer,
        IN ULONG InputBufferLength,
        OUT PVOID OutputBuffer,
        IN ULONG OutputBufferLength,
        IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOLEAN fReturnImmediately = FALSE;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    if ((InputBuffer == NULL) && (OutputBuffer == NULL))
    {
        UMRxEngineCompleteQueuedRequests(
                 g_pUMRxEngine,
                 STATUS_INSUFFICIENT_RESOURCES,
                 FALSE);
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    //  Recd a response packet from umode - process it
    //
    Status = UMRxCompleteUserModeRequest(
                g_pUMRxEngine,
                (PUMRX_USERMODE_WORKITEM) InputBuffer,
                InputBufferLength,
                TRUE,
                &Iosb,
                &fReturnImmediately
                );

    if( !NT_SUCCESS(Iosb.Status) ) 
    {
    }

    if (fReturnImmediately)
    {
         pIoStatusBlock->Status = STATUS_SUCCESS;
         pIoStatusBlock->Information = 0;
         goto Exit;
    }


    //
    //  Remove a request from the Engine and process it
    //
    Status = UMRxEngineProcessRequest(
                 g_pUMRxEngine,
                 (PUMRX_USERMODE_WORKITEM) OutputBuffer,
                 OutputBufferLength,
                 &OutputBufferLength
                 );

    if( !NT_SUCCESS(Status) ) 
    {
        //
        //  error processing request
        //
    }

    pIoStatusBlock->Information = OutputBufferLength;

Exit:

    pIoStatusBlock->Status = Status;
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   AddUmrRef 
//
//  Arguments:  
//
//  Returns:    Number of clients using reflector
//
//
//  Description: Increments the number of clients using the reflector
//
//--------------------------------------------------------------------------
LONG
AddUmrRef(void)

{
    LONG cRefs = 0;

    PAGED_CODE();

    cRefs = InterlockedIncrement(&g_pUMRxEngine->cUserModeReflectionsInProgress);
        
    //DFS_TRACE_HIGH (KUMR_DETAIL, "AddUmrRef %d\n", cRefs);
    ASSERT(cRefs > 0);
    return cRefs;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseUmrRef 
//
//  Arguments:  
//
//  Returns:    Number of clients using reflector
//
//
//  Description: Deccrements the number of clients using the reflector
//
//--------------------------------------------------------------------------
LONG
ReleaseUmrRef(void)
{
    LONG cRefs = 0;

    PAGED_CODE();

    cRefs = InterlockedDecrement(&g_pUMRxEngine->cUserModeReflectionsInProgress);
        
    //DFS_TRACE_HIGH (KUMR_DETAIL, "ReleaseUmrRef %d\n", cRefs);
    //ASSERT(cRefs >= 0); //this is a harmless assert. It's removed for now.
    return cRefs;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetUMRxEngineFromRxContext 
//
//  Arguments:  
//
//  Returns:    A pointer to the reflector engine
//
//
//  Description: returns a pointer to the reflector engine
//
//--------------------------------------------------------------------------
PUMRX_ENGINE 
GetUMRxEngineFromRxContext(void)
{
    PAGED_CODE();
    return g_pUMRxEngine;
}
                
BOOL IsUmrEnabled(void)
{
    PAGED_CODE();
    return ReflectionEngineInitialized;
}

BOOLEAN LockUmrShared(void)
{
    BOOLEAN fAcquired = FALSE;

    PAGED_CODE();

    fAcquired = ExAcquireResourceSharedLite(&g_pUMRxEngine->Q.Lock, FALSE);

    return fAcquired;
}


void UnLockUmrShared(void)
{
    PAGED_CODE();

    ExReleaseResourceForThreadLite (&g_pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\umrx.c ===
/*++

Copyright (c) 1989 - 1998 Microsoft Corporation

Module Name:

    umrx.c

Abstract:

    This is the implementation of the UMRxEngine object and
    associated functions.

Notes:

    This module has been built and tested only in UNICODE environment

Author:


--*/


#include "ntifs.h"
#include <windef.h>
#include <dfsassert.h>
#include <DfsReferralData.h>
#include <midatlax.h>
#include <rxcontx.h>                         
#include <dfsumr.h>
#include <umrx.h>
#include <dfsumrctrl.h>

#include <lmcons.h>     // from the Win32 SDK

//
//  The local debug trace level
//

extern NTSTATUS  g_CheckStatus;
ULONG DfsDbgVerbose = 0;

RXDT_DefineCategory(UMRX);
#define Dbg                              (DEBUG_TRACE_UMRX)

//
//  For now, Max and Init MID entries should be the same so that the MID Atlas doesn't grow.
//    There are several bugs in the mid atlas growth code.
//
#define DFS_MAX_MID_ENTRIES   1024
#define DFS_INIT_MID_ENTRIES  DFS_MAX_MID_ENTRIES


extern PUMRX_ENGINE GetUMRxEngineFromRxContext(void);

PUMRX_ENGINE
CreateUMRxEngine()
/*++

Routine Description:

    Create a UMRX_ENGINE object
   
Arguments:

Return Value:

    PUMRX_ENGINE    -   pointer to UMRX_ENGINE
    
Notes:

--*/
{
    PUMRX_ENGINE  pUMRxEngine = NULL;
    PRX_MID_ATLAS MidAtlas = NULL;

    DfsTraceEnter("CreateUMRxEngine");
    if (DfsDbgVerbose) DbgPrint("Creating an UMRX_ENGINE object\n");

    MidAtlas = RxCreateMidAtlas(DFS_MAX_MID_ENTRIES,DFS_INIT_MID_ENTRIES);
    if (MidAtlas == NULL) {
        if (DfsDbgVerbose) DbgPrint("CreateEngine could not make midatlas\n");
        DfsTraceLeave(0);
        return NULL;
    }
    
    pUMRxEngine = (PUMRX_ENGINE) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                sizeof(UMRX_ENGINE),
                                                UMRX_ENGINE_TAG
                                                );
    if( pUMRxEngine ) {
        //
        //  Initialize the UMRX_ENGINE KQUEUE
        //
        pUMRxEngine->Q.State = UMRX_ENGINE_STATE_STOPPED;
        ExInitializeResourceLite(&pUMRxEngine->Q.Lock);  
        KeInitializeQueue(&pUMRxEngine->Q.Queue,0);
        pUMRxEngine->Q.TimeOut.QuadPart  = -10 * TICKS_PER_SECOND;
        pUMRxEngine->Q.NumberOfWorkerThreads  = 0;
        pUMRxEngine->Q.NumberOfWorkItems = 0;
        pUMRxEngine->Q.ThreadAborted = 0;
        pUMRxEngine->cUserModeReflectionsInProgress = 0;

        //
        //  Initialize the UMRX_ENGINE MidAtlas
        //
        
        pUMRxEngine->MidAtlas = MidAtlas;
        ExInitializeFastMutex(&pUMRxEngine->MidManagementMutex);
        InitializeListHead(&pUMRxEngine->WaitingForMidListhead);        
        pUMRxEngine->NextSerialNumber = 0;
        
        InitializeListHead(&pUMRxEngine->ActiveLinkHead);
        
    } else {
        //
        //  out of resources - cleanup and bail
        //
        if (MidAtlas != NULL) 
        {
            RxDestroyMidAtlas(MidAtlas,NULL);
        }
    }

    DfsTraceLeave(0);
    return pUMRxEngine;
}

VOID
FinalizeUMRxEngine(
    IN PUMRX_ENGINE pUMRxEngine
    )
/*++

Routine Description:

    Close a UMRX_ENGINE object
   
Arguments:

    PUMRX_ENGINE    -   pointer to UMRX_ENGINE

Return Value:

Notes:

    Owner of object ensures that all usage of this object
    is within the Create/Finalize span.

--*/
{
    PLIST_ENTRY pFirstListEntry = NULL;
    PLIST_ENTRY pNextListEntry = NULL;
    BOOLEAN FoundPoisoner = FALSE;

    DfsTraceEnter("FinalizeUMRxEngine");

    //
    //  destroy engine mid atlas
    //
    if (pUMRxEngine->MidAtlas != NULL) 
    {
        RxDestroyMidAtlas(pUMRxEngine->MidAtlas, NULL);  //no individual callbacks needed
    }

    //
    //  rundown engine KQUEUE -
    //  Queue should only have poisoner entry
    //
    pFirstListEntry = KeRundownQueue(&pUMRxEngine->Q.Queue);
    if (pFirstListEntry != NULL) {
        pNextListEntry = pFirstListEntry;

        do {
            PLIST_ENTRY ThisEntry =  pNextListEntry;

            pNextListEntry = pNextListEntry->Flink;

            if (ThisEntry != &pUMRxEngine->Q.PoisonEntry) {
                if (DfsDbgVerbose) DbgPrint("Non poisoner %08lx in the queue...very odd\n",ThisEntry);
                DbgBreakPoint();
            } else {
                FoundPoisoner = TRUE;
            }
        } while (pNextListEntry != pFirstListEntry);
    }

    if (!FoundPoisoner) {
        //if (DfsDbgVerbose) DbgPrint("No poisoner in the queue...very odd\n");
    }

    ExDeleteResourceLite(&pUMRxEngine->Q.Lock);
    
    //
    //  destroy umrx engine
    //
    ExFreePool( pUMRxEngine );
    DfsTraceLeave(0);
}



NTSTATUS
UMRxEngineRestart(
                  IN PUMRX_ENGINE pUMRxEngine
                 )
/*++

Routine Description:

  This allows the engine state to be set so that it can service
  requests again.



--*/
{
    LARGE_INTEGER liTimeout = {0, 0};
    PLIST_ENTRY pListEntry = NULL;
    ULONG PreviousQueueState = 0;
    
    DfsTraceEnter("UMRxEngineRestart");
    if (DfsDbgVerbose) DbgPrint("Restarting a UMRX_ENGINE object\n");

    //
    //  First change the state so that nobody will try to get in.
    //
    PreviousQueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STARTING,
                                            UMRX_ENGINE_STATE_STOPPED);

    if (UMRX_ENGINE_STATE_STARTED == PreviousQueueState)
    {
        //
        // This is likely because the UMR server crashed.  This call is an
        //    indication that it's back up, so we should also clear the
        //    ThreadAborted value.
        //
        InterlockedExchange(&pUMRxEngine->Q.ThreadAborted,
                            0);
                            
        //clear the number of reflections as well.
        InterlockedExchange(&pUMRxEngine->cUserModeReflectionsInProgress,
                            0);

        if (DfsDbgVerbose) DbgPrint("UMRxEngineRestart already started 0x%08x\n",
                    pUMRxEngine);
        return STATUS_SUCCESS;
    }

    if (UMRX_ENGINE_STATE_STOPPED != PreviousQueueState)
    {
        if (DfsDbgVerbose) DbgPrint("UMRxEngineRestart unexpected previous queue state: 0x%08x => %d\n",
                             pUMRxEngine, PreviousQueueState);
        CHECK_STATUS(STATUS_UNSUCCESSFUL ) ;
        return STATUS_UNSUCCESSFUL;
    }
    

    //
    //  We won't be granted exclusive until all the threads queued have vacated.
    //
    ExAcquireResourceExclusiveLite(&pUMRxEngine->Q.Lock,
                                    TRUE);

    //
    //  Try to remove the poison entry that MAY be in the queue.
    //  It won't be there in the case that we've never started the engine.
    //
    pListEntry = KeRemoveQueue(&pUMRxEngine->Q.Queue,
                               UserMode,
                               &liTimeout);
    
    ASSERT(((ULONG_PTR)pListEntry == STATUS_TIMEOUT) ||
           (&pUMRxEngine->Q.PoisonEntry == pListEntry));

    //
    //  Clear the thread aborted value in case it was set.
    //
    InterlockedExchange(&pUMRxEngine->Q.ThreadAborted,
                        0);
    

    //clear the number of reflections as well.
    InterlockedExchange(&pUMRxEngine->cUserModeReflectionsInProgress,
                        0);
    //
    //  Now, that we've reinitialized things, we can change
    //    the state to STARTED;
    //
    PreviousQueueState = InterlockedExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STARTED);

    ASSERT(UMRX_ENGINE_STATE_STARTING == PreviousQueueState);

    //
    // Now, relinquish the lock
    //
    ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                    ExGetCurrentResourceThread());
        
    DfsTraceLeave(0);
    return STATUS_SUCCESS;
}



void
UMRxWakeupWaitingWaiter(IN PRX_CONTEXT RxContext, IN PUMRX_CONTEXT pUMRxContext)
{

    if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) 
    {
        //at last, call the continuation........
        if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
        UMRxResumeEngineContext( RxContext );
    } 
    else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) 
    {
        PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);

        if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) 
        {
            //
            // We won - signal and we are done !
            //
            if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            RxSignalSynchronousWaiter(RxContext);
        } 
        else 
        {
            //
            //  The reflection request has timed out in an async fashion -
            //  We need to complete the job of resuming the engine context !
            //
            if (DfsDbgVerbose) DbgPrint("SYNC Rx completing async %x\n",RxContext);
            if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            UMRxResumeEngineContext( RxContext );
        }

    } 
    else 
    {
        if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
        RxSignalSynchronousWaiter(RxContext);
    }  
}

NTSTATUS
UMRxEngineCompleteQueuedRequests(
                  IN PUMRX_ENGINE pUMRxEngine,
                  IN NTSTATUS     CompletionStatus,
                  IN BOOLEAN      fCleanup
                 )
/*++

Routine Description:

  This cleans up any reqeusts and places the engine in a state were it's ready to startup again.



--*/
{
    LARGE_INTEGER liTimeout = {0, 0};
    PLIST_ENTRY pListEntry = NULL;
    PUMRX_CONTEXT pUMRxContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    
    DfsTraceEnter("UMRxEngineCompleteQueuedRequests");
    if (DfsDbgVerbose) DbgPrint("Cleaning up a UMRX_ENGINE object\n");


    if (fCleanup)
    {

        //
        //  Change the state so nothing more can be queued.
        //
        InterlockedExchange(&pUMRxEngine->Q.State,
                            UMRX_ENGINE_STATE_STOPPED);
        //
        // Lock the queue.
        //
        ExAcquireResourceExclusiveLite(&pUMRxEngine->Q.Lock, TRUE);

        //
        //  Abort any requests that made it into the queue.
        //
        UMRxAbortPendingRequests(pUMRxEngine);
    }
    else
    {        
        ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock, TRUE);
    }

    //
    //  Now clear out the KQUEUE
    //
    for(;;)
    {
        pListEntry = KeRemoveQueue(&pUMRxEngine->Q.Queue,
                                   UserMode,
                                   &liTimeout);

        if (((ULONG_PTR)pListEntry == STATUS_TIMEOUT) ||
            ((ULONG_PTR)pListEntry == STATUS_USER_APC))
            break;

            
        if (&pUMRxEngine->Q.PoisonEntry == pListEntry)
            continue;

        //
        //  We have a valid queue entry
        //
        ASSERT(pListEntry);
        //
        //  Decode the UMRX_CONTEXT and RX_CONTEXT
        //
        pUMRxContext = CONTAINING_RECORD(
                                pListEntry,
                                UMRX_CONTEXT,
                                UserMode.WorkQueueLinks
                                );
                                
        RxContext =  pUMRxContext->RxContext;

        if (DfsDbgVerbose) DbgPrint("UMRxEngineCompleteQueuedRequests %08lx %08lx.\n",
                 RxContext,pUMRxContext);
        
        {
            // Complete the CALL!!!!!
            //
            pUMRxContext->Status = CompletionStatus;
            pUMRxContext->Information = 0;
            if (pUMRxContext->UserMode.CompletionRoutine != NULL)
            {
                ASSERT(pUMRxContext->UserMode.CompletionRoutine);
                if (DfsDbgVerbose) DbgPrint("  +++  Calling completion for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
                pUMRxContext->UserMode.CompletionRoutine(
                            pUMRxContext,
                            RxContext,
                            NULL,
                            0
                            );
            }
        }

        //
        // Wake up the thread that's waiting for this request to complete.
        //
        UMRxWakeupWaitingWaiter(RxContext, pUMRxContext);
        
        if (fCleanup)
        {
            pUMRxEngine->Q.NumberOfWorkerThreads = 0;
            pUMRxEngine->Q.NumberOfWorkItems = 0;
        }
        else
        {
            InterlockedDecrement(&pUMRxEngine->Q.NumberOfWorkItems);
        }
    }
        
    //
    // Unlock the queue.
    //
    ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                   ExGetCurrentResourceThread());

        
    DfsTraceLeave(0);
    return STATUS_SUCCESS;
}




NTSTATUS
UMRxEngineInitiateRequest (
    IN PUMRX_ENGINE pUMRxEngine,
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_CONTINUE_ROUTINE Continuation
    )
/*++

Routine Description:

    Initiate a request to the UMR engine -
    This creates a UMRxContext that is used for response rendezvous.
    All IFS dispatch routines will start a user-mode reflection by
    calling this routine. Steps in routine:

    1. Allocate a UMRxContext and set RxContext
       (NOTE: need to have ASSERTs that validate this linkage)
    2. Set Continue routine ptr and call Continue routine
    3. If Continue routine is done ie not PENDING, Finalize UMRxContext
   
Arguments:

    PRX_CONTEXT RxContext               -   Initiating RxContext
    UMRX_CONTEXT_TYPE RequestType       -   Type of request
    PUMRX_CONTINUE_ROUTINE Continuation -   Request Continuation routine

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_CONTEXT pUMRxContext = NULL;
    BOOLEAN FinalizationComplete;

    DfsTraceEnter("UMRxEngineInitiateRequest");

    ASSERT(RxContext);
    ASSERT(Continuation);
    ASSERT(pUMRxEngine);

    //
    //  Creating an UMRxContext requires a finalization
    //
    pUMRxContext = UMRxCreateAndReferenceContext(
                                RxContext,
                                RequestType
                                );

    if (pUMRxContext==NULL) {
        if (DfsDbgVerbose) DbgPrint("Couldn't allocate UMRxContext!\n");
        DfsTraceLeave(STATUS_INSUFFICIENT_RESOURCES);
        return((STATUS_INSUFFICIENT_RESOURCES));
    }

    pUMRxContext->pUMRxEngine  = pUMRxEngine;
    pUMRxContext->Continuation = Continuation;
    Status = Continuation(pUMRxContext,RxContext);

    //
    //  This matches the Creation above -
    //  NOTE: The continuation should have referenced the UMRxContext if needed
    //
    FinalizationComplete = UMRxDereferenceAndFinalizeContext(pUMRxContext);
        
    if (Status!=(STATUS_PENDING)) 
    {
        ASSERT(FinalizationComplete);
    } 
    else 
    {
        //bugbug
        //ASSERT( (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) ||
          //      (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED))  );
    }

    DfsTraceLeave(Status);
    return(Status);
}

PUMRX_CONTEXT
UMRxCreateAndReferenceContext (
    IN PRX_CONTEXT RxContext,
    IN UMRX_CONTEXT_TYPE RequestType
    )
/*++

Routine Description:

    Create an UMRX_CONTEXT - pool alloc
   
Arguments:

    PRX_CONTEXT RxContext           -   Initiating RxContex
    UMRX_CONTEXT_TYPE RequestType   -   Type of request

Return Value:

    PUMRX_CONTEXT   -   pointer to an UMRX_CONTEXT allocated

Notes:


--*/
{
    PUMRX_CONTEXT pUMRxContext = NULL;
    PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext); //BUGBUG

    DfsTraceEnter("UMRxCreateContext");
    if (DfsDbgVerbose) DbgPrint("UMRxCreateContext  --> entering \n") ;
    
    pUMRxContext = (PUMRX_CONTEXT)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    sizeof(UMRX_CONTEXT),
                                                    UMRX_CONTEXT_TAG 
                                                    );
    if( pUMRxContext ) 
    {
        ZeroAndInitializeNodeType( 
                           pUMRxContext,
                           UMRX_NTC_CONTEXT,
                           sizeof(UMRX_CONTEXT)
                           );
        InterlockedIncrement( &pUMRxContext->NodeReferenceCount );

        //place a reference on the rxcontext until we are finished
        InterlockedIncrement( &RxContext->ReferenceCount );
        
        pUMRxContext->RxContext = RxContext;
        pUMRxContext->CTXType = RequestType;

        //bugbug
        RxMinirdrContext->pUMRxContext = pUMRxContext;
        pUMRxContext->SavedMinirdrContextPtr = RxMinirdrContext;
    }

    if (DfsDbgVerbose) DbgPrint("UMRxCreateContext  --> leaving \n");
    DfsTraceLeave(0);
    return(pUMRxContext);
}


BOOLEAN
UMRxDereferenceAndFinalizeContext (
    IN OUT PUMRX_CONTEXT pUMRxContext
    )
    
/*++

Routine Description:

    Destroy an UMRX_CONTEXT - pool free
   
Arguments:

    PUMRX_CONTEXT   -   pointer to an UMRX_CONTEXT to free

Return Value:

    BOOLEAN - TRUE if success, FALSE if failure

Notes:


--*/
{
    LONG result;
    PRX_CONTEXT RxContext;
    
    DfsTraceEnter("UMRxFinalizeContext");
    
    result =  InterlockedDecrement(&pUMRxContext->NodeReferenceCount);
    if ( result != 0 ) {
        if (DfsDbgVerbose) DbgPrint("UMRxFinalizeContext -- returning w/o finalizing (%d)\n",result);
        DfsTraceLeave(0);
        return FALSE;
    }

    //
    //  Ref count is 0 - finalize the UMRxContext
    //
    if ( (RxContext = pUMRxContext->RxContext) != NULL ) {
        PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);
        ASSERT( RxMinirdrContext->pUMRxContext == pUMRxContext );

        //get rid of the reference on the RxContext....if i'm the last guy this will finalize
        RxDereferenceAndDeleteRxContext( pUMRxContext->RxContext );
    }

    ExFreePool(pUMRxContext);

    DfsTraceLeave(0);
    return TRUE;
}


NTSTATUS
UMRxEngineSubmitRequest(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext,
    IN UMRX_CONTEXT_TYPE RequestType,
    IN PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine,
    IN PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine
    )
/*++

Routine Description:

    Submit a request to the UMR engine -
    This adds the request to the engine KQUEUE for processing by
    a user-mode thread. Steps:
  
    1. set the FORMAT and COMPLETION callbacks in the UMRxContext
    2. initialize the RxContext sync event
    3. insert the UMRxContext into the engine KQUEUE
    4. block on RxContext sync event (for SYNC operations)
    5. after unblock (ie umode response is back), call Resume routine
   
Arguments:

    PUMRX_CONTEXT pUMRxContext      -   ptr to UMRX_CONTEXT for request
    PRX_CONTEXT   RxContext         -   Initiating RxContext
    UMRX_CONTEXT_TYPE RequestType   -   Type of Request
    PUMRX_USERMODE_FORMAT_ROUTINE FormatRoutine     -   FORMAT routine
    PUMRX_USERMODE_COMPLETION_ROUTINE CompletionRoutine -   COMPLETION routine

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS        Status = STATUS_UNSUCCESSFUL;
    PUMRX_ENGINE    pUMRxEngine = pUMRxContext->pUMRxEngine;
    ULONG           QueueState = 0;
    ULONG           ThreadAborted = 0;
    BOOLEAN         FinalizationCompleted = FALSE;
    PUMRX_RX_CONTEXT RxMinirdrContext = NULL;


    DfsTraceEnter("UMRxFinalizeContext");

    RxMinirdrContext = UMRxGetMinirdrContext(RxContext);

    if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest\n");
    if (DfsDbgVerbose) DbgPrint("UMRxSubmitRequest entering......CTX=%08lx <%d>\n",
             pUMRxContext,RequestType);

    pUMRxContext->CTXType = RequestType;
    pUMRxContext->UserMode.FormatRoutine = FormatRoutine;
    pUMRxContext->UserMode.CompletionRoutine = CompletionRoutine;

    RxMinirdrContext->RxSyncTimeout = 1;
    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );

    //
    //  If we fail to submit, we should finalize right away
    //  If we succeed in submitting, we should finalize post completion
    //
    UMRxReferenceContext( pUMRxContext );

    //
    // Try to get a shared lock on the engine.
    // If this fails it means the lock is already own exclusive.
    //
    if (ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock,
                                                                        FALSE))
    {
                QueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                                                        UMRX_ENGINE_STATE_STARTED,
                                                                        UMRX_ENGINE_STATE_STARTED);
                if (UMRX_ENGINE_STATE_STARTED == QueueState)
                {
                        ThreadAborted = InterlockedCompareExchange(&pUMRxEngine->Q.ThreadAborted,
                                                                                                                0,
                                                                                                                0);
                        if (!ThreadAborted)
                        {
                                //
                                //  Insert request into engine KQUEUE
                                //    
                                //RxLog((" UMRSubmitReq to KQ UCTX RXC %lx %lx\n", pUMRxContext, RxContext));
                
                                KeInsertQueue(&pUMRxEngine->Q.Queue,
                                                        &pUMRxContext->UserMode.WorkQueueLinks);
                                
                                InterlockedIncrement(&pUMRxEngine->Q.NumberOfWorkItems);
                                
                                //
                                //  Did it abort while we were enqueing?
                                //
                                ThreadAborted = InterlockedCompareExchange(&pUMRxEngine->Q.ThreadAborted,
                                                                                                                        0,
                                                                                                                        0);
                                //
                                //  If it did abort, we need to clear out any pending requests.
                                //
                                if (ThreadAborted)
                                {
                                    UMRxAbortPendingRequests(pUMRxEngine);
                                }
                                
                                Status = STATUS_SUCCESS;
                        }
                        else
                        {
                                //
                                //  The engine is STARTED, but we have evidence that the
                                //     UMR server has crashed becuase the ThreadAborted value
                                //     is set.
                                //
                                Status = STATUS_NO_SUCH_DEVICE;
                                if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest: Engine in aborted state.\n");
                        }
                }
                else
                {
                        ASSERT(UMRX_ENGINE_STATE_STOPPED == QueueState);
                        //
                        //  The state isn't STARTED, so we'll bail out.
                        //
                        Status = STATUS_NO_SUCH_DEVICE;
                        if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest: Engine is not started.\n");
                }

                ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                                                        ExGetCurrentResourceThread());          
    }
    else
    {
                //
                //  This means that someone owns the lock exclusively which means
                //    it's changing state which means we treat this as STOPPED.
                //
                Status = STATUS_DEVICE_NOT_CONNECTED;
                if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest failed to get shared lock\n");
    }

    //
    //  If we were able to insert the item in the queue, then let's
    //     do what we do to return the result.
    //
    if (NT_SUCCESS(Status))
    {
        //
        //  If async mode, return pending
        //  else if sync with timeout, wait with timeout
        //  else wait for response
        //

        if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) {
            Status = STATUS_PENDING;
        } else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) {
            LARGE_INTEGER liTimeout;
            
            //
            //  Wait for UMR operation to complete
            //
            liTimeout.QuadPart = -10000 * 1000 * 15;    // 15 seconds
            RxWaitSyncWithTimeout( RxContext, &liTimeout );    

            //
            //  There could be a race with the response to resume the engine context -
            //  Need to synchronize using Interlocked operations !
            //
            if( Status == STATUS_TIMEOUT ) {
                if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) {
                    //
                    //  return STATUS_PENDING to caller - a sync reflection that
                    //  timed out is same as an async Rx.
                    //
                    Status = STATUS_PENDING;
                } else {
                    Status = UMRxResumeEngineContext( RxContext );
                }
            } else {
                Status = UMRxResumeEngineContext( RxContext );
            }
            
        } else {
            //
            //  Wait for UMR operation to complete
            //
            RxWaitSync( RxContext );    
            
            //at last, call the continuation........
            Status = UMRxResumeEngineContext( RxContext );
        }        
    }
    else
    {
        //
        // Remove the reference we added up above.
        //
        FinalizationCompleted = UMRxDereferenceAndFinalizeContext(pUMRxContext);
        ASSERT( !FinalizationCompleted );
    }

    if (DfsDbgVerbose) DbgPrint("UMRxEngineSubmitRequest returning %08lx.\n", Status);
    DfsTraceLeave(Status);
    CHECK_STATUS(Status) ;
    return(Status);
}


NTSTATUS
UMRxResumeEngineContext(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    Resume is called after I/O thread is unblocked by umode RESPONSE.
    This routine calls any Finish callbacks and then Finalizes the 
    UMRxContext.
   
Arguments:

    RxContext - Initiating RxContext

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_OBJECT_NAME_EXISTS;
    PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);
    PUMRX_CONTEXT pUMRxContext = (PUMRX_CONTEXT)(RxMinirdrContext->pUMRxContext);

    DfsTraceEnter("UMRxResumeEngineContext");
    if (DfsDbgVerbose) DbgPrint("UMRxResumeEngineContext entering........CTX=%08lx\n",pUMRxContext);

    Status = pUMRxContext->Status;
    UMRxDereferenceAndFinalizeContext(pUMRxContext);

    if (DfsDbgVerbose) DbgPrint("UMRxResumeEngineContext returning %08lx.\n", Status);
    DfsTraceLeave(Status);
    return(Status);
}


void
UMRxDisassoicateMid(
    IN PUMRX_ENGINE pUMRxEngine,
    IN PUMRX_CONTEXT pUMRxContext,
    IN BOOLEAN fReleaseMidAtlasLock
    )
/*++

Routine Description:

    Disassociates a MID.  If there is someone waiting to acquire a mid,
    then this will reassociated the MID on behalf of the waiter.
    
    The MidManagementMutex is held on entry and released on exit.
    
Arguments:

    pUMRxEngine -- Engine that the MID is being disassociated from.
    mid         -- MID to be disassociated.
    fReleaseMidAtlasLock -- should the mid atlas lock be released?
    
Return Value:

    void

Notes:


--*/
{   
    USHORT mid = 0;


    mid = pUMRxContext->UserMode.CallUpMid;
    //
    //  Remove this from the active context list.
    //
    RemoveEntryList(&pUMRxContext->ActiveLink);
        
    if (IsListEmpty(&pUMRxEngine->WaitingForMidListhead)) {
        if (DfsDbgVerbose) DbgPrint("giving up mid %08lx...... mid %04lx.\n",
                    pUMRxEngine,
                    mid);
        
        RxMapAndDissociateMidFromContext(
                                         pUMRxEngine->MidAtlas,
                                         mid,
                                         &pUMRxContext);

        if (fReleaseMidAtlasLock)
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);

    } else {

        //
        //  This is the case where somebody is waiting to allocate a MID
        //    so we need to give the MID to them and associate it on their behalf.
        //
        PLIST_ENTRY ThisEntry = RemoveHeadList(&pUMRxEngine->WaitingForMidListhead);
        
        pUMRxContext = CONTAINING_RECORD(ThisEntry,
                                         UMRX_CONTEXT,
                                         UserMode.WorkQueueLinks);
        
        if (DfsDbgVerbose) DbgPrint(
                   "reassigning MID mid %08lx ...... mid %04lx %08lx.\n",
                    pUMRxEngine,
                    mid,
                    pUMRxContext);
        
        RxReassociateMid(
                         pUMRxEngine->MidAtlas,
                         mid,
                         pUMRxContext);
        //
        //  Add this context to the active link list
        //
        InsertTailList(&pUMRxEngine->ActiveLinkHead, &pUMRxContext->ActiveLink);
        
        if (fReleaseMidAtlasLock)
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);

        pUMRxContext->UserMode.CallUpMid = mid;
        KeSetEvent(
                   &pUMRxContext->UserMode.WaitForMidEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
}


NTSTATUS
UMRxVerifyHeader (
    IN PUMRX_ENGINE pUMRxEngine,
    IN PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG ReassignmentCmd,
    OUT PUMRX_CONTEXT *capturedContext
    )
/*++

Routine Description:

    This routine makes sure that the header passed in is valid....that is,
    that it really refers to the operation encoded. if it does, then it reasigns
    or releases the MID as appropriate.

Arguments:

Return Value:

    STATUS_SUCCESS if the header is good
    STATUS_INVALID_PARAMETER otherwise


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = NULL;
    PUMRX_CONTEXT pUMRxContext = NULL;
    UMRX_USERMODE_WORKITEM_HEADER capturedHeader;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader =
                (PUMRX_WORKITEM_HEADER_PRIVATE)(&capturedHeader);
 
    DfsTraceEnter("UMRxVerifyHeader");
    if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteUserModeRequest %08lx %08lx %08lx.\n",
             pUMRxEngine,WorkItem,
             PrivateWorkItemHeader->pUMRxContext);

    capturedHeader = WorkItem->Header;

    ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);
    pUMRxContext = RxMapMidToContext(pUMRxEngine->MidAtlas,
                                           PrivateWorkItemHeader->Mid);

    if (pUMRxContext)
    {
        RxContext = pUMRxContext->RxContext;
        
        ASSERT(RxContext);

        //
        //  Clear the cancel routine
        //
        Status = RxSetMinirdrCancelRoutine(RxContext,
                                           NULL);
        if (Status == STATUS_CANCELLED)
        {
            //
            //  The cancel routine is being called but hasn't removed this from the MID Atlas yet.
            //  In this case, we know that everthing is handled by the cancel routine.
            //  Setting this to NULL fakes the rest of this function and it's caller
            //  into thinking that the MID wasn't found in the Mid Atlas.  This is exactly what would
            //  have happened if the cancel routine had completed executing before we got to this point.
            //
            pUMRxContext = NULL;
        }
    }

    if ((pUMRxContext == NULL)
          || (pUMRxContext != PrivateWorkItemHeader->pUMRxContext)
          || (pUMRxContext->UserMode.CallUpMid
                                 != PrivateWorkItemHeader->Mid)
          || (pUMRxContext->UserMode.CallUpSerialNumber
                                 != PrivateWorkItemHeader->SerialNumber) ) {
        //this is a bad packet.....just release and get out!
        ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
        if (DfsDbgVerbose) DbgPrint("UMRxVerifyHeader: %08lx %08lx\n",pUMRxContext,PrivateWorkItemHeader);
        Status = STATUS_INVALID_PARAMETER;
    } else {
        BOOLEAN Finalized;

        *capturedContext = pUMRxContext;
        if (ReassignmentCmd == DONT_REASSIGN_MID) {
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
        } else {
            //now give up the MID.....if there is someone waiting then give it to him
            // otherwise, just give it back
            
            // On Entry, the MidManagementMutex is held
            //
            UMRxDisassoicateMid(pUMRxEngine,
                                pUMRxContext,
                                TRUE);
            //
            // Upon return, the MidManagementMutex is not held.
            //
            //remove the reference i put before i went off
            Finalized = UMRxDereferenceAndFinalizeContext(pUMRxContext);
            ASSERT(!Finalized);
        }
    }

    if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteUserModeRequest %08lx %08lx %08lx......%08lx.\n",
             pUMRxEngine,WorkItem,
             PrivateWorkItemHeader->pUMRxContext,Status);

    DfsTraceLeave(Status);
    return(Status);
}


NTSTATUS
UMRxAcquireMidAndFormatHeader (
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext,
    IN PUMRX_ENGINE  pUMRxEngine,
    IN OUT PUMRX_USERMODE_WORKITEM WorkItem
    )
/*++

Routine Description:

    This routine gets a mid and formats the header.....it waits until it can
    get a MID if all the MIDs are currently passed out.

Arguments:

Return Value:

    STATUS_SUCCESS...later could be STATUS_CANCELLED


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader =
                (PUMRX_WORKITEM_HEADER_PRIVATE)(&WorkItem->Header);
    PUMRX_USERMODE_WORKITEM_HEADER PublicWorkItemHeader = 
        (PUMRX_USERMODE_WORKITEM_HEADER)(&WorkItem->Header);
    
    DfsTraceEnter("UMRxAcquireMidAndFormatHeader");
    if (DfsDbgVerbose) DbgPrint(
            "UMRxAcquireMidAndFormatHeader %08lx %08lx %08lx.\n",
             RxContext,pUMRxContext,WorkItem);

    RtlZeroMemory(&WorkItem->Header,
                  FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest));
        
    ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);
    UMRxReferenceContext( pUMRxContext ); //taken away as we disassociate the mid

    if (IsListEmpty(&pUMRxEngine->WaitingForMidListhead)) {
        Status = RxAssociateContextWithMid(
                                pUMRxEngine->MidAtlas,
                                pUMRxContext,
                                &pUMRxContext->UserMode.CallUpMid);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    if (Status == STATUS_SUCCESS) {
        //
        //  Add this context to the active link list
        //
        InsertTailList(&pUMRxEngine->ActiveLinkHead, &pUMRxContext->ActiveLink);
        
        ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
    } else {
        KeInitializeEvent(&pUMRxContext->UserMode.WaitForMidEvent,
                          NotificationEvent,
                          FALSE);
                          
        InsertTailList(&pUMRxEngine->WaitingForMidListhead,
                       &pUMRxContext->UserMode.WorkQueueLinks);
                       
        ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
        KeWaitForSingleObject(
                    &pUMRxContext->UserMode.WaitForMidEvent,
                    Executive,
                    UserMode,
                    FALSE,
                    NULL);
                    
        Status = STATUS_SUCCESS;
    }

    PrivateWorkItemHeader->pUMRxContext = pUMRxContext;
    pUMRxContext->UserMode.CallUpSerialNumber
               = PrivateWorkItemHeader->SerialNumber
               = InterlockedIncrement(&pUMRxEngine->NextSerialNumber);
    PrivateWorkItemHeader->Mid = pUMRxContext->UserMode.CallUpMid;

    if (DfsDbgVerbose) DbgPrint(
        "UMRxAcquireMidAndFormatHeader %08lx %08lx %08lx returning %08lx.\n",
             RxContext,pUMRxContext,WorkItem,Status);
             
    DfsTraceLeave(Status);
    CHECK_STATUS(Status) ;
    return(Status);
}


//
//  The following functions run in the context of user-mode
//  worker threads that issue WORK IOCTLs. The IOCTL calls the
//  following functions in order:
//  1. UMRxCompleteUserModeRequest() - process a response if needed
//  2. UMRxEngineProcessRequest()  - process a request if one is
//     available on the UMRxEngine KQUEUE. 
//

NTSTATUS
UMRxCompleteUserModeRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    IN OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    IN BOOLEAN fReleaseUmrRef,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT BOOLEAN * pfReturnImmediately
    )
/*++

Routine Description:

    Every IOCTL pended is potentially a Response. If so, process it.
    The first IOCTL pended is usually a NULL Response or 'listen'.
    Steps:  
    1. Get MID from response buffer. Map MID to UMRxContext.
    2. Call UMRxContext COMPLETION routine.
    3. Unblock the I/O thread waiting in UMRxEngineSubmitRequest()
   
Arguments:

    PUMRX_ENGINE pUMRxEngine            -   UMRX engine context
    PUMRX_USERMODE_WORKITEM WorkItem    -   WorkItem to process
    ULONG WorkItemLength                -   WorkItem length
    BOOLEAN fReleaseUmrRef              -   Should it be released?
    PIO_STATUS_BLOCK IoStatus           -   STATUS of operation
    BOOLEAN *pfReturnImmediately        -   Parse this out of the response.

Return Value:

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_CONTEXT pUMRxContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    LONG lRefs = 0;
    
    DfsTraceEnter("UMRxCompleteUserModeRequest");
    if (DfsDbgVerbose) DbgPrint("UMRxCompleteUserModeRequest -> %08lx %08lx %08lx\n",
            pUMRxEngine,PsGetCurrentThread(),WorkItem);
            
    try
    {

        ASSERT(pfReturnImmediately);

        *pfReturnImmediately = FALSE;
        IoStatus->Information = 0;
        IoStatus->Status = STATUS_CANNOT_IMPERSONATE;

        if ((NULL == WorkItem) ||
            (WorkItemLength < sizeof(UMRX_USERMODE_WORKITEM_HEADER)) ||
            (WorkItem->Header.CorrelatorAsUInt[0] == 0)) {
            //  NULL/zero length WorkItem => this is a 'listen'
            IoStatus->Status = Status;
            IoStatus->Information = 0;
            return Status;
        }

        *pfReturnImmediately = !!(WorkItem->Header.ulFlags & UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE);

        Status = UMRxVerifyHeader(pUMRxEngine,
                                  WorkItem,
                                  REASSIGN_MID,
                                  &pUMRxContext);

        if (Status != STATUS_SUCCESS) {
            IoStatus->Status = Status;
            if (DfsDbgVerbose) DbgPrint(
                    "UMRxCompleteUserModeRequest [badhdr] %08lx %08lx %08lx returning %08lx.\n",
                    pUMRxEngine,PsGetCurrentThread(),WorkItem,Status);
            DfsTraceLeave(Status);
            RtlZeroMemory(&WorkItem->Header,sizeof(UMRX_USERMODE_WORKITEM_HEADER));
            return(Status);
        }

        RxContext = pUMRxContext->RxContext;

        //BUGBUG need try/except
        pUMRxContext->IoStatusBlock = WorkItem->Header.IoStatus;
        if (pUMRxContext->UserMode.CompletionRoutine != NULL) {
            pUMRxContext->UserMode.CompletionRoutine(
                            pUMRxContext,
                            RxContext,
                            WorkItem,
                            WorkItemLength
                            );
        }

        if( fReleaseUmrRef ) 
        {
           //
           //  NOTE: UmrRef needs to be released AFTER completion routine is called !
           //

            //BUGBUGBUG
           ReleaseUmrRef() ;                
        }

        RtlZeroMemory(&WorkItem->Header,sizeof(UMRX_USERMODE_WORKITEM_HEADER));

        //
        //  release the initiating RxContext !
        //
        if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) 
        {
            //at last, call the continuation........
            Status = UMRxResumeEngineContext( RxContext );
        } 
        else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) 
        {
            PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);

            if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) 
            {
                //
                // We won - signal and we are done !
                //
                RxSignalSynchronousWaiter(RxContext);
            } 
            else 
            {
                //
                //  The reflection request has timed out in an async fashion -
                //  We need to complete the job of resuming the engine context !
                //
                Status = UMRxResumeEngineContext( RxContext );
            }

        } 
        else 
        {
            RxSignalSynchronousWaiter(RxContext);
        }


        if (DfsDbgVerbose) DbgPrint("UMRxCompleteUserModeRequest -> %08lx %08lx %08lx ret %08lx\n",
                pUMRxEngine,PsGetCurrentThread(),WorkItem,Status);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    DfsTraceLeave(Status);
    return(Status);
}


NTSTATUS
UMRxCancelRoutineEx(
      IN PRX_CONTEXT RxContext,
      IN BOOLEAN fMidAtlasLockAcquired
      )
/*++

Routine Description:

    CancelIO handler routine.

Arguments:

    PRX_CONTEXT RxContext               -   Initiating RxContext
    BOOLEAN     fMidAtlasLockAcquired   -   The caller controls the locking

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/      
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMRX_ENGINE pUMRxEngine = GetUMRxEngineFromRxContext();
    PUMRX_CONTEXT pUMRxContext = NULL;
    PUMRX_RX_CONTEXT RxMinirdrContext = UMRxGetMinirdrContext(RxContext);
    BOOLEAN  Finalized = FALSE;

    ASSERT(RxMinirdrContext);
    ASSERT(RxMinirdrContext->pUMRxContext);

    if (!fMidAtlasLockAcquired)
        ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);
        
    pUMRxContext = RxMapMidToContext(pUMRxEngine->MidAtlas,
                                     RxMinirdrContext->pUMRxContext->UserMode.CallUpMid);
    if (pUMRxContext &&
        (pUMRxContext == RxMinirdrContext->pUMRxContext))
    {

        ASSERT(pUMRxContext->RxContext == RxContext);

        UMRxDisassoicateMid(pUMRxEngine,
                            pUMRxContext,
                            (BOOLEAN)!fMidAtlasLockAcquired);
        //
        // Side affect of above call is the release of the MidManagementMutex
        //
        //
        // Remove the reference on the UMRxContext when the mid was associated with
        //    it.
        //
        Finalized = UMRxDereferenceAndFinalizeContext(pUMRxContext);
        ASSERT(!Finalized);

        // Complete the CALL!!!!!
        //
        pUMRxContext->Status = STATUS_CANCELLED;
        pUMRxContext->Information = 0;
        if (pUMRxContext->UserMode.CompletionRoutine != NULL)
        {
            if (DfsDbgVerbose) DbgPrint("  ++  Calling completion for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            pUMRxContext->UserMode.CompletionRoutine(
                        pUMRxContext,
                        RxContext,
                        NULL,
                        0
                        );
        }

        //
        //  Now Release the UmrRef.
        //  NOTE: UmrRef needs to be released AFTER completion routine is called !
        //
         ReleaseUmrRef();

        //
        // Wake up the thread that's waiting for this request to complete.
        //        
        if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION ) ) 
        {
            //at last, call the continuation........
            if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            Status = UMRxResumeEngineContext( RxContext );
        } 
        else if( FlagOn( RxContext->Flags, DFS_CONTEXT_FLAG_FILTER_INITIATED ) ) 
        {

            if( InterlockedDecrement( &RxMinirdrContext->RxSyncTimeout ) == 0 ) 
            {
                //
                // We won - signal and we are done !
                //
                if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
                RxSignalSynchronousWaiter(RxContext);
            } 
            else 
            {
                //
                //  The reflection request has timed out in an async fashion -
                //  We need to complete the job of resuming the engine context !
                //
                if (DfsDbgVerbose) DbgPrint("SYNC Rx completing async %x\n",RxContext);
                if (DfsDbgVerbose) DbgPrint("  +++  Resuming Engine Context for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
                Status = UMRxResumeEngineContext( RxContext );
            }
        
        } 
        else 
        {
            if (DfsDbgVerbose) DbgPrint("  +++  Signalling Synchronous waiter for: 0x%08x, 0x%08x\n", pUMRxContext, RxContext);
            RxSignalSynchronousWaiter(RxContext);
        }                

    }
    else
    {
        // It didn't match.  The request must have completed normally
        //   on its own.
        // We'll release the mutex now.
        //
        if (!fMidAtlasLockAcquired)     
            ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);           
            
        if (DfsDbgVerbose) DbgPrint("  ++  Store Mid Context doesn't match RxContext for: 0x%08x, 0x%08x 0x%08x\n", pUMRxContext, RxContext, RxMinirdrContext->pUMRxContext);
    }       

    return Status;
}


NTSTATUS
UMRxCancelRoutine(
      IN PRX_CONTEXT RxContext
      )
{   
    return UMRxCancelRoutineEx(RxContext, FALSE);
}



void
UMRxMidAtlasIterator(IN PUMRX_CONTEXT pUMRxContext)
{
    if (DfsDbgVerbose) DbgPrint("  ++  Canceling: 0x%08x, 0x%08x\n",
             pUMRxContext, pUMRxContext->RxContext);
    UMRxCancelRoutineEx(pUMRxContext->RxContext,
                      TRUE);
}


void
UMRxAbortPendingRequests(IN PUMRX_ENGINE pUMRxEngine)
{
    ExAcquireFastMutex(&pUMRxEngine->MidManagementMutex);

    RxIterateMidAtlasAndRemove(pUMRxEngine->MidAtlas, UMRxMidAtlasIterator);

    ExReleaseFastMutex(&pUMRxEngine->MidManagementMutex);
}


//
//  NOTE: if no requests are available, the user-mode thread will
//  block till a request is available (It is trivial to make this
//  a more async model).
//  
NTSTATUS
UMRxEngineProcessRequest(
    IN PUMRX_ENGINE pUMRxEngine,
    OUT PUMRX_USERMODE_WORKITEM WorkItem,
    IN ULONG WorkItemLength,
    OUT PULONG FormattedWorkItemLength
    )
/*++

Routine Description:
  
    If a request is available, get the corresponding UMRxContext and
    call ProcessRequest.
    Steps:
    1. Call KeRemoveQueue() to remove a request from the UMRxEngine KQUEUE.
    2. Get a MID for this UMRxContext and fill it in the WORK_ITEM header.
    3. Call the UMRxContext FORMAT routine - this fills in the Request params.
    4. return STATUS_SUCCESS - this causes the IOCTL to complete which
       triggers the user-mode completion and processing of the REQUEST.
   
Arguments:

    PUMRX_CONTEXT pUMRxContext          -   UMRX_CONTEXT for request
    PUMRX_USERMODE_WORKITEM WorkItem    -   Request WorkItem 
    ULONG WorkItemLength                -   WorkItem length
    PULONG FormattedWorkItemLength      -   Len of formatted data in buffer

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    PETHREAD CurrentThread = PsGetCurrentThread();
    PLIST_ENTRY pListEntry = NULL;
    PUMRX_CONTEXT pUMRxContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    ULONG i = 0;
    BOOLEAN fReleaseUmrRef = FALSE;
    BOOLEAN fLockAcquired = FALSE;
    BOOLEAN fThreadCounted = TRUE;
    ULONG   QueueState;
    PUMRX_USERMODE_WORKITEM WorkItemLarge;
    ULONG                   WorkItemLengthLarge;
    ULONG                   FormattedWorkItemLengthLarge = 0;

    DfsTraceEnter("UMRxEngineProcessRequest");
    if (DfsDbgVerbose) DbgPrint("UMRxEngineProcessRequest [Start] -> %08lx %08lx %08lx\n",
            pUMRxEngine,CurrentThread,WorkItem);

    *FormattedWorkItemLength = 0;

    if (WorkItemLength < (ULONG)FIELD_OFFSET(UMRX_USERMODE_WORKITEM,Pad[0])) {
        Status = STATUS_BUFFER_TOO_SMALL;
        if (DfsDbgVerbose) DbgPrint(
            "UMRxEngineProcessRequest [noacc] -> %08lx %08lx %08lx st=%08lx\n",
            pUMRxEngine,CurrentThread,WorkItem,Status);
        goto Exit;
    }

    //
    //  First try to get a shared lock on the UMR Engine.
    //
    fLockAcquired = ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock,
                                                FALSE); 
    if (!fLockAcquired)
    {
        //
        //  We didn't get it, so the engine is either startup up or shutting down.
        //  In either case, we'll bail out.
        //
        if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest [NotStarted] -> %08lx %08lx %08lx st=%08lx\n",
            pUMRxEngine,CurrentThread,WorkItem,Status);
            goto Exit;
    }

    //
    //  Now let's check the current engine state.
    //
    QueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                    UMRX_ENGINE_STATE_STARTED,
                                    UMRX_ENGINE_STATE_STARTED);
    if (UMRX_ENGINE_STATE_STARTED != QueueState)
    {
        //
        //  Must be stopped, so we'll bail out.
        //
        ASSERT(UMRX_ENGINE_STATE_STOPPED == QueueState);
        if (DfsDbgVerbose) DbgPrint(
            "UMRxEngineProcessRequest [NotStarted2] -> %08lx %08lx %08lx st=%08lx\n",
            pUMRxEngine,CurrentThread,WorkItem,Status);
            goto Exit;
    }
    
    //
    //  Remove a request from engine KQUEUE
    //
    InterlockedIncrement(&pUMRxEngine->Q.NumberOfWorkerThreads);
    fThreadCounted = TRUE;
    
    for (i=1;;i++) {

        fReleaseUmrRef = FALSE;

        //
        //  Temporarily enable Kernel APC delivery to this thread
        //     This is because the system will delivery an APC if the
        //     process that this thread owned by dies.
        //
        FsRtlExitFileSystem();
        
        pListEntry = KeRemoveQueue(
                         &pUMRxEngine->Q.Queue,
                         UserMode,
                         NULL //&pUMRxEngine->Q.TimeOut
                         ); 
        
        //
        //  Now, Disable Kernel APC Delivery again.
        //
        FsRtlEnterFileSystem();

        //if (DfsDbgVerbose) DbgPrint("Dequeued entry %x\n",pListEntry);
        //if (DfsDbgVerbose) DbgPrint("poison entry is %x\n",&pUMRxEngine->Q.PoisonEntry);
        
        if ((ULONG_PTR)pListEntry == STATUS_TIMEOUT) 
        {
#if 0
            if ((i%5)==0) 
            {
                if (DfsDbgVerbose) DbgPrint(
                    "UMRxEngineProcessRequest [repost] -> %08lx %08lx %08lx i=%d\n",
                    pUMRxEngine,CurrentThread,WorkItem,i);
            }
#endif
            continue;
        }

        //  may have to check for STATUS_ALERTED so we handle the kill case !!
        if ((ULONG_PTR)pListEntry == STATUS_USER_APC) 
         {
            Status = STATUS_USER_APC;
            if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest [usrapc] -> %08lx %08lx %08lx i=%d\n",
                pUMRxEngine,CurrentThread,WorkItem,i);

            //
            //  unblock outstanding requests in MID ATLAS....
            //
            UMRxAbortPendingRequests(pUMRxEngine);
            
            Status = STATUS_REQUEST_ABORTED;
            break;
        }

        if (pListEntry == &pUMRxEngine->Q.PoisonEntry) 
        {
            if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest [poison] -> %08lx %08lx %08lx\n",
                pUMRxEngine,CurrentThread,WorkItem);
            //Status = STATUS_REQUEST_ABORTED;
            KeInsertQueue(&pUMRxEngine->Q.Queue,pListEntry);
            goto Exit;
        }

        InterlockedDecrement(&pUMRxEngine->Q.NumberOfWorkItems);
        //
        //  Decode the UMRX_CONTEXT and RX_CONTEXT
        //
        pUMRxContext = CONTAINING_RECORD(
                                pListEntry,
                                UMRX_CONTEXT,
                                UserMode.WorkQueueLinks
                                );
                                
        RxContext =  pUMRxContext->RxContext; 

        if (DfsDbgVerbose) DbgPrint(
                "UMRxEngineProcessRequest %08lx %08lx %08lx.\n",
                 RxContext,pUMRxContext,WorkItem);

        //
        //  Acquire MID for UMRX_CONTEXT and call FORMAT routine
        //
        Status = UMRxAcquireMidAndFormatHeader(
                            pUMRxContext,
                            RxContext,
                            pUMRxEngine,
                            WorkItem
                            );

        //
        //  Get a reference to use the Umr for this netroot.
        //
        if (STATUS_SUCCESS == Status )  
        {
           AddUmrRef();
           fReleaseUmrRef = TRUE;
        }

        WorkItem->Header.ulHeaderVersion = UMR_VERSION;
        if ((Status == STATUS_SUCCESS)
             && (pUMRxContext->UserMode.FormatRoutine != NULL)) 
        {
            Status = pUMRxContext->UserMode.FormatRoutine(
                        pUMRxContext,
                        RxContext,
                        WorkItem,
                        WorkItemLength,
                        FormattedWorkItemLength
                        );
            if (( Status != STATUS_SUCCESS ) &&
                ( Status != STATUS_BUFFER_OVERFLOW ) &&
                ( Status != STATUS_DISK_FULL ) &&
                ( Status != STATUS_NO_MEMORY ) &&
                ( Status != STATUS_INSUFFICIENT_RESOURCES ) &&
                ( Status != STATUS_INVALID_PARAMETER )) {
                ASSERT( FALSE );
            }
        }

        if (Status == STATUS_SUCCESS)
        {
            //
            // Establish the Cancel Routine.
            //
            Status = RxSetMinirdrCancelRoutine(RxContext,
                                               UMRxCancelRoutine);
            //
            // This may return STATUS_CANCELED in which case the request will
            //   be completed below.
            //
        }

        //
        //  If FORMAT fails, complete the request here !
        //
        if( Status != STATUS_SUCCESS )
        {
            IO_STATUS_BLOCK IoStatus;
            BOOLEAN fReturnImmediately;

            IoStatus.Status =
            pUMRxContext->Status =
            WorkItem->Header.IoStatus.Status = Status;
            
            IoStatus.Information =
            pUMRxContext->Information =
            WorkItem->Header.IoStatus.Information = 0;
            
            Status = UMRxCompleteUserModeRequest(
                                    pUMRxEngine,
                                    WorkItem,
                                    WorkItemLength,
                                    FALSE,
                                    &IoStatus,
                                    &fReturnImmediately
                                    );

            if (fReleaseUmrRef)
            {
                //
                //  NOTE: UmrRef needs to be released AFTER completion routine is called !
                //
                ReleaseUmrRef();
            }
                                    
            continue;
        }

        //
        //  go back to user-mode to process this request !
        //
        Status = STATUS_SUCCESS;
        break;
    }

Exit:
    //
    //  If one of the threads received a USER_APC, then we want to take
    //    note of this.  This will be another condition undewich client
    //    threads do not enqueue reuqests becuase the UMR server has likely
    //    crashed.
    //
    if (STATUS_REQUEST_ABORTED == Status) 
    {
        if( InterlockedExchange(&pUMRxEngine->Q.ThreadAborted,1) == 0 ) 
        {
            if (DfsDbgVerbose) DbgPrint("Usermode crashed......\n");
        }
    }
    
    if (fThreadCounted)
        InterlockedDecrement(&pUMRxEngine->Q.NumberOfWorkerThreads);

    if (fLockAcquired)
        ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());

    if (DfsDbgVerbose) DbgPrint(
            "UMRxEngineProcessRequest %08lx %08lx %08lx returning %08lx.\n",
             RxContext,pUMRxContext,WorkItem,Status);

    DfsTraceLeave(Status);
    CHECK_STATUS(Status) ;
    return Status;
}


NTSTATUS
UMRxCompleteQueueRequestsWithError(
    IN PUMRX_ENGINE pUMRxEngine,
    IN NTSTATUS     CompletionStatus
    )
/*++

Routine Description:

    This is currently called whenever there isn't enough memory in usermode to
    process requests from the kernel.  We should complete any requests queued to the UMR
    with whatever error is supplied in this call.
   
Arguments:

    PUMRX_ENGINE pUMRxEngine    -   Engine to complete requests against.
    NTSTATUS     CompletionStatus  -- Error to complete requests with.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    BOOLEAN fLockAcquired = FALSE;
    ULONG   QueueState = 0;
    
    //
    //  First try to get a shared lock on the UMR Engine.
    //
    fLockAcquired = ExAcquireResourceSharedLite(&pUMRxEngine->Q.Lock,
                                                FALSE); 
    if (!fLockAcquired)
    {
        //
        //  We didn't get it, so the engine is either startup up or shutting down.
        //  In either case, we'll bail out.
        //
        if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteQueueRequestsWithError [NotStarted] -> %08lx %08lx\n",
            pUMRxEngine, PsGetCurrentThread());
        goto Exit;
    }

    //
    //  Now let's check the current engine state.
    //
    QueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                    UMRX_ENGINE_STATE_STARTED,
                                    UMRX_ENGINE_STATE_STARTED);
    if (UMRX_ENGINE_STATE_STARTED != QueueState)
    {
        //
        //  Must be stopped, so we'll bail out.
        //
        ASSERT(UMRX_ENGINE_STATE_STOPPED == QueueState);
        if (DfsDbgVerbose) DbgPrint(
            "UMRxCompleteQueueRequestsWithError [NotStarted2] -> %08lx %08lx\n",
            pUMRxEngine, PsGetCurrentThread());
        goto Exit;
    }
    
    


Exit:    
    if (fLockAcquired)
        ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,ExGetCurrentResourceThread());
        
    return STATUS_SUCCESS;
}



NTSTATUS
UMRxEngineReleaseThreads(
    IN PUMRX_ENGINE pUMRxEngine
    )
/*++

Routine Description:

    This is called in response to a WORK_CLEANUP IOCTL.
    This routine will insert a dummy item in the engine KQUEUE.
    Each such dummy item inserted will release one thread.
   
Arguments:

    PUMRX_ENGINE pUMRxEngine    -   Engine to release threads on

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    BUGBUG: This should be serialized !

--*/
{
    ULONG PreviousQueueState = 0;

    DfsTraceEnter("UMRxEngineReleaseThreads");
    if (DfsDbgVerbose) DbgPrint("UMRxEngineReleaseThreads [Start] -> %08lx\n", pUMRxEngine);

    //
    //  First change the state so that nobody will try to get in.
    //
    PreviousQueueState = InterlockedCompareExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STOPPING,
                                            UMRX_ENGINE_STATE_STARTED);

    if (UMRX_ENGINE_STATE_STARTED != PreviousQueueState)
    {
        if (DfsDbgVerbose) DbgPrint("UMRxEngineReleaseThreads unexpected previous queue state: 0x%08x => %d\n",
                             pUMRxEngine, PreviousQueueState);
        CHECK_STATUS(STATUS_UNSUCCESSFUL) ;
        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Now, get any threads that are queued up to vacate.
    //
    KeInsertQueue(&pUMRxEngine->Q.Queue,
                  &pUMRxEngine->Q.PoisonEntry);

    //
    //  We won't be granted exclusive until all the threads queued have vacated.
    //
    ExAcquireResourceExclusiveLite(&pUMRxEngine->Q.Lock,
                                    TRUE);
    
    //
    //  Now, that we know there aren't any threads in here, we can change
    //    the state to STOPPED;
    //
    PreviousQueueState = InterlockedExchange(&pUMRxEngine->Q.State,
                                            UMRX_ENGINE_STATE_STOPPED);

    ASSERT(UMRX_ENGINE_STATE_STOPPING == PreviousQueueState);

    //
    // Now, relinquish the lock
    //
    ExReleaseResourceForThreadLite(&pUMRxEngine->Q.Lock,
                                    ExGetCurrentResourceThread());
    
    if (DfsDbgVerbose) DbgPrint("UMRxReleaseCapturedThreads %08lx [exit] -> %08lx\n", pUMRxEngine);
    DfsTraceLeave(0);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\rxcontx.c ===
//+----------------------------------------------------------------------------//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       rxcontx.c
//
//  Contents:   Contains functions for allocating contexts and Cancel Routines
//
//
//  Functions:  
//
//  Author - Rohan Phillips     (Rohanp)
//-----------------------------------------------------------------------------
#include "ntifs.h"
#include <rxcontx.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxInitializeContext)
#pragma alloc_text(PAGE, DfsInitializeContextResources)
#pragma alloc_text(PAGE, DfsDeInitializeContextResources)
#endif

#define RX_IRPC_POOLTAG         ('rsfd')

KSPIN_LOCK  RxStrucSupSpinLock = {0};
LIST_ENTRY  RxActiveContexts;
ULONG NumberOfActiveContexts = 0;
NPAGED_LOOKASIDE_LIST RxContextLookasideList;


//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeContextResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Initializes all resources needed for allocating contexts
//
//--------------------------------------------------------------------------
NTSTATUS DfsInitializeContextResources(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    KeInitializeSpinLock( &RxStrucSupSpinLock );

    // Initialize the look aside list for RxContext allocation
    ExInitializeNPagedLookasideList(
                                    &RxContextLookasideList,
                                    ExAllocatePoolWithTag,
                                    ExFreePool,
                                    0,
                                    sizeof(RX_CONTEXT),
                                    RX_IRPC_POOLTAG,
                                    32);
    
    InitializeListHead(&RxActiveContexts);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDeInitializeContextResources 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: DeInitializes all resources needed for allocating contexts
//
//--------------------------------------------------------------------------
NTSTATUS DfsDeInitializeContextResources(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ExDeleteNPagedLookasideList(&RxContextLookasideList);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RxInitializeContext 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: initializes a context
//
//--------------------------------------------------------------------------
VOID
RxInitializeContext(
    IN PIRP            Irp,
    IN OUT PRX_CONTEXT RxContext)
{
    PAGED_CODE();

    RxContext->ReferenceCount = 1;

    // Initialize the Sync Event.
    KeInitializeEvent(
        &RxContext->SyncEvent,
        SynchronizationEvent,
        FALSE);

    if(Irp)
    {
        if (!IoIsOperationSynchronous(Irp)) 
        {
            SetFlag( RxContext->Flags, DFS_CONTEXT_FLAG_ASYNC_OPERATION );
        } 
    }
    
    //  Set the Irp fields.
    RxContext->CurrentIrp   = Irp;
    RxContext->OriginalThread = RxContext->LastExecutionThread = PsGetCurrentThread();

}


//+-------------------------------------------------------------------------
//
//  Function:   RxCreateRxContext 
//
//  Arguments:  
//
//  Returns:    Pointer to context information
//
//
//  Description: allocates a context
//
//--------------------------------------------------------------------------
PRX_CONTEXT
RxCreateRxContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    )
{
    PRX_CONTEXT        RxContext = NULL;
    ULONG              RxContextFlags = 0;
    KIRQL              SavedIrql;

    RxContext = ExAllocateFromNPagedLookasideList(
                            &RxContextLookasideList);
    if(RxContext == NULL)
    {
        return(NULL);
    }

    InterlockedIncrement(&NumberOfActiveContexts);

    RtlZeroMemory( RxContext, sizeof(RX_CONTEXT) );

    RxContext->Flags = RxContextFlags;

    RxInitializeContext(Irp,RxContext);

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    InsertTailList(&RxActiveContexts,&RxContext->ContextListEntry);

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    return RxContext;
}


//+-------------------------------------------------------------------------
//
//  Function:   RxDereferenceAndDeleteRxContext_Real 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: Deallocates a context
//
//--------------------------------------------------------------------------
VOID
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    )
{
    PRX_CONTEXT          pStopContext = NULL;
    LONG                 FinalRefCount = 0;
    KIRQL                SavedIrql;

    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );
    
    FinalRefCount = InterlockedDecrement(&RxContext->ReferenceCount);

    if (FinalRefCount == 0) 
    {
       RemoveEntryList(&RxContext->ContextListEntry);

       InterlockedDecrement(&NumberOfActiveContexts);

       RtlZeroMemory( RxContext, sizeof(RX_CONTEXT) );

       ExFreeToNPagedLookasideList(
                                    &RxContextLookasideList,
                                    RxContext );
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );
}


//+-------------------------------------------------------------------------
//
//  Function:   RxSetMinirdrCancelRoutine 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: Sets up a cancel routine
//
//--------------------------------------------------------------------------
NTSTATUS
RxSetMinirdrCancelRoutine(
    IN  OUT PRX_CONTEXT   RxContext,
    IN      DFS_CALLDOWN_ROUTINE DfsCancelRoutine)
{
   NTSTATUS Status = STATUS_SUCCESS;
   KIRQL   SavedIrql;

   KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

   if (!FlagOn(RxContext->Flags, DFS_CONTEXT_FLAG_CANCELLED)) 
   {
      RxContext->CancelRoutine = DfsCancelRoutine;
      Status = STATUS_SUCCESS;
   } 
   else 
   {
      Status = STATUS_CANCELLED;
   }

   KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

   return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RxCancelRoutine 
//
//  Arguments:  
//
//  Returns:    
//
//
//  Description: The main cancel routine
//
//--------------------------------------------------------------------------
VOID
RxCancelRoutine(
      PDEVICE_OBJECT    pDeviceObject,
      PIRP              pIrp)
{
    PRX_CONTEXT   pRxContext = NULL;
    PLIST_ENTRY   pListEntry = NULL;
    DFS_CALLDOWN_ROUTINE DfsCancelRoutine = NULL;
    KIRQL         SavedIrql;

    // Locate the context corresponding to the given Irp.
    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    pListEntry = RxActiveContexts.Flink;

    while (pListEntry != &RxActiveContexts) 
    {
        pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);

        if (pRxContext->CurrentIrp == pIrp) 
        {
            break;
        } 
        else 
        {
            pListEntry = pListEntry->Flink;
        }
    }

    if (pListEntry != &RxActiveContexts) 
    {
        SetFlag( pRxContext->Flags, DFS_CONTEXT_FLAG_CANCELLED );
        DfsCancelRoutine = pRxContext->CancelRoutine;
        pRxContext->CancelRoutine = NULL;
        InterlockedIncrement(&pRxContext->ReferenceCount);
    } 
    else 
    {
        pRxContext       = NULL;
        DfsCancelRoutine = NULL;
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (pRxContext != NULL) 
    {
        if (DfsCancelRoutine != NULL) 
        {
            (DfsCancelRoutine)(pRxContext);
        }

        RxDereferenceAndDeleteRxContext(pRxContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\reflector\kernel\klogmacros.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       kLogMacros.h
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    Marc 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------

#include "dfswmi.h"

extern PVOID pkUmrControl;

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) (((WPP_CB_TYPE *)pkUmrControl)->Control.Logger),
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
  (pkUmrControl && (((WPP_CB_TYPE *)pkUmrControl)->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)) && \
  ( ((WPP_CB_TYPE *)pkUmrControl)->Control.Level >= lvl))
 
#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) (((WPP_CB_TYPE *)pkUmrControl)->Control.Logger),
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((pkUmrControl && (!NT_SUCCESS(error) || ((( WPP_CB_TYPE *)pkUmrControl)->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)))) && \
  (((WPP_CB_TYPE *)pkUmrControl)->Control.Level >= lvl))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsfastio.c ===
#include "ntifs.h"
#include "DfsInit.h"

#define _NTDDK_
#include "stdarg.h"
#include "wmikm.h"
#include <wmistr.h>
#include <evntrace.h>

#include <wmiumkm.h>
#include "dfswmi.h" 
#define WPP_BIT_CLI_DRV 0x01

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)  

#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((!NT_SUCCESS(error) || WPP_LEVEL_ENABLED(flags)) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)

#include "DfsFastIo.tmh"

//
//  Macro to test if FAST_IO_DISPATCH handling routine is valid
//

#define VALID_FAST_IO_DISPATCH_HANDLER(_FastIoDispatchPtr, _FieldName) \
    (((_FastIoDispatchPtr) != NULL) && \
     (((_FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
            (FIELD_OFFSET(FAST_IO_DISPATCH, _FieldName) + sizeof(void *))) && \
     ((_FastIoDispatchPtr)->_FieldName != NULL))

BOOLEAN
DfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

VOID
DfsFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice );

BOOLEAN
DfsFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject );

BOOLEAN
DfsFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject);





FAST_IO_DISPATCH DfsFastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),
    DfsFastIoCheckIfPossible,           //  CheckForFastIo
    DfsFastIoRead,                      //  FastIoRead
    DfsFastIoWrite,                     //  FastIoWrite
    DfsFastIoQueryBasicInfo,            //  FastIoQueryBasicInfo
    DfsFastIoQueryStandardInfo,         //  FastIoQueryStandardInfo
    DfsFastIoLock,                      //  FastIoLock
    DfsFastIoUnlockSingle,              //  FastIoUnlockSingle
    DfsFastIoUnlockAll,                 //  FastIoUnlockAll
    DfsFastIoUnlockAllByKey,            //  FastIoUnlockAllByKey
    DfsFastIoDeviceControl,             //  FastIoDeviceControl
    NULL,                               //  AcquireFileForNtCreateSection
    NULL,                               //  ReleaseFileForNtCreateSection
    DfsFastIoDetachDevice,              //  FastIoDetachDevice
    DfsFastIoQueryNetworkOpenInfo,      //  FastIoQueryNetworkOpenInfo
    NULL,                               //  AcquireForModWrite
    DfsFastIoMdlRead,                   //  MdlRead
    DfsFastIoMdlReadComplete,           //  MdlReadComplete
    DfsFastIoPrepareMdlWrite,           //  PrepareMdlWrite
    DfsFastIoMdlWriteComplete,          //  MdlWriteComplete
    DfsFastIoReadCompressed,            //  FastIoReadCompressed
    DfsFastIoWriteCompressed,           //  FastIoWriteCompressed
    DfsFastIoMdlReadCompleteCompressed, //  MdlReadCompleteCompressed
    DfsFastIoMdlWriteCompleteCompressed, //  MdlWriteCompleteCompressed
    DfsFastIoQueryOpen,                 //  FastIoQueryOpen
    NULL,                               //  ReleaseForModWrite
    NULL,                               //  AcquireForCcFlush
    NULL,                               //  ReleaseForCcFlush
};


extern
NTSTATUS
DfsHandlePrivateFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PIRP Irp );

/////////////////////////////////////////////////////////////////////////////
//
//                      FastIO Handling routines
//
/////////////////////////////////////////////////////////////////////////////


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    VALIDATE_IRQL(Irp);


    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            return (fastIoDispatch->FastIoCheckIfPossible)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        CheckForReadOperation,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            return (fastIoDispatch->FastIoRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            return (fastIoDispatch->FastIoWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            return (fastIoDispatch->FastIoQueryBasicInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            return (fastIoDispatch->FastIoQueryStandardInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            return (fastIoDispatch->FastIoLock)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            return (fastIoDispatch->FastIoUnlockSingle)(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;

        if (nextDeviceObject) {

            fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

                return (fastIoDispatch->FastIoUnlockAll)(
                            FileObject,
                            ProcessId,
                            IoStatus,
                            nextDeviceObject );
            }
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            return (fastIoDispatch->FastIoUnlockAllByKey)(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}



/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O control
    operations on a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE PreviousMode;
    BOOLEAN fPossible = FALSE;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);


    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) 
    {
        PreviousMode = ExGetPreviousMode();
        if (PreviousMode == KernelMode) {
            DfsHandlePrivateFsControl (DeviceObject,
                                       IoControlCode,
                                       InputBuffer,
                                       InputBufferLength,
                                       OutputBuffer,
                                       OutputBufferLength,
                                       IoStatus,
                                       NULL);
            fPossible = TRUE;
        }
        else
        {
            fPossible = FALSE;
        }
    }
    else if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) 
        {

            fPossible = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                               Wait,
                                                               InputBuffer,
                                                               InputBufferLength,
                                                               OutputBuffer,
                                                               OutputBufferLength,
                                                               IoControlCode,
                                                               IoStatus,
                                                               nextDeviceObject );
        }
    }
    return fPossible;
}

/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to my device object, which is attached
        to the file system's volume device object.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None

--*/

VOID
DfsFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice )
{

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    ASSERT(IS_MY_DEVICE_OBJECT( SourceDevice ));

    DFS_TRACE_LOW(KUMR_DETAIL, "FastIoDetachDevice....%p, %p\n",
                  SourceDevice, TargetDevice);

    //
    //  Display name information
    //
    //
    //  Detach from the file system's volume device object.
    //

    DfsDetachFilterDevice(SourceDevice, TargetDevice);
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            return (fastIoDispatch->FastIoQueryNetworkOpenInfo)(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            return (fastIoDispatch->MdlRead)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying file system, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

BOOLEAN
DfsFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            return (fastIoDispatch->MdlReadComplete)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            return (fastIoDispatch->PrepareMdlWrite)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/


BOOLEAN
DfsFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            return (fastIoDispatch->MdlWriteComplete)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*********************************************************************************
        UNIMPLEMENTED FAST IO ROUTINES
        
        The following four Fast IO routines are for compression on the wire
        which is not yet implemented in NT.  
        
        NOTE:  It is highly recommended that you include these routines (which
               do a pass-through call) so your filter will not need to be
               modified in the future when this functionality is implemented in
               the OS.
        
        FastIoReadCompressed, FastIoWriteCompressed, 
        FastIoMdlReadCompleteCompressed, FastIoMdlWriteCompleteCompressed
**********************************************************************************/


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading compressed
    data from a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the compressed
        data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/

BOOLEAN
DfsFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            return (fastIoDispatch->FastIoReadCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing compressed
    data to a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/


BOOLEAN
DfsFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            return (fastIoDispatch->FastIoWriteCompressed)(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/


BOOLEAN
DfsFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            return (fastIoDispatch->MdlReadCompleteCompressed)(
                        FileObject,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}


/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the file system's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE, depending on whether or not it is
    possible to invoke this function on the fast I/O path.

--*/

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)

{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            return (fastIoDispatch->MdlWriteCompleteCompressed)(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        nextDeviceObject );
        }
    }
    return FALSE;
}

/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information for it.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to this driver's device object, the device on
        which the operation is to occur.

Return Value:

    The function value is TRUE or FALSE based on whether or not fast I/O
    is possible for this file.

--*/
BOOLEAN
DfsFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject)
{
    PDEVICE_OBJECT nextDeviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    if (DeviceObject->DeviceExtension) {

        ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

        //
        //  Pass through logic for this type of Fast I/O
        //

        nextDeviceObject = ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject;
        ASSERT(nextDeviceObject);

        fastIoDispatch = nextDeviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = nextDeviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)(
                        Irp,
                        NetworkInformation,
                        nextDeviceObject );

            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
            return result;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsumrrequests.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    DfsUmrRequests.h

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/

#ifndef _DFSREQUESTS_H_
#define _DFSREQUESTS_H_


NTSTATUS 
DfsGetReplicaInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


NTSTATUS
DfsFsctrlGetReferrals(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    PIRP Irp,
    IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


NTSTATUS 
DfsIsADfsLinkInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock);

NTSTATUS 
DfsCheckIsPathLocal(PUNICODE_STRING DfsPath);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadblobcache.cxx ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsADBlobCache.cxx
//
//  Contents:   the ADBlob DFS Store class, this contains the 
//              old AD blob store specific functionality. 
//
//  Classes:    DfsADBlobCache.
//
//  History:    Dec. 8 2000,   Author: udayh
//              April 9 2001  Rohanp - Added  AD specific code.
//
//-----------------------------------------------------------------------------
  
#include <DfsAdBlobCache.hxx>
#include <dfsrootfolder.hxx>
#include <dfserror.hxx>
#include "dfsadsiapi.hxx"
#include <sddl.h>
#include <dfssecurity.h>
#include <ntdsapi.h>
#include "dfsAdBlobCache.tmh"


DfsADBlobCache::DfsADBlobCache(
    DFSSTATUS *pStatus, 
    PUNICODE_STRING pShareName,
    DfsRootFolder * pRootFolder) :  DfsGeneric(DFS_OBJECT_TYPE_ADBLOB_CACHE)
{
    SHASH_FUNCTABLE FunctionTable;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    
    *pStatus = ERROR_SUCCESS;

    do {
        m_pBlob = NULL;
        m_pRootBlob = NULL;
        m_pTable = NULL;

        m_pAdHandle = NULL;
        m_AdReferenceCount = 0;
        m_RefreshCount = 0;
        m_ErrorOccured = DFS_DS_NOERROR;

        m_pRootFolder = pRootFolder;

        RtlInitUnicodeString(&m_LogicalShare, NULL);
        RtlInitUnicodeString(&m_ObjectDN, NULL);

        ZeroMemory(&FunctionTable, sizeof(FunctionTable));
        
        FunctionTable.AllocFunc = AllocateShashData;
        FunctionTable.FreeFunc = DeallocateShashData;

        ZeroMemory(&m_BlobAttributePktGuid, sizeof(GUID));
        
        m_fCritInit = InitializeCriticalSectionAndSpinCount( &m_Lock, DFS_CRIT_SPIN_COUNT);
        if(!m_fCritInit)
        {
            Status = GetLastError();
            break;
        }
        
        Status = DfsCreateUnicodeString(&m_LogicalShare, pShareName);

        if (Status != ERROR_SUCCESS)
        {
            break;
        }   

        Status = SetupObjectDN();

        if(Status != ERROR_SUCCESS)
        {
            if(DfsServerGlobalData.bDfsAdAlive)
            {
                DfsServerGlobalData.bDfsAdAlive = FALSE;
                DfsLogDfsEvent(DFS_ERROR_ACTIVEDIRECTORY_OFFLINE, 0, NULL, 0); 
            }
            break;
        }
        
        
        if(DfsServerGlobalData.bDfsAdAlive == FALSE)
        {
            DfsServerGlobalData.bDfsAdAlive = TRUE;
            DfsLogDfsEvent(DFS_INFO_ACTIVEDIRECTORY_ONLINE, 0, NULL, 0); 
        }

        NtStatus = ShashInitHashTable(&m_pTable, &FunctionTable);
        if (NtStatus != STATUS_SUCCESS)
        {
            Status = RtlNtStatusToDosError(NtStatus);
            break;
        }
        
    } while (FALSE);

    *pStatus = Status;
    
    return;
}


DfsADBlobCache::~DfsADBlobCache() 
{

    if(m_pBlob)
    {
        DeallocateShashData(m_pBlob);
        m_pBlob = NULL;
    }
    if(m_pRootBlob)
    {
        DeallocateShashData(m_pRootBlob);
        m_pRootBlob = NULL;
    }

    if (m_pTable != NULL)
    {
        InvalidateCache();
        ShashTerminateHashTable(m_pTable);
        m_pTable = NULL;
    }

    if (m_LogicalShare.Buffer != NULL)
    {
        delete [] m_LogicalShare.Buffer;
        m_LogicalShare.Buffer = NULL;
    }
    if (m_ObjectDN.Buffer != NULL)
    {
        delete [] m_ObjectDN.Buffer;
        m_ObjectDN.Buffer = NULL;
    }

    if(m_fCritInit)
    {
        DeleteCriticalSection(&m_Lock);
        m_fCritInit = FALSE;
    }

}    





#ifndef DFS_USE_LDAP


DFSSTATUS
DfsADBlobCache::UpdateCacheWithDSBlob(
    PVOID pHandle )
{
    HRESULT hr = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    VARIANT BinaryBlob;

    IADs *pADs  = (IADs *)pHandle;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: updating cache with blob \n", this);
    VariantInit(&BinaryBlob);

    hr = pADs->Get(ADBlobAttribute, &BinaryBlob);
    if ( SUCCEEDED(hr) )
    {
        Status = GetBinaryFromVariant( &BinaryBlob, &pBuffer, &Length );
        if (Status == ERROR_SUCCESS)
        {
            Status = UnpackBlob( pBuffer, &Length, NULL );

            DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Unpack blob done with status %x\n", Status);
            
            delete [] pBuffer;
        }
    }
    else
    {
        Status = DfsGetErrorFromHr(hr);
    }
    VariantClear(&BinaryBlob);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: Updated cache (length %x) status %x\n", 
                         this, Length, Status);

    return Status;
}

DFSSTATUS
DfsADBlobCache::GetObjectPktGuid( 
    PVOID pHandle,
    GUID *pGuid )
{
    HRESULT hr = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    VARIANT BinaryBlob;

    IADs *pADs = (IADs *)pHandle;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: getting pkt guid\n", this);

    VariantInit(&BinaryBlob);

    hr = pADs->Get(ADBlobPktGuidAttribute, &BinaryBlob);
    if ( SUCCEEDED(hr) )
    {
        Status = GetBinaryFromVariant( &BinaryBlob, &pBuffer, &Length );
        if (Status == ERROR_SUCCESS)
        {
            if (Length > sizeof(GUID)) Length = sizeof(GUID);

            RtlCopyMemory( pGuid, pBuffer, Length);
            
            delete [] pBuffer;
        }
    }
    VariantClear(&BinaryBlob);

    Status = DfsGetErrorFromHr(hr);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: got pkt guid, Status %x\n", 
                         this, Status );


    return Status;
}


DFSSTATUS 
DfsADBlobCache::UpdateDSBlobFromCache(
    PVOID pHandle,
    GUID *pGuid )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length;
    ULONG UseLength;
    ULONG TotalBlobBytes = 0;
    VARIANT BinaryBlob;
    IADs *pObject = (IADs *)pHandle;

    VariantInit(&BinaryBlob);

    DFS_TRACE_LOW( ADBLOB, "Cache %p: updating ds with cache \n", this);

    UseLength = ADBlobDefaultBlobPackSize;
retry:
    Length = UseLength;
    pBuffer =  (BYTE *) HeapAlloc(GetProcessHeap(), 0, 
                                  Length );
    if(pBuffer != NULL)
    {
        Status = PackBlob(pBuffer, &Length, &TotalBlobBytes); 
        if(Status == STATUS_SUCCESS)
        {
            Status = PutBinaryIntoVariant(&BinaryBlob, pBuffer, TotalBlobBytes);
            if(Status == STATUS_SUCCESS)
            {
                HResult = pObject->Put(ADBlobAttribute, BinaryBlob);
                if (SUCCEEDED(HResult) )
                {
                    HResult = pObject->SetInfo();
                }

                Status = DfsGetErrorFromHr(HResult);

                if (Status == ERROR_SUCCESS)
                {
                    Status = SetObjectPktGuid( pObject, pGuid );
                }
            }
        }
        DFS_TRACE_ERROR_LOW(Status, ADBLOB, "Cache %p: update ds (Buffer Len %x, Length %x) Status %x\n",
                            this, UseLength, Length, Status);

        HeapFree(GetProcessHeap(), 0, pBuffer);

        if (Status == ERROR_BUFFER_OVERFLOW)
        {
            if (UseLength < ADBlobMaximumBlobPackSize)
            {
                UseLength *= 2;
            }
            //
            // If we are still within the maximum bounds, retry.
            //
            if (UseLength <= ADBlobMaximumBlobPackSize)
            {
                goto retry;
            }
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    VariantClear(&BinaryBlob);
    DFS_TRACE_ERROR_LOW(Status, ADBLOB, "Cache %p: update ds done (Buffer Length %x, Length %x) Status %x\n",
                        this, UseLength, Length, Status);

    return Status;
}


DFSSTATUS
DfsADBlobCache::SetObjectPktGuid( 
    IADs *pObject,
    GUID *pGuid )
{
    HRESULT HResult = S_OK;
    DFSSTATUS Status = ERROR_SUCCESS;
    VARIANT BinaryBlob;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: setting pkt guid\n", this);
    VariantInit(&BinaryBlob);

    Status = PutBinaryIntoVariant( &BinaryBlob, (PBYTE)pGuid, sizeof(GUID));
    if (Status == ERROR_SUCCESS)
    {
        HResult = pObject->Put(ADBlobPktGuidAttribute, BinaryBlob);
        if (SUCCEEDED(HResult) )
        {
            HResult = pObject->SetInfo();
        }

        Status = DfsGetErrorFromHr(HResult);
    }

    VariantClear(&BinaryBlob);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: set pkt guid, Status %x\n", 
                         this, Status );


    return Status;
}

#else


DFSSTATUS
DfsADBlobCache::DfsLdapConnect(
    LPWSTR DCName,
    LDAP **ppLdap )
{
    LDAP *pLdap = NULL;
    LPWSTR ActualDC = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LocalStatus = ERROR_SUCCESS;
    LONG PreviousState = DFS_DS_ACTIVE;
    const TCHAR * apszSubStrings[4];

    apszSubStrings[0] = DCName;
    ActualDC = DCName;

    pLdap = ldap_initW(DCName, LDAP_PORT);
    if (pLdap != NULL)
    {
        Status = ldap_set_option(pLdap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

        if (Status == LDAP_SUCCESS)
        {
            UNICODE_STRING DnsDomain;
            if (DfsGetDnsDomainName( &DnsDomain) == ERROR_SUCCESS)
            {
                Status = ldap_set_option(pLdap, LDAP_OPT_DNSDOMAIN_NAME, &DnsDomain.Buffer);

                DfsReleaseDomainName(&DnsDomain);
            }
        }
        if (Status == LDAP_SUCCESS)
        {

            DFS_TRACE_LOW(ADBLOB, 
                          "Ldap Connect, calling LDAP Bind DC: %ws, init ldap status %x\n",
                           DCName, Status);

            Status = ldap_bind_s(pLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE);


            DFS_TRACE_LOW(ADBLOB, 
                          "Ldap Connect, returning from LDAP Bind DC: %ws, init ldap status %x\n",
                          DCName, Status);
        }
    }
    else
    {
        Status = LdapGetLastError();
        DFS_TRACE_ERROR_HIGH(Status, ADBLOB, 
                             "Ldap Connect, DC: %ws, init ldap status %x\n",
                             DCName, Status);
    }

    if (Status == LDAP_SUCCESS)
    {
        *ppLdap = pLdap;

        if(DCName == NULL)
        {

            //Get the actual host name that we connected to. We don't have to free
            //this name since it will get freed when ldap_unbind is called.
            LocalStatus = ldap_get_optionW(pLdap, LDAP_OPT_HOST_NAME , (void *) &ActualDC);
            apszSubStrings[0] = ActualDC;
        }

        DFS_TRACE_HIGH(ADBLOB, "ADBLOBConnected to actual DC: %ws, ldap status %x\n",
                       ActualDC, Status);

        PreviousState = InterlockedCompareExchange(&DfsServerGlobalData.FirstContact, DFS_DS_ACTIVE, DFS_DS_NOTACTIVE); 
        if(PreviousState == DFS_DS_NOTACTIVE)
        {
            DfsLogDfsEvent(DFS_INFO_DS_RECONNECTED, 1, apszSubStrings, Status);
        }
    }
    else
    {
        PreviousState = InterlockedCompareExchange(&DfsServerGlobalData.FirstContact, DFS_DS_NOTACTIVE, DFS_DS_ACTIVE); 
        if(PreviousState == DFS_DS_ACTIVE)
        {
            DfsLogDfsEvent(DFS_ERROR_DSCONNECT_FAILED, 1, apszSubStrings, Status); 
        }

        DFS_TRACE_ERROR_HIGH(Status, ADBLOB, 
                             "Ldap Connect, DC: %ws, ldap status %x\n",
                             DCName, Status);

        Status = LdapMapErrorToWin32(Status);
    }


    if (Status != ERROR_SUCCESS) 
    {
        if (pLdap != NULL)
        {
            //
            // 565302
            // we need to call ldap_unbind if we have a valid connection!
            // Note that this is true even if ldap_bind failed or we never
            // even called ldap_bind.
            //
            ldap_unbind(pLdap);
        }
    }

    return Status;

}



VOID
DfsADBlobCache::DfsLdapDisconnect(
    LDAP *pLdap )
{
    ldap_unbind(pLdap);
}


DFSSTATUS
DfsADBlobCache::DfsGetPktBlob(
    LDAP *pLdap,
    LPWSTR ObjectDN,
    PVOID *ppBlob,
    PULONG pBlobSize,
    PVOID *ppHandle,
    PVOID *ppHandle1 )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LdapStatus = ERROR_SUCCESS;
    PLDAPMessage pLdapSearchedObject = NULL;
    PLDAPMessage pLdapObject = NULL;
    PLDAP_BERVAL *pLdapPktAttr = NULL;
    LPWSTR Attributes[2];
    struct l_timeval Timeout;



    Status = ERROR_ACCESS_DENIED;     // fix this after we understand
                                      // ldap error correctly. When
                                      // ldap_get_values_len returns NULL
                                      // the old code return no more mem.

    Attributes[0] = ADBlobAttribute;
    Attributes[1] = NULL;

    Timeout.tv_sec = DfsServerGlobalData.LdapTimeOut;


    DFS_TRACE_LOW(ADBLOB, 
                 "DfsGetPktBlob, calling LDAP Search ObjectDN: %ws, init ldap status %x\n",
                  ObjectDN, Status);
    LdapStatus = ldap_search_ext_sW( pLdap,
                                     ObjectDN,
                                     LDAP_SCOPE_BASE,
                                     L"(objectClass=*)",
                                     Attributes,
                                     0,            // attributes only
                                     NULL,         // server controls
                                     NULL,         // client controls
                                     &Timeout,
                                     0,            // size limit
                                     &pLdapSearchedObject);

    DFS_TRACE_LOW(ADBLOB, 
                 "DfsGetPktBlob, returning from LDAP Search ObjectDN: %ws, init ldap status %x\n",
                  ObjectDN, Status);
    if (LdapStatus == LDAP_SUCCESS)
    {
        pLdapObject = ldap_first_entry( pLdap,
                                        pLdapSearchedObject );

        if (pLdapObject != NULL)
        {
            pLdapPktAttr = ldap_get_values_len( pLdap,
                                                pLdapObject,
                                                Attributes[0] );
            if (pLdapPktAttr != NULL)
            {
                *ppBlob = pLdapPktAttr[0]->bv_val;
                *pBlobSize = pLdapPktAttr[0]->bv_len;

                *ppHandle = (PVOID)pLdapPktAttr;
                *ppHandle1 = (PVOID)pLdapSearchedObject;
                pLdapSearchedObject = NULL;

                Status = ERROR_SUCCESS;
            }
            else
            {
                if(pLdap->ld_errno == LDAP_NO_SUCH_ATTRIBUTE)
                {
                    Status = ERROR_ACCESS_DENIED;
                }
                else
                {
                    Status = LdapMapErrorToWin32( pLdap->ld_errno );
                }


                DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::DfsGetPktBlob1 (ldap error %x) status %x\n", 
                                      pLdap->ld_errno, Status);
            }
        }
    }
    else
    {
        Status = LdapMapErrorToWin32(LdapStatus);

        DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::DfsGetPktBlob2 (ldap error %x) status %x\n", 
                              LdapStatus, Status);
    }

    if (pLdapSearchedObject != NULL)
    {
        ldap_msgfree( pLdapSearchedObject );
    }

    return Status;
}

VOID
DfsADBlobCache::DfsReleasePktBlob(
    PVOID pHandle,
    PVOID pHandle1 )
{
    PLDAP_BERVAL *pLdapPktAttr = (PLDAP_BERVAL *)pHandle;
    PLDAPMessage pLdapSearchedObject = (PLDAPMessage)pHandle1;

    ldap_value_free_len( pLdapPktAttr );
    ldap_msgfree( pLdapSearchedObject );
}


DFSSTATUS
DfsADBlobCache::UpdateCacheWithDSBlob(
    PVOID pHandle )

{
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    PVOID pHandle1, pHandle2;

    LDAP *pLdap = (LDAP *)pHandle;
    UNICODE_STRING ObjectDN;

    
    DFS_TRACE_LOW( ADBLOB, "Cache %p: updating cache with blob \n", this);

    Status = GetObjectDN(&ObjectDN);

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetPktBlob( pLdap,
                                ObjectDN.Buffer,
                                (PVOID *)&pBuffer,
                                &Length,
                                &pHandle1,
                                &pHandle2);
    }

    if ( Status == ERROR_SUCCESS)
    {
        Status = UnpackBlob( pBuffer, &Length, NULL );

        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Unpack blob done with status %x\n", Status);

        DfsReleasePktBlob( pHandle1, pHandle2);
    }

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "cache %p: Updated cache (length %x) status %x\n", 
                         this, Length, Status);

    return Status;
}




DFSSTATUS
DfsADBlobCache::GetObjectPktGuid(
    PVOID pHandle,
    GUID *pGuid )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LdapStatus = ERROR_SUCCESS;
    PLDAPMessage pLdapSearchedObject = NULL;
    PLDAPMessage pLdapObject = NULL;
    PLDAP_BERVAL *pLdapGuidAttr = NULL;
    ULONG CopySize = 0;    
    LDAP *pLdap = (LDAP *)pHandle;
    UNICODE_STRING ObjectDN;
    struct l_timeval Timeout;
    LPWSTR Attributes[2];

    Status = GetObjectDN(&ObjectDN);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = ERROR_ACCESS_DENIED;     // fix this after we understand
                                      // ldap error correctly. When
                                      // ldap_get_values_len returns NULL
                                      // the old code return no more mem.


    Attributes[0] = ADBlobPktGuidAttribute;
    Attributes[1] = NULL;

    Timeout.tv_sec = DfsServerGlobalData.LdapTimeOut;



    DFS_TRACE_LOW(ADBLOB, 
                 "DfsGetPktGuid, calling LDAP Search - ldap status %x\n",
                  Status);
    LdapStatus = ldap_search_ext_sW( pLdap,
                                     ObjectDN.Buffer,
                                     LDAP_SCOPE_BASE,
                                     L"(objectClass=*)",
                                     Attributes,
                                     0,            // attributes only
                                     NULL,         // server controls
                                     NULL,         // client controls
                                     &Timeout,
                                     0,            // size limit
                                     &pLdapSearchedObject);

    DFS_TRACE_LOW(ADBLOB, 
                 "DfsGetPktGuid, returning from LDAP Search - ldap status %x\n",
                  Status);

    if (LdapStatus == LDAP_SUCCESS)
    {
        pLdapObject = ldap_first_entry( pLdap,
                                        pLdapSearchedObject );

        if (pLdapObject != NULL)
        {
            pLdapGuidAttr = ldap_get_values_len( pLdap,
                                                 pLdapObject,
                                                 Attributes[0] );
            if (pLdapGuidAttr != NULL)
            {
                CopySize = min( pLdapGuidAttr[0]->bv_len, sizeof(GUID));
                RtlCopyMemory( pGuid, pLdapGuidAttr[0]->bv_val, CopySize );

                ldap_value_free_len( pLdapGuidAttr );
                Status = ERROR_SUCCESS;
            }
            else
            {
                if(pLdap->ld_errno == LDAP_NO_SUCH_ATTRIBUTE)
                {
                    Status = ERROR_ACCESS_DENIED;
                }
                else
                {
                    Status = LdapMapErrorToWin32( pLdap->ld_errno );
                }


                DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::GetObjectPktGuid1 (ldap error %x) status %x\n", 
                                      LdapStatus, Status);
            }
        }
    }
    else
    {
        Status = LdapMapErrorToWin32(LdapStatus);

        DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::GetObjectPktGuid2 (ldap error %x) status %x\n", 
                              pLdap->ld_errno, Status);
    }

    if (pLdapSearchedObject != NULL)
    {
        ldap_msgfree( pLdapSearchedObject );
    }

    return Status;
}

DFSSTATUS
DfsADBlobCache::DfsSetPktBlobAndPktGuid ( 
    LDAP *pLdap,
    LPWSTR ObjectDN,
    PVOID pBlob,
    ULONG BlobSize,
    GUID *pGuid )
{
    LDAP_BERVAL  LdapPkt, LdapPktGuid;
    PLDAP_BERVAL  pLdapPktValues[2], pLdapPktGuidValues[2];
    LDAPModW LdapPktMod, LdapPktGuidMod;
    PLDAPModW pLdapDfsMod[3];
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LdapStatus;

    LDAPControlW    LazyCommitControl =
                    {
                        LDAP_SERVER_LAZY_COMMIT_OID_W,  // the control
                        { 0, NULL},                     // no associated data
                        FALSE                           // control isn't mandatory
                    };

    PLDAPControlW   ServerControls[2] =
                    {
                        &LazyCommitControl,
                        NULL
                    };


    LdapPkt.bv_len = BlobSize;
    LdapPkt.bv_val = (PCHAR)pBlob;
    pLdapPktValues[0] = &LdapPkt;
    pLdapPktValues[1] = NULL;
    LdapPktMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    LdapPktMod.mod_type = ADBlobAttribute;
    LdapPktMod.mod_vals.modv_bvals = pLdapPktValues;

    LdapPktGuid.bv_len = sizeof(GUID);
    LdapPktGuid.bv_val = (PCHAR)pGuid;
    pLdapPktGuidValues[0] = &LdapPktGuid;
    pLdapPktGuidValues[1] = NULL;
    LdapPktGuidMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    LdapPktGuidMod.mod_type = ADBlobPktGuidAttribute;
    LdapPktGuidMod.mod_vals.modv_bvals = pLdapPktGuidValues;

    pLdapDfsMod[0] = &LdapPktMod;
    pLdapDfsMod[1] = &LdapPktGuidMod;
    pLdapDfsMod[2] = NULL;


    DFS_TRACE_LOW(ADBLOB, 
                 "DfsSetPktBlobAndPktGuid, calling LDAP ldap_modify_ext_sW ObjectDN: %ws, init ldap status %x\n",
                  ObjectDN, Status);
    LdapStatus = ldap_modify_ext_sW( pLdap,
                                     ObjectDN,
                                     pLdapDfsMod,
                                     (PLDAPControlW *)ServerControls,
                                     NULL );

    DFS_TRACE_LOW(ADBLOB, 
                 "DfsSetPktBlobAndPktGuid, returning from LDAP ldap_modify_ext_sW ObjectDN: %ws, init ldap status %x\n",
                  ObjectDN, Status);

    if (LdapStatus != LDAP_SUCCESS)
    {
        Status = LdapMapErrorToWin32(LdapStatus);
    }



    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "DfsADBlobCache::DfsSetPktBlobAndPktGuid cache %p: LDAP Status %x, Win32 status %x\n", 
                         this, LdapStatus, Status);
    return Status;

}

DFSSTATUS 
DfsADBlobCache::UpdateDSBlobFromCache(
    PVOID pHandle,
    GUID *pGuid )
{
    LDAP *pLdap = (LDAP *)pHandle;
    UNICODE_STRING ObjectDN;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    ULONG UseLength = 0;
    ULONG TotalBlobBytes = 0;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = GetObjectDN(&ObjectDN);
    if (Status != ERROR_SUCCESS)
    {
        DFS_TRACE_ERROR_LOW( Status, ADBLOB, "DfsADBlobCache::UpdateDSBlobFromCache cache %p: GetObjectDN failed status %x\n", 
                             this, Status);
        return Status;
    }

    UseLength = ADBlobDefaultBlobPackSize;
retry:
    Length = UseLength;
    pBuffer =  (BYTE *) HeapAlloc(GetProcessHeap(), 0, Length );
    if(pBuffer != NULL)
    {
        Status = PackBlob(pBuffer, &Length, &TotalBlobBytes); 
        if (Status != ERROR_SUCCESS)
        {
            HeapFree(GetProcessHeap(), 0, pBuffer);

            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                if (UseLength < ADBlobMaximumBlobPackSize)
                {
                    UseLength *= 2;
                }
                goto retry;
            }
        }

        if(Status == STATUS_SUCCESS)
        {

            Status = DfsSetPktBlobAndPktGuid( pLdap,
                                              ObjectDN.Buffer,
                                              pBuffer,
                                              TotalBlobBytes,
                                              pGuid );
            DFS_TRACE_ERROR_LOW(Status, ADBLOB, "Cache %p: DfsADBlobCache::UpdateDSBlobFromCache (Buffer Len %x, Length %x) Status %x\n",
                                this, UseLength, Length, Status);


            HeapFree(GetProcessHeap(), 0, pBuffer);
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return Status;
}
#endif

DFSSTATUS
DfsADBlobCache::CacheRefresh(BOOLEAN fForceSync,
                             BOOLEAN fFromPDC)

{
    PVOID           pHandle = NULL;
    DFSSTATUS       Status = ERROR_SUCCESS;
    LONG            PreviousState = DFS_DS_NOERROR;
    LONG            RefreshCount = 0;
    PUNICODE_STRING pUseShare = NULL;
    GUID            CurrentGuid;
    const TCHAR * apszSubStrings[4];

    LPWSTR UseDC = NULL;
    DfsString *pPDC = NULL;
    DFSSTATUS PDCStatus = ERROR_SUCCESS;



    DFS_TRACE_LOW( ADBLOB, "Cache %p: from pdc? %d cache refresh\n", this, fFromPDC);

    if (fFromPDC == TRUE) 
    {
        PDCStatus = DfsGetBlobPDCName( &pPDC, 0 );
        //
        // Ignore the status here. If this call fails, we dont care
        // since we will just use a non-pdc dc. All callers who 
        // *really* care have already got the object with the right dc.
        // see apiprologue for more details.
        //
        if (PDCStatus == ERROR_SUCCESS) 
        {
            UseDC = pPDC->GetString();
        }
    }

    DFS_TRACE_LOW(ADBLOB, "Cache refresh using dc %ws\n", UseDC);

    Status = GetADObject( &pHandle, UseDC);
    
    if ((Status != ERROR_SUCCESS) &&
        (UseDC != NULL))
    {
        //
        // hmmm. failed here going to pdc. Just get the object without bothering
        // about the PDC.
        //
        Status = GetADObject(&pHandle, NULL);

    }

    if (Status == ERROR_SUCCESS)
    {
        // fFromPDC == FALSE means root scalability mode..every so often, get a new
        // Blob and guid
        if(fFromPDC == FALSE)
        {
            RefreshCount = InterlockedIncrement(&m_RefreshCount);
            if(RefreshCount >= DFS_ROOTSCALABILTY_FORCED_REFRESH_INTERVAL)
            {
                fForceSync = TRUE;
                InterlockedExchange((LPLONG volatile ) &m_RefreshCount, 0);
            }
        }

        Status = GetObjectPktGuid( pHandle, &CurrentGuid );

        if(Status == ERROR_SUCCESS)
        {
            if(!fForceSync)
            {
                //
                // here we pass the 2 guids by reference...
                //
                if (IsEqualGUID( CurrentGuid, m_BlobAttributePktGuid) == FALSE)
                {
                    Status = UpdateCacheWithDSBlob( pHandle );
                    if (Status == ERROR_SUCCESS)
                    {
                        m_BlobAttributePktGuid = CurrentGuid;
                    }
                }
            }
            else
            {
                Status = UpdateCacheWithDSBlob( pHandle );
                if (Status == ERROR_SUCCESS)
                {
                    m_BlobAttributePktGuid = CurrentGuid;
                }
            }
        }

        ReleaseADObject( pHandle );

    }

    DfsReleaseBlobPDCName( pPDC );

    if(Status != ERROR_SUCCESS)
    {
        PreviousState = InterlockedCompareExchange(&m_ErrorOccured, DFS_DS_ERROR, DFS_DS_NOERROR); 
        if(PreviousState == DFS_DS_NOERROR)
        {
            pUseShare = m_pRootFolder->GetRootPhysicalShareName();
            apszSubStrings[0] = pUseShare->Buffer;
            DfsLogDfsEvent(DFS_ERROR_NO_DFS_DATA, 1, apszSubStrings, Status);
        }
    }
    else
    {
        PreviousState = InterlockedCompareExchange(&m_ErrorOccured, DFS_DS_NOERROR, DFS_DS_ERROR); 
        if(PreviousState == DFS_DS_ERROR)
        {
            pUseShare  = m_pRootFolder->GetRootPhysicalShareName();
            apszSubStrings[0] = pUseShare->Buffer;
            DfsLogDfsEvent(DFS_INFO_RECONNECT_DATA, 1, apszSubStrings, Status);
        }

    }
    
    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "Cache %p: CacheRefresh status 0x%x\n", this, Status);
    return Status;
}



void 
DfsADBlobCache::InvalidateCache()
{
    PDFSBLOB_DATA pBlobData;
    DFSBOB_ITER Iter;
    DFS_TRACE_LOW( ADBLOB, "Cache %p: invalidate cache\n", this);
    pBlobData = FindFirstBlob(&Iter);
    while (pBlobData != NULL)
    {
        DFSSTATUS RemoveStatus;

        RemoveStatus = RemoveNamedBlob(&pBlobData->BlobName);
        DFS_TRACE_ERROR_LOW( RemoveStatus, REFERRAL_SERVER, "BlobCache %p, invalidate cache, remove blob status %x\n",
                             this, RemoveStatus);
        pBlobData = FindNextBlob(&Iter);
    }

    FindCloseBlob(&Iter);
    DFS_TRACE_LOW( ADBLOB, "Cache %p: invalidate cache done\n", this);
}

DFSSTATUS
DfsADBlobCache::PutBinaryIntoVariant(VARIANT * ovData, BYTE * pBuf,
                                     unsigned long cBufLen)
{
     DFSSTATUS Status = ERROR_INVALID_PARAMETER;
     void * pArrayData = NULL;
     VARIANT var;
     SAFEARRAYBOUND  rgsabound[1];

     VariantInit(&var);  //Initialize our variant

     var.vt = VT_ARRAY | VT_UI1;

     rgsabound[0].cElements = cBufLen;
     rgsabound[0].lLbound = 0;

     var.parray = SafeArrayCreate(VT_UI1,1,rgsabound);

     if(var.parray != NULL)
     {
        //Get a safe pointer to the array
        SafeArrayAccessData(var.parray,&pArrayData);

        //Copy bitmap to it
        memcpy(pArrayData, pBuf, cBufLen);

        //Unlock the variant data
        SafeArrayUnaccessData(var.parray);

        *ovData = var;  

        Status = STATUS_SUCCESS;
     }
     else
     {
         Status = ERROR_NOT_ENOUGH_MEMORY;
        DFS_TRACE_HIGH( REFERRAL_SERVER, "PutBinaryIntoVariant failed error %d\n", Status);
     }


     return Status;
}



DFSSTATUS
DfsADBlobCache::GetBinaryFromVariant(VARIANT *ovData, BYTE ** ppBuf,
                                     unsigned long * pcBufLen)
{
     DFSSTATUS Status = ERROR_INVALID_PARAMETER;
     void * pArrayData = NULL;

     //Binary data is stored in the variant as an array of unsigned char
     if(ovData->vt == (VT_ARRAY|VT_UI1))  
     {
        //Retrieve size of array
        *pcBufLen = ovData->parray->rgsabound[0].cElements;

        *ppBuf = new BYTE[*pcBufLen]; //Allocate a buffer to store the data
        if(*ppBuf != NULL)
        {
            //Obtain safe pointer to the array
            SafeArrayAccessData(ovData->parray,&pArrayData);

            //Copy the bitmap into our buffer
            memcpy(*ppBuf, pArrayData, *pcBufLen);

            //Unlock the variant data
            SafeArrayUnaccessData(ovData->parray);

            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
     }

     return Status;
}


DFSSTATUS 
DfsADBlobCache::CacheFlush(
    PVOID pHandle )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    GUID NewGuid;

    IADs *pObject  = (IADs *)pHandle;

    DFS_TRACE_LOW( ADBLOB, "Cache %p: cache flush\n", this);
    Status = UuidCreate(&NewGuid);
    if (Status == ERROR_SUCCESS)
    {
        m_BlobAttributePktGuid = NewGuid;

        Status = UpdateDSBlobFromCache( pObject,
                                        &NewGuid );

    }
    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "Cache %p: cache flush, Status %x\n", this, Status);
    return Status;
}


DFSSTATUS
DfsADBlobCache::UnpackBlob(
    BYTE *pBuffer,
    PULONG pLength,
    PDFSBLOB_DATA * pRetBlob )
{
    ULONG Discard = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    BYTE *pUseBuffer = NULL;
    ULONG BufferSize = 0;
    ULONG ObjNdx = 0;
    ULONG TotalObjects = 0;
    ULONG  BlobSize = 0;
    BYTE *BlobBuffer = NULL;
    PDFSBLOB_DATA pLocalBlob = NULL;
    UNICODE_STRING BlobName;
    UNICODE_STRING SiteRoot;
    UNICODE_STRING BlobRoot;
     
    pUseBuffer = pBuffer;
    BufferSize = *pLength;

    DFS_TRACE_LOW( ADBLOB, "BlobCache %p, UnPackBlob \n", this);
    UNREFERENCED_PARAMETER(pRetBlob);

    Status = DfsRtlInitUnicodeStringEx( &SiteRoot, ADBlobSiteRoot );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    Status = DfsRtlInitUnicodeStringEx( &BlobRoot, ADBlobMetaDataNamePrefix);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Note the size of the whole blob.
    //
    m_BlobSize = BufferSize;
    
    //
    // dfsdev: we should not need an interlocked here: this code
    // is already mutex'd by the caller.
    //
    InterlockedIncrement( &m_CurrentSequenceNumber );
    
    //
    // dfsdev: investigate what the first ulong is and add comment
    // here as to why we are discarding it.
    //
    Status = PackGetULong( &Discard, (PVOID *) &pUseBuffer, &BufferSize ); 
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if(BufferSize == 0)
    {
        goto done;
    }

    Status = PackGetULong(&TotalObjects, (PVOID *) &pUseBuffer, &BufferSize);
    if (Status != ERROR_SUCCESS) 
    {
        goto done;
    }


    for (ObjNdx = 0; ObjNdx < TotalObjects; ObjNdx++)
    {
        BOOLEAN FoundSite = FALSE;
        BOOLEAN FoundRoot = FALSE;

        Status = GetSubBlob( &BlobName,
                             &BlobBuffer,
                             &BlobSize,
                             &pUseBuffer,
                             &BufferSize );

        if (Status == ERROR_SUCCESS)
        {
            if (!FoundSite &&
               (RtlCompareUnicodeString( &BlobName, &SiteRoot, TRUE ) == 0))
            {
               FoundSite = TRUE;
               Status = CreateBlob(&BlobName, 
                                   BlobBuffer, 
                                   BlobSize,
                                   &pLocalBlob
                                   );
               if(Status == STATUS_SUCCESS)
               {
                   DeallocateShashData(m_pBlob);
                   m_pBlob = pLocalBlob;
               }

                continue;
            }
            if (!FoundRoot &&
               (RtlCompareUnicodeString( &BlobName, &BlobRoot, TRUE ) == 0))
            {
               FoundRoot = TRUE;
               UNICODE_STRING RootName;
               RtlInitUnicodeString(&RootName, NULL);
               Status = CreateBlob(&RootName,
                                   BlobBuffer, 
                                   BlobSize,
                                   &pLocalBlob
                                   );
               if(Status == STATUS_SUCCESS)
               {
                   DeallocateShashData(m_pRootBlob);
                   m_pRootBlob = pLocalBlob;
               }

                continue;
            }

            Status = StoreBlobInCache( &BlobName, BlobBuffer, BlobSize);
            if (Status != ERROR_SUCCESS)
            {
                break;
            }
        }
    }


done:

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "BlobCache %p: UnPackBlob status %x\n", this, Status);
    return Status;
}


DFSSTATUS
DfsADBlobCache::CreateBlob(PUNICODE_STRING BlobName, 
                           PBYTE pBlobBuffer, 
                           ULONG BlobSize,
                           PDFSBLOB_DATA *pNewBlob )
{
    PDFSBLOB_DATA BlobStructure = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    PBYTE NextBufOffset;

    ULONG TotalSize = sizeof(DFSBLOB_DATA) + 
                      BlobName->Length + sizeof(WCHAR) +
                      BlobSize;

    BlobStructure = (PDFSBLOB_DATA) AllocateShashData( TotalSize );

    if (BlobStructure != NULL)
    {
        RtlZeroMemory(BlobStructure, sizeof(DFSBLOB_DATA));
        NextBufOffset = (PBYTE)(BlobStructure + 1);

        BlobStructure->Header.RefCount = 1;
        BlobStructure->Header.pvKey = &BlobStructure->BlobName;
        BlobStructure->Header.pData = (PVOID)BlobStructure;

        BlobStructure->SequenceNumber = m_CurrentSequenceNumber;        
        BlobStructure->BlobName.Length = BlobName->Length;
        BlobStructure->BlobName.MaximumLength = BlobName->Length + sizeof(WCHAR);
        BlobStructure->BlobName.Buffer = (WCHAR *) (NextBufOffset);

        NextBufOffset = (PBYTE)((ULONG_PTR)(NextBufOffset) + 
                                BlobName->Length + 
                                sizeof(WCHAR));

        if (BlobName->Length != 0)
        {
            RtlCopyMemory(BlobStructure->BlobName.Buffer, 
                          BlobName->Buffer, 
                          BlobName->Length);
        }
        BlobStructure->BlobName.Buffer[BlobName->Length/sizeof(WCHAR)] = UNICODE_NULL;


        BlobStructure->Size = BlobSize;    
        BlobStructure->pBlob = (PBYTE)(NextBufOffset);

        if(pBlobBuffer && BlobSize)
        {
            RtlCopyMemory(BlobStructure->pBlob, pBlobBuffer, BlobSize);
        }
    }
    else
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }
    *pNewBlob = BlobStructure;

    return Status;
}

DFSSTATUS
DfsADBlobCache::CreateSiteBlobIfNecessary(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFSBLOB_DATA pSiteBlob = NULL;
    PBYTE pBuffer = NULL;
    PVOID pUseBuffer = NULL;
    ULONG SiteBlobSize = 0;
    ULONG SizeRemaining = 0;
    GUID NewGuid;
    UNICODE_STRING SiteMetadataName;

    if(m_pBlob == NULL)
    {
        do
        {
            Status = UuidCreate(&NewGuid);
            if (Status != ERROR_SUCCESS)
            {
              break;
            }

            Status = DfsRtlInitUnicodeStringEx(&SiteMetadataName, ADBlobSiteRoot);
            if(Status != ERROR_SUCCESS)
            {
                break;
            }

            SiteBlobSize = sizeof(ULONG) + sizeof(GUID);

            pBuffer = (PBYTE) AllocateShashData (SiteBlobSize);
            if (pBuffer == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            pUseBuffer = pBuffer;
            SizeRemaining = SiteBlobSize;

            Status = PackSetGuid( &NewGuid, &pUseBuffer, &SizeRemaining);
            if (Status != ERROR_SUCCESS)
            {
                break;
            }

            Status = PackSetULong( 0, &pUseBuffer, &SizeRemaining );
            if (Status != ERROR_SUCCESS)
            {
                break;
            }

            Status = CreateBlob(&SiteMetadataName, 
                                pBuffer, 
                                SiteBlobSize,
                                &pSiteBlob);
            if(Status != ERROR_SUCCESS)
             {
                break;
             }

            m_pBlob = pSiteBlob;

        }while(0);
    }

    if (pBuffer) 
    {
       DeallocateShashData(pBuffer);
    }

    return Status;

}

//
// UpdateSiteBlob: This routine takes a binary stream and stuffs that
// as the site information. It gets rid of the old site information.
// No update is done here, the caller has to call us back to say
// that data needs to be written out.
//
//
DFSSTATUS
DfsADBlobCache::UpdateSiteBlob(PVOID pBuffer, ULONG Size)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFSBLOB_DATA pSiteBlob = NULL;
    UNICODE_STRING SiteMetadataName;

    Status = DfsRtlInitUnicodeStringEx(&SiteMetadataName, ADBlobSiteRoot);
    if(Status == ERROR_SUCCESS)
    {
        Status = CreateBlob(&SiteMetadataName, 
                            (PBYTE)pBuffer,
                            Size,
                            &pSiteBlob);
        if(Status == ERROR_SUCCESS)
        {
            if (m_pBlob != NULL)
            {
                DeallocateShashData(m_pBlob);
            }
            m_pBlob = pSiteBlob;
        }
    }

    return Status;

}


DFSSTATUS
DfsADBlobCache::StoreBlobInCache(PUNICODE_STRING BlobName, 
                                 PBYTE pBlobBuffer, 
                                 ULONG BlobSize)
{
    PDFSBLOB_DATA BlobStructure = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;

    DFS_TRACE_LOW( ADBLOB, "cache %p: Storing Blob %wZ in cache, size %x\n",
                   this, BlobName, BlobSize );

    Status = CreateBlob( BlobName,
                         pBlobBuffer,
                         BlobSize,
                         &BlobStructure );

    if (Status == ERROR_SUCCESS)
    {
        if (IsEmptyString(BlobStructure->BlobName.Buffer))
        {
            ReleaseRootBlob();
            m_pRootBlob = BlobStructure;
        }
        else
        {
            NtStatus = SHashInsertKey(m_pTable, 
                                      BlobStructure, 
                                      &BlobStructure->BlobName, 
                                      SHASH_REPLACE_IFFOUND);
            if(NtStatus == STATUS_SUCCESS)
            {
                InterlockedDecrement(&BlobStructure->Header.RefCount);
            }
            else
            {
                DeallocateShashData( BlobStructure );
                Status = RtlNtStatusToDosError(NtStatus);
            }
        }
    }
    DFS_TRACE_LOW( ADBLOB, "cache %p: storing Blob %wZ done, status %x\n",
                   this, BlobName, Status);

    return Status;
}




DFSSTATUS
DfsADBlobCache::WriteBlobToAd(
    BOOLEAN ForceFlush)
{
    DFSSTATUS Status = STATUS_SUCCESS;
    PVOID pHandle = NULL;

    DFS_TRACE_LOW(ADBLOB, "cache %p: writing blob to ad\n", this);

    //
    //  ForceFlush flag is currently implemented as a DirectMode
    //  specific functionality. Essentially all normal flushes that happen
    //  during direct-mode operations are no-ops unless the ForceFlush
    //  flag is specified. All regular mode operations are left unaffected.
    //
    if (DfsCheckDirectMode() && !ForceFlush) 
    {
        DFS_TRACE_LOW(ADBLOB, "cache %p: WriteBlobToAd is a NOOP\n", this);
        return Status;
    }

    Status = GetCachedADObject ( &pHandle );

    if(Status == ERROR_SUCCESS)
    {
        Status = CacheFlush(pHandle);

        ReleaseADObject( pHandle );
    }
    DFS_TRACE_ERROR_LOW(Status, ADBLOB, "cache %p: writing blob to ad, status %x\n",
                        this, Status);

    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   GetSubBlob
//
//  Arguments:    
//
//   PUNICODE_STRING pBlobName (name of the sub blob)
//   BYTE **ppBlobBuffer - holds pointer to sub blob buffer
//   PULONG  pBlobSize -  holds the blob size
//   BYTE **ppBuffer -  holds the pointer to the main blob buffer 
//   PULONG pSize  - holds size of the main blob stream.
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine reads the next stream in the main blob, and
//               returns all the information necessary to unravel the
//               sub blob held within the main blob,
//               It adjusts the main blob buffer and size appropriately
//               to point to the next stream or sub-blob within the main
//               blob.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobCache::GetSubBlob(
    PUNICODE_STRING pName,
    BYTE **ppBlobBuffer,
    PULONG  pBlobSize,
    BYTE **ppBuffer,
    PULONG pSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // ppbuffer is the main blob, and it is point to a stream at this
    // point
    // the first part is the name of the sub-blob.
    //
    Status = PackGetString( pName, (PVOID *) ppBuffer, pSize );
    if (Status == ERROR_SUCCESS)
    {
        //
        // now get the size of the sub blob.
        //
        Status = PackGetULong( pBlobSize, (PVOID *) ppBuffer, pSize );
        if (Status == ERROR_SUCCESS)
        {
            if(*pBlobSize > *pSize)
            {
                Status = ERROR_INVALID_DATA ;
            }
            else
            {

                //
                // At this point the main blob is point to the sub-blob itself.
                // So copy the pointer of the main blob so we can return it
                // as the sub blob.
                //
                *ppBlobBuffer = *ppBuffer;

                //
                // update the main blob pointer to point to the next stream
                // in the blob.

                *ppBuffer = (BYTE *)*ppBuffer + *pBlobSize;
                *pSize -= *pBlobSize;
            }
        }
    }

    return Status;
}


DFSSTATUS
DfsADBlobCache::GetNamedBlob(PUNICODE_STRING pBlobName,
                             PDFSBLOB_DATA *pBlobStructure)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (IsEmptyString(pBlobName->Buffer))
    {
        *pBlobStructure = AcquireRootBlob();
        if (*pBlobStructure == NULL)
        {
            Status = ERROR_NOT_FOUND;
        }
    }
    else
    {
        NtStatus = SHashGetDataFromTable(m_pTable, 
                                         (void *)pBlobName,
                                         (void **) pBlobStructure);
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}


DFSSTATUS
DfsADBlobCache::SetNamedBlob(PDFSBLOB_DATA pBlobStructure)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (IsEmptyString(pBlobStructure->BlobName.Buffer))
    {
        ReleaseRootBlob();
        m_pRootBlob = pBlobStructure;
        AcquireRootBlob();
    }
    else
    {
        NtStatus = SHashInsertKey(m_pTable, 
                                  pBlobStructure, 
                                  &pBlobStructure->BlobName, 
                                  SHASH_REPLACE_IFFOUND);

        Status = RtlNtStatusToDosError(NtStatus);
    }
    
    return Status;
}

DFSSTATUS
DfsADBlobCache::RemoveNamedBlob(PUNICODE_STRING pBlobName )
{
    NTSTATUS NtStatus;
    DFSSTATUS Status = ERROR_SUCCESS;

    if (IsEmptyString(pBlobName->Buffer))
    {
        if (m_pRootBlob == NULL)
        {
            Status = ERROR_NOT_FOUND;
        }
        ReleaseRootBlob();
    }
    else
    {
        NtStatus = SHashRemoveKey(m_pTable, 
                                  pBlobName,
                                  NULL );

        Status = RtlNtStatusToDosError(NtStatus);
    }
    
    return Status;

}

DWORD 
PackBlobEnumerator( PSHASH_HEADER   pEntry,
                    void*  pContext ) 
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING pBlobName = (PUNICODE_STRING) pEntry->pvKey;
    PDFSBLOB_DATA pBlobStructure = (PDFSBLOB_DATA) pEntry;
    PPACKBLOB_ENUMCTX pEnumCtx = (PPACKBLOB_ENUMCTX) pContext;

    if (pBlobStructure->SequenceNumber == pEnumCtx->SequenceNumber)
    {
        Status = AddStreamToBlob( pBlobName,
                                  pBlobStructure->pBlob,
                                  pBlobStructure->Size,
                                  &pEnumCtx->pBuffer,
                                  &pEnumCtx->Size );

    
        pEnumCtx->NumItems++;
        pEnumCtx->CurrentSize += (pBlobName->Length + 
                                  sizeof(USHORT) +
                                  sizeof(ULONG) +
                                  pBlobStructure->Size);
    }
    return Status;
}

//
// skeleton of pack blob. 
// The buffer is passed in. The length is passed in.
// If the information does not fit the buffer, return required length.
// Required for API implementation.
//
//
DFSSTATUS
DfsADBlobCache::PackBlob(
    BYTE *pBuffer,
    PULONG pLength,
    PULONG TotalBlobBytes )

{
    ULONG Discard = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BYTE *pUseBuffer = NULL;
    BYTE *pSavedBuffer = NULL;
    ULONG SavedBufferSize = 0;
    ULONG BufferSize = 0;
    PACKBLOB_ENUMCTX EnumCtx;
     
    pUseBuffer = pBuffer;
    BufferSize = *pLength;

    DFS_TRACE_LOW(ADBLOB, "BlobCache %p: packing blob\n", this);
    //
    // dfsdev: investigate what the first ulong is and add comment
    // here as to why we are setting it to 0.
    //
    Status = PackSetULong( 0, (PVOID *) &pUseBuffer, &BufferSize ); 
    if (Status == ERROR_SUCCESS)
    {

        //save the place where we should write back the number of objects
        pSavedBuffer = pUseBuffer;
        SavedBufferSize = BufferSize;
        //
        // the next argument is the number of objects in the blob.
        // set 0 until we find how many blobs there are
        //
        Status = PackSetULong(0, (PVOID *) &pUseBuffer, &BufferSize);
    }

    if (Status == ERROR_SUCCESS) 
    {

        EnumCtx.pBuffer = pUseBuffer;
        EnumCtx.Size = BufferSize;
        EnumCtx.NumItems = 0;
        EnumCtx.SequenceNumber = m_CurrentSequenceNumber;
        EnumCtx.CurrentSize = sizeof(ULONG);
    }

    if (Status == ERROR_SUCCESS)
    {
        if (m_pRootBlob != NULL)
        {
            PDFSBLOB_DATA pRootBlob;
            UNICODE_STRING RootMetadataName;

            Status = DfsRtlInitUnicodeStringEx(&RootMetadataName, ADBlobMetaDataNamePrefix);
            if(Status == ERROR_SUCCESS)
            {
                Status = CreateBlob( &RootMetadataName,
                                     m_pRootBlob->pBlob,
                                     m_pRootBlob->Size,
                                     &pRootBlob);

                if (Status == ERROR_SUCCESS)
                {
                    Status = PackBlobEnumerator( (SHASH_HEADER *)pRootBlob, (PVOID) &EnumCtx);    

                    DeallocateShashData(pRootBlob);
                }
            }

        }
    }


    
    if (Status == ERROR_SUCCESS)
    {
        NtStatus = ShashEnumerateItems(m_pTable, 
                                       PackBlobEnumerator, 
                                       &EnumCtx);

        //dfsdev: make sure that shash enumerate retuns NTSTATUS.
        // it does not appear to do so... I think it is the packblobenumerator
        // that is returning a non-ntstatus. Till we fix it dont convert err

        //    Status = RtlNtStatusToDosError(NtStatus);
        Status = NtStatus;
    }

    //
    // Now add the site blob as the LAST blob. It appears that old
    // downlevel dfs may rely on this.
    //
    if (Status == ERROR_SUCCESS) 
    {
        CreateSiteBlobIfNecessary();

        if (m_pBlob != NULL)
        {
            Status = PackBlobEnumerator( (SHASH_HEADER *) m_pBlob, (PVOID) &EnumCtx);    
        }
    }

    if (Status == ERROR_SUCCESS)
    {

        if (EnumCtx.NumItems > 0)
        {
            Status = PackSetULong(EnumCtx.NumItems, 
                                  (PVOID *) &pSavedBuffer, 
                                  &SavedBufferSize);

            EnumCtx.CurrentSize += sizeof(ULONG);
        }

        *TotalBlobBytes = EnumCtx.CurrentSize;
    }

    m_BlobSize = *TotalBlobBytes;
    //*TotalBlobBytes =  (ULONG) (EnumCtx.pBuffer -  pBuffer);

    DFS_TRACE_ERROR_LOW( Status, ADBLOB, "BlobCache %p, PackBlob status %x\n",
                         this, Status);
    return Status;
}

ULONG
DfsADBlobCache::GetBlobSize()
{
    return m_BlobSize;
}



PDFSBLOB_DATA
DfsADBlobCache::FindFirstBlob(PDFSBLOB_ITER pIter)
{
    PDFSBLOB_DATA pBlob = NULL;

    pIter->RootReferenced = AcquireRootBlob();
    if (pIter->RootReferenced != NULL) 
    {
        pIter->Started = FALSE;
        pBlob = pIter->RootReferenced;
    }
    else
    {
        pIter->Started = TRUE;
        pBlob = (PDFSBLOB_DATA) SHashStartEnumerate(&pIter->Iter, m_pTable);
    }

    return pBlob;
}


PDFSBLOB_DATA
DfsADBlobCache::FindNextBlob(PDFSBLOB_ITER pIter)
{
    PDFSBLOB_DATA pBlob = NULL;

    if (pIter->Started == FALSE)
    {
        pIter->Started = TRUE;
        pBlob = (PDFSBLOB_DATA) SHashStartEnumerate(&pIter->Iter, m_pTable);
    }
    else
    {
        pBlob = (PDFSBLOB_DATA) SHashNextEnumerate(&pIter->Iter, m_pTable);
    }

    return pBlob;
}



void
DfsADBlobCache::FindCloseBlob(PDFSBLOB_ITER pIter)
{

    if (pIter->RootReferenced)
    {
        ReleaseBlobReference(pIter->RootReferenced);
        pIter->RootReferenced = NULL;
    }
    if (pIter->Started)
    {
        SHashFinishEnumerate(&pIter->Iter, m_pTable);    
        pIter->Started = FALSE;
    }
}


DFSSTATUS
AddStreamToBlob(PUNICODE_STRING BlobName,
                BYTE *pBlobBuffer,
                ULONG  BlobSize,
                BYTE ** pUseBuffer,
                ULONG *BufferSize )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = PackSetString(BlobName, (PVOID *) pUseBuffer, BufferSize);
    if(Status == ERROR_SUCCESS)
    {
         Status = PackSetULong(BlobSize, (PVOID *) pUseBuffer, BufferSize);
         if(Status == ERROR_SUCCESS)
         {
             if ( *BufferSize >= BlobSize )
             {
                 RtlCopyMemory((*pUseBuffer), pBlobBuffer, BlobSize);

                 *pUseBuffer = (BYTE *)((ULONG_PTR)*pUseBuffer + BlobSize);
                 *BufferSize -= BlobSize;
             }
             else
             {
                 Status = ERROR_BUFFER_OVERFLOW;
             }
         }

    }
    if (Status == ERROR_INVALID_DATA)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }

    return Status;
}

PVOID
AllocateShashData(ULONG Size )
{
    PVOID RetValue = NULL;

    if (Size)
    {
        RetValue = (PVOID) new BYTE[Size];
    }
    return RetValue;
}

VOID
DeallocateShashData(PVOID pPointer )
{
    if(pPointer)
    {
        delete [] (PBYTE)pPointer;
    }
}

DFSSTATUS 
DfsADBlobCache::DfsDoesUserHaveAccess(DWORD DesiredAccess)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PVOID pHandle = NULL;
    UNICODE_STRING ObjectDN;
    
    DFS_TRACE_LOW(ADBLOB, "BlobCache %p: DfsADBlobCache::DfsDoesUserHaveAccess\n", this);

    do
    {

        Status = GetCachedADObject ( &pHandle );
        if(Status != ERROR_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::DfsDoesUserHaveAccess: GetCachedADObject failed status %x\n", 
                                 Status);
            break;
        }

        Status = GetObjectDN(&ObjectDN);
        if(Status != ERROR_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::DfsDoesUserHaveAccess: GetObjectDN failed status %x\n", 
                                 Status);
            break;
        }


        Status = DfsGetObjSecurity((LDAP *) pHandle,
                                   ObjectDN.Buffer,
                                   &pSD);

        if(Status != ERROR_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::DfsDoesUserHaveAccess: DfsGetObjectSecurity failed status %x\n", 
                                 Status);
            break;
        }

        Status = DfsDoesUserHaveDesiredAccessToAd(DesiredAccess, 
                                                  pSD);
        if(Status != ERROR_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH( Status, ADBLOB, "DfsADBlobCache::DfsDoesUserHaveAccess: DfsDoesUserHaveDesiredAccessToAd failed status %x\n", 
                                 Status);
            break;
        }

    }while (0);

    if(pHandle != NULL)
    {
        ReleaseADObject( pHandle );
    }

    if(pSD)
    {
        DfsDeallocateSecurityData (pSD);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilterapi\dfsfilterapi.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsFilterApi.cxx
//
//  Contents:   Contains APIs to communicate with the filter driver   
//
//  Classes:    none.
//
//  History:    Jan. 24 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>        
#include <lm.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include <DfsReferralData.h>
#include <ole2.h>
#include <activeds.h>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <dfswmi.h>

#include <dfsserverlibrary.hxx>


                  
#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) (pFilterAPiControl->Control.Logger),
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
  (pFilterAPiControl && (pFilterAPiControl->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)) && \
  (pFilterAPiControl->Control.Level >= lvl))
 
#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) (pFilterAPiControl->Control.Logger),
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((pFilterAPiControl && (!NT_SUCCESS(error) || (pFilterAPiControl->Control.Flags[WPP_FLAG_NO(WPP_BIT_ ## flags)] & WPP_MASK(WPP_BIT_ ## flags)))) && \
  (pFilterAPiControl->Control.Level >= lvl))
 
#include "dfsfilterapi.tmh"

WPP_CB_TYPE *pFilterAPiControl = NULL;

BOOL g_ReflectShutdownFlag = FALSE;

#define MAX_DFS_REFLECTION_THREADS  4

HANDLE ThreadArray[MAX_DFS_REFLECTION_THREADS];

HANDLE gTerminationHandle = NULL;

extern
DFSSTATUS
DfsProcessGetReplicaData(HANDLE hDriver, PBYTE DataBuffer);


NTSTATUS
NtStatusFromLastError(DWORD StatusIn)
{
    NTSTATUS status = 0;

    switch(StatusIn)
    {
    case ERROR_SUCCESS:
        status = STATUS_SUCCESS;
        break;

    case ERROR_ACCESS_DENIED:
        status = STATUS_ACCESS_DENIED;
        break;

    case ERROR_MORE_DATA:
        status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_HOST_UNREACHABLE:
        status = STATUS_PATH_NOT_COVERED;
        break;

    case ERROR_BAD_NET_NAME:
        status = STATUS_BAD_NETWORK_NAME;
        break;

    case ERROR_SHARING_VIOLATION:
        status = STATUS_SHARING_VIOLATION;
        break;

    case ERROR_NO_MORE_ITEMS:
        status = STATUS_NO_MORE_ENTRIES;
        break;

    case ERROR_FILE_NOT_FOUND:
        status = STATUS_NO_SUCH_FILE;
        break;

    case ERROR_ALREADY_EXISTS:
        status = STATUS_OBJECT_NAME_COLLISION;
        break;

    case ERROR_INVALID_PARAMETER:
        status = STATUS_INVALID_PARAMETER;
        break;
        
    case ERROR_CALL_NOT_IMPLEMENTED:
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_FOUND:
        status = STATUS_NOT_FOUND;
        break;

    case ERROR_DUP_NAME:
        status = STATUS_DUPLICATE_NAME;
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        status = STATUS_BUFFER_TOO_SMALL;
        break;
        
    case ERROR_INVALID_DATA:
        status = STATUS_DATA_ERROR;  
        break;

    case ERROR_INVALID_HANDLE:
        status = STATUS_INVALID_HANDLE;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_OPERATION_ABORTED:
        status = STATUS_REQUEST_ABORTED;
        break;

    case ERROR_BAD_COMMAND:
    default:
        status = STATUS_UNSUCCESSFUL;
        //ASSERT(FALSE);
        break;
    }
    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsOpenFilterDriver 
//
//  Arguments:  DriverHandle - Pointer to receive driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Opens the DFS filter driver
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsOpenFilterDriver( HANDLE * DriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDevice = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DfsDeviceName;

    //
    // Attempt to open the driver.
    //
    RtlInitUnicodeString(&DfsDeviceName, DFS_FILTER_NAME);
    InitializeObjectAttributes(&ObjectAttributes,
                           &DfsDeviceName,
                           OBJ_CASE_INSENSITIVE,
                           NULL,
                           NULL);

    Status = NtOpenFile(&hDevice,
                        SYNCHRONIZE | FILE_WRITE_DATA,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (Status != STATUS_SUCCESS) 
    {
        Status = RtlNtStatusToDosError(Status);
    }

    *DriverHandle = hDevice;
    return Status;
}


DFSSTATUS
DfsOpenFilterTerminationHandle( HANDLE * DriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDevice = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DfsDeviceName;
    WCHAR NameBuf[600];

    //
    //

    RtlInitEmptyUnicodeString( &DfsDeviceName, NameBuf, sizeof(NameBuf));
    RtlAppendUnicodeToString(&DfsDeviceName, DFS_FILTER_NAME);
    RtlAppendUnicodeToString(&DfsDeviceName, DFSFILTER_PROCESS_TERMINATION_FILEPATH);

    InitializeObjectAttributes(&ObjectAttributes,
                           &DfsDeviceName,
                           OBJ_CASE_INSENSITIVE,
                           NULL,
                           NULL);

    Status = NtOpenFile(&hDevice,
                        SYNCHRONIZE | FILE_WRITE_DATA,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_SYNCHRONOUS_IO_NONALERT);
    if (Status != STATUS_SUCCESS) 
    {
        Status = RtlNtStatusToDosError(Status);
    }

    *DriverHandle = hDevice;
    return Status;
}



void
DfsCloseFilterTerminationHandle(void)
{
   if(gTerminationHandle != NULL)
   {
       CloseHandle(gTerminationHandle);
       gTerminationHandle = NULL;
   }
}
//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeStartUmrx 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the usermode reflection engine
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeStartUmrx( HANDLE hDriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;
    DFS_FILTER_STARTUP_INFO DfsStartupInfo;


    DfsStartupInfo.IsDC = DfsIsMachineDomainController();
    DfsStartupInfo.Flags = 0;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_START_UMRX,
        &DfsStartupInfo,
        sizeof(DfsStartupInfo),
        NULL,
        0);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeStopUmrx 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Stops the usermode reflection engine
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeStopUmrx( HANDLE hDriverHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_STOP_UMRX,
        NULL,
        0,
        NULL,
        0);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeProcessPacket 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Sends a response to the driver
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeProcessPacket( IN HANDLE hDriverHandle, 
                     IN PVOID InputBuffer,
                     IN DWORD InputBufferLength,
                     IN PVOID OutputBuffer,
                     IN DWORD OutputBufferLength,
                     OUT DWORD * BytesReturned)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_PROCESS_UMRXPACKET,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    *BytesReturned = (DWORD)ioStatus.Information;

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUserModeGetReplicaInfo 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Gets the replica information from filter driver
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsUserModeGetReplicaInfo( IN HANDLE hDriverHandle, 
                     IN PVOID InputBuffer,
                     IN DWORD InputBufferLength,
                     IN PVOID OutputBuffer,
                     IN DWORD OutputBufferLength)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_GETREPLICA_INFO,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsUSerModeAttachToFilesystem 
//
//  Arguments:  DirectoryName - Directory on volume to attach to
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: attaches the filter driver to the volume
//
//--------------------------------------------------------------------------




DFSSTATUS
DfsUserModeAttachToFilesystem(PUNICODE_STRING pVolumeName, 
                              PUNICODE_STRING pShareName )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDriverHandle = NULL;
    PDFS_ATTACH_PATH_BUFFER pBuffer = NULL;
    DWORD SizeToAllocate = 0;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;


    if(pVolumeName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }


    if((pShareName == NULL) || (pShareName->Buffer == NULL)
       || (pShareName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    SizeToAllocate = pVolumeName->Length + pShareName->Length 
                     + sizeof(DFS_ATTACH_PATH_BUFFER);

    pBuffer = (PDFS_ATTACH_PATH_BUFFER) HeapAlloc(GetProcessHeap(), 
                                                  0, 
                                                  SizeToAllocate);
    if(pBuffer == NULL)
    {
        Status = GetLastError();
        goto Exit;
    }

    pBuffer->VolumeNameLength = pVolumeName->Length ;
    pBuffer->ShareNameLength = pShareName->Length ;
    pBuffer->Flags = 0;

    if(pBuffer->VolumeNameLength != 0)
    {
        RtlCopyMemory(
            &pBuffer->PathNameBuffer[0],
            pVolumeName->Buffer,
            pBuffer->VolumeNameLength);
    }

    RtlCopyMemory(
        &pBuffer->PathNameBuffer[pBuffer->VolumeNameLength / sizeof(WCHAR)],
        pShareName->Buffer,
        pBuffer->ShareNameLength);

    Status = DfsOpenFilterDriver(&hDriverHandle);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_ATTACH_FILESYSTEM,
        pBuffer,
        SizeToAllocate,
        NULL,
        0);

    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

Exit:

    CloseHandle(hDriverHandle);


    if(pBuffer)
    {
        HeapFree(GetProcessHeap(), 0, pBuffer);
    }

    return Status;
}


DFSSTATUS
DfsUserModeDetachFromFilesystem(PUNICODE_STRING pVolumeName, 
                                PUNICODE_STRING pShareName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDriverHandle = NULL;
    PDFS_ATTACH_PATH_BUFFER pBuffer = NULL;
    DWORD SizeToAllocate = 0;
    IO_STATUS_BLOCK ioStatus;

    ioStatus.Information = 0;

    if(pVolumeName == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }


    if((pShareName == NULL) || (pShareName->Buffer == NULL)
       || (pShareName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    SizeToAllocate = pVolumeName->Length + pShareName->Length 
                     + sizeof(DFS_ATTACH_PATH_BUFFER);

    pBuffer = (PDFS_ATTACH_PATH_BUFFER) HeapAlloc(GetProcessHeap(), 
                                                  0, 
                                                  SizeToAllocate);
    if(pBuffer == NULL)
    {
        Status = GetLastError();
        goto Exit;
    }

    pBuffer->VolumeNameLength = pVolumeName->Length ;
    pBuffer->ShareNameLength = pShareName->Length ;
    pBuffer->Flags = 0;


    if(pBuffer->VolumeNameLength != 0)
    {
        RtlCopyMemory(
            &pBuffer->PathNameBuffer[0],
            pVolumeName->Buffer,
            pBuffer->VolumeNameLength);
    }

    RtlCopyMemory(
        &pBuffer->PathNameBuffer[pBuffer->VolumeNameLength / sizeof(WCHAR)],
        pShareName->Buffer,
        pBuffer->ShareNameLength);

    Status = DfsOpenFilterDriver(&hDriverHandle);

    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = NtFsControlFile(
        hDriverHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        DFSFILTER_DETACH_FILESYSTEM,
        pBuffer,
        SizeToAllocate,
        NULL,
        0);

    
    if(Status != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(Status);
    }

Exit:

    CloseHandle(hDriverHandle);

    if(pBuffer)
    {
        HeapFree(GetProcessHeap(), 0, pBuffer);
    }

    return Status;
}

NTSTATUS
DfsUSerModePurgeShareList(void) 
{
    NTSTATUS Status = STATUS_SUCCESS;

    return Status;
}
//+-------------------------------------------------------------------------
//
//  Function:   DfsProcessWorkItemData 
//
//  Arguments:  Databuffer from kernel
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Decipher the input buffer and calls the right routines to 
//               process the data
//               
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsProcessWorkItemData(HANDLE DriverHandle, PBYTE DataBuffer)
{
    DFSSTATUS Status = ERROR_INVALID_PARAMETER;
    PUMRX_USERMODE_WORKITEM_HEADER pHeader = NULL;
    PUMRX_USERMODE_WORKITEM        pWorkItem = NULL;

    UNREFERENCED_PARAMETER(DriverHandle);

    pHeader = (PUMRX_USERMODE_WORKITEM_HEADER)DataBuffer;
    if( pHeader->ulHeaderVersion != UMR_VERSION )
    {
        goto Exit;
    }

    switch (pHeader->WorkItemType) 
    {
    case opUmrGetDfsReplicas:
        {
            Status = DfsProcessGetReplicaData(DriverHandle, DataBuffer);
            break;
        }

    default:
        break;

    }

Exit:

    Status = NtStatusFromLastError(Status);

    pHeader->IoStatus.Status = Status;
    pHeader->IoStatus.Information = 0;
    pHeader->ulFlags = UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE;

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsReflectionThread 
//
//  Arguments:  None
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Handles requests from the filter driver
//               
//
//--------------------------------------------------------------------------
DWORD
DfsReflectionThread(LPVOID pData )
{
    NTSTATUS Status = 0;
    HRESULT hr = S_OK;
    DWORD BytesReturned = 0;
    HANDLE hDriverHandle    = INVALID_HANDLE_VALUE;
    HANDLE hClientHandle    = INVALID_HANDLE_VALUE;
    PBYTE pBuffer           = NULL;
    PUMRX_USERMODE_WORKITEM_HEADER pHeader = NULL;
    PUMRX_USERMODE_WORKITEM        pWorkItem = NULL;
    PBYTE OutputBuffer = NULL;

    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);

    //get a handle to receive requests from
    DfsOpenFilterDriver(&hDriverHandle);

    //get a handle to send back data on
    DfsOpenFilterDriver(&hClientHandle);


    OutputBuffer = (PBYTE) pData;
    while (1)
    {

        ZeroMemory (OutputBuffer, MAX_USERMODE_REFLECTION_BUFFER);

        BytesReturned = 0;

        Status = DfsUserModeProcessPacket(hDriverHandle, 
                                          NULL,
                                          0,
                                          OutputBuffer,
                                          MAX_USERMODE_REFLECTION_BUFFER,
                                          &BytesReturned);
        //this means we are shutting down
        if(BytesReturned == 0)
        {
            break;
        }


        Status = DfsProcessWorkItemData(hClientHandle, OutputBuffer);

        if(Status != ERROR_SUCCESS)
        {
            Status = DfsUserModeProcessPacket(hClientHandle, 
                                              OutputBuffer,
                                              MAX_USERMODE_REFLECTION_BUFFER,
                                              NULL,
                                              0,
                                              &BytesReturned);
        }
    }

    if(hDriverHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hDriverHandle);
    }


    if(hClientHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hClientHandle);
    }

    HeapFree(GetProcessHeap(), 0, OutputBuffer);

    CoUninitialize();
    return 0;
}




//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeReflectionThreads 
//
//  Arguments:  DriverHandle - driver handle
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the usermode reflection threads
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsInitializeReflectionThreads(void)
{
    DFSSTATUS Status = 0;
    DWORD Loop = 0;
    DWORD dwThreadId = 0;
    PBYTE Buffer = NULL;

    for (Loop = 0; Loop < MAX_DFS_REFLECTION_THREADS; Loop++) 
    {


        Buffer = (PBYTE) HeapAlloc(GetProcessHeap(), 0, MAX_USERMODE_REFLECTION_BUFFER);
        if(Buffer == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ThreadArray [Loop] = CreateThread(NULL,
                                           0,
                                           DfsReflectionThread,
                                           (LPVOID) Buffer,
                                           0,
                                           &dwThreadId);
        if(ThreadArray [Loop] == NULL)
        {
            Status = GetLastError();
            break;
        }
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeReflectionEngine 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Starts the usermode reflection engine
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsInitializeReflectionEngine(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE hDriver = NULL;


    Status = DfsOpenFilterTerminationHandle(&gTerminationHandle);
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsOpenFilterDriver(&hDriver);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = DfsUserModeStartUmrx(hDriver);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = DfsInitializeReflectionThreads();

Exit:

    if(hDriver != NULL)
    {
        CloseHandle(hDriver);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsWaitForReflectionThreads
//
//  Arguments:  None
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Waits for all the relection threads to die
//               
//
//--------------------------------------------------------------------------
DFSSTATUS DfsWaitForReflectionThreads(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD Loop = 0;

    WaitForMultipleObjects(MAX_DFS_REFLECTION_THREADS, ThreadArray, TRUE, INFINITE);

    for (Loop = 0; Loop < MAX_DFS_REFLECTION_THREADS; Loop++) 
    {
        if(ThreadArray [Loop] != INVALID_HANDLE_VALUE)
        {
            CloseHandle(ThreadArray [Loop]);
            ThreadArray [Loop] = INVALID_HANDLE_VALUE;
        }
    }

    return Status;
}


DFSSTATUS 
DfsTerminateReflectionEngine(void)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hDriver = NULL;

    Status = DfsOpenFilterDriver(&hDriver);
    if(Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = DfsUserModeStopUmrx(hDriver);

Exit:

    if(hDriver != NULL)
    {
        CloseHandle(hDriver);
    }

    return Status;
}


void SetFilterAPiShutdownFlag(void)
{
    g_ReflectShutdownFlag = TRUE;
}


void SetFilterAPiControl(WPP_CB_TYPE * Control)
{
    pFilterAPiControl = Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsinit.h ===
#ifndef __DFS_INIT__
#define __DFS_INIT__



typedef struct _DFS_VOLUME_INFORMATION {
    LIST_ENTRY VolumeList;

    //
    //  Pointer to the real (disk) device object that is associated with
    //  the file system device object we are attached to
    //

    PDEVICE_OBJECT DiskDeviceObject;

    //
    //  A cached copy of the name (if enabled) of the device we are attached to.
    //  - If it is a file system device object it will be the name of that
    //    device object.
    //  - If it is a mounted volume device object it will be the name of the
    //    real device object (since mounted volume device objects don't have
    //    names).
    //

    UNICODE_STRING VolumeName;

    //Number of times we have attached to this device

    LONG RefCount;

} DFS_VOLUME_INFORMATION, *PDFS_VOLUME_INFORMATION;

//
//  Device extension definition for our driver.  Note that the same extension
//  is used for the following types of device objects:
//      - File system device object we attach to
//      - Mounted volume device objects we attach to
//


typedef struct _DFS_FILTER_DEVICE_EXTENSION {
    PDEVICE_OBJECT pThisDeviceObject;
    //
    //  Pointer to the file system device object we are attached to
    //
    PDFS_VOLUME_INFORMATION pDfsVolume;

    PDEVICE_OBJECT pAttachedToDeviceObject;

    BOOLEAN Attached;
} DFS_FILTER_DEVICE_EXTENSION, *PDFS_FILTER_DEVICE_EXTENSION;


typedef struct _DFS_GLOBAL_DATA {
    LIST_ENTRY DfsVolumeList;
    PDRIVER_OBJECT pFilterDriverObject;
    PDEVICE_OBJECT pFilterControlDeviceObject;
    ERESOURCE Resource;
    PVOID     CurrentProcessPointer;
    BOOLEAN   IsDC;
    BOOLEAN   Started;
    PEPROCESS ServiceProcess;
} DFS_GLOBAL_DATA, *PDFS_GLOBAL_DATA;

extern DFS_GLOBAL_DATA DfsGlobalData;

//
// Macro to test if we are still using a device object

#define IS_DFS_ATTACHED(pDeviceObject) \
     ((((PDFS_FILTER_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->DeviceInUse))



extern FAST_IO_DISPATCH DfsFastIoDispatch;


//#define DFS_FILTER_NAME               L"\\FileSystem\\DfsFilter"
//#define DFS_FILTER_NAME               L"\\FileSystem\\Filters\\DfsFilter"
#define DFS_FILTER_DOSDEVICE_NAME     L"\\??\\DfsFilter"

//
//  Macro to test if this is my device object
//

#define IS_MY_DEVICE_OBJECT(_devObj) \
    (((_devObj) != NULL) && \
     ((_devObj)->DriverObject == DfsGlobalData.pFilterDriverObject) && \
      ((_devObj)->DeviceExtension != NULL))


//
//  Macro to test if this is my control device object
//

#define IS_MY_CONTROL_DEVICE_OBJECT(_devObj) \
    (((_devObj) == DfsGlobalData.pFilterControlDeviceObject) ? \
            (ASSERT(((_devObj)->DriverObject == DfsGlobalData.pFilterDriverObject) && \
                    ((_devObj)->DeviceExtension == NULL)), TRUE) : \
            FALSE)

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    ((_type) == FILE_DEVICE_DISK_FILE_SYSTEM)


//
//  Macro to validate our current IRQL level
//

#define VALIDATE_IRQL(_irp) (ASSERT(KeGetCurrentIrql() <= APC_LEVEL))



VOID
DfsCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject);

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//

#define try_return(S) { S; goto try_exit; }


NTSTATUS
DfsFindDfsVolumeByDiskDeviceObject(
    PDEVICE_OBJECT pDiskDeviceObject,
    PDFS_VOLUME_INFORMATION *ppDfsVolume);

VOID
DfsReattachToMountedVolume( 
    PDEVICE_OBJECT pTargetDevice,
    PDEVICE_OBJECT pDiskDevice );

NTSTATUS
DfsFindDfsVolumeByName( 
    PUNICODE_STRING pDeviceName,
    PDFS_VOLUME_INFORMATION *ppDfsVolume);

VOID
DfsDetachFilterDevice(
    PDEVICE_OBJECT DfsDevice, 
    PDEVICE_OBJECT TargetDevice);

NTSTATUS
DfsGetDfsVolume(
    PUNICODE_STRING pName,
    PDFS_VOLUME_INFORMATION *ppDfsVolume);


#define ACQUIRE_GLOBAL_LOCK() ExAcquireResourceExclusiveLite(&DfsGlobalData.Resource, TRUE)
#define RELEASE_GLOBAL_LOCK() ExReleaseResourceLite(&DfsGlobalData.Resource)




#ifndef NOTHING
#define NOTHING
#endif

#endif //__DFS_INIT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsinit.c ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       dfsinit.c
//
//  Contents:   Driver initialization routine for the Dfs server.
//
//  Classes:    None
//
//  Functions:  DriverEntry -- Entry point for driver
//
//-----------------------------------------------------------------------------

     

#include <ntifs.h>
#include <limits.h>
#include <windef.h>
#include <dfsprefix.h>
#include <..\..\lib\prefix\prefix.h>
#include <DfsReferralData.h>
#include "dfsheader.h"
#include "DfsInit.h"
#include "midatlax.h"
#include "rxcontx.h"
#include "dfsumr.h"
#include "umrx.h"
#include "DfsUmrCtrl.h"
#include "DfsUmrRequests.h"
#include <dfsfsctl.h>


#define _NTDDK_
#include "stdarg.h"
#include "wmikm.h"
#include <wmistr.h>
#include <evntrace.h>

#include <wmiumkm.h>
#include "dfswmi.h"     
              
#define WPP_BIT_CLI_DRV 0x01

#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)  

#define WPP_LEVEL_ERROR_FLAGS_LOGGER(lvl, error, flags) WPP_LEVEL_LOGGER(flags)
#define WPP_LEVEL_ERROR_FLAGS_ENABLED(lvl, error, flags) \
  ((!NT_SUCCESS(error) || WPP_LEVEL_ENABLED(flags)) && WPP_CONTROL(WPP_BIT_CLI_DRV ).Level >= lvl)
  
#include "dfsinit.tmh"
      
                  
DFS_GLOBAL_DATA DfsGlobalData;

//prefix table
DFS_PREFIX_TABLE *pPrefixTable = NULL;
BOOL gfRundownPrefixCompleted = FALSE;
BOOLEAN DfsDebugAttachToFsRecognizer = FALSE;

WCHAR gDummyData = 0;

extern POBJECT_TYPE *IoFileObjectType;
extern PUMRX_ENGINE g_pUMRxEngine;

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif
                               
#define DFSFILTER_INIT_DEVICECREATED  0x00000001
#define DFSFILTER_INIT_REGCHANGE      0x00000002
#define DFSFILTER_INIT_SYMLINK        0x00000004

NTSTATUS
DfsCheckReparse( 
    PUNICODE_STRING pParent,
    PUNICODE_STRING pName );


NTSTATUS
DfsFilterCreateCheck(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);


NTSTATUS
DfsCheckDfsShare(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    PIRP Irp,
    IN OUT PIO_STATUS_BLOCK pIoStatusBlock);


//
//  Buffer size for local names on the stack
//

#define MAX_DEVNAME_LENGTH 128


DWORD DFSInitilizationStatus = 0;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING  RegistryPath);

#if defined (DEBUG)
VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject );

#endif

VOID
DfsInitUnwind(
    IN PDRIVER_OBJECT DriverObject);

VOID
DfsFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive );


NTSTATUS
DfsAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject );

VOID
DfsDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject );

NTSTATUS
DfsEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject );



NTSTATUS
DfsAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT DfsFilterDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject );

VOID
DfsGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name );


NTSTATUS
DfsMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

NTSTATUS
DfsLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context );

BOOLEAN
DfsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject, 
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL);

NTSTATUS
DfsPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp );


NTSTATUS
DfsFilterCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);


NTSTATUS 
DfsHandlePrivateOpen(IN PIRP Irp);

NTSTATUS
DfsFilterCleanupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
DfsHandlePrivateFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PIRP Irp );

NTSTATUS
DfsFilterFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);


NTSTATUS
DfsFsctrlIsShareInDfs(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS 
DfsAttachToFileSystem (
    IN PWSTR UserDeviceName);

NTSTATUS
DfsDetachFromFileSystem (
    IN PWSTR UserDeviceName);

NTSTATUS
DfsHandleAttachToFs(PVOID InputBuffer, 
                    ULONG InputBufferSize);


NTSTATUS
DfsHandleDetachFromFs(PVOID InputBuffer, 
                      ULONG InputBufferLength);

NTSTATUS
DfsGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    );


NTSTATUS
DfsRunDownPrefixTable(void);

NTSTATUS 
DfsHandlePrivateCleanupClose(IN PIRP Irp);

void
DfsPrefixRundownFunction(PVOID pEntry);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry)
#if defined (DEBUG)
#pragma alloc_text( PAGE, DriverUnload)
#endif
#pragma alloc_text( PAGE, DfsInitUnwind)
#pragma alloc_text( PAGE, DfsFsNotification )
#pragma alloc_text( PAGE, DfsAttachToFileSystemDevice )
#pragma alloc_text( PAGE, DfsDetachFromFileSystemDevice )
#pragma alloc_text( PAGE, DfsEnumerateFileSystemVolumes )
#pragma alloc_text( PAGE, DfsAttachToMountedDevice )
#pragma alloc_text( PAGE, DfsGetObjectName )
#pragma alloc_text( PAGE, DfsMountCompletion )
#pragma alloc_text( PAGE, DfsLoadFsCompletion )
#pragma alloc_text( PAGE, DfsAttachedToDevice )
#pragma alloc_text( PAGE, DfsFilterCreate )
#pragma alloc_text( PAGE, DfsFilterCleanupClose )
#pragma alloc_text( PAGE, DfsFilterFsControl )
#pragma alloc_text( PAGE, DfsHandlePrivateFsControl )
#pragma alloc_text( PAGE, DfsFsctrlIsShareInDfs )
#pragma alloc_text( PAGE, DfsGetDeviceObjectFromName)
#pragma alloc_text( PAGE, DfsAttachToFileSystem)
#pragma alloc_text( PAGE, DfsDetachFromFileSystem)
#pragma alloc_text( PAGE, DfsHandleAttachToFs)
#pragma alloc_text( PAGE, DfsHandleDetachFromFs)
#pragma alloc_text( PAGE, DfsHandlePrivateCleanupClose)
#pragma alloc_text( PAGE, DfsHandlePrivateOpen)
#pragma alloc_text( PAGE, DfsRunDownPrefixTable)
#pragma alloc_text( PAGE, DfsPrefixRundownFunction)
#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DriverEntry, main entry point
//
//  Synopsis:   This is the initialization routine for the DFS file system
//      device driver.  This routine creates the device object for
//      the FileSystem device and performs all other driver
//      initialization.
//
//  Arguments:  [DriverObject] -- Pointer to driver object created by the
//          system.
//
//  Returns:    [NTSTATUS] - The function value is the final status from
//          the initialization operation.
//
//--------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING NameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG i = 0;

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    //
    // Create the filesystem device object.
    //

    RtlInitUnicodeString( &NameString, DFS_FILTER_NAME );
    Status = IoCreateDevice( DriverObject,
                             0,
                             &NameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &DfsGlobalData.pFilterControlDeviceObject);

    if ( !NT_SUCCESS( Status ) ) {

        DbgPrint("Driverentry IoCreateDevice failed %X\n", Status);
        return Status;
    }

    DfsGlobalData.pFilterDriverObject = DriverObject;
    ExInitializeResourceLite( &DfsGlobalData.Resource );
    InitializeListHead( &DfsGlobalData.DfsVolumeList);

#if defined (DEBUG)
    DriverObject->DriverUnload = DriverUnload;
#endif

    try
    {

        //
        // Initialize the driver object with this driver's entry points.
        // Most are simply passed through to some other device driver.
        //

        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
            DriverObject->MajorFunction[i] = DfsPassThrough;
        }

        DriverObject->MajorFunction[IRP_MJ_CREATE] = DfsFilterCreate;
        DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = DfsFilterFsControl;
        DriverObject->MajorFunction[IRP_MJ_CLEANUP] = DfsFilterCleanupClose;
        DriverObject->MajorFunction[IRP_MJ_CLOSE] = DfsFilterCleanupClose;

        DriverObject->FastIoDispatch = &DfsFastIoDispatch;


        Status = IoRegisterFsRegistrationChange( DriverObject, 
                                                 DfsFsNotification );
        if (NT_SUCCESS (Status)) {
            DFSInitilizationStatus |= DFSFILTER_INIT_REGCHANGE;
            Status = DfsInitializeUmrResources();
        }
    }
    finally
    {
        if (Status != STATUS_SUCCESS) 
        {

           DbgPrint("Driverentry status not success %X\n", Status);
           DfsInitUnwind(DriverObject);
        }
    }

    DfsGlobalData.CurrentProcessPointer = (PVOID)PsGetCurrentProcess();
    DfsGlobalData.IsDC = FALSE;
    DfsGlobalData.ServiceProcess = NULL;
    DfsGlobalData.Started = FALSE;
    ClearFlag( DfsGlobalData.pFilterControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}


VOID
DfsInitUnwind(IN PDRIVER_OBJECT DriverObject)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING  UserModeDeviceName;

    PAGED_CODE();

    if(DFSInitilizationStatus & DFSFILTER_INIT_REGCHANGE)
    {
        IoUnregisterFsRegistrationChange( DriverObject, DfsFsNotification );
    }

    IoDeleteDevice ( DfsGlobalData.pFilterControlDeviceObject );
}



#if defined (DEBUG)

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can not be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject )
{
    PDFS_FILTER_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == DfsGlobalData.pFilterDriverObject);

    //
    //  Log we are unloading
    //

    DbgPrint( "SFILTER: Unloading driver (%p)\n",DriverObject);

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, DfsFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.
        //

        status = IoEnumerateDeviceObjectList(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->pAttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a refrence count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reonsable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed during high stress
        //           situations.  The system will fault if this occurs.  This
        //           is a sample of how to do this during testing.  This is
        //           not recommended for production code.
        //

        interval.QuadPart = -5 * (10 * 1000 * 1000);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that refrences it.
            //

            if (NULL == devList[i]->DeviceExtension) {

                ASSERT(devList[i] == DfsGlobalData.pFilterControlDeviceObject);
                DfsGlobalData.pFilterControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove refrence counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the refrence count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;


    DfsDeInitializeUmrResources();
}

#endif


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsNotification
//
//  Arguments:
//       DeviceObject - Pointer to the file system's device object.
//
//       FsActive - Boolean indicating whether the file system has registered
//        (TRUE) or unregistered (FALSE) itself as an active file system.
//
//
//  Returns:    NONE
//
//  Description: 
//  This routine is invoked whenever a file system has either registered or
//  unregistered itself as an active file system.
//
//  For the former case, this routine creates a device object and attaches it
//  to the specified file system's device object.  This allows this driver
//  to filter all requests to that file system.  Specifically we are looking
//  for MOUNT requests so we can attach to newly mounted volumes.
//
//  For the latter case, this file system's device object is located,
//  detached, and deleted.  This removes this file system as a filter for
//  the specified file system.
//--------------------------------------------------------------------------


VOID
DfsFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive )

{

    PAGED_CODE();

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsFsNotification %p, %x\n", 
                  DeviceObject, FsActive);

    //
    //  Handle attaching/detaching from the given file system.
    //

    if (FsActive) {
        
        DfsAttachToFileSystemDevice( DeviceObject );

    } else {

        DfsDetachFromFileSystemDevice( DeviceObject );
    }
}


/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new volumes are mounted.

Arguments:


    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
           This is passed in to reduce the number of strings buffers on
           the stack.

Return Value:

    Status of the operation

--*/
NTSTATUS
DfsAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject )

{
    PDEVICE_OBJECT newDeviceObject;
    PDEVICE_OBJECT attachedToDevObj;
    PDFS_FILTER_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;
    WCHAR nameBuffer[MAX_DEVNAME_LENGTH];
    UNICODE_STRING Name;

    RtlInitEmptyUnicodeString( &Name, nameBuffer, sizeof(nameBuffer));

    PAGED_CODE();

    //
    //  See if this is a file system type we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if we should attach to recognizers or not
    //
    if (!DfsDebugAttachToFsRecognizer) {

        //
        //  See if this is one of the standard Microsoft file system recognizer
        //  devices (see if this device is in the FS_REC driver).  If so skip it.
        //  We no longer attach to file system recognizer devices, we simply wait
        //  for the real file system driver to load.
        //

        RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
        DfsGetObjectName( DeviceObject->DriverObject, &Name );
        if (RtlCompareUnicodeString( &Name, &fsrecName, TRUE ) == 0) {

            return STATUS_SUCCESS;
        }
    }

    //
    //  We want to attach to this file system.  Create a new device object we
    //  can attach with.
    //

    status = IoCreateDevice( DfsGlobalData.pFilterDriverObject,
                             sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Do the attachment
    //

    attachedToDevObj = IoAttachDeviceToDeviceStack( newDeviceObject, DeviceObject );

    if (attachedToDevObj == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializing our device extension
    //

    devExt = newDeviceObject->DeviceExtension;
    devExt->pAttachedToDeviceObject = attachedToDevObj;
    devExt->pThisDeviceObject = newDeviceObject;
    devExt->Attached = TRUE;
    
    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

#if 0
    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = DfsEnumerateFileSystemVolumes( DeviceObject );

    if (!NT_SUCCESS( status )) {

        goto ErrorCleanupAttachment;
    }
#endif
    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////



    ErrorCleanupDevice:
        IoDeleteDevice( newDeviceObject );


        DFS_TRACE_LOW(KUMR_DETAIL, "attach to file system device %p dfs object %p, status %x\n",
                      DeviceObject,
                      newDeviceObject,
                      status);

    return status;
}


/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 

VOID
DfsDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject )
{
    PDEVICE_OBJECT ourAttachedDevice;
    PDFS_FILTER_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  Skip the base file system device object (since it can't be us)
    //
    DFS_TRACE_LOW(KUMR_DETAIL, "detach from File system device %p\n",
                  DeviceObject);



    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_MY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}



/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer that
           receives the name of the object.

Return Value:

    None

--*/

VOID
DfsGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name )
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}







/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  This
    simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the event to syncwith

--*/
NTSTATUS
DfsCompleteMountRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )
{

    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT pDiskDeviceObject;
    DFS_TRACE_HIGH( KUMR_DETAIL, "Processing mount complete %p, %p\n", DeviceObject, Context);

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    if (NT_SUCCESS( Irp->IoStatus.Status))
    {
        pDiskDeviceObject = Context;

        if ((pDiskDeviceObject->Vpb != NULL) &&
            (pDiskDeviceObject->Vpb->DeviceObject != NULL)) {
            DfsReattachToMountedVolume( pDiskDeviceObject->Vpb->DeviceObject,
                                        pDiskDeviceObject );
        }
    }

    //
    // If pending was returned, then propogate it to the caller.
    //

    if (Irp->PendingReturned) {
            IoMarkIrpPending( Irp );
    }

    DFS_TRACE_HIGH( KUMR_DETAIL, "Processing mount complete done\n");

    return( STATUS_SUCCESS );
}


/*++

Routine Description:

    This routine is invoked for the completion of a LoadFileSystem request.
    This simply re-syncs back to the dispatch routine so the operation can be
    completed.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Pointer to the event to syncwith

Return Value:

    The function value for this routine is always success.

--*/

NTSTATUS
DfsLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context )
{
    PKEVENT event = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.

Arguments:

    DeviceObject - The device chain we want to look through

Return Value:

    TRUE if we are attached, FALSE if not

--*/

BOOLEAN
DfsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL )
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.

    do {
    
        if (IS_MY_DEVICE_OBJECT( currentDevObj )) 
        {
            //
            //  We have found that we are already attached.  If we are
            //  returning the device object we are attached to then leave the
            //  refrence on it.  If not then remove the refrence.
            //

            if (AttachedDeviceObject != NULL) 
            {
                *AttachedDeviceObject = currentDevObj;
            } 
            else 
            {
                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}    


/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    A note to filter file system implementers:  
        This routine actually "passes" through the request by taking this
        driver out of the IRP stack.  If the driver would like to pass the
        I/O request through, but then also see the result, then rather than
        taking itself out of the loop it could keep itself in by copying the
        caller's parameters to the next stack location and then set its own
        completion routine.  

        Hence, instead of calling:
    
            IoSkipCurrentIrpStackLocation( Irp );

        You could instead call:

            IoCopyCurrentIrpStackLocationToNext( Irp );
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE );


        This example actually NULLs out the caller's I/O completion routine, but
        this driver could set its own completion routine so that it would be
        notified when the request was completed (see SfCreate for an example of
        this).

--*/


NTSTATUS
DfsPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp )
{
    VALIDATE_IRQL(Irp);

    //
    //  If this is for our control device object, fail the operation
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) {

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );
    
    //
    //  Call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject, Irp );
}


NTSTATUS 
DfsHandlePrivateOpen(IN PIRP Irp)
{
    NTSTATUS               Status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION     pIrpSp = NULL;
    LONG                   TheSame = 0; 
    UNICODE_STRING         TermPath;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    pIrpSp = IoGetCurrentIrpStackLocation( Irp );

    if(pIrpSp->FileObject->FileName.Length == 0)
    {
        return Status;
    }

    RtlInitUnicodeString( &TermPath, DFSFILTER_PROCESS_TERMINATION_FILEPATH);
    TheSame = RtlCompareUnicodeString( &pIrpSp->FileObject->FileName, &TermPath, TRUE );
    if(TheSame == 0)
    {    
        FsRtlEnterFileSystem();
        ACQUIRE_GLOBAL_LOCK();
    
        if(DfsGlobalData.ServiceProcess == NULL)
        {
            DfsGlobalData.ServiceProcess = IoGetCurrentProcess();
        }
        else
        {
            Status = STATUS_ACCESS_DENIED;
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandlePrivateOpen  %x\n", Status);
        }

        RELEASE_GLOBAL_LOCK();
        FsRtlExitFileSystem();
    }

    return Status;
}

/*++

Routine Description:

    This function filters create/open operations.  It simply establishes an
    I/O completion routine to be invoked if the operation was successful.

Arguments:

    DeviceObject - Pointer to the target device object of the create/open.

    Irp - Pointer to the I/O Request Packet that represents the operation.

Return Value:

    The function value is the status of the call to the file system's entry
    point.

--*/

NTSTATUS
DfsFilterCreate (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION     pIrpSp = NULL;
    KEVENT WaitEvent;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(pDeviceObject)) 
    {

        pIrpSp = IoGetCurrentIrpStackLocation( pIrp );

        Status = DfsHandlePrivateOpen(pIrp);

        pIrp->IoStatus.Status = Status;

        if(Status == STATUS_SUCCESS)
        {
            pIrp->IoStatus.Information = FILE_OPENED;
        }
        else
        {
            pIrp->IoStatus.Information = 0;
        }

        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
        return Status;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( pDeviceObject ));

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    
    //
    // If the the file is not being opened with FILE_OPEN_REPARSE_POINT 
    // then set a completion routine
    //
    if (!(pIrpSp->Parameters.Create.Options & FILE_OPEN_REPARSE_POINT))
    {

       KeInitializeEvent(&WaitEvent, SynchronizationEvent, FALSE);

       //
       //  Copy the stack and set our Completion routine
       //

       IoCopyCurrentIrpStackLocationToNext( pIrp );


       IoSetCompletionRoutine (pIrp,
                               DfsFilterCreateCheck,
                               &WaitEvent,
                               TRUE,        // Call on success
                               TRUE,        // fail
                               TRUE) ;      // and on cancel

    
       Status = IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) pDeviceObject->DeviceExtension)->pAttachedToDeviceObject, pIrp );
       if(Status == STATUS_PENDING)
       {
           //
           // We wait for the event to be set by the
           // completion routine.

           // 555624, Since we wait here, we do not propagate IRP pending
           // flag in the completion routine.
           //

           KeWaitForSingleObject( &WaitEvent,
                                  UserRequest,
                                  KernelMode,
                                  FALSE,
                                  (PLARGE_INTEGER) NULL );
       }

       Status = pIrp->IoStatus.Status;

       //
       // This IRP never completed. Complete it now
       //
       IoCompleteRequest(pIrp,
                         IO_NO_INCREMENT);
    } 
    else {

        //
        //  Don't put us on the stack then call the next driver
        //

        IoSkipCurrentIrpStackLocation( pIrp );

        Status = IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) pDeviceObject->DeviceExtension)->pAttachedToDeviceObject, pIrp );
    }

    return Status;
}


/*++

Routine Description:

   This completion routine will be called by the I/O manager when an
   file create request has been completed by a filtered driver. If the
   returned code is a reparse error and it is a DFS reparse point then
   we must set up for returning PATH_NOT_COVERED.

Arguments:

   DeviceObject - Pointer to the device object (filter's) for this request

   Irp - Pointer to the Irp that is being completed

   Context - Driver defined context - 

Return Value:

   STATUS_SUCCESS           - Recall is complete
   STATUS_MORE_PROCESSING_REQUIRED  - Open request was sent back to file system
--*/

NTSTATUS
DfsFilterCreateCheck(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{
    PREPARSE_DATA_BUFFER   pHdr;
    PKEVENT                pEvent = Context;


   if (Irp->IoStatus.Status == STATUS_REPARSE) {
        pHdr = (PREPARSE_DATA_BUFFER) Irp->Tail.Overlay.AuxiliaryBuffer;

        //
        // The REPARSE_DATA_BUFFER can be legally null for IO_REMOUNTs.
        //
        if ((pHdr != NULL) && (pHdr->ReparseTag == IO_REPARSE_TAG_DFS)) {
           //DbgPrint("Reparse Tag is DFS: returning path not covered\n");
           Irp->IoStatus.Status = STATUS_PATH_NOT_COVERED; 
        }
   }

   //
   // Propogate the IRP pending flag.
   //
   // 555624, do not propagate IRP pending since DFS is
   // synchronizing on this call.
   // if (Irp->PendingReturned) {
   //   IoMarkIrpPending( Irp );
   // }

   KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);
   //
   // This packet would be completed by RsCreate
   //
   return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
DfsIsServiceAttached(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsIsServiceAttached\n");

    ExAcquireResourceSharedLite(&DfsGlobalData.Resource, TRUE);

    if(DfsGlobalData.ServiceProcess != IoGetCurrentProcess())
    {
        Status = STATUS_ACCESS_DENIED;
    }

    ExReleaseResourceLite(&DfsGlobalData.Resource);

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsIsServiceAttached Status = %x\n", Status );
    return Status;
}

void 
DfsPrefixRundownFunction (PVOID pEntry)
{
    PWSTR VolumeName = (PWSTR) pEntry;

    if(VolumeName != NULL)
    {
       DfsDetachFromFileSystem(VolumeName);
       ExFreePool(pEntry);
    }

    return;
}

NTSTATUS
DfsRunDownPrefixTable(void)
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(pPrefixTable == NULL)
    {
        return Status;
    }

    DfsDismantlePrefixTable(pPrefixTable, DfsPrefixRundownFunction);


    DfsDereferencePrefixTable(pPrefixTable); 

    pPrefixTable = NULL;

    gfRundownPrefixCompleted = TRUE;

    return Status;
}

NTSTATUS 
DfsHandlePrivateCleanupClose(IN PIRP Irp)
{
    NTSTATUS               Status   = STATUS_SUCCESS;
    PIO_STACK_LOCATION     pIrpSp = NULL;
    LONG                   TheSame = 0; 
    UNICODE_STRING         TermPath;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    pIrpSp = IoGetCurrentIrpStackLocation( Irp );

    if(pIrpSp->FileObject->FileName.Length == 0)
    {
        return Status;
    }

    RtlInitUnicodeString( &TermPath, DFSFILTER_PROCESS_TERMINATION_FILEPATH);
    TheSame = RtlCompareUnicodeString( &pIrpSp->FileObject->FileName, &TermPath, TRUE );
    if(TheSame == 0)
    {         
        if(g_pUMRxEngine)
        {
            UMRxEngineCompleteQueuedRequests( g_pUMRxEngine,
                                              STATUS_CANCELLED,
                                              TRUE);
        }

        FsRtlEnterFileSystem();
        ACQUIRE_GLOBAL_LOCK();


        if( pPrefixTable)
        {
            DfsRunDownPrefixTable();
        }
    
        DfsGlobalData.ServiceProcess = NULL;
        DfsGlobalData.Started = FALSE;

        RELEASE_GLOBAL_LOCK();
        FsRtlExitFileSystem();
    }

    return Status;
}
/*++

Routine Description:

    This routine is invoked whenever a cleanup or a close request is to be
    processed.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    See notes for SfPassThrough for this routine.


--*/

NTSTATUS
DfsFilterCleanupClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    PAGED_CODE();
    VALIDATE_IRQL(Irp);


    //
    //  If this is for our control device object, return success
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) 
    {
        DfsHandlePrivateCleanupClose(Irp);

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Get this driver out of the driver stack and get to the next driver as
    //  quickly as possible.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    //
    //  Now call the appropriate file system driver with the request.
    //

    return IoCallDriver( ((PDFS_FILTER_DEVICE_EXTENSION) DeviceObject->DeviceExtension)->pAttachedToDeviceObject, Irp );
}



NTSTATUS
DfsFsctrlIsShareInDfs(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    PDFS_IS_SHARE_IN_DFS_ARG arg = (PDFS_IS_SHARE_IN_DFS_ARG) InputBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID pDummyData = NULL;  //not used
    BOOLEAN NotUsed = FALSE;  //not used
    UNICODE_STRING Suffix;    //not used
    UNICODE_STRING ShareName;    
    KPROCESSOR_MODE PreviousMode;
    
    DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl is share in DFS\n");

    ExAcquireResourceSharedLite(&DfsGlobalData.Resource, TRUE);

    RtlInitUnicodeString(&ShareName, NULL);

    //
    // This can only be called from Kernel mode.
    //
    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) 
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Verify the buffer is at least of size DFS_IS_SHARE_IN_DFS_ARG
    //
    if (InputBufferLength < sizeof(DFS_IS_SHARE_IN_DFS_ARG))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if(pPrefixTable == NULL)
    {
        Status = STATUS_NO_SUCH_DEVICE;
        goto Exit;
    }

    if (DfsGlobalData.CurrentProcessPointer != (PVOID)PsGetCurrentProcess())
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    ShareName = arg->ShareName;

    if(ShareName.Buffer != NULL)
    {
        Status = DfsFindUnicodePrefix(pPrefixTable, 
                                      &ShareName,
                                      &Suffix,
                                      &pDummyData);
        if(Status == STATUS_SUCCESS)
        {
            arg->ShareType = DFS_SHARE_TYPE_DFS_VOLUME;

            arg->ShareType |= DFS_SHARE_TYPE_ROOT;
        }
        else
        {
            Status = STATUS_NO_SUCH_DEVICE;
        }
    }
    else
    {
        RtlInitUnicodeString(&ShareName, NULL);
        Status = STATUS_INVALID_USER_BUFFER;
    }

Exit:

    ExReleaseResourceLite(&DfsGlobalData.Resource);

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsFsctrlIsShareInDfs for shareName %wZ, Status %x\n",
                  &ShareName, Status );

    return( Status );
}

#define UNICODE_PATH_SEP  L'\\'
#define UNICODE_PATH_SEP_STR L"\\"

BOOLEAN
DfsConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
) {
    PWSTR  OutBuf = (PWSTR)&(((PCHAR)Dest->Buffer)[Dest->Length]);

    if (Dest->Length > 0) {
        ASSERT(OutBuf[-1] != UNICODE_NULL);
    }

    if (Dest->Length > 0 && OutBuf[-1] != UNICODE_PATH_SEP) {
        *OutBuf++ = UNICODE_PATH_SEP;
        Dest->Length += sizeof (WCHAR);
    }

    if (Length > 0 && *RemainingPath == UNICODE_PATH_SEP) {
        RemainingPath++;
        Length -= sizeof (WCHAR);
    }

    ASSERT(Dest->MaximumLength >= (USHORT)(Dest->Length + Length));

    if (Length > 0) {
        RtlMoveMemory(OutBuf, RemainingPath, Length);
        Dest->Length += Length;
    }
    return TRUE;
}


void
RemoveLastComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix,
    BOOL StripTrailingSlahes
)
{
    PWCHAR      pwch;
    USHORT      i=0;

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch += (Prefix->Length/sizeof(WCHAR)) - 1;

    while ((*pwch != UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  
    {
        i += sizeof(WCHAR);
        pwch--;
    }

    newPrefix->Length = newPrefix->Length - i;

    if(StripTrailingSlahes)
    {
        while ((*pwch == UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  
        {
            newPrefix->Length -= sizeof(WCHAR);
            pwch--;
        }
    }
}

NTSTATUS
DfspFormPrefix(
    IN PUNICODE_STRING ParentPath,
    IN PUNICODE_STRING DfsPathName,
    IN OUT PUNICODE_STRING Prefix)
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SizeRequired = 0;

    //
    // RtlAppend below expects this to be zero
    // in order for the logic to work.
    //
    Prefix->Length = 0;
    
    SizeRequired = sizeof(UNICODE_PATH_SEP) +
                        ParentPath->Length +
                           sizeof(UNICODE_PATH_SEP) +
                               DfsPathName->Length;


    if (SizeRequired > MAXUSHORT) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;

    }

    if (SizeRequired > Prefix->MaximumLength) 
    {
        Prefix->MaximumLength = (USHORT)SizeRequired;

        Prefix->Buffer = ExAllocatePoolWithTag(NonPagedPool, SizeRequired, ' sfD');
    }


    if (Prefix->Buffer != NULL) 
    {
        RtlAppendUnicodeToString(
                Prefix,
                UNICODE_PATH_SEP_STR);

        if (ParentPath->Length > 0) 
          {

            DfsConcatenateFilePath(
                    Prefix,
                    ParentPath->Buffer,
                    (USHORT) (ParentPath->Length));

        } 

        DfsConcatenateFilePath(
            Prefix,
            DfsPathName->Buffer,
            DfsPathName->Length);

        Status = STATUS_SUCCESS;

    } 
    else 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
DfsGetPathComponentsPriv(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining)
{
   USHORT i = 0, j;
   DFSSTATUS Status = STATUS_INVALID_PARAMETER;

   RtlInitUnicodeString(pServerName, NULL);
   if (pShareName)    RtlInitUnicodeString(pShareName, NULL);
   if (pRemaining)    RtlInitUnicodeString(pRemaining, NULL);

   for (; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if (j != i) {
     pServerName->Buffer = &pName->Buffer[i];
     pServerName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pServerName->MaximumLength = pServerName->Length;
     
     Status = STATUS_SUCCESS;
   }
   
   for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }
   for (j = i; j < pName->Length/sizeof(WCHAR); j++) {
     if (pName->Buffer[j] == UNICODE_PATH_SEP) {
       break;
     }
   }

   if ((pShareName) && (j != i)) {
     pShareName->Buffer = &pName->Buffer[i];
     pShareName->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pShareName->MaximumLength = pShareName->Length;
   }


   for (i = j; i < pName->Length/sizeof(WCHAR); i++) {
     if (pName->Buffer[i] != UNICODE_PATH_SEP) {
       break;
     }
   }

   j = pName->Length/sizeof(WCHAR);

   if (pRemaining)
   {
       pRemaining->Buffer = &pName->Buffer[i];
   }

   if ((pRemaining) && (j != i)) {

     pRemaining->Length = (USHORT)((j - i) * sizeof(WCHAR));
     pRemaining->MaximumLength = pRemaining->Length;
   }

   return Status;

}

NTSTATUS
DfsFsctrlTranslatePath(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_TRANSLATE_PATH_ARG arg = (PDFS_TRANSLATE_PATH_ARG) InputBuffer;
    WCHAR nameBuffer[MAX_PATH];
    UNICODE_STRING prefix;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RemainingName;
    UNICODE_STRING LastComponent;
    KPROCESSOR_MODE PreviousMode;


    DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl translate path\n");

    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    if(InputBufferLength < sizeof(DFS_TRANSLATE_PATH_ARG))
    {
        Status = STATUS_INVALID_USER_BUFFER; 
        return Status;
    }

    RtlZeroMemory( &prefix, sizeof(prefix) );

    prefix.Length = 0;
    prefix.MaximumLength = sizeof( nameBuffer );
    prefix.Buffer = nameBuffer;

    Status = DfspFormPrefix(
                &arg->ParentPathName,
                &arg->DfsPathName,
                &prefix);

    DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl translate path: arg->DfsPathName is %wZ\n",
                  &arg->DfsPathName);

    if (NT_SUCCESS(Status)) 
    {  
         DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl translate path: Total Path is %wZ\n",
                  &prefix);

        if (arg->Flags & DFS_TRANSLATE_STRIP_LAST_COMPONENT) 
        {
            LastComponent = prefix;

            RemoveLastComponent(&LastComponent, &prefix, FALSE);

            LastComponent.Length -= prefix.Length;
            LastComponent.MaximumLength -= prefix.Length;
            LastComponent.Buffer += (prefix.Length / sizeof(WCHAR));

            DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl translate path: new Total Path is %wZ, LastComp is %wZ\n",
                          &prefix, &LastComponent);

        }


        DfsGetPathComponentsPriv(&prefix, &ServerName, &ShareName, &RemainingName);            

        DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl translate path: TotalPath is %wZ, RemainingName is %wZ\n",
                       &prefix, &RemainingName);


        Status = DfsCheckReparse( &arg->SubDirectory,
                                  &RemainingName );

        //
        // For DfsPathName which is relative to some parent
        // path, we don't need to adjust the DfsPathName
        //                
        if (arg->ParentPathName.Length == 0) 
        {
            if (arg->Flags & DFS_TRANSLATE_STRIP_LAST_COMPONENT) 
            {            
                if (RemainingName.Length == 0)
                {
                    RemainingName.Buffer = LastComponent.Buffer;
                }
                RemainingName.Length += LastComponent.Length;
            }
            arg->DfsPathName.Length = RemainingName.Length;

            if (RemainingName.Length > 0)
            {
                RtlMoveMemory(
                    arg->DfsPathName.Buffer,
                    RemainingName.Buffer,
                    RemainingName.Length);
            }

            arg->DfsPathName.Buffer[
                    arg->DfsPathName.Length/sizeof(WCHAR)] = UNICODE_NULL;
        }

    }
    
    if (prefix.Buffer != NULL && prefix.Buffer != nameBuffer) 
    {
        ExFreePool( prefix.Buffer );
    }

    DFS_TRACE_LOW(KUMR_DETAIL, "Fsctrl translate path Parent Path %wZ, DfsPathName %wZ, Status %x\n",
                  &arg->ParentPathName, &arg->DfsPathName, Status);    
    
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCheckParse - check if the path crosses a dfs link.
//
//  Arguments:  
//    PUNICODE_STRING pParent - the shared out directory.
//    PUNICODE_STRING pName - the directory hierarchy relative to parent.
//
//  Returns:    Status
//               ERROR_PATH_NOT_COVERED - if link
//               ERROR_SUCCESS - otherwise.
//
//  Description: This routine currently opens the passed in file, and
//               returns the open status if it is PATH_NOT_COVERED.
//               Otherwise it return STATUS_SUCCESS.
//
//
//               This should not have been necessary. When the server
//               gets a query path from the client, it calls DFS to
//               see if this is a link. however, in this new dfs, we
//               use reparse points, so this mechanism of the server
//               querying DFS should not be necessary. The server should
//               get STATUS_PATH_NOT_COVERED during the query path, and
//               return that to the client.
//
//               It turns out that the server (including an io manager api)
//               do a create file with FILE_OPEN_REPARSE_POINT when getting
//               the file attributes. This completely bypasses the DFS
//               mechanism of returning STATUS_PATH_NOT_COVERED, so the 
//               query path actually succeeds even for links!
//               This results in the client coming in with a findfirst
//               which fails, and for some reason that failure does not
//               result in the DFS on the  client attempting to get
//               referrals.
//
//               All of the above needs investigation and fixing.
//               This code will work in the meanwhile. Its not very
//               effective on performance to have this code.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsCheckReparse( 
    PUNICODE_STRING pParent,
    PUNICODE_STRING pName )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE              ParentHandle, Handle;
    IO_STATUS_BLOCK     IoStatus;


    InitializeObjectAttributes(
        &ObjectAttributes,
        pParent,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = ZwCreateFile( &ParentHandle,
                           FILE_READ_ATTRIBUTES,
                           &ObjectAttributes,
                           &IoStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_OPEN,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0);
    
    if (Status == STATUS_SUCCESS)
    {
        InitializeObjectAttributes(
            &ObjectAttributes,
            pName,
            OBJ_CASE_INSENSITIVE,
            ParentHandle,
            NULL);


        Status = ZwCreateFile( &Handle,
                               FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                               FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0);
        ZwClose( ParentHandle );
    }

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsCheckreparse for ParentName %wZ, pName %wZ, Status %x\n",
                  pParent, pName, Status );
             
    if (Status == STATUS_SUCCESS)
    {
        ZwClose(Handle);
    }
    else if (Status != STATUS_PATH_NOT_COVERED)
    {
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
DfsInitializeDriver(    IN PVOID InputBuffer,
                        IN ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_FILTER_STARTUP_INFO pStartupInfo = (PDFS_FILTER_STARTUP_INFO) InputBuffer;

    PAGED_CODE();

    ACQUIRE_GLOBAL_LOCK();

    if(DfsGlobalData.ServiceProcess != IoGetCurrentProcess())
    {
        Status = STATUS_ACCESS_DENIED;
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsInitializeDriver service not attached %x\n", Status);
        goto Exit;
    }

    if(DfsGlobalData.Started == TRUE)
    {
        Status = STATUS_ACCESS_DENIED;
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsInitializeDriver service already started %x\n", Status);
        goto Exit;
    }

    DfsGlobalData.Started = TRUE;

    //see if the raw inputs are valid
    if( (InputBuffer == NULL) ||
         (InputBufferLength <= 0) ||
         (InputBufferLength < sizeof(DFS_FILTER_STARTUP_INFO)))
    {
        Status = STATUS_INVALID_PARAMETER;
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsInitializeDriver buffer length checks failed  %x\n", Status);
        goto Exit;
    }
         
    if(!pPrefixTable)
    {
        DfsGlobalData.IsDC = pStartupInfo->IsDC;

        Status = DfsInitializePrefixTable(&pPrefixTable, FALSE, NULL);
        if (Status == STATUS_SUCCESS) 
        {
            Status = DfsStartupUMRx();
            DFS_TRACE_LOW(KUMR_DETAIL, "DfsInitializeDriver -  DfsStartupUMRx returned Status %x\n", Status);
        }
    }


    gfRundownPrefixCompleted = FALSE;

Exit:

    RELEASE_GLOBAL_LOCK();

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsInitializeDriver returned Status %x\n", Status);

    return Status;
}

NTSTATUS
DfsDeInitializeDriver(    IN PVOID InputBuffer,
                          IN ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = DfsIsServiceAttached();
    if(Status == STATUS_SUCCESS)
    {
        Status = DfsTeardownUMRx();

        ACQUIRE_GLOBAL_LOCK();

        Status = DfsRunDownPrefixTable();

        RELEASE_GLOBAL_LOCK();
    }

    return Status;
}


/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered for the DFS device.
Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
NTSTATUS
DfsHandlePrivateFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PIRP Irp )
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PAGED_CODE();

    DFS_TRACE_LOW(KUMR_DETAIL, "Handle Fs control, code: %x\n",
                  IoControlCode);
    //
    //  Need to disable Kernel APC delivery
    //
    FsRtlEnterFileSystem();

    IoStatus->Information = 0;

    switch(IoControlCode)
    {
    case DFSFILTER_START_UMRX:

        Status = DfsInitializeDriver(InputBuffer,
                                     InputBufferLength);

        break;

    case DFSFILTER_STOP_UMRX:

        Status = DfsDeInitializeDriver(InputBuffer,
                                       InputBufferLength);

        break;

    case DFSFILTER_PROCESS_UMRXPACKET:


        if(DfsIsServiceAttached() == STATUS_SUCCESS)
        {

            Status = DfsProcessUMRxPacket(
                                            InputBuffer,
                                            InputBufferLength,
                                            OutputBuffer,
                                            OutputBufferLength,
                                            IoStatus);
        }
        break;

    case FSCTL_DFS_GET_REFERRALS:

        Status = DfsFsctrlGetReferrals(
                                          InputBuffer,
                                          InputBufferLength,
                                          OutputBuffer,
                                          OutputBufferLength,
                                          Irp,
                                          IoStatus);
        break;

    case FSCTL_DFS_REPORT_INCONSISTENCY:

        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_TRANSLATE_PATH:

        Status = DfsFsctrlTranslatePath(InputBuffer, InputBufferLength);
        break;

    case FSCTL_DFS_IS_ROOT:

        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_IS_SHARE_IN_DFS:

        Status = DfsFsctrlIsShareInDfs(InputBuffer,InputBufferLength );
        break;

    case FSCTL_DFS_FIND_SHARE:

        Status = DfsCheckDfsShare( InputBuffer, 
                                   InputBufferLength,
                                   Irp,
                                   IoStatus );

        break;

    case DFSFILTER_ATTACH_FILESYSTEM:
        Status = DfsHandleAttachToFs(InputBuffer, InputBufferLength);
        break;

    case DFSFILTER_DETACH_FILESYSTEM:
        Status = DfsHandleDetachFromFs(InputBuffer, InputBufferLength);
        break;

    case FSCTL_DFS_START_DFS:

        Status = STATUS_SUCCESS;
        break;

    case FSCTL_DFS_STOP_DFS:

        Status = STATUS_SUCCESS;
        break;

    case  FSCTL_DFS_GET_VERSION:

        if (OutputBuffer != NULL &&
            OutputBufferLength >= sizeof(DFS_GET_VERSION_ARG)) 
        {
            PDFS_GET_VERSION_ARG parg =
                    (PDFS_GET_VERSION_ARG) OutputBuffer;
                    parg->Version = 2;
            Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof(DFS_GET_VERSION_ARG);
        } 
        else 
        {
            Status = STATUS_INVALID_PARAMETER;
        }
        break;

    default:

        break;
    }

    
    IoStatus->Status = Status;
    

    if(Irp != NULL)
    {
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    //
    // Re-enable Kernel APC delivery now.
    //
    FsRtlExitFileSystem();
    DFS_TRACE_LOW(KUMR_DETAIL, "Handle Fs control, code: %x, Status %x\n",
                  IoControlCode, Status);

    return Status;
}

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

NTSTATUS
DfsFilterFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp )
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Operation = 0;
    ULONG OutputBufferLength = 0;
    ULONG InputBufferLength = 0;
    PVOID InputBuffer = NULL;
    PVOID OutputBuffer = NULL;
    PDFS_FILTER_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT newDeviceObject = NULL;
    PDFS_FILTER_DEVICE_EXTENSION newDevExt = NULL;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB vpb;
    KEVENT waitEvent;

    PAGED_CODE();
    VALIDATE_IRQL(Irp);

    //
    //  If this is for our control device object
    //

    if (IS_MY_CONTROL_DEVICE_OBJECT(DeviceObject)) 
    {
        Operation = irpSp->Parameters.FileSystemControl.FsControlCode;
        InputBufferLength = irpSp->Parameters.FileSystemControl.InputBufferLength;
        OutputBufferLength = irpSp->Parameters.FileSystemControl.OutputBufferLength;        

        InputBuffer = Irp->AssociatedIrp.SystemBuffer;
        OutputBuffer = Irp->AssociatedIrp.SystemBuffer;

        status = DfsHandlePrivateFsControl (DeviceObject,
                                            Operation,
                                            InputBuffer,
                                            InputBufferLength,
                                            OutputBuffer,
                                            OutputBufferLength,
                                            &Irp->IoStatus,
                                            Irp );
        return status;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    if ((irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME))
    {

        //
        // We are processing a MOUNT/VERIFY request being directed to
        // another File System to which we have attached our own
        // Attach File System Object. We setup a completion routine
        // and forward the request.
        //
        IoCopyCurrentIrpStackLocationToNext( Irp );
        //
        // We want to pass the real device to our completion routine
        // so we can attach to the proper remounted device.


        IoSetCompletionRoutine(
            Irp,
            DfsCompleteMountRequest,
            irpSp->Parameters.MountVolume.Vpb->RealDevice,
            TRUE,
            TRUE,
            TRUE);

        //
        //  Call the underlying file system via its file system device
        //

        status = IoCallDriver( devExt->pAttachedToDeviceObject, Irp );

        DFS_TRACE_ERROR_HIGH(status, KUMR_DETAIL, "Mount Request processed\n");
        
        return status;

    } else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.
        //
        //  NOTE:  Since we no longer are attaching to the standard
        //         Microsoft file system recognizers (see 
        //         SfAttachToFileSystemDevice) we will normally never execute
        //         this code.  However, there might be 3rd party file systems
        //         which have their own recognizer which may still trigger this
        //         IRP.
        //



        //
        //  Set a completion routine so we can delete the device object when
        //  the load is complete.
        //

        KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine( Irp,
                                DfsLoadFsCompletion,
                                &waitEvent,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Detach from the file system recognizer device object.
        //

        IoDetachDevice( devExt->pAttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->pAttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

        if (STATUS_PENDING == status) {

            NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
            ASSERT(STATUS_SUCCESS == localStatus);
        }


        DbgPrint( "DFSFILTER: Detaching from recognizer  status=%08x\n", 
                  Irp->IoStatus.Status );
        //
        //  Check status of the operation
        //

        if (!NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            //  The load was not successful.  Simply reattach to the recognizer
            //  driver in case it ever figures out how to get the driver loaded
            //  on a subsequent call.
            //

            IoAttachDeviceToDeviceStack( DeviceObject, devExt->pAttachedToDeviceObject );

        } else {

            //
            //  The load was successful, delete the Device object
            //

            IoDeleteDevice( DeviceObject );
        }

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;

    } else {

        //
        //  Simply pass this file system control request through.
        //

        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    //  Any special processing has been completed, so simply pass the request
    //  along to the next driver.
    //

    return IoCallDriver( devExt->pAttachedToDeviceObject, Irp );
}



NTSTATUS
DfsGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    PFILE_OBJECT volumeFileObject = NULL;
    PDEVICE_OBJECT nextDeviceObject =NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;

    InitializeObjectAttributes( &objectAttributes,
                                                                DeviceName,
                                                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                                                NULL,
                                                                NULL);

    //
        // open the file object for the given device
        //

    Status = ZwCreateFile( &fileHandle,
                                                   SYNCHRONIZE|FILE_READ_DATA,
                                                   &objectAttributes,
                                                   &openStatus,
                                                   NULL,
                                                   0,
                                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                                   FILE_OPEN,
                                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                                   NULL,
                                                   0);

    if(!NT_SUCCESS( Status )) {

        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsGetDeviceObjectFromName ZwCreateFile failed  %x\n", Status);
        return Status;
    }

        //
    // get a pointer to the volumes file object
        //

    Status = ObReferenceObjectByHandle( fileHandle,
                                                                                FILE_READ_DATA,
                                                                                *IoFileObjectType,
                                                                                KernelMode,
                                                                                &volumeFileObject,
                                                                                NULL);

    if(!NT_SUCCESS( Status )) 
    {

        ZwClose( fileHandle );

        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsGetDeviceObjectFromName ObReferenceObjectByHandle failed  %x\n", Status);
        return Status;
    }

        //
    // Get the device object we want to attach to (parent device object in chain)
        //

    nextDeviceObject = IoGetRelatedDeviceObject( volumeFileObject );
    
    if (nextDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        Status = STATUS_NO_SUCH_DEVICE;
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsGetDeviceObjectFromName IoGetRelatedDeviceObject failed  %x\n", Status);
        return STATUS_NO_SUCH_DEVICE;
    }

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    ASSERT( NULL != DeviceObject );

    ObReferenceObject( nextDeviceObject );
    
    *DeviceObject = nextDeviceObject;

    return STATUS_SUCCESS;
}


LPWSTR DfsDeviceString = L"\\??\\x:\\";

NTSTATUS 
DfsAttachToFileSystem (
    IN PWSTR UserDeviceName )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_OBJECT NextDeviceObject = NULL;
    PDEVICE_OBJECT DiskDeviceObject = NULL;
    PDEVICE_OBJECT DfsDeviceObject = NULL;
    PDEVICE_OBJECT BaseFileSystemDeviceObject = NULL;
    PDFS_FILTER_DEVICE_EXTENSION pDeviceExt = NULL;

    PDFS_VOLUME_INFORMATION pDfsVolume;

    UNICODE_STRING DeviceName;

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsAttachToFileSystem %ws\n",
                  UserDeviceName);
    RtlInitUnicodeString( &DeviceName, UserDeviceName );

    DeviceName.Length = wcslen(DfsDeviceString) * sizeof(WCHAR);


    Status = DfsGetDeviceObjectFromName (&DeviceName, &NextDeviceObject);
    if (!NT_SUCCESS( Status )) 
    {
        DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsAttachToFileSystem DfsGetDeviceObjectFromName failed  %x\n", Status);
        return Status;
    }

    if(!DfsAttachedToDevice(NextDeviceObject, &DfsDeviceObject))
    {
        //
        //  We want to attach to this file system.  Create a new device object we
        //  can attach with.
        //
        Status = IoCreateDevice( DfsGlobalData.pFilterDriverObject,
                                 sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                                 NULL,
                                 NextDeviceObject->DeviceType,
                                 0,
                                 FALSE,
                                 &DfsDeviceObject );

        if (!NT_SUCCESS( Status )) 
        {
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsAttachToFileSystem IoCreateDevice failed  %x\n", Status);
            return Status;
        }

        //
        //  Get the disk device object associated with this file system
        //  device object.  Only try to attach if we have a disk device object.
        //  It may not have a disk device object for the following reasons:
        //  - It is a control device object for a driver
        //  - There is no media in the device.
        //

        //  We first have to get the base file system device object.  After
        //  using it we remove the refrence by the call.
        //

        
        BaseFileSystemDeviceObject = IoGetDeviceAttachmentBaseRef( NextDeviceObject );
        Status = IoGetDiskDeviceObject( BaseFileSystemDeviceObject, &DiskDeviceObject );
        ObDereferenceObject( BaseFileSystemDeviceObject );

        if (NT_SUCCESS(Status)) {
            ObDereferenceObject( DiskDeviceObject );

            Status = DfsGetDfsVolume( &DeviceName, 
                                      &pDfsVolume );
        }

        if (NT_SUCCESS(Status))
        {
            pDeviceExt = DfsDeviceObject->DeviceExtension;
            //
            //  Call the routine to attach to a mounted device.
            //

            Status = IoAttachDeviceToDeviceStackSafe( DfsDeviceObject,
                                                      NextDeviceObject,
                                                      &pDeviceExt->pAttachedToDeviceObject );


            if (NT_SUCCESS(Status)) 
            {
                pDeviceExt->Attached = TRUE;
                pDeviceExt->pDfsVolume = pDfsVolume;
                pDeviceExt->pThisDeviceObject = DfsDeviceObject;

                InterlockedIncrement(&pDfsVolume->RefCount);
                pDfsVolume->DiskDeviceObject = DiskDeviceObject;

                //  
                //  We are done initializing this device object, so
                //  clear the DO_DEVICE_OBJECT_INITIALIZING flag.
                //

                ClearFlag( DfsDeviceObject->Flags, DO_DEVICE_INITIALIZING );

            }
        }


        if (!NT_SUCCESS(Status)) 
        {
            IoDeleteDevice( DfsDeviceObject);
        }
    }
    else
    {
        pDeviceExt = DfsDeviceObject->DeviceExtension;
        pDfsVolume = pDeviceExt->pDfsVolume;
        if (pDfsVolume != NULL) {
            InterlockedIncrement(&pDfsVolume->RefCount);
        }
    }

    ObDereferenceObject( NextDeviceObject );

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsAttachToFileSystem %ws, Status %x\n",
                  UserDeviceName, Status);

    return Status;

}


NTSTATUS 
DfsDetachFromFileSystem (
    IN PWSTR UserDeviceName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDEVICE_OBJECT DeviceObject = NULL;
    PDFS_VOLUME_INFORMATION pDfsVolume;
    PDFS_FILTER_DEVICE_EXTENSION Devext = NULL;
    UNICODE_STRING DeviceName;

    ACQUIRE_GLOBAL_LOCK();

    DFS_TRACE_LOW(KUMR_DETAIL, "DfsDetachFromFileSystem %ws\n",
                  UserDeviceName);

    RtlInitUnicodeString( &DeviceName, UserDeviceName );
    DeviceName.Length = wcslen(DfsDeviceString) * sizeof(WCHAR);

    Status = DfsFindDfsVolumeByName( &DeviceName, &pDfsVolume);

    if (NT_SUCCESS( Status )) 
    {
        InterlockedDecrement(&pDfsVolume->RefCount);
    }

    RELEASE_GLOBAL_LOCK();
    DFS_TRACE_LOW(KUMR_DETAIL, "DfsDetachFromFileSystem %ws, Status %x\n",
                  UserDeviceName, Status);


    return Status;
}

NTSTATUS
DfsFindAndRemovePrefixEntry(PWSTR ShareString)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR VolumeName = NULL;
    PWSTR OldValue = NULL;
    UNICODE_STRING ShareName;
    UNICODE_STRING Suffix;

    RtlInitUnicodeString(&ShareName, ShareString);
    Status = DfsRemoveFromPrefixTableEx(pPrefixTable,
                                        &ShareName,
                                        (PVOID)VolumeName,
                                        &OldValue);
    if(OldValue)
    {
      ExFreePool(OldValue);
    }


    return Status;
}

VOID
DfsDetachFilterDevice(
    PDEVICE_OBJECT DfsDevice, 
    PDEVICE_OBJECT TargetDevice)
{
    PDFS_FILTER_DEVICE_EXTENSION pDeviceExt = NULL;
    
    FsRtlEnterFileSystem();
    ACQUIRE_GLOBAL_LOCK();

    pDeviceExt = DfsDevice->DeviceExtension;
    IoDetachDevice(TargetDevice);
    pDeviceExt->Attached = FALSE;
    if (pDeviceExt->pDfsVolume) 
    {
        pDeviceExt->pDfsVolume = NULL;
    }
    IoDeleteDevice(DfsDevice);

    RELEASE_GLOBAL_LOCK();
    FsRtlExitFileSystem();
}


NTSTATUS
DfsHandleAttachToFs(PVOID InputBuffer, ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS DummyStatus = STATUS_SUCCESS;
    PWSTR DeviceName = NULL;
    BOOL ShareInserted = FALSE;
    PDFS_ATTACH_PATH_BUFFER pAttachBuffer = (PDFS_ATTACH_PATH_BUFFER)InputBuffer;
    UNICODE_STRING ShareName ;
    UNICODE_STRING VolumeName;

    DFS_TRACE_LOW(KUMR_DETAIL, "Dfshandleattachtofs\n");

    ACQUIRE_GLOBAL_LOCK();

    RtlInitUnicodeString(&ShareName, NULL);

    RtlInitUnicodeString(&VolumeName, NULL);

    if(DfsGlobalData.ServiceProcess != IoGetCurrentProcess())
    {
       Status = STATUS_ACCESS_DENIED;
       DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs - unauthorized process  %x\n", Status);
       goto Exit;
    }

    //see if the raw inputs are valid
    if( (InputBuffer == NULL) || 
         (InputBufferLength <= 0) ||
         (InputBufferLength < sizeof(DFS_ATTACH_PATH_BUFFER)) ||
         (pPrefixTable == NULL))
    {
         Status = STATUS_INVALID_PARAMETER;
         DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs buffer length checks failed  %x\n", Status);
         goto Exit;
    }

    //get the real inputs
     VolumeName.Buffer = pAttachBuffer->PathNameBuffer;
     VolumeName.Length = VolumeName.MaximumLength = (USHORT) pAttachBuffer->VolumeNameLength;


     ShareName.Buffer = VolumeName.Buffer + (pAttachBuffer->VolumeNameLength / sizeof(WCHAR));
     ShareName.Length= ShareName.MaximumLength = (USHORT) pAttachBuffer->ShareNameLength;

     // Now see if the embedded inputs are valid

    if ( (pAttachBuffer->VolumeNameLength > InputBufferLength) ||
          (pAttachBuffer->ShareNameLength > InputBufferLength) ||
          (pAttachBuffer->ShareNameLength < sizeof(WCHAR)) ||
          ((FIELD_OFFSET(DFS_ATTACH_PATH_BUFFER,PathNameBuffer) +
            pAttachBuffer->VolumeNameLength +
            pAttachBuffer->ShareNameLength) > InputBufferLength))
    {
         Status = STATUS_INVALID_PARAMETER;
         DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs embedded inputs failed  %x\n", Status);
         goto Exit;
    }

    DeviceName = ExAllocatePool( NonPagedPool, VolumeName.Length + sizeof(WCHAR) );
    if (DeviceName == NULL) 
    {
         Status = STATUS_INSUFFICIENT_RESOURCES;
         DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs pool allocate failed  %x\n", Status);
         goto Exit;
    }


    if(VolumeName.Length != 0)
    {
        RtlCopyMemory( DeviceName, VolumeName.Buffer, VolumeName.Length );
    }

    DeviceName[VolumeName.Length / sizeof(WCHAR)] = UNICODE_NULL;

    Status = DfsInsertInPrefixTable(pPrefixTable, 
                                    &ShareName,
                                    (PVOID)DeviceName);
    if(Status != STATUS_SUCCESS)
    {
         DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs DfsInsertInPrefixTable2 returned error  %x\n", Status);
         goto Exit;
    }

    ShareInserted = TRUE;

    if(VolumeName.Length != 0)
    {
        Status = DfsAttachToFileSystem (DeviceName);
        if(Status != STATUS_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleAttachToFs DfsAttachToFileSystem returned error  %x\n", Status);
        }
    }

Exit:

    if(Status != STATUS_SUCCESS)
    {
         if(ShareInserted)
         {
            DummyStatus = DfsRemoveFromPrefixTable(pPrefixTable, 
                                                   &ShareName,
                                                   (PVOID)DeviceName);
         }

         if (DeviceName != NULL) 
         {
            ExFreePool( DeviceName );
         }
    }

    RELEASE_GLOBAL_LOCK();

    DFS_TRACE_LOW(KUMR_DETAIL, "Dfshandleattachtofs, Share %wZ, Volume %wZ, Status %x\n",
                  &ShareName, &VolumeName, Status);
    return Status;
}



NTSTATUS
DfsHandleDetachFromFs(PVOID InputBuffer, ULONG InputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS DummyStatus = STATUS_SUCCESS;
    PWSTR DeviceName = NULL;
    PWSTR OldValue = NULL;
    PDFS_ATTACH_PATH_BUFFER pAttachBuffer = (PDFS_ATTACH_PATH_BUFFER)InputBuffer;
    UNICODE_STRING ShareName ;
    UNICODE_STRING VolumeName;

    DFS_TRACE_LOW(KUMR_DETAIL, "Dfshandledetachfromfs\n");

    ACQUIRE_GLOBAL_LOCK();

    RtlInitUnicodeString(&ShareName, NULL);

    RtlInitUnicodeString(&VolumeName, NULL);

    if(DfsGlobalData.ServiceProcess != IoGetCurrentProcess())
    {
         Status = STATUS_ACCESS_DENIED;
         DFS_TRACE_ERROR_HIGH(Status, KUMR_DETAIL, "DfsHandleDetachFromFs - unauthorized process  %x\n", Status);
         goto Exit;
    }

    //see if the raw inputs are valid
    if( (InputBuffer == NULL) || 
            (InputBufferLength <= 0) ||
            (InputBufferLength < sizeof(DFS_ATTACH_PATH_BUFFER)) ||
            (pPrefixTable == NULL))
    {
         Status = STATUS_INVALID_PARAMETER;
         goto Exit;
    }

    //get the real inputs
    VolumeName.Buffer = pAttachBuffer->PathNameBuffer;
    VolumeName.Length = VolumeName.MaximumLength = (USHORT) pAttachBuffer->VolumeNameLength;


    ShareName.Buffer = VolumeName.Buffer + (pAttachBuffer->VolumeNameLength / sizeof(WCHAR));
    ShareName.Length= ShareName.MaximumLength = (USHORT) pAttachBuffer->ShareNameLength;

    // Now see if the embedded inputs are valid
    if ( (pAttachBuffer->VolumeNameLength > InputBufferLength) ||
         (pAttachBuffer->ShareNameLength > InputBufferLength) ||
         (pAttachBuffer->ShareNameLength < sizeof(WCHAR)) ||
         ((FIELD_OFFSET(DFS_ATTACH_PATH_BUFFER,PathNameBuffer) +
           pAttachBuffer->VolumeNameLength +
           pAttachBuffer->ShareNameLength) > InputBufferLength))
    {
         Status = STATUS_INVALID_PARAMETER;
         goto Exit;
    }

    DeviceName = ExAllocatePool( NonPagedPool, VolumeName.Length + sizeof(WCHAR) );
    if (DeviceName == NULL) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
         goto Exit;
    }


    if(VolumeName.Length != 0)
    {
        RtlCopyMemory( DeviceName, VolumeName.Buffer, VolumeName.Length );
    }

    DeviceName[VolumeName.Length / sizeof(WCHAR)] = UNICODE_NULL;

    VolumeName.Buffer = DeviceName;

    if(VolumeName.Length != 0)
    {
        Status = DfsDetachFromFileSystem (VolumeName.Buffer);
    }

    DFS_TRACE_LOW(KUMR_DETAIL, "Detach for %wZ, Status %x\n", 
                      &VolumeName, Status );

    Status = DfsRemoveFromPrefixTableEx(pPrefixTable, 
                                        &ShareName,
                                        NULL,
                                        &OldValue);
    if(OldValue != NULL)
    {
       ExFreePool(OldValue);
    }

Exit:

    if (DeviceName != NULL) 
    {
       ExFreePool( DeviceName );
    }

    RELEASE_GLOBAL_LOCK();

    return Status;
}



NTSTATUS
DfsFindDfsVolumeByName( 
    PUNICODE_STRING pDeviceName,
    PDFS_VOLUME_INFORMATION *ppDfsVolume)
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PLIST_ENTRY pListHead, pListNext;
    PDFS_VOLUME_INFORMATION pDfsVolume;

    *ppDfsVolume = NULL;
    pListHead = &DfsGlobalData.DfsVolumeList;
    pListNext = pListHead->Flink;

    while (pListNext != pListHead)
    {
        pDfsVolume = CONTAINING_RECORD( pListNext,
                                        DFS_VOLUME_INFORMATION,
                                        VolumeList );
        if (RtlCompareUnicodeString(pDeviceName,
                                    &pDfsVolume->VolumeName,
                                    TRUE) == 0) {
            *ppDfsVolume = pDfsVolume;
            Status = STATUS_SUCCESS;
            break;
        }
        pListNext = pListNext->Flink;
    }

    return Status;
}

VOID
DfsReattachToMountedVolume( 
    PDEVICE_OBJECT pTargetDevice,
    PDEVICE_OBJECT pDiskDevice )
{
    PDEVICE_OBJECT DfsDeviceObject = NULL;
    PDFS_FILTER_DEVICE_EXTENSION pDeviceExt = NULL;
    PDFS_VOLUME_INFORMATION pDfsVolume = NULL;
    NTSTATUS Status = STATUS_SUCCESS;


    FsRtlEnterFileSystem();

    ACQUIRE_GLOBAL_LOCK();

    Status = DfsFindDfsVolumeByDiskDeviceObject( pDiskDevice,
                                                 &pDfsVolume );

    if (Status == STATUS_SUCCESS) 
    {
        Status = IoCreateDevice( DfsGlobalData.pFilterDriverObject,
                                 sizeof( DFS_FILTER_DEVICE_EXTENSION ),
                                 NULL,
                                 pTargetDevice->DeviceType,
                                 0,
                                 FALSE,
                                 &DfsDeviceObject );

        if (NT_SUCCESS(Status)) 
        {
            pDeviceExt = DfsDeviceObject->DeviceExtension;
            Status = IoAttachDeviceToDeviceStackSafe( DfsDeviceObject,
                                                      pTargetDevice,
                                                      &pDeviceExt->pAttachedToDeviceObject );

            if (NT_SUCCESS(Status)) 
            {
                pDeviceExt->pDfsVolume = pDfsVolume;
                pDeviceExt->Attached = TRUE;
                pDeviceExt->pThisDeviceObject = DfsDeviceObject;
                ClearFlag( DfsDeviceObject->Flags, DO_DEVICE_INITIALIZING );
            }
            else
            {
                IoDeleteDevice( DfsDeviceObject);
            }
        }
    }

    RELEASE_GLOBAL_LOCK();

    FsRtlExitFileSystem();

    return NOTHING;

}

NTSTATUS
DfsFindDfsVolumeByDiskDeviceObject(
    PDEVICE_OBJECT pDiskDeviceObject,
    PDFS_VOLUME_INFORMATION *ppDfsVolume )
{
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;
    PLIST_ENTRY pListHead, pListNext;
    PDFS_VOLUME_INFORMATION pDfsVolume;

    *ppDfsVolume = NULL;
    pListHead = &DfsGlobalData.DfsVolumeList;
    pListNext = pListHead->Flink;

    while (pListNext != pListHead)
    {
        pDfsVolume = CONTAINING_RECORD( pListNext,
                                        DFS_VOLUME_INFORMATION,
                                        VolumeList );
        if (pDfsVolume->DiskDeviceObject == pDiskDeviceObject) {
            *ppDfsVolume = pDfsVolume;
            Status = STATUS_SUCCESS;
            break;
        }
        pListNext = pListNext->Flink;
    }

    return Status;
}


NTSTATUS
DfsGetDfsVolume(
    PUNICODE_STRING pName,
    PDFS_VOLUME_INFORMATION *ppDfsVolume)
{
    NTSTATUS Status;
    PDFS_VOLUME_INFORMATION pDfsVolume;

    Status = DfsFindDfsVolumeByName( pName, ppDfsVolume );
    if (!NT_SUCCESS(Status)) 
    {
        pDfsVolume = ExAllocatePoolWithTag( PagedPool,
                                            sizeof(DFS_VOLUME_INFORMATION) + pName->Length,
                                            ' sfD');
        if (pDfsVolume == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = STATUS_SUCCESS;
            RtlZeroMemory( pDfsVolume, sizeof(DFS_VOLUME_INFORMATION) + pName->Length );
            pDfsVolume->VolumeName.Buffer = (LPWSTR)(pDfsVolume + 1);
            pDfsVolume->VolumeName.Length = 
                pDfsVolume->VolumeName.MaximumLength = pName->Length;
            RtlCopyMemory(pDfsVolume->VolumeName.Buffer,
                          pName->Buffer,
                          pName->Length);

            InsertHeadList(&DfsGlobalData.DfsVolumeList, &pDfsVolume->VolumeList);
            *ppDfsVolume = pDfsVolume;
        }
    }
    return Status;
}

#define DEFAULT_CHECK_SHARE_BUFFER_SIZE 4096


NTSTATUS
DfsCheckDfsShare(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    PIRP Irp,
    IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    PDFS_FIND_SHARE_ARG ShareArg = (PDFS_FIND_SHARE_ARG)InputBuffer;
    UNICODE_STRING ShareName;
    PREPLICA_DATA_INFO pRep = NULL;
    DWORD AllocSize = 0;    
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR NameContextString = L"\\UnknownNameContext\\";
    UNICODE_STRING NameContext;

    ULONG BufferLength;
    PVOID UseBuffer;
    KPROCESSOR_MODE PreviousMode;

    DFS_TRACE_LOW(KUMR_DETAIL, "FSCTL_DFS_FIND_SHARE\n");

    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }
    
    RtlInitUnicodeString(&NameContext, NameContextString);


    if (InputBufferLength < sizeof(DFS_FIND_SHARE_ARG) ||
        (DfsGlobalData.CurrentProcessPointer != (PVOID)PsGetCurrentProcess()))
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    BufferLength = DEFAULT_CHECK_SHARE_BUFFER_SIZE;
    
    UseBuffer = ExAllocatePoolWithTag( PagedPool, 
                                       BufferLength,
                                       'xsfD' );
    if (UseBuffer == NULL) 
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    ShareName = ShareArg->ShareName;

    //get the size of the allocation
    AllocSize = sizeof(REPLICA_DATA_INFO) + NameContext.Length + ShareName.Length + sizeof(WCHAR);
    pRep = (PREPLICA_DATA_INFO) ExAllocatePoolWithTag( NonPagedPool,
                                                       AllocSize,
                                                       'xsfD');

    if(pRep == NULL)
    {
        ExFreePool( UseBuffer );
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }
    //zero the memory
    RtlZeroMemory(pRep, AllocSize);

    //setup the structure
    pRep->MaxReferralLevel = 3;
    pRep->Flags = DFS_OLDDFS_SERVER;
    pRep->CostLimit = ULONG_MAX;
    pRep->NumReplicasToReturn = 1000;


    pRep->LinkNameLength = NameContext.Length + ShareName.Length + sizeof(WCHAR);
    
    RtlCopyMemory(pRep->LinkName, NameContext.Buffer, NameContext.Length );
    RtlCopyMemory((PVOID)((ULONG_PTR)(pRep->LinkName) + NameContext.Length),
                  ShareName.Buffer,
                  ShareName.Length );


    //make the request to usermode
    Status = DfsGetReplicaInformation((PVOID) pRep, 
                                      AllocSize,
                                      UseBuffer,
                                      BufferLength,
                                      Irp,
                                      pIoStatusBlock);

    ExFreePool(UseBuffer);
    ExFreePool (pRep);

    if (Status == STATUS_SUCCESS) 
    {
        Status = STATUS_PATH_NOT_COVERED;
    }
    else
    {
        Status = STATUS_BAD_NETWORK_NAME;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverfilter\dfsumrrequests.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    DfsUmrrequests.c

Abstract:


Notes:


Author:

    Rohan  Phillips   [Rohanp]       18-Jan-2001

--*/
              
#include "ntifs.h"
#include <windef.h>
#include <limits.h>
#include <smbtypes.h>
#include <smbtrans.h>
#include "DfsInit.h"
#include <DfsReferralData.h>
#include <midatlax.h>
#include <rxcontx.h>
#include <dfsumr.h>
#include <umrx.h>
#include <DfsUmrCtrl.h>
#include <dfsfsctl.h>
//#include <dfsmisc.h>

extern
NTSTATUS
DfsFsctrlIsShareInDfs(PVOID InputBuffer,
                      ULONG InputBufferLength);

extern
NTSTATUS
DfsGetPathComponentsPriv(
   PUNICODE_STRING pName,
   PUNICODE_STRING pServerName,
   PUNICODE_STRING pShareName,
   PUNICODE_STRING pRemaining);


NTSTATUS
UMRxFormatUserModeGetReplicasRequest (
    PUMRX_CONTEXT    pUMRxContext,
    PRX_CONTEXT      RxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength,
    PULONG ReturnedLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferLengthAvailable = 0;
    ULONG BufferLengthNeeded = 0;
    PUMR_GETDFSREPLICAS_REQ GetReplicaRequest = NULL;
    PBYTE Buffer = NULL;

    PAGED_CODE();

    GetReplicaRequest = &WorkItem->WorkRequest.GetDfsReplicasRequest;
    *ReturnedLength = 0;

    BufferLengthAvailable = WorkItemLength - FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest.GetDfsReplicasRequest.RepInfo.LinkName[0]);
    BufferLengthNeeded = RxContext->InputBufferLength;

    *ReturnedLength = FIELD_OFFSET(UMRX_USERMODE_WORKITEM,WorkRequest.GetDfsReplicasRequest.RepInfo.LinkName[0]) + BufferLengthNeeded;

    if (WorkItemLength < *ReturnedLength)
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    WorkItem->Header.WorkItemType = opUmrGetDfsReplicas;

    Buffer = (PBYTE)(GetReplicaRequest);

    RtlCopyMemory(Buffer,
              RxContext->InputBuffer,
              RxContext->InputBufferLength);

    return Status;
}

VOID
UMRxCompleteUserModeGetReplicasRequest (
    PUMRX_CONTEXT    pUMRxContext,
    PRX_CONTEXT      RxContext,
    PUMRX_USERMODE_WORKITEM WorkItem,
    ULONG WorkItemLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUMR_GETDFSREPLICAS_RESP GetReplicasResponse = NULL;

    PAGED_CODE();

    //this means that the request was cancelled
    if ((NULL == WorkItem) || (0 == WorkItemLength))
    {
        Status = pUMRxContext->Status;
        goto Exit;
    }

    GetReplicasResponse = &WorkItem->WorkResponse.GetDfsReplicasResponse;

    Status = WorkItem->Header.IoStatus.Status;
    if (Status != STATUS_SUCCESS) 
    {
        goto Exit ;
    }

    if(RxContext->OutputBufferLength < GetReplicasResponse->Length)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES ;
        goto Exit;
    }


    RtlCopyMemory(RxContext->OutputBuffer,
                  GetReplicasResponse->Buffer,
                  GetReplicasResponse->Length);


   RxContext->ReturnedLength = GetReplicasResponse->Length;

Exit:

    RxContext->Status = Status;
    pUMRxContext->Status = Status;
}

NTSTATUS
UMRxGetReplicasContinuation(
    IN PUMRX_CONTEXT pUMRxContext,
    IN PRX_CONTEXT   RxContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    Status = UMRxEngineSubmitRequest(
                         pUMRxContext,
                         RxContext,
                         UMRX_CTXTYPE_GETDFSREPLICAS,
                         UMRxFormatUserModeGetReplicasRequest,
                         UMRxCompleteUserModeGetReplicasRequest
                         );

    return(Status);
}

NTSTATUS 
DfsGetReplicaInformation(IN PVOID InputBuffer, 
                         IN ULONG InputBufferLength,
                         OUT PVOID OutputBuffer, 
                         OUT ULONG OutputBufferLength,
                         PIRP Irp,
                         IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PRX_CONTEXT pRxContext = NULL;
    PREPLICA_DATA_INFO pRep = NULL;

    PAGED_CODE();

    //make sure we are all hooked up before flying into 
    //user mode
    if(GetUMRxEngineFromRxContext() == NULL)
    {
        Status = STATUS_DEVICE_NOT_CONNECTED;
        return Status;
    }

    //get the input buffer
    pRep = (PREPLICA_DATA_INFO) InputBuffer;

    //check if the buffer is large enough to hold the
    //data passed in
    if(InputBufferLength < sizeof(REPLICA_DATA_INFO))
    {
        return Status;  
    }

    //make sure the referral level is good
    if((pRep->MaxReferralLevel > 3) || (pRep->MaxReferralLevel < 1))
    {
        pRep->MaxReferralLevel = 3;
    }


    //set the outputbuffersize
    pRep->ClientBufferSize = OutputBufferLength;

    //create a context structure
    pRxContext = RxCreateRxContext (Irp, 0);
    if(pRxContext == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    pRxContext->OutputBuffer = OutputBuffer;
    pRxContext->OutputBufferLength = OutputBufferLength;
    pRxContext->InputBuffer = InputBuffer;
    pRxContext->InputBufferLength = InputBufferLength;

    //make the request to user mode
    Status = UMRxEngineInitiateRequest(
                                       GetUMRxEngineFromRxContext(),
                                       pRxContext,
                                       UMRX_CTXTYPE_GETDFSREPLICAS,
                                       UMRxGetReplicasContinuation
                                      );

    pIoStatusBlock->Information = pRxContext->ReturnedLength;

    //delete context
    RxDereferenceAndDeleteRxContext(pRxContext);

    return Status;
}

NTSTATUS 
DfsCheckIsPathLocal(PUNICODE_STRING DfsPath)
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    DFS_IS_SHARE_IN_DFS_ARG DfsArg;

    RtlInitUnicodeString(&ServerName, NULL);
    RtlInitUnicodeString(&ShareName, NULL);

    DfsGetPathComponentsPriv(DfsPath, &ServerName, 
        &ShareName, NULL);

    if((ServerName.Length > 0) && (ShareName.Length > 0))
    {
        DfsArg.ShareName.Buffer = ShareName.Buffer;
        DfsArg.ShareName.Length = ShareName.Length;
        DfsArg.ShareName.MaximumLength = ShareName.MaximumLength;

        Status = DfsFsctrlIsShareInDfs((PVOID)&DfsArg, sizeof(DfsArg));
    }

    return Status;
}

NTSTATUS
DfsFsctrlGetReferrals(
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    PIRP Irp,
    IN OUT PIO_STATUS_BLOCK pIoStatusBlock)
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD AllocSize = 0;
    PDFS_GET_REFERRALS_INPUT_ARG pArg = NULL;
    PREPLICA_DATA_INFO pRep = NULL;
    PUNICODE_STRING Prefix = NULL;
    KPROCESSOR_MODE PreviousMode = KernelMode;

    PreviousMode = ExGetPreviousMode();
    if (PreviousMode != KernelMode) {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    if (InputBufferLength < sizeof(DFS_GET_REFERRALS_INPUT_ARG))
    {
        Status = STATUS_INVALID_PARAMETER;
        return Status;
    }

    pArg = (PDFS_GET_REFERRALS_INPUT_ARG) InputBuffer;
    Prefix = &pArg->DfsPathName;

    if(DfsGlobalData.IsDC == FALSE)
    {
        Status = DfsCheckIsPathLocal(Prefix);
        if(Status != STATUS_SUCCESS)
        {
            return Status;
        }
    }
    
    //get the size of the allocation
    AllocSize = sizeof(REPLICA_DATA_INFO) + Prefix->Length + sizeof(WCHAR);
    pRep = (PREPLICA_DATA_INFO) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                AllocSize,
                                                'xsfD'
                                                );
    if(pRep == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }

    //
    // IP address cannot be longer than char[14]
    //
    if (pArg->IpAddress.IpLen > sizeof(pRep->IpData))
    {
        Status = STATUS_INVALID_PARAMETER;
        ExFreePool (pRep);
        return Status;
    }
    
    //zero the memory
    RtlZeroMemory(pRep, AllocSize);

    //setup the structure
    pRep->MaxReferralLevel = pArg->MaxReferralLevel;
    pRep->Flags = DFS_OLDDFS_SERVER;

    //
    // This is the maximum value for an inter-site-cost.
    // dfsdev: read this in from a registry value
    //
    pRep->CostLimit = ULONG_MAX;
    pRep->NumReplicasToReturn = 1000;
    pRep->IpFamily = pArg->IpAddress.IpFamily;
    pRep->IpLength = pArg->IpAddress.IpLen;

    RtlCopyMemory(pRep->IpData, pArg->IpAddress.IpData, pArg->IpAddress.IpLen); 
    
    pRep->LinkNameLength = Prefix->Length + sizeof(WCHAR);
    
    RtlCopyMemory(pRep->LinkName, Prefix->Buffer, Prefix->Length);
    pRep->LinkName[Prefix->Length/sizeof(WCHAR)] = UNICODE_NULL; // paranoia
    
    //make the request to usermode
    Status = DfsGetReplicaInformation((PVOID) pRep, 
                                      AllocSize,
                                      OutputBuffer, 
                                      OutputBufferLength,
                                      Irp,
                                      pIoStatusBlock);

    ExFreePool (pRep);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadblobrootfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsADBlobRootFolder.cxx
//
//  Contents:   the Root DFS Folder class for ADBlob Store
//
//  Classes:    DfsADBlobRootFolder
//
//  History:    Dec. 8 2000,   Author: udayh
//              April 14 2001  Rohanp - Modified to use ADSI code
//
//-----------------------------------------------------------------------------


#include "DfsADBlobRootFolder.hxx"
#include "DfsReplica.hxx"

#include "lmdfs.h"
#include "dfserror.hxx"
#include "dfsmisc.h"
#include "dfsadsiapi.hxx"
#include "domaincontrollersupport.hxx"
#include "DfsSynchronizeRoots.hxx"

#if !defined(DFS_STORAGE_STATE_MASTER)
#define DFS_STORAGE_STATE_MASTER   0x0010
#endif
#if !defined(DFS_STORAGE_STATE_STANDBY)
#define DFS_STORAGE_STATE_STANDBY  0x0020
#endif

//
// logging specific includes
//
#include "DfsADBlobRootFolder.tmh" 

//+----------------------------------------------------------------------------
//
//  Class:      DfsADBlobRootFolder
//
//  Synopsis:   This class implements The Dfs ADBlob root folder.
//
//-----------------------------------------------------------------------------




//+-------------------------------------------------------------------------
//
//  Function:   DfsADBlobRootFolder - constructor
//
//  Arguments:    NameContext -  the dfs name context
//                pLogicalShare -  the logical share
//                pParentStore -  the parent store for this root.
//                pStatus - the return status
//
//  Returns:    NONE
//
//  Description: This routine initializes a ADBlobRootFolder instance
//
//--------------------------------------------------------------------------

DfsADBlobRootFolder::DfsADBlobRootFolder(
    LPWSTR NameContext,
    LPWSTR pRootRegistryNameString,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsADBlobStore *pParentStore,
    DFSSTATUS *pStatus ) :  DfsRootFolder ( NameContext,
                                            pRootRegistryNameString,
                                            pLogicalShare,
                                            pPhysicalShare,
                                            DFS_OBJECT_TYPE_ADBLOB_ROOT_FOLDER,
                                            pStatus )
{
    DFSSTATUS Status = *pStatus;

    _pBlobCache = NULL;

    _pStore = pParentStore;
    if (_pStore != NULL)
    {
        _pStore->AcquireReference();
    }

    _RootFlavor = DFS_VOLUME_FLAVOR_AD_BLOB;

    //
    // If the namecontext that we are passed is an emptry string,
    // then we are dealing with the referral server running on the root
    // itself. We are required to ignore the name context for such
    // roots during lookups, so that aliasing works. (Aliasing is where
    // someone may access the root with an aliased machine name or ip
    // address)
    //

    if (Status == ERROR_SUCCESS) 
    {
        if (IsEmptyString(NameContext) == TRUE)
        {
            SetIgnoreNameContext();
            _LocalCreate = TRUE;
            //
            // Now we update our visible context, which is the dfs name context
            // seen by people when they do api calls.
            // For the ad blob root folder, this will be the domain name of this
            // machine.
            //

            Status = DfsGetDomainName( &_DfsVisibleContext ); 
        }
        else
        {
            Status = DfsCreateUnicodeStringFromString(&_DfsVisibleContext, NameContext);
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        _pBlobCache = new DfsADBlobCache(&Status, GetLogicalShare(), this);
 
        if ( _pBlobCache == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    
        // 
        // If the constructor returns an error, the caller will release the reference
        // on this BlobCache which in turn will desctruct it.
        //
    }

    *pStatus = Status;

    DFS_TRACE_LOW(REFERRAL_SERVER, "Created new root folder,%p, cache %p, name %wZ\n",
                  this, _pBlobCache, GetLogicalShare());
}


//+-------------------------------------------------------------------------
//
//  Function:   Synchronize
//
//  Arguments:    None
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine synchronizes the children folders
//               of this root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobRootFolder::Synchronize(BOOLEAN fForceSync, BOOLEAN CalledByApi )
{
    DFSSTATUS       Status = ERROR_SUCCESS;
    
    //
    // Read from the metadata store, and unravel the blob.
    // Update the ADBlobCache with the information of each individual
    // link, deleting old inof, adding new info, and/or modifying
    // existing information.
    //
    //
    // if we are in a standby mode, we dont synchronize, till we obtain 
    // ownership again.
    //

    DFS_TRACE_LOW(REFERRAL_SERVER, "Synchronize started on root %p (%wZ)\n", this, GetLogicalShare());

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    if (CheckRootFolderSkipSynchronize() == TRUE)
    {
        ReleaseRootLock();
        return ERROR_SUCCESS;
    }


    //
    // now acquire the root share directory. If this
    // fails, we continue our operation: we can continue
    // with synchonize and not create directories.
    // dfsdev:we need to post a eventlog or something when
    // we run into this.
    //

    do 
    {        
        DFSSTATUS RootStatus = AcquireRootShareDirectory();
        if(CalledByApi && (RootStatus != ERROR_SUCCESS))
        {
            DFS_TRACE_ERROR_LOW(RootStatus, REFERRAL_SERVER, "Recognize Dfs: Root folder for %p, validate status %x\n",
                                this, RootStatus );
            Status = RootStatus;
            break;
        }

        if (IsRootScalabilityMode() == TRUE)
        {
            //
            // Dont have to get blob from PDC
            //
            Status = UpdateRootFromBlob(fForceSync, FALSE);

            DFS_TRACE_LOW(REFERRAL_SERVER, "Loose Sync, Update root from blob Status %x\n", Status);

        }
        else
        {
            //
            // have to to get blob from PDC
            //
            Status = UpdateRootFromBlob(fForceSync, TRUE);

            DFS_TRACE_LOW(REFERRAL_SERVER, "Tight Sync, Update root from blob Status %x\n", Status);
        }


        if(CalledByApi && (Status != ERROR_SUCCESS))
        {

          DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Recognize Dfs: Synchronize Root folder for %p, validate status %x\n",
                              this, Status );
          (void) ReleaseRootShareDirectory();
        }

    } while (0);


    ReleaseRootLock();



    DFS_TRACE_LOW(REFERRAL_SERVER, "Synchronize done on root %p, Status %x\n", this, Status);
    return Status;
}

DFSSTATUS
DfsADBlobRootFolder::UpdateRootFromBlob(
    BOOLEAN fForceSync,
    BOOLEAN FromPDC)
{
    DFSSTATUS Status;
    //
    //  Read in the blob from the AD, enumerate it, 
    //  and put the data in the cache.
    //
    Status = GetMetadataBlobCache()->CacheRefresh( fForceSync,
                                                   FromPDC );
    if (Status == ERROR_SUCCESS)
    {
        Status = EnumerateBlobCacheAndCreateFolders( );

        if (Status == ERROR_SUCCESS)
        {
            //
            //  Mark it so we know the root folder has finished
            //  syncing.
            //
            SetRootFolderSynchronized();
        }
        else
        {
            ClearRootFolderSynchronized();
        }
    }
    return Status;
}



DFSSTATUS
DfsADBlobRootFolder::EnumerateBlobCacheAndCreateFolders( )
{
    DFSSTATUS UpdateStatus;

    DFSSTATUS Status = STATUS_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    PDFSBLOB_DATA pBlobData = NULL;
    DFSBOB_ITER Iter;

    pBlobCache = GetMetadataBlobCache();

    pBlobData = pBlobCache->FindFirstBlob(&Iter);

    while (pBlobData && (!DfsIsShuttingDown()))
    {
        if (pBlobCache->IsStaleBlob(pBlobData))
        {
            DFSSTATUS RemoveStatus;

            RemoveStatus = RemoveLinkFolder( pBlobData->BlobName.Buffer );
            
            DFS_TRACE_ERROR_LOW(RemoveStatus, REFERRAL_SERVER, "Remove stale folder %ws, status %x\n",
                                pBlobData->BlobName.Buffer,
                                RemoveStatus );

            if (RemoveStatus == ERROR_SUCCESS) 
            {
                RemoveStatus = pBlobCache->RemoveNamedBlob( &pBlobData->BlobName );
            }

            DFS_TRACE_ERROR_LOW(RemoveStatus, REFERRAL_SERVER, "Remove stale folder %ws, status %x\n",
                                pBlobData->BlobName.Buffer,
                                RemoveStatus );
        }
        pBlobData = pBlobCache->FindNextBlob(&Iter);
    }

    pBlobCache->FindCloseBlob(&Iter);

    pBlobData = pBlobCache->FindFirstBlob(&Iter);

    while (pBlobData && (!DfsIsShuttingDown()))
    {
        if (pBlobCache->IsStaleBlob(pBlobData) == FALSE)
        {

            UpdateStatus = UpdateLinkInformation((DFS_METADATA_HANDLE) pBlobCache,
                                                 pBlobData->BlobName.Buffer);

            DFS_TRACE_ERROR_LOW(UpdateStatus, REFERRAL_SERVER,
                                "Root %p (%wZ) Ad Blob enumerate, update link returned %x for %wZ\n", 
                                this, GetLogicalShare(), UpdateStatus, &pBlobData->BlobName);

            if (UpdateStatus != ERROR_SUCCESS)
            {
                Status = UpdateStatus;
            }
        }

        pBlobData = pBlobCache->FindNextBlob(&Iter);
    }
    pBlobCache->FindCloseBlob(&Iter);

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER,
                        "Root %p (%wZ) Done with Enumerate blob and create folders, Status %x\n", 
                        this, GetLogicalShare(), Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RenameLinks
//
//  Arguments:  
//    OldDomainName
//    NewDomainName 
//
//  Returns:   SUCCESS or error
//
//  Description: Renames all links referencing the old domain name to the new.
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobRootFolder::RenameLinks(
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    PDFSBLOB_DATA pBlobData = NULL;
    DFS_METADATA_HANDLE RootHandle = NULL;
    PUNICODE_STRING pLinkMetadataName = NULL;
    UNICODE_STRING OldUnicodeName, NewUnicodeName;
    DFSBOB_ITER Iter;
    
    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &OldUnicodeName, OldDomainName );
    if (Status != ERROR_SUCCESS)
    {
        goto Exit;
    }

    Status = DfsRtlInitUnicodeStringEx( &NewUnicodeName, NewDomainName );
    if (Status != ERROR_SUCCESS)
    {
        goto Exit;
    }


    pBlobCache = GetMetadataBlobCache();    
    RootHandle = CreateMetadataHandle(pBlobCache);
    //
    // Iterate over all the blobs and rename its links
    // if applicable. The root blob itself is in here distinguished
    // by an empty LinkMetadataName (ie. \DomainRoot\"").
    //
    for (pBlobData = pBlobCache->FindFirstBlob(&Iter); 
        pBlobData != NULL;
        pBlobData = pBlobCache->FindNextBlob(&Iter)) 
    {
        if (pBlobCache->IsStaleBlob(pBlobData))
            continue;
            
        pLinkMetadataName = &pBlobData->BlobName;
        
        //
        //  Go through all the replicas in this blob and rename
        //  them if need be. This will set the modified metadata back in the cache.
        //  We can't continue if we've hit an error at any point. This is an
        //  atomic rename.
        //
        Status = GetMetadataStore()->RenameLinks( RootHandle,
                                                pLinkMetadataName,
                                                &OldUnicodeName,
                                                &NewUnicodeName );

        if (Status != ERROR_SUCCESS)
            break;
    }
    pBlobCache->FindCloseBlob(&Iter);

    //
    // Now rename the remoteServerName attribute in the AD as well.
    //
    if (Status == ERROR_SUCCESS)
    {
        DFSSTATUS DeleteStatus = ERROR_SUCCESS;
        BOOLEAN NeedToDelete = FALSE;

        //
        // When DfsDnsConfig flag is on, the server name with FQDN
        // gets put on the remoteServerName attribute. See if the old
        // name is there. This will do a GetEx on the AD object to find out.
        //
        DeleteStatus = DfsIsRemoteServerNameEqual( GetLogicalShare()->Buffer,
                                                &OldUnicodeName,
                                                &NeedToDelete );

        // The return status isn't propagated outside. There's no need for it.
        if (DeleteStatus == ERROR_SUCCESS && NeedToDelete)
        {
            
            UNICODE_STRING Context;

            DeleteStatus = GetVisibleContext(&Context);

            //
            // Context here will give us the DC to contact
            // for this root. The DomainName referred to here isn't necessarily a domain name.
            // For this it's actually the root target name. The only reason users want to
            // change the remoteServerName attribute when doing domain renames is if
            // the DfsDnsConfig flag is set and that attribute has the fullyqualified servername in it.
            //
            if (DeleteStatus == ERROR_SUCCESS)
            {
                DeleteStatus = DfsUpdateRootRemoteServerName( GetLogicalShare()->Buffer,
                                                              Context.Buffer,
                                                              OldDomainName,
                                                              GetRootPhysicalShareName()->Buffer,
                                                              FALSE );
                //
                // Now, add the new one.
                //
                if (DeleteStatus == ERROR_SUCCESS)
                {
                    Status = DfsUpdateRootRemoteServerName( GetLogicalShare()->Buffer,
                                                            Context.Buffer,
                                                            NewDomainName,
                                                            GetRootPhysicalShareName()->Buffer,
                                                            TRUE );
                }

                ReleaseVisibleContext(&Context);
            }


        }
    }
    
    //
    //  Flush the cache to make our changes permanent. If there were errors
    //  purge our changes and refresh our cache.
    //
    if (Status == ERROR_SUCCESS)
    {
        Flush();
        
    } else
    {
        ReSynchronize( TRUE );
    }

    if(RootHandle != NULL)
    {
        ReleaseMetadataHandle( RootHandle );
    }

Exit:

    ReleaseRootLock();
    return Status;
    
}



VOID
DfsADBlobRootFolder::SynchronizeRoots( )
{
    DfsFolderReferralData *pReferralData = NULL;
    DFS_INFO_101 DfsState;
    DFSSTATUS Status, SyncStatus;
    DfsReplica *pReplica = NULL;
    ULONG Target = 0;
    UNICODE_STRING DfsName;

    PUNICODE_STRING pRootShare;
    ULONG SyncCount = 0, ReplicaCount = 0;
    BOOLEAN CacheHit = FALSE;

    if (IsRootScalabilityMode() == TRUE)
    {
        DFS_TRACE_LOW(REFERRAL_SERVER, "Loose Sync updates not sent to target servers\n");
        return;
    }

    DfsState.State = DFS_STORAGE_STATE_MASTER;



    pRootShare = GetLogicalShare();

    Status = GetReferralData( &pReferralData,
                              &CacheHit);

    if (Status == ERROR_SUCCESS)
    {
        ReplicaCount = pReferralData->ReplicaCount;

        for (Target = 0; Target < pReferralData->ReplicaCount; Target++)
        {
            PUNICODE_STRING pTargetServer, pTargetFolder;
            
            pReplica = &pReferralData->pReplicas[ Target ];
            
            pTargetServer = pReplica->GetTargetServer();
            pTargetFolder = pRootShare;
            
            if (DfsIsTargetCurrentMachine(pTargetServer))
            {
                continue;
            }

            Status = DfsCreateUnicodePathString( &DfsName, 
                                                 2,
                                                 pTargetServer->Buffer,
                                                 pTargetFolder->Buffer );

            if (Status == ERROR_SUCCESS)
            {
                SyncStatus = AddRootToSyncrhonize( &DfsName );

                if (SyncStatus == ERROR_SUCCESS)
                {
                    SyncCount++;
                }
                DfsFreeUnicodeString( &DfsName );
            }


            if (DfsIsShuttingDown())
            {
                break;
            }
        }
        pReferralData->ReleaseReference();
    }

    DFS_TRACE_LOW( REFERRAL_SERVER, "Synchronize roots %wZ done: %x roots, %x succeeded\n",
                   pRootShare, ReplicaCount, SyncCount);

    return NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadblobstore.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsADBlobStore.cxx
//
//  Contents:   the AD Blob DFS Store class, this contains the registry
//              specific functionality.
//
//  Classes:    DfsADBlobStore.
//
//  History:    Dec. 8 2000,   Author: udayh
//              April 9 2001   Rohanp - Added ADSI specific code
//
//-----------------------------------------------------------------------------


#include "DfsADBlobStore.hxx"
#include "DfsADBlobRootFolder.hxx"
#include "DfsFilterApi.hxx"
#include "dfsmisc.h"
#include "lmdfs.h"
#include "shlwapi.h"
#include "align.h"
#include "dfserror.hxx"
#include "DomainControllerSupport.hxx"
#include "dfsadsiapi.hxx"

#include "dfsinit.hxx"

#include "DfsAdBlobStore.tmh"

//+----------------------------------------------------------------------------
//
//  Class:      DfsADBlobStore.
//
//  Synopsis:   This class inherits the basic DfsStore, and extends it
//              to include the blob DS specific functionality.
//
//-----------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizer -  the recognizer for the store.
//
//  Arguments:  Name - the namespace of interest.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine checks if the specified namespace holds
//               a domain based DFS. If it does, it reads in the
//               root in that namespace and creates and adds it to our
//               list of known roots, if it doesn't already exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::StoreRecognizer(
    LPWSTR Name )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY ADBlobDfsKey;
    BOOLEAN MachineContacted = FALSE;

    DFSSTATUS NewDfsStatus = ERROR_SUCCESS;
    //
    // Make sure the namespace is the name of a machine. FT based
    // dfs exist only on domains.
    //

    if (IsEmptyString(Name) == FALSE) 
    {
        Status = DfsIsThisADomainName( Name );
    }


    DFS_TRACE_LOW(REFERRAL_SERVER, "DfsADBlob:StoreRecognizer, %ws Is domain Status %x\n", 
                  Name, Status);

    
    //
    // Now, open the registry key where we store all the DFS root
    // information.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = GetNewADBlobRegistryKey( Name,
                                          FALSE, // write permission not required
                                          &MachineContacted,
                                          &ADBlobDfsKey );

        if (Status == ERROR_SUCCESS)
        {
            Status = StoreRecognizeNewDfs( Name,
                                           ADBlobDfsKey );

            RegCloseKey( ADBlobDfsKey );
        }
    }

    //
    // Need to refine the return status further: success should mean
    // machine is not domain dfs or we have read the domain dfs data 
    // correctly.
    //
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "DfsADBlob:StoreRecognizer, Status %x\n",
                        Status);

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizer -  the recognizer for the store.
//
//  Arguments:  DfsNameContext - the namespace of interest.
//             LogicalShare
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine checks if the specified namespace holds
//               a domain based DFS. If it does, it reads in the
//               root in that namespace and creates and adds it to our
//               list of known roots, if it doesn't already exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::StoreRecognizer (
    LPWSTR DfsNameContext,
    PUNICODE_STRING pLogicalShare )
{
    DFSSTATUS Status;

    Status = DfsIsThisADomainName( DfsNameContext );

    if (Status == ERROR_SUCCESS)
    {
        Status = StoreRecognizeNewDfs( DfsNameContext,
                                     pLogicalShare );
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "DfsADBlob:StoreRecognizer (remote), Status %x\n",
                          Status);
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateNewRootFolder -  creates a new root folder
//
//  Arguments:
//    LPWSTR DfsNameContextString - name context string
//    LPWSTR RootRegKeyName -  the registry holding the information about this root.
//    PUNICODE_STRING pLogicalShare - the logical share name.
//    PUNICODE_STRING pPhysicalShare - the physical share name.
//    DfsRootFolder **ppRoot - root to return.
//
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine creates a new root folder, and
//               adds it to the list of known roots.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::CreateNewRootFolder (
    LPWSTR DfsNameContextString,
    LPWSTR RootRegKeyName,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRootFolder **ppRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pNewRoot = NULL;

    //
    // Create a new instance of the RegistryRootFolder class.
    // This gives us a reference RootFolder.
    //
    pNewRoot = new DfsADBlobRootFolder( DfsNameContextString,
                                        RootRegKeyName,
                                        pLogicalShare,
                                        pPhysicalShare,
                                        this,
                                        &Status );
    if ( NULL == pNewRoot )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } 

    if ( ERROR_SUCCESS == Status )
    {
        //
        // AddRootFolder to the list of known roots. AddRootFolder
        // is responsible to acquire any reference on the root folder
        // if it is storing a reference to this root.

        Status = AddRootFolder( pNewRoot, NewRootList );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We were successful, return the reference root. The reference
            // that we are returning is the create reference on the new root.
            //
            *ppRoot = pNewRoot;
        }
        else 
        {
            pNewRoot->ReleaseReference();
            pNewRoot = NULL;
        }
    }
    else
    {
        //
        // Our constructor may have failed. E.g. DC may be down.
        // Release our reference to this root and unwind.
        //
        if (pNewRoot != NULL) {
            pNewRoot->ReleaseReference();
            pNewRoot = NULL;
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "ADBlobStore::CreateNewRootFolder. New root %p, for share %wZ (%wZ) on machine %ws. Status %x\n", 
                        pNewRoot, pLogicalShare, pPhysicalShare, DfsNameContextString, Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetMetadataReplicaBlob - gets the replica blob
//
//  Arguments:  DfsMetadataHandle -  the handle to the root
//              MetadataName - name of the metadata
//              ppBlob - the replica blob
//              pBlobSize-size of blob
//              pLastModifiedTime - time the blob was last modified
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information
//               error status otherwise.
//
//
//  Description: This routine read the replica blob and returns a copy
//
//--------------------------------------------------------------------------
DFSSTATUS      
DfsADBlobStore::GetMetadataReplicaBlob(
    IN DFS_METADATA_HANDLE DfsMetadataHandle,
    IN LPWSTR MetadataName,
    OUT PVOID *ppBlob,
    OUT PULONG pBlobSize,
    OUT PFILETIME pLastModifiedTime )
{

    UNREFERENCED_PARAMETER(pLastModifiedTime); // dfsdev: investigate.

    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pMetadata;
    ULONG MetadataSize;
    PVOID pUseBlob;
    ULONG UseBlobSize;
    PVOID pReplicaBlob = NULL;
    ULONG ReplicaBlobSize;

    PDFS_NAME_INFORMATION pNameInformation = NULL;

    Status = GetMetadata( (PVOID)DfsMetadataHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          NULL); // pass NULL For time information.

    if (Status == ERROR_SUCCESS)
    {
        pNameInformation = new DFS_NAME_INFORMATION;
        if(pNameInformation != NULL)
        {
            RtlZeroMemory (pNameInformation, sizeof(DFS_NAME_INFORMATION));
            pUseBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
            UseBlobSize = MetadataSize;
            Status = PackGetNameInformation( pNameInformation,
                                             &pUseBlob,
                                             &UseBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                PackGetULong( &ReplicaBlobSize,
                              &pUseBlob,
                              &UseBlobSize );
                if(ReplicaBlobSize > UseBlobSize)
                {
                    Status = ERROR_INVALID_DATA;
                }
                else
                {
                    pReplicaBlob = (PVOID) new unsigned char [ReplicaBlobSize];
                    if(pReplicaBlob != NULL)
                    {
                        RtlCopyMemory(pReplicaBlob, pUseBlob, ReplicaBlobSize);
                    }
                    else 
                    {
                        Status = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

            }

            delete pNameInformation;
        }
        else 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        ReleaseMetadata( (PVOID)DfsMetadataHandle, pMetadata );
    }

    //
    // If we were successful, return the read in information. Otherwise free
    // up the allocate resources and return error.
    //
    if ( Status == STATUS_SUCCESS )
    {
        *ppBlob = pReplicaBlob;
        *pBlobSize = ReplicaBlobSize;
    }
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetMetadataNameBlob - gets the name blob
//
//  Arguments:  DfsMetadataHandle -  the handle to the root
//              MetadataName - name of the metadata
//              ppBlob - the name blob
//              pBlobSize-size of blob
//              pLastModifiedTime - time the blob was last modified
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information
//               error status otherwise.
//
//
//  Description: This routine read the name blob and returns a copy.
//
//--------------------------------------------------------------------------

DFSSTATUS      
DfsADBlobStore::GetMetadataNameBlob(
    IN DFS_METADATA_HANDLE DfsMetadataHandle,
    IN LPWSTR MetadataName,
    OUT PVOID *ppBlob,
    OUT PULONG pBlobSize,
    OUT PFILETIME pLastModifiedTime )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pMetadata;
    ULONG MetadataSize;
    PVOID pBlob, pUseBlob;
    ULONG UseBlobSize, NameBlobSize;
    PVOID pNameBlob = NULL;

    PDFS_NAME_INFORMATION pNameInformation = NULL;

    Status = GetMetadata( (PVOID)DfsMetadataHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          pLastModifiedTime);

    if (Status == ERROR_SUCCESS)
    {
        pNameInformation = new DFS_NAME_INFORMATION;
        if(pNameInformation != NULL)
        {

            RtlZeroMemory (pNameInformation, sizeof(DFS_NAME_INFORMATION));
            pBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
            pUseBlob = pBlob;
            UseBlobSize = MetadataSize;
            Status = PackGetNameInformation( pNameInformation,
                                             &pUseBlob,
                                             &UseBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                NameBlobSize = MetadataSize - UseBlobSize;
                pNameBlob = (PVOID) new unsigned char [NameBlobSize ];
                if(pNameBlob != NULL)
                {
                    RtlCopyMemory(pNameBlob, pBlob, NameBlobSize );
                }
                else 
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            delete pNameInformation;
        }
        else 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        ReleaseMetadata( (PVOID)DfsMetadataHandle, pMetadata );
    }

    //
    // If we were successful, return the read in information. Otherwise free
    // up the allocate resources and return error.
    //
    if ( Status == STATUS_SUCCESS )
    {
        *ppBlob = pNameBlob;
        *pBlobSize = NameBlobSize;
    }
    return Status;
}
        
DFSSTATUS
DfsADBlobStore::SetMetadataNameBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pNameBlob,
    ULONG NameBlobSize )
{
    PVOID pReplicaBlob, pNewBlob;
    ULONG ReplicaBlobSize, NewBlobSize;
    FILETIME LastTime;
    DFSSTATUS Status;

    Status = GetMetadataReplicaBlob( RootHandle,
                                     MetadataName,
                                     &pReplicaBlob,
                                     &ReplicaBlobSize,
                                     &LastTime );
                                  
    if (Status == ERROR_SUCCESS)
    {
        NewBlobSize = NameBlobSize + ReplicaBlobSize;
        Status = AllocateMetadataBlob( &pNewBlob,
                                       NewBlobSize );
        if (Status == ERROR_SUCCESS)
        {
            RtlCopyMemory(pNewBlob, pNameBlob, NameBlobSize);
            RtlCopyMemory((PVOID)((ULONG_PTR)pNewBlob + NameBlobSize),
                          pReplicaBlob, 
                          ReplicaBlobSize );
            
            Status = SetMetadata( (PVOID)RootHandle,
                                  MetadataName,
                                  NULL,
                                  pNewBlob,
                                  NewBlobSize );

            ReleaseMetadataBlob( pNewBlob );
        }

        ReleaseMetadataReplicaBlob(pReplicaBlob, ReplicaBlobSize );
    }

    return Status;
}


DFSSTATUS
DfsADBlobStore::SetMetadataReplicaBlob(
    DFS_METADATA_HANDLE RootHandle,
    LPWSTR MetadataName,
    PVOID pReplicaBlob,
    ULONG ReplicaBlobSize )
{
    PVOID pNameBlob, pRemainingBlob;
    ULONG NameBlobSize,  RemainingBlobSize;
    PVOID pOldBlob, pNewBlob, pUseBlob;
    ULONG OldBlobSize, NewBlobSize, UseBlobSize;
    ULONG OldReplicaBlobSize;
    PVOID pMetadata;
    ULONG MetadataSize;

    DFSSTATUS Status;
    DFS_NAME_INFORMATION NameInformation;

    Status = GetMetadata( (PVOID)RootHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          NULL); 

    if (Status == ERROR_SUCCESS)
    {
        pNameBlob = pOldBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
        OldBlobSize = MetadataSize;
        Status = PackGetNameInformation( &NameInformation,
                                         &pOldBlob,
                                         &OldBlobSize );

        if (Status == ERROR_SUCCESS)
        {

            Status = PackGetULong( &OldReplicaBlobSize,
                                   &pOldBlob,
                                   &OldBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                pRemainingBlob = (PVOID)((ULONG_PTR)pOldBlob + OldReplicaBlobSize);
                RemainingBlobSize = OldBlobSize - OldReplicaBlobSize;
            }
        }

        if (Status == ERROR_SUCCESS)
        {
            NameBlobSize = PackSizeNameInformation( &NameInformation );

            NewBlobSize = NameBlobSize + sizeof(ULONG) + ReplicaBlobSize + RemainingBlobSize;
            Status =  AllocateMetadataBlob( &pNewBlob, NewBlobSize );



            if (Status == ERROR_SUCCESS)
            {
                SYSTEMTIME CurrentTime;
                FILETIME ModifiedTime;

                pUseBlob = pNewBlob;
                UseBlobSize = NewBlobSize;

                GetSystemTime( &CurrentTime);

                if (SystemTimeToFileTime( &CurrentTime, &ModifiedTime ))
                {
                    NameInformation.LastModifiedTime = ModifiedTime;
                }

                Status = PackSetNameInformation( &NameInformation,
                                                 &pUseBlob,
                                                 &UseBlobSize);

                //
                // At this point, we better have enough space for
                // the rest of the stuff. Otherwise we have an 
                // internal computing problem.
                //
                if (Status == ERROR_SUCCESS)
                {
                    if (UseBlobSize < (sizeof(ULONG) + ReplicaBlobSize + RemainingBlobSize))
                    {
                        Status = ERROR_INVALID_DATA;
                    }
                }


                if (Status == ERROR_SUCCESS)
                {
                    Status = PackSetULong( ReplicaBlobSize,
                                           &pUseBlob,
                                           &UseBlobSize );
                }

                if (Status == ERROR_SUCCESS) 
                {
                    RtlCopyMemory(pUseBlob, pReplicaBlob, ReplicaBlobSize );
                    pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                    UseBlobSize -= ReplicaBlobSize;

                    RtlCopyMemory(pUseBlob, pRemainingBlob, RemainingBlobSize );

                    Status = SetMetadata( (PVOID)RootHandle,
                                          MetadataName,
                                          NULL,
                                          pNewBlob,
                                          NewBlobSize );
                }

                ReleaseMetadataBlob( pNewBlob );
            }
            else 
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        ReleaseMetadata((PVOID)RootHandle, pMetadata );
    }

    return Status;
}





INIT_ADBLOB_DFS_ID_PROPERTY_INFO();
//+-------------------------------------------------------------------------
//
//  Function:   PackGetNameInformation - Unpacks the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete name
//               info structure (as defined by MiADBlobDfsIdProperty). If the stream 
//               does not have the sufficient
//               info, ERROR_INVALID_DATA is returned back.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsADBlobStore::PackGetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status = STATUS_SUCCESS;

    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiADBlobDfsIdProperty );

    if (Status == ERROR_SUCCESS)
    {
        pDfsNameInfo->LastModifiedTime = pDfsNameInfo->PrefixTimeStamp;

        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_AD_BLOB;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetNameInformation - Packs the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to pack.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the name info
//               error status otherwise.
//
//
//  Description: This routine takes the passedin name information and
//               stores it in the binary stream passed in.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsADBlobStore::PackSetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    if ((pDfsNameInfo->Type & 0x80) == 0x80)
    {
        pDfsNameInfo->State &= ~DFS_VOLUME_FLAVORS;
    }

    pDfsNameInfo->PrefixTimeStamp = pDfsNameInfo->LastModifiedTime;
    pDfsNameInfo->StateTimeStamp = pDfsNameInfo->LastModifiedTime;
    pDfsNameInfo->CommentTimeStamp = pDfsNameInfo->LastModifiedTime;

    //
    // Store the DfsNameInfo in the stream first.
    //
    Status = PackSetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiADBlobDfsIdProperty );


    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeNameInformation - Gets the size of the name info.
//
//  Arguments:  pDfsNameInfo - info to size.
//
//  Returns:    Status
//               ULONG - size needed
//
//  Description: This routine gets us the size of the binary stream
//               required to pack the passed in name info.
//
//--------------------------------------------------------------------------
ULONG
DfsADBlobStore::PackSizeNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo )
{
    ULONG Size;

    Size = PackSizeInformation( (ULONG_PTR)pDfsNameInfo,
                                 &MiADBlobDfsIdProperty );

    return Size;
}

DFSSTATUS      
DfsADBlobStore::GetMetadata (
    IN  PVOID DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    OUT PVOID *ppData,
    OUT ULONG *pDataSize,
    OUT PFILETIME pLastModifiedTime)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID pDataBuffer = NULL;
    DfsADBlobCache * pBlobCache = NULL;
    ULONG DataSize = 0;
    ULONG DataType = 0;
    PDFSBLOB_DATA BlobData;
    UNICODE_STRING BlobName;

    UNREFERENCED_PARAMETER (RegistryValueNameString);
    UNREFERENCED_PARAMETER (pLastModifiedTime);

    Status = DfsRtlInitUnicodeStringEx( &BlobName, RelativeName );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsMetadataKey );
    Status = pBlobCache->GetNamedBlob(&BlobName, &BlobData);
    if(Status == STATUS_SUCCESS)
    {
       *ppData = (PVOID) BlobData;
       *pDataSize = BlobData->Size;
    }

    return Status;

}

DFSSTATUS
DfsADBlobStore::SetMetadata (
    IN PVOID DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    IN PVOID pData,
    IN ULONG DataSize)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    UNICODE_STRING BlobName;

    UNREFERENCED_PARAMETER (RegistryValueNameString);
    
    Status = DfsRtlInitUnicodeStringEx( &BlobName, RelativeName );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsMetadataKey );
    Status = pBlobCache->StoreBlobInCache(&BlobName, (PBYTE) pData, DataSize);

    if (Status == ERROR_SUCCESS)
    {
        Status = pBlobCache->WriteBlobToAd();
    }
    DFS_TRACE_LOW(REFERRAL_SERVER, "Done Setting metadata for %p %ws, Status %x\n", pBlobCache, RelativeName, Status);

    return Status;
}


DFSSTATUS
DfsADBlobStore::RemoveMetadata (
    IN PVOID DfsMetadataKey,
    IN LPWSTR RelativeName)

{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsADBlobCache * pBlobCache = NULL;
    UNICODE_STRING BlobName;

    Status = DfsRtlInitUnicodeStringEx( &BlobName, RelativeName );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsMetadataKey );
    Status = pBlobCache->RemoveNamedBlob( &BlobName );

    if (Status == ERROR_SUCCESS)
    {
        Status = pBlobCache->WriteBlobToAd();
    }

    return Status;
}



DFSSTATUS
DfsADBlobStore::CreateADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DCName,
    LPWSTR PhysicalShare,
    LPWSTR LogicalShare,
    LPWSTR Comment,
    BOOLEAN NewRoot)
{    
    DFSSTATUS Status= ERROR_SUCCESS;
    HKEY DfsKey = NULL;
    DfsRootFolder *pRootFolder = NULL;
    DfsRootFolder *pLookupRootFolder = NULL;
    BOOLEAN IsLastRootTarget = FALSE;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    UNICODE_STRING DfsPhysicalShare;

    //
    // We had decided to disallow mismatch on Logical and physical
    // shares, but we are just going to document this.
    //

#if 0
    if (_wcsicmp(LogicalShare, PhysicalShare) != 0)
    {
        return ERROR_INVALID_NAME;
    }
#endif

    DFS_TRACE_LOW( REFERRAL_SERVER, "Dfs ad blob store, create root %ws\n", LogicalShare);
    Status = DfsRtlInitUnicodeStringEx( &DfsShare, LogicalShare );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsPhysicalShare, PhysicalShare );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsMachine, MachineName );
    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }

    if (DfsIsSpecialDomainShare(&DfsShare) ||
         DfsIsSpecialDomainShare(&DfsPhysicalShare))
    {
        Status = ERROR_INVALID_PARAMETER;
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Dfs ad blob store, special share - create root %ws, status %x\n", LogicalShare, Status);
        return Status;
    }

    Status = LookupRoot( &DfsMachine,
                             &DfsShare,
                             &pLookupRootFolder );

    DFS_TRACE_LOW( REFERRAL_SERVER, "Dfs ad blob store, looup root %p, status %x\n", pRootFolder, Status);
    if (Status == ERROR_SUCCESS)
    {
        pLookupRootFolder->ReleaseReference();

         //
         // DO NOT CHANGE this error code. A change here will affect the client
         // The client will tear down the root if we return any other
         // error code here, so be very careful.
         //
         // We also need to return here: the rest of the code assumes this.
         //
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Dfs ad blob store, Already Exists - create root %ws, status %x\n", LogicalShare, Status);

        return ERROR_ALREADY_EXISTS;
    }


    Status = DfsCheckServerRootHandlingCapability();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = GetNewADBlobRegistryKey( MachineName,
                                      TRUE, // write permission required
                                      NULL,
                                      &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
       Status = SetupADBlobRootKeyInformation( DfsKey,
                                               LogicalShare,
                                               PhysicalShare );

            //RegCloseKey( DfsKey );
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = GetRootFolder( NULL,
                                LogicalShare,
                                &DfsShare,
                                &DfsPhysicalShare,
                                &pRootFolder );

        if (Status == ERROR_SUCCESS) 
        {
            Status = pRootFolder->RootRequestPrologue( DCName );


            if (Status == ERROR_SUCCESS)
            {
                Status = AddRootToBlob( MachineName,
                                        pRootFolder,
                                        NewRoot,    //NewRoot,
                                        LogicalShare,
                                        PhysicalShare,
                                        Comment );
                if ((Status == ERROR_FILE_EXISTS) ||
                    (Status == ERROR_ALREADY_EXISTS))
                {
                    Status = ERROR_SUCCESS;
                }


                if (Status == ERROR_SUCCESS)
                {
                    Status = DfsUpdateRootRemoteServerName( LogicalShare,
                                                            DCName,
                                                            MachineName,
                                                            PhysicalShare,
                                                            TRUE );
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = pRootFolder->AcquireRootShareDirectory();

                    //
                    // now mark the root folder as synchronized:
                    // this is true since this root is empty.
                    //
                    if (Status == ERROR_SUCCESS)
                    {
                        pRootFolder->SetRootFolderSynchronized();
                    }
                }
                else
                {
                   (void) pRootFolder->ReleaseRootShareDirectory();
                }

                pRootFolder->RootRequestEpilogue();
            }
        }

    }


    if (Status != ERROR_SUCCESS)
    {
        DFSSTATUS LocalStatus = ERROR_SUCCESS;


        LocalStatus = RegDeleteKey( DfsKey,
                                    LogicalShare );


        LocalStatus = DfsUpdateRootRemoteServerName( LogicalShare,
                                                     DCName,
                                                     MachineName,
                                                     PhysicalShare,
                                                     FALSE );
           
        if(pRootFolder)
        {

            LocalStatus = pRootFolder->RootRequestPrologue( DCName );
            if (LocalStatus == ERROR_SUCCESS) 
            {
                LocalStatus = RemoveRootFromBlob( pRootFolder,
                                                  MachineName,
                                                  PhysicalShare,
                                                  &IsLastRootTarget );

                pRootFolder->RootRequestEpilogue();
            }

            if(IsLastRootTarget)
            {
                DfsDeleteDfsRootObject( DCName,
                                        LogicalShare);
            }


            RemoveRootFolder(pRootFolder, TRUE);
        }
    }

    if(pRootFolder)
    {
        pRootFolder->ReleaseReference();
    }

    if(DfsKey != NULL)
    {
        RegCloseKey( DfsKey );
    }

    //
    // At this point we CANNOT return ERROR_ALREADY_EXISTS. The client
    // will use this code to mean that the DS object it creates is not
    // cleaned up.
    //
    // Does not mean that ERROR_NOT_SUPPORTED is a better error, but till
    // we find one, this should suffice.
    //
    if (Status == ERROR_ALREADY_EXISTS)
    {
        Status = ERROR_NOT_SUPPORTED;
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Dfs ad blob store, create root %ws, status %x\n", LogicalShare, Status);
    return Status;
}


DFSSTATUS
DfsADBlobStore::DeleteADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DCName,
    LPWSTR PhysicalShare,
    LPWSTR LogicalShare )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    DfsRootFolder *pRootFolder = NULL;
    BOOLEAN IsLastRootTarget = FALSE;

    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %ws\n", LogicalShare);

    Status = DfsRtlInitUnicodeStringEx( &DfsMachine, MachineName );
    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsShare, LogicalShare );
    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }

    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pRootFolder );


    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %ws, Lookup root %p, Status %x\n", LogicalShare, pRootFolder, Status);

    if (Status == ERROR_SUCCESS) 
    {
        PUNICODE_STRING pRootPhysicalShare;
        UNICODE_STRING DfsPhysicalShare;

        pRootPhysicalShare = pRootFolder->GetRootPhysicalShareName();
        Status = DfsRtlInitUnicodeStringEx( &DfsPhysicalShare, PhysicalShare);
        if (Status == ERROR_SUCCESS) 
        {
            if (RtlCompareUnicodeString( &DfsPhysicalShare,
                                         pRootPhysicalShare,
                                         TRUE) != 0) 
            {
                Status = ERROR_INVALID_PARAMETER;
            }
        }

        if (Status != ERROR_SUCCESS) 
        {
            pRootFolder->ReleaseReference();
        }
    }


    if (Status == ERROR_SUCCESS)
    {
        Status = pRootFolder->RootApiRequestPrologue(TRUE,
                                                     DCName);

        if (Status == ERROR_SUCCESS)
        {
           Status = DoesUserHaveAccess(pRootFolder, GENERIC_ALL);
           if (Status == ERROR_SUCCESS)
           {
               Status = pRootFolder->AcquireRootLock();
               if(Status == ERROR_SUCCESS)
               {
                   pRootFolder->SetRootFolderDeleteInProgress();
                   pRootFolder->ReleaseRootLock();
               }
           }


           if (Status == ERROR_SUCCESS)
           {
               Status = CleanRegEntry( MachineName, LogicalShare );

               if (Status == ERROR_SUCCESS)
               {

                   Status = DfsUpdateRootRemoteServerName( LogicalShare,
                                                           DCName,
                                                           MachineName,
                                                           PhysicalShare,
                                                           FALSE );
               }
               //
               // Update blob and write it back.
               //


               if (Status == ERROR_SUCCESS)
               { 
                   // dfsdev: move this function to rootfolder class.
                   Status = RemoveRootFromBlob( pRootFolder,
                                                MachineName,
                                                PhysicalShare,
                                                &IsLastRootTarget );

               }

               NTSTATUS DeleteStatus;

               //
               // we are done with this folder. Release the root share directory
               // we had acquired earlier on: this will tell the driver we are 
               // no longer interested on the specified drive.
               //
               DeleteStatus = RemoveRootFolder( pRootFolder, TRUE );
               DFS_TRACE_ERROR_HIGH( DeleteStatus, REFERRAL_SERVER, "remove root folder status %x\n", DeleteStatus);

               DeleteStatus = pRootFolder->ReleaseRootShareDirectory();
               DFS_TRACE_ERROR_LOW( DeleteStatus, REFERRAL_SERVER, "release root dir status %x\n", DeleteStatus);
           }
           pRootFolder->RootApiRequestEpilogue(TRUE,
                                               Status );
        }

        pRootFolder->ReleaseReference();

#if 0

        if(Status != ERROR_SUCCESS)
        {
            DFS_TRACE_HIGH(REFERRAL_SERVER, "remove root folder failed. Trying to recreate root \n");

            CreateADBlobRoot(MachineName,
                             DCName,
                             PhysicalShare,
                             LogicalShare,
                             L"",
                             TRUE );
        }
#endif

    }

    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %p (%ws), Status %x\n", 
                  pRootFolder, LogicalShare, Status);
    return Status;
}


DFSSTATUS
DfsADBlobStore::DeleteADBlobRootForced(
    LPWSTR MachineName,
    LPWSTR DCName,
    LPWSTR PhysicalShare,
    LPWSTR LogicalShare )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;
    DfsRootFolder *pRootFolder = NULL;
    BOOLEAN IsLastRootTarget = FALSE;

    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: delete ad blob root %ws\n", LogicalShare);

    Status = DfsRtlInitUnicodeStringEx( &DfsMachine, MachineName );
    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsShare, LogicalShare );
    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }

    Status = GetCompatRootFolder( &DfsShare,
                                  &pRootFolder );
    
    DFS_TRACE_LOW(REFERRAL_SERVER, "AdBlob: forced delete ad blob root %ws, Lookup root %p, Status %x\n", LogicalShare, pRootFolder, Status);


    if (Status == ERROR_SUCCESS)
    {

        Status = pRootFolder->RootApiRequestPrologue(TRUE,
                                                     DCName);

        if (Status == ERROR_SUCCESS)
        {
            Status = DoesUserHaveAccess(pRootFolder, GENERIC_ALL);

            if (Status == ERROR_SUCCESS)
            {
                Status = pRootFolder->AcquireRootLock();
                if(Status == ERROR_SUCCESS)
                {
                    pRootFolder->SetRootFolderDeleteInProgress();
                    pRootFolder->ReleaseRootLock();
                }
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = DfsUpdateRootRemoteServerName( LogicalShare,
                                                        DCName,
                                                        MachineName,
                                                        PhysicalShare,
                                                        FALSE );

                if (Status == ERROR_SUCCESS)
                {
                    Status = RemoveRootFromBlob( pRootFolder,
                                                 MachineName,
                                                 PhysicalShare,
                                                 &IsLastRootTarget );

                }
            }
            pRootFolder->RootApiRequestEpilogue(TRUE,
                                                Status );
        }

        pRootFolder->ReleaseReference();
    }

    return Status;
}



DFSSTATUS
DfsADBlobStore::RemoveChild(
    DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName )
{

    return RemoveMetadata( (PVOID)DfsHandle, ChildName );
}





//+-------------------------------------------------------------------------
//
//  Function:   AddChild - Add a child to the metadata.
//
//  Arguments:  
//    DfsMetadataHandle - the Metadata key for the root.
//    PUNICODE_STRING pLinkLogicalName - the logical name of the child
//    LPWSTR ReplicaServer - the first target server for this link.
//    LPWSTR ReplicaPath - the target path for this link
//    LPWSTR Comment  - the comment to be associated with this link.
//    LPWSTR pMetadataName - the metadata name for the child, returned..
//
//
//  Returns:    Status: 
//
//  Description: This routine adds a child to the Root metadata. It packs
//               the link name into the name information. If the replica
//               information exists, it packs that into the replica info.
//               It then saves the name and replica streams under the
//               Childkey.
//               NOTE: this function does not require that the link
//               have atleast one replica. Any such requirements
//               should be enforced by the caller.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::AddChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_NAME_INFORMATION pNameInfo,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    IN PUNICODE_STRING pMetadataName)
{
    DFSSTATUS Status;
    PVOID pNameBlob, pReplicaBlob, pNewBlob, pUseBlob;
    ULONG NameBlobSize, ReplicaBlobSize, NewBlobSize, UseBlobSize;

    Status = CreateNameInformationBlob( pNameInfo,
                                        &pNameBlob,
                                        &NameBlobSize );

    if (Status == ERROR_SUCCESS)
    {
        Status = CreateReplicaListInformationBlob( pReplicaListInfo,
                                                   &pReplicaBlob,
                                                   &ReplicaBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            NewBlobSize = NameBlobSize + sizeof(ULONG) + ReplicaBlobSize +
                            3 * sizeof(ULONG);


            Status = AllocateMetadataBlob( &pNewBlob,
                                           NewBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                pUseBlob = pNewBlob;
                UseBlobSize = NewBlobSize;

                RtlCopyMemory( pUseBlob, pNameBlob, NameBlobSize );
                pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + NameBlobSize);
                UseBlobSize -= NameBlobSize;

                PackSetULong( ReplicaBlobSize,
                              &pUseBlob,
                              &UseBlobSize );
                RtlCopyMemory(pUseBlob, pReplicaBlob, ReplicaBlobSize );
                pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                UseBlobSize -= ReplicaBlobSize;

                PackSetULong( 4,
                              &pUseBlob,
                              &UseBlobSize );
                PackSetULong( 0,
                              &pUseBlob,
                              &UseBlobSize );
                PackSetULong( pNameInfo->Timeout,
                              &pUseBlob,
                              &UseBlobSize );

                Status = SetMetadata( (PVOID)DfsHandle,
                                      pMetadataName->Buffer,
                                      NULL,
                                      pNewBlob,
                                      NewBlobSize );

                ReleaseMetadataBlob( pNewBlob );
            }

            ReleaseMetadataReplicaBlob( pReplicaBlob, ReplicaBlobSize );
        }
        ReleaseMetadataNameBlob( pNameBlob, NameBlobSize );
    }

    return Status;
}



DFSSTATUS
DfsADBlobStore::EnumerateApiLinks(
    IN DFS_METADATA_HANDLE DfsHandle,
    PUNICODE_STRING pRootName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG  BufferSize,
    LPDWORD pEntriesToRead,
    LPDWORD pResumeHandle,
    PLONG pSizeRequired )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN OverFlow = FALSE;
    LONG HeaderSize = 0;
    LONG EntriesRead = 0;
    LONG EntriesToRead = *pEntriesToRead;
    LONG SizeRequired = 0;
    LONG EntryCount = 0;
    ULONG ChildNum = 0;
    LPBYTE pLinkBuffer = NULL;
    LONG LinkBufferSize = 0;

    LPBYTE CurrentBuffer = NULL;
    LPBYTE NewBuffer = NULL;
    LONG SizeRemaining = 0;

    DfsADBlobCache * pBlobCache = NULL;
    PDFSBLOB_DATA pBlobData = NULL;
    LONG CurrentCount = 0;
    ULONG_PTR SizeDiff;
    DFSBOB_ITER Iter;

    pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( DfsHandle );

    OverFlow = FALSE;
    Status = DfsApiSizeLevelHeader( Level, &HeaderSize );
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    SizeRequired = ROUND_UP_COUNT(EntriesToRead * HeaderSize, ALIGN_QUAD);

    if (EntriesToRead * HeaderSize < BufferSize )
    {
        CurrentBuffer = (LPBYTE)((ULONG_PTR)pBuffer + EntriesToRead * HeaderSize);
        SizeRemaining = BufferSize - EntriesToRead * HeaderSize;
    }
    else 
    {
        CurrentBuffer = pBuffer;
        SizeRemaining = 0;
        OverFlow = TRUE;
    }


    if(pResumeHandle)
    {
        EntryCount = *pResumeHandle;
    }

    CurrentCount = 0;

    pBlobData = pBlobCache->FindFirstBlob(&Iter);
    while ((pBlobData != NULL) &&
           CurrentCount < EntryCount )
    {
        CurrentCount++;
        pBlobData = pBlobCache->FindNextBlob(&Iter);
    }


    while ((pBlobData != NULL) && (pBlobCache->IsStaleBlob(pBlobData)))
    {
        pBlobData = pBlobCache->FindNextBlob(&Iter);
    }

    if (pBlobData == NULL)
    {
        Status = ERROR_NO_MORE_ITEMS;
    }
    while ((pBlobData != NULL) &&
           (Status == ERROR_SUCCESS))
    {
        //
        // For each child, get the child name.
        //

        if (EntriesToRead && EntriesRead >= EntriesToRead)
        {
            break;
        }

        Status = GetStoreApiInformationBuffer( DfsHandle,
                                               pRootName,
                                               pBlobData->BlobName.Buffer,
                                               Level,
                                               &pLinkBuffer,
                                               &LinkBufferSize );

        if (Status == ERROR_SUCCESS)
        {
            SizeRequired += ROUND_UP_COUNT(LinkBufferSize, ALIGN_QUAD);
                
            if (OverFlow == FALSE) 
            {
                DFSSTATUS PackStatus;
                PackStatus = PackageEnumerationInfo( Level,
                                                     EntriesRead,
                                                     pLinkBuffer,
                                                     pBuffer,
                                                     &CurrentBuffer,
                                                     &SizeRemaining );
                if (PackStatus == ERROR_BUFFER_OVERFLOW)
                {
                    OverFlow = TRUE;
                }
                NewBuffer = (LPBYTE)ROUND_UP_POINTER( CurrentBuffer, ALIGN_LPVOID);
                SizeDiff = (NewBuffer - CurrentBuffer);
                if ((LONG)SizeDiff > SizeRemaining)
                {
                    SizeRemaining = 0;
                }
                else 
                {
                    SizeRemaining -= (LONG)SizeDiff;
                }
                CurrentBuffer = NewBuffer;
            }

            ReleaseStoreApiInformationBuffer( pLinkBuffer );
            EntryCount++;
            EntriesRead++;
        }
        pBlobData = pBlobCache->FindNextBlob(&Iter);
        while ((pBlobData != NULL) && (pBlobCache->IsStaleBlob(pBlobData)))
        {
            pBlobData = pBlobCache->FindNextBlob(&Iter);
        }
        if (pBlobData == NULL)
        {
            Status = ERROR_NO_MORE_ITEMS;
        }
    }


    pBlobCache->FindCloseBlob(&Iter);

    *pSizeRequired = SizeRequired;

    if (Status == ERROR_NO_MORE_ITEMS) 
    {
        if (EntriesRead) 
        {
            if (OverFlow) 
            {
                Status = ERROR_BUFFER_OVERFLOW;
            }
            else
            {
                Status = ERROR_SUCCESS;
            }
        }

    }
    else if (OverFlow)
    {
        Status = ERROR_BUFFER_OVERFLOW;
    }
    
    if (Status == ERROR_SUCCESS)
    {
        if(pResumeHandle)
        {
            *pResumeHandle = EntryCount;
        }
        *pEntriesToRead = EntriesRead;
    }

    return Status;
}

DFSSTATUS
DfsADBlobStore::AddRootToBlob( 
    LPWSTR MachineName,
    DfsRootFolder *pRootFolder,
    BOOLEAN   NewRoot,
    LPWSTR    LogicalShare,
    LPWSTR    ShareName,
    LPWSTR    Comment )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status;

    UNICODE_STRING DomainName;
    UNICODE_STRING LogicalName, RootMetadataName;

    DFS_NAME_INFORMATION NameInfo;
    DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
    DFS_REPLICA_INFORMATION ReplicaInfo;
    UUID NewUid;
    LPWSTR RootMetadataNameString = NULL;

    Status = DfsRtlInitUnicodeStringEx( &RootMetadataName, RootMetadataNameString);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = UuidCreate(&NewUid);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }


    Status = pRootFolder->GetMetadataHandle( &RootHandle );

    if (Status == ERROR_SUCCESS)
    {
        if (NewRoot == FALSE) 
        {
            Status = pRootFolder->Synchronize(FALSE, TRUE);        
            if (Status == ERROR_SUCCESS)
            {
                Status = RootEntryExists((PVOID)RootHandle, &NewRoot);
            }
        }
        
        if (Status == ERROR_SUCCESS) 
        {
            if (NewRoot)
            {
                Status = DfsGetDomainName(&DomainName);
                if (Status == ERROR_SUCCESS)
                {
                    Status = DfsCreateUnicodePathString( &LogicalName,
                                                         1, // 1 leading path seperator.
                                                         DomainName.Buffer,
                                                         LogicalShare);
                    if (Status == ERROR_SUCCESS)
                    {
                        StoreInitializeNameInformation( &NameInfo,
                                                        &LogicalName,
                                                        &NewUid,
                                                        Comment );

                        NameInfo.Type |= PKT_ENTRY_TYPE_REFERRAL_SVC;

                        StoreInitializeReplicaInformation( &ReplicaListInfo,
                                                           &ReplicaInfo,
                                                           MachineName,
                                                           ShareName );

                        Status = AddChild( RootHandle,
                                           &NameInfo,
                                           &ReplicaListInfo,
                                           &RootMetadataName );
                    
                        DfsFreeUnicodeString( &LogicalName);
                    }
                    DfsFreeUnicodeString( &DomainName );
                }
            }
            else
            {
                Status = AddChildReplica( RootHandle,
                                          RootMetadataNameString,
                                          MachineName,
                                          ShareName );
            }
        }
        pRootFolder->ReleaseMetadataHandle( RootHandle );
    }

    return Status;
}


DFSSTATUS
DfsADBlobStore::RemoveRootFromBlob(
    DfsRootFolder *pRootFolder,
    LPWSTR    MachineName,
    LPWSTR    ShareName,
    PBOOLEAN  pLastRoot )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN LastRoot = FALSE;
    DfsADBlobCache *pBlobCache = NULL;
    LPWSTR RootMetadataNameString = NULL;

    Status = pRootFolder->GetMetadataHandle( &RootHandle );
    if (Status == ERROR_SUCCESS)
    {
        Status = RemoveChildReplica( RootHandle,
                                     RootMetadataNameString,
                                     MachineName,
                                     ShareName,
                                     &LastRoot,
                                     TRUE);

        if((Status == ERROR_SUCCESS) || (Status == ERROR_LAST_ADMIN))
        {
            if (LastRoot)
            {
                pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( RootHandle);
                pBlobCache->InvalidateCache();
                pBlobCache->WriteBlobToAd();

            }

            Status = ERROR_SUCCESS;

        }
        pRootFolder->ReleaseMetadataHandle( RootHandle );
    }

    if (Status == ERROR_SUCCESS)
    {
        *pLastRoot = LastRoot;
    }

    return Status;
}




DFSSTATUS
DfsADBlobStore::GetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    OUT PDFS_NAME_INFORMATION *ppInfo )
{
    PVOID pBlob, pUseBlob;
    ULONG UseBlobSize, ReplicaBlobSize, RecoveryBlobSize;
    FILETIME BlobModifiedTime;
    PVOID pMetadata;
    ULONG MetadataSize;
    PDFS_NAME_INFORMATION pNewInfo = NULL;
    DFSSTATUS Status;


    Status = GetMetadata( (PVOID)RootHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          &BlobModifiedTime);

    if (Status == ERROR_SUCCESS)
    {

        pBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;

        pNewInfo = new DFS_NAME_INFORMATION;
        if (pNewInfo != NULL)
        {
            RtlZeroMemory (pNewInfo, sizeof(DFS_NAME_INFORMATION));

            pUseBlob = pBlob;
            UseBlobSize = MetadataSize;

            Status = PackGetNameInformation( pNewInfo,
                                             &pUseBlob,
                                             &UseBlobSize );

            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &ReplicaBlobSize,
                                       &pUseBlob,
                                       &UseBlobSize );

                if (Status == ERROR_SUCCESS)
                {

                    if(ReplicaBlobSize > UseBlobSize)
                    {
                        Status = ERROR_INVALID_DATA;
                    }
                    else
                    {
                        pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                        UseBlobSize -= ReplicaBlobSize;
                    }
                }
            }
    
            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &RecoveryBlobSize,
                                       &pUseBlob,
                                       &UseBlobSize );
                if (Status == ERROR_SUCCESS)
                {

                    if(RecoveryBlobSize > UseBlobSize)
                    {
                        Status = ERROR_INVALID_DATA;
                    }
                    else
                    {
                        pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + RecoveryBlobSize);
                        UseBlobSize -= RecoveryBlobSize;
                    }
                }
            }

            if (Status == ERROR_SUCCESS)
            {
                Status = PackGetULong( &pNewInfo->Timeout,
                                       &pUseBlob,
                                       &UseBlobSize );
            }


            if (Status != ERROR_SUCCESS)
            {
                ReleaseMetadata( (PVOID)RootHandle, pMetadata );
                delete pNewInfo;
            }
        }
        else 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if (Status == ERROR_SUCCESS)
    {
        pNewInfo->pData = pMetadata;
        pNewInfo->DataSize = MetadataSize;
        *ppInfo = pNewInfo;
    }

    return Status;
}
        
VOID
DfsADBlobStore::ReleaseMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    ReleaseMetadata( (PVOID)RootHandle, pNameInfo->pData );
    delete [] pNameInfo;
}


DFSSTATUS
DfsADBlobStore::SetMetadataNameInformation(
    IN DFS_METADATA_HANDLE RootHandle,
    IN LPWSTR MetadataName,
    IN PDFS_NAME_INFORMATION pNameInfo )
{
    PVOID pBlob, pUseBlob, pNewBlob;
    ULONG UseBlobSize, NewBlobSize;
    ULONG ReplicaBlobSize, RecoveryBlobSize;
    DFSSTATUS Status;
    PVOID pNameBlob;
    ULONG NameBlobSize;
    FILETIME BlobModifiedTime;
    PVOID pMetadata;
    ULONG MetadataSize;

    SYSTEMTIME CurrentTime;
    FILETIME ModifiedTime;

    GetSystemTime( &CurrentTime);

    if (SystemTimeToFileTime( &CurrentTime, &ModifiedTime ))
    {
        pNameInfo->LastModifiedTime = ModifiedTime;
    }




    Status = CreateNameInformationBlob( pNameInfo,
                                        &pNameBlob,
                                        &NameBlobSize );


    if (Status == ERROR_SUCCESS)
    {
        Status = GetMetadata( (PVOID)RootHandle,
                          MetadataName,
                          NULL,
                          &pMetadata,
                          &MetadataSize,
                          &BlobModifiedTime);
    }
    
    if (Status == ERROR_SUCCESS)
    {
        DFS_NAME_INFORMATION NameInformation;
        pBlob = ((PDFSBLOB_DATA)(pMetadata))->pBlob;
        pUseBlob = pBlob;
        UseBlobSize = MetadataSize;
        Status = PackGetNameInformation( &NameInformation,
                                         &pUseBlob,
                                         &UseBlobSize );
        if (Status == ERROR_SUCCESS)
        {
            NewBlobSize = NameBlobSize + UseBlobSize;
            Status = AllocateMetadataBlob( &pNewBlob,
                                           NewBlobSize );
            if (Status == ERROR_SUCCESS)
            {
                RtlCopyMemory(pNewBlob, pNameBlob, NameBlobSize);
                RtlCopyMemory((PVOID)((ULONG_PTR)pNewBlob + NameBlobSize),
                              pUseBlob, 
                              UseBlobSize );



                pUseBlob = (PVOID)((ULONG_PTR)pNewBlob + NameBlobSize);

                if (Status == ERROR_SUCCESS)
                {
                    Status = PackGetULong( &ReplicaBlobSize,
                                           &pUseBlob,
                                           &UseBlobSize );
                    if (Status == ERROR_SUCCESS)
                    {
                        pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + ReplicaBlobSize);
                        UseBlobSize -= ReplicaBlobSize;
                    }
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = PackGetULong( &RecoveryBlobSize,
                                           &pUseBlob,
                                           &UseBlobSize );
                    if (Status == ERROR_SUCCESS)
                    {
                        pUseBlob = (PVOID)((ULONG_PTR)pUseBlob + RecoveryBlobSize);
                        UseBlobSize -= RecoveryBlobSize;
                    }
                }
                if (Status == ERROR_SUCCESS)
                {
                    Status = PackSetULong( pNameInfo->Timeout,
                                           &pUseBlob,
                                           &UseBlobSize );
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = SetMetadata( (PVOID)RootHandle,
                                          MetadataName,
                                          NULL,
                                          pNewBlob,
                                          NewBlobSize );
                }
                ReleaseMetadataBlob( pNewBlob );
            }
        }
        ReleaseMetadata( (PVOID)RootHandle, pMetadata );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   RenameLinks
//
//  Arguments: 
//    RootHandle - handle to root's metadata
//    OldDomainName
//    NewDomainName 
//
//  Returns:   SUCCESS or error
//
//  Description: Renames all links referencing the old domain name to the new.
//             To do that, this retrieves NameInformation as well as ReplicaInformation
//             from the blob cache. Once done, the metadata are written back to the
//             cache. Flushing the metadata to the AD or aborting the changes is
//             the caller's responsibility.
//--------------------------------------------------------------------------

DFSSTATUS
DfsADBlobStore::RenameLinks(
    DFS_METADATA_HANDLE RootHandle,
    IN PUNICODE_STRING pLinkMetadataName,
    IN PUNICODE_STRING pOldDomainName,
    IN PUNICODE_STRING pNewDomainName)
{
    DFSSTATUS Status;
        
    //
    // Change the NameInfo structure first.
    //
    Status = RenameNameInfo( RootHandle, 
                             pLinkMetadataName,
                             pNewDomainName,
                             pOldDomainName );   

    //
    //  We've successfully renamed the prefix in the NameInfo. Now see if there are
    //  any links to change in the Replica List.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = RenameReplicaInfo( RootHandle, 
                                  pLinkMetadataName,
                                  pNewDomainName,
                                  pOldDomainName);
          
    }
            
    return Status;
}

//
// RenameNameInfoPrefix - replace both the Prefix and the ShortPrefix.
//      SUCCESS indicates a successful rename.
//
//

DFSSTATUS
DfsADBlobStore::RenameNameInfo(
    IN DFS_METADATA_HANDLE RootHandle,
    IN PUNICODE_STRING pLinkMetadataName,
    IN PUNICODE_STRING pNewDomainName,
    IN PUNICODE_STRING pOldDomainName)
{
    DFSSTATUS Status;
    PDFS_NAME_INFORMATION pNameInfo;
    UNICODE_STRING FirstComponent;
    
    Status = GetMetadataNameInformation( RootHandle,
                                       pLinkMetadataName->Buffer,
                                       &pNameInfo);
    if (Status != ERROR_SUCCESS)
    {    
        return Status;
    }
    
    //
    // Sanity check the Prefix string of the NameInfo.
    // Although the LinkMetadataName is NULL for
    // the root the NameInfo->Prefix has the real name.
    //
    Status = DfsGetFirstComponent( &pNameInfo->Prefix, &FirstComponent, NULL );

    if ((Status != ERROR_SUCCESS) ||
       (RtlEqualDomainName(pOldDomainName, &FirstComponent) == FALSE))
    {
        ReleaseMetadataNameInformation( RootHandle, pNameInfo );
        return Status;
    }
    
    //
    //  We have a match. Just replace that first component with the 
    //  new domain name. The substitution happens in place, so we ideally should save
    //  the old pointer to patch back the nameinfo snapshot afterwards.
    // 
    Status = GenerateMetadataLogicalName(pNewDomainName, 
                                        &pNameInfo->Prefix, 
                                        &pNameInfo->Prefix);
    if (Status == ERROR_SUCCESS)
    {
        //
        //  Similarly, change the ShortPrefix as well. We don't just assume
        //  that they are identical, although in practice they are currently.
        //
        Status = GenerateMetadataLogicalName(pNewDomainName, 
                                          &pNameInfo->ShortPrefix, 
                                          &pNameInfo->ShortPrefix);

        //  We don't bother to modify the timestamps.
          
        //
        //  We don't bother to undo our previous changes if we get errors.
        //  The understanding is that the whole metadata blob will be
        //  thrown away without getting written back to the AD. Just free the old
        //  NameInfo strings on our way out.
        //
        if (Status == ERROR_SUCCESS)
        {
            Status = SetMetadataNameInformation( RootHandle, 
                               pLinkMetadataName->Buffer,
                               pNameInfo );
            
            ReleaseMetadataLogicalName( &pNameInfo->ShortPrefix );
        }
        ReleaseMetadataLogicalName( &pNameInfo->Prefix );
    }

    //
    // Release our snapshot of the blob. This doesn't write the changes back to the cache;
    // the SetMetadata above does that.
    //
    ReleaseMetadataNameInformation( RootHandle, pNameInfo );
    return Status;
}

//
//  RenameReplicaInfo - Walk through the replica list and replace stale domain names.
//
DFSSTATUS
DfsADBlobStore::RenameReplicaInfo(
    IN DFS_METADATA_HANDLE RootHandle,
    IN PUNICODE_STRING pLinkMetadataName,
    IN PUNICODE_STRING pNewDomainName,
    IN PUNICODE_STRING pOldDomainName)
{
    DFSSTATUS Status;
    PUNICODE_STRING pReplicaName;   
    PDFS_REPLICA_LIST_INFORMATION pReplicaList;
    BOOLEAN RenamedLink = FALSE;
    ULONG i;

    //
    // Get a snapshot of the replica set.
    //
    Status = GetMetadataReplicaInformation( RootHandle,
                                        pLinkMetadataName->Buffer,
                                        &pReplicaList );
    if (Status != ERROR_SUCCESS)
    {    
        return Status;
    }

    //
    //  Go through all its links looking for a match of the stale domain name.
    //
    for (i = 0; i < pReplicaList->ReplicaCount; i++)
    {
        pReplicaName = &pReplicaList->pReplicas[i].ServerName;
        
        //
        //  The names must match to change the replica.
        //
        if (!RtlEqualDomainName( pOldDomainName, pReplicaName ))
        {
            continue;
        }  
                
        // XXX: Ideally we should keep a pointer to the old ServerName
        // and put it back after we SetMetadata and before we release
        // this NameInfo snapshot. The current logic basically assumes that losing
        // the old pointer doesn't end in a memory leak (TRUE currently).
        //      
        Status = DfsRtlInitUnicodeStringEx( pReplicaName, pNewDomainName->Buffer );
        if (Status != ERROR_SUCCESS)
        {
            // The rootfolder will resynchronize to revert the changes.
            break;
        }
        
        RenamedLink = TRUE;     
    }

    if ((Status == ERROR_SUCCESS) && 
       (RenamedLink))
    {
        //
        //  Put the blob back in the cache if we've changed any of it. 
        //  We don't need to make this operation atomic with respect to
        //  NameInfo changes because if any of these fails, the caller's supposed to
        //  purge the cache with a ReSynchronize().
        //
        Status = SetMetadataReplicaInformation( RootHandle, 
                                            pLinkMetadataName->Buffer,
                                            pReplicaList );
    }
    ReleaseMetadataReplicaInformation( RootHandle, pReplicaList );
    return Status;
}


//
//  This removes the target share from the 
//  Microsoft\Dfs\Roots\Domain registry key.
//
DFSSTATUS
DfsADBlobStore::CleanRegEntry(
    LPWSTR MachineName,
    LPWSTR LogicalShare
    )
{
    HKEY FtDfsKey;
    DFSSTATUS Status;
    DFSSTATUS RetStatus = ERROR_NOT_FOUND;
    
    Status = GetNewADBlobRegistryKey( MachineName,
                                      TRUE, // write permission required
                                      NULL,
                                      &FtDfsKey );

    if (Status == ERROR_SUCCESS) 
    {
        
        Status = RegDeleteKey( FtDfsKey,
                              LogicalShare );

        // Return success only if something got successfully deleted.
        if (Status == ERROR_SUCCESS)
        {
            RetStatus = Status;
        }
        
        RegCloseKey( FtDfsKey );
    }

    return RetStatus;
}

DFSSTATUS
DfsADBlobStore::GenerateApiLogicalPath ( 
    IN PUNICODE_STRING pRootName,
    IN PUNICODE_STRING pMetadataPrefix,
    IN PUNICODE_STRING pApiLogicalName )
{

    DFSSTATUS Status;
    UNICODE_STRING FirstComponent;
    UNICODE_STRING Remaining;
    //
    // For the ad blob store, the metadata prefix holds the
    // name context, the share name and the link name.
    // However, we will want to replace the first component
    // with the rootname, so that when domains are renamed,
    // we keep passing back correct information even though
    // the blob has not been updated.
    //
    if (DfsCheckSubstitutePaths())
    {
        Status = DfsGetFirstComponent( pMetadataPrefix,
                                       &FirstComponent,
                                       &Remaining );
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsCreateUnicodePathStringFromUnicode( pApiLogicalName,
                                                            2, // 2 leading path sep
                                                            pRootName,
                                                            &Remaining );
        }
    } else
    {
        //
        //  The caller has disabled path name substitution because she wants to see
        //  things as is. So just make a copy.
        //
        
        Status = DfsCreateUnicodePathStringFromUnicode(pApiLogicalName,
                                                   2, // 2 leading path separators
                                                   pMetadataPrefix,
                                                   NULL); 
    }

    return Status;
}
 


DFSSTATUS
DfsADBlobStore::GetCompatRootFolder( 
    PUNICODE_STRING pName,
    DfsRootFolder **ppNewRoot )
{
    DfsADBlobRootFolder *pNewRoot = NULL;
    UNICODE_STRING DomainName;
    DFSSTATUS Status = ERROR_SUCCESS;

    *ppNewRoot = NULL;
    
    Status = DfsGetDomainName( &DomainName );
    if (Status != ERROR_SUCCESS) 
    {
        return Status;
    }

    pNewRoot = new DfsADBlobRootFolder( DomainName.Buffer,
                                        L"Unknown",
                                        pName,
                                        pName,
                                        this, 
                                        &Status );
    //
    // The root folder made a copy of this, so we are safe to delete.
    //
    DfsReleaseDomainName( &DomainName );
            
    // The new operator may fail.
    if (pNewRoot == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        return Status;
    }

    if (Status == ERROR_SUCCESS) 
    {
        pNewRoot->ResetCreateDirectories();

        //set this so we read from this DC, instead of the PDC.
        pNewRoot->SetRootScalabilityMode();

        Status = pNewRoot->Synchronize( TRUE );

        if (Status == ERROR_SUCCESS)
        {
            *ppNewRoot = pNewRoot;
        }
    } 

    if (Status != ERROR_SUCCESS)
    {
        ASSERT(pNewRoot);
        pNewRoot->ReleaseReference();
    }

    return Status;
}

DFSSTATUS
DfsADBlobStore::DoesUserHaveAccess(DfsRootFolder *pRootFolder,
                                   DWORD DesiredAccess)
{
    DFS_METADATA_HANDLE RootHandle = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsADBlobCache *pBlobCache = NULL;

    Status = pRootFolder->GetMetadataHandle( &RootHandle );
    if (Status == ERROR_SUCCESS)
    {
        pBlobCache = (DfsADBlobCache *)ExtractFromMetadataHandle( RootHandle);

        Status = pBlobCache->DfsDoesUserHaveAccess(DesiredAccess);

        pRootFolder->ReleaseMetadataHandle( RootHandle );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsadsiapi.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsAdsiApi.cxx
//
//  Contents:   Contains APIs to communicate with the DS
//
//  Classes:    none.
//
//  History:    March. 13 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include "DfsAdsiAPi.hxx"
#include "DfsError.hxx"
#include "dfsgeneric.hxx"
#include "dfsinit.hxx"
#include "lm.h"
#include "lmdfs.h"
 
#include "strsafe.h"
#include "dsgetdc.h"
//
// dfsdev: comment this properly.
//
LPWSTR RootDseString=L"LDAP://RootDSE";

//
// The prefix for AD path string. This is used to generate a path of
// the form "LDAP://<dcname>/CN=,...DC=,..."
//
LPWSTR LdapPrefixString=L"LDAP://";

DFSSTATUS
DfsCreateDN(
    OUT LPWSTR PathString,
    IN size_t CharacterCount,
    LPWSTR DCName,
    LPWSTR PathPrefix,
    LPWSTR *CNNames );

DFSSTATUS
DfsGenerateRootCN(
    LPWSTR RootName,
    LPWSTR *pRootCNName);

VOID
DfsDeleteRootCN(
    LPWSTR PathString);

DFSSTATUS
DfsGenerateADPathString(
    IN LPWSTR DCName,
    IN LPWSTR ObjectName,
    IN LPWSTR PathPrefix,
    OUT LPOLESTR *pPathString);

VOID
DfsDeleteADPathString(
    LPWSTR PathString);

DFSSTATUS
DfsGetADObjectWithDsGetDCName(
    LPWSTR DCName,
    REFIID Id,
    LPWSTR ObjectName,
    ULONG   GetDCFlags,
    PVOID *ppObject );


//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateDN
//
//  Arguments:  
//    OUT LPWSTR PathString -> updated pathstring on return
//    IN size_t CharacterCount -> number of characters in PathString
//    LPWSTR DCName -> DcNAME to use
//    LPWSTR PathPrefix -> path prefix if any
//    LPWSTR *CNNames -> Array of CNNames.

//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description:  dfscreatedn take a pathstring and fills it with the
//                information necessary for the path to be used as a
//                Distinguished Name.
//                It starts the string with LDAP://, follows that with
//                a DCName if supplied, and then adds the array of 
//                CNNames passed in one after the other , each one 
//                followed by a , the final outcome is something like:
//                LDAP://ntdev-dc-01/CN=Dfs-Configuration, CN=System, Dc=Ntdev, etc
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsCreateDN(
    OUT LPWSTR PathString,
    IN size_t CharacterCount,
    LPWSTR DCName,
    LPWSTR PathPrefix,
    LPWSTR *CNNames )
{
    LPWSTR *InArray = CNNames;
    LPWSTR CNName;
    HRESULT HResult = S_OK;
    size_t CurrentCharacterCount = CharacterCount;
    DFSSTATUS Status = ERROR_SUCCESS;
    //
    // If we are not adding the usual "LDAP://" string,
    // Start with a NULL so string cat will work right.
    //

    if (CurrentCharacterCount <=0 ) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (PathPrefix != NULL)
    {
        HResult = StringCchCopy( PathString,
                                 CurrentCharacterCount,
                                 PathPrefix );
    } else {
    
        *PathString = UNICODE_NULL;
    }
    
    if (SUCCEEDED(HResult)) {
        //
        // if the dc name is specified, we want to go to a specific dc
        // add that in.
        //
        if (!IsEmptyString(DCName))
        {
            HResult = StringCchCat( PathString,
                                    CurrentCharacterCount,
                                    DCName );

            if (SUCCEEDED(HResult)) 
            {
                HResult = StringCchCat( PathString,
                                        CurrentCharacterCount,
                                        L"/" );
            }
        }
    }
    //
    // Now treat the CNNames as an array of LPWSTR and add each one of
    // the lpwstr to our path.
    //

    if (SUCCEEDED(HResult)) {
        if (CNNames != NULL)
        {
            while (((CNName = *InArray++) != NULL) &&
                   (SUCCEEDED(HResult)))
            {
                HResult = StringCchCat( PathString,
                                        CurrentCharacterCount,
                                        CNName );

                if ((*InArray != NULL) &&
                    (SUCCEEDED(HResult)))
                {
                    HResult = StringCchCat( PathString,
                                            CurrentCharacterCount,
                                            L"," );
                }
            }
        }
    }

    if (!SUCCEEDED(HResult))
    {
        Status = HRESULT_CODE(HResult);
    }
    return Status;
}

DFSSTATUS
DfsGenerateDfsAdNameContext(
    PUNICODE_STRING pString )

{
    IADs *pRootDseObject;
    HRESULT HResult;
    VARIANT VarDSRoot;
    DFSSTATUS Status = ERROR_SUCCESS;
    BSTR NamingContext;

    NamingContext = SysAllocString(L"defaultNamingContext");
    if (NamingContext == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    HResult = ADsGetObject( RootDseString,
                            IID_IADs,
                            (void **)&pRootDseObject );
    
    if (SUCCEEDED(HResult))
    {
        VariantInit( &VarDSRoot );
        // Get the Directory Object on the root DSE, to get to the server configuration
        HResult = pRootDseObject->Get(NamingContext, &VarDSRoot);

        if (SUCCEEDED(HResult))
        {
            Status = DfsCreateUnicodeStringFromString( pString,
                                                       (LPWSTR)V_BSTR(&VarDSRoot) );
        }

        VariantClear(&VarDSRoot);

        pRootDseObject->Release();
    }

    if (!SUCCEEDED(HResult)) 
    {
        Status = DfsGetErrorFromHr(HResult);
    }

    SysFreeString(NamingContext);
    return Status;
}


DFSSTATUS
DfsGenerateDfsAdNameContextForDomain(
    PUNICODE_STRING pString,
    LPWSTR DCName )

{
    IADs *pRootDseObject;
    HRESULT HResult;
    VARIANT VarDSRoot;
    DFSSTATUS Status = ERROR_SUCCESS;
    BSTR NamingContext;
    LPWSTR CNNames[2];
    LPWSTR PathString = NULL;
    CNNames[0] = L"RootDSE";
    CNNames[1] = NULL;

    size_t CharacterCount = 1;
    
    CharacterCount += wcslen(LdapPrefixString);
    if (DCName)
    {
        CharacterCount += wcslen(DCName) + 1;
        CharacterCount++;
    }
    CharacterCount += wcslen(CNNames[0]) + 1;
    CharacterCount++;

    PathString = new WCHAR[CharacterCount];
    if (PathString == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Status = DfsCreateDN( PathString, 
                          CharacterCount,
                          DCName, 
                          LdapPrefixString,
                          CNNames);

    if (Status == ERROR_SUCCESS)
    {
        NamingContext = SysAllocString(L"defaultNamingContext");
        if (NamingContext == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status == ERROR_SUCCESS)
        {

            HResult = ADsGetObject( PathString,
                                    IID_IADs,
                                    (void **)&pRootDseObject );
    
            if (SUCCEEDED(HResult))
            { 
                VariantInit( &VarDSRoot );
                // Get the Directory Object on the root DSE, to get to the server configuration
                HResult = pRootDseObject->Get(NamingContext, &VarDSRoot);

                if (SUCCEEDED(HResult))
                {
                    Status = DfsCreateUnicodeStringFromString( pString,
                                                               (LPWSTR)V_BSTR(&VarDSRoot) );
                }

                VariantClear(&VarDSRoot);

                pRootDseObject->Release();
            }

            if (!SUCCEEDED(HResult)) 
            {
                Status = DfsGetErrorFromHr(HResult);
            }

            SysFreeString(NamingContext);
        }
        delete [] PathString;
    }

    return Status;
}


#define MAX_CN_ARRAY 5

DFSSTATUS
DfsGenerateADPathString(
    IN LPWSTR DCName,
    IN LPWSTR ObjectName,
    IN LPWSTR PathPrefix,
    OUT LPWSTR *pPathString)
{
    LPWSTR CNNames[MAX_CN_ARRAY];
    ULONG Index;
    LPWSTR ADNameContext;
    size_t CharacterCount = 0;
    size_t UseCount;
    HRESULT HResult = S_OK;
    
    DFSSTATUS Status = ERROR_SUCCESS;
    
    do {
        CharacterCount = 1; // For null termination;

        if (PathPrefix != NULL) 
        {
            Status = DfsStringCchLength( PathPrefix,
                                       MAXUSHORT,
                                       &UseCount);
            if (Status != ERROR_SUCCESS) 
                break;

            CharacterCount += UseCount + 1; // path prefix + seperator
        }

        //
        // ADNameContext will be of the form CN=NtDev, CN=Micorosft etc etc.
        //
        ADNameContext = DfsGetDfsAdNameContextString();
        if (ADNameContext == NULL)
        {
            Status = ERROR_NOT_READY;
            break;
        }
        
        if (DCName != NULL)
        {
            Status = DfsStringCchLength( DCName,
                                       MAXUSHORT,
                                       &UseCount);
            if (Status != ERROR_SUCCESS) 
                break;
                
            CharacterCount += UseCount + 1; //dcname + seperator;
        }

        if (ObjectName != NULL)
        {
            Status = DfsStringCchLength( ObjectName,
                                       MAXUSHORT,
                                       &UseCount);
            if (Status != ERROR_SUCCESS) 
                break;

            CharacterCount += UseCount + 1; //ObjectName + seperator
        }
        
        Status = DfsStringCchLength( DFS_AD_CONFIG_DATA,
                                       MAXUSHORT,
                                       &UseCount);
        if (Status != ERROR_SUCCESS) 
            break;

        CharacterCount += UseCount + 1; // config container + seperator;
        
        Status = DfsStringCchLength( ADNameContext,
                                       MAXUSHORT,
                                       &UseCount);
        
        if (Status != ERROR_SUCCESS) 
            break;
            
        CharacterCount += UseCount + 1; //context + seperator;

        //
        // Note: Be very wary here. We have a fixed CNNames array, and
        // we are using that knowledge here. Adding any more CNNames
        // needs to bump up the array count.
        //
        Index = 0;
        if (ObjectName != NULL)
        {
            CNNames[Index++] = ObjectName;
        }
        CNNames[Index++] = DFS_AD_CONFIG_DATA;
        CNNames[Index++] = ADNameContext;
        CNNames[Index] = NULL;


        *pPathString = new WCHAR[CharacterCount];
        if (*pPathString == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Status = DfsCreateDN( *pPathString, 
                              CharacterCount,
                              DCName, 
                              PathPrefix, 
                              CNNames);
        if (Status != ERROR_SUCCESS) 
        {
            delete [] *pPathString;
            *pPathString = NULL;
            break;
        }
        
    } while (FALSE);
    
    return Status;
}

VOID
DfsDeleteADPathString(
    LPWSTR PathString)
{
    delete [] PathString;
    return NOTHING;
}


DFSSTATUS
DfsGetADObjectWithDsGetDCName(
    LPWSTR DCName,
    REFIID Id,
    LPWSTR ObjectName,
    ULONG   GetDCFlags,
    PVOID *ppObject )
//
//  This function calls ADSI to open the object.  Alas, we're not thrilled with
//  how ADSI does DC-stickyness so we'll work around that by getting the DC 
//  name and passing it in to ADSI ourselves so that they don't have to bother.
//
{
    HRESULT HResult;
    LPWSTR PathString;
    DFSSTATUS Status;
    LPWSTR DCNameToUse = DCName;        // may be DCName or pointer into dcInfo
    DOMAIN_CONTROLLER_INFO *dcInfo = NULL;  // be sure to free if not null

    if (DCName == NULL) {

        Status = DsGetDcName(   NULL,       // computer name
                                NULL,       // domain name
                                NULL,       // domain guid
                                NULL,       // site name
                                GetDCFlags,
                                &dcInfo
                            );
    
        if ((Status == ERROR_SUCCESS) && (dcInfo->DomainControllerName != NULL)) {
    
            DCNameToUse = dcInfo->DomainControllerName;
    
            // don't include the double slashes at the front of the DC name
    
            while (*DCNameToUse == L'\\') {
                DCNameToUse++;
            }
        }
    }   

    Status = DfsGenerateADPathString( DCNameToUse,
                                      ObjectName,
                                      LdapPrefixString,
                                      &PathString );

    if (dcInfo != NULL) {
        (VOID) NetApiBufferFree( dcInfo );     // ignore status returned
    }

    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //
    // open dfs configuration container for enumeration.
    //

    HResult = ADsOpenObject(PathString,
                            NULL,
                            NULL,
                            ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND | ADS_SERVER_BIND,
                            Id,
                            ppObject );

    Status = DfsGetErrorFromHr(HResult);

    DfsDeleteADPathString( PathString );

    return Status;
}

DFSSTATUS
DfsGetADObject(
    LPWSTR DCName,
    REFIID Id,
    LPWSTR ObjectName,
    PVOID *ppObject )
{
    DFSSTATUS Status;

    Status = DfsGetADObjectWithDsGetDCName( DCName,
                                            Id,
                                            ObjectName,
                                            DS_DIRECTORY_SERVICE_REQUIRED,
                                            ppObject );

    if (Status != ERROR_SUCCESS && DCName == NULL) {

        Status = DfsGetADObjectWithDsGetDCName( DCName,
                                                Id,
                                                ObjectName,
                                                DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_REQUIRED,
                                                ppObject );
    }

    return Status;
}


//
//  Given the root share name, get the root object.
//

DFSSTATUS
DfsGetDfsRootADObject(
    LPWSTR DCName,
    LPWSTR RootName,
    IADs **ppRootObject )
{
    LPWSTR RootCNName = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsGenerateRootCN( RootName, &RootCNName );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetADObject( DCName,
                                 IID_IADs,
                                 RootCNName,
                                 (PVOID *)ppRootObject );
                              
        DfsDeleteRootCN( RootCNName );
    }

    return Status;
}

DFSSTATUS
PackRootName(
    LPWSTR Name,
    PDFS_INFO_200 pDfsInfo200,
    PULONG pBufferSize,
    PULONG pTotalSize )
{
    size_t CharacterCount, ByteCount;
    ULONG NeedSize;
    DFSSTATUS Status = ERROR_SUCCESS;
    HRESULT HResult;
    LPWSTR UseName;

    UseName = &Name[3]; // skip over the leading whacks.

    HResult = StringCchLength( UseName,
                               MAXUSHORT,
                               &CharacterCount );
    if (SUCCEEDED(HResult)) 
    {
        CharacterCount += 1;  // For null termination;

        ByteCount = CharacterCount * sizeof(WCHAR);


        NeedSize  = sizeof(DFS_INFO_200) + ByteCount;
        *pTotalSize += NeedSize;
        if (*pBufferSize >= NeedSize)
        {
            LPWSTR pStringBuffer;

            pStringBuffer = (LPWSTR)((ULONG_PTR)(pDfsInfo200) + *pBufferSize - ByteCount);

            HResult = StringCchCopy( pStringBuffer,
                                     CharacterCount,
                                     UseName );
            if (SUCCEEDED(HResult)) 
            {
                pDfsInfo200->FtDfsName = (LPWSTR)pStringBuffer;
                *pBufferSize -= NeedSize;
            }
        }
        else
        {
            Status = ERROR_BUFFER_OVERFLOW;
            *pBufferSize = 0;
        }
    }

    if (!SUCCEEDED(HResult))
    {
        Status = HRESULT_CODE(HResult);
    }

    return Status;
}



DFSSTATUS
DfsGetDfsConfigurationObject(
    LPWSTR DCName,
    IADsContainer **ppDfsConfiguration )
{
    DFSSTATUS Status;

    Status = DfsGetADObject( DCName,
                             IID_IADsContainer,
                             NULL,
                             (PVOID *)ppDfsConfiguration );

    return Status;
}


DFSSTATUS
DfsGetBinaryFromVariant(VARIANT *ovData, BYTE ** ppBuf,
                        unsigned long * pcBufLen)
{
     DFSSTATUS Status = ERROR_INVALID_PARAMETER;
     void * pArrayData = NULL;

     //Binary data is stored in the variant as an array of unsigned char
     if(ovData->vt == (VT_ARRAY|VT_UI1))  
     {
        //Retrieve size of array
        *pcBufLen = ovData->parray->rgsabound[0].cElements;

        *ppBuf = new BYTE[*pcBufLen]; //Allocate a buffer to store the data
        if(*ppBuf != NULL)
        {
            //Obtain safe pointer to the array
            SafeArrayAccessData(ovData->parray,&pArrayData);

            //Copy the bitmap into our buffer
            memcpy(*ppBuf, pArrayData, *pcBufLen);

            //Unlock the variant data
            SafeArrayUnaccessData(ovData->parray);

            Status = ERROR_SUCCESS;
        }
        else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
     }

     return Status;
}

DFSSTATUS
DfsCheckRootADObjectExistence( 
    LPWSTR DCName,
    PUNICODE_STRING pRootName,
    GUID *pGuid )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    IADs *pRootObject = NULL;
    BYTE *pBuffer = NULL;
    ULONG Length = 0;
    UNICODE_STRING RootName;

    Status = DfsCreateUnicodeString( &RootName,
                                     pRootName );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetDfsRootADObject( DCName,
                                        RootName.Buffer,
                                        &pRootObject );
        if (Status == ERROR_SUCCESS)
        {

            //
            //
            // Now check for ability to read an attribute...

            VARIANT Variant;
            HRESULT HResult;
 
            VariantInit(&Variant);
 
            LPWSTR pszAttrs[] = { L"pKTGuid" };
            DWORD dwNumber = sizeof( pszAttrs ) /sizeof(LPWSTR);
            HResult = ADsBuildVarArrayStr( pszAttrs, dwNumber, &Variant );
            if (HResult == S_OK) 
            {
                HResult = pRootObject->GetInfoEx(Variant, 0);

                if (HResult != S_OK) 
                {
                    Status = DfsGetErrorFromHr(HResult);
                }
            }

            VariantClear(&Variant);
            VariantInit( &Variant );

            if ((Status == ERROR_SUCCESS) && pGuid)
            {
                //
                // Make a BSTR out of WCHAR *
                //
                BSTR PktGuidBstr = SysAllocString(L"pKTGuid");
                if (PktGuidBstr == NULL) 
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }

                if (Status == ERROR_SUCCESS)
                {
                    HResult = pRootObject->Get( PktGuidBstr, &Variant );
                    if (HResult == S_OK) 
                    {
                        Status = DfsGetBinaryFromVariant( &Variant, &pBuffer, &Length );
                        if (Status == ERROR_SUCCESS)
                        {
                            if (Length > sizeof(GUID)) 
                            {
                                Length = sizeof(GUID);
                            }

                            RtlCopyMemory( pGuid, pBuffer, Length);

                            delete [] pBuffer;
                        }
                    }
                    else
                    {
                        if (HResult != S_OK) 
                        {
                            Status = DfsGetErrorFromHr(HResult);
                        }
                    }

                    if (PktGuidBstr != NULL) // paranoia
                    {
                        SysFreeString( PktGuidBstr );
                    }
                }
            }
 
            pRootObject->Release();
        }
        DfsFreeUnicodeString( &RootName );
    }

    return Status;
}


DFSSTATUS
DfsDeleteDfsRootObject(
    LPWSTR DCName,
    LPWSTR RootName )
{
    BSTR ObjectName, ObjectClass;
    DFSSTATUS Status;
    HRESULT HResult;
    IADsContainer *pDfsConfiguration;
    IADs *pRootObject;

    Status = DfsGetDfsRootADObject( DCName,
                                    RootName,
                                    &pRootObject );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetDfsConfigurationObject( DCName,
                                               &pDfsConfiguration );


        if (Status == ERROR_SUCCESS)
        {

            HResult = pRootObject->get_Name(&ObjectName);
            if (SUCCEEDED(HResult))
            {
                HResult = pRootObject->get_Class(&ObjectClass);

                if (SUCCEEDED(HResult))
                {
                    HResult = pDfsConfiguration->Delete( ObjectClass,
                                                         ObjectName );

                    SysFreeString(ObjectClass);
                }
                SysFreeString(ObjectName);
            }
            pDfsConfiguration->Release();

            Status = DfsGetErrorFromHr(HResult);
        }

        pRootObject->Release();

    }
    return Status;
}



DFSSTATUS
DfsEnumerateDfsADRoots(
    LPWSTR DCName,
    PULONG_PTR pBuffer,
    PULONG pBufferSize,
    PULONG pEntriesRead,
    DWORD MaxEntriesToRead,
    LPDWORD pResumeHandle,
    PULONG pSizeRequired )
{
    HRESULT HResult;
    IADsContainer *pDfsConfiguration;
    IEnumVARIANT *pEnum;

    ULONG TotalSize = 0;
    ULONG TotalEntries = 0;
    PDFS_INFO_200 pDfsInfo200;
    ULONG BufferSize = *pBufferSize;
    DFSSTATUS Status;
    LONG ResumeCount;
    LONG NumRoots;
    
    //
    // point the dfsinfo200 structure to the start of buffer passed in
    // we will use this as an array of info200 buffers.
    //
    pDfsInfo200 = (PDFS_INFO_200)*pBuffer;


    Status = DfsGetDfsConfigurationObject( DCName,
                                           &pDfsConfiguration );

    if (Status == ERROR_SUCCESS)
    {
        HResult = ADsBuildEnumerator( pDfsConfiguration,
                                          &pEnum );

        if (SUCCEEDED(HResult))
        {
            VARIANT Variant;
            ULONG Fetched;
            BSTR BString;
            IADs *pRootObject;
            IDispatch *pDisp;

            ResumeCount = 0;
            NumRoots = 0;
            
            // See if we need to resume from a previous enumeration.
            if (pResumeHandle && *pResumeHandle > 0)
            {
                ResumeCount = *pResumeHandle;
            }
            
            VariantInit(&Variant);
            while ((HResult = ADsEnumerateNext(pEnum, 
                                               1,
                                               &Variant,
                                               &Fetched)) == S_OK)
            {
                if (TotalEntries >= MaxEntriesToRead)
                {
                    break;
                }
                
                // Skip ResumeCount number of entries
                NumRoots++;
                if (NumRoots <= ResumeCount)
                {
                    continue;
                }

                pDisp  = V_DISPATCH(&Variant);
                pDisp->QueryInterface(IID_IADs, (void **)&pRootObject);
                pDisp->Release();

                HResult = pRootObject->get_Name(&BString);
                if (HResult == S_OK) 
                {
                    Status = PackRootName( BString, pDfsInfo200, &BufferSize, &TotalSize );
                    if (Status == ERROR_SUCCESS)
                    {
                        TotalEntries++;
                        pDfsInfo200++;
                    }
                    SysFreeString(BString);
                }
                pRootObject->Release();

                // DfsDev: investigate. this causes an av.
                // VariantClear(&Variant);

            }

            if (HResult == S_FALSE)
            {
                HResult = S_OK;
            }

            ADsFreeEnumerator( pEnum );
        }

        pDfsConfiguration->Release();

        if (!SUCCEEDED(HResult))
        {
            Status = DfsGetErrorFromHr(HResult);
        }
    }

    if ((Status == ERROR_SUCCESS) || (Status == ERROR_BUFFER_OVERFLOW))
    {
        *pSizeRequired = TotalSize;
        if (TotalSize > *pBufferSize)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        else if (TotalEntries == 0)
        {
            Status = ERROR_NO_MORE_ITEMS;
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        *pEntriesRead = TotalEntries;

        if (pResumeHandle)
        {
            *pResumeHandle = NumRoots;
        }
    }

    return Status;
}


DFSSTATUS
DfsGenerateRootCN(
    LPWSTR RootName,
    LPWSTR *pRootCNName)
{
    size_t CharacterCount, UseCount;

    LPWSTR UsePrefix = L"CN=";
    HRESULT HResult;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR RootCNName;

    CharacterCount = 1; // for null termination;

    HResult = StringCchLength( UsePrefix,
                               MAXUSHORT,
                               &UseCount);
    if (SUCCEEDED(HResult)) 
    {
        CharacterCount += UseCount;
        HResult = StringCchLength( RootName,
                                   MAXUSHORT,
                                   &UseCount);
        if (SUCCEEDED(HResult)) 
        {
            CharacterCount += UseCount;
        }
    }

    
    if (SUCCEEDED(HResult)) 
    {
        RootCNName = new WCHAR[CharacterCount];

        if (RootCNName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (Status == ERROR_SUCCESS) 
        {
            HResult = StringCchCopy( RootCNName,
                                     CharacterCount,
                                     UsePrefix );

            if (SUCCEEDED(HResult)) 
            {
                HResult = StringCchCat( RootCNName,
                                        CharacterCount,
                                        RootName );
            }

            if (!SUCCEEDED(HResult))
            {
                delete [] RootCNName;
            }
        }
    }

    //
    // Note: here are 2 possibilities. We either have a HResult that is
    // not S_OK or we have a Status that is already set.
    // If the HResult is not S_OK, convert that to a status and return
    // Otherwise, use the status as set by the above code.
    // IF YOU DO HRESULT_CODE() at this point on a S_OK Hresult, we will
    // lost the status above.
    //
    if (!SUCCEEDED(HResult)) 
    {
        Status = HRESULT_CODE(HResult);
    }

    if (Status == ERROR_SUCCESS) 
    {
        *pRootCNName = RootCNName;
    }

    return Status;
}

VOID
DfsDeleteRootCN(
    LPWSTR RootCNName)
{
    delete [] RootCNName;
    return NOTHING;
}

//
//  Given a DFS rootname, this spews out a heap-allocated, NULL terminated
//  string containing the LDAP name context. This string, for example
//  ends up in the FTDfsObjectDN value name in the registry.
//  eg: CN=Rootname,CN=Dfs-Configuration,CN=System,DC=supwdomain,DC=nttest, ...
//
DFSSTATUS
DfsGenerateDNPathString(
    LPWSTR RootObjName,
    OUT LPWSTR *pPathString)
{
    DFSSTATUS Status;
    LPWSTR RootCNName;

    //
    // Generate the CN=Rootname part.
    //
    Status = DfsGenerateRootCN( RootObjName, &RootCNName );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Now add in the rest of the CN and DC configuration strings.
        //
        Status = DfsGenerateADPathString( NULL,
                                          RootCNName,
                                          NULL,
                                          pPathString );
        DfsDeleteRootCN( RootCNName );
    }

    return Status;
}

VOID
DfsDeleteDNPathString(
    LPWSTR PathString)
{
    DfsDeleteADPathString( PathString );
    return NOTHING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfscompat.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsReferral.cxx
//
//  Contents:   This file contains the functionality to generate a referral
//
//
//  History:    Jan 16 2001,   Authors: RohanP/UdayH
//
//-----------------------------------------------------------------------------

#include "DfsReferral.hxx"
#include "Align.h"
#include "dfstrusteddomain.hxx"
#include "dfsadsiapi.hxx"
#include "DfsDomainInformation.hxx"
#include "DomainControllerSupport.hxx"


#include "dfsreferral.tmh" // logging

DFSSTATUS
DfsGetCompatRootFolder(
    PUNICODE_STRING pName,
    DfsRootFolder **ppNewRoot );

DFSSTATUS
DfsLookupCompatFolder( 
    DfsRootFolder *pRoot,
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolder **ppFolder )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // if the rest of the name is empty, we need the root folder
    // itself, so acquire a reference on the root folder and return it
    // as a folder.
    //
    if (pName->Length == 0) 
    {
        *ppFolder = (DfsFolder *)pRoot;
        pRoot->AcquireReference();
    }
    else
    {
        Status = pRoot->LookupFolderByLogicalName( pName,
                                                   pRemainingName,
                                                   ppFolder );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder
//
//  Arguments:  pName - The logical name
//              pRemainingName - the name beyond the root
//              ppRoot       - the Dfs root found.
//
//  Returns:    ERROR_SUCCESS
//              Error code otherwise
//
//
//  Description: This routine runs through all the stores and looks up
//               a root with the matching name context and share name.
//               If multiple stores have the same share, the highest
//               priority store wins (the store registered first is the
//               highest priority store)
//               A referenced root is returned, and the caller is 
//               responsible for releasing the reference.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsGetCompatReferralData(
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolderReferralData **ppReferralData,
    PBOOLEAN pCacheHit )
{
    DfsRootFolder *pNewRoot = NULL;
    DfsFolder *pFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING ServerName, ShareName, Rest;

    //
    // Break up the path into name components.
    // 
    Status = DfsGetPathComponents( pName,
                                   &ServerName,
                                   &ShareName,
                                   &Rest );

    //
    // Now find the Root folder for the name, and then lookup the link
    // folder using the rest of the name.
    //

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsCheckRootADObjectExistence( NULL,
                                                &ShareName,
                                                NULL );

    }

    if (Status == ERROR_SUCCESS) 
    {
        Status = DfsGetCompatRootFolder( &ShareName,
                                         &pNewRoot );
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsLookupCompatFolder( pNewRoot,
                                            &Rest,
                                            pRemainingName,
                                            &pFolder );
            //
            //Generate the referral data so we can create a referral
            // to return to the client.
            //
            if (Status == ERROR_SUCCESS)
            {
                Status = pFolder->GetReferralData( ppReferralData,
                                                   pCacheHit,
                                                   FALSE );

                pFolder->ReleaseReference();
            }
            //
            // We had created this root folder temporarily, just so we 
            // can get the referral information. we dont want this root
            // to live forever.
            
            // So remove all the link folders in the root, being careful
            // that we dont delete any directories if this machine is hosting
            // this root itself.
            //
            // We then release the reference on the root to delete it.
            //
            pNewRoot->RemoveAllLinkFolders(FALSE);
            pNewRoot->ReleaseReference();

            if (Status == ERROR_SUCCESS) 
            {
                (*ppReferralData)->SetTime();
                (*ppReferralData)->DetachFromFolder();
            }
        }
    }

    return Status;
}


DFSSTATUS
DfsGetRootReferralData(
    PUNICODE_STRING pShareName,
    PUNICODE_STRING pRemainingName,
    PUNICODE_STRING pRest,
    DfsFolderReferralData **ppReferralData,
    PBOOLEAN pCacheHit )
{
    DfsRootFolder *pNewRoot = NULL;
    DfsFolder *pFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // Now find the Root folder for the name, and then lookup the link
    // folder using the rest of the name.
    //

    Status = DfsGetCompatRootFolder( pShareName,
                                     &pNewRoot );
    if (Status == ERROR_SUCCESS)
    {
         Status = DfsLookupCompatFolder( pNewRoot,
                                         pRest,
                                         pRemainingName,
                                         &pFolder );
         //
         //Generate the referral data so we can create a referral
         // to return to the client.
         //
         if (Status == ERROR_SUCCESS)
          {
             Status = pFolder->GetReferralData( ppReferralData,
                                                pCacheHit,
                                                FALSE );

             pFolder->ReleaseReference();
          }

           //
           // We had created this root folder temporarily, just so we 
           // can get the referral information. we dont want this root
           // to live forever.
            
           // So remove all the link folders in the root, being careful
           // that we dont delete any directories if this machine is hosting
           // this root itself.
           //
           // We then release the reference on the root to delete it.
           //  

           pNewRoot->RemoveAllLinkFolders(FALSE);
           pNewRoot->ReleaseReference();

           if (Status == ERROR_SUCCESS) 
           {
               (*ppReferralData)->SetTime();
               (*ppReferralData)->DetachFromFolder();
           }
    }

    return Status;
}


DFSSTATUS
DfsGetRootReferralDataEx(
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolderReferralData **ppReferralData,
    PBOOLEAN pCacheHit)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING ServerName, ShareName, Rest;

    do
    {

        //
        // Break up the path into name components.
        // 
        Status = DfsGetPathComponents( pName,
                                       &ServerName,
                                       &ShareName,
                                       &Rest );
        if(Status != ERROR_SUCCESS)
        {
            break;
        }

        Status = DfsGetRootReferralData(&ShareName,
                                        pRemainingName,
                                        &Rest,
                                        ppReferralData,
                                        pCacheHit );

        if(Status != ERROR_SUCCESS)
        {
            break;
        }

    }while (0);


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsapifrontend.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsApiFrontEnd.cxx
//
//  Contents:   Contains the support routines for the administering DFS
//              The DFS api server implementation uses this.
//              Also, any other admin tool that does not use the API
//              can use the facilities provided here to administer DFS.
//
//  Classes:    none.
//
//  History:    Feb. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------
#include "DfsRootFolder.hxx"
#include "DfsReferral.hxx"
#include "lm.h"
#include "lmdfs.h"
#include "DfsRegistryStore.hxx"
#include "DfsADBlobStore.hxx"
#include "DfsADBlobRootFolder.hxx"
#include "DfsEnterpriseStore.hxx"
#include "DfsInit.hxx"
#include "netdfs.h"
#include "DomainControllerSupport.hxx"
#include "dfsfsctl.h"
//
// logging specific includes
//
#include "DfsApiFrontEnd.tmh" 

DFSSTATUS
DfsDirectApiAllocContext(
    OUT PDFS_DIRECT_API_CONTEXT *ppApiContext,
    IN PUNICODE_STRING pDfsPathName,
    IN PUNICODE_STRING pServerName, 
    IN PUNICODE_STRING pShareName);

VOID
DfsDirectApiFreeContext(
    PDFS_DIRECT_API_CONTEXT pApiContext);



//
//dfsdev: validate input arguments.
//
#define API_VALIDATE_ARGUMENTS(_a, _b, _c, _d)                       \
{                                                                    \
    if ((((_b) != NULL) && (IS_VALID_SERVER_TOKEN(_b, wcslen(_b)) == FALSE))) \
    {                                                                \
        (_d) = ERROR_INVALID_NAME;                                   \
    }                                                                \
    else                                                             \
    {                                                                \
       (_d) = ERROR_SUCCESS;                                        \
    }                                                                \
}

//
// Valid link states as published by lmdfs.h.
// dfsdev: migrate this to the header file eventually.
//
inline BOOLEAN
IsValidReplicaState( DWORD State )
{
    return ( State == DFS_STORAGE_STATE_OFFLINE ||
             State == DFS_STORAGE_STATE_ONLINE );
}

//
// Unfortunately these values are such that bitwise OR isn't
// sufficient.
//
inline BOOLEAN
IsValidLinkState( DWORD State )
{
    return ( State == DFS_VOLUME_STATE_OK ||
             State == DFS_VOLUME_STATE_OFFLINE ||
             State == DFS_VOLUME_STATE_ONLINE );  
}

inline BOOLEAN
IsValidGetInfoLevel( DWORD Level )
{
    return ((Level >= 100 && Level <= 102) ||
             (Level >= 1 && Level <= 4)); 
}

inline BOOLEAN
IsValidSetInfoLevel( DWORD Level )
{
    return (Level >= 100 && Level <= 102); 
}




DFSSTATUS
DfsAddValidate(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    API_VALIDATE_ARGUMENTS( DfsPathName, ServerName, ShareName, Status);

    if (Status == ERROR_SUCCESS)
    {
        //
        // Null or empty server/share names are illegal.
        // The DfsPathName needs to have all three components \\x\y\z
        // but that'll get indirectly validated when we do DfsGetRootFolder.
        //
        if ((IsEmptyString( ServerName )) ||
            (IsEmptyString( ShareName )) ||
            (IsEmptyString( DfsPathName )))
        {
            Status = ERROR_INVALID_PARAMETER;
        }
    }


    if (Status == ERROR_SUCCESS)
    {
        //
        // Check for valid flags.
        //  
        if (Flags &&
            (Flags & ~(DFS_ADD_VOLUME | DFS_RESTORE_VOLUME)))
        {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        StripTrailingSpacesFromPath(DfsPathName); 
    }

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsAdd 
//
//  Arguments:  DfsPathName - the pathname that is being added or updated
//              ServerName  - Name of server being added as target
//              ShareName   - Name of share on ServerName backing the link
//              Comment     - Comment associated if this is a new link
//              Flags       - If DFS_ADD_VOLUME, fail this request if link exists
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsAdd(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    UNICODE_STRING DfsPath, LinkName;

    DFS_TRACE_NORM(API, "[%!FUNC!]DfsAdd for path %ws, Server %ws Share %ws\n", 
                   DfsPathName, ServerName, ShareName);


    //
    // Null or empty server/share names are illegal.
    // The DfsPathName needs to have all three components \\x\y\z
    // but that'll get indirectly validated when we do DfsGetRootFolder.
    //
    if ((IsEmptyString( ServerName )) ||
        (IsEmptyString( ShareName )) ||
        (IsEmptyString( DfsPathName )))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //
    // One or two leading '\'s are valid components of a ServerName here.
    //
    if (ServerName[0] == UNICODE_PATH_SEP)
    {
        // advance past a max of two '\'s.
        ServerName++;
        if (ServerName[0] == UNICODE_PATH_SEP)
        {
            ServerName++;
        }
    }
        
    API_VALIDATE_ARGUMENTS( DfsPathName, ServerName, ShareName, Status);
    if (Status != ERROR_SUCCESS)
        goto done;


    //
    // Check for valid flags.
    //  
    if (Flags &&
        (Flags & ~(DFS_ADD_VOLUME | DFS_RESTORE_VOLUME)))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    StripTrailingSpacesFromPath(DfsPathName); 


    Status = DfsRtlInitUnicodeStringEx( &DfsPath, DfsPathName );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    //
    // Get a root folder for the passed in path name.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );

    if (Status == ERROR_SUCCESS)
    {
        //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        // For callers linking with the server library directly, this is a no-op.
        // This is because they are supposed to perform a Initialize, Open, 
        // Synchronize, Close sequence.
        //
        if (!DfsCheckDirectMode())
        {
            Status = pRoot->RootApiRequestPrologue( TRUE );
        }
        
        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //
        if (Status == ERROR_SUCCESS) {

            //
            // Check if this is a valid link name. A valid link is one that
            // either is a perfect match of the LinkName, or the LinkName
            // does not encompass as existing link.
            //
            Status = pRoot->ValidateLinkName( &LinkName );
        
            //
            // If validate link name succeeds, we can add the servername
            // and share name as a target to this link
            //
            if (Status == ERROR_SUCCESS)
            {
                //
                // If someone wanted to create this as a new link, we fail the request here.
                // the link already exists.
                //
                if (Flags & DFS_ADD_VOLUME)
                {
                    Status = ERROR_FILE_EXISTS;
                }
                else 
                {
                    //
                    // Add the target to this link.
                    //
                    Status = pRoot->AddMetadataLinkReplica( &LinkName,
                                                            ServerName,
                                                            ShareName );
                }
            }
            else if (Status == ERROR_NOT_FOUND)
            {
                //
                // If the link was not found, at this point we are assured that this link is
                // neither a prefix of an existing link not is any link a prefix of this link
                // name (validate prefix above provides that assurance)
                // We add a new link to this root.
                //
                Status = pRoot->AddMetadataLink( &DfsPath,
                                                 ServerName,
                                                 ShareName,
                                                 Comment );
            }

            //
            // We are done with this request, so release our reference on the root folder.
            //
            if (!DfsCheckDirectMode())
            {
                pRoot->RootApiRequestEpilogue( TRUE, Status );
            }
        }


        pRoot->ReleaseReference();
    }
done:
    DFS_TRACE_ERROR_NORM(Status, API, "[%!FUNC!]for path %ws, Status %x\n", 
                         DfsPathName, Status );

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsRemove
//
//  Arguments:  DfsPathName - the pathname that is being added or updated
//              ServerName  - Name of server being added as target
//              ShareName   - Name of share on ServerName backing the link
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsRemove(
    LPWSTR DfsPathName,
    LPWSTR ServerName,
    LPWSTR ShareName )

{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    BOOLEAN LastReplica = FALSE;
    UNICODE_STRING DfsPath, LinkName;

    DFS_TRACE_NORM(API, "[%!FUNC!] for path %ws, Server=%ws Share=%ws \n", DfsPathName, ServerName, ShareName);

    //
    // One or two leading '\'s are valid components of a ServerName here.
    //
    if ((ServerName != NULL) && (ServerName[0] == UNICODE_PATH_SEP))
    {
        // advance past a max of two '\'s.
        ServerName++;
        if (ServerName[0] == UNICODE_PATH_SEP)
        {
            ServerName++;
        }
    }

    //
    // It is legal for the ServerName and the ShareName to be NULL. DfsPathName should
    // have all its \\x\y\z components, but that gets validated below in DfsGetRootFolder.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, ServerName, ShareName, Status);

    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsPath, DfsPathName );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if (IsEmptyUnicodeString( &DfsPath ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }
    
    if (((ServerName == NULL) && (ShareName != NULL)) ||
        ((ServerName != NULL) && (ShareName == NULL)))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }
    //
    //Get the root folder matching this name. We get a referenced root folder.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );


    if (Status == ERROR_SUCCESS)
    {
        //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        if (!DfsCheckDirectMode())
        {
            Status = pRoot->RootApiRequestPrologue( TRUE );
        }
        
        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //
        if (Status == ERROR_SUCCESS) 
        {
            if ((ServerName != NULL) && (ShareName != NULL))
            {
                //
                // If the servername/sharename was provided, we just remove the matching target.
                // If the serername/sharename was not provided, we remove the link itself.
                //
                Status = pRoot->RemoveMetadataLinkReplica( &LinkName,
                                                           ServerName,
                                                           ShareName,
                                                           &LastReplica );
                //
                // DFSDEV: REMOVE THIS FROM THE API!!!
                //
                if ((Status == ERROR_LAST_ADMIN) && (LastReplica == TRUE))
                {
                    Status = pRoot->RemoveMetadataLink( &LinkName );
                }
            }
            else 
            {
                Status = pRoot->RemoveMetadataLink( &LinkName );
            }
            //
            // We now release the reference that we have on the root.
            //
            if (!DfsCheckDirectMode())
            {
                pRoot->RootApiRequestEpilogue( TRUE, Status );
            }
        }

        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "DfsRemove for path %ws, Server=%ws Share=%ws, LastReplica=%d, Status %x\n",
                         DfsPathName, ServerName, ShareName, LastReplica, Status);

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsEnumerate
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is being added or updated
//    DWORD Level        - the level of information requested
//    DWORD PrefMaxLen   - a hint as to how many items to enumerate.
//    LPBYTE pBuffer     - the buffer to fill, passed in by the caller.
//    LONG BufferSize,   - the size of passed in buffer.
//    LPDWORD pEntriesRead - the number of entries read, set on return
//    LPDWORD pResumeHandle - the entry to start from, set to new value on return
//    PLONG pNextSizeRequired - size required to successfully complete this call.
//                              usefule when this call return buffer overflow.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsEnumerate(
    LPWSTR DfsPathName,
    DWORD Level,
    DWORD PrefMaxLen,
    LPBYTE pBuffer,
    LONG BufferSize,
    LPDWORD pEntriesRead,
    LPDWORD pResumeHandle,
    PLONG pNextSizeRequired )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    LONG LevelInfoSize = 0;
    DWORD EntriesToRead = 0;
    UNICODE_STRING DfsPath, LinkName;
    UNICODE_STRING DfsServer, DfsShare;

    DFS_TRACE_NORM(API, "Dfs Enumerate for path %ws Level %d ResumeHandle %d PrefMaxLen %d Size %d\n", 
                   DfsPathName, Level, pResumeHandle ? *pResumeHandle : 0, PrefMaxLen, BufferSize);


    //
    // validate the input parameters.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, NULL, NULL, Status);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // Get the unicode dfs path.
    //
    Status = DfsRtlInitUnicodeStringEx( &DfsPath, DfsPathName );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    if(!pEntriesRead || !pNextSizeRequired || !pBuffer)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    Status = DfsApiSizeLevelHeader(Level, &LevelInfoSize);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    Status = DfsGetPathComponents( &DfsPath,
                                   &DfsServer,
                                   &DfsShare,
                                   NULL );

    //
    // For legacy reasons, we need to support this call coming in with a null name.
    // This is where the server would host a single root, and we always knew which root
    // we wanted.
    // To workaround this situation, if we get a null pathname, we get the first root
    // folder and use that.
    //

    if (DfsShare.Length != 0)
    {
        Status = DfsGetRootFolder( &DfsPath,
                                   &LinkName,
                                   &pRoot );
    }
    else
    {
        Status = DfsGetOnlyRootFolder( &pRoot );
    }

    if (Status == ERROR_SUCCESS)
    {
       //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        // For callers linking with the server library directly, this is a no-op.
        // This is because they are supposed to perform a Initialize, Open, 
        // Synchronize, Close sequence.
        //
        if (!DfsCheckDirectMode())
        {
            Status = pRoot->RootApiRequestPrologue( FALSE );
        }

        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //
        if (Status == ERROR_SUCCESS)
        {
            //
            // If PrefMAxLen is 0xffffffff, we need to read all entries. OTherwise we need
            // to read a subset of the entries. Let PrefMaxLen decide the number in the array
            // of info parameters we pass back. (This is how we document our NEtDfsEnum api)
            //
        
            EntriesToRead = PrefMaxLen / LevelInfoSize;
            if (EntriesToRead == 0) {
                EntriesToRead = 1;
            }

            //
            // Things could be in a state of flux: if the request is for more than twice what we
            // already know about, limit it to 2 times our link count.
            //
            if (EntriesToRead > pRoot->RootEnumerationCount() * 2)
            {
                EntriesToRead = pRoot->RootEnumerationCount() * 2;
            }
            *pEntriesRead = EntriesToRead;

            //
            // Now enumerate the entries in the root in the passed in buffer.
            //

            Status = pRoot->EnumerateApiLinks( DfsPathName,
                                               Level,
                                               pBuffer,
                                               BufferSize,
                                               pEntriesRead,
                                               pResumeHandle,
                                               pNextSizeRequired );

            //
            // Release the root reference, and return status back to the caller.
            //

            if (!DfsCheckDirectMode())
            {
                pRoot->RootApiRequestEpilogue( FALSE, Status );
            }
        }
        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs Enumerate for path %ws EntriesRead %d ResumeHandle %d Status %x Size %d\n",
                         DfsPathName, pEntriesRead ? *pEntriesRead : 0, 
                         pResumeHandle ? *pResumeHandle : 0,
                         Status, 
                         pNextSizeRequired ? *pNextSizeRequired : 0);

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetInfo
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is of interest.
//    DWORD Level        - the level of information requested
//    LPBYTE pBuffer     - the buffer to fill, passed in by caller
//    LONG BufferSize,   - the size of passed in buffer.
//    PLONG pSizeRequired - size required to successfully complete this call.
//                              usefule when this call return buffer overflow.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsGetInfo(
    LPWSTR DfsPathName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG BufferSize,
    PLONG pSizeRequired )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DfsPath, LinkName;
    DfsRootFolder *pRoot = NULL;

    DFS_TRACE_NORM(API, "Dfs get info for path %ws Level %d\n",
                   DfsPathName, Level );

    Status = DfsRtlInitUnicodeStringEx( &DfsPath, DfsPathName );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    //
    // Validate the input parameters.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, NULL, NULL, Status);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if (!pSizeRequired || !pBuffer || (IsEmptyUnicodeString( &DfsPath )))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //
    // Level has to be 100...102 or 1...4 currently.
    //
    if (!IsValidGetInfoLevel( Level ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }
    
    //
    // Get a referenced root folder for the passed in path.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );
    if (Status == ERROR_SUCCESS)
    {
        if (!DfsCheckDirectMode())
        {
            Status = pRoot->RootApiRequestPrologue( FALSE );
        }

        //
        // If we got a root folder, see if there is a link that matches
        // the rest of the name beyond the root.
        //

        if (Status == ERROR_SUCCESS) {
            //
            // If we got a root folder, get the requested information into the passed
            // in buffer.
            //
            Status = pRoot->GetApiInformation( &DfsPath,
                                               &LinkName,
                                               Level,
                                               pBuffer,
                                               BufferSize,
                                               pSizeRequired );
            //
            //WE are done: release our reference on the root.
            //
            if (!DfsCheckDirectMode())
            {
                pRoot->RootApiRequestEpilogue( FALSE, Status );
            }
        }
        pRoot->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs get info for path %ws Status %x\n",
                   DfsPathName, Status );

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsSetInfo
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is being  updated
//    LPWSTR Server      - the servername (optional) whose info is being set.
//    LPWSTR Share       - the share on the server.
//    DWORD Level        - the level of information being set
//    LPBYTE pBuffer     - the buffer holding the information to be set
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------


DFSSTATUS
DfsSetInfo(
    LPWSTR DfsPathName,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE pBuffer)
{
    return DfsSetInfoCheckAccess( DfsPathName,
                                  Server,
                                  Share,
                                  Level,
                                  pBuffer,
                                  ERROR_SUCCESS );
}
    

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetInfoCheckAccess
//
//  Arguments:  
//    LPWSTR DfsPathName - the pathname that is being  updated
//    LPWSTR Server      - the servername (optional) whose info is being set.
//    LPWSTR Share       - the share on the server.
//    DWORD Level        - the level of information being set
//    LPBYTE pBuffer     - the buffer holding the information to be set
//    DFSSTATUS Status   - access status if any.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsSetInfoCheckAccess(
    LPWSTR DfsPathName,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE pBuffer,
    DFSSTATUS AccessCheckStatus )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    UNICODE_STRING DfsPath, LinkName;

    DFS_TRACE_NORM(API, "[%!FUNC!]Dfs set info for path %ws AccessCheck Status %x Level %d\n",
                   DfsPathName, AccessCheckStatus, Level);

    Status = DfsRtlInitUnicodeStringEx( &DfsPath, DfsPathName );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    //
    //validate the input arguments.
    //
    API_VALIDATE_ARGUMENTS( DfsPathName, NULL, NULL, Status);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    //
    // It is legal for the Server and Share args to be NULL,
    // but the DfsPath must have \\x\y\z components. DfsGetRootFolder
    // will validate that.
    //
    if (!pBuffer || !(*(PULONG)pBuffer) || (IsEmptyUnicodeString( &DfsPath )))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    // Server may have leading \\.
    if ((Server != NULL) && (Server[0] == UNICODE_PATH_SEP))
    {
        // advance past a max of two '\'s.
        Server++;
        if (Server[0] == UNICODE_PATH_SEP)
        {
            Server++;
        }
    }
    
    //
    // Level has to be 100...102 currently.
    //
    if (!IsValidSetInfoLevel( Level ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }
    
    //
    // Get a referenced root folder for the passed in path.
    //
    Status = DfsGetRootFolder( &DfsPath,
                               &LinkName,
                               &pRoot );

    //
    // For cluster, checkpointing may add stuff to the registry which
    // we had not found when we started off. So, make an attempt
    // to look into the registry.
    // In future, this should work across all the roots, but for now
    // this is sort of a quick means of getting clusters going.
    //

    if (Status == ERROR_NOT_FOUND)
    {
        DfsRegistryStore *pRegStore = NULL;
        UNICODE_STRING DfsServer, DfsShare, NewDfsShare;

        Status = DfsGetRegistryStore( &pRegStore );

        if (Status == ERROR_SUCCESS)
        {
            Status = DfsGetPathComponents( &DfsPath,
                                           &DfsServer,
                                           &DfsShare,
                                           NULL );
            if (Status == ERROR_SUCCESS)
            {
                Status = DfsCreateUnicodeString( &NewDfsShare, 
                                                 &DfsShare );
            }
            if (Status == ERROR_SUCCESS)
            {
                Status = pRegStore->LookupNewRootByName( NewDfsShare.Buffer,
                                                         &pRoot );

                DfsFreeUnicodeString( &NewDfsShare );
            }

            pRegStore->ReleaseReference();
        }
    }

    //
    // dfsdev: special case master and standby here.
    //
    // We call into the service with the appropriate bits to 
    // set the root in a standby mode or a master mode.
    //

    if (Status == ERROR_SUCCESS)
    {
        BOOLEAN Done = FALSE;
        if (Level == 101)
        {
            PDFS_INFO_101 pInfo101 = (PDFS_INFO_101)*((PULONG_PTR)pBuffer);
            DFS_TRACE_NORM(API, "Dfs set info for path %ws Level %d State is %d\n",
                           DfsPathName, Level, pInfo101->State);

            if (pInfo101->State == DFS_VOLUME_STATE_RESYNCHRONIZE)
            {
                DFS_TRACE_NORM(API, "[%!FUNC!]Root folder set to Master\n");

                //
                // Check if resynchronize should succeed of fail, based
                // on the passed in access check status.
                //
                Status = pRoot->CheckResynchronizeAccess(AccessCheckStatus);
                if (Status == ERROR_SUCCESS)
                {
                    Status = pRoot->SetRootResynchronize();
                }
                Done = TRUE;
            }
            else if (pInfo101->State == DFS_VOLUME_STATE_STANDBY)
            {
                ASSERT(Status == ERROR_SUCCESS);
                Status = AccessCheckStatus;
                
                if (Status == ERROR_SUCCESS)
                {
                    if (DfsIsMachineCluster())
                    {
                        DFS_TRACE_NORM(API, "[%!FUNC!]Root folder set to standby\n");
                        pRoot->SetRootStandby();
                    }
                    else
                    {
                        Status = ERROR_NOT_SUPPORTED;
                    }
                }

                //
                // Ideally, we should purge the referral(s) for this root and all its links.
                // For that we'll have to iterate over all its links (among other things).
                // That can be expensive and might even lead to DoS attacks. However
                //
                Done = TRUE;
                
            }
            else 
            {
                if ((Server == NULL) && (Share == NULL))
                {
                    if (!IsValidLinkState(pInfo101->State))
                    {
                        Done = TRUE;
                        Status = ERROR_INVALID_PARAMETER;
                    }
                }
                else
                {
                    if (!IsValidReplicaState(pInfo101->State))
                    {
                        Done = TRUE;
                        Status = ERROR_INVALID_PARAMETER;
                    }
                }
            }
        }

        if (Done)
        {
            goto done;
        }
    }

    //
    // At this point, if we are to be denied access, we should not 
    // proceed.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = AccessCheckStatus;
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // Check if the root folder is available for api calls. If not,
        // we return an error back to the caller:
        // dfsdev: check if this error is a valid one to return.
        //
        if (!DfsCheckDirectMode())
        {
            Status = pRoot->RootApiRequestPrologue( TRUE );
        }
        if (Status == ERROR_SUCCESS)
        {
            //
            // If we successfully got a root folder, set the specifed information
            // on the passed in path/server/share combination.
            //
            Status = pRoot->SetApiInformation( &LinkName,
                                               Server,
                                               Share,
                                               Level,
                                               pBuffer );
            //
            // release our reference on the root folder.
            //
            if (!DfsCheckDirectMode())
            {
                pRoot->RootApiRequestEpilogue( TRUE, Status );
            }
        }
    }

done:

    if(pRoot)
    {
        pRoot->ReleaseReference();
    }

    DFS_TRACE_ERROR_NORM(Status, API, "Dfs set info for path %ws Status %x\n",
                         DfsPathName, Status );
    
    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   DfsAddStandaloneRoot
//
//  Arguments:  
//    LPWSTR ShareName - the share name to use
//    LPWSTR Comment   - the comment for this root
//    DWORD Flags  -  the flags for this root
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsAddStandaloneRoot(
    LPWSTR MachineName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags )
{

    DFS_TRACE_NORM(API, "Dfs add standalone root Machine Share %ws\n",
                   ShareName);

    //
    // dfsdev: use these parameters.
    //
    UNREFERENCED_PARAMETER(Comment);
    UNREFERENCED_PARAMETER(Flags);

    DfsRegistryStore *pRegStore;
    DFSSTATUS Status;

    //
    // It's legal to get a NULL MachineName to signify '.', but the
    // ShareName can't be empty.
    //   
    if (IsEmptyString( ShareName ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }
    

    Status = DfsCheckServerRootHandlingCapability();
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    //
    // This is a registry store specific function. So finf the registry store.
    // This gives us a referenced registry store pointer.
    //
    Status = DfsGetRegistryStore( &pRegStore );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Create the standalone root, and release our reference on the registry
        // store.
        //
        Status = pRegStore->CreateStandaloneRoot( MachineName,
                                                  ShareName,
                                                  Comment );
        pRegStore->ReleaseReference();
    }

done:
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs add standalone root status %x Machine  Share %ws\n",
                         Status, ShareName);
    

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteStandaloneRoot
//
//  Arguments:  
//    LPWSTR ShareName - the root to delete
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsDeleteStandaloneRoot(
    LPWSTR ServerName,
    LPWSTR ShareName )
{
    DfsRegistryStore *pRegStore;
    DFSSTATUS Status;

    DFS_TRACE_NORM(API, "Dfs delete standalone root Machine Share %ws\n",
                   ShareName);

    if (IsEmptyString( ServerName ))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    if (IsEmptyString( ShareName ))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    //
    // This is registry store specific function, so get the registry store.
    //
    Status = DfsGetRegistryStore( &pRegStore );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Delete the standalone root specified by the passed in sharename
        // and release our reference on the registry store.
        //
        Status = pRegStore->DeleteStandaloneRoot( NULL,
                                                  ShareName );
        pRegStore->ReleaseReference();
    }
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs delete standalone root status %x Machine  Share %ws\n",
                         Status, ShareName);

    return Status;
}



DFSSTATUS
DfsEnumerateLocalRoots( 
    LPWSTR MachineName,
    BOOLEAN DomainRoots,
    LPBYTE pBuffer,
    ULONG  BufferSize,
    PULONG pEntriesRead,
    DWORD MaxEntriesToRead,
    LPDWORD pResumeHandle,
    PULONG pSizeRequired )
{

    UNREFERENCED_PARAMETER(MachineName);

    DFSSTATUS Status = ERROR_SUCCESS;    
    ULONG  TotalSize = 0;
    ULONG  EntriesRead = 0;
    ULONG_PTR CurrentBuffer = (ULONG_PTR)pBuffer;
    ULONG  CurrentSize = BufferSize;
    DfsStore *pStore;
    ULONG CurrentNumRoots = 0;
    
    BOOLEAN OverFlow = FALSE;
    ASSERT(pBuffer != NULL);
    ASSERT(pEntriesRead != NULL);
    ASSERT(pSizeRequired != NULL);

    DFS_TRACE_NORM(API, "[%!FUNC!]for path %ws\n", MachineName);
    
    //
    // Call the store enumerator of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         (pStore != NULL) && (Status == ERROR_SUCCESS);
         pStore = pStore->pNextRegisteredStore) {

        Status = pStore->EnumerateRoots( DomainRoots,
                                         &CurrentBuffer,
                                         &CurrentSize,
                                         &EntriesRead,
                                         MaxEntriesToRead,
                                         &CurrentNumRoots,
                                         pResumeHandle,
                                         &TotalSize );
        if (Status == ERROR_BUFFER_OVERFLOW)
        {
            OverFlow = TRUE;
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if (OverFlow == TRUE)
        {
            Status = ERROR_BUFFER_OVERFLOW;
        }
        else if (EntriesRead == 0)
        {
            //
            // We should never return SUCCESS if we aren't
            // returning entries.
            //
            Status = ERROR_NO_MORE_ITEMS;
        }
        else if (pResumeHandle)
        {        
            *pResumeHandle = CurrentNumRoots;
        }
        
        *pEntriesRead = EntriesRead;
        *pSizeRequired = TotalSize;
    }

    DFS_TRACE_ERROR_NORM(Status, API, "[%!FUNC!]for path %ws, Status %x\n",
                         MachineName, Status );

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsEnumerateRoots
//
//  Arguments:  
//    LPBYTE pBuffer     - the buffer to fill, passed in by teh caller
//    LONG BufferSize,   - the size of passed in buffer.
//    LPDWORD pEntriesRead - the number of entries read, set on return
//    LPDWORD pResumeHandle - the entry to start from, set to new value on return
//    PLONG pSizeRequired - size required to successfully complete this call.
//                              usefule when this call return buffer overflow.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------

DFSSTATUS
DfsEnumerateRoots(
    IN LPWSTR DfsName,
    IN BOOLEAN DomainRoots,
    IN DWORD PrefMaxLen,
    IN LPBYTE pBuffer,
    IN ULONG BufferSize,
    OUT PULONG pEntriesRead,
    IN OUT PULONG pResumeHandle,
    OUT PULONG pSizeRequired )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DfsPath;
    UNICODE_STRING NameContext;
    UNICODE_STRING RemainingPart;
    DWORD MaxEntriesToRead = 0;
    LONG LevelInfoSize = 0;
    
    DFS_TRACE_NORM(API, "Dfs enumerate roots: resume handle %d\n",
                   pResumeHandle ? *pResumeHandle : 0);
    
    if(!pEntriesRead || !pSizeRequired || !pBuffer)
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsPath, DfsName );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }

    if (IsEmptyUnicodeString( &DfsPath ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }
    
    Status = DfsGetFirstComponent( &DfsPath,
                                   &NameContext,
                                   &RemainingPart );

    if (Status == ERROR_SUCCESS)
    {
        if (RemainingPart.Length != 0)
        {
            //
            // return not found for now... dfsdev: fix on client.
            //
            Status = ERROR_PATH_NOT_FOUND;
        }
    }

    Status = DfsApiSizeLevelHeader( (DomainRoots == TRUE) ? 200 : 300, &LevelInfoSize);
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    //
    // If PrefMAxLen is 0xffffffff, we need to read all entries. OTherwise we need
    // to read a subset of the entries. Let PrefMaxLen decide the number in the array
    // of info parameters we pass back. (This is how we document our NEtDfsEnum api)
    //
    MaxEntriesToRead = PrefMaxLen / LevelInfoSize;
    if (MaxEntriesToRead == 0) {
        MaxEntriesToRead = 1;
    }

    //
    // Things could be in a state of flux: if the request is for more than the maximum
    // number of roots allowed on a single server, then cap it right there.
    //
    else if (MaxEntriesToRead > MAX_DFS_NAMESPACES)
    {
        MaxEntriesToRead = MAX_DFS_NAMESPACES;
    }
    
    if (Status == ERROR_SUCCESS)
    {
        if (DfsIsMachineDC() &&
            DfsIsNameContextDomainName(&NameContext))
        {

            if (DomainRoots != TRUE) 
            {
                Status = ERROR_INVALID_NAME;

            }
            else
            {
                Status = DfsDcEnumerateRoots( NULL,
                                              pBuffer,
                                              BufferSize,
                                              pEntriesRead,
                                              MaxEntriesToRead,
                                              pResumeHandle,
                                              pSizeRequired);
            }
        }
        else 
        {
            if (DomainRoots == TRUE) 
            {
                Status = ERROR_INVALID_NAME;
            }
            else
            {
                Status = DfsEnumerateLocalRoots( NULL,
                                                 DomainRoots,
                                                 pBuffer,
                                                 BufferSize,
                                                 pEntriesRead,
                                                 MaxEntriesToRead,
                                                 pResumeHandle,
                                                 pSizeRequired );
            }
        }
    }
    DFS_TRACE_ERROR_NORM(Status, API, "Dfs enumerate roots, status %x\n",
                         Status );

done:

    return Status;

}




//+----------------------------------------------------------------------------
//
//  Function:   DfsAddADBlobRoot
//
//  Arguments:  
//      LPWSTR MachineName,
//      LPWSTR DcName,
//      LPWSTR ShareName,
//      LPWSTR LogicalShare,
//      LPWSTR Comment,
//      DWORD Flags,
//     PDFSM_ROOT_LIST *ppRootList )
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsAddADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DcName,
    LPWSTR ShareName,
    LPWSTR LogicalShare,
    LPWSTR Comment,
    BOOLEAN NewFtDfs,
    DWORD Flags,
    PVOID ppList )
{

    DFS_TRACE_NORM(API, "Dfs add ad blob root Machine Share %ws\n",
                   ShareName);
    
    PDFSM_ROOT_LIST *ppRootList = (PDFSM_ROOT_LIST *)ppList;
    DfsADBlobStore *pADBlobStore = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING UseMachineName;
    size_t LogicalShareLength = 0;
    
    Status = DfsRtlInitUnicodeStringEx(&UseMachineName, NULL);
    if (Status != ERROR_SUCCESS)
    {
      goto done;
    }

    //
    // dfsdev: use these parameters.
    //

    UNREFERENCED_PARAMETER(MachineName);
    UNREFERENCED_PARAMETER(Comment);
    UNREFERENCED_PARAMETER(Flags);

    //
    // MachineName and ppList passed in are unused. ShareName
    // and LogicalShare must be valid args.
    // 
    if (IsEmptyString( ShareName ) ||
        IsEmptyString( LogicalShare ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    Status = DfsStringCchLength( LogicalShare, MAXUSHORT, &LogicalShareLength );
    if (Status != ERROR_SUCCESS)
    {
        goto done;
    }
    
    //
    // Logical share cannot have illegal characters. These are currently the
    // STANDARD_ILLEGAL_CHARS. Therefore, SPACE is a valid character.
    //
    if (!IS_VALID_TOKEN( LogicalShare, LogicalShareLength ))
    {
        Status = ERROR_INVALID_NAME;
        goto done;
    }
    

    //
    // This is a registry store specific function. So find the registry store.
    // This gives us a referenced registry store pointer.
    //
    Status = DfsGetADBlobStore( &pADBlobStore );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetMachineName( &UseMachineName);

        if (Status == ERROR_SUCCESS) {

            Status = pADBlobStore->CreateADBlobRoot( UseMachineName.Buffer,
                                                     DcName,
                                                     ShareName,
                                                     LogicalShare,
                                                     Comment,
                                                     NewFtDfs);
            DfsReleaseMachineName(&UseMachineName);
        }
        pADBlobStore->ReleaseReference();
    }

done:

    DFS_TRACE_ERROR_NORM(Status, API, "Dfs add ad blob root status %x Machine  Share %ws\n",
                         Status, ShareName);
    
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteADBlobRoot
//
//  Arguments:  
//      LPWSTR MachineName,
//      LPWSTR DcName,
//      LPWSTR ShareName,
//      LPWSTR LogicalShare,
//      DWORD Flags,
//     PDFSM_ROOT_LIST *ppRootList )
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//-----------------------------------------------------------------------------
DFSSTATUS
DfsDeleteADBlobRoot(
    LPWSTR MachineName,
    LPWSTR DcName,
    LPWSTR ShareName,
    LPWSTR LogicalShare,
    DWORD Flags,
    PVOID ppList )
{
    DFS_TRACE_NORM(API, "Dfs delete ad blob root Machine Share %ws\n",
                   ShareName);

    UNREFERENCED_PARAMETER(ppList);

    DfsADBlobStore *pADBlobStore = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    UNICODE_STRING UseMachineName;
    
    Status = DfsRtlInitUnicodeStringEx(&UseMachineName, NULL);
    if (Status != ERROR_SUCCESS)
    {
      goto done;
    }

    //
    // MachineName and ppList passed in are unused. ShareName
    // and LogicalShare must be valid args.
    // 
    if (IsEmptyString( ShareName ) ||
       IsEmptyString( LogicalShare ))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //
    // This gives us a referenced ad blob store pointer.
    //
    Status = DfsGetADBlobStore( &pADBlobStore );
    if (Status == ERROR_SUCCESS)
    {

        if ((Flags & DFS_FORCE_REMOVE) == DFS_FORCE_REMOVE) 
        {
            if ((DfsServerGlobalData.IsDc == FALSE) ||
                (IsEmptyString(MachineName)))
            {
                Status = ERROR_INVALID_PARAMETER;
            }
            else
            {
                Status = pADBlobStore->DeleteADBlobRootForced( MachineName,
                                                               DcName,
                                                               ShareName,
                                                               LogicalShare );
            }

        }
        else
        {
            Status = DfsGetMachineName( &UseMachineName);
            if (Status == ERROR_SUCCESS) {
                Status = pADBlobStore->DeleteADBlobRoot( UseMachineName.Buffer,
                                                         DcName,
                                                         ShareName,
                                                         LogicalShare );
                DfsReleaseMachineName(&UseMachineName);
            }
        }
        pADBlobStore->ReleaseReference();
    }

done:

    DFS_TRACE_ERROR_NORM(Status, API, "Dfs delete ad blob root status %x Machine  Share %ws\n",
                         Status, ShareName);
    
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsClean
//
//  Arguments:  
//    HostServerName - target server name to contact
//    ShareNameToClean - name of the unwanted to share
//
//
//  Returns:    Status: 
//
//  Description: This function contacts the registry of a given machine to remove
//             its references to an obsolete root name in its registry. The root
//             can be standalone or fault-tolerant.
//             This is primarily a utility function. We don't assume that the roots
//             are recognized or even that the stores registered. CleanRegEntry
//             are static functions.
//+-------------------------------------------------------------------------

DFSSTATUS
DfsClean(
    LPWSTR HostServerName,
    LPWSTR ShareNameToClean
    )
{
    DFSSTATUS Status = ERROR_NOT_FOUND;
    DFSSTATUS CleanStatus;
    
    DFS_TRACE_LOW(REFERRAL_SERVER, "DfsClean: \\%ws\\%ws\n", 
                    HostServerName, ShareNameToClean);

    if ( IsEmptyString(HostServerName) || 
        IsEmptyString(ShareNameToClean)) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ask each store registered to remove this share
    // from this server's registry. Each store will take care of
    // \Domain \Standalone and \Enterprise portions of the
    // reg keys.
    //
    CleanStatus = DfsADBlobStore::CleanRegEntry( HostServerName,
                                              ShareNameToClean );
    
    //
    // Return SUCCESS if at least one store managed to do
    // the clean successfully.
    //
    if (CleanStatus == ERROR_SUCCESS) 
    {
        Status = CleanStatus;
    } 

    CleanStatus = DfsRegistryStore::CleanRegEntry( HostServerName,
                                              ShareNameToClean );
    if (CleanStatus == ERROR_SUCCESS) 
    {
        Status = CleanStatus;  
    }

    // no-op.
    CleanStatus = DfsEnterpriseStore::CleanRegEntry( HostServerName,
                                              ShareNameToClean );
    if (CleanStatus == ERROR_SUCCESS) 
    {
        Status = CleanStatus;  
    }

    DFS_TRACE_ERROR_NORM(Status, API, "DfsClean: \\%ws\\%ws Status = %x\n", 
                         HostServerName, ShareNameToClean, Status );

    return Status;
}


DFSSTATUS
DfsEnum(
    IN LPWSTR DfsName,
    IN DWORD Level,
    IN DWORD PrefMaxLen,
    OUT LPBYTE *pBuffer,
    OUT LPDWORD pEntriesRead,
    IN OUT LPDWORD pResumeHandle)

{
    LONG BufferSize = 0;
    LONG SizeRequired = 0;
    ULONG MaxRetry = 0;
    ULONG EntriesRead = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    LPDFS_INFO_1 pInfo1 = NULL;

    DFS_TRACE_LOW( API, "DfsEnum from ApiFrontEnd %ws\n", DfsName);

    MaxRetry = 5;
    BufferSize = sizeof(DFS_INFO_1);


    if(!pEntriesRead || !pBuffer || (Level == 0))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto done;
    }

    do
    {
        pInfo1 = (LPDFS_INFO_1) MIDL_user_allocate( BufferSize );
        if (pInfo1 == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (Level != 200 && Level != 300)
        {
            Status = DfsEnumerate( DfsName,
                                   Level,
                                   PrefMaxLen,
                                   (LPBYTE)pInfo1,
                                   BufferSize,
                                   &EntriesRead,
                                   pResumeHandle,
                                   &SizeRequired );
        } else {
            //
            // Level 200 takes in a domain and 300, the root server.
            //
            Status = DfsEnumerateRoots( DfsName,
                                     (Level == 200) ? TRUE : FALSE,
                                     PrefMaxLen,
                                     (LPBYTE)pInfo1,
                                     BufferSize,
                                     &EntriesRead,
                                     pResumeHandle,
                                     (PULONG)&SizeRequired ); // xxx supw
        }
        
        if (Status != ERROR_SUCCESS)
        {
            MIDL_user_free( pInfo1 );
        }

        if (Status == ERROR_BUFFER_OVERFLOW)
        {
            BufferSize = SizeRequired;
        }
    
    } while ( (Status == ERROR_BUFFER_OVERFLOW) && (MaxRetry--) );

    if (Status == ERROR_SUCCESS) 
    {
        *pEntriesRead = EntriesRead;
        *pBuffer = (LPBYTE)pInfo1;
    }

done:


    DFS_TRACE_ERROR_HIGH( Status, API, "DfsEnum from ApiFrontEnd %ws, Status %x\n", DfsName, Status);
    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsRenameLinks
//
//  Arguments:  DfsPathName - the root that is affected
//              OldName  - Old domain name
//              NewName   - new domain name
//
//  Returns:    ERROR_SUCCESS 
//              Error code otherwise.
//
//  Description: Given the old domain name and a new one to replace it with
//             this iterates through all the links in the given namespace and 
//             fixes obsolete references to the old domain.
//-----------------------------------------------------------------------------

DFSSTATUS
DfsRenameLinks(
    IN LPWSTR DfsPathString,
    IN LPWSTR OldDomainName,
    IN LPWSTR NewDomainName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    UNICODE_STRING DfsPathName;
    
    Status = DfsRtlInitUnicodeStringEx( &DfsPathName, DfsPathString);
    if (Status != ERROR_SUCCESS)
    {
      return Status;
    }

    API_VALIDATE_ARGUMENTS( DfsPathName, OldDomainName, NewDomainName, Status );

    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //
    // Null or empty server/share names are illegal.
    // The DfsPathName needs to have all three components \\x\y\z
    // but that'll get indirectly validated when we do DfsGetRootFolder.
    //
    if ((IsEmptyUnicodeString( &DfsPathName )) ||
       (IsEmptyString( OldDomainName )) ||
       (IsEmptyString( NewDomainName )))
       
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }
    
    //
    // Get the root folder matching the given namespace. 
    // We get a referenced root folder.
    //
    Status = DfsGetRootFolder( &DfsPathName,
                            NULL,
                            &pRoot );

    if (Status == ERROR_SUCCESS)
    {
        //
        // Let the root folder know that a new api request is coming in
        // This will give it a chance to let us know if api requests
        // are allowed, and to synchronize with the metadata as necessary.
        //
        if (!DfsCheckDirectMode())
        {
            Status = pRoot->RootApiRequestPrologue( TRUE );
        }
        
        if (Status == ERROR_SUCCESS) {
                    
            //
            // Replace all references to OldDomainName with the new.
            //
            Status = pRoot->RenameLinks( OldDomainName,
                                        NewDomainName );
            //
            // We are done: release our reference on the root.
            //
            if (!DfsCheckDirectMode())
            {
                pRoot->RootApiRequestEpilogue( FALSE, Status );
            }
        }
        pRoot->ReleaseReference();
    }
    
    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDirectApiOpen
//
//  Arguments:  DfsPath - the root that is affected
//  Returns:    ERROR_SUCCESS 
//              Error code otherwise.
//
//  Description: The most important task this does is to perform LdapConnect.
//             Callers are supposed to perform a corresponding DirectApiClose when done.
//             This protocol is handy because direct-mode users may execute many
//             api requests in between an DirectApiOpen and its DirectApiClose. There's no
//             need to synchronize per each such request.
//-----------------------------------------------------------------------------

DFSSTATUS
DfsDirectApiOpen(
    IN LPWSTR DfsNameSpace,
    IN LPWSTR DCName,
    OUT PVOID *pLibHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    PDFS_DIRECT_API_CONTEXT pApiContext = NULL;
    UNICODE_STRING DfsPathName;
    UNICODE_STRING ServerName, ShareName;

    LPWSTR UseDCName = NULL;
    UNICODE_STRING DomainName;
    DfsString *pPDC;

    Status = DfsRtlInitUnicodeStringEx( &DfsPathName, DfsNameSpace);
    if (Status != ERROR_SUCCESS)
    {
      return Status;
    }

    *pLibHandle = NULL;

    do {
        
        //
        // We must have a valid-looking root.
        //
        Status = DfsGetPathComponents(&DfsPathName,
                                      &ServerName,
                                      &ShareName,
                                      NULL );

        if ( Status != ERROR_SUCCESS ||
            ServerName.Length == 0 || ShareName.Length == 0 )
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }


        Status = DfsCreateUnicodeString( &DomainName, &ServerName);


        //
        // tread very carefully here:
        // this is to fix a bug that we should fix in a better
        // way in future, by changing the core of DFS to handle
        // any domain name, instead of assuming all accesses are
        // to the local domain
        //
        // all of dfs code assumes that we are running in the local
        // domain. This does not work well for dfsutil.
        // Here we are working around this by doing a couple of things:
        // 1) we force a DC for the domain of interest. This gets stored
        //    in our global data structures, for all other accesses.
        // 2) We force a new ad name context for this domain, again
        //    this gets stored in our global data structures, for all
        //    other accesses.
        //  
        // Once we have created the object and have cached it we dont
        // need this information anymore. The next direct open will
        // overwrite this global information.
        //
        // this code is based on certain assumptions as to how the
        // rest of the code works. If those assumptions are violated,
        // things will break.
        //
        // assumption 1: RootApiPrologue will accept a DC name, and not
        // forcefully get a new dc name. 
        // assumption 2: RootApiPrologue will cache the ldap connection
        // to the DC, for the entire request till we call epilogue.
        // assumption 3: Once we have created a root in this code,
        // no other global information will be necessary when we 
        // flush out the information at a later point.
        //
        //
        if (Status == ERROR_SUCCESS)
        {
            if (DfsIsThisADomainName(DomainName.Buffer) == ERROR_SUCCESS)
            {
                if (DCName != NULL)
                {
                    Status = DfsSetBlobPDCName( DCName,
                                                &pPDC);
                }
                else
                {
                    Status = DfsGetBlobPDCName( &pPDC, 
                                                DFS_FORCE_DC_QUERY,
                                                DomainName.Buffer);
                }

                if (Status == ERROR_SUCCESS)
                {
                    UseDCName = pPDC->GetString();
                }


                if (Status == ERROR_SUCCESS)
                {
                    LPWSTR ADContext;

                    extern LPWSTR DfsGetDfsAdNameContextStringForDomain(LPWSTR UseDC);
                    ADContext = DfsGetDfsAdNameContextStringForDomain(UseDCName);
                }
            }
            DfsFreeUnicodeString(&DomainName);
        }
        

        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        Status = DfsDirectApiAllocContext( &pApiContext, 
                                      &DfsPathName, 
                                      &ServerName,
                                      &ShareName );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
        
        //
        //  Now see if any of the stores recognizes this root.
        //  The store will read in the root's metadata in to the cache.
        //  
        Status = DfsRecognize( pApiContext->ServerName.Buffer, &pApiContext->ShareName );

        if (Status != ERROR_SUCCESS)
        {
            break;
        }             
                    
        //
        // Get the root folder matching the given namespace. 
        // We get a referenced root folder.
        //
        Status = DfsGetRootFolder( &pApiContext->RootName,
                                NULL,
                                &pRoot );

        if (Status != ERROR_SUCCESS)
        {
            break;
        }
                    
        //
        //  ApiRequestPrologue will open AD object
        //  and get us ready for incoming API requests. All direct 
        //  mode opens are considered WRITE requests, although currently,
        //  that makes no difference as CommonRequestPrologue ignores it.
        //
        Status = pRoot->RootApiRequestPrologue( TRUE,
                                                UseDCName );


        if (Status != ERROR_SUCCESS)
        {
            pRoot->ReleaseReference();
            break;
        }
        
        //
        // Return a valid 'handle' on success.
        //
        pApiContext->pObject = (PVOID)pRoot;
        pApiContext->IsInitialized = TRUE;
        pApiContext->IsWriteable = FALSE;
        *pLibHandle = (PVOID)pApiContext;
        
    } while (FALSE);

    if (Status != ERROR_SUCCESS)
    {
        // 
        // Clean up the DirectApiContext if we hit errors.
        // We have been careful not to do any operations that might fail
        // after we do the RootApiRequestPrologue.
        //
        if (pApiContext != NULL)
        {
            DfsDirectApiFreeContext( pApiContext );
        }
    }
   
    return Status;
}


DFSSTATUS
DfsDirectApiCommitChanges(
    IN PVOID Handle)
{
    DFS_SERVER_LIB_HANDLE LibHandle = (DFS_SERVER_LIB_HANDLE)Handle;
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_DIRECT_API_CONTEXT pApiContext = (PDFS_DIRECT_API_CONTEXT)LibHandle;
    DfsRootFolder *pRoot;
    
    if ((pApiContext == NULL) ||
        (pApiContext->IsInitialized == FALSE) ||
        (pApiContext->pObject == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    if (pApiContext->IsWriteable == FALSE)
    {
        return ERROR_ACCESS_DENIED;
    }

    pRoot = (DfsRootFolder *)pApiContext->pObject;

    Status = pRoot->Flush();

    return Status;
}

DFSSTATUS
DfsDirectApiClose(
    IN PVOID Handle)
{
    DFS_SERVER_LIB_HANDLE LibHandle = (DFS_SERVER_LIB_HANDLE)Handle;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pRoot;
    PDFS_DIRECT_API_CONTEXT pApiContext = (PDFS_DIRECT_API_CONTEXT)LibHandle;

    do {
        // 
        // Check for valid handle
        //
        if ((pApiContext == NULL) ||
           (pApiContext->IsInitialized == FALSE) ||
           (pApiContext->pObject == NULL))
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

        pRoot = (DfsRootFolder *)pApiContext->pObject;

        pRoot->RootApiRequestEpilogue( TRUE, Status );
        pRoot->ReleaseReference();

    } while (FALSE);

    //
    // Free the DirectApiContext on our way out.
    //
    if (pApiContext != NULL)
    {
        DfsDirectApiFreeContext( pApiContext );
    }
    
    return Status;
}

DFSSTATUS
DfsDirectApiAllocContext(
    OUT PDFS_DIRECT_API_CONTEXT *ppApiContext,
    IN PUNICODE_STRING pDfsPathName,
    IN PUNICODE_STRING pServerName, 
    IN PUNICODE_STRING pShareName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_DIRECT_API_CONTEXT pApiContext = NULL;
    do {

        pApiContext = (PDFS_DIRECT_API_CONTEXT) MIDL_user_allocate(sizeof(DFS_DIRECT_API_CONTEXT));
        if (pApiContext == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        RtlZeroMemory( pApiContext, sizeof( DFS_DIRECT_API_CONTEXT ));        
        
        Status = DfsCreateUnicodeString( &pApiContext->RootName, pDfsPathName );  
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
        
        //
        //  dfsdev: we really need to standardize on the LPWSTR vs. UNICODE issue.
        //
        Status = DfsCreateUnicodeString( &pApiContext->ServerName, pServerName );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        Status = DfsCreateUnicodeString( &pApiContext->ShareName, pShareName );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        *ppApiContext = pApiContext;
    } while (FALSE);

    if (Status != ERROR_SUCCESS)
    {
        if (pApiContext != NULL)
        {
           DfsDirectApiFreeContext( pApiContext );
        }
    }

    return Status;
}

VOID
DfsDirectApiFreeContext(
    PDFS_DIRECT_API_CONTEXT pApiContext)
{
    if (pApiContext != NULL)
    {
        if (pApiContext->RootName.Buffer != NULL)
        {
            DfsFreeUnicodeString( &pApiContext->RootName );
            RtlInitUnicodeString( &pApiContext->RootName, NULL );
        }

        if (pApiContext->ServerName.Buffer != NULL)
        {
            DfsFreeUnicodeString( &pApiContext->ServerName );
            RtlInitUnicodeString( &pApiContext->ServerName, NULL );
        }

        if (pApiContext->ShareName.Buffer != NULL)
        {
            DfsFreeUnicodeString( &pApiContext->ShareName );
            RtlInitUnicodeString( &pApiContext->ShareName, NULL );
        }

        pApiContext->pObject = NULL;
        pApiContext->IsInitialized = FALSE;
        pApiContext->IsWriteable = FALSE;
        
        MIDL_user_free( pApiContext );
    }

    return;
}



DFSSTATUS
DfsExtendedRootAttributes(
    IN PVOID Handle,
    PULONG pAttr,
    PUNICODE_STRING pRemaining,
    BOOLEAN Set )
{
    DFS_SERVER_LIB_HANDLE LibHandle = (DFS_SERVER_LIB_HANDLE)Handle;
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_DIRECT_API_CONTEXT pApiContext = (PDFS_DIRECT_API_CONTEXT)LibHandle;
    DfsRootFolder *pRoot;
    
    if ((pApiContext == NULL) ||
        (pApiContext->IsInitialized == FALSE) ||
        (pApiContext->pObject == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }
    pRoot = (DfsRootFolder *)pApiContext->pObject;

    Status = pRoot->ExtendedRootAttributes( pAttr, pRemaining, Set);

    return Status;
}
//
// Get the size of the blob.
//
DFSSTATUS
DfsGetBlobSize(
    IN PVOID Handle,
    OUT PULONG pBlobSize )
{

    DFS_SERVER_LIB_HANDLE LibHandle = (DFS_SERVER_LIB_HANDLE)Handle;
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_DIRECT_API_CONTEXT pApiContext = (PDFS_DIRECT_API_CONTEXT)LibHandle;
    DfsRootFolder *pRoot;
    
    if ((pApiContext == NULL) ||
        (pApiContext->IsInitialized == FALSE) ||
        (pApiContext->pObject == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    pRoot = (DfsRootFolder *)pApiContext->pObject;
    //
    // Now ask the root get the blob from the cache.
    //
    *pBlobSize = pRoot->GetBlobSize();

    return Status;
}



//
// Get the size of the blob.
//
DFSSTATUS
DfsGetSiteBlob(
    IN PVOID Handle,
    OUT PVOID *ppBlob,
    OUT PULONG pBlobSize )
{

    DFS_SERVER_LIB_HANDLE LibHandle = (DFS_SERVER_LIB_HANDLE)Handle;
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_DIRECT_API_CONTEXT pApiContext = (PDFS_DIRECT_API_CONTEXT)LibHandle;
    DfsRootFolder *pRoot;
    
    if ((pApiContext == NULL) ||
        (pApiContext->IsInitialized == FALSE) ||
        (pApiContext->pObject == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    pRoot = (DfsRootFolder *)pApiContext->pObject;
    //
    // Now ask the root get the blob from the cache.
    //
    Status = pRoot->GetSiteBlob(ppBlob, pBlobSize);

    return Status;
}


//
// Get the size of the blob.
//
DFSSTATUS
DfsSetSiteBlob(
    IN PVOID Handle,
    IN PVOID pBlob,
    IN ULONG BlobSize )
{

    DFS_SERVER_LIB_HANDLE LibHandle = (DFS_SERVER_LIB_HANDLE)Handle;
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_DIRECT_API_CONTEXT pApiContext = (PDFS_DIRECT_API_CONTEXT)LibHandle;
    DfsRootFolder *pRoot;
    
    if ((pApiContext == NULL) ||
        (pApiContext->IsInitialized == FALSE) ||
        (pApiContext->pObject == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }

    pRoot = (DfsRootFolder *)pApiContext->pObject;
    //
    // Now ask the root get the blob from the cache.
    //
    Status = pRoot->SetSiteBlob(pBlob, BlobSize);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsdownlevel.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsDownLevel.cxx
//
//  Contents:   Contains APIs to communicate old DFS Servers   
//
//  Classes:    none.
//
//  History:    Jan. 24 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>        
#include <lm.h>
#include <winsock2.h>
#include <smbtypes.h>

#pragma warning(disable: 4200) //nonstandard extension used: zero-sized array in struct/union (line 1085
#include <smbtrans.h>
#pragma warning(default: 4200)

#include <dsgetdc.h>
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <dfsfilterapi.hxx>


#define PATH_DELIMITER L'\\'



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV1ReferralSize 
//
//  Arguments:  List of referrals
//
//  Returns:    size of referrals
//
//
//  Description: calculates size needed to fit V1 referrals
//
//--------------------------------------------------------------------------
ULONG
DfspGetV1ReferralSize(
    IN PREFERRAL_HEADER pRefHeader)
{
    ULONG i = 0;
    ULONG size = 0;
    PREPLICA_INFORMATION pRep = NULL;

    size = sizeof( RESP_GET_DFS_REFERRAL );
    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {
        size += sizeof(DFS_REFERRAL_V1) +
                    pRep->ReplicaNameLength +
                        sizeof(UNICODE_NULL);

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );

    }

    return( size );

}


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV2ReferralSize 
//
//  Arguments:  List of referrals
//
//  Returns:    size of referrals
//
//
//  Description: calculates size needed to fit V2 referrals
//
//--------------------------------------------------------------------------

ULONG
DfspGetV2ReferralSize(
    IN PREFERRAL_HEADER pRefHeader)
{
    ULONG i = 0;
    ULONG size = 0;
    PREPLICA_INFORMATION pRep = NULL;
    UNICODE_STRING PrefixTail;

    size = sizeof( RESP_GET_DFS_REFERRAL );
    PrefixTail.Length = 0;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {

        size += sizeof(DFS_REFERRAL_V2) +
                    pRep->ReplicaNameLength +
                        sizeof(UNICODE_NULL);

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );    
    }


    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);


    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);

    return( size );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3ReferralSize 
//
//  Arguments:  List of referrals
//
//  Returns:    size of referrals
//
//
//  Description: calculates size needed to fit V3 referrals
//
//--------------------------------------------------------------------------

ULONG
DfspGetV3ReferralSize(
    IN PREFERRAL_HEADER pRefHeader)
{
    ULONG i = 0;
    ULONG size = 0;
    PREPLICA_INFORMATION pRep = NULL;
    UNICODE_STRING PrefixTail;

    size = sizeof( RESP_GET_DFS_REFERRAL );

    PrefixTail.Length = 0;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);
    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {

        size += sizeof(DFS_REFERRAL_V3) +
                    pRep->ReplicaNameLength +
                        sizeof(UNICODE_NULL);

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }


    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);

    size += sizeof(UNICODE_PATH_SEP) +
                    pRefHeader->LinkNameLength +
                        sizeof(UNICODE_NULL);

    return( size );
}


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV1Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V1 referrals to output buffer
//
//--------------------------------------------------------------------------

VOID
DfspGetV1Referral(
    IN PREFERRAL_HEADER pRefHeader,
    OUT PRESP_GET_DFS_REFERRAL Ref)
{
    PDFS_REFERRAL_V1 pv1 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;

    Ref->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;

    Ref->ReferralServers = 1;

    Ref->StorageServers = 1;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);
    pv1 = &Ref->Referrals[0].v1;

    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {
         pv1->VersionNumber = 1;

         pv1->Size = (USHORT)( sizeof(DFS_REFERRAL_V1) +
                        pRep->ReplicaNameLength +
                            sizeof(UNICODE_NULL));

         if (((pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL) == 0) &&
            ((pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_OUT_OF_DOMAIN) == 0))
         {
             pv1->ServerType = 0;
         } 
         else
         {
             pv1->ServerType = 1;
         }

         RtlCopyMemory(
            pv1->ShareName,
            pRep->ReplicaName,
            pRep->ReplicaNameLength);

         pv1->ShareName[ pRep->ReplicaNameLength / sizeof(WCHAR) ] =
            UNICODE_NULL;

         pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
         pv1 = (PDFS_REFERRAL_V1) ( ((PCHAR) pv1) + pv1->Size );

    }

}


//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV2Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V2 referrals to output buffer
//
//--------------------------------------------------------------------------

NTSTATUS
DfspGetV2Referral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V2 pv2 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    LPWSTR LinkName;
    ULONG LinkNameLength;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize =
        sizeof (RESP_GET_DFS_REFERRAL) +
          pRefHeader->LinkNameLength +
             sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL) +
               pRefHeader->LinkNameLength +
                  sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_OUT_OF_DOMAIN)
    {
        pRef->ReferralServers = 1;
        pRef->StorageServers = 0;

    }
    else if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL)
    {
        pRef->ReferralServers = 1;
        pRef->StorageServers = 1;
    }
    else
    {
        pRef->ReferralServers = 0;
        pRef->StorageServers = 1;
    }

    pRef->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;

    pv2 = &pRef->Referrals[0].v2;


    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {

        CurrentSize = sizeof(DFS_REFERRAL_V3) +
           pRep->ReplicaNameLength + sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }


    // Adjust the number of referrals accordingly.
    pRef->NumberOfReferrals = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pRef->NumberOfReferrals == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv2[ pRef->NumberOfReferrals ];


    LinkName = pRefHeader->LinkName;
    LinkNameLength = pRefHeader->LinkNameLength;



    while ((LinkNameLength > (sizeof(WCHAR) + sizeof(WCHAR))) && 
           (LinkName[0] == UNICODE_PATH_SEP) &&
           (LinkName[1] == UNICODE_PATH_SEP))
    {
        LinkName++;
        LinkNameLength -= sizeof(WCHAR);
    }

    pRef->PathConsumed = (USHORT)LinkNameLength;
    RtlCopyMemory(
       pNextAddress,
       LinkName,
       LinkNameLength);

    pNextAddress += LinkNameLength/sizeof(WCHAR);

   *pNextAddress++ = UNICODE_NULL;

   //
   // Copy the 8.3 volume prefix into the response buffer after the
   // dfsPath
   //

   pAlternatePath = pNextAddress;

   RtlCopyMemory(
      pNextAddress,
      LinkName,      
      LinkNameLength);

   pNextAddress += LinkNameLength/sizeof(WCHAR);

   *pNextAddress++ = UNICODE_NULL;


   pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);
   for (i = 0; i < pRef->NumberOfReferrals; i++) 
   {
       pv2->VersionNumber = 2;
       pv2->Size = sizeof(DFS_REFERRAL_V2);

       //
       // Clients who use V2 Referrals (< NT4SP5 for example) expect ServerType of 0
       // for SMB link targets. Root referrals and targets pointing at other 
       // DFS namespaces need to send ServerType of 1.
       //
       if (((pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL) == 0) &&
           ((pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_OUT_OF_DOMAIN) == 0))
       {
            pv2->ServerType = 0;
       } 
       else
       {
            pv2->ServerType = 1;
       }
       pv2->Proximity = 0;
       pv2->TimeToLive = pRefHeader->Timeout;
       pv2->DfsPathOffset = (USHORT) (((PCHAR) pDfsPath) - ((PCHAR) pv2));
       pv2->DfsAlternatePathOffset =
               (USHORT) (((PCHAR) pAlternatePath) - ((PCHAR) pv2));
       pv2->NetworkAddressOffset =
               (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv2));

       RtlCopyMemory(
               pNextAddress,
               pRep->ReplicaName,
               pRep->ReplicaNameLength);
       pNextAddress[ pRep->ReplicaNameLength/sizeof(WCHAR) ] = UNICODE_NULL;
       pNextAddress += pRep->ReplicaNameLength/sizeof(WCHAR) + 1;
       pv2++;
       pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
   }


   *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3DomainReferral 
//
//  Arguments:  dfsdev: fill this in.
//
//  Returns:    
//
//
//  Description: Copies the V3 referrals to output buffer
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetV3DomainReferral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V3 pv3 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize = sizeof (RESP_GET_DFS_REFERRAL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    //
    // For compatibility, set all referrals to be storage servers.
    // and only the root referral as the referral servers.
    // This appears to keep the client happy for all cases
    // dfsdev: investigate if this is fine.
    //
    pRef->StorageServers = 0;
    pRef->ReferralServers = 0;
    pRef->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;
    pRef->PathConsumed = 0;

    pv3 = &pRef->Referrals[0].v3;

    //
    // double unicode_null at end.
    //
    CumulativeSize += sizeof(UNICODE_NULL);

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {

        CurrentSize = sizeof(DFS_REFERRAL_V3) + sizeof(UNICODE_PATH_SEP) +
           pRep->ReplicaNameLength + sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
        {
            Status = ERROR_MORE_DATA;
            break;
        }

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    if (Status == ERROR_MORE_DATA)
    {
#define EVENT_POSTED 1
#define EVENT_NOT_POSTED 0
        static LONG DomainOverflowMaxEventPosted = 0;
        static LONG DomainOverflowMinEventPosted = 0;
        LONG PostedState;

        PostedState = InterlockedCompareExchange(&DomainOverflowMinEventPosted,
                                                 EVENT_POSTED, EVENT_NOT_POSTED);
        if (PostedState == EVENT_NOT_POSTED)
        {
            DfsLogDfsEvent(DFS_INFO_DOMAIN_REFERRAL_MIN_OVERFLOW,
                           0, NULL, 0);
        }
                                                 

        if (BufferSize < MAX_REFERRAL_SIZE)
        {
            return Status;
        }
        else
        {
            Status = ERROR_SUCCESS;
            PostedState = InterlockedCompareExchange(&DomainOverflowMaxEventPosted,
                                                     EVENT_POSTED, EVENT_NOT_POSTED);
            if (PostedState == EVENT_NOT_POSTED)
            {
                //post event;
                DfsLogDfsEvent(DFS_WARN_DOMAIN_REFERRAL_OVERFLOW,
                               0, NULL, 0);
            }
        }
    }
    // Adjust the number of referrals accordingly.
    pRef->NumberOfReferrals = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pRef->NumberOfReferrals == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv3[ pRef->NumberOfReferrals ];

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {
        pv3->VersionNumber = 3;
        pv3->Size = sizeof(DFS_REFERRAL_V3);
        pv3->ServerType = 0;
        pv3->StripPath = 0;                        // for now
        pv3->NameListReferral = 1;
        pv3->TimeToLive = 600;

        pv3->SpecialNameOffset =
            (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

        pv3->NumberOfExpandedNames = 0;
        pv3->ExpandedNameOffset = 0;

        //
        // dfsdev investigate.
        //
        *pNextAddress++ = UNICODE_PATH_SEP;
        RtlMoveMemory(
            pNextAddress,
            pRep->ReplicaName,
            pRep->ReplicaNameLength);

        pNextAddress[ pRep->ReplicaNameLength / sizeof(WCHAR)] = UNICODE_NULL;
        pNextAddress += pRep->ReplicaNameLength / sizeof(WCHAR) + 1;

        pv3++;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V3 referrals to output buffer
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetV3DCReferral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V3 pv3 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize = sizeof (RESP_GET_DFS_REFERRAL) +
        pRefHeader->LinkNameLength + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    //
    // For compatibility, set all referrals to be storage servers.
    // and only the root referral as the referral servers.
    // This appears to keep the client happy for all cases
    // dfsdev: investigate if this is fine.
    //
    pRef->StorageServers = 0;
    pRef->ReferralServers = 0;
    pRef->NumberOfReferrals = 1;
    pRef->PathConsumed = 0;

    pv3 = &pRef->Referrals[0].v3;

    //
    // double unicode_null at end.
    //
    CumulativeSize += sizeof(UNICODE_NULL);

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRefHeader->ReplicaCount; i++) 
    {
        CurrentSize = sizeof(UNICODE_PATH_SEP) +
                      pRep->ReplicaNameLength + 
                      sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    // Adjust the number of referrals accordingly.
    pv3->NumberOfExpandedNames = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pv3->NumberOfExpandedNames == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv3[ pRef->NumberOfReferrals ];
    pv3->SpecialNameOffset =
        (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

    *pNextAddress++ = UNICODE_PATH_SEP;
    RtlMoveMemory(
       pNextAddress,
       pRefHeader->LinkName,      
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);
    *pNextAddress++ = UNICODE_NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);


    pv3->VersionNumber = 3;
    pv3->Size = sizeof(DFS_REFERRAL_V3);
    pv3->ServerType = 0;
    pv3->StripPath = 0;                        // for now
    pv3->NameListReferral = 1;
    pv3->TimeToLive = 600;


    pv3->ExpandedNameOffset = 
        (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

    for (i = 0; i < pv3->NumberOfExpandedNames; i++) {

        //
        // dfsdev: this is very confusing.. 
        // investigate. Each of the referrals we call keep
        // adding a unicode path sep.
        //
#if 0
        *pNextAddress++ = UNICODE_PATH_SEP;
#endif
        RtlCopyMemory(
            pNextAddress,
            pRep->ReplicaName,
            pRep->ReplicaNameLength );

        pNextAddress[ pRep->ReplicaNameLength / sizeof(WCHAR)] = UNICODE_NULL;
        pNextAddress += pRep->ReplicaNameLength / sizeof(WCHAR) + 1;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }


    *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

    return Status;
}



DFSSTATUS
DfsGetV3NormalReferral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REFERRAL_V3 pv3 = NULL;
    PREPLICA_INFORMATION pRep = NULL;
    ULONG i = 0;
    ULONG CumulativeSize = 0;
    ULONG CurrentSize = 0;
    LPWSTR pDfsPath = NULL;
    LPWSTR pAlternatePath = NULL;
    LPWSTR pNextAddress = NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    // Calculate the size of the referral, and make sure our size does not
    // exceed the passed in buffer len.
    CumulativeSize =
        sizeof (RESP_GET_DFS_REFERRAL) +
          pRefHeader->LinkNameLength +
             sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL) +
               pRefHeader->LinkNameLength +
                  sizeof(UNICODE_PATH_SEP) + sizeof(UNICODE_NULL);

    if (BufferSize < CumulativeSize) 
    {
        Status = ERROR_MORE_DATA;
        return Status;
    }


    //
    // For compatibility, set all referrals to be storage servers.
    // and only the root referral as the referral servers.
    // This appears to keep the client happy for all cases
    // dfsdev: investigate if this is fine.
    //

    if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_OUT_OF_DOMAIN)
    {
        pRef->ReferralServers = 1;
        pRef->StorageServers = 0;

    }
    else if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL)
    {
        pRef->ReferralServers = 1;
        pRef->StorageServers = 1;
    }
    else
    {
        pRef->ReferralServers = 0;
        pRef->StorageServers = 1;
    }

    pRef->NumberOfReferrals = (USHORT) pRefHeader->ReplicaCount;

    pv3 = &pRef->Referrals[0].v3;

    //see how many referrals we can actually fit into the buffer
    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {

        CurrentSize = sizeof(DFS_REFERRAL_V3) +
           pRep->ReplicaNameLength + sizeof(UNICODE_NULL);

        if ((CumulativeSize + CurrentSize) >= BufferSize)
            break;

        CumulativeSize += CurrentSize;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    // Adjust the number of referrals accordingly.
    pRef->NumberOfReferrals = (USHORT)i;

    //
    // we have more than one service, but cannot fit any into the buffer
    // return buffer overflow.
    //
    if ((pRefHeader->ReplicaCount > 0) && (pRef->NumberOfReferrals == 0)) 
    {
        return ERROR_MORE_DATA;
    }

    //
    // Copy the volume prefix into the response buffer, just past the end
    // of all the V3 referrals
    //

    pNextAddress = pDfsPath = (LPWSTR) &pv3[ pRef->NumberOfReferrals ];

    RtlMoveMemory(
       pNextAddress,
       pRefHeader->LinkName,      
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);

    *pNextAddress++ = UNICODE_NULL;

    //
    // Copy the 8.3 volume prefix into the response buffer after the
    // dfsPath
    //

    pAlternatePath = pNextAddress;

    RtlMoveMemory(
       pNextAddress,
       pRefHeader->LinkName,      
       pRefHeader->LinkNameLength);

    pNextAddress += pRefHeader->LinkNameLength/sizeof(WCHAR);

    *pNextAddress++ = UNICODE_NULL;

    pRep = (PREPLICA_INFORMATION) ((PBYTE)pRefHeader + pRefHeader->OffsetToReplicas);

    for (i = 0; i < pRef->NumberOfReferrals; i++) 
    {
        pv3->VersionNumber = 3;
        pv3->Size = sizeof(DFS_REFERRAL_V3);

        //
        // The server type is important for the client. Set to 1 for
        // root referral, and 0 otherwise. It appears to keep the client
        // happy.
        // dfsdev: investigate further.
        //

        if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_ROOT_REFERRAL)
        {
            pv3->ServerType = 1;
        }
        else {
            pv3->ServerType = 0;
        }

        pv3->StripPath = 0;                        // for now
        pv3->NameListReferral = 0;
        pv3->TimeToLive = pRefHeader->Timeout;
        pv3->DfsPathOffset = (USHORT) (((PCHAR) pDfsPath) - ((PCHAR) pv3));

        pv3->DfsAlternatePathOffset =
            (USHORT) (((PCHAR) pAlternatePath) - ((PCHAR) pv3));

        pv3->NetworkAddressOffset =
            (USHORT) (((PCHAR) pNextAddress) - ((PCHAR) pv3));

        RtlZeroMemory(
            &pv3->ServiceSiteGuid,
            sizeof (GUID));

        RtlMoveMemory(
            pNextAddress,
            pRep->ReplicaName,
            pRep->ReplicaNameLength);

        pNextAddress[ pRep->ReplicaNameLength / sizeof(WCHAR)] = UNICODE_NULL;
        pNextAddress += pRep->ReplicaNameLength / sizeof(WCHAR) + 1;

        pv3++;

        pRep = (PREPLICA_INFORMATION) ( ((PCHAR) pRefHeader) + pRep->NextEntryOffset );
    }

    *ReferralSize = (ULONG)((PUCHAR)pNextAddress - (PUCHAR)pRef);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspGetV3Referral 
//
//  Arguments:  List of referrals
//
//  Returns:    
//
//
//  Description: Copies the V3 referrals to output buffer
//
//--------------------------------------------------------------------------

NTSTATUS
DfspGetV3Referral(
    IN PREFERRAL_HEADER pRefHeader,
    IN ULONG BufferSize,
    OUT PRESP_GET_DFS_REFERRAL pRef,
    OUT PULONG ReferralSize)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    
    //
    //The client could be asking for either the trusted domains referral
    // or for the list of DC for a domain or for a normal dfs referral
    // to a path.
    //
    if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_DOMAIN_REFERRAL)
    {
        Status = DfsGetV3DomainReferral( pRefHeader,
                                         BufferSize,
                                         pRef,
                                         ReferralSize );
    }
    else if (pRefHeader->ReferralFlags & DFS_REFERRAL_DATA_DOMAIN_DC_REFERRAL)
    {
        Status = DfsGetV3DCReferral( pRefHeader,
                                     BufferSize,
                                     pRef,
                                     ReferralSize );

    }
    else 
    {
        Status = DfsGetV3NormalReferral( pRefHeader,
                                         BufferSize,
                                         pRef,
                                         ReferralSize );

    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   ProcessOldDfsServerRequest 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Converts new data to what the old DFS server expects
//
//--------------------------------------------------------------------------
DFSSTATUS ProcessOldDfsServerRequest(HANDLE hDriverHandle,
                                     PUMRX_USERMODE_WORKITEM ProtocolBuffer,
                                     PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest,
                                     REFERRAL_HEADER *pReferral, 
                                     ULONG *ReturnedDataSize)

{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Size = 0;
    ULONG SendSize = 0;
    ULONG MaxLevel = 0;
    DWORD BytesReturned = 0;
    PRESP_GET_DFS_REFERRAL pRef = NULL;
    PBYTE pSendBuffer = NULL;
    PUMRX_USERMODE_WORKITEM pSendWorkItem = NULL;

    //get the level
    MaxLevel = pGetReplicaRequest->RepInfo.MaxReferralLevel;

    //check if MaxLevel is legal
    switch (MaxLevel) 
    {
        case 1:
            Size = DfspGetV1ReferralSize(pReferral); 
            break;
        case 2:
            Size = DfspGetV2ReferralSize(pReferral); 
            break;
        case 3:    
            Size = DfspGetV3ReferralSize(pReferral); 
            break;
        default:
            ASSERT(FALSE && "Invalid MaxLevel");
            Status = ERROR_INVALID_PARAMETER;
            break;
    }


    if(Status != ERROR_SUCCESS)
    {
        return Status;
    }    

    SendSize = UMR_ALIGN(pGetReplicaRequest->RepInfo.ClientBufferSize) + sizeof(UMRX_USERMODE_WORKITEM);
    pSendWorkItem = (PUMRX_USERMODE_WORKITEM) HeapAlloc(GetProcessHeap(), 0, SendSize);
    if(pSendWorkItem == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //get a pointer to the response buffer
    pSendBuffer = pSendWorkItem->WorkResponse.GetDfsReplicasResponse.Buffer;
    
    pRef = (PRESP_GET_DFS_REFERRAL) pSendBuffer;

    pRef->PathConsumed = (USHORT) pReferral->LinkNameLength;

    //
    // For level 1 referral, we fail if buffer is not big enough to
    // fit entire referral. For level 2 and 3, we try to fit as many
    // entries as possible into the refferal.
    if(MaxLevel == 1)
    {
        if(Size < pGetReplicaRequest->RepInfo.ClientBufferSize) 
        {
            DfspGetV1Referral(pReferral, pRef);
        }
        else
        {
            Status = ERROR_MORE_DATA;
        }
    }
    else if(MaxLevel == 2)
    {
        Status = DfspGetV2Referral(pReferral, pGetReplicaRequest->RepInfo.ClientBufferSize, pRef,&Size);
    }
    else
    {
        Status = DfspGetV3Referral(pReferral, pGetReplicaRequest->RepInfo.ClientBufferSize, pRef ,&Size);
    }

    if(Status == ERROR_SUCCESS)
    {

        //copy the original header
        pSendWorkItem->Header = ProtocolBuffer->Header;
        pSendWorkItem->Header.IoStatus.Status = Status;
        pSendWorkItem->Header.IoStatus.Information = 0;

        //return without waiting for a response
        pSendWorkItem->Header.ulFlags = UMR_WORKITEM_HEADER_FLAG_RETURN_IMMEDIATE;

        //set the size of the data being returned
        pSendWorkItem->WorkResponse.GetDfsReplicasResponse.Length = Size;

        //finally send the data
        Status = DfsUserModeProcessPacket(hDriverHandle, 
                                          (PBYTE) pSendWorkItem,
                                          SendSize,
                                          NULL,
                                          0,
                                          &BytesReturned);
    }


    if(pSendWorkItem != NULL)
    {
        HeapFree (GetProcessHeap(), 0, (PVOID) pSendWorkItem);
    }

    *ReturnedDataSize = Size;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsdomaininformation.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2001, Microsoft Corporation
//
//  File:       DfsDomainInformation.cxx
//
//  Contents:   the Dfs domain info class
//
//  Classes:    DfsDomainInformation
//
//  History:    apr. 8 2001,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsGeneric.hxx"
#include "Align.h"
#include "dsgetdc.h"
#include "DfsTrustedDomain.hxx"
#include "DfsReferralData.h"

#include "dfsdomainInformation.hxx"

#include "dfsxforest.hxx"

#include "dfsdomainInformation.tmh"

DfsDomainInformation::DfsDomainInformation(
    DFSSTATUS *pStatus, 
    DFSSTATUS *pXforestStatus) 
    : DfsGeneric( DFS_OBJECT_TYPE_DOMAIN_INFO)
{

   ULONG DsDomainCount = 0;
   PDS_DOMAIN_TRUSTS pDsDomainTrusts = NULL;
   DFSSTATUS Status = ERROR_SUCCESS;
   DFSSTATUS XforestInitStatus = ERROR_SUCCESS;
   LPWSTR ServerName = NULL;
   ULONG Index = 0;

   DfsXForest XForestInfo;

   _pTrustedDomains = NULL;
   _DomainCount = 0;
   _fCritInit = FALSE;
   _DomainReferralLength = 0;
        
   _pLock = new CRITICAL_SECTION;
   if ( _pLock == NULL )
   {
       Status = ERROR_NOT_ENOUGH_MEMORY;
   }
   else 
   {
       _fCritInit = InitializeCriticalSectionAndSpinCount( _pLock, DFS_CRIT_SPIN_COUNT );
       if(!_fCritInit)
       {
           Status = GetLastError();
           DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsDomainInformation::DfsDomainInformation InitializeCriticalSectionAndSpinCount Status %d\n",
                                Status);                
       }
   }

   if (Status == ERROR_SUCCESS)
   {
       ULONG ValidDomainCount = 0;
       DfsTrustedDomain *pUseDomain = NULL;

       //
       // We ignore Xforest initialization errors temporarily
       // but propagate them back to the DcLoop thread so
       // it can retry.
       //
       Status = XForestInfo.Initialize( pXforestStatus );

       if (Status == ERROR_SUCCESS)
       {
           ValidDomainCount = XForestInfo.GetCount();
       }

       if ( (Status == ERROR_SUCCESS) &&
                 (ValidDomainCount > 0) )
       {
           _DomainCount = ValidDomainCount;
           _pTrustedDomains = new DfsTrustedDomain[ _DomainCount ];

           if (_pTrustedDomains == NULL)
           {
                Status = ERROR_NOT_ENOUGH_MEMORY;

                DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsDomainInformation - _pTrustedDomains is NULL Status %d\n",
                                     Status);
           }

           ValidDomainCount = 0;

           if (Status == ERROR_SUCCESS)
           {
               PDFS_DOMAIN_NAME_INFO pDomainInfo;
               do
               {


                   pDomainInfo = XForestInfo.GetNextDomainInfo();
                   if (pDomainInfo != NULL)
                   {
                       pUseDomain = &_pTrustedDomains[ValidDomainCount];
                       pUseDomain->Initialize(_pLock );

                       if (pDomainInfo->UseBindDomain)
                       {
                           Status = pUseDomain->SetBindDomainName( &pDomainInfo->BindDomainName);
                       }

                       if (Status == ERROR_SUCCESS)
                       {
                           Status = pUseDomain->SetDomainName( &pDomainInfo->DomainName,
                                                               pDomainInfo->Netbios);
                       }

                       if (Status == ERROR_SUCCESS)
                       {
                           _DomainReferralLength += (pUseDomain->GetDomainName())->Length;
                       }
                       else 
                       {
                           break;
                       }
                       ValidDomainCount++;
                   }
               } while ( pDomainInfo != NULL );

           }

           if (Status == ERROR_SUCCESS)
           {
               _SkippedDomainCount = XForestInfo.GetSkippedDomainCount();
               DFS_TRACE_LOW(REFERRAL_SERVER, "DfsDomainInformation, with %d domains, (%d domains skipped)\n", 
                             ValidDomainCount,
                             _SkippedDomainCount);
           }
       }
   }

   *pStatus = Status;
   
   //
   // XForestInfo goes out of scope and is destroyed
   //
}


DFSSTATUS    
DfsDomainInformation::GenerateDomainReferral(
        REFERRAL_HEADER ** ppReferralHeader)
{
   DFSSTATUS Status = ERROR_SUCCESS;
   ULONG TotalSize = 0;
   ULONG NextEntry = 0;
   ULONG LastEntry = 0;
   ULONG CurrentEntryLength = 0;
   ULONG LastEntryLength = 0;
   ULONG BaseLength = 0;
   ULONG HeaderBaseLength = 0;
   ULONG CurrentNameLength =0;
   PUCHAR Buffer = NULL;
   PUCHAR pDomainBuffer = NULL;
   PWCHAR ReturnedName = NULL;
   PREFERRAL_HEADER pHeader = NULL;


   HeaderBaseLength = FIELD_OFFSET( REFERRAL_HEADER, LinkName[0] );
        
   //calculate size of base replica structure
   BaseLength = FIELD_OFFSET( REPLICA_INFORMATION, ReplicaName[0] );

   TotalSize = ROUND_UP_COUNT(HeaderBaseLength, ALIGN_LONG);

   for (ULONG Index = 0; Index < _DomainCount; Index++)
   {
       PUNICODE_STRING pDomainName = (&_pTrustedDomains[Index])->GetDomainName();
       TotalSize += ROUND_UP_COUNT(pDomainName->Length + BaseLength, ALIGN_LONG);
   }

   //allocate the buffer
   Buffer = new BYTE[TotalSize];
   if(Buffer == NULL)
   {
      Status = ERROR_NOT_ENOUGH_MEMORY;

      DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "DfsDomainInformation:GenerateDomainReferral allocation failure Status %d\n",
                           Status);
      return Status;
   }

   RtlZeroMemory( Buffer, TotalSize );
   //setup the header 

   pHeader = (PREFERRAL_HEADER) Buffer;
   pHeader->VersionNumber = CURRENT_DFS_REPLICA_HEADER_VERSION;
   pHeader->ReplicaCount = 0;
   pHeader->OffsetToReplicas = ROUND_UP_COUNT((HeaderBaseLength), ALIGN_LONG);
   pHeader->LinkNameLength = 0;
   pHeader->TotalSize = TotalSize;
   pHeader->ReferralFlags = DFS_REFERRAL_DATA_DOMAIN_REFERRAL;

   pDomainBuffer = Buffer + pHeader->OffsetToReplicas;

   for (ULONG Index = 0; Index < _DomainCount; Index++)
   {
       PUNICODE_STRING pDomainName = (&_pTrustedDomains[Index])->GetDomainName();
       if (pDomainName->Length == 0)
       {
           continue;
       }
       pHeader->ReplicaCount++;
       NextEntry += (ULONG)( CurrentEntryLength );

       ReturnedName = (PWCHAR) &pDomainBuffer[NextEntry + BaseLength];
       CurrentNameLength = 0;

#if 0
       //
       // Start with the leading path seperator
       //
       ReturnedName[ CurrentNameLength / sizeof(WCHAR) ] = UNICODE_PATH_SEP;
       CurrentNameLength += sizeof(UNICODE_PATH_SEP);
#endif
       //
       // next copy the server name.
       //
       RtlMoveMemory( &ReturnedName[ CurrentNameLength / sizeof(WCHAR) ],
                      pDomainName->Buffer, 
                      pDomainName->Length);
       CurrentNameLength += pDomainName->Length;
       ((PREPLICA_INFORMATION)&pDomainBuffer[NextEntry])->ReplicaFlags = 0;
       ((PREPLICA_INFORMATION)&pDomainBuffer[NextEntry])->ReplicaCost = 0;
       ((PREPLICA_INFORMATION)&pDomainBuffer[NextEntry])->ReplicaNameLength = CurrentNameLength;

       CurrentEntryLength = ROUND_UP_COUNT((CurrentNameLength + BaseLength), ALIGN_LONG);

       //setup the offset to the next entry
       *((PULONG)(&pDomainBuffer[NextEntry])) = pHeader->OffsetToReplicas + NextEntry + CurrentEntryLength;
   }

   *((PULONG)(&pDomainBuffer[NextEntry])) = 0;
   *ppReferralHeader = pHeader;

   return Status;
}

VOID
DfsDomainInformation::PurgeDCReferrals()
{
    ULONG Index;

    for (Index = 0; Index < _DomainCount; Index++)
    {
        DFSSTATUS DiscardStatus;

        DiscardStatus = _pTrustedDomains[Index].RemoveDcReferralData( NULL, NULL);
    }
    return NOTHING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsclustersupport.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsclustersupport.cxx
//
//  Contents:   DfsClusterSupport
//
//  Classes:
//
//-----------------------------------------------------------------------------



#include "DfsClusterSupport.hxx"

typedef struct _DFS_CLUSTER_CONTEXT {
    PUNICODE_STRING pShareName;
    PUNICODE_STRING pVSName ;
        
} DFS_CLUSTER_CONTEXT;

DWORD
ClusterCallBackFunction(
    HRESOURCE hSelf,
    HRESOURCE hResource,
    PVOID Context)
{

    UNREFERENCED_PARAMETER( hSelf );

    HKEY HKey = NULL;
    HKEY HParamKey = NULL;
    ULONG NameSize = MAX_PATH;
    WCHAR ClusterName[MAX_PATH];
    DFS_CLUSTER_CONTEXT *pContext = (DFS_CLUSTER_CONTEXT *)Context;
    LPWSTR ResShareName = NULL;
    UNICODE_STRING VsName;

    DWORD Status = ERROR_SUCCESS;
    DWORD TempStatus;
    DWORD Value = 0;

    HKey = GetClusterResourceKey(hResource, KEY_READ);

    if (HKey == NULL)
    {
        Status = GetLastError();
        return Status;
    }

    TempStatus = ClusterRegOpenKey( HKey, 
                                L"Parameters", 
                                KEY_READ, 
                                &HParamKey );
    ClusterRegCloseKey( HKey );

    //
    // Apparently there can be (small) window during which a resource may not
    // have the Parameters key set. In such a case, we should keep enumerating,
    // so don't return an error.
    //
    if (TempStatus != ERROR_SUCCESS)
    {
        return ERROR_SUCCESS;
    }

    // Find the logical share name to see if that's what we've been looking for.
    ResShareName = ResUtilGetSzValue( HParamKey,
                                      L"ShareName" );

    //
    // It is possible for a Share resource to be configured without the sharename parameter
    // set. In such a case this function shouldn't return an error; we need to keep enumerating.
    //
    if (ResShareName != NULL)
    {
        Status = DfsRtlInitUnicodeStringEx(&VsName, ResShareName);
        if(Status == ERROR_SUCCESS)
        {
            if (pContext->pShareName->Length == VsName.Length)
            {
                //
                // Look to see if this is a dfs root. It is legitimate to find
                // this property not set, so don't propagate the return status. We shouldn't terminate
                // our enumeration just because this property doesn't exist on this resource.
                //
                TempStatus = ResUtilGetDwordValue(HParamKey, L"IsDfsRoot", &Value, 0);

                if ((ERROR_SUCCESS == TempStatus)  &&
                    (Value == 1))
                {

                    if (_wcsnicmp(pContext->pShareName->Buffer,
                                 VsName.Buffer,
                                 VsName.Length) == 0)
                    {
                        //
                        // We've found what we wanted. Grab the virtual-cluster name
                        // and return that in a separately allocated string.
                        // We know for a fact that the dfs root name can't be
                        // longer than MAX_PATH. So we don't bother checking for 
                        // ERROR_MORE_DATA.
                        //
                        if ((GetClusterResourceNetworkName( hResource,
                                                            ClusterName,
                                                            &NameSize )) == TRUE)
                        {
                            ASSERT(pContext->pVSName->Buffer == NULL);
                            Status = DfsCreateUnicodeStringFromString( pContext->pVSName,
                                                                       ClusterName );
                            //
                            // Return ERROR_NO_MORE_ITEMS to ResUtilEnumResources so that
                            // the enumeration will get terminated, but the return status to
                            // GetRootClusterInformation will be SUCCESS.
                            //
                            if (Status == ERROR_SUCCESS)
                            {
                                Status = ERROR_NO_MORE_ITEMS;
                            }
                        }
                        else
                        {
                            // Return this error and terminate the enumeration.
                            Status = GetLastError();
                            ASSERT( Status != ERROR_MORE_DATA );
                        }
                    }
                }
            }
        }
        
        LocalFree( ResShareName );
    }

    ClusterRegCloseKey( HParamKey );

    return Status;
}
#if 0

DoNotUse()
{

    DWORD  Status      = ERROR_SUCCESS;
    DWORD  BufSize     = ClusDocEx_DEFAULT_CB;
    LPVOID pOutBuffer   = NULL;
    DWORD  ControlCode = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES;

    pOutBuffer = new BYTE [ BufSize ];

    if( pOutBuffer == NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = ClusterResourceControl( hResource,                                         // resource handle
                                           NULL,
                                           ControlCode,
                                           NULL,                                              // input buffer (not used)
                                           0,                                                 // input buffer size (not used)
                                           pOutBuffer,                                       // output buffer: property list
                                           OutBufferSize,                                   // allocated buffer size (bytes)
                                           pBytesReturned );     


    dwResult = ResUtilFindDwordProperty( lpPropList, 
                                         cbPropListSize, 
                                         lpszPropName, 
                                         lpdwPropValue );


    }
}
#endif

//
// Guarantees that the pVSName is allocated upon SUCCESS.
// Caller needs to free it with DfsFreeUnicodeString.
//
DWORD
GetRootClusterInformation(
    PUNICODE_STRING pShareName,
    PUNICODE_STRING pVSName )

{
    DWORD Status;
    DFS_CLUSTER_CONTEXT Context;
    
    (VOID)RtlInitUnicodeString( pVSName, NULL );
    Context.pShareName = pShareName;
    Context.pVSName = pVSName;

    Status = ResUtilEnumResources(NULL,
                                  L"File Share",
                                  ClusterCallBackFunction,
                                  (PVOID)&Context );

    //
    // ClusterCallbackFunction above returns ERROR_NO_MORE_ITEMS
    // to ResUtilEnumResources to terminate the enumeration. ResUtilEnumResources
    // converts that error code to SUCCESS. So, under the current behavior it isn't possible
    // for us to have allocated the VSName and still get an error. The following is a feeble
    // attempt to not be dependent on that unadvertised behavior.
    //
    if ((Status != ERROR_SUCCESS) && 
       (pVSName->Buffer != NULL))
    {
        // If we've allocated a VSName, we have succeeded.
        Status = ERROR_SUCCESS;
    }

/*
    // xxx Longhorn
    else if (Status == ERROR_SUCCESS && 
            pVSName->Buffer == NULL)
    {
        // Always return some error when the VSName isn't allocated.
        Status = ERROR_NOT_FOUND;
    }
*/   

    return Status;


}

DFSSTATUS
DfsClusterInit(
    PBOOLEAN pIsCluster )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DWORD ClusterState;

    *pIsCluster = FALSE;

    Status = GetNodeClusterState( NULL, // local node
                                  &ClusterState );

    if (Status == ERROR_SUCCESS)
    {
        if ( (ClusterStateRunning == ClusterState) ||
             (ClusterStateNotRunning == ClusterState) )
        {
            *pIsCluster = TRUE;

        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfserror.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsError.cxx
//
//  Contents:   Converts HRESULT to DFSSTATUS   
//
//  Classes:    none.
//
//  History:    April. 09 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include <ole2.h>
#include <activeds.h>
#include <dfsheader.h>
#include <dfsError.hxx>
      
 
/////////////////////////////////////////////
//
// Error message specific to ADSI 
//
////////////////////////////////////////////

DFSSTATUS
DfsGetADSIError( HRESULT hr )
{
	DFSSTATUS status = ERROR_SUCCESS;

	switch(hr)
	{
    case S_OK:
        status = ERROR_SUCCESS;
        break;

    case E_ADS_BAD_PATHNAME:
    case E_ADS_INVALID_DOMAIN_OBJECT:
    case E_ADS_INVALID_USER_OBJECT:
    case E_ADS_INVALID_COMPUTER_OBJECT:
        status = ERROR_BAD_NET_NAME;
        break;

    case E_ADS_UNKNOWN_OBJECT:
    case E_ADS_PROPERTY_INVALID:
    case E_ADS_BAD_PARAMETER:
    case E_ADS_PROPERTY_NOT_SET:
		status = ERROR_INVALID_PARAMETER;
		break;
		
	case E_NOTIMPL:
		status = ERROR_CALL_NOT_IMPLEMENTED;
		break;

    case E_NOINTERFACE:
    case E_ADS_PROPERTY_NOT_FOUND:
        status = ERROR_NOT_FOUND;
        break;

    case E_ADS_PROPERTY_NOT_SUPPORTED:
        status = ERROR_NOT_SUPPORTED;
        break;
		
    case E_POINTER:
        status = ERROR_INVALID_HANDLE;
        break;

    case E_ADS_SCHEMA_VIOLATION:
        status = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case E_ABORT:
        status = ERROR_OPERATION_ABORTED;
        break;

    case E_FAIL:
    case E_UNEXPECTED:
	default:
		status = ERROR_BAD_COMMAND;
        //ASSERT(FALSE);
		break;
	}
	return status;
}


DFSSTATUS 
DfsGetErrorFromHr( HRESULT hr )
{
    DFSSTATUS Status = ERROR_SUCCESS;
  
    if(hr == S_OK)
    {
        Status = ERROR_SUCCESS;
    }
    else if ( (ULONG)hr & 0x00005000) // standard ADSI Errors 
    {
        Status = DfsGetADSIError(hr);
    }
    else if ( HRESULT_FACILITY(hr)==FACILITY_WIN32 )
    {
        Status = hr & 0x0000FFFF;
    }
    else 
    {
        Status = ERROR_BAD_COMMAND;
    }
 
     return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfseventlog.cxx ===
/*++

   Copyright    (c)    2001        Microsoft Corporation

   Module Name:
        Dfseventlog.cxx

   Abstract:

        This module defines APIs for logging events.


   Author:

        Rohan Phillips    (Rohanp)    31-March-2001


--*/
              
              

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dfsheader.h>

#include "dfsinit.hxx"

HANDLE 
DfsOpenEventLog(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE EventLogHandle = NULL;

    EventLogHandle = RegisterEventSource( NULL, L"DfsSvc");

    if (EventLogHandle == NULL ) 
    {
        Status = GetLastError();
    }

    return EventLogHandle;

} 


DFSSTATUS 
DfsCloseEventLog(HANDLE EventLogHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOL fSuccess = TRUE;


    if ( EventLogHandle != NULL) 
    {
        fSuccess = DeregisterEventSource(EventLogHandle);

        if ( !fSuccess) 
         {
           Status = GetLastError();
         }

    }

    return Status;
}



DFSSTATUS 
DfsLogEventEx(IN DWORD idMessage,
              IN WORD wEventType,
              IN WORD cSubstrings,
              IN LPCTSTR *rgszSubstrings,
              IN DWORD errCode)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE EventLogHandle = NULL;
    void *pRawData = NULL;
    DWORD cbRawData = 0;

    if (DfsPostEventLog() == FALSE) 
    {
        return Status;
    }

    //
    // Also include errCode in raw data form
    // where people can view it from EventViewer
    // 
    if (errCode != 0) {
        cbRawData = sizeof(errCode);
        pRawData = &errCode;
    }


    EventLogHandle = DfsOpenEventLog();
    if(EventLogHandle != NULL)
    {
        //
        // log the event
        //
        if (!ReportEvent(EventLogHandle,
                         wEventType,
                         0,
                         idMessage,
                         NULL,
                         cSubstrings,
                         cbRawData,
                         rgszSubstrings,
                         pRawData))
        {
            Status = GetLastError();
        }


        DfsCloseEventLog(EventLogHandle);
    }


    return Status;
} 


DFSSTATUS 
DFsLogEvent(IN DWORD  idMessage,
            IN const TCHAR * ErrorString,
            IN DWORD  ErrCode)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    WORD wEventType = 0;                
    const TCHAR * apszSubStrings[2];
   
    apszSubStrings[0] = ErrorString;    

    if ( NT_INFORMATION( idMessage)) 
    {
        wEventType = EVENTLOG_INFORMATION_TYPE;
    } 
    else if ( NT_WARNING( idMessage)) 
    {
        wEventType = EVENTLOG_WARNING_TYPE;
    } 
    else 
    {
        wEventType = EVENTLOG_ERROR_TYPE;
    }


    Status = DfsLogEventEx(idMessage,
                           wEventType,
                           1,
                           apszSubStrings,
                           ErrCode);
    return Status;

}

//usage:
//  const TCHAR * apszSubStrings[4];
//  apszSubStrings[0] = L"Root1";
//  DfsLogDfsEvent(DFS_ERROR_ROOT_DELETION_FAILURE,
//  1,
//  apszSubStrings,
//  errorcode);
//
//
DFSSTATUS 
DfsLogDfsEvent(IN DWORD  idMessage,
               IN WORD   cSubStrings,
               IN const TCHAR * apszSubStrings[],
               IN DWORD  ErrCode)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    WORD wEventType = 0;                
   
    if ( NT_INFORMATION( idMessage)) 
    {
        wEventType = EVENTLOG_INFORMATION_TYPE;
    } 
    else if ( NT_WARNING( idMessage)) 
    {
        wEventType = EVENTLOG_WARNING_TYPE;
    } 
    else 
    {
        wEventType = EVENTLOG_ERROR_TYPE;
    }


    Status = DfsLogEventEx(idMessage,
                           wEventType,
                           cSubStrings,
                           apszSubStrings,
                           ErrCode);
    return Status;

} 

void 
DfsLogEventSimple(DWORD MessageId, DWORD ErrorCode=0)
{
    DfsLogDfsEvent(MessageId, 0, NULL, ErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfslogmacros.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsLogMacros.cxx
//
//  Contents:   This file contains the functionality to generate WMI Logging Macros
//
//
//  History:    Marc 12 2001,   Authors: RohanP
//
//-----------------------------------------------------------------------------
       
#include <windows.h>
#include "dfswmi.h"
#include "dfsLogMacros.hxx"
#include "dfsLogMacros.tmh"

PVOID pReferralControl = NULL;

void SetReferralControl(WPP_CB_TYPE * Control)
{
    pReferralControl = (PVOID)Control;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsistgsupport.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <ntsam.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <string.h>
#include <tchar.h>
#include <stdarg.h>
#include <process.h>

#include <ole2.h>
#include <ntdsapi.h>
#include <DfsISTGSupport.hxx>
#include <DfsInit.hxx>

#define NTDSAPI_INTEGRATED

#if defined(NTDSAPI_INTEGRATED)

#define _DsBindToISTG(a,b) DsBindToISTG(a,b)
#define _DsUnBind(a) DsUnBind(a)
#define _DsBindingSetTimeout(a,b) DsBindingSetTimeout(a,b)
#else
#define _DsBindToISTG(a,b) STUB_DsBindToISTG(a,b)
#define _DsUnBind(a) STUB_DsUnBind(a)
#define _DsBindingSetTimeout(a,b) NOTHING
#endif

DWORD
STUB_DsBindToISTG( LPWSTR Site, HANDLE *pDs )
{
    *pDs = (HANDLE)101; // bogus
    return ERROR_SUCCESS;
    
    UNREFERENCED_PARAMETER(Site);
}

DWORD
STUB_DsUnBind( HANDLE *pDs )
{
    *pDs = (HANDLE)99; // bogus
    return ERROR_SUCCESS;
}    

// return a referenced global handle
DFSSTATUS
DfsISTGHandleSupport::Acquire( 
    DfsISTGHandle **ppHdl )
{
    DFSSTATUS Status = ERROR_NOT_FOUND;
    
    //
    // Return a referenced ISTG handle.
    // This count is actually good indicator of
    // how much the DS APIs are stressed
    // at a given point in time.
    //
    EnterCriticalSection( &_HandleLock );
    if ((_GlobalHandle != NULL) && (_GlobalHandle->IsInitialized))
    {
        _GlobalHandle->AcquireReference();
        *ppHdl = _GlobalHandle;
        Status = ERROR_SUCCESS;
    }
    LeaveCriticalSection( &_HandleLock );

    return Status;
}

//
// One time call.
// 
DFSSTATUS
DfsISTGHandleSupport::Initialize( VOID )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOL LockCreated = FALSE;

    do {
        LockCreated = InitializeCriticalSectionAndSpinCount( &_HandleLock, DFS_CRIT_SPIN_COUNT );
        if (!LockCreated)
        {
            Status = GetLastError();
            break;
        }

        //
        // The logic is similar to reinitialization.
        // However, we ignore the status because we dont want the server-initialize to
        // fail because it couldn't bind to an ISTG. We have to handle the possibility of
        // not being able to bind to an ISTG anyway.

        // We don't actually do the ReBind at this point because we don't want this ISTG
        // handle to exist at all when site costing is turned off (by default). ReBind will be
        // done on-demand.
        //(VOID)ReBind();
        
    } while (FALSE);


    //
    // Error path
    //
    if (Status != ERROR_SUCCESS)
    {
        if (LockCreated)
        {
            DeleteCriticalSection( &_HandleLock );
            LockCreated = FALSE;
        }

        ASSERT(_GlobalHandle == NULL);
    }

    return Status;
}

//
// Get a new handle to the ISTG and
// initialize the global handle accordingly.
//
DFSSTATUS
DfsISTGHandleSupport::ReBind( VOID )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsISTGHandle *TempHandle = NULL;
    DfsISTGHandle *OldHandle = NULL;

    //
    // If it isn't time to retry, let's not.
    //
    if (_LastRetryTime != 0 &&
       !IsTimeToRetry())
    {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Replace the global handle with a new one.
    //
    do {
        //
        // Create a temporary handle first.
        //
        TempHandle = new DfsISTGHandle;
        if (TempHandle == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Status = TempHandle->Bind();
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
        _NumberOfBinds++;
        
        //
        // Now atomically swap the two handles.
        // Let's not close the old handle while 
        // we are holding the handle-lock.
        // It is of course entirely possible for somebody
        // else to race with us. Only one will win.
        //
        EnterCriticalSection( &_HandleLock );
        OldHandle = _GlobalHandle;
        _GlobalHandle = TempHandle;
        LeaveCriticalSection( &_HandleLock );

        if (OldHandle != NULL)
        {
            OldHandle->ReleaseReference();   
        }
        
        _CreationTime = GetTickCount();
        _LastRetryTime = 0;
    } while (FALSE);

    // Error path
    if (Status != ERROR_SUCCESS)
    {
        _LastRetryTime = GetTickCount();
        if (TempHandle != NULL)
        {
            TempHandle->ReleaseReference();
        }

        // We don't get rid of the existing handle
        // just because we failed to get a new one.
    }        

    return Status;
}


//
// Static one time call to create the global 
// handle support class instance.
//
DFSSTATUS 
DfsISTGHandleSupport::DfsCreateISTGHandleSupport( 
    DfsISTGHandleSupport **ppSup )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsISTGHandleSupport *pSup = NULL;

    *ppSup = NULL;
    
    do {
        pSup = new DfsISTGHandleSupport;
        if (pSup == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        // Bind to ISTG to get a new handle.
        Status = pSup->Initialize();
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        *ppSup = pSup;
        
    } while (FALSE);

    // Error path
    if (Status != ERROR_SUCCESS)
    {
        if (pSup != NULL) 
        {
            delete pSup;
            pSup = NULL;
        }
    }
    
    return Status;
}


DfsISTGHandle::~DfsISTGHandle( VOID )
{
    if (IsInitialized == TRUE)
    {
        // Close our handle to the ISTG
        _DsUnBind( &DsHandle );
    }
}

DFSSTATUS
DfsISTGHandle::Bind( VOID )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if (!IsInitialized)
    {
        Status = _DsBindToISTG( NULL, &DsHandle ); 
        if (Status == ERROR_SUCCESS)
        {
            IsInitialized = TRUE;
            
            //
            // Set the time out. There's no need to fail the call
            // because of an error here. xxxdfsdev: DFSLOG this.
            // 
            _DsBindingSetTimeout( DsHandle, DsTimeOut );
        }
    }
    return Status;
}

//
// Return a referenced handle or NULL.
//
DfsISTGHandle * 
DfsAcquireISTGHandle( VOID )
{   
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsISTGHandle *pHdl = NULL;

    if (DfsServerGlobalData.pISTGHandleSupport != NULL)
    {
        Status = DfsServerGlobalData.pISTGHandleSupport->Acquire( &pHdl );
    }
    return pHdl;
}

//
// Release an ISTG handle acquired using the above DfsAcquireISTGHandle.
//
VOID
DfsReleaseISTGHandle( 
    DfsISTGHandle *pHdl )
{
    if (DfsServerGlobalData.pISTGHandleSupport != NULL)
    {
        DfsServerGlobalData.pISTGHandleSupport->Release( pHdl );
    }
}

DFSSTATUS
DfsReBindISTGHandle( VOID )
{
    DFSSTATUS Status = ERROR_NOT_FOUND;
    
    if (DfsServerGlobalData.pISTGHandleSupport != NULL)
    {
        Status = DfsServerGlobalData.pISTGHandleSupport->ReBind();
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsmigrate.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsMigrate.cxx
//
//  Contents:   Contains the routines to migrate existing DFS root 
//              information in the registry to a different location,
//              to allow multiple roots per server.
//
//  Classes:    none.
//
//  History:    Feb. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

//
// dfsdev: need to add code to delete, on failure, any intermediate stuff 
// we create during migration
//

#include "DfsGeneric.hxx"
#include "DfsInit.hxx"
#include "shlwapi.h"
#include "DfsStore.hxx"
DFSSTATUS
MigrateFTDfs( 
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare );

DFSSTATUS
MigrateStdDfs(
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare,
    BOOLEAN fDoCleanup);


//+----------------------------------------------------------------------------
//
//  Function:   MigrateDfs
//
//  Arguments:  MachineName - Name of the machine to target. 
//                            Can be NULL for local machine.
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//  Description: This routine contacts the specified machine, and checks
//               if the registry information indicates the machine is
//               hosting a standalone or domain DFS. It moves this 
//               information appropriately under the new StandaloneRoot
//               or DomainRoots key, so that we can have multiple roots
//               on the machine.
//
//-----------------------------------------------------------------------------

DFSSTATUS
MigrateDfs(
    LPWSTR MachineName )
{
    LPWSTR DfsRootShare = NULL;
    LPWSTR FtDfsValue = NULL;

    ULONG DataSize = 0;
    ULONG DataType = 0;
    ULONG RootShareLength = 0;
    ULONG FtDfsValueSize;
    DWORD Status;

    HKEY OldKey;

    PRINTF("Migrate DFS Called. This will migrate the DFS on %wS\n",
           (MachineName != NULL) ? MachineName : L"this machine");

    Status = DfsStore::GetOldDfsRegistryKey( MachineName,
                                             TRUE,
                                             NULL,
                                             &OldKey );

    //
    // If we opened the DFS hierarchy key properly, get the maximum
    // size of any of the values under this key. This is so that we
    // know how much memory to allocate, so that we can read any of
    // the values we desire.
    // 
    //
    if ( Status == ERROR_SUCCESS ) {
        Status = RegQueryInfoKey( OldKey,       // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  NULL );       // Last write time

        //
        // We want to read the value of the DfsRootShare. If the value
        // is still a string, this is indeed an old style DFS and needs
        // to be migrated. If the value is something else, this is
        // already a migrated machine, so do nothing.
        //

        if (Status == ERROR_SUCCESS) {
            //
            // Space for null terminator
            //
            DataSize += sizeof(WCHAR);
            
            RootShareLength = DataSize;
            DfsRootShare = (LPWSTR) new BYTE[DataSize];
            if (DfsRootShare == NULL) {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                Status = RegQueryValueEx( OldKey,
                                          DfsRootShareValueName,
                                          NULL,
                                          &DataType,
                                          (LPBYTE)DfsRootShare,
                                          &RootShareLength);
            }
        }
        //
        // check if the value is a string.
        //
        if ((Status == ERROR_SUCCESS) &&
            (DataType == REG_SZ)) {

            DWORD Migrated;
            ULONG MigrateSize;

            MigrateSize = sizeof(Migrated);
            Status = RegQueryValueEx( OldKey,
                                      DfsMigratedValueName,
                                      NULL,
                                      &DataType,
                                      (PBYTE)&Migrated,
                                      &MigrateSize);

            if (Status == ERROR_FILE_NOT_FOUND)
            {

                FtDfsValueSize = DataSize;
                FtDfsValue = (LPWSTR) new BYTE[DataSize];
                if (FtDfsValue == NULL) {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
                else {
                    //
                    // Now check if this is a Domain Based root.
                    //
                    Status = RegQueryValueEx( OldKey,
                                              DfsFtDfsValueName,
                                              NULL,
                                              &DataType,
                                              (LPBYTE)FtDfsValue,
                                              &FtDfsValueSize);
            
                    //
                    // At this point we do know we have a machine that
                    // needs to be migrated. If the machine was hosting
                    // a standalone root, call MigrateFTDfs to take care
                    // of the domain based dfs root migration. Else, this
                    // is a standalone root, so call the standalone root
                    // migration routine.
                    //
                    if (Status == ERROR_SUCCESS) {
                        Status = MigrateFTDfs( MachineName,
                                               OldKey,
                                               FtDfsValue,
                                               DfsRootShare );
                    }
                    else {
                        Status = MigrateStdDfs( MachineName,
                                                OldKey,
                                                DfsRootShare,
                                                DfsRootShare,
                                                FALSE );
                    }

                    if (Status == ERROR_SUCCESS)
                    {
                        DWORD DfsMigrated = 1;
                        //
                        // ignore error returns here...
                        //
                        RegSetValueEx( OldKey,
                                       DfsMigratedValueName,
                                       0,
                                       REG_DWORD,
                                       (PBYTE)&DfsMigrated,
                                       sizeof(DfsMigrated));
                    }
                }
            } else {
                //
                // Already Migrated
                // dfsutil from creating an old fashioned root.
                //
                Status = ERROR_SUCCESS;
            }
        }else {
            //
            // there is no root here: do whatever is necessary to block
            // dfsutil from creating an old fashioned root.
            //
            Status = ERROR_SUCCESS;

        }

        //
        // We are done, close the key we opened.
        //
        RegCloseKey( OldKey );
    }


    //
    // dfsdev: if we fail, we need to cleanup any of the work we have
    // done so far!
    //
    //
    // release any of the resources we had allocated, since we are 
    // about to return back to the caller.
    //
    if ( DfsRootShare != NULL ) {
        delete [] DfsRootShare;
    }

    if ( FtDfsValue != NULL ) {
        delete [] FtDfsValue;
    }

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   MigratefFTDfs
//
//  Arguments:  
//    HKEY DfsKey -  The open key to the top of DFS registry hierarchy
//    LPWSTR DfsLogicalShare - the logical domain based share.
//    LPWSTR DfsRootShare - the share on this machine backing the name
//    LPWSTR FtDfsDN  - The distinguished name in the AD for the DFS.
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//  Description: This routine moves the domain based DFS root information
//               in the registry under a new key, so that we can support
//               multiple roots per machine.
//
//-----------------------------------------------------------------------------

DFSSTATUS
MigrateFTDfs( 
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare )
{
    DWORD Status;
    HKEY NewBlobKey;
    //
    // We open the ft parent, which holds all the ft roots.
    //
    DFSLOG("Migrating FT Dfs\n");

    Status = DfsStore::GetNewADBlobRegistryKey( MachineName,
                                                TRUE,
                                                NULL,
                                                &NewBlobKey );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsStore::SetupADBlobRootKeyInformation( NewBlobKey,
                                                          DfsLogicalShare,
                                                          DfsRootShare );

        RegCloseKey( NewBlobKey );
    }


    //
    // dfsdev: if we fail, we need to cleanup any of the work we have
    // done so far!
    //


    if (Status == ERROR_SUCCESS) {
        RegDeleteValue( DfsKey,
                        DfsFtDfsConfigDNValueName);
        RegDeleteValue( DfsKey,
                        DfsFtDfsValueName );
    }

    DFSLOG("Migrating FT Dfs: Status %x\n", Status);
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   MigratefStdDfs
//
//  Arguments:  
//    HKEY DfsKey -  The open key to the top of DFS registry hierarchy
//    LPWSTR DfsLogicalShare - the logical dfs share.
//    LPWSTR DfsRootShare - the share on this machine backing the name
//
//  Returns:    ERROR_SUCCESS 
//              Error code other wise.
//
//  Description: This routine moves the registry based DFS root information
//               in the registry under a new key, so that we can support
//               multiple roots per machine.
//
//-----------------------------------------------------------------------------

DFSSTATUS
MigrateStdDfs(
    LPWSTR MachineName,
    HKEY DfsKey,
    LPWSTR DfsLogicalShare,
    LPWSTR DfsRootShare,
    BOOLEAN fDoCleanup)
{
    DWORD Status = ERROR_SUCCESS;
    HKEY StdDfsKey = NULL;
    HKEY StdDfsShareKey = NULL;
    ULONG RootShareValue = 1;
    size_t LogicalShareCchLength = 0;
    size_t PhysicalShareCchLength = 0;
    
    DFSLOG("Migrating Std Dfs\n");
    //
    // Open the new standalone DFS parent, which holds all the
    // standalone roots and their metadata as its children.
    //
    Status = DfsStore::GetNewStandaloneRegistryKey( MachineName,
                                                    TRUE,
                                                    NULL,
                                                    &StdDfsKey );

    //
    // We now create an unique metadata name for our root, and add
    // it as a child to the parent key we created.
    //
    if (Status == ERROR_SUCCESS) {

        Status = RegCreateKeyEx( StdDfsKey,
                                 DfsLogicalShare,
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &StdDfsShareKey,
                                 NULL );
        //
        // We have successfully created the child root. Now, just copy
        // all the link information under the old root key to the new
        // root key. If we successfully copy, we can delete the old
        // standalone root and all its children.
        //
        if (Status == ERROR_SUCCESS) {
                
            Status = SHCopyKey( DfsKey,
                                DfsOldStandaloneChild,
                                StdDfsShareKey,
                                NULL );
            if (Status == ERROR_SUCCESS) 
            {
                if(fDoCleanup)
                {
                    Status = SHDeleteKey( DfsKey,
                                          DfsOldStandaloneChild );
                }
            }
            
            //
            // Now setup the values for the new root so that we know
            // the shares that are backing this new root.
            //
            if (Status == ERROR_SUCCESS) {
                
                Status = DfsStringCchLength( DfsRootShare, 
                                          MAXUSHORT, 
                                          &PhysicalShareCchLength );

                if (Status == ERROR_SUCCESS)
                {
                    // Allow an extra character for NULL terminator.
                    PhysicalShareCchLength++;
                    
                    Status = RegSetValueEx( StdDfsShareKey,
                                        DfsRootShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)DfsRootShare,
                                        PhysicalShareCchLength * sizeof(WCHAR) );
                }
            }

            if (Status == ERROR_SUCCESS) {
                
                Status = DfsStringCchLength( DfsRootShare, 
                                          MAXUSHORT, 
                                          &LogicalShareCchLength );

                if (Status == ERROR_SUCCESS)
                {
                    // Allow an extra character for NULL terminator.
                    LogicalShareCchLength++;
                    Status = RegSetValueEx( StdDfsShareKey,
                                        DfsLogicalShareValueName,
                                        0,
                                        REG_SZ,
                                        (PBYTE)DfsLogicalShare,
                                        LogicalShareCchLength * sizeof(WCHAR) );
                }
            }


            RegCloseKey( StdDfsShareKey );
        }

        RegCloseKey( StdDfsKey );
    }

    DFSLOG("Migrating Std Dfs: Status %x\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsFolder.cxx
//
//  Contents:   implements the base DFS Folder class
//
//  Classes:    DfsFolder.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsFolder.hxx"
#include "DfsFolderReferralData.hxx"
#include "DfsInit.hxx"

//
// logging specific includes
//

#include "DfsFolder.tmh" 


//+-------------------------------------------------------------------------
//
//  Function:   GetReferralData - get the referral data
//
//  Arguments:  ppReferralData - the referral data for this folder
//              pCacheHit - did we find it already loaded?
//
//  Returns:    Status
//               ERROR_SUCCESS if we could get the referral data
//               error status otherwise.
//
//
//  Description: This routine returns a reference DfsFolderReferralDAta
//               for the folder. If one does not already exist in this
//               folder, we create a new one. If someone is in the process
//               of loading the referral, we wait on the event in 
//               the referral data which gets signalled when the thread
//               responsible for loading is done with the load.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsFolder::GetReferralData(
    OUT DfsFolderReferralData **ppReferralData,
    OUT BOOLEAN   *pCacheHit,
    IN BOOLEAN AddToLoadedList )
{
    DfsFolderReferralData *pRefData;
    DFSSTATUS Status = STATUS_SUCCESS;
    
    *pCacheHit = FALSE;

    Status = AcquireWriteLock();
    if ( Status != STATUS_SUCCESS )
    {
        return Status;
    }

    // First see if we may need to do a reload.
    if (_LoadState == DfsFolderLoadFailed && 
       IsTimeToRetry())
    {
        ASSERT(_pReferralData == NULL);
        _LoadState = DfsFolderNotLoaded;
        DFS_TRACE_HIGH(REFERRAL_SERVER, "Retrying failed folder load for %wZ (%wZ)\n",
                   GetFolderMetadataName(),
                   GetFolderLogicalName());
    }    
    
    //
    // WE take difference action depending on the load state.
    //
    switch ( _LoadState )
    {
    case DfsFolderLoaded:

        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: Cache hit\n");
        //
        // we are dealing with a loaded folder. Just acquire a reference
        // and return the loaded referral data.
        //
        ASSERT (_pReferralData != NULL);

        pRefData = _pReferralData;

        pRefData->Timeout = _Timeout;
        pRefData->AcquireReference();
        
        ReleaseLock();
        
        *pCacheHit = TRUE;        
        *ppReferralData = pRefData;

        break;

    case DfsFolderNotLoaded:

        //
        // The folder is not loaded. Make sure that the referral data is
        // indeed empty. Create a new instance of the referral data
        // and set the state to load in progress.
        // The create reference of the folder referral data is inherited
        // by the folder. (we are holding a reference to the referral
        // data in _pReferralData). This reference is released when
        // we RemoveReferralData at a later point.
        //
        ASSERT(_pReferralData == NULL);
        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: not loaded\n");

        _pReferralData = new DfsFolderReferralData( &Status,
                                                    this );
        if ( _pReferralData != NULL )
        {
            if(Status == ERROR_SUCCESS)
            {
                _LoadState = DfsFolderLoadInProgress;

                if (IsFolderRoot() == TRUE)
                {
                    _pReferralData->SetRootReferral();
                }

                if (IsFolderInSiteReferrals() ||
                   ((_pParent != NULL) && (_pParent->IsFolderInSiteReferrals()))) 
                {
                    _pReferralData->SetInSite();
                }

                //
                // Site costing is inherited from the parent.
                //
                if (IsFolderSiteCostingEnabled() ||
                   ((_pParent != NULL) && (_pParent->IsFolderSiteCostingEnabled())))
                {
                    _pReferralData->SetSiteCosting();
                }
                
                if (IsFolderOutOfDomain()) 
                {
                    _pReferralData->SetOutOfDomain();
                }

                _pReferralData->Timeout = _Timeout;

                pRefData = _pReferralData;

            }
            else
            {
                _pReferralData->ReleaseReference();
                _pReferralData = NULL;
            }
        } else
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // We no longer need the lock. We have allocate the referral
        // data and marked the state accordingly. No other thread can
        // interfere with our load now.
        //
        ReleaseLock();

        //
        // Now we load the referral data, and save the status of the
        // load in both our load status as well as the load status
        // in the referral data.
        // If the load was successful, we add this to the loaded list
        // of referral data that can be scavenged later. We set the load
        // state to loaded, and signal the event so that all waiting
        // threads can now be woken up.
        //

        if ( Status == ERROR_SUCCESS )
        {
            DFS_TRACE_NORM(REFERRAL_SERVER, " Load called on link %wZ (%wZ)\n",
                   GetFolderMetadataName(),
                   GetFolderLogicalName());

            //
            // We depend on _pReferralData being non-null although
            // we aren't holding the folder lock still.
            //
            _pReferralData->FolderOffLine = IsFolderOffline();
            Status = LoadReferralData( _pReferralData);

            if(IsFolderOffline())
            {
                DFS_TRACE_NORM(REFERRAL_SERVER, "Link %wZ (%wZ) is OFFLINE\n",
                       GetFolderMetadataName(),
                       GetFolderLogicalName());
            }

            _LoadStatus = Status;
            _pReferralData->LoadStatus = Status;


            if ( Status == ERROR_SUCCESS )
            {
                //
                // Acquire a reference on the new referral data, since we 
                // have to return a referenced referral data to the caller.
                // Get the reference here before we add it to the loaded list,
                // otherwise we could end up with the referral data
                // being freed up.
                //

                pRefData->AcquireReference();

                _LoadState = DfsFolderLoaded;
                _RetryFailedLoadTimeout = 0;
                
                if (AddToLoadedList == TRUE) 
                {
                    DfsAddReferralDataToLoadedList( _pReferralData );
                }
                *ppReferralData = pRefData;
                pRefData->Signal();
            } 
            else
            {
                DFSSTATUS RemoveStatus;

                _LoadState = DfsFolderLoadFailed;

                // We'll try reloading this at some other time
                _RetryFailedLoadTimeout = GetTickCount();
                pRefData->Signal();
                RemoveStatus = RemoveReferralData(pRefData, NULL);

                DFS_TRACE_ERROR_HIGH(_LoadStatus, REFERRAL_SERVER, 
                                    "Replica load failed for %wZ (%wZ), load status %x\n",
                                     GetFolderMetadataName(),
                                     GetFolderLogicalName(), 
                                     _LoadStatus);
                
            }
        }

        break;

    case DfsFolderLoadInProgress:

        //
        // The load is in progress. We acquire a reference on the
        // referral data being loaded and wait for the event in the
        // referral data to be signalled. The return status of the wait
        // indicates if we can return the referral data or we fail
        // this request with an error.
        //
        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: load in progress\n");
        ASSERT(_pReferralData != NULL);
        pRefData = _pReferralData;
        pRefData->AcquireReference();

        ReleaseLock();

        DFSLOG("Thread: Waiting fod ..r referral load\n");

        Status = pRefData->Wait();

        if ( Status == ERROR_SUCCESS )
        {
            *ppReferralData = pRefData;
        } else
        {
            pRefData->ReleaseReference();
        }
        DFS_TRACE_NORM(REFERRAL_SERVER, " Get Referral Data: load in progress done\n");
        break;

    case DfsFolderLoadFailed:
        //
        // The Load failed. REturn error. We've already setup a time
        // after which we'll reattempt the load.
        //
        ASSERT(_pReferralData == NULL);
        Status = _LoadStatus;
        ReleaseLock();
        *ppReferralData = NULL;
        break;

    default:
        //
        // We should never get here. Its an invalid state.
        //
        ASSERT(TRUE);
        Status = ERROR_INVALID_STATE;
        ReleaseLock();

        break;
    }

    ASSERT((Status != ERROR_SUCCESS) || (*ppReferralData != NULL));

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   RemoveReferralData - remove the referral data from folder
//
//  Arguments:  NONE
//
//  Returns:    Status
//               ERROR_SUCCESS if we could remove  the referral data
//               error status otherwise.
//
//
//  Description: This routine removes the cached reference to the loaded
//               referral data in the folder, and releases its reference
//               on it.
//               This causes all future GetREferralDAta to be loaded
//               back from the store.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsFolder::RemoveReferralData( 
    DfsFolderReferralData *pRemoveReferralData,
    PBOOLEAN pRemoved )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolderReferralData *pRefData = NULL;
    
    //
    // Get tnhe exclusive lock on the folder
    //
    if (pRemoved != NULL)
    {
        *pRemoved = FALSE;
    }

    AcquireWriteLock();
    
    if ( (pRemoveReferralData == NULL) || 
         (pRemoveReferralData == _pReferralData) )
    {   
        //
        // BUG 773319 : There's a race between the worker thread
        // trying to sync and purge referral data in UpdateLinkFolder
        // and referrals trying to load referral data in GetReferralData.  
        // GetReferralData drops the folder-lock with the understanding that
        // others will honor the DfsFolderLoadInProgress flag.
        //   
        if (_LoadState == DfsFolderLoadInProgress)
        {
            pRefData = _pReferralData;
            ASSERT(pRefData != NULL);
            pRefData->AcquireReference();
            ReleaseLock();

            DFS_TRACE_NORM(REFERRAL_SERVER, 
                "ReplicaData load in progress for Link %wZ (%wZ). Waiting\n",
                       GetFolderMetadataName(),
                       GetFolderLogicalName());
            //
            // We wait here because we don't want to lose our race to the thread
            // that did LoadReferralData. The sync-thread would've already created
            // folders based on what was in cache at one point. What's about to
            // get loaded may be inconsistent with respect to the linkfolder data.
            //
            (VOID)pRefData->Wait();
 
            // Release the reference we took above.
            pRefData->ReleaseReference(); 
            pRefData = NULL;
            
            AcquireWriteLock();
            
        };
        
        //
        // There are only two states that LoadInProgress transition to: Loaded and LoadFailed.
        // If we are in any other state then we are done because some other thread must have
        // beaten us to it.
        //
        // Also, don't change the LoadFailed status here. There's a separate timer ticking on
        // on that transition.
        //
        if (_LoadState == DfsFolderLoaded || _LoadState == DfsFolderLoadFailed)
        {
            // Don't take another reference here. We want to deref its original reference
            // to get rid of it (see below).
            pRefData = _pReferralData;
            _pReferralData = NULL;
            _LoadState = (_LoadState == DfsFolderLoaded) ? 
                            DfsFolderNotLoaded : DfsFolderLoadFailed;
        }
    }

    ReleaseLock();
    
    //
    // Release reference on the referral data. This is the reference
    // we had taken when we had cached the referral data in this folder.
    //
    if (pRefData != NULL)
    {
        if (pRefData->GetOwningFolder() != NULL)
        {
            DFS_TRACE_LOW(REFERRAL, "Purged cached referral for Logical Name %ws, Link %ws\n",
                pRefData->GetOwningFolder()->GetFolderLogicalNameString(), 
                pRefData->GetOwningFolder()->GetFolderMetadataNameString());
        }
        pRefData->ReleaseReference();
        if (pRemoved != NULL)
        {
            *pRemoved = TRUE;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsinit.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsInit.cxx
//
//  Contents:   Contains initialization of server
//
//  Classes:    none.
//
//  History:    Dec. 8 2000,   Author: udayh
//              Jan. 12 2001,  Rohanp - Added retrieval of replica data
//
//-----------------------------------------------------------------------------

#include "DfsRegStrings.hxx"
#include "DfsRegistryStore.hxx"
#include "DfsADBlobStore.hxx"
#include "DfsFolderReferralData.hxx"
#include "DfsInit.hxx"
#include "DfsServerSiteInfo.hxx"
#include "DfsSiteSupport.hxx"
#include "dfsfilterapi.hxx"
#include "DfsClusterSupport.hxx"
#include "DomainControllerSupport.hxx"
#include "DfsDomainInformation.hxx"
#include "dfsadsiapi.hxx"
#include "DfsSynchronizeRoots.hxx"
#include "DfsSiteCache.hxx"
#include "DfsSiteNameSupport.hxx"
#include "DfsISTGSupport.hxx"
#include "DfsReparse.hxx"

#include "dfsinit.tmh"
#include <dsrole.h>
#include "dfscompat.hxx"
#include "dfssecurity.h"

#include "ntlsa.h"
//
// DFS_REGISTER_STORE: A convenience define to be able to register a
// number of differnet store types.
//
#define DFS_REGISTER_STORE(_name, _sts)                          \
{                                                                \
    DFSSTATUS LocalStatus = ERROR_SUCCESS;                       \
    DfsServerGlobalData.pDfs ## _name ## Store = new Dfs ## _name ## Store(&LocalStatus); \
                                                                 \
    if (DfsServerGlobalData.pDfs ## _name ## Store == NULL) {    \
        (_sts) = ERROR_NOT_ENOUGH_MEMORY;                        \
    }                                                            \
    else if (LocalStatus == ERROR_SUCCESS){                                                       \
        DfsServerGlobalData.pDfs ## _name ## Store->pNextRegisteredStore = DfsServerGlobalData.pRegisteredStores; \
        DfsServerGlobalData.pRegisteredStores = DfsServerGlobalData.pDfs ## _name ## Store;        \
        (_sts) = ERROR_SUCCESS;                                  \
    }                                                            \
    else                                                         \
    {                                                            \
       (_sts) = LocalStatus;                                     \
    }                                                            \
}

//
// INITIALIZE_COMPUTER_INFO: A convenience define to initialize the
// different information about the computer (netbios, dns, domain etc)
//

#define INITIALIZE_COMPUTER_INFO( _NamedInfo, _pBuffer, _Sz, _Sts ) \
{                                                                   \
    ULONG NumChars = _Sz;                                           \
    if (_Sts == ERROR_SUCCESS) {                                    \
        DWORD dwRet = GetComputerNameEx( _NamedInfo,_pBuffer,&NumChars ); \
        if (dwRet == 0) _Sts = GetLastError();                      \
    }                                                               \
    if (_Sts == ERROR_SUCCESS) {                                    \
        LPWSTR NewName = new WCHAR [ NumChars + 1 ];                \
        if (NewName == NULL) _Sts = ERROR_NOT_ENOUGH_MEMORY;        \
        else wcscpy( NewName, _pBuffer );                           \
        DfsServerGlobalData.DfsMachineInfo.Static ## _NamedInfo ## = NewName;\
    }                                                               \
}                 


//
// The DfsServerGlobalData: the data structure that holds the registered
// stores and the registered names, among others.
//
DFS_SERVER_GLOBAL_DATA DfsServerGlobalData;

//
// Varios strings that represent the names in registry where some of
// DFS information is stored.
//
LPWSTR DfsSvcPath = DFS_REG_SVC_PATH;
LPWSTR DfsDnsConfigValue = DFS_REG_DNS_CONFIG_VALUE;

LPWSTR DfsParamPath = DFS_REG_PARAM_PATH;

LPWSTR DfsRegistryHostLocation = DFS_REG_HOST_LOCATION;
LPWSTR DfsOldRegistryLocation = DFS_REG_OLD_HOST_LOCATION;
LPWSTR DfsVolumesLocation = DFS_REG_VOLUMES_LOCATION;
LPWSTR DfsOldStandaloneChild = DFS_REG_OLD_STANDALONE_CHILD;



LPWSTR DfsRegistryDfsLocation = DFS_REG_DFS_LOCATION;
LPWSTR DfsNewRegistryLocation = DFS_REG_NEW_DFS_LOCATION;
LPWSTR DfsRootLocation = DFS_REG_ROOT_LOCATION;
LPWSTR DfsStandaloneChild = DFS_REG_STANDALONE_CHILD;
LPWSTR DfsADBlobChild = DFS_REG_AD_BLOB_CHILD;




LPWSTR DfsRootShareValueName = DFS_REG_ROOT_SHARE_VALUE;
LPWSTR DfsMigratedValueName = DFS_REG_MIGRATED_VALUE;

LPWSTR DfsLogicalShareValueName = DFS_REG_LOGICAL_SHARE_VALUE;
LPWSTR DfsFtDfsValueName = DFS_REG_FT_DFS_VALUE;
LPWSTR DfsFtDfsConfigDNValueName = DFS_REG_FT_DFS_CONFIG_DN_VALUE;
LPWSTR DfsWorkerThreadIntervalName = DFS_SYNC_INTERVAL_NAME;

LPWSTR DfsSiteSupportRefreshIntervalName = DFS_REG_SITE_SUPPORT_REFRESH_INTERVAL_NAME;

LPWSTR DfsSiteIpCacheTrimValueName = DFS_REG_SITE_IP_CACHE_TRIM_VALUE;

LPWSTR DfsAllowableErrorsValueName = DFS_REG_ALLOWABLE_ERRORS_VALUE;

LPWSTR DfsLdapTimeoutValueName = DFS_REG_LDAP_TIMEOUT_VALUE;
LPWSTR DfsSiteCostedReferralsValueName = DFS_REG_SITE_COSTED_REFERRALS_VALUE;
LPWSTR DfsInsiteReferralsValueName = DFS_REG_INSITE_REFERRALS_VALUE;

LPWSTR DfsMaxClientSiteValueName = DFS_REG_MAXSITE_VALUE;
LPWSTR DfsQuerySiteCostTimeoutName = DFS_REG_QUERY_SITECOST_TIMEOUT_NAME;

LPWSTR DfsDomainNameRefreshInterval = DFS_REG_DOMAIN_NAME_REFRESH_INTERVAL_NAME;

static SECURITY_DESCRIPTOR AdminSecurityDesc;

static GENERIC_MAPPING AdminGenericMapping = {

        STANDARD_RIGHTS_READ,                    // Generic read

        STANDARD_RIGHTS_WRITE,                   // Generic write

        STANDARD_RIGHTS_EXECUTE,                 // Generic execute

        STANDARD_RIGHTS_READ |                   // Generic all
        STANDARD_RIGHTS_WRITE |
        STANDARD_RIGHTS_EXECUTE
};


DFSSTATUS
DfsRegisterStores( VOID );

DFSSTATUS
DfsRecognize( LPWSTR Name );

DFSSTATUS
DfsRegisterName(LPWSTR Name);

DWORD
DfsWorkerThread(LPVOID TData);


DFSSTATUS
DfsCreateRequiredDfsKeys(void);


BOOLEAN 
DfsGetGlobalRegistrySettings(void);


BOOLEAN
DfsGetStaticGlobalRegistrySettings(void);

BOOLEAN
DfsInitializeSecurity();

DWORD
DfsSiteSupportThread(LPVOID TData);

VOID
StartPreloadingServerSiteData(void);


DFSSTATUS
DfsSetupPrivileges (void);


extern
DFSSTATUS
DfsGetRootReferralDataEx(
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolderReferralData **ppReferralData,
    PBOOLEAN pCacheHit);

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRegistryStore 
//
//  Arguments:  ppRegStore -  the registered registry store.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine searches through the registered stores, and
//  picks the one that is the registry store. This is required for
//  specific API requests that target the Registry based DFS 
//  For example: add standalone root, etc
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetRegistryStore(
    DfsRegistryStore **ppRegStore )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    *ppRegStore = DfsServerGlobalData.pDfsRegistryStore;

    if (*ppRegStore != NULL)
    {
        (*ppRegStore)->AcquireReference();
    }
    else
    {
        Status = ERROR_NOT_SUPPORTED;
    }


    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetADBlobStore 
//
//  Arguments:  ppRegStore -  the registered ADBlob store.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine searches through the registered stores, and
//  picks the one that is the registry store. This is required for
//  specific API requests that target the ADBlob based DFS 
//  For example: add  root, etc
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetADBlobStore(
    DfsADBlobStore **ppStore )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    *ppStore = DfsServerGlobalData.pDfsADBlobStore;

    if (*ppStore != NULL)
    {
        (*ppStore)->AcquireReference();
    }
    else
    {
        Status = ERROR_NOT_SUPPORTED;
    }


    return Status;
}




BOOL
IsStandardServerSKU(
    PBOOL pIsServer
    )
{
    BOOL  fReturnValue = (BOOL) FALSE;
    OSVERSIONINFOEX  VersionInfo;
    BOOL  IsServer = FALSE;

     //
     // get the current SKU.
     //
     VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
     if (GetVersionEx((OSVERSIONINFO *)&VersionInfo)) 
     {
         fReturnValue = TRUE;

         //
         // is it some sort of server SKU?
         //
         if (VersionInfo.wProductType != VER_NT_WORKSTATION) 
         {

             //
             // standard server or a server variant?
             //
             if ((VersionInfo.wSuiteMask & (VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER)) == 0)
             {
                 //
                 // it's standard server
                 //
                 IsServer = TRUE;
             }
         }

         *pIsServer = IsServer;

     }

     return(fReturnValue);


}

//+-------------------------------------------------------------------------
//
//  Function:   DfsServerInitialize
//
//  Arguments:  Flags - the server flags
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine initializes the DFS server. It registers
//               all the different stores we care about, and also
//               starts up a thread that is responsible for keeping the
//               DFS info upto date.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsServerInitialize(
    ULONG Flags ) 
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN fSecurity = FALSE;
    BOOL fCritInit = FALSE;
    BOOL fIsStandardServer = TRUE;
    WSADATA   wsadata;
    
    ZeroMemory(&DfsServerGlobalData, sizeof(DfsServerGlobalData));
    DfsServerGlobalData.pRegisteredStores = NULL;
    DfsServerGlobalData.Flags = Flags;
    DfsServerGlobalData.bDfsAdAlive = TRUE;
    DfsServerGlobalData.bIsShuttingDown = FALSE;
    DfsServerGlobalData.ServiceState = SERVICE_START_PENDING;
    

    IsStandardServerSKU(&fIsStandardServer);

    if(fIsStandardServer)
    {
        DfsServerGlobalData.bLimitRoots = TRUE;
    }

    DfsSetupPrivileges ();

    Status = WSAStartup( MAKEWORD( 1, 1 ), &wsadata );
    if(Status != 0)
    {
        DfsLogDfsEvent(DFS_ERROR_WINSOCKINIT_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!] WSAStartup failed status %x\n", Status);
        goto Exit;
    }

    fSecurity = DfsInitializeSecurity();
    if(fSecurity == FALSE)
    {
        Status = GetLastError();
        DfsLogDfsEvent(DFS_ERROR_SECURITYINIT_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsInitializeSecurity failed status %x\n", Status);
        goto Exit;
    }

    InitializeListHead(&DfsServerGlobalData.ReparseVolumeList);
    InitializeListHead(&DfsServerGlobalData.SiteCostTableMruList);
    
    DfsServerGlobalData.NumSiteCostTables = 0;

    // The following are statistics we keep around, primarily for diagnostic purposes.
    // There might be a better place for these. xxxdfsdev
    DfsServerGlobalData.NumDfsSites = 0;
    DfsServerGlobalData.NumClientDfsSiteEntries = 0;
    DfsServerGlobalData.NumServerDfsSiteEntries = 0;
    DfsServerGlobalData.NumDfsSitesInCache = 0; // not the same as NumDfsSites because of refcounts
    DfsServerGlobalData.NumSiteCostTablesOnMruList = 0;
    
    //
    // Create and initialize the cache that maps incoming IP addresses to their corresponding
    // DfsSites.
    //
    DfsServerGlobalData.pClientSiteSupport = DfsSiteNameCache::CreateSiteHashTable(&Status);
    if(DfsServerGlobalData.pClientSiteSupport == NULL)
    {
        DfsLogDfsEvent(DFS_ERROR_SITECACHEINIT_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsSiteNameCache::CreateSiteHashTable failed status %x\n", Status);
        goto Exit;
    }

    //
    // Create and initialize the repository of known DfsSites indexed by their site names.
    //
    DfsServerGlobalData.pSiteNameSupport = DfsSiteNameSupport::CreateSiteNameSupport( &Status );
    if(DfsServerGlobalData.pSiteNameSupport == NULL)
    {
        DfsLogDfsEvent(DFS_ERROR_SITECACHEINIT_FAILED, 0, NULL, Status); // dfsdev: insert unique error code.
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsSiteNameSupport::CreateSiteNameSupport failed status %x\n", Status);
        goto Exit;
    }  

    //
    // Create a default DfsSite with a NULL sitename that we will always keep around..
    //
    DfsServerGlobalData.pDefaultSite = DfsSite::CreateDfsSite( &Status );
    if(DfsServerGlobalData.pDefaultSite == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        DfsLogDfsEvent(DFS_ERROR_SITECACHEINIT_FAILED, 0, NULL, Status); // dfsdev: insert unique error code.
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Default DFS site creation failed with status %x\n", 
                            Status);
        goto Exit;
    }  

    fCritInit = InitializeCriticalSectionAndSpinCount( &DfsServerGlobalData.DataLock, DFS_CRIT_SPIN_COUNT );
    if(!fCritInit)
    {
        Status = GetLastError();
        goto Exit;
    }

    DfsServerGlobalData.ShutdownHandle = CreateEvent( NULL,
                                    TRUE,
                                    FALSE,
                                    NULL );
    if(DfsServerGlobalData.ShutdownHandle == NULL)
    {
        Status = GetLastError();
        DfsLogDfsEvent(DFS_ERROR_CREATEEVENT_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]CreateEvent failed status %x\n", Status);
        goto Exit;
    }


    DfsServerGlobalData.RegNotificationHandle = CreateEvent( NULL, FALSE, FALSE, NULL );

    if(DfsServerGlobalData.RegNotificationHandle == NULL)
    {
        Status = GetLastError();
        DfsLogDfsEvent(DFS_ERROR_CREATEEVENT_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]CreateEvent2 failed status %x\n", Status);
        goto Exit;
    }
    //
    // Initialize the prefix table library.
    //
    DfsPrefixTableInit();


    Status = DfsCreateRequiredDfsKeys();

    //
    // Create a site support class that lets us look up the server-site
    // information of servers that configured in our metadata.
    //
    DfsServerGlobalData.pServerSiteSupport = DfsSiteSupport::DfsCreateSiteSupport(&Status);
    if(DfsServerGlobalData.pServerSiteSupport == NULL)
    {
        DfsLogDfsEvent(DFS_ERROR_SITESUPPOR_FAILED, 0, NULL, Status); 
        goto Exit;
    }


    DfsServerGlobalData.CacheFlushInterval = CACHE_FLUSH_INTERVAL;



    DfsGetStaticGlobalRegistrySettings();
    DfsGetGlobalRegistrySettings();

    Status = DfsRootSynchronizeInit();
    if(Status != ERROR_SUCCESS)
    {
        DfsLogDfsEvent(DFS_ERROR_ROOTSYNCINIT_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Initialize root synchronization status %x\n", Status);
        goto Exit;
    }
    
    //
    // Now initialize the computer info, so that this server knows
    // the netbios name, domain name and dns name of this machine.
    //
    Status = DfsInitializeComputerInfo();
    if(Status != ERROR_SUCCESS)
    {
       DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Initialize computer info status %x\n", Status);
       DfsLogDfsEvent(DFS_ERROR_COMPUTERINFO_FAILED, 0, NULL, Status); 
       goto Exit;
    }

    Status = DfsClusterInit( &DfsServerGlobalData.IsCluster );
    if (Status != ERROR_SUCCESS)
    {
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Dfs Cluster Init Status %x IsCluster %d\n", 
                             Status, DfsServerGlobalData.IsCluster);
        DfsLogDfsEvent(DFS_ERROR_CLUSTERINFO_FAILED, 0, NULL, Status); 
        goto Exit;
    }

    Status = DfsDcInit( &DfsServerGlobalData.IsDc);
    if (Status != ERROR_SUCCESS)
    {
        DfsLogDfsEvent(DFS_ERROR_DCINFO_FAILED, 0, NULL, Status); 
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Dfs DC Init Status %x, IsDC %d\n", 
                             Status, DfsServerGlobalData.IsDc);
        goto Exit;
    }

    // 
    // We always create the ISTGHandleSupport instance, but the actual Bind call to the Ds won't
    // happen until we need it. This is because at this point we just don't know if any of the roots
    // has site-costing enabled or not.
    //
    Status = DfsISTGHandleSupport::DfsCreateISTGHandleSupport( &DfsServerGlobalData.pISTGHandleSupport ); 
    if (Status != ERROR_SUCCESS)
    {
        DfsLogDfsEvent(DFS_ERROR_DCINFO_FAILED, 0, NULL, Status); // xxx dfsdev: add new error
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Dfs ISTGHandle creation Status %x\n", 
                              Status);
        goto Exit;
    }
    
    Status = DfsInitializePrefixTable( &DfsServerGlobalData.pDirectoryPrefixTable,
                                       FALSE, 
                                       NULL );
    if ( Status != ERROR_SUCCESS )
    {
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Initialize directory prefix table Status %x\n", Status);
        DfsLogDfsEvent(DFS_ERROR_PREFIXTABLE_FAILED, 0, NULL, Status); 
        goto Exit;
    }

    DfsServerGlobalData.pRootReferralTable = NULL;
    if (DfsServerGlobalData.IsDc == TRUE) 
    {
        Status = DfsInitializePrefixTable( &DfsServerGlobalData.pRootReferralTable,
                                           FALSE, 
                                           NULL );
        if ( Status != ERROR_SUCCESS )
        {
            DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Initialize Root Referral table Status %x\n", Status);
            DfsLogDfsEvent(DFS_ERROR_PREFIXTABLE_FAILED, 0, NULL, Status); 
            return Status;
        }
    }


    //
    // If the flags indicate that we are handling all known local 
    // namespace on this machine, add an empty string to the handled
    // namespace list.
    //


    if (Flags & DFS_LOCAL_NAMESPACE)    
    {
        Status = DfsAddHandledNamespace(L"", TRUE);

        if (Status != ERROR_SUCCESS) 
        {
           DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsAddHandledNamespace Status %x\n", Status);
           DfsLogDfsEvent(DFS_ERROR_HANDLENAMESPACE_FAILED, 0, NULL, Status); 
           goto Exit;
        }
    }

    //
    // Now register all the stores.
    //

    Status = DfsRegisterStores();
    if (Status != ERROR_SUCCESS) 
    {
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsRegisterStores Status %x\n", Status);
        DfsLogDfsEvent(DFS_ERROR_REGISTERSTORE_FAILED, 0, NULL, Status); 
        goto Exit;
    }


    //
    // Create our sitesupport thread.
    //
    DWORD Tid;
        
    DfsServerGlobalData.SiteSupportThreadHandle = CreateThread (
                     NULL,
                     0,
                     DfsSiteSupportThread,
                     0,
                     CREATE_SUSPENDED,
                     &Tid);
        
    if (DfsServerGlobalData.SiteSupportThreadHandle != NULL) 
    {
       DFS_TRACE_HIGH(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Created DfsSiteSupportThread (%d) Tid\n", Tid);
    }
    else 
    {
       Status = GetLastError();
       DFS_TRACE_HIGH(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Failed DfsSiteSupportThread creation, Status %x\n", Status);
       DfsLogDfsEvent(DFS_ERROR_THREADINIT_FAILED, 0, NULL, Status); 
       goto Exit;
    }

    //
    // Create our scavenge thread.
    //
    HANDLE THandle;
        
    THandle = CreateThread (
                     NULL,
                     0,
                     DfsWorkerThread,
                     0,
                     0,
                     &Tid);
        
    if (THandle != NULL) 
    {
       CloseHandle(THandle);
       DFS_TRACE_HIGH(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Created Scavenge Thread (%d) Tid\n", Tid);
    }
    else 
    {
       Status = GetLastError();
       DFS_TRACE_HIGH(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Failed Scavenge Thread creation, Status %x\n", Status);
       CloseHandle(DfsServerGlobalData.SiteSupportThreadHandle);
       DfsServerGlobalData.SiteSupportThreadHandle = NULL;
       goto Exit;
    }

    Status = DfsInitializeReflectionEngine();
    if(Status != ERROR_SUCCESS)
    {
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Initialize Reflection Engine, Status %x\n", Status);
        DfsLogDfsEvent(DFS_ERROR_REFLECTIONENGINE_FAILED, 0, NULL, Status); 
        goto Exit;
    }


Exit:

    if(Status != ERROR_SUCCESS)
    {
        DfsServerGlobalData.ServiceState = SERVICE_STOPPED;
    }

    return Status;
}

DFSSTATUS
DfsServerStop(
    ULONG Flags ) 
{
   UNREFERENCED_PARAMETER(Flags);

   DFSSTATUS Status = ERROR_SUCCESS;


   DfsServerGlobalData.bIsShuttingDown = TRUE;
   if(DfsServerGlobalData.ServiceState == SERVICE_RUNNING)
   {
       DfsServerGlobalData.ServiceState = SERVICE_STOP_PENDING;

       if(DfsServerGlobalData.ShutdownHandle)
       {
           SetEvent(DfsServerGlobalData.ShutdownHandle);
       }

       Status = DfsTerminateReflectionEngine();

       if(DfsServerGlobalData.ShutdownHandle)
       {
           CloseHandle(DfsServerGlobalData.ShutdownHandle);
           DfsServerGlobalData.ShutdownHandle = NULL;
       }

       DfsServerGlobalData.ServiceState = SERVICE_STOPPED;
   }

   return Status;


}


//+-------------------------------------------------------------------------
//
//  Function:   DfsServerLibraryInitialize
//
//  Arguments:  Flags - the server flags
//             DfsName - server name
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This performs a trimmed down DfsServerInitialize
//             for clients who want to bypass the server and access
//             the domain dfs information directly.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsServerLibraryInitialize(
    ULONG Flags )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOL fCritInit = FALSE;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    
    ZeroMemory(&DfsServerGlobalData, sizeof(DfsServerGlobalData));
    DfsServerGlobalData.pRegisteredStores = NULL;
    DfsServerGlobalData.Flags = Flags;
    DfsServerGlobalData.bIsShuttingDown = FALSE;
        
    fCritInit = InitializeCriticalSectionAndSpinCount( &DfsServerGlobalData.DataLock, DFS_CRIT_SPIN_COUNT);
    if(!fCritInit)
    {
        Status = GetLastError();
    }

    //
    // Now register all the stores. This essentially constructs the respective
    // store class objects.
    //
    if (Status == ERROR_SUCCESS) {
        Status = DfsRegisterStores();

        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsRegisterStores Status %x\n", Status);
    }
    DfsServerGlobalData.LdapTimeOut = DFS_LDAP_TIMEOUT;
    
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsRegisterStores
//
//  Arguments:  NONE
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine registers the different stores 
//               that the referral library implements.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegisterStores(
    VOID )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if(!DfsIsMachineWorkstation())
    {
        if (Status == ERROR_SUCCESS) 
            DFS_REGISTER_STORE(ADBlob, Status);
    }


    if (Status == ERROR_SUCCESS) 
        DFS_REGISTER_STORE(Registry, Status);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAddHandleNamespace
//
//  Arguments:  Name - namespace to add
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine registers the namespace, so that we handle
//               referrals to that namespace. We also migrate the DFS data
//               in the registry for the multiple root support. This 
//               happens only if the client wants to migrate DFS.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsAddHandledNamespace(
    LPWSTR Name,
    BOOLEAN Migrate )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR NewName = NULL;
    
    //
    // allocate a new name, and copy the passed in string.
    //
    NewName = new WCHAR[wcslen(Name) + 1];
    if (NewName == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS) {
        wcscpy( NewName, Name );


        //
        // always migrate the dfs to the new location.
        //
        if (Migrate == TRUE)
        {
            extern DFSSTATUS MigrateDfs(LPWSTR MachineName);

            Status = MigrateDfs(NewName);
        }

        //
        // Now register the passed in name.
        //
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsRegisterName( NewName );

            //
            // 565500, delete allocation on errors.
            //
            if (Status != ERROR_SUCCESS)
            {
                delete [] NewName;                
            }
            if (Status == ERROR_DUP_NAME)
            {
                Status = ERROR_SUCCESS;
            }
        }
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsRegisterName
//
//  Arguments:  Name - name to register
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR_DUP_NAME if name is already registered.
//               ERROR status code otherwise
//
//
//  Description: This routine registers the namespace, if it is not already
//               registered.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegisterName( 
    LPWSTR Name )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG i = 0;
                                                                 
    if (DfsServerGlobalData.NumberOfNamespaces > MAX_DFS_NAMESPACES) 
    { 
        Status = ERROR_INVALID_PARAMETER;
    }
    else 
    {
        for (i = 0; i < DfsServerGlobalData.NumberOfNamespaces; i++) 
        {
            if (_wcsicmp( Name,
                          DfsServerGlobalData.HandledNamespace[i] ) == 0)
            {
                Status = ERROR_DUP_NAME;
                break;
            }
        }
        if (Status == ERROR_SUCCESS)
        {
            DfsServerGlobalData.HandledNamespace[DfsServerGlobalData.NumberOfNamespaces++] = Name;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsHandleNamespaces()
//
//  Arguments:  None
//
//  Returns:    None
//
//  Description: This routine runs through all the registered names, and
//               call the recognize method on each name.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsHandleNamespaces()
{
    ULONG i = 0;
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS RetStatus = ERROR_SUCCESS;
    
    for (i = 0; i < DfsServerGlobalData.NumberOfNamespaces; i++) {
        DFSLOG("Calling recognize on %wS\n", 
               DfsServerGlobalData.HandledNamespace[ i ] );
        
        Status = DfsRecognize( DfsServerGlobalData.HandledNamespace[ i ] );

        //
        // xxx This error isn't the original error; it's typically
        // something like ERROR_NOT_READY currently. We need to change that
        // in the future.
        //
        if (Status != ERROR_SUCCESS)
        {
            RetStatus = Status;
        }
        
        if (DfsIsShuttingDown())
        {
            break;
        }
    }

    // If we got an error at any point, return that.
    return RetStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsRecognize
//
//  Arguments:  Namespace
//
//  Returns:    None
//
//  Description: This routine passes the name to each registered store
//               by calling the StoreRecognize method. The store will
//               decide whether any roots exist on namespace, and add
//               the discovered roots to a list maintained by the store.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRecognize( 
    LPWSTR Name) 
{
    DfsStore *pStore = NULL;
    LPWSTR UseName = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS RetStatus = ERROR_SUCCESS;
    
    //
    // If the string is empty, we are dealing with the local case.
    // Pass a null pointer, since the underlying routines expect a
    // a valid machine, or a null pointer to represent the local case.
    //
    if (IsEmptyString(Name) == FALSE)
    {
        UseName = Name;
    }

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        DFSLOG("Calling StoreRecognizer on %wS for store %p\n", 
               Name, pStore );

        Status = pStore->StoreRecognizer( UseName );

        //
        // If any of the roots failed to load, typically because 
        // the DC was unavailable, then we need to make a note of
        // that and retry later. 
        //
        if (Status != ERROR_SUCCESS)
        {
            RetStatus = Status;
        }
        
        if (DfsIsShuttingDown())
        {
            break;
        }
    }

    return RetStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsRecognize
//
//  Arguments:  Namespace
//              LogicalShare
//
//  Returns:    SUCCESS if we managed to create a root folder, ERROR otherwise.
//
//  Description: This routine passes the name to each registered store
//               by calling the StoreRecognize method. The store will
//               decide whether the given root exist on that namespace, and adds
//               the discovered root to a list maintained by the store.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRecognize( 
    LPWSTR Name,
    PUNICODE_STRING pLogicalShare)
{
    DfsStore *pStore = NULL;
    DFSSTATUS Status = ERROR_NOT_FOUND;
    
    if (IsEmptyString(Name) || IsEmptyString(pLogicalShare->Buffer))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    // Call the store recognizer of each registered store.
    //

    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        DFSLOG("Calling StoreRecognizer (remote) on %wS for store %p\n", 
               Name, pStore );

        Status = pStore->StoreRecognizer( Name, pLogicalShare );

        //
        //  A store has successfully recognized a root for this <name,share>.
        //  We are done.
        //
        if (Status == ERROR_SUCCESS)
            break;
    }
         
    DFS_TRACE_LOW(REFERRAL_SERVER, "StoreRecognizer (remote) Status %x\n", Status);
    return Status;
}

VOID
DfsSynchronize()
{
    DfsStore *pStore = NULL;

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        DFSLOG("Calling StoreSynchronizer for store %p\n", pStore );

        pStore->StoreSynchronizer();

        if (DfsIsShuttingDown())
        {
            break;
        }

    }

    return NOTHING;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsDumpStatistics
//
//  Arguments:  NONE
//
//  Returns:    None
//
//--------------------------------------------------------------------------

VOID
DfsDumpStatistics( )
{
    DfsStore *pStore = NULL;

    //
    // Call the store recognizer of each registered store.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        pStore->DumpStatistics();

        if (DfsIsShuttingDown())
        {
            break;
        }
    }

    return NOTHING;
}




void 
DfsinitializeWorkerThreadInfo(void)
{
    //
    // Iterate through all the stores and 'recognize' their roots.
    //
    DfsHandleNamespaces();

    DfsLogDfsEvent(DFS_INFO_FINISH_BUILDING_NAMESPACE, 0, NULL, 0);

    StartPreloadingServerSiteData();

    DfsServerGlobalData.IsStartupProcessingDone = TRUE;

    DfsLogDfsEvent(DFS_INFO_FINISH_INIT, 0, NULL, 0);

    ResumeThread(DfsServerGlobalData.SiteSupportThreadHandle);

    CloseHandle(DfsServerGlobalData.SiteSupportThreadHandle);

    DfsServerGlobalData.SiteSupportThreadHandle = NULL;

    DfsServerGlobalData.ServiceState = SERVICE_RUNNING;

}


void 
DfsProcessAgedReferrelList(void)
{
    DfsFolderReferralData *pRefData = NULL;
    DfsFolderReferralData *pRefList = NULL;

    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread handling all namespaces\n");
    DfsHandleNamespaces();
    DFS_TRACE_LOW(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread done syncing\n");

    DfsDumpStatistics();
    //
    // now run through the loaded list and pick up aged referrals.
    // and unload them.
    //
    DfsGetAgedReferralList( &pRefList );

    while (pRefList != NULL) 
    {
        DfsFolder *pFolder;

        pRefData = pRefList;

        if (pRefData->pNextLoaded == pRefData) 
        {
            pRefList = NULL;
        }
        else
        {
            pRefList = pRefData->pNextLoaded;
            pRefData->pNextLoaded->pPrevLoaded = pRefData->pPrevLoaded;
            pRefData->pPrevLoaded->pNextLoaded = pRefData->pNextLoaded;
        }

        pFolder = pRefData->GetOwningFolder();
        if (pFolder != NULL) 
        {
            pFolder->RemoveReferralData( pRefData );
        }
        pRefData->ReleaseReference();

    } // while
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsWorkedThread
//
//  Arguments:  TData
//
//  Returns:    DWORD
//
//  Description: This is the scavenge thread. It sits in a loop forever,
//               waking up periodically to remove the aged referral data 
//               that had been cached during referral requests. 
//               Periodically, we call HAndleNamespaces so that the
//               namespace we know of is kept in sync with the actual
//               data in the respective metadata stores.
//
//--------------------------------------------------------------------------


DWORD ScavengeTime;
#define DFS_NAMESPACE_RETRY_STARTING_INTERVAL (15 * 1000);
#define DFS_NAMESPACE_MAX_RETRIES 5

DWORD
DfsWorkerThread(LPVOID TData)
{
    DfsFolderReferralData *pRefData = NULL, *pRefList = NULL;
    HRESULT hr = S_OK;
    SYSTEMTIME StartupSystemTime;
    FILETIME ReparseScavengeTime;
    BOOLEAN DoReparseScavenge = TRUE;
    DFSSTATUS RecognizeStatus = ERROR_SUCCESS;
    DWORD RetryScavengeTimeLeft = 0;
    ULONG InitialRetry = DFS_NAMESPACE_MAX_RETRIES;
    
    static LoopCnt = 0;
    
    ScavengeTime = DFS_NAMESPACE_RETRY_STARTING_INTERVAL; // 15 seconds

    UNREFERENCED_PARAMETER(TData);

    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED| COINIT_DISABLE_OLE1DDE);

    //
    // As long as reparse points are created after this time stamp, we are fine.
    //
    GetSystemTime( &StartupSystemTime );

    if (!SystemTimeToFileTime( &StartupSystemTime, &ReparseScavengeTime ))
    {
        DoReparseScavenge = FALSE;
    }
        
    //
    // Iterate through all the stores and 'recognize' their roots.
    // If any of them failed to load we retry a set number of times below.
    //
    RecognizeStatus = DfsHandleNamespaces();
        
    DfsLogDfsEvent(DFS_INFO_FINISH_BUILDING_NAMESPACE, 0, NULL, 0);

    StartPreloadingServerSiteData();

    DfsServerGlobalData.IsStartupProcessingDone = TRUE;

    DfsLogDfsEvent(DFS_INFO_FINISH_INIT, 0, NULL, 0);

    ResumeThread(DfsServerGlobalData.SiteSupportThreadHandle);

    CloseHandle(DfsServerGlobalData.SiteSupportThreadHandle);

    DfsServerGlobalData.SiteSupportThreadHandle = NULL;

    DfsServerGlobalData.ServiceState = SERVICE_RUNNING;

    // Retry failed namespaces.
    while ( (RecognizeStatus != ERROR_SUCCESS) &&
            (InitialRetry-- > 0) ) 
    {
        WaitForSingleObject(DfsServerGlobalData.ShutdownHandle, ScavengeTime);

        if (DfsIsShuttingDown())
        {
            goto Exit;
        }

        DFS_TRACE_HIGH( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread retrying failed namespaces after %d secs\n",
                        ScavengeTime/1000);
        
        RecognizeStatus = DfsHandleNamespaces();
        DFS_TRACE_HIGH(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread done retrying, Status 0x%x\n", RecognizeStatus);

        ScavengeTime *= 2;
    }

    // Revert to the 'normal' sleep time (~1hr)
    ScavengeTime = SCAVENGE_TIME;
    
    while (TRUE) {

        DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread sleeping for %d\n", ScavengeTime);
        WaitForSingleObject(DfsServerGlobalData.ShutdownHandle, ScavengeTime);

        if (DfsIsShuttingDown())
        {
            goto Exit;
        }


        LoopCnt++;

        // DfsDev: need to define a better mechanism as to how often
        // this gets to run.
        //
        DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread handling all namespaces\n");
        RecognizeStatus = DfsHandleNamespaces();
        DFS_TRACE_LOW(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Worker thread done syncing, status 0x%x\n", RecognizeStatus);

        DfsDumpStatistics();

        //
        // now run through the loaded list and pick up aged referrals.
        // and unload them.
        //
        DfsGetAgedReferralList( &pRefList );

        while (pRefList != NULL) 
        {
            DfsFolder *pFolder;

            pRefData = pRefList;

            if (pRefData->pNextLoaded == pRefData) 
            {
                pRefList = NULL;
            }
            else
            {
                pRefList = pRefData->pNextLoaded;
                pRefData->pNextLoaded->pPrevLoaded = pRefData->pPrevLoaded;
                pRefData->pPrevLoaded->pNextLoaded = pRefData->pNextLoaded;
            }

            pFolder = pRefData->GetOwningFolder();
            if (pFolder != NULL) 
            {
                pFolder->RemoveReferralData( pRefData );
            }
            pRefData->ReleaseReference();

        } // while

        //
        // If we haven't cleaned up orphaned reparse points, do that now.
        // Note that this doesn't run until SCAVEGE_TIME seconds after
        // the service has started.
        //
        if (DoReparseScavenge)
        {
            // We have no choice but to ignore errors
            (VOID)DfsRemoveOrphanedReparsePoints( ReparseScavengeTime );
            
            // This gets to run only once, irrespective of any errors.
            DoReparseScavenge = FALSE;
        }      
                
    }

Exit:

    CoUninitialize();
    return 0;
}


DWORD
DfsSiteSupportThread(LPVOID TData)
{
    DWORD   dw = 0;

    UNREFERENCED_PARAMETER(TData);

    while (TRUE)
    {
        DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]DfsSiteSupportThread sleeping for %d\n", 
                        DfsServerGlobalData.SiteSupportThreadInterval);

        dw = WaitForSingleObject(DfsServerGlobalData.ShutdownHandle, 
                                 DfsServerGlobalData.SiteSupportThreadInterval);
        
        if(WAIT_TIMEOUT == dw)
        {
            DfsServerGlobalData.pSiteNameSupport->InvalidateAgedSites();
            DfsServerGlobalData.pClientSiteSupport->RefreshSiteData();
            StartPreloadingServerSiteData();
        }

        if (DfsIsShuttingDown())
        {
            break;
        }
    }

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAddReferralDataToloadedList
//
//  Arguments:  pRefData
//
//  Returns:    Nothing
//
//  Description: Given the referral data that was laoded, we add it
//               to a loaded list, first acquiring a reference to 
//               it. This is effectively to keep track of the cached
//               referral data in the folders.
//
//               To scavenge the cache, we maintain this list, and we run
//               through this list periodically freeing up aged data.
//
//--------------------------------------------------------------------------
VOID
DfsAddReferralDataToLoadedList(
    DfsFolderReferralData *pRefData )
{
    //
    // we are going to save a pointer to the referral data. 
    // Acquire a reference on it
    //
    pRefData->AcquireReference();
    
    //
    // Now get a lock on the list, and add the ref data to the list
    //

    ACQUIRE_LOADED_LIST_LOCK();
    if (DfsServerGlobalData.LoadedList == NULL) {
        DfsServerGlobalData.LoadedList = pRefData;
        pRefData->pPrevLoaded = pRefData->pNextLoaded = pRefData;
    } else {
        pRefData->pNextLoaded = DfsServerGlobalData.LoadedList;
        pRefData->pPrevLoaded = DfsServerGlobalData.LoadedList->pPrevLoaded;
        DfsServerGlobalData.LoadedList->pPrevLoaded->pNextLoaded = pRefData;
        DfsServerGlobalData.LoadedList->pPrevLoaded = pRefData;
    }

    //
    // we are done, release the list lock.
    //
    RELEASE_LOADED_LIST_LOCK();
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetAgedReferralList
//
//  Arguments:  ppReferralData
//
//  Returns:    Nothing
//
//  Description: This routine removes the list and hands it back to the
//               caller. It sets the list as empty.
//               The caller is responsible for freeing up the list
//
//--------------------------------------------------------------------------
VOID
DfsGetAgedReferralList(
    DfsFolderReferralData **ppReferralData )
{

    //
    // this needs to be optimized to return a subset or LRU entries.
    //
    ACQUIRE_LOADED_LIST_LOCK();
    
    *ppReferralData =  DfsServerGlobalData.LoadedList;
    DfsServerGlobalData.LoadedList = NULL;

    RELEASE_LOADED_LIST_LOCK();
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetServerInfo
//
//  Arguments:  pServer, ppInfo
//
//  Returns:    Status
//
//  Description: This routine takes a server name and returns the 
//               structure that holds the site information for that server
//
//               A referenced pointer is returned and the caller is
//               required to release the reference when done.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsGetServerInfo (
    PUNICODE_STRING pServer,
    DfsServerSiteInfo **ppInfo,
    BOOLEAN * CacheHit,
    BOOLEAN SyncThread )
{
    return DfsServerGlobalData.pServerSiteSupport->GetServerSiteInfo(pServer, ppInfo, CacheHit, SyncThread );
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsReleaseServerInfo
//
//  Arguments:  pInfo
//
//  Returns:    Nothing
//
//  Description: This routine releases a server info that was earlier
//               got by calling GetServerInfo
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsReleaseServerInfo (
    DfsServerSiteInfo *pInfo)
{
    return DfsServerGlobalData.pServerSiteSupport->ReleaseServerSiteInfo(pInfo);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetDefaultSite
//
//  Arguments:  Nothing
//
//  Returns:    DfsSite
//
//  Description: This routine returns a referenced pointer to the default DfsSite.
//             The site name of this site is empty. Once done, caller is supposed to call
//             ReleaseReference() on the DfsSite returned here. 
//--------------------------------------------------------------------------
DfsSite *
DfsGetDefaultSite( VOID )
{
    DfsServerGlobalData.pDefaultSite->AcquireReference();
    return DfsServerGlobalData.pDefaultSite;
}
    

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeComputerInfo
//
//  Arguments:  NOTHING
//
//  Returns:    Status
//
//  Description: This routine initializes the computer info, which contains the domain name
//               of this computer, the netbios name and dns names of this computer.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsInitializeComputerInfo()
{
#define COMPUTER_NAME_BUFFER_SIZE 2048
    LONG NameBufferCchLength;
    LPWSTR NameBuffer;
    DFSSTATUS Status = ERROR_SUCCESS ;

    NameBufferCchLength = COMPUTER_NAME_BUFFER_SIZE;

    NameBuffer = new WCHAR [ NameBufferCchLength ];

    if (NameBuffer != NULL)
    {
        INITIALIZE_COMPUTER_INFO( ComputerNameNetBIOS, NameBuffer, NameBufferCchLength, Status );
        INITIALIZE_COMPUTER_INFO( ComputerNameDnsFullyQualified, NameBuffer, NameBufferCchLength, Status );
        INITIALIZE_COMPUTER_INFO( ComputerNameDnsDomain, NameBuffer, NameBufferCchLength, Status );

        delete [] NameBuffer;
    }
    else {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return Status;
}


DFSSTATUS
DfsCreateRequiredOldDfsKeys(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY RootKey, DfsLocationKey, DfsVolumesKey;

    Status = RegConnectRegistry( NULL,
                                 HKEY_LOCAL_MACHINE,
                                 &RootKey );

    if(Status == ERROR_SUCCESS)
    {
        Status = RegCreateKeyEx( RootKey,     // the parent key
                                 DfsRegistryHostLocation, // the key we are creating.
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &DfsLocationKey,
                                 NULL );
        RegCloseKey(RootKey);
        
        if (Status == ERROR_SUCCESS)
        {
            Status = RegCreateKeyEx( DfsLocationKey,     // the parent key
                                     DfsVolumesLocation, // the key we are creating.
                                     0,
                                     L"",
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &DfsVolumesKey,
                                     NULL );
            if (Status == ERROR_SUCCESS)
            {
                RegCloseKey(DfsVolumesKey);
            }

            RegCloseKey(DfsLocationKey);
        }
    }

    return Status;
}

DFSSTATUS
DfsCreateRequiredDfsKeys(void)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY RootKey, DfsLocationKey, DfsRootsKey, FlavorKey;


    Status = DfsCreateRequiredOldDfsKeys();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    Status = RegConnectRegistry( NULL,
                                 HKEY_LOCAL_MACHINE,
                                 &RootKey );

    if(Status == ERROR_SUCCESS)
    {
        Status = RegCreateKeyEx( RootKey,     // the parent key
                                 DfsRegistryDfsLocation, // the key we are creating.
                                 0,
                                 L"",
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &DfsLocationKey,
                                 NULL );
        RegCloseKey(RootKey);
        
        if (Status == ERROR_SUCCESS)
        {
            Status = RegCreateKeyEx( DfsLocationKey,     // the parent key
                                     DfsRootLocation, // the key we are creating.
                                     0,
                                     L"",
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_READ | KEY_WRITE,
                                     NULL,
                                     &DfsRootsKey,
                                     NULL );

            RegCloseKey(DfsLocationKey);
            
            if (Status == ERROR_SUCCESS)
            {
                Status = RegCreateKeyEx( DfsRootsKey,     // the parent key
                                         DfsStandaloneChild,
                                         0,
                                         L"",
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_READ | KEY_WRITE,
                                         NULL,
                                         &FlavorKey,
                                         NULL );
                if (Status == ERROR_SUCCESS)
                {
                    RegCloseKey(FlavorKey);
                }

                if (Status == ERROR_SUCCESS)
                {
                    Status = RegCreateKeyEx( DfsRootsKey,     // the parent key
                                             DfsADBlobChild,
                                             0,
                                             L"",
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_READ | KEY_WRITE,
                                             NULL,
                                             &FlavorKey,
                                             NULL );
                }

                if (Status == ERROR_SUCCESS)
                {
                    RegCloseKey(FlavorKey);
                }

                RegCloseKey( DfsRootsKey );
            }
        }
    }
    return Status;
}





DFSSTATUS
DfsGetMachineName(
    PUNICODE_STRING pName)
{
    DFSSTATUS Status;
    LPWSTR UseName;

    if (DfsServerGlobalData.DfsDnsConfig == 0)
    {
        UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameNetBIOS;
    }
    else {
        UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsFullyQualified;
    }
    Status = DfsCreateUnicodeStringFromString( pName,
                                               UseName );
    return Status;
}

VOID
DfsReleaseMachineName( 
    PUNICODE_STRING pName )
{
    DfsFreeUnicodeString( pName );
}


DFSSTATUS
DfsGetDomainName(
    PUNICODE_STRING pName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR UseName = NULL;

    if (DfsServerGlobalData.DfsDnsConfig == 0)
    {
        if (!IsEmptyString(DfsServerGlobalData.DomainNameFlat.Buffer))
        {
            UseName = DfsServerGlobalData.DomainNameFlat.Buffer;
        }
        else if (!IsEmptyString(DfsServerGlobalData.DomainNameDns.Buffer))
        {
            UseName = DfsServerGlobalData.DomainNameDns.Buffer;
        }
        else if (!IsEmptyString(DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsDomain))
        {
            UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsDomain;
        }
        else 
        {
            Status = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        if (!IsEmptyString(DfsServerGlobalData.DomainNameDns.Buffer))
        {
            UseName = DfsServerGlobalData.DomainNameDns.Buffer;
        }
        else if (!IsEmptyString(DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsDomain))
        {
            UseName = DfsServerGlobalData.DfsMachineInfo.StaticComputerNameDnsDomain;
        }
        else if (!IsEmptyString(DfsServerGlobalData.DomainNameFlat.Buffer))
        {
            UseName = DfsServerGlobalData.DomainNameFlat.Buffer;

        }
        else 
        {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsCreateUnicodeStringFromString( pName,
                                                   UseName );
    }

    return Status;
}

DFSSTATUS
DfsGetDnsDomainName(
    PUNICODE_STRING pName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR UseName = NULL;

    if (!IsEmptyString(DfsServerGlobalData.DomainNameDns.Buffer))
    {
        UseName = DfsServerGlobalData.DomainNameDns.Buffer;
    }
    else 
    {
        Status = ERROR_NOT_FOUND;
    }

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsCreateUnicodeStringFromString( pName,
                                                   UseName );
    }

    return Status;
}


VOID
DfsReleaseDomainName( 
    PUNICODE_STRING pName )
{
    DfsFreeUnicodeString( pName );
}



DFSSTATUS
DfsAddKnownDirectoryPath( 
    PUNICODE_STRING pDirectoryName,
    PUNICODE_STRING pLogicalShare )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID pData = NULL;
    BOOLEAN SubStringMatch = FALSE;
    UNICODE_STRING RemainingName;


    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pDirectoryPrefixTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pDirectoryPrefixTable,
                                               pDirectoryName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );

        if ( (NtStatus == STATUS_SUCCESS) ||
             ((NtStatus != STATUS_SUCCESS) && (SubStringMatch)) )
        {
            NtStatus = STATUS_OBJECT_NAME_COLLISION;
        }
        else 
        {
            //
            // Insert the directory and share information in our
            // database.
            //
            NtStatus = DfsInsertInPrefixTableLocked(DfsServerGlobalData.pDirectoryPrefixTable,
                                                    pDirectoryName,
                                                    (PVOID)pLogicalShare);

        }
        DfsPrefixTableReleaseLock( DfsServerGlobalData.pDirectoryPrefixTable );
    }
    if(NtStatus != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}


DFSSTATUS
DfsRemoveKnownDirectoryPath( 
    PUNICODE_STRING pDirectoryName,
    PUNICODE_STRING pLogicalShare)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID pData = NULL;
    BOOLEAN SubStringMatch = FALSE;
    UNICODE_STRING RemainingName;

    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pDirectoryPrefixTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pDirectoryPrefixTable,
                                               pDirectoryName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );
        //
        // if we found a perfect match, we can remove this
        // from the table.
        //
        if ( (NtStatus == STATUS_SUCCESS) &&
             (RemainingName.Length == 0) )
        {
            NtStatus = DfsRemoveFromPrefixTableLocked( DfsServerGlobalData.pDirectoryPrefixTable,
                                                       pDirectoryName,
                                                       (PVOID)pLogicalShare);
        }
        else
        {
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        DfsPrefixTableReleaseLock( DfsServerGlobalData.pDirectoryPrefixTable );
    }

    if (NtStatus != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}



//
// Function AcquireLock: Acquires the lock on the folder
//
DFSSTATUS
DfsAcquireWriteLock(
    PCRITICAL_SECTION pLock)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    EnterCriticalSection(pLock);

    return Status;
}


DFSSTATUS
DfsAcquireReadLock(
    PCRITICAL_SECTION pLock)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    
    EnterCriticalSection(pLock);

    return Status;
}


VOID
DfsSetGlobalDomainInfo(
    DfsDomainInformation *pDomainInfo)
{
    DFSSTATUS Status;
    DfsDomainInformation *pOldInfo = NULL;

    Status = DfsAcquireGlobalDataLock();
    if (Status == ERROR_SUCCESS)
    {
        pDomainInfo->AcquireReference();
        pOldInfo = DfsServerGlobalData.pDomainInfo;
        DfsServerGlobalData.pDomainInfo = pDomainInfo;

        DfsReleaseGlobalDataLock();
    }

    if (pOldInfo != NULL) 
    {
        pOldInfo->ReleaseReference();
    }

    return NOTHING;
}


DFSSTATUS
DfsAcquireDomainInfo (
    DfsDomainInformation **ppDomainInfo )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsAcquireGlobalDataLock();
    if (Status == ERROR_SUCCESS)
    {
        *ppDomainInfo = DfsServerGlobalData.pDomainInfo;
        if (*ppDomainInfo == NULL)
        {
            Status = ERROR_NOT_READY;
        }
        else 
        {
            (*ppDomainInfo)->AcquireReference();
        }
        DfsReleaseGlobalDataLock();
    }
    
    return Status;
}

VOID
DfsReleaseDomainInfo (
    DfsDomainInformation *pDomainInfo )
{
    pDomainInfo->ReleaseReference();
    return NOTHING;
}



DFSSTATUS
DfsSetDomainNameFlat(LPWSTR DomainNameFlatString)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DomainNameFlat;

    Status = DfsRtlInitUnicodeStringEx( &DomainNameFlat, DomainNameFlatString);
    if(Status == ERROR_SUCCESS)
    {
        Status = DfsCreateUnicodeString( &DfsServerGlobalData.DomainNameFlat,
                                         &DomainNameFlat );

    }

    return Status;
}

DFSSTATUS
DfsSetDomainNameDns( LPWSTR DomainNameDnsString )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING DomainNameDns;

    Status = DfsRtlInitUnicodeStringEx( &DomainNameDns, DomainNameDnsString);
    if(Status == ERROR_SUCCESS)
    {
        Status = DfsCreateUnicodeString( &DfsServerGlobalData.DomainNameDns,
                                         &DomainNameDns);
    }

    return Status;
}


BOOLEAN
DfsIsNameContextDomainName( PUNICODE_STRING pName )
{
    BOOLEAN ReturnValue = FALSE;

    if (pName->Length == DfsServerGlobalData.DomainNameFlat.Length)
    {
        if (_wcsnicmp(DfsServerGlobalData.DomainNameFlat.Buffer,
                      pName->Buffer, pName->Length/sizeof(WCHAR)) == 0)
        {
            ReturnValue = TRUE;
        }
    }
    else if (pName->Length == DfsServerGlobalData.DomainNameDns.Length)
    {
        if (_wcsnicmp(DfsServerGlobalData.DomainNameDns.Buffer,
                      pName->Buffer, pName->Length/sizeof(WCHAR)) == 0)
        {
            ReturnValue = TRUE;
        }
    }

    return ReturnValue;

}

DWORD DfsReadRegistryDword( HKEY    hkey,
                            LPWSTR   pszValueName,
                            DWORD    dwDefaultValue )
{
    DWORD  dwerr = 0;
    DWORD  dwBuffer = 0;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType = 0;

    if( hkey != NULL )
    {
        dwerr = RegQueryValueEx( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( dwerr == NO_ERROR ) && ( dwType == REG_DWORD ) )
        {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;
}   


//*************************************************************
//
//  IsNullGUID()
//
//  Purpose:    Determines if the passed in GUID is all zeros
//
//  Parameters: pguid   GUID to compare
//
//  Return:     TRUE if the GUID is all zeros
//              FALSE if not
//
//*************************************************************

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}


BOOLEAN
DfsGetGlobalRegistrySettings(void)
{
    BOOLEAN        fRet = TRUE;
    HKEY        hkeyDfs = NULL;
    HKEY        hkeyDfs2 = NULL;
    DWORD       dwErr = 0;
    DWORD       dwDisp = 0;


    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DfsSvcPath, 
                           NULL,
                           NULL,
                           REG_OPTION_NON_VOLATILE, 
                           KEY_READ|KEY_WRITE, // Write = Create if 
                           NULL, &hkeyDfs, &dwDisp);
    if (dwErr == ERROR_SUCCESS) 
    {
        //
        //support the old format of specifying the time interval to refresh.
        //
        DfsServerGlobalData.CacheFlushInterval = DfsReadRegistryDword(hkeyDfs, 
                                                                      DfsWorkerThreadIntervalName, 
                                                                      CACHE_FLUSH_INTERVAL/1000);   

        dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DfsParamPath, NULL, NULL,
                REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkeyDfs2, &dwDisp);
        if (dwErr == ERROR_SUCCESS)
        {
            DfsServerGlobalData.SiteSupportRefreshInterval = DfsReadRegistryDword(hkeyDfs2, DfsSiteSupportRefreshIntervalName, SITE_REFRESH_INTERVAL/1000);
            //
            // domain name refresh interval defaults to same as site refresh: 12 hours
            //
            DfsServerGlobalData.DomainNameRefreshInterval = DfsReadRegistryDword(hkeyDfs2, DfsDomainNameRefreshInterval, SITE_REFRESH_INTERVAL/1000);
            DfsServerGlobalData.SiteIpCacheTrimValue = DfsReadRegistryDword(hkeyDfs2, DfsSiteIpCacheTrimValueName, SITE_IPCACHE_TRIM_VALUE);
            DfsServerGlobalData.AllowedErrors = DfsReadRegistryDword(hkeyDfs2, DfsAllowableErrorsValueName, DFS_MAX_ROOT_ERRORS);
            DfsServerGlobalData.LdapTimeOut = DfsReadRegistryDword(hkeyDfs2, DfsLdapTimeoutValueName, DFS_LDAP_TIMEOUT);
            DfsServerGlobalData.NumClientSiteEntriesAllowed = DfsReadRegistryDword(hkeyDfs2, DfsMaxClientSiteValueName, DFS_INITIAL_CLIENTS_SITES);
            DfsServerGlobalData.QuerySiteCostTimeoutInSeconds = DfsReadRegistryDword(hkeyDfs2, DfsQuerySiteCostTimeoutName, DFS_QUERY_SITE_COST_TIMEOUT);
            
            DfsServerGlobalData.RootReferralRefreshInterval = DfsReadRegistryDword(hkeyDfs2, DFS_REG_ROOT_REFERRAL_TIMEOUT_NAME, ROOTREF_REFRESH_INTERVAL/1000);
            if (DfsReadRegistryDword(hkeyDfs2, DfsSiteCostedReferralsValueName, 0) != 0)
            {
                DfsServerGlobalData.Flags |= DFS_SITE_COSTED_REFERRALS;
            }
            if (DfsReadRegistryDword(hkeyDfs2, DfsInsiteReferralsValueName, 0) != 0)
            {
                DfsServerGlobalData.Flags |= DFS_INSITE_REFERRALS;
            }

            //
            // if we are possibly in a NT4 domain, check if we need to disable
            // siteawareness.
            //
            {
                LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
                NTSTATUS                  status = 0;
                LSA_HANDLE                hPolicy;
                BOOLEAN CheckRegistry = TRUE;

                DfsServerGlobalData.DisableSiteAwareness = FALSE;

              //attempt to open the policy.
                ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));//object attributes are reserved, so initalize to zeroes.
                status = LsaOpenPolicy(	NULL,
                                        &ObjectAttributes,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &hPolicy);  //recieves the policy handle

                if (NT_SUCCESS(status))
                {
                    //ask for audit event policy information
                    PPOLICY_DNS_DOMAIN_INFO   info;
                    status = LsaQueryInformationPolicy(hPolicy, 
                                                       PolicyDnsDomainInformation,
                                                       (PVOID *)&info);
                    if (NT_SUCCESS(status))
                    {
                        if (!IsNullGUID(&info->DomainGuid))
                        {
                            CheckRegistry = FALSE;
                        }

                        LsaFreeMemory((PVOID) info); //free policy info structure
                    }

                    LsaClose(hPolicy); //Freeing the policy object handle
                }

                if (CheckRegistry)
                {
                    DWORD DisableSiteAwareness = 0;

                    DisableSiteAwareness = 
                        DfsReadRegistryDword( hkeyDfs2,
                                              DFS_DISABLE_SITE_AWARENESS,
                                              DisableSiteAwareness );

                    DfsServerGlobalData.DisableSiteAwareness = (DisableSiteAwareness == 0) ? FALSE : TRUE;
                }

            }
            
            RegCloseKey(hkeyDfs2);
        }

        RegCloseKey(hkeyDfs);
    }

     
    DfsServerGlobalData.CacheFlushInterval *= 1000;

    if(DfsServerGlobalData.CacheFlushInterval < CACHE_FLUSH_MIN_INTERVAL)
    {
        DfsServerGlobalData.CacheFlushInterval = CACHE_FLUSH_MIN_INTERVAL;
        DfsServerGlobalData.RetryFailedReferralLoadInterval = DfsServerGlobalData.CacheFlushInterval / 3;
    }
    else
    {
        DfsServerGlobalData.RetryFailedReferralLoadInterval = DfsServerGlobalData.CacheFlushInterval /4;
    }
    
    DfsServerGlobalData.SiteSupportRefreshInterval *= 1000;

    if(DfsServerGlobalData.SiteSupportRefreshInterval == 0)
    {
        DfsServerGlobalData.SiteSupportRefreshInterval = SITE_REFRESH_INTERVAL;
    }
    
    if(DfsServerGlobalData.SiteSupportRefreshInterval < MIN_SITE_REFRESH_INTERVAL)
    {
      DfsServerGlobalData.SiteSupportRefreshInterval = MIN_SITE_REFRESH_INTERVAL;
    }

    if(DfsServerGlobalData.DomainNameRefreshInterval < MIN_DOMAIN_REFRESH_INTERVAL)
    {
      DfsServerGlobalData.DomainNameRefreshInterval = MIN_DOMAIN_REFRESH_INTERVAL;
    }
    
    if(DfsServerGlobalData.NumClientSiteEntriesAllowed < DFS_MINIMUM_CLIENTS_SITES)
    {
      DfsServerGlobalData.NumClientSiteEntriesAllowed = DFS_MINIMUM_CLIENTS_SITES;
    }

    if (DfsServerGlobalData.QuerySiteCostTimeoutInSeconds < DFS_MIN_QUERY_SITE_COST_TIMEOUT)
    {
        DfsServerGlobalData.QuerySiteCostTimeoutInSeconds = DFS_MIN_QUERY_SITE_COST_TIMEOUT;
    }
    else if (DfsServerGlobalData.QuerySiteCostTimeoutInSeconds > DFS_MAX_QUERY_SITE_COST_TIMEOUT)
    {
        DfsServerGlobalData.QuerySiteCostTimeoutInSeconds = DFS_MAX_QUERY_SITE_COST_TIMEOUT;
    }

    DfsServerGlobalData.RootReferralRefreshInterval *= 1000;
    if(DfsServerGlobalData.RootReferralRefreshInterval < ROOTREF_REFRESH_INTERVAL)
    {
         DfsServerGlobalData.RootReferralRefreshInterval = ROOTREF_REFRESH_INTERVAL;
    }

    DfsServerGlobalData.SiteSupportThreadInterval = DfsServerGlobalData.SiteSupportRefreshInterval - SITE_THREAD_INTERVAL_DIFF;

    DfsServerGlobalData.FirstContact = DFS_DS_ACTIVE;


    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Read regkey DfsServerGlobalData.SiteSupportRefreshInterval %d\n", DfsServerGlobalData.SiteSupportRefreshInterval);
    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Read regkey DfsServerGlobalData.CacheFlushInterval %d\n", DfsServerGlobalData.CacheFlushInterval);
    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Read regkey DfsServerGlobalData.SiteIpCacheTrimValue %d\n", DfsServerGlobalData.SiteIpCacheTrimValue);
    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Read regkey DfsServerGlobalData.AllowedErrors %d\n", DfsServerGlobalData.AllowedErrors);
    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Read regkey DfsServerGlobalData.LdapTimeOut %d\n", DfsServerGlobalData.LdapTimeOut);
    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Read regkey DfsServerGlobalData.NumClientSiteEntriesAllowed %d\n", DfsServerGlobalData.NumClientSiteEntriesAllowed);

    return fRet;
}


BOOLEAN
DfsGetStaticGlobalRegistrySettings(void)
{
    BOOLEAN     fRet = TRUE;
    HKEY        hkeyDfs = NULL;
    HKEY        hkeyDfs2 = NULL;
    DWORD       dwErr = 0;
    DWORD       dwDisp = 0;


    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DfsSvcPath, 
                           NULL,
                           NULL,
                           REG_OPTION_NON_VOLATILE, 
                           KEY_READ|KEY_WRITE, // Write = Create if 
                           NULL, &hkeyDfs, &dwDisp);
    if (dwErr == ERROR_SUCCESS) 
    {

        DfsServerGlobalData.DfsDnsConfig = (DWORD) !!DfsReadRegistryDword(hkeyDfs, 
                                                                DfsDnsConfigValue,
                                                                0 );

        dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DfsParamPath, NULL, NULL,
                REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hkeyDfs2, &dwDisp);
        if (dwErr == ERROR_SUCCESS)
        {
            DfsServerGlobalData.NumWorkerThreads = DfsReadRegistryDword(hkeyDfs2, DFS_REG_WORKER_THREAD_VALUE, DFS_DEFAULT_WORKER_THREADS);            
            
            RegCloseKey(hkeyDfs2);
        }

        if(DfsServerGlobalData.NumWorkerThreads < DFS_MIN_WORKER_THREADS)
        {
            DfsServerGlobalData.NumWorkerThreads = DFS_MIN_WORKER_THREADS;
        }
        else if (DfsServerGlobalData.NumWorkerThreads > DFS_MAX_WORKER_THREADS) 
        {
            DfsServerGlobalData.NumWorkerThreads = DFS_MAX_WORKER_THREADS;
        }


        RegCloseKey(hkeyDfs);
    }

     
    return fRet;
}

#define DFS_PDC_CACHE_TIME_INTERVAL 60 * 60 * 1000  // 60 minutes.

DFSSTATUS
DfsGetBlobPDCName(
    DfsString **ppPDCName,
    ULONG Flags,
    LPWSTR DomainName )
{
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LockStatus = ERROR_SUCCESS;
    ULONG CurrentTimeStamp = 0;
    ULONG TimeDiff = 0;
    BOOLEAN NewDcAttempted = FALSE;

    DfsString NewDC;

    *ppPDCName = NULL;

    DfsGetTimeStamp(&CurrentTimeStamp);


    TimeDiff = CurrentTimeStamp - DfsServerGlobalData.PDCTimeStamp;

    if ((Flags & DFS_FORCE_DC_QUERY) ||
        (TimeDiff > DFS_PDC_CACHE_TIME_INTERVAL) ||
        (DfsServerGlobalData.PDCTimeStamp == 0))
    {
        NewDcAttempted = TRUE;

        Status = DsGetDcName( NULL,    //computer name
                              DomainName,    // domain name
                              NULL,    // domain guid
                              NULL,    // site name
                              DS_DIRECTORY_SERVICE_REQUIRED |
                              DS_PDC_REQUIRED | 
                              DS_FORCE_REDISCOVERY,
                              &pDomainControllerInfo );

        DFS_TRACE_LOW( REFERRAL_SERVER, "Got New PDC, Status %x\n", Status);

        if (Status == ERROR_SUCCESS)
        {
            Status = NewDC.CreateString(&pDomainControllerInfo->DomainControllerName[2] );

            NetApiBufferFree(pDomainControllerInfo);
        }
    }
    else
    {
        Status = DfsServerGlobalData.PDCStatus;
    }

    LockStatus = DfsAcquireGlobalDataLock();
    if (LockStatus != ERROR_SUCCESS) {
        return LockStatus;
    }

    if (NewDcAttempted == TRUE) 
    {
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsServerGlobalData.PDCName.CreateString(&NewDC);
        }
        if (Status == ERROR_SUCCESS)
        {
            DfsServerGlobalData.PDCTimeStamp = CurrentTimeStamp;
        }
        DfsServerGlobalData.PDCStatus = Status;
    }

    if ((Status == ERROR_SUCCESS) &&
        (ppPDCName != NULL))
    {
        DfsString *pReturnDcName;

        pReturnDcName = new DfsString;
        if (pReturnDcName == NULL) 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Status = pReturnDcName->CreateString(&DfsServerGlobalData.PDCName );
            if (Status == ERROR_SUCCESS) 
            {
                *ppPDCName = pReturnDcName;
            }
            else
            {
                delete pReturnDcName;
            }
        }
    }

    DfsReleaseGlobalDataLock();

    if (*ppPDCName != NULL) {
        DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Returning PDC: %ws, Status %x\n", 
                       (*ppPDCName)->GetString(), Status);
    }

    return Status;
}


DFSSTATUS
DfsSetBlobPDCName(
    LPWSTR DCName,
    DfsString **ppPDCName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS LockStatus = ERROR_SUCCESS;
    DfsString NewDC;
    ULONG CurrentTimeStamp = 0;

    DfsGetTimeStamp(&CurrentTimeStamp);

    *ppPDCName = NULL;

    Status = NewDC.CreateString(DCName);
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    LockStatus = DfsAcquireGlobalDataLock();
    if (LockStatus != ERROR_SUCCESS) {
        return LockStatus;
    }

    Status = DfsServerGlobalData.PDCName.CreateString(&NewDC);

    if (Status == ERROR_SUCCESS)
    {
        DfsServerGlobalData.PDCTimeStamp = CurrentTimeStamp;
    }
    DfsServerGlobalData.PDCStatus = Status;


    if ((Status == ERROR_SUCCESS) &&
        (ppPDCName != NULL))
    {
        DfsString *pReturnDcName;

        pReturnDcName = new DfsString;
        if (pReturnDcName == NULL) 
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Status = pReturnDcName->CreateString(&DfsServerGlobalData.PDCName );
            if (Status == ERROR_SUCCESS) 
            {
                *ppPDCName = pReturnDcName;
            }
            else
            {
                delete pReturnDcName;
            }
        }
    }

    DfsReleaseGlobalDataLock();

    if (*ppPDCName != NULL) {
        DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Returning PDC: %ws, Status %x\n", 
                       (*ppPDCName)->GetString(), Status);
    }
    return Status;
}



VOID
DfsReleaseBlobPDCName( 
    DfsString *pDCName )
{
    if (pDCName != NULL) 
    {
        delete pDCName;
    }
}


BOOLEAN
DfsIsTargetCurrentMachine (
    PUNICODE_STRING pServer )
{
    UNICODE_STRING MachineName;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN ReturnValue = FALSE;

    Status = DfsGetMachineName(&MachineName);

    if (Status == ERROR_SUCCESS)
    {
        if (RtlCompareUnicodeString( pServer, &MachineName, TRUE) == 0)
        {
            ReturnValue = TRUE;
        }
        DfsFreeUnicodeString( &MachineName );
    }

    return ReturnValue;
}



LPWSTR
DfsGetDfsAdNameContextString()
{
    if (DfsServerGlobalData.DfsAdNameContext.Buffer == NULL)
    {
        //
        // ignore return status: we should log it.
        //
        DFSSTATUS DummyStatus;

        DummyStatus = DfsGenerateDfsAdNameContext(&DfsServerGlobalData.DfsAdNameContext);

    }
    return DfsServerGlobalData.DfsAdNameContext.Buffer;
}


LPWSTR
DfsGetDfsAdNameContextStringForDomain(LPWSTR UseDC)
{

extern DFSSTATUS DfsGenerateDfsAdNameContextForDomain(PUNICODE_STRING pString,LPWSTR DCName );

    if (DfsServerGlobalData.DfsAdNameContext.Buffer != NULL)
    {
        DfsFreeUnicodeString(&DfsServerGlobalData.DfsAdNameContext);
        RtlInitUnicodeString(&DfsServerGlobalData.DfsAdNameContext, NULL);

    }
    //
    // ignore return status: we should log it.
    //
    DFSSTATUS DummyStatus;

    DummyStatus = DfsGenerateDfsAdNameContextForDomain(&DfsServerGlobalData.DfsAdNameContext, UseDC);

    return DfsServerGlobalData.DfsAdNameContext.Buffer;
}

extern SECURITY_DESCRIPTOR AdminSecurityDesc;

//+----------------------------------------------------------------------------
//
//  Function:   InitializeSecurity
//
//  Synopsis:   Initializes data needed to check the access rights of callers
//              of the NetDfs APIs
//
//  Arguments:  None
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsInitializeSecurity()
{
    static PSID AdminSid;
    static PACL AdminAcl;
    NTSTATUS status;
    ULONG cbAcl;
    BOOLEAN InitDone = FALSE;
    
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    status = RtlAllocateAndInitializeSid(
                &ntAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &AdminSid);

    if (!NT_SUCCESS(status))
        return( FALSE );

    cbAcl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(AdminSid);

    do {
        AdminAcl = (PACL) new BYTE[ cbAcl ];

        if (AdminAcl == NULL)
            break;

        if (!InitializeAcl(AdminAcl, cbAcl, ACL_REVISION))
            break;

        if (!AddAccessAllowedAce(AdminAcl, ACL_REVISION, STANDARD_RIGHTS_WRITE, AdminSid))
            break;

        if (!InitializeSecurityDescriptor(&AdminSecurityDesc, SECURITY_DESCRIPTOR_REVISION))
            break;

        if (!SetSecurityDescriptorOwner(&AdminSecurityDesc, AdminSid, FALSE))
            break;

        if (!SetSecurityDescriptorGroup(&AdminSecurityDesc, AdminSid, FALSE))
            break;

        if (!SetSecurityDescriptorDacl(&AdminSecurityDesc, TRUE, AdminAcl, FALSE))
            break;
            
        InitDone = TRUE;
    } while (FALSE);
    
    if (InitDone == FALSE && AdminAcl != NULL)
    {
        delete [] AdminAcl;
        AdminAcl = NULL;
    }
    
    return InitDone;

}

DFSSTATUS 
AccessImpersonateCheckRpcClient(void)
{
    DFSSTATUS dwErr = 0;

    dwErr = AccessImpersonateCheckRpcClientEx(&AdminSecurityDesc, 
                                              &AdminGenericMapping,
                                              STANDARD_RIGHTS_WRITE);

    return dwErr;
}


VOID
StartPreloadingServerSiteData(void)
{
   DfsStore *pStore = NULL;

    for (pStore = DfsServerGlobalData.pRegisteredStores; pStore != NULL;
            pStore = pStore->pNextRegisteredStore) 
    {
       pStore->LoadServerSiteDataPerRoot();

       if (DfsIsShuttingDown())
       {
           break;
       }
    }
}



DFSSTATUS
DfsGetCompatRootFolder(
    PUNICODE_STRING pName,
    DfsRootFolder **ppNewRoot )
{
    DfsADBlobStore *pStore = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = DfsGetADBlobStore(&pStore );
    if (Status == ERROR_SUCCESS) 
    {
        Status = pStore->GetCompatRootFolder( pName,
                                              ppNewRoot );

        pStore->ReleaseReference();
    }

    return Status;
}



//+----------------------------------------------------------------------------
//
//  Function:   DfsCacheInsertADRootReferral
//
//  Synopsis:   Insert a ReferralData structure into our list.
//
//  Returns:    Status.
//
//-----------------------------------------------------------------------------


typedef struct _DFS_ROOTREF_INFORMATION 
{
    DfsFolderReferralData * pReferralData;
    GUID RootGuid;
}DFS_ROOTREF_INFORMATION, *PDFS_ROOTREF_INFORMATION;


DFSSTATUS
DfsCacheInsertADRootReferral( 
    PUNICODE_STRING pRootName,
    PDFS_ROOTREF_INFORMATION  pRefInfo )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID pData = NULL;
    BOOLEAN SubStringMatch = FALSE;
    UNICODE_STRING RemainingName;

    pRefInfo->pReferralData->AcquireReference();

    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pRootReferralTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pRootReferralTable,
                                               pRootName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );


        if ( (NtStatus == STATUS_SUCCESS) ||
             ((NtStatus != STATUS_SUCCESS) && (SubStringMatch)) )
        {
            NtStatus = STATUS_OBJECT_NAME_COLLISION;
        }
        else 
        {
            //
            // Insert the directory and share information in our
            // database.
            //
            NtStatus = DfsInsertInPrefixTableLocked(DfsServerGlobalData.pRootReferralTable,
                                                    pRootName,
                                                    (PVOID)pRefInfo );


        }
        DfsPrefixTableReleaseLock( DfsServerGlobalData.pRootReferralTable );
    }


    if(NtStatus != STATUS_SUCCESS)
    {
        pRefInfo->pReferralData->ReleaseReference();
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}


DFSSTATUS
DfsCacheRemoveADRootReferral(
    PUNICODE_STRING pRootName,
    PDFS_ROOTREF_INFORMATION  pRefInfo )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID pData = NULL;
    BOOLEAN SubStringMatch = FALSE;
    UNICODE_STRING RemainingName;

    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pRootReferralTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pRootReferralTable,
                                               pRootName,
                                               &RemainingName,
                                               &pData,
                                               &SubStringMatch );
        //
        // if we found a perfect match, we can remove this
        // from the table.
        //

        if ( (NtStatus == STATUS_SUCCESS) &&
             (RemainingName.Length == 0) )
        {
            if ((pRefInfo == NULL) || ((PVOID)pRefInfo == pData)) 
            {
                pRefInfo = (PDFS_ROOTREF_INFORMATION)pData;
                NtStatus = DfsRemoveFromPrefixTableLocked( DfsServerGlobalData.pRootReferralTable,
                                                           pRootName,
                                                           (PVOID)pData );
            }
            else
            {
                NtStatus = STATUS_OBJECT_TYPE_MISMATCH;
            }
        }
        else
        {
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        DfsPrefixTableReleaseLock( DfsServerGlobalData.pRootReferralTable );
    }


    if (NtStatus == STATUS_SUCCESS) 
    {
        pRefInfo->pReferralData->ReleaseReference();
        delete []  pRefInfo;
    }
    else
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }

    return Status;
}



DFSSTATUS
DfsGetADRootReferralInformation( 
    PUNICODE_STRING pRootName,
    PDFS_ROOTREF_INFORMATION * pRefInformation,
    GUID *pNewGuid)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolderReferralData *pReferralData = NULL;
    BOOLEAN CacheHit = TRUE;
    PDFS_ROOTREF_INFORMATION  pRefInfo = NULL;
    UNICODE_STRING RemainingName;

    Status = DfsGetRootReferralDataEx(pRootName,
                                      &RemainingName,
                                      &pReferralData,
                                      &CacheHit);
    if(Status == ERROR_SUCCESS)
    {
      pRefInfo = (PDFS_ROOTREF_INFORMATION) new BYTE[sizeof(DFS_ROOTREF_INFORMATION)];

      if(pRefInfo == NULL)
      {
        pReferralData->ReleaseReference();
        Status = ERROR_NOT_ENOUGH_MEMORY;
      }
      else
      {
          pRefInfo->pReferralData = pReferralData;
          RtlCopyMemory(&pRefInfo->RootGuid, pNewGuid, sizeof(GUID)); 
          *pRefInformation = pRefInfo;
      }
    }

    return Status;
}


DFSSTATUS
DfsCheckIfRootExist(
    PUNICODE_STRING pName,
    GUID *pNewGuid)

{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING ServerName, ShareName, Rest;


    //
    // Break up the path into name components.
    // 
    Status = DfsGetPathComponents( pName,
                                   &ServerName,
                                   &ShareName,
                                   &Rest );

    if(Status == ERROR_SUCCESS)
    {

        Status = DfsCheckRootADObjectExistence(NULL, 
                                               &ShareName, 
                                               pNewGuid);
    }

    return Status;
}


DFSSTATUS
DfsGetADRootReferralData( 
    PUNICODE_STRING pRootName,
    DfsReferralData **ppReferralData )
{
    BOOLEAN SubStringMatch = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS NtTempStatus = STATUS_SUCCESS;
    DfsFolderReferralData *pReferralData = NULL;
    PDFS_ROOTREF_INFORMATION  pRefInfo = NULL;
    BOOLEAN CacheHit = TRUE;
    BOOLEAN RootExists = FALSE;
    GUID NewGuid;
    UNICODE_STRING RemainingName;

    *ppReferralData = NULL;

    DFS_TRACE_LOW(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Getting AD Root referral for %wZ\n", pRootName);
    NtStatus = DfsPrefixTableAcquireWriteLock( DfsServerGlobalData.pRootReferralTable );
    if ( NtStatus == STATUS_SUCCESS )
    {
        NtStatus = DfsFindUnicodePrefixLocked( DfsServerGlobalData.pRootReferralTable,
                                               pRootName,
                                               &RemainingName,
                                               (PVOID *)&pRefInfo,
                                               &SubStringMatch );
        if (NtStatus == STATUS_SUCCESS)
        {
            DFS_TRACE_LOW(REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Found cached, for %wZ, %p\n", pRootName, pReferralData);
            if (pRefInfo->pReferralData->TimeToRefresh() == TRUE) 
            {
                //initialize the new guid
                RtlZeroMemory(&NewGuid, sizeof(NewGuid));

                //see if the root actually exists
                Status = DfsCheckIfRootExist(pRootName, 
                                             &NewGuid);
                if(Status == ERROR_SUCCESS)
                {
                    RootExists = TRUE;

                    NtStatus = STATUS_UNSUCCESSFUL;
                }
                else
                {
                    NtTempStatus = DfsCacheRemoveADRootReferral(pRootName, NULL);
                }
                
            }
            else
            {
                pReferralData = pRefInfo->pReferralData; 
                pReferralData->AcquireReference();
                *ppReferralData = pReferralData;
            }

        }
        else
        {

            //No data in our table. see if the root actually exists.
            //if it does not exist, then we bail out
            Status = DfsCheckIfRootExist(pRootName, 
                                         &NewGuid);
            if(Status == ERROR_SUCCESS)
            {           
                RootExists = TRUE;
            }
        }

        DfsPrefixTableReleaseLock( DfsServerGlobalData.pRootReferralTable );
    }

    if(RootExists && (NtStatus != STATUS_SUCCESS)) 
    {
        Status = DfsGetADRootReferralInformation(pRootName,  
                                                 &pRefInfo,
                                                 &NewGuid); 
        if (Status == ERROR_SUCCESS) 
        {
            *ppReferralData = pRefInfo->pReferralData;

            NtTempStatus = DfsCacheRemoveADRootReferral(pRootName, NULL);

            NtTempStatus = DfsCacheInsertADRootReferral(pRootName, pRefInfo);
            if(NtTempStatus != STATUS_SUCCESS)
            {
                delete []  pRefInfo;
            }
            DFS_TRACE_ERROR_LOW( NtTempStatus, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]AD Root Referral, insert status %x\n",
                                 NtTempStatus );

        }

        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]Generate AD ROOT referral, got %p, status %x\n",
                            pReferralData, Status);

    }

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "[%!FUNC!- Level %!LEVEL!]AD Root Referral for %wZ is %p, status %x\n",
                          pRootName, pReferralData, Status);
    return Status;
}

BOOLEAN
DfsIsMachineDomainController()
{
    return DfsServerGlobalData.IsDc;
}

DWORD
DfsGetNumReflectionThreads(void)
{
  return DfsServerGlobalData.NumWorkerThreads;
}


DFSSTATUS
DfsSetupPrivileges (void)
{

    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // Get the SE_SECURITY_PRIVILEGE to read/write SACLs.
    //
    Status = DfsAdjustPrivilege(SE_SECURITY_PRIVILEGE, TRUE);
    if(Status != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    //
    // Get backup/restore privilege to bypass ACL checks.
    //
    Status = DfsAdjustPrivilege(SE_BACKUP_PRIVILEGE, TRUE);
    if(Status != ERROR_SUCCESS) 
    {
        return FALSE;
    }

    Status = DfsAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE);
    if(Status != ERROR_SUCCESS) 
    {
        return FALSE;
    }
    
    
    //disable stuff we don't need

    Status = DfsAdjustPrivilege(SE_CREATE_TOKEN_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_LOCK_MEMORY_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_SYSTEMTIME_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_CREATE_PERMANENT_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_CREATE_PAGEFILE_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_DEBUG_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, FALSE);

    Status = DfsAdjustPrivilege(SE_PROF_SINGLE_PROCESS_PRIVILEGE, FALSE);    

    //now, remove anything disabled
    Status = DfsRemoveDisabledPrivileges();

    return Status;
}


DFSSTATUS
DfsGetRootCount(
    PULONG pRootCount )
{
    DfsStore *pStore;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG RootCount;
    ULONG TotalCount = 0;


    //
    // For each store registered, get the number of roots.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        Status = pStore->GetRootCount(&RootCount);

        if (Status == ERROR_SUCCESS)
        {
            TotalCount += RootCount;
        }
        else
        {
            break;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        *pRootCount = TotalCount;
    }
    return Status;

}

DFSSTATUS
DfsCheckServerRootHandlingCapability()
{
    DFSSTATUS Status = ERROR_SUCCESS;


    if (DfsLimitRoots() == TRUE)
    {
        ULONG RootCount = 0;

        Status = DfsGetRootCount(&RootCount);

        if (Status == ERROR_SUCCESS)
        {
            if (RootCount >= 1)
            {
                Status = ERROR_NOT_SUPPORTED;
            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsprocessreferral.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsProcessReferral.cxx
//
//  Contents:   Contains APIs to communicate with the filter driver   
//
//  Classes:    none.
//
//  History:    Jan. 24 2001,   Author: Rohanp
//
//-----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>        
#include <lm.h>
#include <winsock2.h>
#include <smbtypes.h>

#pragma warning(disable: 4200) //nonstandard extension used: zero-sized array in struct/union (line 1085
#include <smbtrans.h>
#pragma warning(default: 4200)

#include <dsgetdc.h>
#include <dsrole.h>
#include <DfsReferralData.h>
#include <DfsReferral.hxx>
#include <dfsheader.h>
#include <Dfsumr.h>
#include <DfsDownLevel.hxx>
#include <dfssitecache.hxx>
#include <DfsSite.hxx>

//
// logging includes.
//

#include "dfsprocessreferral.tmh" 


//
// Flags used in DsGetDcName()
//

DWORD dwFlags[] = {
        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED,

        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_FORCE_REDISCOVERY
     };
       


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetSiteNameFromIpAddress 
//
//  Arguments:  DataBuffer - Buffer from the FilterDriver
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Gets a list of sites from the DC
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetSiteNameFromIpAddress(char * IpData, 
                            ULONG IpLength, 
                            USHORT IpFamily,
                            LPWSTR **SiteNames)
{
    DFSSTATUS Status = ERROR_INVALID_PARAMETER;
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    PSOCKET_ADDRESS pSockAddr = NULL;
    PSOCKADDR_IN pSockAddrIn = NULL;
    DWORD cRetry = 0;
    SOCKET_ADDRESS SockAddr;
    SOCKADDR_IN SockAddrIn;

    if(DfsServerGlobalData.IsWorkGroup == TRUE)
    {
        Status =  ERROR_SUCCESS;
        return Status;
    }

    //setup the socket structures in order to call DsAddressToSiteNames
    pSockAddr = &SockAddr;
    pSockAddr->iSockaddrLength = sizeof(SOCKADDR_IN);
    pSockAddr->lpSockaddr = (LPSOCKADDR)&SockAddrIn;
    pSockAddrIn = &SockAddrIn;
    pSockAddrIn->sin_family = IpFamily;
    pSockAddrIn->sin_port = 0;
    RtlCopyMemory(
                &pSockAddrIn->sin_addr,
                IpData,
                (IpLength & 0xff));



    if(DfsServerGlobalData.IsDc == FALSE)
    {
        if (DfsServerGlobalData.DisableSiteAwareness == TRUE)
        {
            Status = ERROR_NOT_SUPPORTED;
        }
        else
        {
            //
            // Call DsGetDcName() with ever-increasing urgency, until either
            // we get a good DC or we just give up.
            //  

            for (cRetry = 0; cRetry <= (sizeof(dwFlags) / sizeof(dwFlags[1])); cRetry++)
            {
                DFS_TRACE_NORM(REFERRAL_SERVER, "Calling DsGetDc\n");


                Status = DsGetDcName( NULL,             // Computer to remote to
                                      NULL,             // Domain - use local domain
                                      NULL,             // Domain Guid
                                      NULL,             // Site Guid
                                      dwFlags[cRetry],  // Flags
                                      &pDCInfo);

                DFS_TRACE_LOW(REFERRAL_SERVER, "Calling GetSiteName\n");

                if (Status == ERROR_SUCCESS) 
                {
                    Status = DsAddressToSiteNames( pDCInfo->DomainControllerAddress,
                                                   1,
                                                   pSockAddr,
                                                   SiteNames);

                    NetApiBufferFree( pDCInfo );

                    if (Status == ERROR_SUCCESS) 
                    {
                        goto Exit;
                    }
                }
            }
        }

    }
    else
    {

        DFS_TRACE_NORM(REFERRAL_SERVER, "We are a DC Calling GetSiteName locally\n");
        Status = DsAddressToSiteNames(
                            NULL,
                            1,
                            pSockAddr,
                            SiteNames);

    }

    DFS_TRACE_NORM(REFERRAL_SERVER, "Donewith Sites\n");

Exit:

    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGenerateReferralFromReplicaRequest 
//
//  Arguments:  
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Calls DsAddressToSiteNames to get the local site and then gets
//               the referrels for that site
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsGenerateReferralFromReplicaRequest(
    PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest, 
    REFERRAL_HEADER **pReferral)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    REFERRAL_HEADER *pLocalReferral = NULL;
    PDFSSITE_DATA pSiteData = NULL;
    DWORD IpAddress = 0;
    DfsSite *pClientSite = NULL;
    
    unsigned char *IpAddr = (unsigned char *)pGetReplicaRequest->RepInfo.IpData;

    DFS_TRACE_NORM(REFERRAL_SERVER, "Remote referral request from %d:%d:%d:%d\n", 
                   IpAddr[0],                  
                   IpAddr[1],
                   IpAddr[2],
                   IpAddr[3]);

    if(DfsServerGlobalData.IsWorkGroup == FALSE)
    {
        CopyMemory(&IpAddress, IpAddr, sizeof(IpAddress));

        pSiteData = (PDFSSITE_DATA) DfsServerGlobalData.pClientSiteSupport->LookupIpInHash(IpAddress);
        if (pSiteData == NULL)
        {
            DFS_TRACE_LOW(REFERRAL_SERVER, "IP %d:%d:%d:%d not in ClientSite Cache. Calling IpToDfsSite\n",
                            IpAddr[0],                  
                            IpAddr[1],
                            IpAddr[2],
                            IpAddr[3]);

            //
            // Find the DfsSite for this site name.
            // This DfsSite will already be referenced. 
            // This will always succeed because it'll return us the Default Site if
            // all else fail.
            //
            DfsIpToDfsSite(pGetReplicaRequest->RepInfo.IpData,
                         pGetReplicaRequest->RepInfo.IpLength, 
                         pGetReplicaRequest->RepInfo.IpFamily,
                         &pClientSite);

            DFS_TRACE_LOW(REFERRAL_SERVER, "StoreSiteInCache: IP %d:%d:%d:%d maps to DfsSite %p, Name %ws\n",
                IpAddr[0],                  
                IpAddr[1],
                IpAddr[2],
                IpAddr[3], 
                pClientSite,
                pClientSite->SiteNameString());
            //
            // No need to fail the referral just because cache insert failed.
            //
            (VOID) DfsServerGlobalData.pClientSiteSupport->StoreSiteInCache( IpAddress, pClientSite );
        }
        else
        {
            //
            // Cache hit.
            //
            ASSERT( pSiteData->ClientSite );
            pClientSite = pSiteData->ClientSite;
            
            //
            // Be sure to take an extra reference on the DfsSite
            // before dropping the reference on the SiteData structure.
            //
            pClientSite->AcquireReference();   
            DfsServerGlobalData.pClientSiteSupport->ReleaseSiteCacheData( pSiteData );
            DFS_TRACE_LOW(REFERRAL_SERVER, "Cache hit: IP %d:%d:%d:%d maps to DfsSite %p, Name %ws\n",
                IpAddr[0],                  
                IpAddr[1],
                IpAddr[2],
                IpAddr[3], 
                pClientSite,
                pClientSite->SiteNameString());
        }

    }
    else 
    //
    // Workgroups get the default site.
    //
    {
        pClientSite = DfsGetDefaultSite(); 
    }

    //
    // At this point we always have a valid ClientSite. The site name itself may be NULL.
    //
    ASSERT( pClientSite != NULL );
    Status = DfsGenerateReferral( pGetReplicaRequest->RepInfo.LinkName,
                              pClientSite,
                              pGetReplicaRequest->RepInfo.NumReplicasToReturn,
                              pGetReplicaRequest->RepInfo.CostLimit,
                              &pLocalReferral );

    *pReferral = pLocalReferral;

    //
    // We are done with the client site.
    //
    pClientSite->ReleaseReference();
    
    return Status;

}

DFSSTATUS
DfsGenerateReferralBySitenameForTesting(
    LPWSTR LinkName, 
    LPWSTR SiteNameString,  
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsSite *pClientSite = NULL;
    
    Status = DfsGetSiteBySiteName( SiteNameString, &pClientSite );                  
    if (Status == ERROR_SUCCESS)
    {  
        Status = DfsGenerateReferral( LinkName,
                           pClientSite,
                           NumReplicasToReturn,
                           CostLimit,
                           ppReferralHeader );
        if (pClientSite)
            pClientSite->ReleaseReference();
    }

 
    
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsProcessGetReplicaData 
//
//  Arguments:  DataBuffer - Buffer from the FilterDriver
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: Gets the replica information from server
//               and places the results in the given buffer
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsProcessGetReplicaData(HANDLE hDriverHandle, PBYTE DataBuffer)
{
    DFSSTATUS Status = ERROR_INVALID_PARAMETER;
    ULONG ReturnedDataSize = 0;
    REFERRAL_HEADER *pReferral = NULL;
    PUMRX_USERMODE_WORKITEM pProtocolWorkItem = NULL;
    PUMR_GETDFSREPLICAS_REQ pGetReplicaRequest = NULL;

    pProtocolWorkItem = (PUMRX_USERMODE_WORKITEM) DataBuffer;

    //get the request
    pGetReplicaRequest = &pProtocolWorkItem->WorkRequest.GetDfsReplicasRequest;

    //
    // Now generate the referral
    //
    Status = DfsGenerateReferralFromReplicaRequest( pGetReplicaRequest, &pReferral );
    
    //if we were successful in getting the referral list, then
    //we need to process the list.  
    if(Status == ERROR_SUCCESS)
    {
        //if this request came from an old DFS server, process
        //the request accordingly
        if(pGetReplicaRequest->RepInfo.Flags & DFS_OLDDFS_SERVER)
        {
            Status = ProcessOldDfsServerRequest(hDriverHandle, pProtocolWorkItem, pGetReplicaRequest, pReferral, &ReturnedDataSize);
        }
        else
        {
            //else this must be a new DFS server. Just return the info
            ReturnedDataSize = pReferral->TotalSize;

            //RtlCopyMemory(pBuffer, pReferral, ReturnedDataSize);
        }
    }

    //if we were successful, then setup the returned data
    //if(Status == ERROR_SUCCESS)
    //{
      //  ((PUMRX_USERMODE_WORKITEM)(DataBuffer))->WorkResponse.GetDfsReplicasResponse.Length = ReturnedDataSize;
    //}


    if(pReferral != NULL)
    {
        DfsReleaseReferral(pReferral);
        pReferral = NULL;
    }

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsregistryrootfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsRegistryRootFolder.cxx
//
//  Contents:   the Root DFS Folder class for Registry Store
//
//  Classes:    DfsRegistryRootFolder
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include "DfsRegistryRootFolder.hxx"
#include "DfsReplica.hxx"

#include "lmdfs.h"
#include "DfsClusterSupport.hxx"
//
// logging specific includes
//
#include "DfsRegistryRootFolder.tmh" 

//+----------------------------------------------------------------------------
//
//  Class:      DfsRegistryRootFolder
//
//  Synopsis:   This class implements The Dfs Registry root folder.
//
//-----------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Function:   DfsRegistryRootFolder - constructor
//
//  Arguments:    NameContext -  the dfs name context
//                pLogicalShare -  the logical share
//                pParentStore -  the parent store for this root.
//                pStatus - the return status
//
//  Returns:    NONE
//
//  Description: This routine initializes a RegistryRootFolder instance
//
//--------------------------------------------------------------------------
DfsRegistryRootFolder::DfsRegistryRootFolder(
    LPWSTR NameContext,
    LPWSTR pRootRegKeyNameString,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRegistryStore *pParentStore,
    DFSSTATUS *pStatus ) :  DfsRootFolder ( NameContext,
                                            pRootRegKeyNameString,
                                            pLogicalShare,
                                            pPhysicalShare,
                                            DFS_OBJECT_TYPE_REGISTRY_ROOT_FOLDER,
                                            pStatus )
{
    DFSSTATUS Status = *pStatus;

    _pStore = pParentStore;
    if (_pStore != NULL)
    {
        _pStore->AcquireReference();
    }
    _RootFlavor = DFS_VOLUME_FLAVOR_STANDALONE;

    //
    // If the namecontext that we are passed is an emptry string,
    // then we are dealing with the referral server running on the root
    // itself. We are required to ignore the name context for such
    // roots during lookups, so that aliasing works. (Aliasing is where
    // someone may access the root with an aliased machine name or ip
    // address)
    //
    if (IsEmptyString(NameContext) == TRUE)
    {
        SetIgnoreNameContext();
        _LocalCreate = TRUE;
    }

    //
    // dfsdev: If this is cluster resource, we should set the visible name
    // to virtual server name of this resource.
    //
    // The constructor for DfsRootFolder will be called before we
    // get here, and pstatus will be initialized
    //
    if (Status == ERROR_SUCCESS) 
    {
        if (DfsIsMachineCluster())
        {
            DFSSTATUS ClusterStatus;

            ClusterStatus = GetRootClusterInformation( pLogicalShare, 
                                                       &_DfsVisibleContext);
            if (ClusterStatus != ERROR_SUCCESS)
            {
                RtlInitUnicodeString(&_DfsVisibleContext, NULL);
            }
        }
        if (IsEmptyString(_DfsVisibleContext.Buffer))
        {
            Status = DfsGetMachineName( &_DfsVisibleContext );
        }
    }

    *pStatus = Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   Synchronize
//
//  Arguments:    None
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine synchronizes the children folders
//               of this root.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryRootFolder::Synchronize( BOOLEAN fForceSynch, BOOLEAN CalledByApi )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY RootKey = NULL;
    ULONG ChildNum = 0;
    DWORD CchMaxName = 0;
    DWORD CchChildName = 0;
    LPWSTR ChildName = NULL;
    FILETIME LastModifiedTime;
    
    UNICODE_STRING NewClusterName;

    UNREFERENCED_PARAMETER(fForceSynch);

    
    DFS_TRACE_NORM(REFERRAL_SERVER, "Synchronize for %p\n", this);


    RtlInitUnicodeString(&NewClusterName, NULL);

    if (DfsIsMachineCluster())
    {
        DFSSTATUS IgnoreStatus;

        IgnoreStatus = GetRootClusterInformation( GetLogicalShare(),
                                              &NewClusterName);
        ASSERT((IgnoreStatus == ERROR_SUCCESS) ||
                (NewClusterName.Buffer == NULL));
    }


    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    if (NewClusterName.Length != 0)
    {
        DFSSTATUS ClusterNameStatus;
        BOOLEAN Changed = FALSE;
        ClusterNameStatus = SetVisibleContext( &NewClusterName, &Changed );

        //
        // if the cluster information has changed, get rid of cached
        // referral.
        //
        if (ClusterNameStatus == ERROR_SUCCESS)
        {
            if (Changed)
            {
                RemoveReferralData(NULL, NULL);
            }
        }
        DfsFreeUnicodeString(&NewClusterName);

        DFS_TRACE_LOW(REFERRAL_SERVER, "SetVisbleContext, status %x\n", 
                      ClusterNameStatus);
    }

    if (CheckRootFolderSkipSynchronize() == TRUE)
    {
        ReleaseRootLock();
        return ERROR_SUCCESS;
    }


    //
    // now acquire the root share directory. If this
    // fails, we continue our operation: we can continue
    // with synchonize and not create directories.
    // dfsdev:we need to post a eventlog or something when
    // we run into this.
    //
    do 
    {
        DFSSTATUS RootStatus = AcquireRootShareDirectory();

        if(CalledByApi && (RootStatus != ERROR_SUCCESS))
        {
            DFS_TRACE_ERROR_LOW(RootStatus, REFERRAL_SERVER, "Recognize Dfs: Root folder for %p, validate status %x\n",
                                this, RootStatus );
            Status = RootStatus;
            break;
        }

        //
        // if we are in a standby mode, we dont synchronize, till we obtain 
        // ownership again.
        //

        Status = GetMetadataKey( &RootKey );

        if ( Status == ERROR_SUCCESS )
        {

            {
                DFS_METADATA_HANDLE DfsHandle;

                DfsHandle = CreateMetadataHandle(RootKey);

                UpdateLinkInformation( DfsHandle, NULL );

                DestroyMetadataHandle(DfsHandle );
            }

            //
            // Iterate over all our folders to make sure they actually
            // exist in the registry.
            //
            CheckPreSynchronize( RootKey );

            //
            // First find the length of the longest subkey 
            // and allocate a buffer big enough for it.
            //
            Status = RegQueryInfoKey( RootKey,       // Key
                                      NULL,         // Class string
                                      NULL,         // Size of class string
                                      NULL,         // Reserved
                                      NULL,         // # of subkeys
                                      &CchMaxName,  // max size of subkey name in TCHARs
                                      NULL,         // max size of class name
                                      NULL,         // # of values
                                      NULL,         // max size of value name
                                      NULL,    // max size of value data,
                                      NULL,         // security descriptor
                                      NULL );       // Last write time
            if (Status == ERROR_SUCCESS)
            {
                // Space for the NULL terminator.
                CchMaxName++; 

                ChildName = (LPWSTR) new WCHAR [CchMaxName];
                if (ChildName == NULL)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (Status == ERROR_SUCCESS)
            {

                do
                {
                    //
                    // For each child, get the child name.
                    //

                    CchChildName = CchMaxName;

                    Status = RegEnumKeyEx( RootKey,
                                           ChildNum,
                                           ChildName,
                                           &CchChildName,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &LastModifiedTime );

                    ChildNum++;

                    //
                    // Call update on the child. This either adds a new folder
                    // or if it exists, ensure the child folder is upto date.
                    //
                    if ( Status == ERROR_SUCCESS )
                    {
                        DFS_METADATA_HANDLE DfsHandle;

                        DfsHandle = CreateMetadataHandle(RootKey);

                        Status = UpdateLinkInformation( DfsHandle,
                                                        ChildName );

                        DestroyMetadataHandle(DfsHandle );
                    }

                } while ( Status == ERROR_SUCCESS );

                delete [] ChildName;
            }

            if ( Status == ERROR_NO_MORE_ITEMS )
            {
                Status = ERROR_SUCCESS;
            }


            //
            // We are done with synchronize.
            // update the Root folder, so that this root folder may be made 
            // either available or unavailable, as the case may be.
            //
            if (Status == ERROR_SUCCESS)
            {
                SetRootFolderSynchronized();
            }
            else
            {
                ClearRootFolderSynchronized();
            }

            //
            // Now release the Root metadata key.
            //
            ReleaseMetadataKey( RootKey );
        }


        if(CalledByApi && (Status != ERROR_SUCCESS))
        {

          DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Recognize Dfs: Registry Synchronize Root folder for %p, validate status %x\n",
                              this, Status );
          (void) ReleaseRootShareDirectory();
        }

    } while (0);


    DFS_TRACE_NORM(REFERRAL_SERVER, "Synchronize for %p, Status %x\n", this, Status);

    ReleaseRootLock();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsreferral.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsReferral.cxx
//
//  Contents:   This file contains the functionality to generate a referral
//
//
//  History:    Jan 16 2001,   Authors: RohanP/UdayH
//
//-----------------------------------------------------------------------------

#include "DfsReferral.hxx"
#include "Align.h"
#include "dfstrusteddomain.hxx"
#include "dfsadsiapi.hxx"
#include "DfsDomainInformation.hxx"
#include "DomainControllerSupport.hxx"
#include "dfscompat.hxx"

#include "dfsreferral.tmh" // logging

LONG ShuffleFudgeFactor = 0;


extern "C" {
DWORD
I_NetDfsIsThisADomainName(
    IN  LPWSTR                      wszName);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder
//
//  Arguments:  pName - The logical name
//              pRemainingName - the name beyond the root
//              ppRoot       - the Dfs root found.
//
//  Returns:    ERROR_SUCCESS
//              Error code otherwise
//
//
//  Description: This routine runs through all the stores and looks up
//               a root with the matching name context and share name.
//               If multiple stores have the same share, the highest
//               priority store wins (the store registered first is the
//               highest priority store)
//               A referenced root is returned, and the caller is 
//               responsible for releasing the reference.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetRootFolder( 
    IN  PUNICODE_STRING pName,
    OUT PUNICODE_STRING pRemainingName,
    OUT DfsRootFolder **ppRoot )
{

    DFSSTATUS Status;
    UNICODE_STRING DfsNameContext, LogicalShare;

    // First we breakup the name into the name component, the logica
    // share and the rest of the name

    Status = DfsGetPathComponents(pName,
                                  &DfsNameContext,
                                  &LogicalShare,
                                  pRemainingName );

    // If either the name component or the logical share is empty, error.
    //
    if (Status == ERROR_SUCCESS) {
        if ((DfsNameContext.Length == 0) || (LogicalShare.Length == 0)) {
            Status = ERROR_INVALID_PARAMETER;
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        Status = DfsGetRootFolder( &DfsNameContext,
                                   &LogicalShare,
                                   pRemainingName,
                                   ppRoot );
    }

    return Status;
}


DFSSTATUS
DfsGetRootFolder(
    IN PUNICODE_STRING pNameContext,
    IN PUNICODE_STRING pLogicalShare,
    IN PUNICODE_STRING pRemains,
    OUT DfsRootFolder **ppRoot )
{
    DFSSTATUS Status;
    DfsStore *pStore;

    UNREFERENCED_PARAMETER(pRemains);

    // Assume we are not going to find a root.
    //
    Status = ERROR_NOT_FOUND;

    //
    // For each store registered, see if we find a matching root. The
    // first matching root wins.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {


        Status = pStore->LookupRoot( pNameContext,
                                     pLogicalShare,
                                     ppRoot );
        if (Status == ERROR_SUCCESS) {
            break;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsGetRootFolder
//
//  Arguments:  pName - The logical name
//              pRemainingName - the name beyond the root
//              ppRoot       - the Dfs root found.
//
//  Returns:    ERROR_SUCCESS
//              Error code otherwise
//
//
//  Description: This routine runs through all the stores and looks up
//               a root with the matching name context and share name.
//               If multiple stores have the same share, the highest
//               priority store wins (the store registered first is the
//               highest priority store)
//               A referenced root is returned, and the caller is 
//               responsible for releasing the reference.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetOnlyRootFolder( 
    OUT DfsRootFolder **ppRoot )
{
    DfsStore *pStore;
    DFSSTATUS Status;
    DfsStore *pFoundStore = NULL;
    ULONG RootCount;
    // Assume we are not going to find a root.
    //
    Status = ERROR_NOT_FOUND;

    //
    // For each store registered, see if we find a matching root. The
    // first matching root wins.
    //
    for (pStore = DfsServerGlobalData.pRegisteredStores;
         pStore != NULL;
         pStore = pStore->pNextRegisteredStore) {

        Status = pStore->GetRootCount(&RootCount);

        if (Status == ERROR_SUCCESS)
        {
            if ((RootCount > 1) ||
                (RootCount && pFoundStore))
            {
                Status = ERROR_DEVICE_NOT_AVAILABLE;
                break;
            }

            if (RootCount == 1)
            {
                pFoundStore = pStore;
            }
        }
        else
        {
            break;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if (pFoundStore == NULL)
        {
            Status = ERROR_NOT_FOUND;
        }
    }
    if (Status == ERROR_SUCCESS)
    {
        Status = pFoundStore->FindFirstRoot( ppRoot );
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupFolder
//
//  Arguments:  pName  - name to lookup
//              pRemainingName - the part of the name that was unmatched
//              ppFolder - the folder for the matching part of the name.
//
//  Returns:    ERROR_SUCCESS
//              ERROR code otherwise
//
//  Description: This routine finds the folder for the maximal path
//               that can be matched, and return the referenced folder
//               along with the remaining part of the name that had
//               no match.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsLookupFolder( 
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolder **ppFolder )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    DfsRootFolder *pRoot = NULL;
    DfsFolder *pFolder = NULL;
    UNICODE_STRING LinkName, Remaining;
    UNICODE_STRING LongName;
    UNICODE_STRING NotUsed;

    DFS_TRACE_LOW( REFERRAL, "DfsLookupFolder Name %wZ\n", pName);

    LongName.Length = LongName.MaximumLength = 0;
    LongName.Buffer = NULL;

    //
    // Get a root folder
    //
    Status = DfsGetRootFolder( pName,
                               &LinkName,
                               &pRoot );

    DFS_TRACE_ERROR_LOW( Status, REFERRAL, "get referral data, lookup folder %p, Status %x\n",
                         pRoot, Status);
    if (Status == ERROR_SUCCESS)
    {
        //
        // we now check if the root folder is available for referral
        // requests. If not, return error.
        //
        if (pRoot->IsRootFolderAvailableForReferral() == FALSE)
        {
            Status = ERROR_DEVICE_NOT_AVAILABLE;
            pRoot->ReleaseReference();
        }
    }

    //
    // If we got a root folder, see if there is a link that matches
    // the rest of the name beyond the root.
    //
    if (Status == ERROR_SUCCESS) {
        if (LinkName.Length != 0) {
            Status = pRoot->LookupFolderByLogicalName( &LinkName,
                                                       &Remaining,
                                                       &pFolder );
            if(Status == ERROR_NOT_FOUND)
            {
                //see if it's a short name, in the short name 
                //case, we have to calculate the remaining name
                //ourselves
                Status = pRoot->ExpandShortName(&LinkName,
                                                &LongName,
                                                &Remaining);
                if(Status == ERROR_SUCCESS)
                {
                    //NotUsed just takes the place of Remaining
                    //since it's really not used here
                    Status = pRoot->LookupFolderByLogicalName( &LongName,
                                                               &NotUsed,
                                                               &pFolder );
                }

                pRoot->FreeShortNameData(&LongName);
            }
        } 
        else {
            Status = ERROR_NOT_FOUND;

        }

        //
        // If no link was found beyond the root, we are interested
        // in the root folder itself. Return the root folder. 
        // If we did find a link, we have a referenced link folder.
        // Release the root and we are done.
        //
        if (Status == ERROR_NOT_FOUND) {
            pFolder = pRoot;
            Remaining = LinkName;
            Status = ERROR_SUCCESS;                
        }
        else {
            pRoot->ReleaseReference();
        }
    }

    if (Status == ERROR_SUCCESS) {
        *ppFolder = pFolder;
        *pRemainingName = Remaining;
    }


    DFS_TRACE_ERROR_NORM(Status, REFERRAL, "DfsLookupFolder Exit %x name %wZ\n",
                         Status, pName);
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetReferralData
//
//  Arguments:  pName - name we are interested in.
//              pRemainingName - the name that was unmatched.
//              ppReferralData - the referral data for the matching portion.
//
//  Returns:    ERROR_SUCCESS
//              error code otherwise
//
//
//  Description: This routine looks up the folder for the passed in name,
//               and loads the referral data for the folder and returns
//               a referenced FolderReferralData to the caller.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsGetReferralData( 
    PUNICODE_STRING pName,
    PUNICODE_STRING pRemainingName,
    DfsFolderReferralData **ppReferralData,
    PBOOLEAN pCacheHit )
{
    DFSSTATUS Status;
    DfsFolder *pFolder;
    BOOLEAN CacheHit = FALSE;

    DFS_TRACE_LOW( REFERRAL, "DfsGetReferralData Name %wZ\n", pName);

    Status = DfsLookupFolder( pName,
                              pRemainingName,
                              &pFolder );
    DFS_TRACE_ERROR_LOW( Status, REFERRAL, "get referral data, lookup folder %p, Status %x\n",
                         pFolder, Status);
    
    if (Status == ERROR_SUCCESS) {

        Status = pFolder->GetReferralData( ppReferralData,
                                           &CacheHit );

        DFS_TRACE_LOW(REFERRAL, "Loaded %p Status %x\n",  *ppReferralData, Status );

        pFolder->ReleaseReference();
    }

    if (pCacheHit != NULL)
    {
        *pCacheHit = CacheHit;
    }
    
    DFS_TRACE_ERROR_LOW( Status, REFERRAL, "DfsGetReferralData Name %wZ Status %x\n",
                         pName, Status );

    return Status;
}

/*
ULONG
DfsGetInterSiteCost(
    PUNICODE_STRING pSiteFrom,
    PUNICODE_STRING pSiteTo)
{
    ULONG Cost = 100;

    if ((IsEmptyString(pSiteFrom->Buffer) == FALSE) && 
        (IsEmptyString(pSiteTo->Buffer) == FALSE))
    {
        if (RtlEqualUnicodeString(pSiteFrom, pSiteTo, TRUE ))
        {
            Cost = 0;
        }
    }

    return Cost;
}
*/


VOID
DfsShuffleReplicas(
    REPLICA_COST_INFORMATION * pReplicaCosts,
    ULONG       nStart,
    ULONG       nEnd)
{
    ULONG i = 0;
    ULONG j = 0;
    ULONG nRemaining = 0;
    ULONG CostTemp = 0;
    LONG  NewFactor = 0;
    DfsReplica * pTempReplica = NULL;
    LARGE_INTEGER Seed;

    for (i = nStart; i < nEnd; i++) 
    {
        NtQuerySystemTime( &Seed );
        NewFactor = InterlockedIncrement(&ShuffleFudgeFactor);

        Seed.LowPart += (NewFactor + GetTickCount());


        DFS_TRACE_LOW(REFERRAL, "Shuffling %d to %d, seed %d (%x)\n",
                      nStart, nEnd, Seed.LowPart, Seed.LowPart );

        //
        // Exchange the current entry with one in the remaining portion.
        // Make sure the entry doesn't get swapped with itself.
        //
        j = (RtlRandomEx( &Seed.LowPart ) % (nEnd - i)) + i;

        //
        // Give up.
        //
        if (j == i)
        {
            DFS_TRACE_LOW(REFERRAL_SERVER, "NOT Shuffling %d with %d\n",
                      i, j);
            continue;
        }
        DFS_TRACE_LOW(REFERRAL_SERVER, "Shuffling %d with %d\n",
                      i, j);
                      
        CostTemp = (&pReplicaCosts[i])->ReplicaCost;
        pTempReplica = (&pReplicaCosts[i])->pReplica;

        (&pReplicaCosts[i])->pReplica = (&pReplicaCosts[j])->pReplica;
        (&pReplicaCosts[i])->ReplicaCost = (&pReplicaCosts[j])->ReplicaCost;

        (&pReplicaCosts[j])->pReplica = pTempReplica;
        (&pReplicaCosts[j])->ReplicaCost = CostTemp;

    }
    DFS_TRACE_LOW(REFERRAL, "Shuffling done\n");
}

VOID
DfsSortReplicas(
    REPLICA_COST_INFORMATION * pReplicaCosts, 
    ULONG NumReplicas)
{
    LONG LoopVar = 0;
    LONG InnerLoop = 0;
    ULONG CostTemp = 0;
    DfsReplica * pTempReplica = NULL;

    for (LoopVar = 1; LoopVar < (LONG) NumReplicas; LoopVar++)
    {       
        CostTemp = (&pReplicaCosts[LoopVar])->ReplicaCost;
        pTempReplica = (&pReplicaCosts[LoopVar])->pReplica;     

        for(InnerLoop = LoopVar - 1; InnerLoop >= 0; InnerLoop--)
        {
            if((&pReplicaCosts[InnerLoop])->ReplicaCost > CostTemp)
            {
                (&pReplicaCosts[InnerLoop + 1])->ReplicaCost = (&pReplicaCosts[InnerLoop])->ReplicaCost;
                (&pReplicaCosts[InnerLoop + 1])->pReplica = (&pReplicaCosts[InnerLoop])->pReplica;          
            }
            else
            {
                break;
            }
        
        }

        (&pReplicaCosts[InnerLoop + 1])->ReplicaCost = CostTemp;
        (&pReplicaCosts[InnerLoop + 1])->pReplica = pTempReplica;                   
    }   
}


VOID
DfsShuffleAndSortReferralInformation(
    PREFERRAL_INFORMATION pReferralInformation )
{
    DfsShuffleReplicas( &pReferralInformation->ReplicaCosts[0], 0, pReferralInformation->NumberOfReplicas);
    DfsSortReplicas( &pReferralInformation->ReplicaCosts[0], pReferralInformation->NumberOfReplicas);
}

VOID
DfsGetDefaultInterSiteCost(
    IN DfsSite *pReferralSite,
    IN DfsReplica *pReplica,
    OUT PULONG pCost)
{
    pReferralSite->GetDefaultSiteCost( pReplica->GetSite(), pCost );
    return;
}


VOID
DfsReleaseReferralInformation(
    PREFERRAL_INFORMATION pReferralInfo )
{
    delete [] (PBYTE)(pReferralInfo);

    return NOTHING;
}

DFSSTATUS
DfsGetDsInterSiteCost(
    IN DfsSite *pReferralSite,
    IN DfsReferralData *pReferralData,
    IN DfsReplica *pReplica,
    IN OUT PBOOLEAN pRetry,
    OUT PULONG pCost)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN CostMatrixGenerated = *pRetry;
    BOOLEAN UseDefault = FALSE;
    DFSSTATUS RetStatus = ERROR_SUCCESS;
    
    //
    // Lookup the cost of going from the ReferralSite to the Replica Site
    // in our cache. 
    //                                            
    Status = pReferralSite->GetRealSiteCost( pReplica->GetSite(), pCost );
                                       
    // Try only once.
    if (CostMatrixGenerated)
    {
        *pRetry = FALSE;
    }

    // Ruminate over our choices based on what GetCost returned.
    do {
    
        if (Status == ERROR_SUCCESS)
        {
            // we are all set
            *pRetry = FALSE;
            break;
        }

        // We can get memory allocation failures at this point.
        if (CostMatrixGenerated || Status != ERROR_NOT_FOUND)
        {
            // 
            // We've tried generating the inter-site cost once, but still
            // we haven't been able to find what we need. So use the default scheme.
            //
            UseDefault = TRUE;
            break;
        }
       
        // We try to generate the cost matrix at most once per referral.
        // This is the first time around.
        
        ASSERT(Status == ERROR_NOT_FOUND);
        ASSERT(CostMatrixGenerated == FALSE);
 
        Status = pReferralData->GenerateCostMatrix( pReferralSite );

        //
        // If our call to the DS failed, then we just have to fall back on our default.
        //
        if (Status != ERROR_SUCCESS)
        {
            UseDefault = TRUE;
            RetStatus = Status;
            break;
        } 

        // Caller needs to iterate over all the referrals again.
        *pRetry = TRUE; 
        
    } while (FALSE);

    //
    // Somehow we haven't been able to find the real inter-site cost.
    // Use the default cost. This call won't fail.
    //
    if (UseDefault)
    {
        *pRetry = FALSE;
        pReferralSite->GetDefaultSiteCost( pReplica->GetSite(), pCost );
    }

    // 
    // The only errors that we propogate back are those we get from the DS.
    // They indicate that the cost matrix didn't get generated so we know not
    // to retry this call for all the link targets.
    //
    return RetStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsGetReferralInformation
//
//  Arguments:  pReferralData - the referral data
//              NumReplicasToReturn - Number of replicas to return
//
//  Returns:    ERROR_SUCCESS
//              ERROR_NOT_ENOUGH_MEMORY
//
//
//  Description: This routine generates the cost of reaching each replica
//               
//               
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsGetReferralInformation(
    PUNICODE_STRING pUseTargetServer,
    PUNICODE_STRING pUseFolder,
    DfsSite *pReferralSite,
    DfsReferralData *pReferralData,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    PREFERRAL_INFORMATION *ppReferralInformation )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NumReplicas = 0;
    ULONG TotalSize =0;
    ULONG SizeOfStrings = 0;
    ULONG Cost = 0;
    DfsReplica *pReplica = NULL;
    PREFERRAL_INFORMATION pReferralInfo = NULL;
    BOOLEAN IsSiteCostingEnabled = FALSE;
    BOOLEAN Retrying = FALSE;
    BOOLEAN DsErrorHit = FALSE;
    BOOLEAN DomainReplica = FALSE;
    
    //
    // Give out Insite referrals only, if we are not pointing to
    // an interlink with a single target (this is a clue to us that
    // this is a potential domain DFS, where insite does not make
    // sense)
    //

    if (pReferralData->IsOutOfDomain() && (pReferralData->ReplicaCount == 1))
    {
        pReplica = &pReferralData->pReplicas[ 0 ];
        if (pReplica->IsTargetAvailable())
        {
            PUNICODE_STRING pServer = NULL;
            DFSSTATUS DomainStatus = ERROR_SUCCESS;

            pServer = pReplica->GetTargetServer();
            
            DomainStatus = I_NetDfsIsThisADomainName(pServer->Buffer);
            if (DomainStatus == ERROR_SUCCESS)
            {
                DomainReplica = TRUE;
            }
        }
    }

    if (DomainReplica == FALSE)
    {
        if (pReferralData->IsRestrictToSite())
        {
            CostLimit = 0;
        }

        IsSiteCostingEnabled = pReferralData->DoSiteCosting;
    }
    
    //allocate the buffer
    TotalSize = sizeof(REFERRAL_INFORMATION) + (pReferralData->ReplicaCount * sizeof(REPLICA_COST_INFORMATION));
    pReferralInfo = (PREFERRAL_INFORMATION) new BYTE[TotalSize];

    DFS_TRACE_LOW(REFERRAL, "Client Site %wZ\n", pReferralSite->SiteName());

    if (pReferralInfo == NULL) 
    {
        *ppReferralInformation = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    //
    // Make sure the site is ready to receive data. This means it is not
    // going to throw its SiteCostCache away while we are trying to add to it, or 
    // read from it. This is a NO-OP when site costing is disabled.
    //
    pReferralSite->StartPrepareForCostGeneration( IsSiteCostingEnabled );
    
    do {
    
        RtlZeroMemory(pReferralInfo, TotalSize);
        pReferralInfo->pUseTargetServer = pUseTargetServer;
        pReferralInfo->pUseTargetFolder = pUseFolder;
        DsErrorHit = FALSE;
        
        for (NumReplicas = 0; NumReplicas < pReferralData->ReplicaCount; NumReplicas++)
        {
            pReplica = &pReferralData->pReplicas[ NumReplicas ];
            if (pReplica->IsTargetAvailable() == FALSE)
            {
                continue;
            }

            if (!IsSiteCostingEnabled || DsErrorHit)
            {
                // The cost is going to be either Zero or ULONG_MAX.
                DfsGetDefaultInterSiteCost(pReferralSite,
                                        pReplica,
                                        &Cost);
                ASSERT(Retrying == FALSE);
                ASSERT(Status == ERROR_SUCCESS);
            } 
            else 
            {    
                //
                // Find the cost between the referral site and this potential destination replica.
                // If Site-Costing is turned on, we attempt to get the intersite cost from
                // our site-cost cache(s). If the information isn't cached we try to get the cost matrix
                // from an ISTG nearby. The protocol here is to RETRY this entire loop just once
                // if the DfsGetInterSiteCost call below returns Retrying = TRUE.
                //
                if (DfsGetDsInterSiteCost(pReferralSite,
                                    pReferralData,
                                    pReplica,
                                    &Retrying,
                                    &Cost) != ERROR_SUCCESS)
                {
                    //
                    // Remember the fact that we got an error trying to generate
                    // the cost matrix. This way we won't try to do this DS call
                    // for every replica. However, it is entirely possible for another
                    // thread to try to generate the cost in the meantime.
                    //
                    DsErrorHit = TRUE;
                    ASSERT(Retrying == FALSE);
                }
                
                //
                // If we don't find this, then we know we should retry.
                // So start this all over again. 
                // We only retry once. 
                //
                if (Retrying)
                {
                    DFS_TRACE_LOW(REFERRAL, "Intersite cost for <%ws, %ws> not found. Retrying the referral\n",
                                    pReferralSite->SiteNameString(),
                                    pReplica->GetSite()->SiteNameString());
                    break;
                }
            }
            
            
            DFS_TRACE_LOW(REFERRAL, "REplica %wZ, Inter site <%ws, %ws> Cost %d (Limit = %d)\n",
                          pReplica->GetTargetServer(),
                          pReferralSite->SiteNameString(),
                          pReplica->GetSite()->SiteNameString(),
                          Cost,
                          CostLimit);
            if (Cost <= CostLimit)
            {
                PUNICODE_STRING pTargetServer = (pUseTargetServer == NULL)? pReplica->GetTargetServer() : pUseTargetServer;
                PUNICODE_STRING pTargetFolder = (pUseFolder == NULL) ? pReplica->GetTargetFolder() : pUseFolder;

                pReferralInfo->ReplicaCosts[pReferralInfo->NumberOfReplicas].ReplicaCost = Cost;
                pReferralInfo->ReplicaCosts[pReferralInfo->NumberOfReplicas].pReplica = pReplica;

                SizeOfStrings = (sizeof(UNICODE_PATH_SEP) +
                                 pTargetServer->Length +                                                               
                                 sizeof(UNICODE_PATH_SEP) +
                                 pTargetFolder->Length );

                SizeOfStrings = ROUND_UP_COUNT(SizeOfStrings, ALIGN_LONG);

                pReferralInfo->TotalReplicaStringLength += SizeOfStrings;
                pReferralInfo->NumberOfReplicas++; 
            }
        }
        
    } while (Retrying);
    
    pReferralSite->EndPrepareForCostGeneration( IsSiteCostingEnabled );


    if (Status == ERROR_SUCCESS)
    {
        if (pReferralInfo->NumberOfReplicas > 1)
        {
            DfsShuffleAndSortReferralInformation( pReferralInfo );
        }
        if (pReferralInfo->NumberOfReplicas > NumReplicasToReturn)
        {
            pReferralInfo->NumberOfReplicas = NumReplicasToReturn;
        }
    
        *ppReferralInformation = pReferralInfo;

        {
            ULONG i;
            DFS_TRACE_LOW(REFERRAL, "Final Referral for Client Site %ws offline status is %ws\n", pReferralSite->SiteNameString(),
                          (pReferralData->FolderOffLine == TRUE) ? L"OFFLINE":L"ONLINE" );

            for (i=0 ; i<pReferralInfo->NumberOfReplicas; i++)
            {
                DFS_TRACE_LOW(REFERRAL, "%d. Target %wZ, Site %ws, Cost %d\n",
                               i, 
                               pReferralInfo->ReplicaCosts[i].pReplica->GetTargetServer(),
                               pReferralInfo->ReplicaCosts[i].pReplica->GetSite()->SiteNameString(),
                               pReferralInfo->ReplicaCosts[i].ReplicaCost);
            }
        }
    } else {
    
        DfsReleaseReferralInformation( pReferralInfo );
        *ppReferralInformation = NULL;
    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsExtractReplicaData -
//
//  Arguments:  pReferralData - the referral data
//              NumReplicasToReturn - Number of replicas to return
//              CostLimit - maximum cost caller is willing to accept
//              Name - link name
//              pReplicaCosts - array of replicas with cost info
//              ppReferralHeader - address of buffer to accept replica info
//
//  Returns:    Status
//               ERROR_SUCCESS 
//               ERROR_NOT_ENOUGH_MEMORY
//               others
//
//
//  Description: This routine formats the replicas into the format
//               the client expects. Which is a REFERRAL_HEADER followed
//               by an array of REPLICA_INFORMATIONs
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsExtractReferralData(
    PUNICODE_STRING pName,
    PREFERRAL_INFORMATION pReferralInformation,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NumReplicas = 0;
    ULONG TotalSize = 0;
    ULONG HeaderBaseLength = 0;
    ULONG BaseLength = 0;
    ULONG LinkNameLength = 0;
    PREFERRAL_HEADER pHeader = NULL;
    ULONG CurrentNameLength =0;
    ULONG CurrentEntryLength = 0;
    ULONG NextEntry = 0;
    DfsReplica *pReplica = NULL;
    PUNICODE_STRING pUseTargetFolder = pReferralInformation->pUseTargetFolder;
    PUNICODE_STRING pUseTargetServer = pReferralInformation->pUseTargetServer;
    PUCHAR ReferralBuffer = NULL;
    PUCHAR pReplicaBuffer = NULL;
    PWCHAR ReturnedName = NULL;
    PUNICODE_STRING pTargetServer = NULL;
    PUNICODE_STRING pTargetFolder = NULL;

    DFS_TRACE_LOW(REFERRAL, "Entering DfsExtractReferralData");

    //calculate size of header base structure
    HeaderBaseLength = FIELD_OFFSET( REFERRAL_HEADER, LinkName[0] );

    //calculate link name
    LinkNameLength = pName->Length;

    //calculate size of base replica structure
    BaseLength = FIELD_OFFSET( REPLICA_INFORMATION, ReplicaName[0] );

    //the total size of the data to be returned is the sum of all the
    //above calculated sizes
    TotalSize = ROUND_UP_COUNT((HeaderBaseLength + LinkNameLength), ALIGN_LONG) + 
                (pReferralInformation->NumberOfReplicas * ROUND_UP_COUNT(BaseLength, ALIGN_LONG)) + 
                pReferralInformation->TotalReplicaStringLength + 
                sizeof(DWORD);  // null termination at the end.

    //allocate the buffer
    ReferralBuffer = new BYTE[ TotalSize ];
    if (ReferralBuffer != NULL)
    {
        RtlZeroMemory( ReferralBuffer, TotalSize );

        pHeader = (PREFERRAL_HEADER) ReferralBuffer;
        pHeader->VersionNumber = CURRENT_DFS_REPLICA_HEADER_VERSION;
        pHeader->ReplicaCount = pReferralInformation->NumberOfReplicas;
        pHeader->OffsetToReplicas = ROUND_UP_COUNT((HeaderBaseLength + LinkNameLength), ALIGN_LONG);
        pHeader->LinkNameLength = LinkNameLength;
        pHeader->TotalSize = TotalSize;
        pHeader->ReferralFlags = 0;

        //copy the link name at the end of the header
        RtlCopyMemory(&ReferralBuffer[HeaderBaseLength], pName->Buffer, LinkNameLength);

        //place the replicas starting here
        pReplicaBuffer = (PUCHAR) ((PBYTE)ReferralBuffer + pHeader->OffsetToReplicas);

        //format the replicas in the output buffer
        for ( NumReplicas = 0; NumReplicas < pReferralInformation->NumberOfReplicas ; NumReplicas++ )
        {
            NextEntry += (ULONG)( CurrentEntryLength );
            pReplica = pReferralInformation->ReplicaCosts[NumReplicas].pReplica;

            pTargetServer = (pUseTargetServer == NULL) ? pReplica->GetTargetServer() : pUseTargetServer;

            pTargetFolder = (pUseTargetFolder == NULL) ? pReplica->GetTargetFolder() : pUseTargetFolder;

         
            CurrentNameLength = 0;
            ReturnedName = (PWCHAR) &pReplicaBuffer[NextEntry + BaseLength];

            //
            // Start with the leading path seperator
            //
            ReturnedName[ CurrentNameLength / sizeof(WCHAR) ] = UNICODE_PATH_SEP;
            CurrentNameLength += sizeof(UNICODE_PATH_SEP);

            //
            // next copy the server name.
            //
            RtlMoveMemory( &ReturnedName[ CurrentNameLength / sizeof(WCHAR) ],
                           pTargetServer->Buffer, 
                           pTargetServer->Length);
            CurrentNameLength += pTargetServer->Length;

            if (pTargetFolder->Length > 0)
            {
                //
                // insert the unicode path seperator.
                //

                ReturnedName[ CurrentNameLength / sizeof(WCHAR) ] = UNICODE_PATH_SEP;
                CurrentNameLength += sizeof(UNICODE_PATH_SEP);

                RtlMoveMemory( &ReturnedName[ CurrentNameLength / sizeof(WCHAR) ],
                               pTargetFolder->Buffer, 
                               pTargetFolder->Length);
                CurrentNameLength += pTargetFolder->Length;
            }
            ((PREPLICA_INFORMATION)&pReplicaBuffer[NextEntry])->ReplicaFlags = pReplica->GetReplicaFlags();
            ((PREPLICA_INFORMATION)&pReplicaBuffer[NextEntry])->ReplicaCost = pReferralInformation->ReplicaCosts[NumReplicas].ReplicaCost;
            ((PREPLICA_INFORMATION)&pReplicaBuffer[NextEntry])->ReplicaNameLength = CurrentNameLength;

            CurrentEntryLength = ROUND_UP_COUNT((CurrentNameLength + BaseLength), ALIGN_LONG);
 
            //setup the offset to the next entry
            *((PULONG)(&pReplicaBuffer[NextEntry])) = pHeader->OffsetToReplicas + NextEntry + CurrentEntryLength;
        }
        *((PULONG)(&pReplicaBuffer[NextEntry])) = 0;
    }
    else 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (Status == ERROR_SUCCESS)
    {
        *ppReferralHeader = pHeader;
    }


    DFS_TRACE_ERROR_HIGH(Status, REFERRAL, "Leaving DfsExtractReferralData, Status %x",
                         Status);

    return Status;
}



DFSSTATUS
DfsGenerateReferralFromData(
    PUNICODE_STRING pName,
    PUNICODE_STRING pUseTargetServer,
    PUNICODE_STRING pUseFolder,
    DfsSite *pSite,
    DfsReferralData *pReferralData,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status;
    REFERRAL_INFORMATION *pReferralInformation;

    //make sure the user doesn't over step his bounds
    if( (NumReplicasToReturn > pReferralData->ReplicaCount) ||
        (NumReplicasToReturn == 0) )
    {
        NumReplicasToReturn = pReferralData->ReplicaCount;
    }

    Status = DfsGetReferralInformation( pUseTargetServer,
                                        pUseFolder,
                                        pSite,
                                        pReferralData, 
                                        NumReplicasToReturn, 
                                        CostLimit,
                                        &pReferralInformation );
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsExtractReferralData( pName, 
                                         pReferralInformation,
                                         ppReferralHeader);         

        if(Status == STATUS_SUCCESS)
        {
         (*ppReferralHeader)->Timeout = pReferralData->Timeout;
        }

        DfsReleaseReferralInformation( pReferralInformation );
    }

    return Status;
}



DFSSTATUS 
DfsGenerateADBlobReferral(
    PUNICODE_STRING pName,
    PUNICODE_STRING pShare,
    DfsSite *pReferralSite,
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status;
    DfsReferralData *pReferralData;
    UNICODE_STRING ShareName;

    Status = DfsCreateUnicodeString( &ShareName, pShare );

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGetADRootReferralData( pName,
                                           &pReferralData );

        DfsFreeUnicodeString( &ShareName );
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsGenerateReferralFromData( pName,
                                                  NULL,
                                                  NULL,
                                                  pReferralSite,
                                                  pReferralData,
                                                  NumReplicasToReturn,
                                                  CostLimit,
                                                  ppReferralHeader );
            if (Status == ERROR_SUCCESS)
            {
                (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_ROOT_REFERRAL;
            }
            pReferralData->ReleaseReference();
        }

    }

    return Status;
}


DFSSTATUS 
DfsGenerateDomainDCReferral(
    PUNICODE_STRING pDomainName,
    DfsSite *pReferralSite, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pReferralData = NULL;
    BOOLEAN CacheHit;
    DfsDomainInformation *pDomainInfo;

    DFS_TRACE_LOW( REFERRAL, "DfsGenerateDomainDcReferral for Domain %wZ\n",
                    pDomainName);


    Status = DfsAcquireDomainInfo( &pDomainInfo );
    if (Status == ERROR_SUCCESS)
    {
        Status = pDomainInfo->GetDomainDcReferralInfo( pDomainName,
                                                       &pReferralData,
                                                       &CacheHit );

        DfsReleaseDomainInfo (pDomainInfo );
    }
                                             

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGenerateReferralFromData( pDomainName,
                                              NULL,
                                              NULL,
                                              pReferralSite,
                                              pReferralData,
                                              NumReplicasToReturn,
                                              CostLimit,
                                              ppReferralHeader );

        if (Status == ERROR_SUCCESS)
        {
            (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_DOMAIN_DC_REFERRAL;   
        }

        pReferralData->ReleaseReference();
    }
    return Status;
}




DFSSTATUS 
DfsGenerateNormalReferral(
    LPWSTR LinkName, 
    DfsSite *pSite, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolderReferralData *pReferralData = NULL;
    BOOLEAN CacheHit = TRUE;
    DFSSTATUS GetStatus = ERROR_SUCCESS;
    PUNICODE_STRING pUseTargetServer = NULL;
    UNICODE_STRING ServerComponent, ShareComponent, RemainingName;
    DfsRootFolder *pRoot = NULL;
    UNICODE_STRING LinkRemains;
    UNICODE_STRING Name, Remaining;
    
    ULONG StartTime, EndTime;


    DFS_TRACE_LOW( REFERRAL, "DfsGenerateReferral for Link %ws\n",
                    LinkName);

    DfsGetTimeStamp( &StartTime );
    
    Status = DfsRtlInitUnicodeStringEx(&Name, LinkName);
    if (Status != ERROR_SUCCESS)
    {
      goto done;
    }

    Status = DfsGetReferralData( &Name,
                                 &Remaining,
                                 &pReferralData,
                                 &CacheHit );

    //
    // DFSDEV: this is necessary to support clusters: the api request will
    // neveer come to the dfs server when the VS name has failed.
    // The cluster service retries the api request with the machine name,
    // the dfs api still goes to the vs name due to the way we pack the
    // referral: this special cases clusters.
    // if the request comes in with a machine name, return the machine
    // name.
    //

    if ((Status == ERROR_SUCCESS) &&
        DfsIsMachineCluster())
    {
        Status = DfsGetPathComponents( &Name,
                                       &ServerComponent,
                                       &ShareComponent,
                                       &RemainingName );
        if ((Status == ERROR_SUCCESS) &&
            (RemainingName.Length == 0))
        {
            UNICODE_STRING MachineName;

            Status = DfsGetMachineName( &MachineName );
            if (Status == ERROR_SUCCESS) 
            {
                if ( (ServerComponent.Length == MachineName.Length) &&
                     (_wcsnicmp( ServerComponent.Buffer, 
                                 MachineName.Buffer, 
                                 MachineName.Length/sizeof(WCHAR)) == 0) )
                {
                    pUseTargetServer = &ServerComponent;
                }
                DfsReleaseMachineName( &MachineName);
            }
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        Name.Length -= Remaining.Length;
        if (Name.Length && (Name.Buffer[(Name.Length/sizeof(WCHAR)) - 1] == UNICODE_PATH_SEP)) 
        {
            Name.Length -= sizeof(WCHAR);
        }
        
        Status = DfsGenerateReferralFromData( &Name,
                                              pUseTargetServer,
                                              NULL,
                                              pSite,
                                              pReferralData,
                                              NumReplicasToReturn,
                                              CostLimit,
                                              ppReferralHeader);

        if (Status == ERROR_SUCCESS)
        {
            if (pReferralData->IsRootReferral())
            {
                (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_ROOT_REFERRAL;
            }
            if (pReferralData->IsOutOfDomain()) 
            {
                (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_OUT_OF_DOMAIN;
            }
        }

        pReferralData->ReleaseReference();          
    }

    DfsGetTimeStamp( &EndTime );


    //
    // Get a root folder
    //
    GetStatus = DfsGetRootFolder( &Name,
                                  &LinkRemains,
                                  &pRoot );

    if (GetStatus == ERROR_SUCCESS)
    {

        pRoot->pStatistics->UpdateReferralStat( CacheHit,
                                                EndTime - StartTime,
                                                Status );
        pRoot->ReleaseReference();
    }

done:

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL, "DfsGenerateReferral for Link %ws CacheHit %d Status %x\n",
                          LinkName, CacheHit, Status);

    return Status;  
}


DFSSTATUS 
DfsGenerateSpecialShareReferral(
    PUNICODE_STRING pName,
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    DfsSite *pSite, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReferralData *pReferralData = NULL;
    BOOLEAN CacheHit;
    DfsDomainInformation *pDomainInfo;

    DFS_TRACE_LOW( REFERRAL, "DfsGenerateDomainDcReferral for Domain %wZ\n",
                    pDomainName);


    Status = DfsAcquireDomainInfo( &pDomainInfo );
    if (Status == ERROR_SUCCESS)
    {
        Status = pDomainInfo->GetDomainDcReferralInfo( pDomainName,
                                                       &pReferralData,
                                                       &CacheHit );

        DfsReleaseDomainInfo (pDomainInfo );
    }
                                             

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsGenerateReferralFromData( pName,
                                              NULL,
                                              pShareName,
                                              pSite,
                                              pReferralData,
                                              NumReplicasToReturn,
                                              CostLimit,
                                              ppReferralHeader );

        //
        // Do not enable this ROOT_REFERRAL for special shares.
        // These are not treated as normal DFS shares, and for compat
        // purposes, it is necessary that this flag be turned off.
        //
        //
        //        if (Status == ERROR_SUCCESS) {
        //          (*ppReferralHeader)->ReferralFlags |= DFS_REFERRAL_DATA_ROOT_REFERRAL;
        //        }

        pReferralData->ReleaseReference();
    }
    return Status;
}

DFSSTATUS 
DfsGenerateDcReferral(
    LPWSTR LinkNameString, 
    DfsSite *pReferralSite, 
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsDomainInformation *pDomainInfo = NULL;
    UNICODE_STRING NameContext;
    UNICODE_STRING ShareName;
    UNICODE_STRING RemainingName;
    UNICODE_STRING LinkName;

    Status = DfsRtlInitUnicodeStringEx( &LinkName, LinkNameString );
    if (Status != ERROR_SUCCESS)
    {
       goto done;
    }

    RtlInitUnicodeString(&NameContext, NULL);

    if (LinkName.Length > 0)
    {
        Status = DfsGetPathComponents( &LinkName, 
                                       &NameContext,
                                       &ShareName,
                                       &RemainingName );
    }
    if (Status == ERROR_SUCCESS)
    {
        if (NameContext.Length == 0)
        {
            Status = DfsAcquireDomainInfo( &pDomainInfo );
            if (Status == ERROR_SUCCESS)
            {
                Status = pDomainInfo->GenerateDomainReferral( ppReferralHeader );
                DfsReleaseDomainInfo( pDomainInfo );
            }
        }
        else if (ShareName.Length == 0)
        {
            Status = DfsGenerateDomainDCReferral( &NameContext,
                                                  pReferralSite,
                                                  NumReplicasToReturn,
                                                  CostLimit,
                                                  ppReferralHeader );
        }
        else if ( (RemainingName.Length == 0) )
            //
            // Commenting out the rest of the IF statement for win9x 
            // compatibility.
            //  (DfsIsNameContextDomainName(&NameContext)) )
            //

        {
            if (DfsIsSpecialDomainShare(&ShareName))
            {
                Status = DfsGenerateSpecialShareReferral( &LinkName,
                                                          &NameContext,
                                                          &ShareName,
                                                          pReferralSite,
                                                          NumReplicasToReturn,
                                                          CostLimit,
                                                          ppReferralHeader );
            }
            else 
            {
                Status = DfsGenerateADBlobReferral( &LinkName,
                                                    &ShareName,
                                                    pReferralSite,
                                                    NumReplicasToReturn,
                                                    CostLimit,
                                                    ppReferralHeader );
            }

            if (Status != ERROR_SUCCESS) 
            {
                if (DfsIsNameContextDomainName(&NameContext) == FALSE) 
                {
                    Status = ERROR_NOT_FOUND;
                }
            }
        }
        else
        {
            Status = ERROR_NOT_FOUND;
        }
    }

done:

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetReplicaData - 

//
//  Arguments:  LinkName - pointer to link name
//              Sitename - pointer to site name.
//              NumReplicasToReturn - Number of replicas to return
//              CostLimit - maximum cost caller is willing to accept
//              ppReferralHeader - address of buffer to accept replica info
//
//  Returns:    Status
//               ERROR_SUCCESS 
//               ERROR_NOT_ENOUGH_MEMORY
//               others
//
//
//  Description: This routine extracts the replicas from the referral
//
//--------------------------------------------------------------------------
DFSSTATUS 
DfsGenerateReferral(
    LPWSTR LinkName, 
    DfsSite *pReferralSite,  
    DWORD NumReplicasToReturn,
    ULONG CostLimit,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status;

    //
    // First check if this machine is a DC. If it is, it has special
    // responsibility in the referral process. Check if it needs to
    // provide a referral as a DC.
    // 
    //
    if (DfsIsMachineDC())
    {
        Status = DfsGenerateDcReferral( LinkName,
                                        pReferralSite,
                                        NumReplicasToReturn,
                                        CostLimit,
                                        ppReferralHeader );

        if (Status != ERROR_NOT_FOUND)
        {
            return Status;
        }
    }

    //
    // If we are here, we are either an ordinary machine or a DC
    // and this referral is not a DC type referral.
    // Try to treat this machine as a normal machine, and generate a
    // referral based on what this machine knows about.
    //
    Status = DfsGenerateNormalReferral( LinkName,
                                        pReferralSite,
                                        NumReplicasToReturn,
                                        CostLimit,
                                        ppReferralHeader );

    //
    // if we still failed, and we are a DC, it is possible that a old
    // win9x client is coming in and we try to generate a referral
    // for compat.
    //

    if ((DfsIsMachineDC()) &&
        (Status != ERROR_SUCCESS))
    {
        DFSSTATUS CompatStatus;

        CompatStatus = DfsGenerateCompatReferral( LinkName,
                                                  pReferralSite,
                                                  ppReferralHeader );
        if (CompatStatus == ERROR_SUCCESS) 
        {
            Status = CompatStatus;
        }
    }

    return Status;

}


VOID
DfsReleaseReferral(
    REFERRAL_HEADER *pReferralHeader)
{
    delete [] (PBYTE)pReferralHeader;
}



DFSSTATUS
DfsGenerateCompatReferral(
    LPWSTR LinkName,
    DfsSite *pReferralSite,
    REFERRAL_HEADER ** ppReferralHeader)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolderReferralData *pReferralData = NULL;
    BOOLEAN CacheHit = TRUE;
    UNICODE_STRING Name, Remaining;
    
    DFS_TRACE_LOW( REFERRAL, "DfsGenerateCompatReferral for Link %ws\n",
                    LinkName);

    Status = DfsRtlInitUnicodeStringEx(&Name, LinkName);
    if (Status != ERROR_SUCCESS)
    {
      goto done;
    }

    Status = DfsGetCompatReferralData( &Name,
                                       &Remaining,
                                       &pReferralData,
                                       &CacheHit );

    if (Status == ERROR_SUCCESS)
    {
        Name.Length -= Remaining.Length;
        if (Name.Length && (Name.Buffer[(Name.Length/sizeof(WCHAR)) - 1] == UNICODE_PATH_SEP)) 
        {
            Name.Length -= sizeof(WCHAR);
        }
        
        Status = DfsGenerateReferralFromData( &Name,
                                              NULL,
                                              NULL,
                                              pReferralSite,
                                              pReferralData,
                                              1000,
                                              DFS_MAX_COST,
                                              ppReferralHeader);

        pReferralData->ReleaseReference();         
    }


done:

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL, "DfsGenerateCompatReferral for Link %ws CacheHit %d Status %x\n",
                          LinkName, CacheHit, Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsreparsesupport.cxx ===
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsReparseSupport.cxx
//
//  Contents:  This handles all reparse point work. 
//
//
//  History:    April 2002,   Author: SupW
//
//-----------------------------------------------------------------------------
#include <stdlib.h>
#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntstatus.h>
#include <ntioapi.h>

#include <windows.h>
#include <shlwapi.h>

#include <strsafe.h>
#include <dfsgeneric.hxx>
#include <dfsheader.h>
#include <DfsInit.hxx>
#include <DfsRootFolder.hxx>
#include <DfsReparse.hxx>

#include "DfsReparseSupport.tmh"


// Local support routines
DFSSTATUS 
DfsGetVolumePathName(
    IN PUNICODE_STRING pDirectoryName,
    OUT PUNICODE_STRING ppVolumePath);

VOID
DfsFreeVolumePathName(
    PUNICODE_STRING VolumeName);

DFSSTATUS
DfsInsertInReparseVolList(
    LPWSTR VolumeName);

DFSSTATUS
DfsOpenReparseIndex(
    IN PUNICODE_STRING pVolume,
    OUT HANDLE *pHandle);

DFSSTATUS
DfsGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION pReparseInfo,
    PBOOLEAN pDone);

DFSSTATUS
DfsRemoveReparseIfOrphaned(
    IN HANDLE VolumeHandle,
    IN PUNICODE_STRING pVolumeName,
    IN LONGLONG FileReference,
    IN FILETIME ServiceStartupTime);

DFSSTATUS
DfsDeleteReparseDirectory(
    PUNICODE_STRING pVolumeName, 
    LPWSTR pDfsDirectory);

DFSSTATUS
DfsIsReparseOrphaned(
    IN HANDLE Handle,
    IN FILETIME ServiceStartupTime,
    OUT PBOOLEAN pOrphaned);

DFSSTATUS
DfsOpenReparseByID(
    IN HANDLE VolumeHandle,
    IN LONGLONG FileReference,
    OUT PHANDLE pReparseHandle);

DFSSTATUS
DfsGetVolumeHandleByName(
    IN PUNICODE_STRING pVolume,
    OUT PHANDLE pVolumeHandle);

VOID
DfsGetReparseVolumeToScan(
    PDFS_REPARSE_VOLUME_INFO *ppVolumeInfo );


NTSTATUS
DfsIsDirectoryReparsePoint(
    HANDLE DirHandle,
    PBOOLEAN pReparsePoint,
    PBOOLEAN pDfsReparsePoint );

NTSTATUS
DfsClearDfsReparsePoint(
    IN HANDLE DirHandle );


NTSTATUS
DfsDeleteLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle,
    BOOLEAN           bRemoveParentDirs);

BOOLEAN
DfsIsEmptyDirectory(
    HANDLE DirectoryHandle,
    PVOID pDirectoryBuffer,
    ULONG DirectoryBufferSize );


NTSTATUS
DfsOpenDirectory(
    PUNICODE_STRING pDirectoryName,
    ULONG ShareMode,
    HANDLE RelativeHandle,
    PHANDLE pOpenedHandle,
    PBOOLEAN pIsNewlyCreated )
{

    NTSTATUS                    NtStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    ACCESS_MASK                 DesiredAccess;
    PLARGE_INTEGER              AllocationSize;
    ULONG                       FileAttributes;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    IO_STATUS_BLOCK IoStatusBlock;

    AllocationSize             = NULL;
    FileAttributes             = FILE_ATTRIBUTE_NORMAL;
    CreateDisposition          = FILE_OPEN_IF;
    CreateOptions              = FILE_DIRECTORY_FILE |
                                 FILE_OPEN_REPARSE_POINT |
                                 FILE_SYNCHRONOUS_IO_NONALERT |
                                 FILE_OPEN_FOR_BACKUP_INTENT;

    DesiredAccess              = FILE_READ_DATA | 
                                 FILE_WRITE_DATA |
                                 FILE_READ_ATTRIBUTES | 
                                 FILE_WRITE_ATTRIBUTES |
                                 SYNCHRONIZE;

    InitializeObjectAttributes (
        &ObjectAttributes, 
        pDirectoryName,              //Object Name
        OBJ_CASE_INSENSITIVE,        //Attributes
        RelativeHandle,              //Root handle
        NULL);                       //Security descriptor.

    NtStatus = NtCreateFile(pOpenedHandle,
                            DesiredAccess,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            AllocationSize,
                            FileAttributes,
                            ShareMode,
                            CreateDisposition,
                            CreateOptions,
                            NULL,                // EaBuffer
                            0 );                 // EaLength

    
    DFSLOG("Open on %wZ: Status %x\n", pDirectoryName, NtStatus);

    if ( (NtStatus == STATUS_SUCCESS)  && (pIsNewlyCreated != NULL) )
    {
        *pIsNewlyCreated = (IoStatusBlock.Information == FILE_CREATED)? TRUE : FALSE;
    }

    return NtStatus;
}


VOID
DfsCloseDirectory(
    HANDLE DirHandle )
{
    NtClose( DirHandle );
}

//+-------------------------------------------------------------------------
//
//  Function:   ClearDfsReparsePoint
//
//  Arguments:  DirHandle - handle on open directory
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a handle to an open directory and
//               makes that directory a reparse point with the DFS tag
//
//--------------------------------------------------------------------------

NTSTATUS
DfsClearDfsReparsePoint(
    IN HANDLE DirHandle )
{
    NTSTATUS NtStatus;
    REPARSE_DATA_BUFFER         ReparseDataBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    
    //
    // Attempt to set a reparse point on the directory
    //
    RtlZeroMemory( &ReparseDataBuffer, sizeof(ReparseDataBuffer) );

    ReparseDataBuffer.ReparseTag          = IO_REPARSE_TAG_DFS;
    ReparseDataBuffer.ReparseDataLength   = 0;

    NtStatus = NtFsControlFile( DirHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_DELETE_REPARSE_POINT,
                                &ReparseDataBuffer,
                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataBuffer.ReparseDataLength,
                                NULL,
                                0 );
    
    return NtStatus;
}


NTSTATUS
DfsDeleteLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle,
    BOOLEAN           bRemoveParentDirs)
{
    UNICODE_STRING DirectoryToDelete = *pLinkName;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE CurrentDirectory = NULL;
    ULONG ShareMode = 0;

    ShareMode =  FILE_SHARE_READ;
    //
    // dfsdev: fix this fixed size limit. it will hurt us in the future.
    //
    ULONG DirectoryBufferSize = 4096;
    PBYTE pDirectoryBuffer = new BYTE [DirectoryBufferSize];

    if (pDirectoryBuffer == NULL)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    while ( (NtStatus == STATUS_SUCCESS) && (DirectoryToDelete.Length != 0) )
    {
        NtStatus = DfsOpenDirectory( &DirectoryToDelete,
                                  ShareMode,
                                  RelativeHandle,
                                  &CurrentDirectory,
                                  NULL );
        if (NtStatus == ERROR_SUCCESS)
        {
            if (DfsIsEmptyDirectory(CurrentDirectory,
                                 pDirectoryBuffer,
                                 DirectoryBufferSize) == FALSE)
            {
                NtClose( CurrentDirectory );
                break;
            }

            NtClose( CurrentDirectory );
            InitializeObjectAttributes (
                &ObjectAttributes,
                &DirectoryToDelete,
                OBJ_CASE_INSENSITIVE,
                RelativeHandle,
                NULL);

            NtStatus = NtDeleteFile( &ObjectAttributes );
            //
            // When the worker thread is trying to clean up orphaned
            // reparse points, don't try to iterate and remove all parent
            // dirs all the way to the root. All we want to do is to
            // remove the reparse dir. 
            // BUG 701594.
            //
            if (!bRemoveParentDirs)
            {
                break;
            }

            StripLastPathComponent( &DirectoryToDelete );
        }
    }

    if (pDirectoryBuffer != NULL)
    {
        delete [] pDirectoryBuffer;
    }
    return NtStatus;
}

BOOLEAN
DfsIsEmptyDirectory(
    HANDLE DirectoryHandle,
    PVOID pDirectoryBuffer,
    ULONG DirectoryBufferSize )
{
    NTSTATUS NtStatus;
    FILE_NAMES_INFORMATION *pFileInfo;
    ULONG NumberOfFiles = 1;
    BOOLEAN ReturnValue = FALSE;
    IO_STATUS_BLOCK     IoStatus;

    NtStatus = NtQueryDirectoryFile ( DirectoryHandle,
                                      NULL,   // no event
                                      NULL,   // no apc routine
                                      NULL,   // no apc context
                                      &IoStatus,
                                      pDirectoryBuffer,
                                      DirectoryBufferSize,
                                      FileNamesInformation,
                                      FALSE, // return single entry = false
                                      NULL,  // filename
                                      FALSE ); // restart scan = false
    if (NtStatus == ERROR_SUCCESS)
    {
        pFileInfo =  (FILE_NAMES_INFORMATION *)pDirectoryBuffer;

        while (pFileInfo->NextEntryOffset) {
            NumberOfFiles++;
            if (NumberOfFiles > 3) 
            {
                break;
            }
            pFileInfo = (FILE_NAMES_INFORMATION *)((ULONG_PTR)(pFileInfo) + 
                                                   pFileInfo->NextEntryOffset);
        }

        if (NumberOfFiles <= 2)
        {
            ReturnValue = TRUE;
        }
    }

    return ReturnValue;
}



//+-------------------------------------------------------------------------
//
//  Function:   IsDirectoryReparsePoint
//
//  Arguments:  DirHandle - handle to open directory.
//              pReparsePoint - returned boolean: true if this directory is
//              a reparse point
//              pDfsReparsePoint - returned boolean: true if this 
//              directory is a dfs reparse point
//                          
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a handle to an open directory and
//               sets 2 booleans to indicate if this directory is a
//               reparse point, and if so, if this directory is a dfs
//               reparse point. The booleans are initialized if this
//               function returns success.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsIsDirectoryReparsePoint(
    IN  HANDLE DirHandle,
    OUT PBOOLEAN pReparsePoint,
    OUT PBOOLEAN pDfsReparsePoint )
{
    NTSTATUS NtStatus;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    //we assume these are not reparse points.
    //
    *pReparsePoint = FALSE;
    *pDfsReparsePoint = FALSE;

    //
    // Query for the basic information, which has the attributes.
    //
    NtStatus = NtQueryInformationFile( DirHandle,
                                     &IoStatusBlock,
                                     (PVOID)&BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (NtStatus == STATUS_SUCCESS)
    {
        //
        // If the attributes indicate reparse point, we have a reparse
        // point directory on our hands.
        //
        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) 
        {
            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

            *pReparsePoint = TRUE;
            
            NtStatus = NtQueryInformationFile( DirHandle,
                                               &IoStatusBlock,
                                               (PVOID)&FileTagInformation,
                                               sizeof(FileTagInformation),
                                               FileAttributeTagInformation );

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Checkif the tag indicates its a DFS reparse point,
                // and setup the return accordingly.
                //
                if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_DFS)
                {
                    *pDfsReparsePoint = TRUE;
                }
            }
        }
    }

    return NtStatus;
}

NTSTATUS
DfsDeleteLinkReparsePoint( 
    PUNICODE_STRING pDirectoryName,
    HANDLE ParentHandle,
    BOOLEAN bRemoveParentDirs)
{
    NTSTATUS NtStatus;
    HANDLE LinkDirectoryHandle;
    BOOLEAN IsReparsePoint, IsDfsReparsePoint;

    NtStatus = DfsOpenDirectory( pDirectoryName,
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              ParentHandle,
                              &LinkDirectoryHandle,
                              NULL );
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DfsIsDirectoryReparsePoint( LinkDirectoryHandle,
                                            &IsReparsePoint,
                                            &IsDfsReparsePoint );

        if ((NtStatus == STATUS_SUCCESS) && 
            (IsDfsReparsePoint == TRUE) )
        {
            NtStatus = DfsClearDfsReparsePoint( LinkDirectoryHandle );
            DFS_TRACE_NORM( REFERRAL_SERVER, "ClearDfsReparsePoint: %wZ, NtStatus 0x%x\n",
                pDirectoryName, NtStatus );
        }

        NtClose( LinkDirectoryHandle );
    }

    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DfsDeleteLinkDirectories( pDirectoryName,
                                          ParentHandle, 
                                          bRemoveParentDirs );
        DFS_TRACE_NORM( REFERRAL_SERVER, "DfsDeleteLinkDirectories: %wZ, NtStatus 0x%x\n",
                pDirectoryName, NtStatus );
    }

    return NtStatus;
}

//
// Given a directory name, return the volume it is on.
//
DFSSTATUS 
DfsGetVolumePathName(
    IN PUNICODE_STRING pDirectoryName,
    OUT PUNICODE_STRING pVolumePath)
{
    DWORD BufferSize = MAX_PATH;
    PWSTR pName = NULL;
    BOOL bResult = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;
    
    do
    {

        // Buffersize is just a rough guess. We adjust it later.
        pName = new WCHAR[BufferSize];
        if(pName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Now get the volume path
        bResult = GetVolumePathName(
            pDirectoryName->Buffer,
            pName,
            BufferSize);

        // If we failed, see if it's because we needed a longer buffer.
        if (!bResult)
        {
            delete [] pName;
            pName = NULL;
            
            Status = GetLastError();

            //
            // We assume a well behaved GetVolumePathName
            // that returns OVERFLOW finite number of times.
            //
            if (Status == ERROR_BUFFER_OVERFLOW)
            {
                BufferSize *= 2;
            }
            else
            {
                break;
            }
        }
        
    } while (!bResult);

    Status = DfsRtlInitUnicodeStringEx( pVolumePath, pName );
    if (Status != ERROR_SUCCESS && pName != NULL)
    {
        delete [] pName;
        pName = NULL;
    }
    
    return Status;
}

VOID
DfsFreeVolumePathName(
    PUNICODE_STRING pVolumeName)
{
    if (pVolumeName != NULL)
    {
        delete [] pVolumeName->Buffer;
        pVolumeName->Buffer = NULL;
    }
}

DFSSTATUS
DfsInsertInReparseVolList(
    LPWSTR VolumeName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PDFS_REPARSE_VOLUME_INFO pNewReparseEntry = NULL;
    
    pNewReparseEntry = new DFS_REPARSE_VOLUME_INFO;
    if (pNewReparseEntry != NULL)
    {
        //
        // We create a new null terminated string to keep. The input may be unnecessarily longer.
        //
        Status = DfsCreateUnicodeStringFromString( &pNewReparseEntry->VolumeName, VolumeName );

        if (Status == ERROR_SUCCESS)
        {
            //
            // Add to the global reparse volume list. The caller knows that the entry isn't there,
            // and has held the datalock through out.
            //
            InsertTailList( &DfsServerGlobalData.ReparseVolumeList, &pNewReparseEntry->ListEntry);
            DFS_TRACE_NORM( REFERRAL_SERVER, "[%!FUNC! Added %ws to ReparseVolumeList\n", 
                              VolumeName );
        }
    }
    else 
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        
    }

    // Error path
    if (Status != ERROR_SUCCESS)
    {
        if (pNewReparseEntry != NULL)
        {
            delete pNewReparseEntry;
            pNewReparseEntry = NULL;
        }
    }
    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, 
                "[%!FUNC!- Level %!LEVEL!] OUT OF RESOURCES adding %ws to ReparseVolumeList\n",
                VolumeName );
    return Status;
}



DFSSTATUS
DfsGetNextReparseRecord(
    HANDLE hIndex,
    PFILE_REPARSE_POINT_INFORMATION pReparseInfo,
    PBOOLEAN pDone)
{
    BOOLEAN bResult = FALSE;
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    NtStatus = NtQueryDirectoryFile(hIndex,
        NULL,
        NULL,
        NULL,
        &IoStatus,
        pReparseInfo,
        sizeof(FILE_REPARSE_POINT_INFORMATION),
        FileReparsePointInformation,
        TRUE,
        NULL,
        FALSE);
        
    if (!NT_SUCCESS(NtStatus))
    {
        Status = RtlNtStatusToDosError(NtStatus);
        if (Status == ERROR_NO_MORE_FILES)
        {
            Status = ERROR_SUCCESS;
        }

        *pDone = TRUE;
    }

    return Status;
}


DFSSTATUS
DfsOpenReparseIndex(
    IN PUNICODE_STRING pVolume,
    OUT HANDLE *pHandle)
{
    HANDLE ReparseHandle = INVALID_HANDLE_VALUE;
    LPWSTR pReparsePathName = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    size_t CchPathLen;
    HRESULT Hr = S_OK;
    LPWSTR pIndexAllocPath = REPARSE_INDEX_PATH;
    
    *pHandle = INVALID_HANDLE_VALUE;

    do {
        CchPathLen = pVolume->Length;
        
        //
        // Extra space is to concat "\$Extend\\$Reparse:$R:$INDEX_ALLOCATION"
        //
        CchPathLen += REPARSE_INDEX_PATH_LEN;
        pReparsePathName = new WCHAR[ CchPathLen ];
        if (pReparsePathName == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;

        }

        // The volume name.
        Hr = StringCchCopy( pReparsePathName, CchPathLen, pVolume->Buffer );
        if (!SUCCEEDED(Hr))
        {
            Status = HRESULT_CODE(Hr);
            break;
        }

        (VOID)PathAddBackslash( pReparsePathName );

        //
        // $Extend\\$Reparse:$R:$INDEX_ALLOCATION
        //
        Hr = StringCchCat( pReparsePathName, CchPathLen, pIndexAllocPath );
        if (!SUCCEEDED(Hr))
        {
            Status = HRESULT_CODE(Hr);
            break;
        }
        
        ReparseHandle = CreateFile(
           pReparsePathName,
           GENERIC_READ,
           FILE_SHARE_READ,
           NULL,
           OPEN_EXISTING,
           FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
           NULL);

        Status = GetLastError();

        // paranoia
        if (Status == ERROR_SUCCESS)
        {
            *pHandle = ReparseHandle;
        }
        
    } while (FALSE);

    //
    // Clean up
    //
    if (pReparsePathName != NULL)
    {
        delete [] pReparsePathName;
        pReparsePathName = NULL;
    }
    
    return Status;
}

//
// Given the volume name, return a handle to it.
//
DFSSTATUS
DfsGetVolumeHandleByName(
    IN PUNICODE_STRING pVolume,
    OUT PHANDLE pVolumeHandle)
{
    LPWSTR VolumeName = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOL bResult = FALSE;

    *pVolumeHandle = INVALID_HANDLE_VALUE;
    
    VolumeName = new WCHAR[ MAX_PATH ];
    if (VolumeName == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        return Status;
    }
        
    bResult = GetVolumeNameForVolumeMountPoint(
        pVolume->Buffer,
        VolumeName,
        MAX_PATH);

    if (bResult)
    {
        *pVolumeHandle = CreateFile(
            VolumeName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | SECURITY_IMPERSONATION,
            NULL);

    }

    Status = GetLastError();
    delete [] VolumeName;

    return Status;
}

DFSSTATUS
DfsOpenReparseByID(
    IN HANDLE VolumeHandle,
    IN LONGLONG FileReference,
    OUT PHANDLE pReparseHandle)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING FileIdString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    
    *pReparseHandle = INVALID_HANDLE_VALUE;
        
    //
    // Open the file by its file reference.
    //

    FileIdString.Length = sizeof(LONGLONG);
    FileIdString.MaximumLength = sizeof(LONGLONG);
    FileIdString.Buffer = (PWCHAR)&FileReference;

    InitializeObjectAttributes(
            &ObjectAttributes,
            &FileIdString,
            OBJ_CASE_INSENSITIVE,
            VolumeHandle,
            NULL);      // security descriptor

    NtStatus = NtCreateFile(
                pReparseHandle,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,           // allocation size
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT | FILE_OPEN_BY_FILE_ID,
                NULL,           // EA buffer
                0);             // EA length
                
    Status = RtlNtStatusToDosError( NtStatus );

    return Status;
}

    
DFSSTATUS
DfsIsReparseOrphaned(
    IN HANDLE Handle,
    IN FILETIME ServiceStartupTime,
    OUT PBOOLEAN pOrphaned)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION FileBasicInfo;
    FILETIME ReparseTimeStamp;
    
    *pOrphaned = FALSE;

    //
    // Query the LastWriteTime to see if this reparse point is orphaned.
    //
    ZeroMemory( &FileBasicInfo, sizeof( FileBasicInfo ));
    NtStatus = NtQueryInformationFile(
        Handle,
        &IoStatusBlock,
        &FileBasicInfo,
        sizeof(FileBasicInfo),
        FileBasicInformation);

    Status = RtlNtStatusToDosError( NtStatus );
    if (Status == ERROR_SUCCESS)
    {
        //
        // Since we would've re-written all reparse points
        // when the service had started up, a good reparse point
        // can't have an older timestamp.
        //
        LARGE_INTEGER_TO_FILETIME( &ReparseTimeStamp, &FileBasicInfo.ChangeTime );
        if (CompareFileTime( &ReparseTimeStamp, &ServiceStartupTime ) == -1)
        {
            *pOrphaned = TRUE;
        }
    }
    
    return Status;
}

DFSSTATUS
DfsDeleteReparseDirectory(
    PUNICODE_STRING pVolumeName, 
    LPWSTR pDfsDirectory,
    ULONG CbDirLength)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    NTSTATUS NtStatus;
    DWORD BuffLen = 0;
    LPWSTR FullFileName = NULL;
    UNICODE_STRING UnicodeFileName;
    ULONG CbCurrentPos;
    
        
    BuffLen = WHACKWHACKQQ_SIZE;
    BuffLen += (pVolumeName->Length);
    BuffLen += CbDirLength;
    BuffLen += sizeof(UNICODE_NULL);

    //
    // Unicodes can't handle paths longer than MAXUSHORT.
    //
    if (BuffLen >= MAXUSHORT)
    {
        Status = ERROR_INVALID_PARAMETER;
        return Status;
    }
    
    FullFileName = new WCHAR[ BuffLen/sizeof(WCHAR) ];
    if (FullFileName == NULL)
    {
       Status = ERROR_NOT_ENOUGH_MEMORY;
       return Status;
    }

    CbCurrentPos = 0;
    
    // First the \??\ portion.
    RtlCopyMemory( FullFileName, 
                   WHACKWHACKQQ, 
                   WHACKWHACKQQ_SIZE );  
    CbCurrentPos += WHACKWHACKQQ_SIZE;
    
    // Volume name goes next.
    RtlCopyMemory( &FullFileName[ CbCurrentPos / sizeof(WCHAR) ],
                   pVolumeName->Buffer,
                   pVolumeName->Length );
    CbCurrentPos += pVolumeName->Length;
    
    // The reparse path itself.
    RtlCopyMemory( &FullFileName[ CbCurrentPos / sizeof(WCHAR) ],
                   pDfsDirectory,
                   CbDirLength);
    CbCurrentPos += CbDirLength;

    FullFileName[ CbCurrentPos / sizeof(WCHAR) ] = UNICODE_NULL;
    
    UnicodeFileName.Buffer = FullFileName;
    UnicodeFileName.Length = (USHORT)CbCurrentPos;
    
    CbCurrentPos += sizeof(UNICODE_NULL);   
    ASSERT( BuffLen == CbCurrentPos );
    
    UnicodeFileName.MaximumLength = (USHORT)CbCurrentPos;

    //
    // Finally get rid of this reparse point directory.
    // We delete only the reparse directory, not anything above it.
    // We don't want it to go all the way up and delete the root directory, for example.
    // BUG 701594
    //
    NtStatus = DfsDeleteLinkReparsePointDir( &UnicodeFileName, NULL );
    if (NtStatus != STATUS_SUCCESS)
    {
        Status = RtlNtStatusToDosError(NtStatus);
    }
    
    delete [] FullFileName;

    return Status;
}

DFSSTATUS
DfsRemoveReparseIfOrphaned(
    IN HANDLE VolumeHandle,
    IN PUNICODE_STRING pVolumeName,
    IN LONGLONG FileReference,
    IN FILETIME ServiceStartupTime)
{
    
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE ReparseDirectoryHandle = INVALID_HANDLE_VALUE;
    BOOLEAN Orphaned = FALSE;
    BOOLEAN ReparseOpened = FALSE;
    PFILE_NAME_INFORMATION  pFileInfo = NULL;
    ULONG CbPathLen = MAX_PATH * sizeof(WCHAR);
    ULONG CbBufSize = 0;
    
    do {

        //
        // First get a handle to the reparse directory. We have its FileID.
        //
        Status = DfsOpenReparseByID( VolumeHandle,
                                FileReference,
                                &ReparseDirectoryHandle );

        if (Status != ERROR_SUCCESS)
            break;

        ReparseOpened = TRUE;
        
        Status = DfsIsReparseOrphaned( ReparseDirectoryHandle,
                                     ServiceStartupTime,
                                     &Orphaned);

        //
        // If this reparse point is active, we are done.
        //
        if (Status != ERROR_SUCCESS || Orphaned == FALSE)
        {
            break;
        }
        
        //
        // Query the name of the file.
        //

        do { 

            CbBufSize = sizeof( FILE_NAME_INFORMATION ) + CbPathLen;
            pFileInfo = (PFILE_NAME_INFORMATION) new BYTE[CbBufSize];
            if (pFileInfo == NULL)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            //
            // Zero the buffer before querying the filename.
            //
            ZeroMemory( pFileInfo, CbBufSize );
            NtStatus = NtQueryInformationFile(
                ReparseDirectoryHandle,
                &IoStatusBlock,
                pFileInfo,
                CbBufSize,
                FileNameInformation);

            //
            // If we need to resize the buffer, do it in
            // multiples of two, but cap it at ULONGMAX.
            //
            if (NtStatus == STATUS_BUFFER_OVERFLOW)
            {
                delete [] pFileInfo;
                pFileInfo = NULL;
                
                if (CbPathLen >= (ULONG_MAX / 2))
                {
                    // this isn't the ideal error message, but...
                    NtStatus = STATUS_INVALID_PARAMETER;
                    break;
                }

                CbPathLen *= 2;
            }
            
        } while (NtStatus == STATUS_BUFFER_OVERFLOW);
        
        Status = RtlNtStatusToDosError( NtStatus );
        if (Status != ERROR_SUCCESS ||
           pFileInfo == NULL) // To keep PREFAST happy
        {
            break;
        }
        CloseHandle( ReparseDirectoryHandle );
        ReparseOpened = FALSE;

        //
        // Now do the actual deletion
        //
        Status = DfsDeleteReparseDirectory( pVolumeName, pFileInfo->FileName, pFileInfo->FileNameLength );
    
    } while (FALSE);

    //
    // If we still haven't closed the reparse handle, do so before we get out.
    //
    if (ReparseOpened)
    {
        CloseHandle( ReparseDirectoryHandle );
        ReparseOpened = FALSE;
    }

    if (pFileInfo != NULL)
    {
        delete [] pFileInfo;
        pFileInfo = NULL;
    }
    
    return Status;
    
}


VOID
DfsGetReparseVolumeToScan(
    PDFS_REPARSE_VOLUME_INFO *ppVolumeInfo )
{
    PLIST_ENTRY pNext = NULL;
    PDFS_REPARSE_VOLUME_INFO pVolInfo = NULL;
    *ppVolumeInfo = NULL;
    
    //
    // this needs to be optimized to return a subset or LRU entries.
    //
    DfsAcquireGlobalDataLock();

    if (!IsListEmpty( &DfsServerGlobalData.ReparseVolumeList ))
    {
        pNext = RemoveHeadList( &DfsServerGlobalData.ReparseVolumeList );
        ASSERT( pNext != NULL);
        pVolInfo = CONTAINING_RECORD( pNext, 
                                       DFS_REPARSE_VOLUME_INFO,
                                       ListEntry );
        if (!IsEmptyUnicodeString( &pVolInfo->VolumeName )) 
        {
            *ppVolumeInfo = pVolInfo;
        }
    }    

    DfsReleaseGlobalDataLock();
}


DFSSTATUS
DfsRemoveOrphanedReparsePoints(
    IN PUNICODE_STRING pVolumeName,
    IN FILETIME ServiceStartupTime)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE ReparseIndexHandle = INVALID_HANDLE_VALUE;
    HANDLE ReparseDirectoryHandle = INVALID_HANDLE_VALUE;
    HANDLE VolumeHandle = INVALID_HANDLE_VALUE;
    FILE_REPARSE_POINT_INFORMATION ReparseInfo;
    BOOLEAN Done = FALSE;
    
    do { 
 
        //
        // Open the $Reparse index of the volume.
        //
        Status = DfsOpenReparseIndex( pVolumeName, &ReparseIndexHandle );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
                
        //
        // First get a handle to this volume.
        //

        Status = DfsGetVolumeHandleByName( pVolumeName, &VolumeHandle );

        if (Status != ERROR_SUCCESS)
        {
            break;
        }
        
        //
        // Go through all the reparse points in the index.
        //
        Done = FALSE;
        Status = DfsGetNextReparseRecord( ReparseIndexHandle, 
                                        &ReparseInfo, 
                                        &Done );

        while (!Done && Status == ERROR_SUCCESS)
        {
            //
            // If we find a DFS reparse point...
            //
            if (ReparseInfo.Tag == IO_REPARSE_TAG_DFS)
            {
                DFSSTATUS TempStatus;
                TempStatus = DfsRemoveReparseIfOrphaned( VolumeHandle,
                                                        pVolumeName,
                                                        ReparseInfo.FileReference,
                                                        ServiceStartupTime );
                //
                // Ignore and move on if we hit an error. This will get retried when the 
                // service starts up next.
                //                
                DFS_TRACE_ERROR_NORM( Status, REFERRAL_SERVER, 
                          "[%!FUNC!] Status 0x%x in ReparseIfOrphaned for Volume %wZ, FileRef 0x%x\n",
                          TempStatus, pVolumeName, (ULONG)ReparseInfo.FileReference);
            }
            
            //
            // Iterate to the next reparse record.
            //
            Status = DfsGetNextReparseRecord( ReparseIndexHandle, 
                                        &ReparseInfo, 
                                        &Done );
        
        }

    } while (FALSE);

    if (ReparseIndexHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( ReparseIndexHandle );
        ReparseIndexHandle = INVALID_HANDLE_VALUE;
    }

    if (VolumeHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle( VolumeHandle );
        VolumeHandle = INVALID_HANDLE_VALUE;
    }
    return Status;
}

//
// Given a path to a reparse point, this adds the volume that it resides in
// to our list of volumes to scan (for orphaned reparse points) later. 
//
DFSSTATUS
DfsAddReparseVolumeToList (
    IN PUNICODE_STRING pDirectoryName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING VolumeName;
    PLIST_ENTRY pNext = NULL;
    BOOLEAN Found = FALSE;
    PDFS_REPARSE_VOLUME_INFO pReparseVolInfo = NULL;
    BOOLEAN VolumeAdded = FALSE;
    
    do { 
    
        //
        // First find the volume this path belongs in.
        //
        Status = DfsGetVolumePathName( pDirectoryName, &VolumeName );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        DfsAcquireGlobalDataLock();
        {
            //
            // See if the volume is already on the list
            //
            pNext = DfsServerGlobalData.ReparseVolumeList.Flink;
            while (pNext != &DfsServerGlobalData.ReparseVolumeList)
            {
                pReparseVolInfo = CONTAINING_RECORD( pNext, 
                                                 DFS_REPARSE_VOLUME_INFO,
                                                 ListEntry );
                if (RtlCompareUnicodeString(&pReparseVolInfo->VolumeName,
                                         &VolumeName,
                                         TRUE) == 0) // Case insensitive
                {
                    Found = TRUE;
                    break;
                }
                pNext = pNext->Flink;
            }

            //
            // Insert this volume only if it isn't already there.
            //
            if (!Found)
            {
                Status = DfsInsertInReparseVolList( VolumeName.Buffer );          
            }
        }
        DfsReleaseGlobalDataLock();
        
    } while (FALSE);

    // 
    // We've made a copy of the volume name, so we are ok to free it.
    //
    if (VolumeName.Buffer != NULL)
    {
        DfsFreeVolumePathName( &VolumeName );
    }

    return Status;
}

//
// This is the entry point for cleaning up reparse points.
// It'll iterate through all local volumes that are known to have DFS roots on them
// (and therefore reparse points) and inspect their respective $Reparse indices.
// This assumes that all good reparse points will have been written to when the service
// started up. 
//
VOID
DfsRemoveOrphanedReparsePoints(
    IN FILETIME ServiceStartupTime)
{
    PDFS_REPARSE_VOLUME_INFO pVolInfo = NULL;
    DfsGetReparseVolumeToScan( &pVolInfo );

    while (pVolInfo != NULL)
    {
        DFS_TRACE_NORM( REFERRAL_SERVER, "[%!FUNC!] Starting ReparsePt cleanup on volume %wZ\n", 
                         &pVolInfo->VolumeName);
        // We have no choice but to ignore errors and keep going
        (VOID)DfsRemoveOrphanedReparsePoints( &pVolInfo->VolumeName,
                                            ServiceStartupTime );

        pVolInfo = NULL; // paranoia

        // Get the next volume if any.
        DfsGetReparseVolumeToScan( &pVolInfo );
    }
    DFS_TRACE_NORM( REFERRAL_SERVER, "[%!FUNC!] Done reparse cleanup\n");
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsrootfolder.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsRootFolder.cxx
//
//  Contents:   implements the base DFS Folder class
//
//  Classes:    DfsRootFolder.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------

#include "DfsRootFolder.hxx"
#include "dfsfilterapi.hxx"
#include "rpc.h"
#include "rpcdce.h"
#include "DfsStore.hxx"
#include "srvfsctl.h" //for calling into srv.sys
#include "dfsfsctl.h"
#include "DfsReparse.hxx"
//
// logging includes.
//

#include "DfsRootFolder.tmh" 

#define FILETIMETO64(_f) (*(UINT64 *)(&(_f)))
LPWSTR DFSRENAMEPREFIX = L"DFS.";
ULONG  DFSDIRWHACKQOFFSET = 4;

extern "C" {
DWORD
I_NetDfsIsThisADomainName(
    IN  LPWSTR                      wszName);
}

NTSTATUS
StripAndReturnLastPathComponent(
    PUNICODE_STRING pPath, 
    PUNICODE_STRING pLeaf) ;

DFSSTATUS
SendShareToSrv(PUNICODE_STRING pShareName, 
               BOOLEAN fAttach) ;


//+-------------------------------------------------------------------------
//
//  Function:   DfsRootFolder - Contstruct for the rootFolder class
//
//  Arguments:  NameContext -  the Dfs Name context
//              pLogicalShare - the Logical Share name
//              ObType - the object type. Set to the derived class type.
//              pStatus - status of this call.
//
//  Returns:    NONE
//
//  Description: This routine initializes the class variables of the
//               the root folder, and initialize the name context and 
//               logical share name to the passed in values.
//               It also allocated and initializes the lock for the root
//               folder, as well as all the locks that will be assigned
//               to the child folders.
//               We then create a metadata name table and a logical namespace
//               prefix table.
//
//--------------------------------------------------------------------------
DfsRootFolder::DfsRootFolder(
    IN LPWSTR NameContext,
    IN LPWSTR RootRegKeyNameString,
    IN PUNICODE_STRING pLogicalShare,
    IN PUNICODE_STRING pPhysicalShare,
    IN DfsObjectTypeEnumeration ObType,
    OUT DFSSTATUS *pStatus ) : DfsFolder (NULL, 
                                          NULL, 
                                          ObType )
{
    ULONG LockNum = 0;

    DFSSTATUS Status = ERROR_SUCCESS;

    DfsRtlInitUnicodeStringEx( &_DfsNameContext, NULL );
    DfsRtlInitUnicodeStringEx( &_LogicalShareName, NULL );
    DfsRtlInitUnicodeStringEx( &_RootRegKeyName, NULL );
    DfsRtlInitUnicodeStringEx( &_PhysicalShareName, NULL );
    DfsRtlInitUnicodeStringEx( &_ShareFilePathName, NULL );
    DfsRtlInitUnicodeStringEx( &_DirectoryCreateRootPathName, NULL );
    DfsRtlInitUnicodeStringEx( &_DfsVisibleContext, NULL );

    _DirectoryCreateError = STATUS_SUCCESS;
    
    _ShareAcquireStatus = STATUS_SUCCESS;
    
    _pMetadataNameTable = NULL;
    _pLogicalPrefixTable = NULL;
    _IgnoreNameContext = FALSE;
    _CreateDirectories = DfsCheckCreateDirectories();
    pStatistics = NULL;
    _pChildLocks = NULL;
    _pRootLock = NULL;
    
    _ChildCount = 0;

    _CurrentErrors = 0;

    _RootFlags = 0;

    _PrefetchNeeded = FALSE;
    _LogicalShareAddedToTable = FALSE;

    _RootFlavor = 0;

    _fRootLockInit = FALSE;

    _fpLockInit = FALSE;

    _TooManyEventLogErrors = FEWERRORS_ON_ROOT;

    ZeroMemory(&_fChildLocksInit, sizeof(_fChildLocksInit));

    Status = DfsCreateUnicodeStringFromString( &_DfsNameContext, NameContext );

    if ( Status == ERROR_SUCCESS )
    {
        DfsGetNetbiosName( &_DfsNameContext, &_DfsNetbiosNameContext, NULL );

        Status = DfsCreateUnicodeString( &_LogicalShareName, pLogicalShare );
    }

    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsCreateUnicodeStringFromString( &_RootRegKeyName,
                                                   RootRegKeyNameString );
    }

    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsCreateUnicodeString( &_PhysicalShareName,
                                         pPhysicalShare );
    }


    if ( Status == ERROR_SUCCESS )
    {
        pStatistics = new DfsStatistics();

        if (pStatistics == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        _pRootLock = new CRITICAL_SECTION;
        if ( _pRootLock == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        _fRootLockInit = (BOOLEAN) InitializeCriticalSectionAndSpinCount( _pRootLock, 0);
        if(!_fRootLockInit)
        {
            Status = GetLastError();
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        _pLock = new CRITICAL_SECTION;
        if ( _pLock == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        _fpLockInit = (BOOLEAN) InitializeCriticalSectionAndSpinCount( _pLock, DFS_CRIT_SPIN_COUNT );

        if(!_fpLockInit)
        {
            Status = GetLastError();
        }

        if(Status == ERROR_SUCCESS)
        {
            _Flags = DFS_FOLDER_ROOT;

            //
            // Allocate the child locks, and initiailize them.
            //
            _pChildLocks = new CRITICAL_SECTION[ NUMBER_OF_SHARED_LINK_LOCKS ];
            if ( _pChildLocks != NULL )
            {
                for ( LockNum = 0; LockNum < NUMBER_OF_SHARED_LINK_LOCKS; LockNum++ )
                {
                    _fChildLocksInit[LockNum] = (BOOLEAN) InitializeCriticalSectionAndSpinCount( &_pChildLocks[LockNum],DFS_CRIT_SPIN_COUNT ); 
                    if(!_fChildLocksInit[LockNum])
                    {
                        Status = GetLastError();
                        break;
                    }
                }
            } else
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;       
            }

        }

    }

    //
    // Initialize the prefix and nametable for this root.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsInitializePrefixTable( &_pLogicalPrefixTable,
                                           FALSE, 
                                           NULL );
    }

    if ( Status == ERROR_SUCCESS )
    {
        Status = DfsInitializeNameTable( 0, &_pMetadataNameTable );
    }


    //
    // We have not assigned any of the child locks: set the lock index 
    // to 0. This index provides us a mechanism of allocating locks
    // to the child folders in a round robin way.
    //
    _ChildLockIndex = 0;
    
    _LocalCreate = FALSE;

    //
    // we start by assuming we have to use the PDC for AD Blobs.
    //
    _RootScalability = FALSE;

    pPrevRoot = pNextRoot = NULL; 

    *pStatus = Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateLinkFolder - Create a DfsFolder and initialize it.
//
//  Arguments:  ChildName - metadata name of the child
//              pLinkName - the logical namespace name, relative to root
//              ppChildFolder -  the returned child folder
//
//  Returns:    Status: Success or error status
//
//  Description: This routine Creates a link folder and adds it to the
//               parent Root's table.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::CreateLinkFolder(
    IN LPWSTR ChildName,
    IN PUNICODE_STRING pLinkName,
    OUT DfsFolder **ppChildFolder,
    IN BOOLEAN CalledByApi )
{
    DfsFolder *pChildFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    const TCHAR * apszSubStrings[4];

    DFS_TRACE_LOW( REFERRAL_SERVER, "Create Link Folder: MetaName %ws, Link %wZ\n",
                   ChildName, pLinkName );

    //
    // Create a new child folder. Allocate a lock for this child
    // and pass the lock along to the Folder constructor.
    //
    pChildFolder = new DfsFolder (this,
                                  GetChildLock() );

    if ( pChildFolder == NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } else
    {
        //
        // We successfully created the folder. Now set the metadata
        // and logical name of the child folder.
        //
        Status = pChildFolder->InitializeMetadataName( ChildName );
        if ( Status == ERROR_SUCCESS )
        {
           Status = pChildFolder->InitializeLogicalName( pLinkName );
        }
    }

    if ( Status == ERROR_SUCCESS )
    {
        //
        // We now acquire the child folder's write lock, and insert
        // the child into the parent's metadata and logical namespace
        // tables.
        // When adding/removing the child in one of these tables,
        // it is necessary to acquire the child folder lock since 
        // we are setting state in the folder indicating whether the
        // child is in any of these tables.
        //

        Status = pChildFolder->AcquireWriteLock();

        if ( Status == ERROR_SUCCESS )
        {
            Status = InsertLinkFolderInMetadataTable( pChildFolder );

            if ( Status == ERROR_SUCCESS )
            {
                IncrementChildCount();
                Status = InsertLinkFolderInLogicalTable( pChildFolder );
            }

            pChildFolder->ReleaseLock();
        }
    }



    if (Status == ERROR_SUCCESS)
    {
        DFSSTATUS DfStatus;

        DfStatus = SetupLinkReparsePoint( pChildFolder->GetFolderLogicalNameString() );
        if(DfStatus != ERROR_SUCCESS)
        {
            apszSubStrings[0] = pChildFolder->GetFolderLogicalNameString();
            apszSubStrings[1] = GetDirectoryCreatePathName()->Buffer;
            GenerateEventLog(DFS_ERROR_CREATE_REPARSEPOINT_FAILURE,
                             2,
                             apszSubStrings,
                             DfStatus);
        }

        if(CalledByApi)
        {
            Status = DfStatus;
        }

        DFS_TRACE_ERROR_LOW(DfStatus, REFERRAL_SERVER, "[%!FUNC!]Setup link reparse point child %p, link %wZ, Status %x\n",
                            pChildFolder, pLinkName, Status);
    }

    //
    // If we are successful, return the newly created child folder.
    // We currently have a reference on the folder (the reference on 
    // the folder when the folder was created)
    //
    // If we encountered an error, and the childFolder has been created,
    // get rid of out reference on this folder. This will usually 
    // destroy the childFolder.
    //
    //
    if ( Status == ERROR_SUCCESS )
    {
        *ppChildFolder = pChildFolder;

        pStatistics->UpdateLinkAdded();

        LoadServerSiteData(pChildFolder);
        
    } else
    {
        if ( pChildFolder != NULL )
        {
            pChildFolder->ReleaseReference();
        }
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Create Link Folder: MetaName %ws, Child %p Status %x\n",
                   ChildName, pChildFolder, Status );

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   UpdateLinkFolder - Update a DfsFolder.
//
//  Arguments:  ChildName - metadata name of the child
//              pLinkName - the logical namespace name, relative to root
//              pChildFolder -  the child folder
//
//  Returns:    Status: Success or error status
//
//  Description: This routine TBD
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::UpdateLinkFolder(
    IN LPWSTR ChildName,
    IN PUNICODE_STRING pLinkName,
    IN DfsFolder *pChildFolder )
{
    BOOLEAN Removed = FALSE;

    UNREFERENCED_PARAMETER(ChildName);
    UNREFERENCED_PARAMETER(pLinkName);

    pChildFolder->RemoveReferralData( NULL, &Removed );

    pStatistics->UpdateLinkModified();
    if (Removed == TRUE)
    {
        pStatistics->UpdateForcedCacheFlush();
    }

    LoadServerSiteData(pChildFolder);

    //
    // Create directories too. Delete old directories.
    //
    return ERROR_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveAllLinkFolders - Remove all folders of this root
//
//  Arguments:  None
//
//  Returns:    Status: Success or error status
//
//  Description: This routine TBD
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::RemoveAllLinkFolders(
    BOOLEAN IsPermanent)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolder *pChildFolder;
    ULONG Count = 0;

    while (Status == ERROR_SUCCESS)
    {
        Status = LookupFolder(&pChildFolder);
        if (Status == ERROR_SUCCESS)
        {
            Status = RemoveLinkFolder(pChildFolder,
                                      IsPermanent);

            pChildFolder->ReleaseReference();
            Count++;
        }
    }

    DFS_TRACE_ERROR_HIGH( Status, REFERRAL_SERVER, "Remove all link folders Count %d Status %x\n", 
                          Count, 
                          Status);

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   RemoveLinkFolder - Update a DfsFolder.
//
//  Arguments:  ChildName - metadata name of the child
//              pLinkName - the logical namespace name, relative to root
//              pChildFolder -  the child folder
//
//  Returns:    Status: Success or error status
//
//  Description: This routine TBD
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::RemoveLinkFolder(
    IN DfsFolder *pChildFolder,
    BOOLEAN IsPermanent )
{

    DFSSTATUS Status = ERROR_SUCCESS;


    if (IsPermanent == TRUE)
    {
        //
        // try to tear down the link reparse point: return status ignored.
        //
        Status = TeardownLinkReparsePoint( pChildFolder->GetFolderLogicalNameString() );

        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!] Tear down reparse for %p, status %x \n", pChildFolder, Status );
    }

    Status = pChildFolder->AcquireWriteLock();

    if ( Status == ERROR_SUCCESS )
    {


        Status = RemoveLinkFolderFromMetadataTable( pChildFolder );

        if ( Status == ERROR_SUCCESS )
        {
            DFSSTATUS LinkRemoveStatus;

            pChildFolder->SetFlag( DFS_FOLDER_DELETE_IN_PROGRESS );

            DecrementChildCount();
            LinkRemoveStatus = RemoveLinkFolderFromLogicalTable( pChildFolder );
            DFS_TRACE_ERROR_LOW(LinkRemoveStatus, REFERRAL_SERVER, "Remove Link From logical %p, status %x \n", pChildFolder, LinkRemoveStatus );
        }

        pChildFolder->ReleaseLock();
    }


    if (Status == ERROR_SUCCESS)
    {
        pStatistics->UpdateLinkDeleted();
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Remove Link Folder %p, status %x \n", pChildFolder, Status );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetDfsReparsePoint
//
//  Arguments:  DirHandle - handle on open directory
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a handle to an open directory and
//               makes that directory a reparse point with the DFS tag
//
//--------------------------------------------------------------------------

NTSTATUS
DfsRootFolder::SetDfsReparsePoint(
    IN HANDLE DirHandle )
{
    NTSTATUS NtStatus;
    REPARSE_DATA_BUFFER         ReparseDataBuffer;
    IO_STATUS_BLOCK IoStatusBlock;
    
    //
    // Attempt to set a reparse point on the directory
    //
    RtlZeroMemory( &ReparseDataBuffer, sizeof(ReparseDataBuffer) );

    ReparseDataBuffer.ReparseTag          = IO_REPARSE_TAG_DFS;
    ReparseDataBuffer.ReparseDataLength   = 0;

    NtStatus = NtFsControlFile( DirHandle,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_SET_REPARSE_POINT,
                                &ReparseDataBuffer,
                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataBuffer.ReparseDataLength,
                                NULL,
                                0 );
    

    return NtStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   MorphLinkCollision
//
//  Arguments:  DirectoryName - Name of directory to morph.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine takes a NT pathname to a directory. It
//               renames that directory with a morphed name.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::MorphLinkCollision( 
    PUNICODE_STRING ParentDirectory,
    PUNICODE_STRING DirectoryToRename )
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = RenamePath(ParentDirectory,
                        DirectoryToRename);

    return Status;
}



DFSSTATUS
DfsRootFolder::TeardownLinkReparsePoint(
    LPWSTR LinkNameString )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE DirectoryHandle = NULL;
    UNICODE_STRING LinkName;

    Status = DfsRtlInitUnicodeStringEx( &LinkName, LinkNameString);

    if ((IsRootFolderShareAcquired() == TRUE) &&
        (Status == ERROR_SUCCESS))
    {

        NtStatus = DfsOpenDirectory ( GetDirectoryCreatePathName(),
                                   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                   NULL,
                                   &DirectoryHandle,
                                   NULL );

        if (NtStatus == STATUS_SUCCESS)
        {
            //
            // Delete empty parent directories as well.
            //
            NtStatus = DfsDeleteLinkReparsePointAndParents( &LinkName, DirectoryHandle );
            DfsCloseDirectory( DirectoryHandle );
        }
        
        Status = RtlNtStatusToDosError(NtStatus);
    }

   return Status;
}



DFSSTATUS
DfsRootFolder::SetupLinkReparsePoint(
    LPWSTR LinkNameString )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE DirectoryHandle = NULL;
    UNICODE_STRING LinkName;

    //
    // We don't want to create any reparse points
    // if we're not supposed to.
    //
    if (IsRootCreateDirectories() == FALSE)
        return ERROR_SUCCESS;
        
    Status = GetRootShareAcquireStatus();
    if(Status == ERROR_SUCCESS)
    {
        Status = DfsRtlInitUnicodeStringEx( &LinkName, LinkNameString);
        if (Status == ERROR_SUCCESS)
        {
            NtStatus = DfsOpenDirectory ( GetDirectoryCreatePathName(),
                                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                       NULL,
                                       &DirectoryHandle,
                                       NULL );

            if (NtStatus == STATUS_SUCCESS)
            {
                Status = CreateLinkReparsePoint( &LinkName,
                                                 DirectoryHandle );

                DfsCloseDirectory( DirectoryHandle );
            }
            else
            {
                Status = RtlNtStatusToDosError(NtStatus);
            }
        }
    }

   if (Status != ERROR_SUCCESS)
   {
       SetLastCreateDirectoryError(Status);
   }
   
   return Status;

}

DFSSTATUS
DfsRootFolder::CreateLinkReparsePoint(
    PUNICODE_STRING pLinkName,
    HANDLE RelativeHandle )
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS MorphStatus = ERROR_SUCCESS;
    DFSSTATUS DosStatus = ERROR_SUCCESS;
    ULONG    ShareMode = 0;
    ULONG    RetryCount = 0;
    HANDLE DirectoryHandle = INVALID_HANDLE_VALUE;
    BOOLEAN IsNewlyCreated = FALSE;
    UNICODE_STRING LastComp;

Retry:

    DfsRtlInitUnicodeStringEx(&LastComp, NULL);

    NtStatus = CreateLinkDirectories( pLinkName,
                                      RelativeHandle,
                                      &DirectoryHandle,
                                      &IsNewlyCreated,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE );
    if (NtStatus == STATUS_SUCCESS)
    {
        NtStatus = SetDfsReparsePoint( DirectoryHandle);

        NtClose( DirectoryHandle);

        if((RetryCount == 0) && (NtStatus == STATUS_DIRECTORY_NOT_EMPTY))
        {
            StripAndReturnLastPathComponent(pLinkName, &LastComp);

            MorphStatus = MorphLinkCollision(pLinkName, &LastComp);

            AddNextPathComponent(pLinkName);

            if(MorphStatus == ERROR_SUCCESS)
            {
                RetryCount++;
                goto Retry;
            }
        }
    }

    DosStatus = RtlNtStatusToDosError(NtStatus);

    DFS_TRACE_ERROR_HIGH(DosStatus, REFERRAL_SERVER, "[%!FUNC!] DirectoryName of interest %wZ: Create Reparse point Status %x\n",
                         pLinkName, 
                         DosStatus);

    return DosStatus;
}


NTSTATUS
DfsRootFolder::CreateLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    HANDLE            RelativeHandle,
    PHANDLE           pDirectoryHandle,
    PBOOLEAN          pIsNewlyCreated,
    ULONG             ShareMode )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE CurrentDirectory = INVALID_HANDLE_VALUE;
    HANDLE LocalRelativeHandle = INVALID_HANDLE_VALUE;
    BOOLEAN DfsMountPoint = FALSE;
    BOOLEAN  NewlyCreated = FALSE;
    UNICODE_STRING RemainingName;
    UNICODE_STRING TempString;
    UNICODE_STRING DirectoryToCreate;
    UNICODE_STRING TrackDirectory;

    TrackDirectory = *pLinkName;
    TrackDirectory.Length = 0;

    LocalRelativeHandle = RelativeHandle;

    NtStatus = DfsGetFirstComponent(pLinkName, 
                                    &DirectoryToCreate, 
                                    &RemainingName);

    while ( NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DfsOpenDirectory( &DirectoryToCreate,
                                  ShareMode,
                                  LocalRelativeHandle,
                                  &CurrentDirectory,
                                  &NewlyCreated );
        if (NtStatus == STATUS_SUCCESS)
        {

            AddNextPathComponent(&TrackDirectory);

            if(LocalRelativeHandle != RelativeHandle)
            {
                DfsCloseDirectory( LocalRelativeHandle );
            }

            LocalRelativeHandle = CurrentDirectory;
            CurrentDirectory = INVALID_HANDLE_VALUE;


            if(RemainingName.Length == 0)
            {
                break;
            }

            NtStatus = DfsGetNextComponent(&RemainingName, 
                                           &DirectoryToCreate, 
                                           &TempString);
            RemainingName = TempString;
        }
        else if(NtStatus == STATUS_NOT_A_DIRECTORY)
        {
            Status = MorphLinkCollision(&TrackDirectory,
                                        &DirectoryToCreate);
            if(Status == ERROR_SUCCESS)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }
    } 

    if (NtStatus == STATUS_SUCCESS)
    {
        IsDirectoryMountPoint(LocalRelativeHandle,
                              &DfsMountPoint);

        if(DfsMountPoint)
        {
            NtStatus = STATUS_DIRECTORY_IS_A_REPARSE_POINT;

            if(LocalRelativeHandle != INVALID_HANDLE_VALUE)
            {
                DfsCloseDirectory( LocalRelativeHandle );
                LocalRelativeHandle = INVALID_HANDLE_VALUE;
            }
        }
        else
        {
            if(pDirectoryHandle)
            {
                *pDirectoryHandle = LocalRelativeHandle;
            }
            else
            {
                DfsCloseDirectory( LocalRelativeHandle );
            }

            if(pIsNewlyCreated)
            {
                *pIsNewlyCreated = NewlyCreated;
            }
        }

    }
    else
    {

        if(LocalRelativeHandle != RelativeHandle)
        {
            if(LocalRelativeHandle != INVALID_HANDLE_VALUE)
            {
                DfsCloseDirectory( LocalRelativeHandle );
                LocalRelativeHandle = INVALID_HANDLE_VALUE;
            }
        }
    }


    DFS_TRACE_ERROR_LOW(NtStatus, REFERRAL_SERVER, "CreateLinkDirectory: %wZ: Status %x\n",
                        pLinkName, NtStatus );
    return NtStatus;
}


#define WHACKWHACKDOTWHACKDIROFFSET 14

//the code below attempt to see if the directory, pointed to by pDirectory
//name is a mount point. The name comes in looking like \\??\\c:\directoryname.
//To see if this name is a mount point, we have to open up the parent directory,
//and then try to create the subdirectory. In the name above, \\??\\c:\ is the 
//parent directory and directoryname is the subdirectory.WHACKWHACKDOTWHACKDIROFFSET
//is the length of \\??\\c:\. This is the RootDir in the below code. The remaining
//name is the rest of the string

NTSTATUS 
DfsRootFolder::IsRootShareMountPoint(PUNICODE_STRING pDirectoryName)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE DirHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING RemainingName;
    UNICODE_STRING RootDir;

    RootDir = RemainingName = * pDirectoryName;

    //setup the root directory length (i.e \\??\\c:\)
    RootDir.Length = (USHORT) WHACKWHACKDOTWHACKDIROFFSET;

    //next, setup the renmaining piece of the directory
    RemainingName.Length -= (USHORT) WHACKWHACKDOTWHACKDIROFFSET;
    RemainingName.MaximumLength -= (USHORT)WHACKWHACKDOTWHACKDIROFFSET;
    RemainingName.Buffer = &RemainingName.Buffer[WHACKWHACKDOTWHACKDIROFFSET/sizeof(WCHAR)];


    //open the root directory
    InitializeObjectAttributes ( &ObjectAttributes, 
                                 &RootDir,
                                 OBJ_CASE_INSENSITIVE,  //Attributes
                                 NULL,                  //Root handle
                                 NULL );                //Security descriptor.

    NtStatus = NtOpenFile( &DirHandle,
                           (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT );

    if(NtStatus == STATUS_SUCCESS)
    {

        //now, if there is still a path left, try to create this directory.
        if(RemainingName.Length != 0)
        {
            NtStatus = CreateLinkDirectories(&RemainingName, 
                                            DirHandle, 
                                            NULL,
                                            NULL,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);
        }

        CloseHandle(DirHandle);
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   AcquireRootShareDirectory 
//
//  Arguments:  none
//
//  Returns:    Status: success if we passed all checks.
//
//  Description: This routine checks to see if the share backing the
//               the dfs root actually exists. If it does, it confirms
//               that the filesystem hosting this directory supports
//               reparse points. Finally, it tells the driver to attach
//               to this directory.
//               If all of this works, we have acquired the root share.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::AcquireRootShareDirectory(void)
{

    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    DFSSTATUS                   Status = ERROR_SUCCESS;
    HANDLE                      DirHandle = NULL;
    PUNICODE_STRING             pDirectoryName = NULL;
    PUNICODE_STRING             pUseShare = NULL;
    PUNICODE_STRING             pLogicalShare = NULL;
    BOOLEAN                     SubStringMatch = FALSE;
    BOOLEAN                     Inserted = FALSE;
    BOOLEAN                     PhysicalShareInDFS = FALSE;
    BOOLEAN                     DfsMountPoint = FALSE;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    ULONG                       pAttribInfoSize;
    PFILE_FS_ATTRIBUTE_INFORMATION pAttribInfo = NULL;
    UNICODE_STRING              LogicalVol;
    const TCHAR * apszSubStrings[4];

    
    ZeroMemory (&LogicalVol, sizeof(LogicalVol));


    pUseShare  = GetRootPhysicalShareName();

    pLogicalShare  = GetLogicalShare();

    DFS_TRACE_LOW(REFERRAL_SERVER, "[%!FUNC!] AcquireRoot Share called for root %p, name %wZ\n", this, pUseShare);
    //
    // if either the root share is already acquired, or the library
    // was told that we are not interested in creating directories, we
    // are done.
    //
    if ( (IsRootFolderShareAcquired() == TRUE) ||
         (IsRootCreateDirectories() == FALSE) )
    {
        DFS_TRACE_LOW(REFERRAL_SERVER, "Root %p, Share Already acquired\n", this);
        return ERROR_SUCCESS;
    }
    //
    // first we get the logical share
    // Then we call into initialize directory information to setup the
    // physical share path etc.
    //

    Status = InitializeDirectoryCreateInformation();


    //
    // If the directory create path is invalid, we are done.
    //
    if (Status == ERROR_SUCCESS)
    {
        pDirectoryName = GetDirectoryCreatePathName();

        if ( (pDirectoryName == NULL) || 
             (pDirectoryName->Buffer == NULL) ||
             (pDirectoryName->Length == 0) )
        {
            Status = ERROR_INVALID_PARAMETER;

        }
    }

    if (Status == ERROR_SUCCESS)
    {
        //
        // Now allocate space to fill the attribute information we 
        // will query.
        // dfsdev: document why we allocate an additional max_path.
        //
        pAttribInfoSize = sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + MAX_PATH;
        pAttribInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)new BYTE [pAttribInfoSize];
        if (pAttribInfo != NULL)
        {
            InitializeObjectAttributes ( &ObjectAttributes, 
                                         pDirectoryName,
                                         OBJ_CASE_INSENSITIVE,                     //Attributes
                                         NULL,                  //Root handle
                                         NULL );                //Security descriptor.

            NtStatus = NtOpenFile( &DirHandle,
                                   (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                                   &ObjectAttributes,
                                   &IoStatusBlock,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT );
    

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Query for the basic information, which has the attributes.
                //
                NtStatus = NtQueryVolumeInformationFile( DirHandle,
                                                         &IoStatusBlock,
                                                         pAttribInfo,
                                                         pAttribInfoSize,
                                                         FileFsAttributeInformation );

                if (NtStatus == STATUS_SUCCESS)
                {
                    //
                    // If the attributes indicate reparse point, we have a reparse
                    // point directory on our hands.
                    //
                    if ( (pAttribInfo->FileSystemAttributes & FILE_SUPPORTS_REPARSE_POINTS) == 0)
                    {
                        NtStatus = STATUS_NOT_SUPPORTED;
                        apszSubStrings[0] = pUseShare->Buffer;
                        apszSubStrings[1] = pDirectoryName->Buffer;
                        GenerateEventLog(DFS_ERROR_UNSUPPORTED_FILESYSTEM,
                                         2,
                                         apszSubStrings,
                                         0);
                                         
                    }
                }

                CloseHandle (DirHandle);

            }
            else
            {
                Status = RtlNtStatusToDosError(NtStatus);

                DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!] - NTOPEN failed share for root %p, (%wZ) (%wZ) status %x NtStatus %x\n",
                        this, pUseShare, pDirectoryName, Status, NtStatus);

            }

            if (NtStatus == STATUS_SUCCESS)
            {
                NtStatus = IsRootShareMountPoint(pDirectoryName);
            }

            if( NtStatus != STATUS_SUCCESS)
            {
                Status = RtlNtStatusToDosError(NtStatus);
            }

            delete [] pAttribInfo;
            pAttribInfo = NULL;
            
            DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "AcquireRoot - IsRootShareMountPoint failed share for root %p, (%wZ) (%wZ) status %x NtStatus %x\n",
                        this, pUseShare, pDirectoryName, Status, NtStatus);

        }
        else {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!] Root %p, Share check status %x\n", this, Status);
    //
    // Now check if we already know about parts of this path.
    // if there is overlap with other paths that we already know about,
    // we cannot handle this root, so reject it.
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = DfsAddKnownDirectoryPath( pDirectoryName,
                                           pUseShare );
        if (Status == ERROR_SUCCESS)
        {
            Inserted = TRUE;
        }
        else
        {
            Status = ERROR_BAD_PATHNAME;
            apszSubStrings[0] = pUseShare->Buffer;
            apszSubStrings[1] = pDirectoryName->Buffer;
            GenerateEventLog(DFS_ERROR_OVERLAPPING_DIRECTORIES,
                             2,
                             apszSubStrings,
                             0);
        }
        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "Root %p, Share add known directory status %x\n", this, Status);
    }


    //
    // if we are here: we know this is a reparse point, and we have
    // inserted in the user mode database. 
    // now call into the driver so it may attach to this filesystem.
    //

    if (Status == ERROR_SUCCESS)
    {
        Status = DfsUserModeAttachToFilesystem( pDirectoryName,
                                                pUseShare);
        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]Root %p, user mode attach status %x\n", this, Status);

        if(Status == ERROR_SUCCESS)
        {
            PhysicalShareInDFS = TRUE;

            if (RtlCompareUnicodeString(pUseShare, pLogicalShare, TRUE ))
            {
                Status = DfsUserModeAttachToFilesystem( &LogicalVol,
                                                        pLogicalShare);
                if(Status == ERROR_SUCCESS)
                {
                    _LogicalShareAddedToTable = TRUE;

                }
            }
        }
    }


    if(Status == ERROR_SUCCESS)
    {
        Status = SendShareToSrv(pUseShare, TRUE);
        DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]Root %p, user mode SendShareToSrv status %x\n", this, Status);
    }

    //
    // if we are successful, we acquired the root share, now mark
    // our state accordingly.
    //

    if (Status == ERROR_SUCCESS)
    {
        SetRootFolderShareAcquired();
        SetRootShareAcquireStatus(Status);
    }
    else 
    {
        //
        // otherwise, clear up some of the work we just did.
        //
        ClearRootFolderShareAcquired();
        SetRootShareAcquireStatus(Status);
        if (Inserted == TRUE)
        {
            DfsRemoveKnownDirectoryPath( pDirectoryName,
                                         pUseShare);
        }

        if(PhysicalShareInDFS == TRUE)
        {   DFSSTATUS LocalStatus = ERROR_SUCCESS;

            LocalStatus = DfsUserModeDetachFromFilesystem( pDirectoryName,
                                                           pUseShare);
        }


        if(_LogicalShareAddedToTable == TRUE)
        {   DFSSTATUS LocalStatus = ERROR_SUCCESS;

            LocalStatus = DfsUserModeDetachFromFilesystem( &LogicalVol,
                                                           pUseShare);
        }
    }
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]AcquireRoot share for root %p, (%wZ) status %x\n",
                        this, pUseShare, Status);
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   ReleaseRootShareDirectory 
//
//  Arguments:  none
//
//  Returns:    Status: success if we are successful
//
//  Description: This routine checks to see if the share backing the
//               the dfs root was acquired by us earlier. If so, we
//               tell the driver to releast its reference on this 
//               share, and remove this information from our tables,
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::ReleaseRootShareDirectory(void)
{

    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    DFSSTATUS                   Status = ERROR_SUCCESS;
    PUNICODE_STRING             pDirectoryName = NULL;
    PUNICODE_STRING             pUseShare = NULL;
    PUNICODE_STRING             pLogicalShare = NULL;
    PVOID                       pData = NULL;
    BOOLEAN                     SubStringMatch = FALSE;
    UNICODE_STRING              LogicalVol;

    DFS_TRACE_LOW(REFERRAL_SERVER, "[%!FUNC!]ReleaseRoot share for root %p\n", this);
    if (IsRootFolderShareAcquired() == TRUE)
    {
        //
        // get the logical share, and the physical directory backing the
        // share.
        //

        ZeroMemory (&LogicalVol, sizeof(LogicalVol));
        pUseShare  = GetRootPhysicalShareName();
        pLogicalShare  = GetLogicalShare();
        pDirectoryName = GetDirectoryCreatePathName();

        if ( (pDirectoryName == NULL) || 
             (pDirectoryName->Buffer == NULL) ||
             (pDirectoryName->Length == 0) )
        {
            Status = ERROR_INVALID_PARAMETER;
        }

        if(Status == ERROR_SUCCESS)
        {
            Status = SendShareToSrv(pUseShare, FALSE);

            DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]SendShareToSrv path %wZ, %wZ: Status %x\n",
                                pDirectoryName, pUseShare, Status );
        }
        //
        // now, signal the driver to detach itself from this share.
        //dfsdev: if this fails, we are in an inconsistent state, since
        // we just removed it from our table above!
        //
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsUserModeDetachFromFilesystem( pDirectoryName,
                                                      pUseShare);
            DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]user mode detach path %wZ, %wZ: Status %x\n",
                                pDirectoryName, pUseShare, Status );

        }

        if (Status == ERROR_SUCCESS)
        {
            if(_LogicalShareAddedToTable == TRUE)
            {   DFSSTATUS LocalStatus = ERROR_SUCCESS;

                LocalStatus = DfsUserModeDetachFromFilesystem( &LogicalVol,
                                                               pUseShare);
            }
        }

        //
        // now, find the information in our database. if we did not find an
        // exact match, something went wrong and signal that.
        //
        if (Status == ERROR_SUCCESS)
        {
            DFSSTATUS RemoveStatus;

            RemoveStatus = DfsRemoveKnownDirectoryPath( pDirectoryName,
                                                        pUseShare );

            DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]RemoveKnownDirectory path %wZ, %wZ: Status %x\n",
                                 pDirectoryName, pUseShare, RemoveStatus );
        }


        if (Status == ERROR_SUCCESS)
        {
            ClearRootFolderShareAcquired();
        }
    }
    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]Release root share %p, Status %x\n",
                        this, Status );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   AddMetadataLink
//
//  Arguments:  
//        pLogicalName: the complete logical unc name of this link.
//        ReplicaServer: the target server for this link.
//        ReplicaPath: the target path on the server.
//        Comment : comment to be associated with this link.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine Adds a link to the metadata.
//               In future, ReplicaServer and ReplicaPath's
//               can be null, since we will allow links with
//               no targets. 
//               dfsdev: make sure we do the right thing for
//               compat.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//               The caller is also responsible for ensuring
//               this link does not already exist in the
//               the metadata.
//               The caller is also responsible to make sure that this
//               name does not overlap an existing link.
//               (for example if link a/b exisits, link a or a/b/c are
//               overlapping links and should be disallowed.)
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::AddMetadataLink(
    PUNICODE_STRING  pLogicalName,
    LPWSTR           ReplicaServer,
    LPWSTR           ReplicaPath,
    LPWSTR           Comment )
{
    DFS_METADATA_HANDLE RootHandle = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    BOOLEAN IsDomainDfs = FALSE;
    UNICODE_STRING LinkMetadataName;
    UNICODE_STRING VisibleNameContext, UseName;
    DFS_NAME_INFORMATION NameInfo;
    DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
    DFS_REPLICA_INFORMATION ReplicaInfo;

    UUID NewUid;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = UuidCreate(&NewUid);
    if (Status == ERROR_SUCCESS)
    {
        Status = GetMetadataStore()->GenerateLinkMetadataName( &NewUid,
                                                               &LinkMetadataName);
    }


    if (Status == ERROR_SUCCESS)
    {
        //
        // First get a handle to the 
        // metadata. The handle has different meaning to different 
        // underlying stores: for example the registry store may
        // use the handle as a key, while the ad store may use the
        // handle as a pointer in some cache.
        //
        Status = GetMetadataHandle( &RootHandle );

        if (Status == ERROR_SUCCESS)
        {
            GetVisibleNameContextLocked( NULL, &VisibleNameContext );

            Status = GetMetadataStore()->GenerateMetadataLogicalName( &VisibleNameContext,
                                                                      pLogicalName,
                                                                      &UseName );

            if (Status == ERROR_SUCCESS)
            {
                GetMetadataStore()->StoreInitializeNameInformation( &NameInfo,
                                                                    &UseName,
                                                                    &NewUid,
                                                                    Comment );
                if (DfsIsThisARealDfsName(ReplicaServer, ReplicaPath, &IsDomainDfs) == ERROR_SUCCESS)
                {
                    NameInfo.Type |= (PKT_ENTRY_TYPE_OUTSIDE_MY_DOM);

                }

                GetMetadataStore()->StoreInitializeReplicaInformation( &ReplicaListInfo,
                                                                       &ReplicaInfo,
                                                                       ReplicaServer,
                                                                       ReplicaPath );

                Status = GetMetadataStore()->AddChild( RootHandle,
                                                       &NameInfo,
                                                       &ReplicaListInfo,
                                                       &LinkMetadataName );

                //
                // if we failed add child, we need to reset the
                // internal state to wipe out any work we did when
                // we were adding the child.
                //
                if (Status != ERROR_SUCCESS)
                {

                    DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::AddMetadataLink path %wZ, %ws, %ws: Status %x\n",
                                         pLogicalName, ReplicaServer, ReplicaPath, Status );
                    ReSynchronize(TRUE);
                }

                GetMetadataStore()->ReleaseMetadataLogicalName(&UseName );

                //
                // if we successfully added the link, update the link information
                // so that we can pass this out in referrals, and create the appropriate
                // directories.
                //  
                if (Status == ERROR_SUCCESS)
                {

                    Status = UpdateLinkInformation( RootHandle,
                                                    LinkMetadataName.Buffer,
                                                    TRUE );

                    if(Status != ERROR_SUCCESS)
                    {
                        DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::AddMetadataLink (2) path %wZ, %ws, %ws: Status %x\n",
                                             pLogicalName, ReplicaServer, ReplicaPath, Status );
                    }

                }
            }

            //
            // Finally, release the root handle we acquired earlier.
            //

            ReleaseMetadataHandle( RootHandle );
        }
        GetMetadataStore()->ReleaseLinkMetadataName( &LinkMetadataName );
    }

    ReleaseRootLock();
    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   RemoveMetadataLink
//
//  Arguments:  
//        pLogicalName: the link name relative to root share
//
//  Returns:   SUCCESS or error
//
//  Description: This routine removes a link from the the metadata.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::RemoveMetadataLink(
    PUNICODE_STRING pLinkName )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR  LinkMetadataName = NULL;
    DfsFolder *pFolder = NULL;
    DFS_METADATA_HANDLE RootHandle;
    UNICODE_STRING Remaining;
    
    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    // First, look this link up in our local data structures.
    //
    Status = LookupFolderByLogicalName( pLinkName,
                                        &Remaining,
                                        &pFolder );

    //
    // if an EXACT match was not found, we are done.
    //
    if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
    {
        pFolder->ReleaseReference();
        Status = ERROR_NOT_FOUND;

        DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::RemoveMetadataLink (1) path %wZ: Status %x\n",
                             pLinkName, Status );
    }

    //
    // we found the child folder. Now work on removing the metadata
    // and our local structures associated with this link.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // Get a handle to our metadata.
        //
        Status = GetMetadataHandle( &RootHandle );

        //
        //Now, look up the metadata name and remove it from the store.
        //
        if (Status == ERROR_SUCCESS)
        {
            LinkMetadataName = pFolder->GetFolderMetadataNameString();
        
            Status = GetMetadataStore()->RemoveChild( RootHandle,
                                                      LinkMetadataName );

            if (Status != ERROR_SUCCESS)
            {

                DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::RemoveMetadataLink path %wZ: Status %x\n",
                                     pLinkName, Status );
                ReSynchronize(TRUE);
            }

            ReleaseMetadataHandle( RootHandle );

            //
            // If we successfully removed the child from the metadata,
            // remove the link folder associated with this child. This will
            // get rid of our data structure and related directory for that child.
            //
            if (Status == ERROR_SUCCESS)
            {
                DFSSTATUS RemoveStatus;

                RemoveStatus = RemoveLinkFolder( pFolder,
                                                 TRUE ); // permanent removal
            }
        }
        pFolder->ReleaseReference();
    }

    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   AddMetadataLinkReplica
//
//  Arguments:  
//        pLinkName: the link name relative to root share
//        ReplicaServer : the target server to add
//        ReplicaPath : the target path on the server.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine adds a target to an existing link.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::AddMetadataLinkReplica(
    PUNICODE_STRING pLinkName,
    LPWSTR    ReplicaServer,
    LPWSTR    ReplicaPath )
{
    DFS_METADATA_HANDLE RootHandle;
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsFolder *pFolder = NULL;
    BOOLEAN IsDomainDfs = FALSE;
    LPWSTR LinkMetadataName = NULL;
    UNICODE_STRING Remaining;

    //
    // If either the target server or the path is null, reject the request.
    //
    if ((ReplicaServer == NULL) || (ReplicaPath == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    // Find the link folder associated with this logical name.
    //
    Status = LookupFolderByLogicalName( pLinkName,
                                        &Remaining,
                                        &pFolder );

    //
    // If we did not find an EXACT match on the logical name, we are done.
    //
    if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
    {
        pFolder->ReleaseReference();
        Status = ERROR_NOT_FOUND;
    }

    if ( (Status == ERROR_SUCCESS) &&
         (I_NetDfsIsThisADomainName(ReplicaServer) == ERROR_SUCCESS))
    {
        //
        //dfsdev: include in this check nameinfo->type == OUTSIDE_MY_DOM.
        //
        pFolder->ReleaseReference();
        Status = ERROR_NOT_SUPPORTED;

        DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::AddMetadataLinkReplica (1) path %wZ, %ws, %ws: Status %x\n",
                             pLinkName, ReplicaServer, ReplicaPath, Status );
    }
    
    //
    // if we are successful so far, call the store with a handle to
    // the metadata to add this target.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // get the metadata name for this link from the root folder.
        //
        LinkMetadataName = pFolder->GetFolderMetadataNameString();

        //
        // Get a handle to the root metadata this root folder.
        //  
        Status = GetMetadataHandle( &RootHandle );
        
        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->AddChildReplica( RootHandle,
                                                          LinkMetadataName,
                                                          ReplicaServer,
                                                          ReplicaPath );

            if (Status != ERROR_SUCCESS)
            {

                DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::AddMetadataLinkReplica path %wZ, %ws, %ws: Status %x\n",
                                     pLinkName, ReplicaServer, ReplicaPath, Status );
                ReSynchronize(TRUE);
            }
            //
            // Release the metadata handle we acquired earlier.
            //
            ReleaseMetadataHandle( RootHandle );
        }

        //
        // If we successfully added the target in the metadata, update the
        // link folder so that the next referral request will pick up the 
        // new target.
        //
        if (Status == ERROR_SUCCESS)
        {
            DFSSTATUS UpdateStatus;

            UpdateStatus = UpdateLinkFolder( LinkMetadataName,
                                             pLinkName,
                                             pFolder );
            //
            // dfsdev: log the update state.
            //
        }

        //
        // we are done with this link folder: release thre reference we got
        // when we looked it up.
        //
        pFolder->ReleaseReference();
    }

    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveMetadataLinkReplica
//
//  Arguments:  
//        pLinkName: the link name relative to root share
//        ReplicaServer : the target server to remove
//        ReplicaPath : the target path on the server.
//        pLastReplica: pointer to boolean, returns true if the last
//                      target on this link is being deleted.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine removes the target of an existing link.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::RemoveMetadataLinkReplica(
    PUNICODE_STRING pLinkName,
    LPWSTR  ReplicaServer,
    LPWSTR  ReplicaPath,
    PBOOLEAN pLastReplica )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR  LinkMetadataName = NULL;
    DfsFolder *pFolder = NULL;
    DFS_METADATA_HANDLE RootHandle;
    UNICODE_STRING Remaining;
    

    //
    // if either the target server or target path is empty, return error.
    //
    if ((ReplicaServer == NULL) || (ReplicaPath == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    //
    //find the link folder associated with this logical name.
    //
    Status = LookupFolderByLogicalName( pLinkName,
                                        &Remaining,
                                        &pFolder );

    //
    // if we did not find an EXACT match on the logical name, we are done.
    //
    if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
    {
        pFolder->ReleaseReference();
        Status = ERROR_NOT_FOUND;
    }

    //
    // Call the store to remove the target from this child.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // Get the link metadata name from the folder.
        //
        LinkMetadataName = pFolder->GetFolderMetadataNameString();

        //
        // Get the handle to the root metadata for this root folder.
        //  
        Status = GetMetadataHandle( &RootHandle );
        
        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->RemoveChildReplica( RootHandle,
                                                             LinkMetadataName,
                                                             ReplicaServer,
                                                             ReplicaPath,
                                                             pLastReplica );

            if( (Status != ERROR_SUCCESS) && (Status != ERROR_LAST_ADMIN))
            {

                DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::RemoveMetadataLinkReplica path %wZ, %ws, %ws: Status %x\n",
                                     pLinkName, ReplicaServer, ReplicaPath, Status );
                ReSynchronize(TRUE);
            }
            //
            // release the metadata handle we acquired a little bit earlier.
            //
            ReleaseMetadataHandle( RootHandle );
        }
        
        //
        // if we are successful in removing the target, update the link
        // folder so that future referrals will no longer see the target
        // we just deleted.
        //

        if (Status == ERROR_SUCCESS)
        {
            DFSSTATUS UpdateStatus;
            UpdateStatus = UpdateLinkFolder( LinkMetadataName,
                                             pLinkName,
                                             pFolder );

        }

        pFolder->ReleaseReference();
    }
    ReleaseRootLock();
    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   EnumerateApiLinks
//
//  Arguments:  
//    LPWSTR DfsPathName :  the dfs root to enumerate.
//    DWORD Level        :  the enumeration level
//    LPBYTE pBuffer     :  buffer to hold results.
//    LONG BufferSize,   :  buffer size
//    LPDWORD pEntriesRead : number of entries to read.
//    LPDWORD pResumeHandle : the starting child to read.
//    PLONG pNextSizeRequired : return value to hold size required in case of overflow.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine enumerates the dfs metadata information.
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsRootFolder::EnumerateApiLinks(
    LPWSTR DfsPathName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG BufferSize,
    LPDWORD pEntriesRead,
    LPDWORD pResumeHandle,
    PLONG pNextSizeRequired )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    DFS_METADATA_HANDLE RootHandle = NULL;
    UNICODE_STRING VisibleNameContext;
    UNICODE_STRING DfsPath;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsPath,
                                        DfsPathName );
    if(Status == ERROR_SUCCESS)
    {
        //
        // Get the name context for this call.
        // do not use the user passed in name context within the path
        // for this call: if the user comes in with an ip address, we want
        // to return back the correct server/domain info to the caller
        // so the dfsapi results will not show the ip address etc.
        //
        GetVisibleNameContextLocked( NULL,
                                     &VisibleNameContext );
        //
        // Get the handle to the metadata for this root folder, and call
        // the store to enumerate the links.
        //
        Status = GetMetadataHandle( &RootHandle );

        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->EnumerateApiLinks( RootHandle,
                                                            &VisibleNameContext,
                                                            Level,
                                                            pBuffer,
                                                            BufferSize,
                                                            pEntriesRead,
                                                            pResumeHandle,
                                                            pNextSizeRequired);

            //
            // Release the metadata handle.
            //
            ReleaseMetadataHandle( RootHandle );
        }
    }


    ReleaseRootLock();
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetApiInformation
//
//  Arguments:  
//    PUNICODE DfsPathName :  the dfs root name
//    PUNICODE pLinkName : the link within the root.
//    DWORD Level        :  the info level.
//    LPBYTE pBuffer     :  buffer to hold results.
//    LONG BufferSize,   :  buffer size
//    PLONG pSizeRequired : return value to hold size required in case of overflow.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine gets the required information for a given root or link
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::GetApiInformation(
    PUNICODE_STRING pDfsName,
    PUNICODE_STRING pLinkName,
    DWORD Level,
    LPBYTE pBuffer,
    LONG BufferSize,
    PLONG pSizeRequired )
{
    UNREFERENCED_PARAMETER(pDfsName);

    DFSSTATUS Status;
    DFS_METADATA_HANDLE RootHandle;
    LPWSTR MetadataName;
    DfsFolder *pFolder;
    UNICODE_STRING VisibleNameContext;
    UNICODE_STRING Remaining;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //
    //
    // Do not base the context to use on the passed in dfsname:
    //  it is important to pass back our correct information 
    // in the api call.
    //
    //
    GetVisibleNameContextLocked( NULL,
                                 &VisibleNameContext );

    //
    // If  the link name is empty, we are dealing with the root.
    // so set the metadata name to null.
    //
    if (pLinkName->Length == 0)
    {
        MetadataName = NULL;
        Status = ERROR_SUCCESS;
    }
    //
    // otherwise, lookup the link folder and get the metadataname for that link.
    //
    else {
        Status = LookupFolderByLogicalName( pLinkName,
                                            &Remaining,
                                            &pFolder );
        //
        // if we did not find an EXACT match on the logical name, we are done.
        //
        if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
        {
            pFolder->ReleaseReference();
            Status = ERROR_NOT_FOUND;
        }

        //
        // we had an exact match, so lookup the metadata name and release the
        // the reference on the folder.
        //
        if (Status == ERROR_SUCCESS)
        {
            MetadataName = pFolder->GetFolderMetadataNameString();
            pFolder->ReleaseReference();
        }
    }

    //
    // we got the metadata name: now call into the store to get the
    // required information for the metadata name.
    //
    if (Status == ERROR_SUCCESS)
    {
        //
        // Get the handle to the metadata for this root folder.
        //  
        Status = GetMetadataHandle( &RootHandle );

        if (Status == ERROR_SUCCESS)
        {
            Status = GetMetadataStore()->GetStoreApiInformation( RootHandle,
                                                                 &VisibleNameContext,
                                                                 MetadataName,
                                                                 Level,
                                                                 pBuffer,
                                                                 BufferSize,
                                                                 pSizeRequired);

            ReleaseMetadataHandle( RootHandle );
        }
    }
    ReleaseRootLock();
    return Status;
}


DFSSTATUS
DfsRootFolder::ExtendedRootAttributes(
    PULONG pAttr,
    PUNICODE_STRING pRemainingName,
    BOOLEAN Set)
{
    DFSSTATUS Status;
    DFS_METADATA_HANDLE RootHandle;
    LPWSTR MetadataName = NULL;

    /*
     we get RESETs too (Set == TRUE). INSITE_ONLY flag
     is masked out in those. So there's no way to easily
     do this check. BUG 603118
    if (Set && 
        !IsEmptyUnicodeString(pRemainingName) &&
        (*pAttr != PKT_ENTRY_TYPE_INSITE_ONLY))
    {
        return ERROR_INVALID_PARAMETER;
    }
    */
    
    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    
    Status = GetMetadataHandle( &RootHandle );

    if (Status == ERROR_SUCCESS)
    {
        if (!IsEmptyUnicodeString(pRemainingName))
        {
            PUNICODE_STRING pLinkName = pRemainingName;
            UNICODE_STRING Remaining;
            DfsFolder *pFolder = NULL;

            Status = LookupFolderByLogicalName( pLinkName,
                                                &Remaining,
                                                &pFolder );
            //
            // if we did not find an EXACT match on the logical name, we are done.
            //
            if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
            {
                pFolder->ReleaseReference();
                Status = ERROR_NOT_FOUND;
            }

            if (Status == ERROR_SUCCESS)
            {
                MetadataName = pFolder->GetFolderMetadataNameString();

                //
                // if we got the metadataname, call the store with the
                // details so that it can associate the information
                // with this root or link.
                //
            }
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if (Set)
        {
            Status = GetMetadataStore()->SetExtendedAttributes( RootHandle,
                                                                MetadataName,
                                                                *pAttr);

        }
        else
        {
            Status = GetMetadataStore()->GetExtendedAttributes( RootHandle,
                                                                MetadataName,
                                                                pAttr);
        }
    }

    ReleaseRootLock();

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   SetApiInformation
//
//  Arguments:  
//    PUNICODE pLinkName : the name of link relative to root share
//    LPWSTR Server,        : the target server.
//    LPWSTR Share,         : the target path within the server.
//    DWORD Level        :  the info level.
//    LPBYTE pBuffer     :  buffer that has the information to be set.
//
//  Returns:   SUCCESS or error
//
//  Description: This routine sets the required information for a given root or link
//
//  Assumptions: the caller is responsible for mutual exclusion.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::SetApiInformation(
    PUNICODE_STRING pLinkName,
    LPWSTR Server,
    LPWSTR Share,
    DWORD Level,
    LPBYTE pBuffer )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFS_METADATA_HANDLE RootHandle = NULL;
    LPWSTR MetadataName = NULL;
    DfsFolder *pFolder = NULL;

    UNICODE_STRING Remaining;
    
    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    //

    // if the link name is empty we are dealing with 
    // the root itself.
    //  dfsdev: we need to set the root metadata appropriately!
    //
    if (pLinkName->Length == 0)
    {
        MetadataName = NULL;
    }
    //
    // else get to the link folder, and get
    // the link metadata name.
    //
    else {
        Status = LookupFolderByLogicalName( pLinkName,
                                            &Remaining,
                                            &pFolder );
        //
        // if we did not find an EXACT match on the logical name, we are done.
        //
        if ( (Status == ERROR_SUCCESS) && (Remaining.Length != 0) )
        {
            pFolder->ReleaseReference();
            Status = ERROR_NOT_FOUND;
        }

        if (Status == ERROR_SUCCESS)
        {
            MetadataName = pFolder->GetFolderMetadataNameString();

            //
            // if we got the metadataname, call the store with the
            // details so that it can associate the information
            // with this root or link.
            //
        }
    }

    if (Status == ERROR_SUCCESS) 
    {
        if ((Level == 101) && (MetadataName == NULL))
        {
            Status = ERROR_NOT_SUPPORTED;
        }
        else
        {
            //
            // Get the handle to the root of this metadata
            //
            Status = GetMetadataHandle( &RootHandle );

            if (Status == ERROR_SUCCESS)
            {
                Status = GetMetadataStore()->SetStoreApiInformation( RootHandle,
                                                                     MetadataName,
                                                                     Server,
                                                                     Share,
                                                                     Level,
                                                                     pBuffer );

                if (Status != ERROR_SUCCESS)
                {

                    DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::SetApiInformation path %wZ, %ws, %ws: Status %x\n",
                                         pLinkName, Server, Share, Status );
                    ReSynchronize(TRUE);
                }
                else
                {

                    Status = UpdateFolderInformation(RootHandle, 
                                                     MetadataName, 
                                                     pFolder);
                }
                ReleaseMetadataHandle( RootHandle );

            }
  
            //
            // If we successfully updated the metadata, update the
            // link folder so that the next referral request will pick up the 
            // changes
            //
            if ((Status == ERROR_SUCCESS) &&
                (MetadataName != NULL))
            {
                DFSSTATUS UpdateStatus;

                UpdateStatus = UpdateLinkFolder( MetadataName,
                                                 pLinkName,
                                                 pFolder );
                //
                // dfsdev: log the update state.
                //
            }
        }

        if (pFolder != NULL) {
            pFolder->ReleaseReference();
        }
    }
    ReleaseRootLock();
    return Status;
}






//+-------------------------------------------------------------------------
//
//  Function:  LoadReferralData -  Loads the referral data.
//
//  Arguments:    pReferralData -  the referral data to load
//
//  Returns:    Status: Success or error code
//
//  Description: This routine sets up the ReferralData instance to have
//               all the information necessary to create a referral.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::LoadReferralData(
    DfsFolderReferralData *pReferralData )
{
    DFS_METADATA_HANDLE RootMetadataHandle;
    DFSSTATUS Status;
    DfsFolder *pFolder;
    //
    // Get the Root key for this root folder.
    //

    DFS_TRACE_LOW( REFERRAL_SERVER, "LoadReferralData called, %p\n", pReferralData);
    
    Status = GetMetadataHandle( &RootMetadataHandle );

    if ( Status == ERROR_SUCCESS )
    {
        //
        // Now get the owning folder of the referralDAta. Note that
        // this does not give us a new reference on the Folder.
        // however, the folder is guaranteed to be around till
        // we return from this call, since the pReferralData that
        // was passed in to us cannot go away.
        //
        pFolder = pReferralData->GetOwningFolder();    

        DFS_TRACE_LOW( REFERRAL_SERVER, "Load referral data, Got Owning Folder %p\n", pFolder );

        //
        // Now load the replica referral data for the passed in folder.
        //
        Status = LoadReplicaReferralData( RootMetadataHandle,
                                          pFolder->GetFolderMetadataNameString(),
                                          pReferralData );
        DFS_TRACE_LOW( REFERRAL_SERVER, "LoadReferralData for %p replica data loaded %x\n",
                       pReferralData, Status );


        if ( Status == ERROR_SUCCESS )
        {
            //
            // Load the policy referrral data for the passedin folder.
            //
            Status = LoadPolicyReferralData( RootMetadataHandle );

        }
        ReleaseMetadataHandle( RootMetadataHandle );
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "[%!FUNC!]Done load referral data %p, Status %x\n", 
                        pReferralData, Status);
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnloadReferralData - Unload the referral data.
//
//  Arguments:  pReferralData - the ReferralData instance to unload.
//
//  Returns:    Status: Success or Error status code.
//
//  Description: This routine Unloads the referral data. It undoes what
//              the corresponding load routine did.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::UnloadReferralData(
    DfsFolderReferralData *pReferralData )

{
    DFSSTATUS Status;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Unload referral data %p\n", pReferralData);
    Status = UnloadReplicaReferralData( pReferralData );
    if ( Status == ERROR_SUCCESS )
    {
        Status = UnloadPolicyReferralData( pReferralData );
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Unload referral data %p, Status %x\n", pReferralData, Status);
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   LoadReplicaReferralData - load the replica information.
//
//  Arguments:  RegKey -  the registry key of the root folder,
//              RegistryName - Name of the registry key relative to to Root Key
//              pReferralData - the referral data to load.
//
//  Returns:   Status - Success or error status code.
//
//  Description: This routine loads the replica referral data for the
//               the passed in ReferralData instance.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::LoadReplicaReferralData(
    DFS_METADATA_HANDLE RootMetadataHandle,
    LPWSTR MetadataName,
    DfsFolderReferralData *pReferralData)
{
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo = NULL;
    PDFS_REPLICA_INFORMATION pReplicaInfo = NULL;
    PUNICODE_STRING pServerName = NULL;
    DfsReplica *pReplica = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Replica = 0;
    ULONG NumReplicas = 0;
    BOOLEAN CacheHit = FALSE;

    DFS_TRACE_LOW( REFERRAL_SERVER, "Load Replica Referral Data %ws, for %p\n", MetadataName, pReferralData);
    pReferralData->pReplicas = NULL;
    
    //
    // Get the replica information.
    //
    if(!pReferralData->FolderOffLine)
    {
        Status = GetMetadataStore()->GetMetadataReplicaInformation(RootMetadataHandle,
                                                                   MetadataName,
                                                                   &pReplicaListInfo );
        if(Status == ERROR_SUCCESS)
        {
            NumReplicas = pReplicaListInfo->ReplicaCount;
        }
    }

    if ( Status == ERROR_SUCCESS )
    {

        //
        // Set the appropriate count, and allocate the replicas
        // required.
        //
        pReferralData->ReplicaCount = NumReplicas;
        if (pReferralData->ReplicaCount > 0)
        {
            pReferralData->pReplicas = new DfsReplica [ NumReplicas ];
            if ( pReferralData->pReplicas == NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    //
    // Now, for each replica, set the replicas server name, the target
    // folder and the replica state.
    //
    if ( Status == ERROR_SUCCESS )
    {
        for ( Replica = 0; 
             (Replica < NumReplicas) && (Status == ERROR_SUCCESS);
             Replica++ )
        {
            UNICODE_STRING UseName;

            RtlInitUnicodeString(&UseName, NULL);

            pReplicaInfo = &pReplicaListInfo->pReplicas[Replica];
            pReplica = &pReferralData->pReplicas[ Replica ];

            pServerName = &pReplicaInfo->ServerName;

            //
            // If the servername is a ., this is a special case where
            // the servername is the root itself. In this case,
            // set the server name to the name of this machine.
            //
            if (IsLocalName(pServerName))
            {
                Status = GetVisibleNameContext( NULL,
                                                &UseName);
                if (Status == ERROR_SUCCESS)
                {
                    *pServerName = UseName;
                }
            }

            if ( Status == ERROR_SUCCESS )
            {
                Status = pReplica->SetTargetServer( pServerName, &CacheHit );
            }
            if ( Status == ERROR_SUCCESS )
            {
                pStatistics->UpdateServerSiteStat(CacheHit);
                Status = pReplica->SetTargetFolder( &pReplicaInfo->ShareName );
            }
            if ( Status == ERROR_SUCCESS )
            {
                if ( pReplicaInfo->ReplicaState & REPLICA_STORAGE_STATE_OFFLINE )
                {
                    pReplica->SetTargetOffline();
                }
            }

            if (UseName.Length != 0)
            {
                DfsFreeUnicodeString(&UseName);
                RtlInitUnicodeString(&UseName, NULL);
            }
        }

    }


    //
    // Now release the replica information that was allocated
    // by the store.
    //
    if(pReplicaListInfo)
    {

        GetMetadataStore()->ReleaseMetadataReplicaInformation( RootMetadataHandle,
                                                               pReplicaListInfo );
    }

    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Done with Load Replica Referral Data %ws, for %p, Status %x\n", 
                         MetadataName, pReferralData, Status);
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   UnloadReplicaReferralData - Unload the replicas 
//
//  Arguments:    pReferralData - the DfsFolderReferralData to unload
//
//  Returns:    Status: Success always.
//
//  Description: This routine gets rid of the allocate replicas in the
//               folder's referral data.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRootFolder::UnloadReplicaReferralData(
    DfsFolderReferralData *pReferralData )
{
    if (pReferralData->pReplicas != NULL) {
        delete [] pReferralData->pReplicas;
        pReferralData->pReplicas = NULL;
    }

    return ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetRootStandby - set the root in a standby mode.
//
//  Arguments:  none
//
//  Returns:    Status: Success always for now.
//
//  Description: This routine checks if we are already in standby mode.
//               If not, it releases the root share directory, removes
//               all the link folders and set the root in a standby mode
//               DFSDEV: need to take into consideration synchronization
//               with other threads.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsRootFolder::SetRootStandby()
{
    DFSSTATUS Status = ERROR_SUCCESS;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }
    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Root %p being set to standby\n", this);
    if (IsRootFolderStandby() == FALSE)
    {
        //
        // dfsdev:: ignore error returns from these calls?
        //
        DFSSTATUS ReleaseStatus;

        RemoveAllLinkFolders( TRUE ); // permanent removal

        ReleaseStatus = ReleaseRootShareDirectory();
        DFS_TRACE_ERROR_LOW( ReleaseStatus, REFERRAL_SERVER, "[%!FUNC!]Release root share status %x\n", ReleaseStatus);

        SetRootFolderStandby();
    }
    else
    {
        DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Root %p was already standby\n", this);
    }

    ReleaseRootLock();
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetRootResynchronize - set the root in a ready mode.
//
//  Arguments:  none
//
//  Returns:    Status: Success always for now.
//
//  Description: This routine checks if we are already in ready mode.
//               If not, it acquires the root share directory, calls
//               synchronize to add all the links back
//               DFSDEV: need to take into consideration synchronization
//               with other threads.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::SetRootResynchronize()
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS RootStatus;

    Status = AcquireRootLock();
    if (Status != ERROR_SUCCESS)
    {
        return Status;
    }

    DFS_TRACE_LOW( REFERRAL_SERVER, "[%!FUNC!]Root %p being resynced\n", this);
    //
    // if the root folder is already marked available, we are done
    // otherwise, clear the standby mode, and try to bring this
    // root into a useable state.
    //
    if (!IsRootFolderAvailable())
    {
        ClearRootFolderStandby();

        //
        // need to take appropriate locks.
        //
        RootStatus = Synchronize();
        DFS_TRACE_ERROR_LOW( RootStatus, REFERRAL_SERVER, "[%!FUNC!]Set root resync: Synchronize status for %p is %x\n", 
                             this, RootStatus);
    }
    else
    {
        //
        // Synchronize without the FORCE flag here, because we don't want to
        // get the entire blob unless the GUID has changed. This will still result in
        // a minimum of one network call to get the GUID.
        //
        RootStatus = ReSynchronize();
        DFS_TRACE_ERROR_LOW( RootStatus, REFERRAL_SERVER, "[%!FUNC!]Set root resync: Synchronize status for %p is %x\n", 
                             this, RootStatus);
    }

    ReleaseRootLock();
    return Status;
}



DFSSTATUS
DfsRootFolder::UpdateFolderInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName,
    DfsFolder *pChildFolder)
{

    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Timeout = 0;
    PDFS_NAME_INFORMATION pChild = NULL;
    ULONG ChildType = 0;
    ULONG ChildState = 0;
    FILETIME LastModifiedTime;


    Status = GetMetadataStore()->GetMetadataNameInformation( DfsHandle,
                                                             ChildName,
                                                             &pChild);
    if(Status == ERROR_SUCCESS)
    {

        ChildType = pChild->Type;
        ChildState = pChild->State;

        Timeout = pChild->Timeout;

        LastModifiedTime = pChild->LastModifiedTime;


        if( pChildFolder != NULL)
        {
           if (ChildType & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) 
           {
              pChildFolder->SetFlag( DFS_FOLDER_OUT_OF_DOMAIN );
           }
           else
           {
               pChildFolder->ResetFlag( DFS_FOLDER_OUT_OF_DOMAIN );
           }


           if((ChildState & DFS_VOLUME_STATE_OFFLINE) ==  DFS_VOLUME_STATE_OFFLINE)
           {
               pChildFolder->SetFlag( DFS_FOLDER_OFFLINE );
           }
           else
           {
               pChildFolder->ResetFlag( DFS_FOLDER_OFFLINE );
           }


           pChildFolder->SetTimeout(Timeout);
           pChildFolder->SetUSN( FILETIMETO64(LastModifiedTime) );

        }
        else
        {

            SetTimeout(Timeout);
            SetUSN( FILETIMETO64(LastModifiedTime) );
        }

        GetMetadataStore()->ReleaseMetadataNameInformation( DfsHandle, pChild );
    }


    //
    // Now that we have the child name, get the name information
    // for this child. This is the logical namespace information
    // for this child.
    //

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateLinkInformation
//
//  Arguments:    
//    DfsMetadataHandle - the parent handle
//    LPWSTR ChildName - the child name
//
//  Returns:    Status: Success or Error status code
//
//  Description: This routine reads the metadata for the child and, updates
//               the child folder if necessary. This includes adding
//               the folder if it does not exist, or if the folder exists
//               but the metadata is newer, ensuring that all future
//               request use the most upto date data.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRootFolder::UpdateLinkInformation(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName,
    BOOLEAN CalledByApi )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Timeout = 0;
    PDFS_NAME_INFORMATION pChild = NULL;
    DfsFolder *pChildFolder = NULL;
    FILETIME LastModifiedTime;

    ULONG ChildType = 0;
    ULONG ChildState = 0;

    UNICODE_STRING LinkName;

    //
    // Now that we have the child name, get the name information
    // for this child. This is the logical namespace information
    // for this child.
    //
    Status = GetMetadataStore()->GetMetadataNameInformation( DfsHandle,
                                                             ChildName,
                                                             &pChild);


    if ( Status == ERROR_SUCCESS )
    {

        ChildType = pChild->Type;
        ChildState = pChild->State;

        Timeout = pChild->Timeout;

        if ((ChildType & (PKT_ENTRY_TYPE_REFERRAL_SVC | PKT_ENTRY_TYPE_DFS)) ==
            (PKT_ENTRY_TYPE_REFERRAL_SVC | PKT_ENTRY_TYPE_DFS))
        {
            SetTimeout(Timeout);

            if (ChildType & PKT_ENTRY_TYPE_INSITE_ONLY) 
            {
                SetFlag( DFS_FOLDER_INSITE_REFERRALS );
            }
            else
            {
                ResetFlag( DFS_FOLDER_INSITE_REFERRALS );
            }

            // If site-costing is turned on for this root, mark it so.
            if (ChildType & PKT_ENTRY_TYPE_COST_BASED_SITE_SELECTION) 
            {
                SetFlag( DFS_FOLDER_COST_BASED_SITE_SELECTION );
            }
            else
            {
                ResetFlag( DFS_FOLDER_COST_BASED_SITE_SELECTION );
            }

            if (ChildType & PKT_ENTRY_TYPE_ROOT_SCALABILITY)
            {
                SetRootScalabilityMode();
            }
            else
            {
                ResetRootScalabilityMode();
            }

            GetMetadataStore()->ReleaseMetadataNameInformation( DfsHandle, pChild );
            return Status;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        LastModifiedTime = pChild->LastModifiedTime;

        //
        // Now translate the metadata logical name to a relative
        // link name: each store has its own behavior, so
        // the getlinkname function is implemented by each store.
        //
        Status = GetMetadataLogicalToLinkName(&pChild->Prefix, 
                                              &LinkName);
        if ( Status == ERROR_SUCCESS )
        {
            Status = LookupFolderByMetadataName( ChildName,
                                                 &pChildFolder );

            if ( Status == ERROR_SUCCESS )
            {

                //
                // IF we already know this child, check if the child
                // has been updated since we last visited it.
                // If so, we need to update the child.
                //
                if ( pChildFolder->UpdateRequired( FILETIMETO64(LastModifiedTime) ) )
                {
                    Status = UpdateLinkFolder( ChildName,
                                               &LinkName,
                                               pChildFolder );
                }

                //
                // we now check if we need to create root directories for even
                // those folders that we already know about. This may be true
                // when we had one or more errors creating the
                // directory when we initially created this folder or it may
                // be true when we are going from standby to master.
                //

                if (IsRootDirectoriesCreated() == FALSE)
                {
                    DFSSTATUS CreateStatus;

                    CreateStatus = SetupLinkReparsePoint(pChildFolder->GetFolderLogicalNameString());
                }
            } 
            else if ( Status == ERROR_NOT_FOUND )
            {
                //
                // We have not seen this child before: create 
                // a new one.
                //
                Status = CreateLinkFolder( ChildName,
                                           &LinkName,
                                           &pChildFolder,
                                           CalledByApi );

                if(CalledByApi)
                {
                    if(Status != ERROR_SUCCESS)
                    {
                      DFSSTATUS RemoveStatus = ERROR_SUCCESS;


                      DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::UpdateLinkInformation (1) %ws: Status %x\n",
                                           ChildName, Status );

                      RemoveStatus = RemoveMetadataLink(&LinkName);
                      if(RemoveStatus != ERROR_SUCCESS)
                      {

                        DFS_TRACE_ERROR_HIGH(Status, API, "DfsRootFolder::UpdateLinkInformation (2)%ws: Status %x\n",
                                               ChildName, Status );
                        ReSynchronize(TRUE);
                      }
                    }
                }
            }

            ReleaseMetadataLogicalToLinkName( &LinkName );
        }
        //
        // Now release the name information of the child.
        //
        GetMetadataStore()->ReleaseMetadataNameInformation( DfsHandle, pChild );
    }

    //
    // We were successful. We have a child folder that is
    // returned to us with a valid reference. Set the Last
    // modified time in the folder, and release our reference
    // on the child folder.
    //
    if ( Status == ERROR_SUCCESS )
    {
        if (ChildType & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) 
        {
            pChildFolder->SetFlag( DFS_FOLDER_OUT_OF_DOMAIN );
        }
        else
        {
            pChildFolder->ResetFlag( DFS_FOLDER_OUT_OF_DOMAIN );
        }

        if (ChildType & PKT_ENTRY_TYPE_INSITE_ONLY) 
        {
            pChildFolder->SetFlag( DFS_FOLDER_INSITE_REFERRALS );
        }
        else
        {
            pChildFolder->ResetFlag( DFS_FOLDER_INSITE_REFERRALS );
        }

        if((ChildState & DFS_VOLUME_STATE_OFFLINE) ==  DFS_VOLUME_STATE_OFFLINE)
        {
            pChildFolder->SetFlag( DFS_FOLDER_OFFLINE );
        }
        else
        {
            pChildFolder->ResetFlag( DFS_FOLDER_OFFLINE );
        }

        pChildFolder->SetTimeout(Timeout);
        pChildFolder->SetUSN( FILETIMETO64(LastModifiedTime) );
        pChildFolder->ReleaseReference();
    }

    return Status;
}



void
DfsRootFolder::GenerateEventLog(DWORD EventMsg, 
                                WORD Substrings,
                                const TCHAR * apszSubStrings[],
                                DWORD Errorcode)
{
    LONG RetVal = FEWERRORS_ON_ROOT;

    if(InterlockedIncrement(&_CurrentErrors) < DFS_MAX_ROOT_ERRORS)
    {
        DfsLogDfsEvent(EventMsg, 
                       Substrings, 
                       apszSubStrings, 
                       Errorcode); 
    }
    else
    {
        const TCHAR * apszErrSubStrings[1];

        RetVal = InterlockedCompareExchange(&_TooManyEventLogErrors,
                                            TOOMANY_ERRORS_ON_ROOT,
                                            FEWERRORS_ON_ROOT);

        if(RetVal == FEWERRORS_ON_ROOT)
        {
            apszErrSubStrings[0] = GetLogicalShare()->Buffer;
            DfsLogDfsEvent(DFS_ERROR_TOO_MANY_ERRORS,            
                           1, 
                           apszErrSubStrings, 
                           0); 

        }

    }
}

NTSTATUS
DfsRootFolder::IsDirectoryMountPoint(
    IN  HANDLE DirHandle,
    OUT PBOOLEAN pDfsMountPoint )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    FILE_BASIC_INFORMATION BasicInfo;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    //we assume these are not reparse points.
    //
    *pDfsMountPoint = FALSE;

    //
    // Query for the basic information, which has the attributes.
    //
    NtStatus = NtQueryInformationFile( DirHandle,
                                     &IoStatusBlock,
                                     (PVOID)&BasicInfo,
                                     sizeof(BasicInfo),
                                     FileBasicInformation );

    if (NtStatus == STATUS_SUCCESS)
    {
        //
        // If the attributes indicate reparse point, we have a reparse
        // point directory on our hands.
        //
        if ( BasicInfo.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) 
        {
            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
            
            NtStatus = NtQueryInformationFile( DirHandle,
                                               &IoStatusBlock,
                                               (PVOID)&FileTagInformation,
                                               sizeof(FileTagInformation),
                                               FileAttributeTagInformation );

            if (NtStatus == STATUS_SUCCESS)
            {
                //
                // Checkif the tag indicates its a mount point,
                // and setup the return accordingly.
                //
                if (FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
                {
                    *pDfsMountPoint = TRUE;
                }
            }
        }
    }

    return NtStatus;
}


DFSSTATUS
DfsRootFolder::PrefetchReplicaData(DfsFolder *pChildFolder)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DFS_METADATA_HANDLE RootMetadataHandle;

    Status = GetMetadataHandle( &RootMetadataHandle );
    if(Status == ERROR_SUCCESS)
     {
         Status = LoadCachedServerSiteData(RootMetadataHandle,
                                           pChildFolder->GetFolderMetadataNameString());

         ReleaseMetadataHandle( RootMetadataHandle );
     }

    return Status;
}

DFSSTATUS
DfsRootFolder::LoadServerSiteData(DfsFolder *pChildFolder)
{
    DFSSTATUS Status = ERROR_SUCCESS;

    if(DfsServerGlobalData.IsStartupProcessingDone)
    {
       if(_PrefetchNeeded == FALSE)
       {
           _PrefetchNeeded = TRUE;
       }
    }

    if(!_PrefetchNeeded)
    {
        return Status;
    }

    Status = PrefetchReplicaData(pChildFolder);

    return Status;
}

DFSSTATUS
DfsRootFolder::LoadCachedServerSiteData(
    DFS_METADATA_HANDLE RootMetadataHandle,
    LPWSTR MetadataName)
{
    PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo = NULL;
    PDFS_REPLICA_INFORMATION pReplicaInfo = NULL;
    PUNICODE_STRING pServerName = NULL;
    DfsReplica *pReplica = NULL;
    DfsReplica *pReplicaList = NULL;
    DfsServerSiteInfo *pInfo = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG Replica = 0;
    ULONG NumLocalReplicas = 0;
    BOOLEAN CacheHit = FALSE;

    DFS_TRACE_LOW( SITE, "LoadCachedServerSiteData %ws\n", MetadataName);

    //
    // Get the replica information.
    //
    Status = GetMetadataStore()->GetMetadataReplicaInformation(RootMetadataHandle,
                                                               MetadataName,
                                                               &pReplicaListInfo );

    if ( Status == ERROR_SUCCESS )
    {

        //
        // Set the appropriate count, and allocate the replicas
        // required.
        //
        NumLocalReplicas = pReplicaListInfo->ReplicaCount;
        if (NumLocalReplicas > 0)
        {
            pReplicaList = new DfsReplica [ pReplicaListInfo->ReplicaCount ];
            if ( pReplicaList == NULL )
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    //
    // Now, for each replica, set the replicas server name, the target
    // folder and the replica state.
    //
    if ( Status == ERROR_SUCCESS )
    {
        for ( Replica = 0; 
             (Replica < pReplicaListInfo->ReplicaCount) && (Status == ERROR_SUCCESS);
             Replica++ )
        {

            UNICODE_STRING UseName;

            RtlInitUnicodeString(&UseName, NULL);

            pReplicaInfo = &pReplicaListInfo->pReplicas[Replica];
            pReplica = &pReplicaList[ Replica ];

            pServerName = &pReplicaInfo->ServerName;

            //
            // If the servername is a ., this is a special case where
            // the servername is the root itself. In this case,
            // set the server name to the name of this machine.
            //
            if (IsLocalName(pServerName))
            {
                Status = GetVisibleNameContext( NULL,
                                                &UseName);
                if (Status == ERROR_SUCCESS)
                 {
                     *pServerName = UseName;
                 }
            }

            if ( Status == ERROR_SUCCESS )
            {
                Status = DfsGetServerInfo (pServerName, &pInfo, &CacheHit, TRUE);
            }
            if(Status == ERROR_SUCCESS)
            {

                DFS_TRACE_LOW( SITE, "LoadCachedServerSiteData: Server %wZ <->Site %ws\n", 
                               pServerName, pInfo->GetSiteNameString());
                pInfo->ReleaseReference();
            }

            if (UseName.Length != 0)
             {
                 DfsFreeUnicodeString(&UseName);
                 RtlInitUnicodeString(&UseName, NULL);
             }
        }

    }


   
    //
    // Now release the replica information that was allocated
    // by the store.
    //
    if(pReplicaListInfo != NULL)
    {
        GetMetadataStore()->ReleaseMetadataReplicaInformation( RootMetadataHandle,
                                                               pReplicaListInfo );
    }

    if(pReplicaList)
    {
        delete []pReplicaList;
    }
     
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Done with LoadCachedServerSiteData %ws, Status %x\n", 
                         MetadataName, Status);
    return Status;
}

//this callback should not hold any child folder locks
void PrefetchCallBack(LPVOID pEntry, LPVOID pContext)
{
    DfsFolder *pFolder = (DfsFolder *) pEntry;
    DfsRootFolder * pRootFolder = (DfsRootFolder *) pContext;

    if (!DfsIsShuttingDown())    
    {
        if(pFolder != NULL)
        {
            pRootFolder->PrefetchReplicaData(pFolder);
        }
    }
}

DFSSTATUS
DfsRootFolder::PreloadServerSiteData(void)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = DfsPrefixTableAcquireWriteLock( _pLogicalPrefixTable );
    if (NtStatus == STATUS_SUCCESS)
    {
        DfsEnumeratePrefixTableLocked(_pLogicalPrefixTable, PrefetchCallBack, this);

        DfsPrefixTableReleaseLock( _pLogicalPrefixTable );
    }

    _PrefetchNeeded = TRUE;

    return NtStatus;
}

DFSSTATUS
DfsRootFolder::ValidateAPiShortName(PUNICODE_STRING pLinkName)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    HANDLE DirectoryHandle = NULL;
    DWORD NumComponentsExpanded = 0;
    UNICODE_STRING NewLinkName;

    NewLinkName.Buffer = NULL;
    NewLinkName.Length = NewLinkName.MaximumLength = 0;

    if(IsAShortName(pLinkName))
    {
        NtStatus = DfsOpenDirectory ( GetDirectoryCreatePathName(),
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    &DirectoryHandle,
                    NULL );

        if(NtStatus == STATUS_SUCCESS)
        {
            NtStatus = ExpandLinkDirectories(pLinkName, 
                                             &NewLinkName, 
                                             DirectoryHandle,
                                             TRUE,
                                             &NumComponentsExpanded);  

           if(NtStatus == STATUS_NAME_TOO_LONG)
            {
               Status = ERROR_BAD_PATHNAME;
            }
           else
            {
               Status = ERROR_SUCCESS;
            }


            CloseHandle (DirectoryHandle);
        }

        if(NewLinkName.Buffer)
        {
            delete [] NewLinkName.Buffer;
        }

    }

    return Status;
}

DFSSTATUS
DfsRootFolder::ExpandShortName(PUNICODE_STRING pLinkName,
                               PUNICODE_STRING pNewPath,
                               PUNICODE_STRING pRemainingName)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_NOT_FOUND;
    HANDLE DirectoryHandle = NULL;
    DWORD NumComponentsExpanded = 0;

    pNewPath->Length = 0;
    pNewPath->MaximumLength = 0;
    pNewPath->Buffer = NULL;

    if(IsAShortName(pLinkName))
    {
        NtStatus = DfsOpenDirectory ( GetDirectoryCreatePathName(),
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    NULL,
                    &DirectoryHandle,
                    NULL );

        if(NtStatus == STATUS_SUCCESS)
        {
            NtStatus = ExpandLinkDirectories(pLinkName, 
                                             pNewPath, 
                                             DirectoryHandle,
                                             FALSE,
                                             &NumComponentsExpanded);  

            if((NtStatus == STATUS_DIRECTORY_IS_A_REPARSE_POINT) ||
               (NtStatus == STATUS_NO_SUCH_FILE))
            {
                NtStatus = STATUS_SUCCESS;
            }

            CloseHandle (DirectoryHandle);
        }

        Status = RtlNtStatusToDosError(NtStatus);

        if((Status == ERROR_SUCCESS) && NumComponentsExpanded && pRemainingName)
        {
            NtStatus = FindRemaingName(pLinkName,
                                       pRemainingName,
                                       NumComponentsExpanded);


            Status = RtlNtStatusToDosError(NtStatus);
        }
    }

    return Status;
}


NTSTATUS
DfsRootFolder::FindRemaingName(PUNICODE_STRING pLinkName,
                               PUNICODE_STRING pRemainingName,
                               DWORD NumComponentsExpanded)
{
    DWORD LoopVar = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING RemainingName;
    UNICODE_STRING RemPath;
    UNICODE_STRING TempString;

    RemainingName = *pLinkName;

    for (LoopVar = 0; LoopVar < NumComponentsExpanded; LoopVar++) 
    {

        NtStatus = DfsGetNextComponent(&RemainingName, 
                                       &RemPath, 
                                       &TempString);

        RemainingName = TempString;
    }

    *pRemainingName = RemainingName;

    return NtStatus;
}

NTSTATUS
DfsRootFolder::ExpandLinkDirectories( 
    PUNICODE_STRING   pLinkName,
    PUNICODE_STRING   pNewPath,
    HANDLE            RelativeHandle,
    BOOLEAN              FailOnExpand,
    DWORD *           NumComponentsExpanded)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS  Status = ERROR_SUCCESS;
    HANDLE CurrentDirectory = INVALID_HANDLE_VALUE;
    HANDLE LocalRelativeHandle = INVALID_HANDLE_VALUE;
    ULONG  ShareMode = 0;
    DWORD NumExpanded = 0;
    BOOLEAN Expanded = FALSE;
    BOOLEAN  NewlyCreated = FALSE;
    UNICODE_STRING RemainingName;
    UNICODE_STRING TempString;
    UNICODE_STRING DirectoryToCreate;

    *NumComponentsExpanded = 0;

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    LocalRelativeHandle = RelativeHandle;

    RemainingName = *pLinkName;
    while ( NtStatus == STATUS_SUCCESS)
    {
        NtStatus = DfsGetNextComponent(&RemainingName, 
                                       &DirectoryToCreate, 
                                       &TempString);
        RemainingName = TempString;

        Expanded = FALSE;
        NtStatus = GetAShortName(LocalRelativeHandle,
                                 &Expanded,
                                 &DirectoryToCreate,
                                 pNewPath);
        

        if (NtStatus != STATUS_SUCCESS)
        {
            break;
        }

        NumExpanded++;

        if( FailOnExpand && Expanded)
        {

            NtStatus = STATUS_NAME_TOO_LONG;
            break;
        }

        NtStatus = DfsOpenDirectory( &DirectoryToCreate,
                                  ShareMode,
                                  LocalRelativeHandle,
                                  &CurrentDirectory,
                                  &NewlyCreated );
        if (NtStatus == STATUS_SUCCESS)
        {

            if(LocalRelativeHandle != RelativeHandle)
            {
                DfsCloseDirectory( LocalRelativeHandle );
            }

            LocalRelativeHandle = CurrentDirectory;
            CurrentDirectory = INVALID_HANDLE_VALUE;


            if(RemainingName.Length == 0)
            {
                break;
            }
        }
    } 

    *NumComponentsExpanded = NumExpanded;

    if(LocalRelativeHandle != RelativeHandle)
    {
        if(LocalRelativeHandle != INVALID_HANDLE_VALUE)
        {
            DfsCloseDirectory( LocalRelativeHandle );
            LocalRelativeHandle = INVALID_HANDLE_VALUE;
        }
    }


    DFS_TRACE_ERROR_LOW(NtStatus, REFERRAL_SERVER, "ExpandLinkDirectory: %wZ: Status %x\n",
                        pLinkName, NtStatus );
    return NtStatus;
}


BOOLEAN
DfsRootFolder::IsAShortName(PUNICODE_STRING pLinkName)
{
    ULONG idx = 0;
    ULONG nameLen = 0;
    BOOLEAN RetVal = FALSE;

    if(pLinkName->Length == 0)
    {
        return FALSE;
    }

    nameLen = pLinkName->Length / sizeof(WCHAR);

    for (idx = 0; idx < nameLen; idx++)
    {
       if (pLinkName->Buffer[idx] == L'~')
       {
            RetVal = TRUE;
            break;
       }
    }

    return RetVal;
}

NTSTATUS
DfsRootFolder::GetAShortName(HANDLE ParentHandle,
                             BOOLEAN  *Expanded,
                             PUNICODE_STRING pLinkName,
                             PUNICODE_STRING pNewPath)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PFILE_NAMES_INFORMATION pFileEntry = NULL;
    ULONG  NameInformationSize = 0;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING LongName;
    UNICODE_STRING PathSep;

    *Expanded = FALSE;

    PathSep.Length = sizeof(UNICODE_PATH_SEP);
    PathSep.MaximumLength = sizeof(UNICODE_PATH_SEP);
    PathSep.Buffer = L"\\"; 


    NameInformationSize = sizeof(FILE_NAMES_INFORMATION) + DFS_SHORTNAME_EXPANSION_SIZE;
    pFileEntry = (PFILE_NAMES_INFORMATION) new BYTE [NameInformationSize];
    if (pFileEntry != NULL)
    {
        NtStatus = NtQueryDirectoryFile( ParentHandle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &ioStatusBlock,
                                       pFileEntry,
                                       NameInformationSize,
                                       FileNamesInformation,
                                       TRUE,            // ReturnSingleEntry
                                       pLinkName,
                                       TRUE );          // RestartScan

        if(NtStatus == STATUS_SUCCESS)
        {
            LongName.Buffer = pFileEntry->FileName;
            LongName.Length = LongName.MaximumLength = (USHORT) pFileEntry->FileNameLength;

            DFS_TRACE_ERROR_LOW(NtStatus, REFERRAL_SERVER, "GetShortName: %wZ expanded to %wZ: Status %x\n",
                                pLinkName, &LongName, NtStatus );

            if (RtlCompareUnicodeString(&LongName, pLinkName, TRUE) != 0)
            {
                *Expanded = TRUE;
                NtStatus = CopyShortName(&LongName, 
                                         pNewPath);

            }
            else
            {

                *Expanded = FALSE;
                NtStatus = CopyShortName(pLinkName, 
                                         pNewPath);

            }

            //
            // A previous CopyShortName may have failed because 
            // we were out of resources.
            //
            if (NtStatus == STATUS_SUCCESS)
            {
                NtStatus = CopyShortName(&PathSep, 
                                        pNewPath);
            }
        }


        delete [] pFileEntry;
        pFileEntry = NULL;
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DFS_TRACE_ERROR_LOW(NtStatus, REFERRAL_SERVER, "GetShortName: Status %x\n",
                        NtStatus );
    return NtStatus;
}


NTSTATUS
DfsRootFolder::CopyShortName(PUNICODE_STRING pNewName, 
                             PUNICODE_STRING pNewPath)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NewMaxLength = 0;
    PWSTR pNewBuffer = NULL;

    do {
        NtStatus = RtlAppendUnicodeStringToString(pNewPath, pNewName);

        //
        // If the append succeeded then we are done.
        //
        if (NtStatus != STATUS_BUFFER_TOO_SMALL)
        {
            break;
        }
        
        NewMaxLength = pNewPath->MaximumLength +
                        pNewName->Length +
                        (DFS_SHORTNAME_EXPANSION_SIZE * sizeof(WCHAR));

        // unicode strings can't go beyond a ushort
        if (NewMaxLength > MAXUSHORT)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
        
        pNewBuffer = (PWSTR) new BYTE [NewMaxLength];
        if (pNewBuffer == NULL)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        if (pNewPath->Buffer)
        {
          RtlMoveMemory( pNewBuffer, pNewPath->Buffer, pNewPath->Length );
          delete [] pNewPath->Buffer;
          pNewPath->Buffer = NULL;
        }

        pNewPath->Buffer = pNewBuffer;
        pNewPath->MaximumLength = (USHORT) NewMaxLength;

        NtStatus = RtlAppendUnicodeStringToString(pNewPath, pNewName);

    } while (FALSE);
        

    return NtStatus;
}

void 
DfsRootFolder::FreeShortNameData(PUNICODE_STRING pLinkName)
{
    if(pLinkName->Buffer != NULL)
    {
        delete []  pLinkName->Buffer;
        pLinkName->Buffer = NULL;
    }
}



DFSSTATUS 
DfsRootFolder::CreateRenameName(PUNICODE_STRING pNewName)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    LPWSTR String = NULL;
    UUID NewUid;

    Status = UuidCreate(&NewUid);
    if (Status == ERROR_SUCCESS)
    {
        Status = UuidToString( &NewUid,
                               &String );
        if (Status == ERROR_SUCCESS)
        {
            Status = DfsCreateUnicodePathString ( pNewName,
                                              0,  // no leading path sep
                                              NULL,
                                              String );

            RpcStringFree(&String );
        }
    }
    

    return Status;
}

DFSSTATUS 
DfsRootFolder::RenamePath(PUNICODE_STRING ParentDirectory,
                          PUNICODE_STRING DirectoryToRename)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NewdirectoryNameSize = 0;
    ULONG OlddirectoryNameSize = 0;
    BOOL fMoved = FALSE;
    PUNICODE_STRING pRootDir = NULL;
    PWSTR NewBuffer = NULL;
    PWSTR NewBuffer2 = NULL;
    PWSTR OldName = NULL;
    PWSTR NewName = NULL;
    UNICODE_STRING NewFileName;
    UNICODE_STRING OldFileName;
    UNICODE_STRING PartialName;
    UNICODE_STRING PathSep;
    UNICODE_STRING DfsPrefix;
    UNICODE_STRING UniNull;

    pRootDir = GetDirectoryCreatePathName();

    DfsRtlInitUnicodeStringEx( &NewFileName, NULL);
    DfsRtlInitUnicodeStringEx( &OldFileName, NULL);
    DfsRtlInitUnicodeStringEx( &PartialName, NULL);

    PathSep.Length = sizeof(UNICODE_PATH_SEP);
    PathSep.MaximumLength = sizeof(UNICODE_PATH_SEP);
    PathSep.Buffer = L"\\"; 

    UniNull.Length = sizeof(WCHAR);
    UniNull.MaximumLength = sizeof(WCHAR);
    UniNull.Buffer = L"\0"; 

    DfsRtlInitUnicodeStringEx( &DfsPrefix, DFSRENAMEPREFIX);

    Status = CreateRenameName(&PartialName);
    if(Status == ERROR_SUCCESS)
    {
        NewdirectoryNameSize = pRootDir->Length + ParentDirectory->Length +
                               DirectoryToRename->Length + 
                               PartialName.Length + (3 *PathSep.Length) +
                               DfsPrefix.Length+UniNull.Length;

        NewBuffer = (PWSTR) new BYTE[NewdirectoryNameSize];
        if(NewBuffer)
        {
            NewFileName.Buffer = NewBuffer;
            NewFileName.MaximumLength = (USHORT)NewdirectoryNameSize;

            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, pRootDir);
            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, &PathSep);
            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, ParentDirectory);
            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, &PathSep);
            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, &DfsPrefix);
            NtStatus = RtlAppendUnicodeToString(&NewFileName, &PartialName.Buffer[1]);
            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, DirectoryToRename);
            NtStatus = RtlAppendUnicodeStringToString(&NewFileName, &UniNull);
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if(NtStatus == STATUS_SUCCESS)
        {

            OlddirectoryNameSize = pRootDir->Length + ParentDirectory->Length + 
                                   (2*PathSep.Length) + DirectoryToRename->Length +
                                   UniNull.Length;
            NewBuffer2 = (PWSTR) new BYTE[OlddirectoryNameSize];
            if(NewBuffer2)
            {
                OldFileName.Buffer = NewBuffer2;
                OldFileName.MaximumLength = (USHORT)OlddirectoryNameSize;

                NtStatus = RtlAppendUnicodeStringToString(&OldFileName, pRootDir);
                NtStatus = RtlAppendUnicodeStringToString(&OldFileName, &PathSep);
                NtStatus = RtlAppendUnicodeStringToString(&OldFileName, ParentDirectory);
                NtStatus = RtlAppendUnicodeStringToString(&OldFileName, &PathSep);
                NtStatus = RtlAppendUnicodeStringToString(&OldFileName, DirectoryToRename);
                NtStatus = RtlAppendUnicodeStringToString(&OldFileName, &UniNull);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        Status = RtlNtStatusToDosError(NtStatus);
        if(Status == ERROR_SUCCESS)
        {
            OldName =  &OldFileName.Buffer[DFSDIRWHACKQOFFSET];
            NewName =  &NewFileName.Buffer[DFSDIRWHACKQOFFSET];
            fMoved = MoveFileW(OldName, NewName);
            if(fMoved == FALSE)
            {
                Status = GetLastError();
            }
        }
    }

    if(PartialName.Buffer)
    {
        DfsFreeUnicodeString( &PartialName );
    }

    if(OldFileName.Buffer)
    {
        delete [] OldFileName.Buffer;
    }

    if(NewFileName.Buffer)
    {
        delete [] NewFileName.Buffer;
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "RenamePath, link %wZ, Status %x\n",
                        ParentDirectory, Status);
    return Status;
}

NTSTATUS
StripAndReturnLastPathComponent(
    PUNICODE_STRING pPath, 
    PUNICODE_STRING pLeaf)
{
    USHORT i = 0, j = 0;
    USHORT OriginalLength = 0;

    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR *Src = NULL;


    if (pPath->Length == 0)
    {
        return Status;
    }

    OriginalLength = pPath->Length;

    for( i = (pPath->Length - 1)/ sizeof(WCHAR); i != 0; i--)
    {
        if (pPath->Buffer[i] != UNICODE_PATH_SEP)
        {
            break;
        }
    }

    for (j = i; j != 0; j--)
    {
        if (pPath->Buffer[j] == UNICODE_PATH_SEP)
        {
            break;
        }
    }

    //change the length of the orignal buffer to reflect
    //that the last component was stripped off

    pPath->Length = (j) * sizeof(WCHAR);

    if(j > 0 )
    {
        Src = &pPath->Buffer[((pPath->Length + sizeof( WCHAR)) /sizeof( WCHAR ))];

        pLeaf->Buffer = Src;
        pLeaf->Length = OriginalLength - (pPath->Length + sizeof( WCHAR));
        pLeaf->MaximumLength = pLeaf->Length;
    }
    else  //didn't find any //s
    {
        Src = &pPath->Buffer[pPath->Length /sizeof( WCHAR )];

        pLeaf->Buffer = Src;
        pLeaf->Length = OriginalLength - (pPath->Length);
        pLeaf->MaximumLength = pLeaf->Length;
    }


    return Status;

}

NTSTATUS
SendDataToSrv(PBYTE Buffer, 
              ULONG BUfferLength,
              DWORD IoCtl)
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE hMrxSmbHandle = NULL;
    UNICODE_STRING unicodeServerName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Open the server device.
    //

    DfsRtlInitUnicodeStringEx( &unicodeServerName, SERVER_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Opening the server with desired access = SYNCHRONIZE and open
    // options = FILE_SYNCHRONOUS_IO_NONALERT means that we don't have
    // to worry about waiting for the NtFsControlFile to complete--this
    // makes all IO system calls that use this handle synchronous.
    //

    status = NtOpenFile(
                 &hMrxSmbHandle,
                 FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 0,
                 0
                 );

    if ( NT_SUCCESS(status) ) {
        status = NtFsControlFile( hMrxSmbHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &ioStatusBlock,
                                  IoCtl,
                                  Buffer,
                                  BUfferLength,
                                  NULL,
                                  0 );

        NtClose( hMrxSmbHandle );
    }

    return status;
}

DFSSTATUS
SendShareToSrv(PUNICODE_STRING pShareName, 
               BOOLEAN fAttach) 
{
    NTSTATUS Status = STATUS_SUCCESS;
    DFSSTATUS DosStatus = ERROR_SUCCESS;
    PDFS_ATTACH_SHARE_BUFFER pBuffer = NULL;
    DWORD SizeToAllocate = 0;

    if((pShareName == NULL) || (pShareName->Buffer == NULL)
       || (pShareName->Length == 0))
    {
        return ERROR_INVALID_PARAMETER;
    }

    SizeToAllocate = pShareName->Length 
                   + sizeof(DFS_ATTACH_SHARE_BUFFER);


    pBuffer = (PDFS_ATTACH_SHARE_BUFFER) HeapAlloc(GetProcessHeap(), 
                                                0, 
                                                SizeToAllocate);
    if(pBuffer != NULL)
    {
        pBuffer->ShareNameLength = pShareName->Length ;
        pBuffer->fAttach = fAttach;

        RtlCopyMemory(
          &pBuffer->ShareName[0],
          pShareName->Buffer,
          pBuffer->ShareNameLength);

        Status = SendDataToSrv((PBYTE) pBuffer, 
                               SizeToAllocate,
                               FSCTL_DFS_UPDATE_SHARE_TABLE);

        DosStatus = RtlNtStatusToDosError(Status);

        if(pBuffer)
        {
          HeapFree(GetProcessHeap(), 0, pBuffer);
        }

        if(DosStatus != ERROR_SUCCESS)
        {
            DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!] (1) %wZ status %x DosStatus %x\n", pShareName, Status, DosStatus);
        }
    }
    else
    {
        DosStatus = ERROR_NOT_ENOUGH_MEMORY;
        DFS_TRACE_ERROR_HIGH(Status, REFERRAL_SERVER, "[%!FUNC!] %wZ status %x\n", pShareName, DosStatus);
    }


    return DosStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsreferraldata.cxx ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <ntsam.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <string.h>
#include <tchar.h>
#include <stdarg.h>
#include <process.h>

#include <ole2.h>
#include <Align.h>
#include <ntdsapi.h>
#include <DfsReferralData.hxx>
#include <DfsSiteNameSupport.hxx>
#include <DfsISTGSupport.hxx>

#define NTDSAPI_INTEGRATED

// xxxdfsdev Take this stuff out when we integrate with DSAPI.

#if defined(NTDSAPI_INTEGRATED)

#define _DsQuerySitesByCost(a,b,c,d,e,f) DsQuerySitesByCost(a,b,c,d,e,f) 
#define _DsQuerySitesFree(a) DsQuerySitesFree(a)
#else
#define _DsQuerySitesByCost(a,b,c,d,e,f) STUB_DsQuerySitesByCost(a,b,c,d,e,f) 
#define _DsQuerySitesFree(a) STUB_DsQuerySitesFree(a)

#endif

typedef struct xx {
    LPWSTR From;
    LPWSTR To;
    ULONG Cost;
} DfsSiteLinkCost, *PCOST_VECTOR;

static DfsSiteLinkCost CostMatrix[] = {
                            { L"SiteT1", L"SiteT1", 0xFFFFFFFF},
                            { L"SiteT1", L"SiteT2", 30 }, 
                            { L"SiteT1", L"SiteT3", 40 },
                            { L"SiteT1", L"SiteT4", 50 },
                            { L"SiteT2", L"SiteT2", 0xFFFFFFFF},
                            { L"SiteT2", L"SiteT3", 50 },
                            { L"SiteT2", L"SiteT4", 60 },
                            { L"SiteT3", L"SiteT3", 0xFFFFFFFF},
                            { L"SiteT3", L"SiteT4", 70 },
                            { L"SiteT4", L"SiteT4", 0xFFFFFFFF},
                            { NULL, NULL, NULL }
                         };
                            
DFSSTATUS
DfsGetCostsFromDs( 
    IN DfsSite *pFromSite,
    IN LPWSTR *pToSites,
    IN ULONG NumSites,
    OUT PDS_SITE_COST_INFO *ppDsSiteCostInfo);

DWORD
STUB_DsQuerySitesByCost( 
    IN HANDLE hDs,
    IN LPWSTR pFromSite,
    IN LPWSTR *pToSites,
    IN DWORD NumSites,
    IN DWORD dwFlags,
    OUT PDS_SITE_COST_INFO *ppDsSiteCostInfo);

VOID
STUB_DsQuerySitesFree(
    IN PDS_SITE_COST_INFO pSiteInfo)
{
    free(pSiteInfo);
}

ULONG
CalcCost(
    PCOST_VECTOR pMatrix,
    IN LPWSTR pFromSite,
    IN LPWSTR pToSite)
{
    while (pMatrix->From)
    {
        if (((!_wcsicmp(pFromSite, pMatrix->From)) &&
           (!_wcsicmp(pToSite, pMatrix->To))) ||

           ((!_wcsicmp(pFromSite, pMatrix->To)) &&
           (!_wcsicmp(pToSite, pMatrix->From))))
        {
            return pMatrix->Cost;
        }
        pMatrix +=1;
    }

    if (!_wcsicmp(pFromSite, pToSite))
        return 0;
    return ULONG_MAX;
    UNREFERENCED_PARAMETER(pMatrix);
}

DWORD
STUB_DsQuerySitesByCost( 
    IN HANDLE hDs,
    IN LPWSTR pFromSite,
    IN LPWSTR *pToSites,
    IN DWORD NumSites,
    IN DWORD dwFlags,
    OUT PDS_SITE_COST_INFO *ppDsSiteCostInfo)
{
    PDS_SITE_COST_INFO SiteArray = NULL;
    *ppDsSiteCostInfo = NULL;
    //ULONG rand = 0;
    ULONG i;
    
    SiteArray = (PDS_SITE_COST_INFO)malloc(sizeof(DS_SITE_COST_INFO) * NumSites);
    if (SiteArray == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    for (i = 0; i < NumSites; i++)
    {
        SiteArray[i].errorCode = ERROR_SUCCESS; //(rand > 70) ? ERROR_DC_NOT_FOUND : ERROR_SUCCESS;
        SiteArray[i].cost = CalcCost( CostMatrix, pFromSite, pToSites[i]);
    }

    *ppDsSiteCostInfo = SiteArray;
    return ERROR_SUCCESS;
    
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pToSites);
    UNREFERENCED_PARAMETER(pFromSite);
    UNREFERENCED_PARAMETER(hDs);
}

                               
DFSSTATUS
DfsReferralData::PopulateTransientTable(
    PUNICODE_STRING pReferralSiteName,
    DfsSiteNameSupport  *pTransientSiteTable)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsReplica *pReplica = NULL;
    DfsSite *pTargetSite = NULL;
    ULONG NumReplicas = 0; 

    //
    // Iterate through all the replicas and add their sites to the transient table.
    // This will give us a list of unique sites.
    //
    for (NumReplicas = 0; NumReplicas < ReplicaCount; NumReplicas++)
    {
        pReplica = &pReplicas[ NumReplicas ];
        pTargetSite = pReplica->GetSite();

        ASSERT(pTargetSite != NULL);

        //
        // Note that NULL sitenames is the only exception we make.
        // We don't even assume that the cost between sites of
        // two equal names is 0 here.
        //
        if ((pReplica->IsTargetAvailable() == TRUE) && 
           (!IsEmptyUnicodeString( pTargetSite->SiteName() )))
        {
            //
            // Add it to our temporary hash table to eliminate duplicate
            // site names. This call will take an additional reference on 
            // the target site.
            // We ignore errors here and keep going. The cost generation
            // may fail at multiple points so we deal with it anyway.
            //
            (VOID) pTransientSiteTable->StoreSiteInCache( pTargetSite );
        }
    }

    return Status;
    UNREFERENCED_PARAMETER( pReferralSiteName );
}


DFSSTATUS
DfsReferralData::CreateUniqueSiteArray(
    PUNICODE_STRING pReferralSiteName,
    LPWSTR **ppSiteNameArray,
    DfsSite ***ppDfsSiteArray,
    PULONG pNumUniqueSites)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    SHASH_ITERATOR Iter;
    LPWSTR *UniqueSiteArray = NULL;
    DfsSite **DfsSiteArray = NULL;
    ULONG NumSites = 0;
    DfsSite *pSite = NULL;
    DfsSiteNameSupport *pTable = NULL;
    ULONG i;

    *ppSiteNameArray = NULL;
    *ppDfsSiteArray = NULL;
        
    do {
        //
        // Round up the table size to the nearest 4, but cap it at 512.
        //
        ULONG HashTableSize = ROUND_UP_COUNT(ReplicaCount, (ULONG)MIN_SITE_COST_HASH_BUCKETS);
        if (HashTableSize > MAX_SITE_COST_HASH_BUCKETS)
        {
            HashTableSize = MAX_SITE_COST_HASH_BUCKETS;
        }
        
        pTable = DfsSiteNameSupport::CreateSiteNameSupport( &Status, HashTableSize);
        if (Status != ERROR_SUCCESS)
        {
            break;
        }        
        
        // We need to iterate through all the replica servers here,
        // and create a list of unique sites they belong to.
        // If we hit an error, we can't generate this cost matrix.
        //
        Status = PopulateTransientTable( pReferralSiteName, pTable );
        if (Status != ERROR_SUCCESS)
        {
            break;
        }
        
        NumSites = pTable->NumElements();
        
        //
        // If there aren't any sites to deal with, we've nothing to do.
        //
        if (NumSites == 0)
        {
            Status = ERROR_NO_MORE_ITEMS;
            break;
        }

        //
        // Next allocate the array of pointers to hold the sitenames.
        //
        UniqueSiteArray = (LPWSTR *)new BYTE [sizeof(LPWSTR) * NumSites];
        if (UniqueSiteArray == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // This array is useful in remembering the DfsSites corresponding to the sitenames above.
        //
        DfsSiteArray = (DfsSite **)new BYTE[ sizeof(pSite) * NumSites ];
        if (DfsSiteArray == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Now iterate through the unique site names and make an array 
        // of strings out of them. We also get the corresponding DfsSite in the same order
        // because we don't want to do a lookup for them later.
        //
        pSite = pTable->StartSiteEnumerate( &Iter );
        for (i = 0; 
            (i < NumSites) && (pSite != NULL) && (!IsEmptyString(pSite->SiteNameString())); 
            i++)
        {
            //
            // We simply copy pointers because we know that the targetsite is
            // referenced and won't go away until we are done.
            //
            UniqueSiteArray[i] = pSite->SiteNameString();

            //
            // Keep a reference to the destination site. We don't need to take
            // an additional reference here because this is just temporary and 
            // we are already protected by a reference in DfsReplica.
            //
            DfsSiteArray[i] = pSite;

            //
            // Iterate to the next site.
            //
            pSite = pTable->NextSiteEnumerate( &Iter );
        }
        
        pTable->FinishSiteEnumerate( &Iter );

        *ppSiteNameArray = UniqueSiteArray;
        *ppDfsSiteArray = DfsSiteArray;
        *pNumUniqueSites = i;
    } while (FALSE);
    
    //
    // If we populated this table, take those elements out and
    // delete the table.
    //
    if (pTable != NULL)
    {
        delete pTable;
        pTable = NULL;
    }
    
    // Error path
    if (Status != ERROR_SUCCESS)
    { 
        if (UniqueSiteArray != NULL)
        {
            DeleteUniqueSiteArray((LPBYTE)UniqueSiteArray);
        }

        if (DfsSiteArray != NULL)
        {
            DeleteUniqueSiteArray((LPBYTE)DfsSiteArray);
        }
    }
    
    return Status;
}

VOID
DfsReferralData::DeleteUniqueSiteArray(
    LPBYTE pSiteArray)
{
    delete [] pSiteArray;
}

// GenerateCostMatrix
//
// Given the referral site, get the corresponding cost
// information for referrals coming from it.
//
DFSSTATUS
DfsReferralData::GenerateCostMatrix(
    DfsSite *pReferralSite)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    ULONG NumUniqueSites = 0;
    LPWSTR *UniqueSiteArray = NULL;
    DfsSite **DestinationDfsSiteArray = NULL;
    PDS_SITE_COST_INFO pDsSiteCostInfo = NULL;
    ULONG i;
    
    do {
        //
        // This check is unsafe. But this check doesn't need to be
        // critically accurate anyway. It's not worth avoiding a race
        // with another thread that is updating these counters simultaneously.
        // Worst case, we do the DS call that's likely to fail. No big deal.
        //
        if (_NumDsErrors > DS_ERROR_THRESHOLD)
        {
            //
            // xxx We can certainly implement a timer here, so we only skip
            // the DS call for a shorter period of time than the cachetime
            // of the Referral (~1 hr or so).
            //
            Status = _LastDsError;
            break;
        }
        
        //
        // We need to iterate through all the replica servers here,
        // and create a list of unique sites they belong to.
        // If we hit an error, we can't generate this cost matrix.
        //
        Status = CreateUniqueSiteArray( pReferralSite->SiteName(), 
                                     &UniqueSiteArray, 
                                     &DestinationDfsSiteArray, 
                                     &NumUniqueSites );
        
        
        if (Status != ERROR_SUCCESS)
        {
            break;
        }

        ASSERT( UniqueSiteArray != NULL );
        ASSERT( DestinationDfsSiteArray != NULL );
        
        //
        // We are ready to send the sitearray to the DS to get the corresponding cost array.
        //
        Status = DfsGetCostsFromDs( pReferralSite, UniqueSiteArray, NumUniqueSites, &pDsSiteCostInfo);

        //
        // If we got any errors, keep track of them so we know not to retry this
        // too many times.
        //
        if (Status != ERROR_SUCCESS)
        {
            //
            // This is the number of *consecutive* errors.
            //
            InterlockedIncrement((volatile LONG*)&_NumDsErrors);
            InterlockedExchange((volatile LONG*)&_LastDsError, Status);
            break;
        }

        //
        // The DS call succeeded. 
        // Zero the counter now. We don't bother to see whether it's
        // already zero or not.
        //
        InterlockedExchange((volatile LONG*)&_NumDsErrors, 0);
        
        //
        // Add the cost array to the SiteCostTable.
        // If we are going to chuck entire site cost tables when we do aging,
        // we'll have to protect ourselves here. xxxdfsdev
        //
        for (i = 0; i < NumUniqueSites; i++)
        {
            //
            // Ignore errors SetCost returns and continue. 
            // Also note that the SiteInfoW array we got may contain
            // errors in the ValidityStatus field. We still cash these entries
            // so that we know we have tried.
            //
            (VOID) pReferralSite->SetCost( DestinationDfsSiteArray[i],
                                           pDsSiteCostInfo[i].cost,
                                           pDsSiteCostInfo[i].errorCode );         
        }
        
    } while (FALSE);

    //
    // Delete temporary arrays we used.
    //
    if (UniqueSiteArray != NULL)
    {
        DeleteUniqueSiteArray( (LPBYTE)UniqueSiteArray );
        DeleteUniqueSiteArray( (LPBYTE)DestinationDfsSiteArray );
    }

    //
    // Free what we got from DS.
    //
    if (pDsSiteCostInfo != NULL)
    {
        _DsQuerySitesFree( pDsSiteCostInfo );
    }
    
    return Status;
}


DFSSTATUS
DfsGetCostsFromDs( 
    IN DfsSite *pFromSite,
    IN LPWSTR *pToSites,
    IN ULONG NumSites,
    OUT PDS_SITE_COST_INFO *ppDsSiteCostInfo)
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsISTGHandle *pDsHandle = NULL;
    BOOLEAN ReInitialized = FALSE;

    //
    // Acquire the global handle to the ISTG.
    // It is entirely possible for this to not be 
    // initialized at this point due to an ISTG bind failure.
    //
    pDsHandle = DfsAcquireISTGHandle();
    while (pDsHandle == NULL && !ReInitialized)
    {
        Status = DfsReBindISTGHandle();
            
        //
        // If we still can't get a handle to the ISTG
        // return an error so the caller knows to fall back
        // to the default costs.
        //
        if (Status != ERROR_SUCCESS)
        {
            return Status;
        }
        ReInitialized = TRUE;
        pDsHandle = DfsAcquireISTGHandle();
    }

    // Can't go on without a handle
    if (pDsHandle == NULL)
    {
        return ERROR_NOT_FOUND;
    }
    
    // Call the DS API to get the corresponding cost info array.
    Status = _DsQuerySitesByCost(
                    pDsHandle->DsHandle,
                    pFromSite->SiteNameString(),
                    pToSites,
                    NumSites,
                    0,
                    ppDsSiteCostInfo);

    // Release our reference on the global handle
    DfsReleaseISTGHandle( pDsHandle );
    
    if (Status != ERROR_SUCCESS)
    {
        //
        // We'll need to regenerate this handle.
        // This will implement a policy that ensures that
        // we don't overload the ISTG. 
        // However, it doesn't change the fact that this
        // query failed. We don't want to retry here.
        //
        if (!ReInitialized)
        {
            (VOID)DfsReBindISTGHandle();
        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\remotefs\dfs\dfsserver\serverlibrary\dfsregistrystore.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       DfsRegistryStore.cxx
//
//  Contents:   the Registry DFS Store class, this contains the registry
//              specific functionality.
//
//  Classes:    DfsRegistryStore.
//
//  History:    Dec. 8 2000,   Author: udayh
//
//-----------------------------------------------------------------------------


#include "DfsRegistryStore.hxx"
#include "DfsRegistryRootFolder.hxx"
#include "DfsFilterApi.hxx"
#include "dfsmisc.h"

#include "domainControllerSupport.hxx"
#include "DfsRegStrings.hxx"
#include "shlwapi.h"
#include "align.h"

//
// logging specific includes
//
#include "DfsRegistryStore.tmh" 

extern
DFSSTATUS
MigrateDfs(
    LPWSTR MachineName);


//+----------------------------------------------------------------------------
//
//  Class:      DfsRegistryStore
//
//  Synopsis:   This class inherits the basic DfsStore, and extends it
//              to include the registry specific functionality.
//
//-----------------------------------------------------------------------------

LPWSTR DfsRegistryNameString = L"ID";
LPWSTR DfsRegistryRecoveryString = L"Recovery";
LPWSTR DfsRegistryReplicaString  = L"Svc";
LPWSTR DfsRegistryDfsDriverLocation = DFS_REG_DFS_DRIVER_LOCATION;
LPWSTR DfsLocalVolumesValue = DFS_REG_LOCAL_VOLUMES_CHILD;
extern LPWSTR DfsVolumesLocation;

//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizer -  the recognizer for the store.
//
//  Arguments:  Name - the namespace of interest.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine checks if the specified namespace holds
//               a registry based DFS. If it does, it reads in the
//               root in that namespace and creates and adds it to our
//               list of known roots, if it doesn't already exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::StoreRecognizer(
    LPWSTR Name )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY OldStandaloneDfsKey = NULL;
    HKEY StandaloneDfsKey = NULL;
    BOOLEAN MachineContacted = FALSE;

    //
    // Make sure the namespace is the name of a machine. Registry based
    // dfs exist only on machines.
    //

    if (IsEmptyString(Name) == FALSE) 
    {
        Status = DfsIsThisAMachineName( Name );
        if(Status != ERROR_SUCCESS)
        {
            return Status;
        }
    }


    DFS_TRACE_LOW(REFERRAL_SERVER, "DfsRegistryStore:StoreRecognizer, Name %ws Is Machine Status %x\n", Name, Status);


    //
    // we now find all the migrated multiple roots standalone DFS's as 
    // well as the old single root standalone DFS, and add them to our
    // in memory metadata.
    //
    Status = GetNewStandaloneRegistryKey( Name,
                                          FALSE,
                                          &MachineContacted,
                                          &StandaloneDfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = StoreRecognizeNewDfs( Name,
                                       StandaloneDfsKey );

         RegCloseKey( StandaloneDfsKey );
    }

    //
    // Need to refine the return status further: success should mean
    // machine is not std dfs or we have read the std dfs data correctly.
    //
    DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "Dfs registry store recognizser, status %x\n", Status);
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizer -  the recognizer for the store.
//
//  Arguments:  DfsNameContext - the namespace of interest.
//             LogicalShare
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine checks if the specified namespace holds
//               a domain based DFS. If it does, it reads in the
//               root in that namespace and creates and adds it to our
//               list of known roots, if it doesn't already exist in our list.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::StoreRecognizer (
    LPWSTR DfsNameContext,
    PUNICODE_STRING pLogicalShare )
{
    DFSSTATUS Status;

    Status = DfsIsThisAMachineName( DfsNameContext );

    if (Status == ERROR_SUCCESS)
    {
        Status = StoreRecognizeNewDfs( DfsNameContext,
                                       pLogicalShare );
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "DfsRegistryStore:StoreRecognizer (remote), Status %x\n",
                          Status);
    return Status;
}


DFSSTATUS
DfsRegistryStore::LookupDotNetRootByName(
    LPWSTR ShareName,
    DfsRootFolder **ppRootFolder )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY DfsKey = NULL;
    HKEY DfsRootKey = NULL;

    Status = GetNewStandaloneRegistryKey( NULL,
                                          FALSE,
                                          NULL,
                                          &DfsKey );
    if (Status == ERROR_SUCCESS)
    {
        Status = RegOpenKeyEx( DfsKey,
                               ShareName,
                               0,
                               KEY_READ,
                               &DfsRootKey );

        RegCloseKey(DfsKey );


        if (Status == ERROR_SUCCESS)
        {
            Status = GetRootFolder( NULL,
                                    ShareName,
                                    DfsRootKey,
                                    ppRootFolder );
            RegCloseKey(DfsRootKey);
        }
    }

    return Status;
}


DFSSTATUS
DfsRegistryStore::LookupOldRootByName(
    LPWSTR ShareName,
    DfsRootFolder **ppRootFolder )
{

    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY DfsKey = NULL;
    HKEY DfsRootKey = NULL;
    UNICODE_STRING LogicalShare;

    Status = GetOldStandaloneRegistryKey( NULL,
                                          FALSE,
                                          NULL,
                                          &DfsRootKey );

    if (Status == ERROR_SUCCESS)
    {
        Status = GetRootPhysicalShare( DfsRootKey,
                                      &LogicalShare);
        if (Status == ERROR_SUCCESS)
        {
            if (_wcsicmp(ShareName, LogicalShare.Buffer) != 0)
            {
                Status = ERROR_NOT_FOUND;

                ReleaseRootLogicalShare( &LogicalShare );
            }
        }


        if(Status == ERROR_SUCCESS)
        {
            Status = MigrateDfs( L"" );
            if(Status == ERROR_SUCCESS)
            {

               Status = GetRootFolder( L"",
                                       ShareName,
                                       &LogicalShare,
                                       &LogicalShare,
                                       ppRootFolder );
            }


            ReleaseRootLogicalShare( &LogicalShare );
        }


        if(DfsRootKey != NULL)
        {
            RegCloseKey( DfsRootKey );
        }
    }

    return Status;
}

DFSSTATUS
DfsRegistryStore::LookupNewRootByName(
    LPWSTR ShareName,
    DfsRootFolder **ppRootFolder )
{
    DFSSTATUS Status = ERROR_NOT_FOUND;

    if(DfsIsMachineCluster())
    {
        Status = LookupOldRootByName (ShareName, ppRootFolder);
        if(Status != ERROR_SUCCESS)
        {
            Status = LookupDotNetRootByName (ShareName, ppRootFolder);
        }
    }
    return Status;
}


#if 0
//+-------------------------------------------------------------------------
//
//  Function:   StoreRecognizeOldStandaloneDfs -  recognizer for single root dfs
//
//  Arguments:  Name - the namespace of interest.
//              HKEY OldDfsKey.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine reads a single root from the old standalone
//               location, and loads it in if the root exists.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::StoreRecognizeOldStandaloneDfs(
    LPWSTR MachineName,
    HKEY   OldDfsKey )
{
    DfsRootFolder *pRootFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;
    DFSSTATUS RootStatus = ERROR_SUCCESS;
    UNICODE_STRING LogicalRoot;
    UNICODE_STRING DfsNameContext;
    UNREFERENCED_PARAMETER(MachineName);

    RtlZeroMemory(&LogicalRoot, sizeof(LogicalRoot));
    
    //
    // Check if we have a root folder read from the old dfs location 
    // ("domainroot"). If we have not seen the root already, and one
    // exists, a new root folder gets created. 
    // Status = DfsGetRegValueString (OldDfsKey, 
                                  // DfsRootShareValueName,
                                  // &LogicalRoot);

    Status = GetRootPhysicalShare(OldDfsKey,&LogicalRoot);
    if(Status == ERROR_SUCCESS)
    {


        RtlInitUnicodeStringEx( &DfsNameContext, NULL);

        //
        // Check if we already know about this root. If we do, this
        // routine gives us a referenced root folder which we can return.
        // If not, we create a brand new root folder.
        //

        Status = LookupRoot( &DfsNameContext,
                             &LogicalRoot,
                             &pRootFolder );

        //
        // we did not find a root, so create a new one.
        //
        if ( Status != ERROR_SUCCESS )
        {
            Status = MigrateStdDfs( L"", 
                                    OldDfsKey,
                                    (LPWSTR) LogicalRoot.Buffer,
                                    (LPWSTR) LogicalRoot.Buffer,
                                    FALSE);
            if(Status == ERROR_SUCCESS)
            {

                //
                // Now get either an existing root by this name,
                // or create a new one.
                //
                RootStatus = GetRootFolder( L"",
                                            LogicalRoot.Buffer,
                                            &LogicalRoot,
                                            &LogicalRoot,
                                            &pRootFolder );

                if (RootStatus == ERROR_SUCCESS)
                {

                //
                // Call the synchronize method on the root to
                // update it with the latest children.
                // Again, ignore the error since we need to move
                // on to the next root.
                // dfsdev: need eventlog to signal this.
                //
                RootStatus = pRootFolder->Synchronize();

                //
                // If the Synchronize above had succeeded, then it would
                // all the reparse points that the root needs. Now we n
                // this volume as one that has DFS reparse points so th
                // to perform garbage collection on this volume later o
                //
                (VOID)pRootFolder->AddReparseVolumeToList();

                }
            }
        }



        ReleaseRootPhysicalShare( &LogicalRoot );
    }


    if(pRootFolder != NULL)
    {
        pRootFolder->ReleaseReference();
    }
  
    return Status;
}
#endif
#if 0
DFSSTATUS
DfsRegistryStore::StoreRecognizeOldStandaloneDfs(
    LPWSTR MachineName,
    HKEY   OldDfsKey )
{
    DfsRootFolder *pRootFolder = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // Check if we have a root folder read from the old dfs location 
    // ("domainroot"). If we have not seen the root already, and one
    // exists, a new root folder gets created. 
    //
    Status = GetRootFolder( MachineName,
                            NULL,
                            OldDfsKey,
                            &pRootFolder );

    //
    // We got a root folder. call synchronize on it to update its contents.
    // The synchronize method fills the root with the most upto date
    // children data.
    //

    if (Status == ERROR_SUCCESS)
    {

        DFSSTATUS RootStatus;

        //
        // now acquire the root share directory. If this
        // fails, we continue our operation: we can continue
        // with synchonize and not create directories.
        // dfsdev:we need to post a eventlog or something when
        // we run into this.
        //
        RootStatus = pRootFolder->AcquireRootShareDirectory();

        //
        // Call the synchronize method on the root to
        // update it with the latest children.
        // Again, ignore the error since we need to move
        // on to the next root.
        // dfsdev: need eventlog to signal this.
        //
        RootStatus = pRootFolder->Synchronize();

        DFSLOG("Root folder for %ws, Synchronize status %x\n",
               RootStatus );

        // Release our reference on the root folder.

        pRootFolder->ReleaseReference();
    }
    
    return Status;
}
#endif



//+-------------------------------------------------------------------------
//
//  Function:   CreateNewRootFolder -  creates a new root folder
//
//  Arguments:  Name - the namespace of interest.
//              pPrefix - the logical share for this DFs.
//              ppRoot -  the newly created root.
//
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine creates a new registry root folder, and
//               adds it to the list of known roots.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::CreateNewRootFolder (
    LPWSTR MachineName,
    LPWSTR RootRegKeyName,
    PUNICODE_STRING pLogicalShare,
    PUNICODE_STRING pPhysicalShare,
    DfsRootFolder **ppRoot )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    DfsRootFolder *pNewRoot = NULL;

    //
    // Create a new instance of the RegistryRootFolder class.
    // This gives us a reference RootFolder.
    //
    pNewRoot = new DfsRegistryRootFolder( MachineName,
                                          RootRegKeyName,
                                          pLogicalShare,
                                          pPhysicalShare,
                                          this,
                                          &Status );

    if ( pNewRoot == NULL )
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } 

    if ( ERROR_SUCCESS == Status )
    {
        //
        // AddRootFolder to the list of known roots. AddRootFolder
        // is responsible to acquire any reference on the root folder
        // if it is storing a reference to this root.

        Status = AddRootFolder( pNewRoot, NewRootList );

        if ( ERROR_SUCCESS == Status )
        {
            //
            // We were successful, return the reference root. The reference
            // that we are returning is the create reference on the new root.
            //
            *ppRoot = pNewRoot;
        }
        else 
        {
            pNewRoot->ReleaseReference();
            pNewRoot = NULL;
        }
    }
    else
    {
      if(pNewRoot != NULL)
      {
          pNewRoot->ReleaseReference();
          pNewRoot = NULL;
      }
    }

    DFS_TRACE_ERROR_LOW(Status, REFERRAL_SERVER, "RegistryStore::CreateNewRootFolder. New root %p, for root %wZ (%wZ) on machine %ws. Status %x\n",
                        *ppRoot, pLogicalShare, pPhysicalShare, MachineName, Status);

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetMetadata- Gets the DFS metadata information
//
//  Arguments:  DfsMetadataKey - The key under which the information exists
//              RelativeName   - the name of the subkey, having info of interest
//              RegistryValueNameString - The value name that holds the info.
//              ppData - the pointer that holds data buffer being returned
//              pDataSize - pointer to size of data being returned.
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information,
//               error status otherwise.
//
//
//  Description: This routine reads the value of interest under the specified
//               key/subkey. The information is read in a buffer allocated
//               by this routine, and the buffer is returned to the caller.
//               It is the caller's responsibility to free this buffer when
//               done.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::GetMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    OUT PVOID *ppData,
    OUT ULONG *pDataSize,
    OUT PFILETIME pLastModifiedTime)
{

    HKEY NewKey = NULL;
    HKEY UseKey = NULL;
    PVOID pDataBuffer = NULL;
    ULONG DataSize, DataType;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // If a relative name was passed in, we need to open a subkey under the
    // passed in key. Otherwise, we already have a key open to the information
    // of interest.
    //
    if ( RelativeName != NULL )
    {
        Status = RegOpenKeyEx( DfsMetadataKey, 
                               RelativeName, 
                               0,
                               KEY_READ,
                               &NewKey );
        if ( Status == ERROR_SUCCESS )
        {
            UseKey = NewKey;
        }
        else
        {
          DFS_TRACE_HIGH( REFERRAL_SERVER, "registry store, GetMetadata-RegOpenKeyEx %ws status=%d\n", RelativeName, Status);
        }
    } else
    {
        UseKey = DfsMetadataKey;
    }

    //
    // Get the largest size of any value under the key of interest, so we know
    // how much we need to allocate in the worst case.
    // (If a subkey has 3 values, this returns the maximum memory size required
    // to read any one of the values.)
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = RegQueryInfoKey( UseKey,       // Key
                                  NULL,         // Class string
                                  NULL,         // Size of class string
                                  NULL,         // Reserved
                                  NULL,         // # of subkeys
                                  NULL,         // max size of subkey name
                                  NULL,         // max size of class name
                                  NULL,         // # of values
                                  NULL,         // max size of value name
                                  &DataSize,    // max size of value data,
                                  NULL,         // security descriptor
                                  pLastModifiedTime ); // Last write time
    }

    //
    // We have the required size now: allocate a buffer for that size and
    // read the value we are interested in.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pDataBuffer = new BYTE [DataSize];

        if ( pDataBuffer == NULL )
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
        } else
        {
            Status = RegQueryValueEx( UseKey,
                                      RegistryValueNameString,
                                      NULL,
                                      &DataType,
                                      (LPBYTE)pDataBuffer,
                                      &DataSize );
            //
            // If the format of data is not a certain type (usually binary type for DFS)
            // we have bogus data.
            //
            if ( (Status == ERROR_SUCCESS) && (DataType != DFS_REGISTRY_DATA_TYPE) )
            {
                Status = ERROR_INVALID_DATA;
            }
        }
    }

    //
    // If we are successful in reading the value, pass the allcoated buffer and
    // size back to caller. Otherwise, free up the allocate buffer and return
    // error status to the caller.
    //
    if ( Status == ERROR_SUCCESS )
    {
        *ppData = pDataBuffer;
        *pDataSize = DataSize;
    } 
    else 
    {
        if ( pDataBuffer != NULL )
        {
            delete [] pDataBuffer;
        }
    }

    //
    // If we did open a new key, it is time to close it now.
    //
    if ( NewKey != NULL )
        RegCloseKey(NewKey);

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, GetMetadata-leaving %ws status=%d\n", RelativeName, Status);


    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   SetMetadata- Sets the DFS metadata information
//
//  Arguments:  DfsMetadataKey - The key under which the information exists
//              RelativeName   - the name of the subkey, to store info
//              RegistryValueNameString - The value name that holds the info.
//              pData - the pointer that holds data buffer
//              DataSize - Size of data
//
//  Returns:    Status
//               STATUS_SUCCESS if we could write the information,
//               error status otherwise.
//
//
//  Description: This routine writes the value of interest under the specified
//               key/subkey. 
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::SetMetadata (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    IN LPWSTR RegistryValueNameString,
    IN PVOID pData,
    IN ULONG DataSize )
{

    HKEY UseKey = NULL;
    DFSSTATUS Status = ERROR_SUCCESS;

    //
    // If a relative name was passed in, we need to open a subkey under the
    // passed in key. Otherwise, we already have a key open to the information
    // of interest.
    //
    Status = RegOpenKeyEx( DfsMetadataKey, 
                           RelativeName, 
                           0,
                           KEY_READ | KEY_WRITE,
                           &UseKey );

    //
    // Store the value against the passed in value string
    //
    if (Status == ERROR_SUCCESS)
    {
        Status = RegSetValueEx( UseKey,
                                RegistryValueNameString,
                                NULL,
                                DFS_REGISTRY_DATA_TYPE,
                                (LPBYTE)pData,
                                DataSize );
        RegCloseKey(UseKey);
    }

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, SetMetadata-RegOpenKeyEx %ws status=%d\n", RelativeName, Status);

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   GetRootKey -  get the root key
//
//  Arguments:  Name - the namespace of interest.
//              pMachineContacted - did we contact the machine?
//              pDfsRootKey -  the returned key.
//
//  Returns:    Status
//               ERROR_SUCCESS on success
//               ERROR status code otherwise
//
//
//  Description: This routine connects to the appropriate machine, and
//               opens the DFS metadata information in the registry.
//               If it succeeds, the machine hosts a registry DFs, and
//               the opened key is returned.
//
//--------------------------------------------------------------------------


DFSSTATUS
DfsRegistryStore::GetRootKey(
    LPWSTR MachineName,
    LPWSTR ChildName,
    BOOLEAN *pMachineContacted,
    OUT PHKEY pDfsRootKey )
{
    DFSSTATUS Status;
    HKEY DfsStdRegistryKey;
    LPWSTR UseChildName = NULL;

    if (IsEmptyString(ChildName) == FALSE) 
    {
        UseChildName = ChildName;
    }

    //
    // If there is no childname specified, we are dealing with the
    // old style dfs: a single root exists on the machine under "domainroot".
    // so open that key, and return it.
    // If a childname is specified, we are dealing with a migrated
    // dfs. Open the specified child in the new location.
    //

    if (UseChildName != NULL) 
    {
        Status = GetNewStandaloneRegistryKey( MachineName,
                                              FALSE,
                                              pMachineContacted,
                                              &DfsStdRegistryKey );

        if (Status == ERROR_SUCCESS) 
        {
            //
            // We then open the required child key, and close
            // the parents key.
            //
            Status = RegOpenKeyEx( DfsStdRegistryKey,
                                   ChildName,
                                   0,
                                   KEY_READ,
                                   pDfsRootKey );

            RegCloseKey( DfsStdRegistryKey );
        }
    }
    else 
    {
        //
        // no name was specified. This must be the old standalone
        // child.   (single root)
        //
        Status = GetOldStandaloneRegistryKey( MachineName,
                                              FALSE,
                                              pMachineContacted,
                                              pDfsRootKey );
    }

    DFSLOG("DfsRegistryStore::GetDfsRootKey %ws Machine, Contacted %d Status %x\n",
           MachineName, pMachineContacted ? *pMachineContacted : 2, Status );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDataRecoveryInformation -  Gets recovery info
//
//  Arguments:  DfsMetadataKey -  an open key to the registry.
//              RelativeName - Name of a subkey under the above key.
//              pRecoveryState - The recovery state we read.
//
//  Returns:    Status
//               STATUS_SUCCESS if we could read the information
//               error status otherwise.
//
//
//  Description: This routine read the RECOVERY value for the Root or link of
//               a dfs tree and returns with the value.
//               A non-zero state means that some recovery is required.
//               Note that there is more information in the RECOVERY value than
//               the state. Currently, we ignore that information and just return
//               the state.
//               In the future, we dont plan to use this value.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::GetDataRecoveryState (
    IN HKEY DfsMetadataKey,
    IN LPWSTR RelativeName,
    OUT PULONG pRecoveryState )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    PVOID DataBuffer = NULL, CurrentBuffer;
    ULONG DataSize, CurrentSize;

    Status = GetMetadata (DfsMetadataKey,
                          RelativeName,
                          DfsRegistryRecoveryString,
                          &DataBuffer,
                          &DataSize,
                          NULL ); // we dont care about last mod time.

    //
    // We are currently interested in the first word in the data stream.
    // This holds the recovery state.
    //

    if ( Status == STATUS_SUCCESS )
    {
        CurrentBuffer = DataBuffer;
        CurrentSize = DataSize;
        Status = PackGetULong( pRecoveryState,
                               &CurrentBuffer,
                               &CurrentSize );
    }

    ReleaseMetadataBlob( DataBuffer );

    //
    // If we could not read the value, then we return success and
    // and indicate state of 0. This is so that we can support roots
    // or links that dont have this value.
    //
    if ( Status != ERROR_SUCCESS )
    {
        DFSLOG("DfsRegistryStore::DfsGetDataRecoveryState Status %x\n", 
               Status);

        *pRecoveryState = 0;
        Status = ERROR_SUCCESS;
    }

    return Status;
}





INIT_STANDALONE_DFS_ID_PROPERTY_INFO();
//+-------------------------------------------------------------------------
//
//  Function:   PackGetNameInformation - Unpacks the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to fill.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could unpack the name info
//               error status otherwise.
//
//
//  Description: This routine expects the binary stream to hold all the 
//               information that is necessary to return a complete name
//               info structure (as defined by MiDfsIdProperty). If the stream 
//               does not have the sufficient
//               info, ERROR_INVALID_DATA is returned back.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::PackGetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    //
    // Get the name information from the binary stream.
    //
    Status = PackGetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiStdDfsIdProperty );
    //
    // Immediately following the name value is a timeout value. 
    // This is not in the MiDfsIdProperty because it appers that some
    // of the older DFS may not have the timeout value.
    //
    if ( Status == ERROR_SUCCESS )
    {
        pDfsNameInfo->LastModifiedTime = pDfsNameInfo->PrefixTimeStamp;

        Status = PackGetULong(&pDfsNameInfo->Timeout,
                              ppBuffer,
                              pSizeRemaining);
        //
        // Use a default value if we cannot get the timeout value in
        // the stream.
        //
        if ( Status != ERROR_SUCCESS )
        {
            pDfsNameInfo->Timeout = 300;   // hard code this value.
            Status = ERROR_SUCCESS;
        }
    }

    if (Status == ERROR_SUCCESS)
    {
        if ((pDfsNameInfo->Type & 0x80) == 0x80)
        {
            pDfsNameInfo->State |= DFS_VOLUME_FLAVOR_STANDALONE;
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSetNameInformation - Packs the root/link name info
//
//  Arguments:  pDfsNameInfo - pointer to the info to pack.
//              ppBuffer - pointer to buffer that holds the binary stream.
//              pSizeRemaining - pointer to size of above buffer
//
//  Returns:    Status
//               ERROR_SUCCESS if we could pack the name info
//               error status otherwise.
//
//
//  Description: This routine takes the passedin name information and
//               stores it in the binary stream passed in.
//
//--------------------------------------------------------------------------
DFSSTATUS
DfsRegistryStore::PackSetNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo,
    IN OUT PVOID *ppBuffer,
    IN OUT PULONG pSizeRemaining)
{
    DFSSTATUS Status;

    pDfsNameInfo->State &= ~DFS_VOLUME_FLAVORS;

    pDfsNameInfo->PrefixTimeStamp = pDfsNameInfo->LastModifiedTime;
    pDfsNameInfo->StateTimeStamp = pDfsNameInfo->LastModifiedTime;
    pDfsNameInfo->CommentTimeStamp = pDfsNameInfo->LastModifiedTime;
    //
    // Store the DfsNameInfo in the stream first.
    //
    Status = PackSetInformation( (ULONG_PTR)pDfsNameInfo,
                                 ppBuffer,
                                 pSizeRemaining,
                                 &MiStdDfsIdProperty );

    //
    // Follow that info with the timeout information.
    //
    if ( Status == ERROR_SUCCESS )
    {
        Status = PackSetULong( pDfsNameInfo->Timeout,
                               ppBuffer,
                               pSizeRemaining);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   PackSizeNameInformation - Gets the size of the name info.
//
//  Arguments:  pDfsNameInfo - info to size.
//
//  Returns:    Status
//               ULONG - size needed
//
//  Description: This routine gets us the size of the binary stream
//               required to pack the passed in name info.
//
//--------------------------------------------------------------------------
ULONG
DfsRegistryStore::PackSizeNameInformation(
    IN PDFS_NAME_INFORMATION pDfsNameInfo )
{
    ULONG Size;

    Size = PackSizeInformation( (ULONG_PTR)pDfsNameInfo,
                                 &MiStdDfsIdProperty );

    Size += PackSizeULong();

    return Size;
}



//+-------------------------------------------------------------------------
//
//  Function:   AddChild - Add a child to the metadata.
//
//  Arguments:  
//    DfsMetadataHandle - the Metadata key for the root.
//    PUNICODE_STRING pLinkLogicalName - the logical name of the child
//    LPWSTR ReplicaServer - the first target server for this link.
//    LPWSTR ReplicaPath - the target path for this link
//    LPWSTR Comment  - the comment to be associated with this link.
//    LPWSTR pMetadataName - the metadata name for the child, returned..
//
//
//  Returns:    Status: 
//
//  Description: This routine adds a child to the Root metadata. It packs
//               the link name into the name information. If the replica
//               information exists, it packs that into the replica info.
//               It then saves the name and replica streams under the
//               Childkey.
//               NOTE: this function does not require that the link
//               have atleast one replica. Any such requirements
//               should be enforced by the caller.
//
//--------------------------------------------------------------------------

DFSSTATUS
DfsRegistryStore::AddChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PDFS_NAME_INFORMATION pNameInfo,
    IN PDFS_REPLICA_LIST_INFORMATION pReplicaListInfo,
    IN PUNICODE_STRING pMetadataName )
{
    DFSSTATUS Status;
    PVOID pNameBlob, pReplicaBlob;
    ULONG NameBlobSize, ReplicaBlobSize;

    Status = CreateNameInformationBlob( pNameInfo,
                                        &pNameBlob,
                                        &NameBlobSize );

    if (Status == ERROR_SUCCESS)
    {
        Status = CreateReplicaListInformationBlob( pReplicaListInfo,
                                                   &pReplicaBlob,
                                                   &ReplicaBlobSize );

        if (Status == ERROR_SUCCESS)
        {
            Status = CreateNewChild( DfsHandle,
                                     pNameBlob, 
                                     NameBlobSize,
                                     pReplicaBlob,
                                     ReplicaBlobSize,
                                     pMetadataName );

            ReleaseMetadataReplicaBlob( pReplicaBlob, ReplicaBlobSize );
        }
        ReleaseMetadataNameBlob( pNameBlob, NameBlobSize );
    }
    return Status;
}


DFSSTATUS
DfsRegistryStore::CreateNewChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    IN PVOID pNameBlob,
    IN ULONG NameBlobSize,
    IN PVOID pReplicaBlob,
    IN ULONG ReplicaBlobSize,
    IN PUNICODE_STRING pMetadataName )
{
    HKEY DfsMetadataKey;
    DFSSTATUS Status;
    HKEY ChildKey;
    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( DfsHandle );

    //
    // Now create the child with this name
    //      
    Status = RegCreateKeyEx( DfsMetadataKey,
                             pMetadataName->Buffer,
                             0,
                             L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE,
                             NULL,
                             &ChildKey,
                             NULL );

    //
    // Now set the name and replica information on this newly created
    // key.
    //
    if (Status == ERROR_SUCCESS) 
    {
        Status = SetMetadata( ChildKey,
                              NULL,
                              DfsRegistryNameString,
                              pNameBlob,
                              NameBlobSize );
        if (Status == ERROR_SUCCESS)
        {
            Status = SetMetadata( ChildKey,
                                  NULL,
                                  DfsRegistryReplicaString,
                                  pReplicaBlob,
                                  ReplicaBlobSize );
        }
        //
        // we are done with the child key: close it here.
        //
        RegCloseKey (ChildKey);

        //
        // if we were unsuccessful in adding the name and
        // replica details, get rid of the new child registry entry.
        //

        if (Status != ERROR_SUCCESS)
        {
            DFSSTATUS DeleteStatus;

            DeleteStatus = RegDeleteKey( DfsMetadataKey,
                                         pMetadataName->Buffer );

            DFSLOG("Created Key, but failed to add values %x. Delete Status %x\n",
                   Status, DeleteStatus );
        }
    }

    return Status;
}



DFSSTATUS
DfsRegistryStore::RemoveChild(
    IN DFS_METADATA_HANDLE DfsHandle,
    LPWSTR ChildName )

{
    DFSSTATUS Status;
    HKEY DfsMetadataKey;

    DfsMetadataKey = (HKEY)ExtractFromMetadataHandle( DfsHandle );

    Status = RegDeleteKey( DfsMetadataKey,
                           ChildName );

    return Status;
}



DFSSTATUS
DfsRegistryStore::CreateStandaloneRoot(
    LPWSTR MachineName,
    LPWSTR LogicalShare,
    LPWSTR Comment )
{
    DFSSTATUS Status = ERROR_SUCCESS;
    HKEY StdDfsKey = NULL;
    HKEY StdDfsShareKey = NULL;
    DfsRootFolder *pRootFolder = NULL;
    PVOID pBlob = NULL;
    ULONG BlobSize = 0;
    DFS_NAME_INFORMATION NameInfo;
    DFS_REPLICA_LIST_INFORMATION ReplicaListInfo;
    DFS_REPLICA_INFORMATION ReplicaInfo;
    UNICODE_STRING DfsMachine;
    UNICODE_STRING DfsShare;

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, create root %ws\n", LogicalShare);

    Status = DfsRtlInitUnicodeStringEx( &DfsMachine, MachineName );
    if(Status != ERROR_SUCCESS)
    {
        Status = ERROR_INVALID_PARAMETER;
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "CreateStandaloneRoot, DfsRtlInitUnicodeStringEx - create root %ws, status %x\n", LogicalShare, Status);
        return Status;
    }

    Status = DfsRtlInitUnicodeStringEx( &DfsShare, LogicalShare );
    if(Status != ERROR_SUCCESS)
    {
        Status = ERROR_INVALID_PARAMETER;
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "CreateStandaloneRoot, DfsRtlInitUnicodeStringEx - create root %ws, status %x\n", LogicalShare, Status);
        return Status;
    }

    RtlZeroMemory(&NameInfo, sizeof(DFS_NAME_INFORMATION));

    if (DfsIsSpecialDomainShare(&DfsShare)) 
    {
        Status = ERROR_INVALID_PARAMETER;
        DFS_TRACE_ERROR_LOW( Status, REFERRAL_SERVER, "registry store, Special Share - create root %ws, status %x\n", LogicalShare, Status);
        return Status;
    }


    Status = LookupRoot( &DfsMachine,
                         &DfsShare,
                         &pRootFolder );

    DFS_TRACE_LOW( REFERRAL_SERVER, "registry store, create root, lookup root %p, status %x\n", pRootFolder, Status);