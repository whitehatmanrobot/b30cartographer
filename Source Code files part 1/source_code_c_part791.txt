    rm  = BIT20(mrm);                   /* get rm */

    if (mod == 3) {                     /* register only mode */
        src = &regtab[rm * 2];          /* point to 16-bit register */
        if (EAsize[0] > 1) {
            src += 16;                  /* point to 16-bit register */
            if (opsize_32 && !fMovX)
                *(*ppchBuf)++ = 'e';    /* make it a 32-bit register */
            }
        *(*ppchBuf)++ = *src++;         /* copy register name */
        *(*ppchBuf)++ = *src;
        EAsize[0] = 0;                  //  no EA value to output
        return;
        }

    if (mode_32) {                      /* 32-bit addressing mode */
        oldrm = rm;
        if (rm == 4) {                  /* rm == 4 implies sib byte */
            sib = *pMem++;              /* get s_i_b byte */
            rm = BIT20(sib);            /* return base */
            }

        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 5) {
            OutputSymbol(hProcess,ppchBuf, pMem, 4, segOvr); // offset
            pMem += 4;
            }
        else {
            if (fEAout) {
                if (segOvr) {
                    EAaddr[0] = (ULONG)GetRegValue(reg32[rm]);
                    pchEAseg[0] = distbl[segOvr].instruct;
                    }
                else if (reg32[rm] == REGEBP || reg32[rm] == REGESP) {
                    EAaddr[0] = (ULONG)GetRegValue(reg32[rm]);
                    pchEAseg[0] = dszSS_;
                    }
                else
                    EAaddr[0] = (ULONG)GetRegValue(reg32[rm]);
                }
            OutputString(ppchBuf, mrmtb32[rm]);
            }

        if (oldrm == 4) {               //  finish processing sib
            ind = BIT53(sib);
            if (ind != 4) {
                *(*ppchBuf)++ = '+';
                OutputString(ppchBuf, mrmtb32[ind]);
                ss = 1 << BIT76(sib);
                if (ss != 1) {
                    *(*ppchBuf)++ = '*';
                    *(*ppchBuf)++ = (char)(ss + '0');
                    }
                if (fEAout)
                    EAaddr[0] = (ULONG)GetRegValue(reg32[ind]);
                }
            }
        }
    else {                              //  16-bit addressing mode
        *(*ppchBuf)++ = '[';
        if (mod == 0 && rm == 6) {
            OutputSymbol(hProcess,ppchBuf, pMem, 2, segOvr);   // 16-bit offset
            pMem += 2;
            }
        else {
            if (fEAout) {
                if (segOvr) {
                    EAaddr[0] = (ULONG)GetRegValue(reg16[rm]);
                    pchEAseg[0] = distbl[segOvr].instruct;
                    }
                else if (reg16[rm] == REGEBP) {
                    EAaddr[0] = (ULONG)GetRegValue(reg16[rm]);
                    pchEAseg[0] = dszSS_;
                    }
                else
                    EAaddr[0] = (ULONG)GetRegValue(reg16[rm]);
                if (rm < 4)
                    EAaddr[0] += (ULONG)GetRegValue(reg16_2[rm]);
            }
            OutputString(ppchBuf, mrmtb16[rm]);
            }
        }

    //  output any displacement

    if (mod == 1) {
        if (fEAout)
            EAaddr[0] += (ULONG)pMem;
        OutputHexValue(ppchBuf, pMem, 1, TRUE);
        pMem++;
        }
    else if (mod == 2) {
        long tmp = 0;
        if (mode_32) {
            memmove(&tmp,pMem,sizeof(long));
            if (fEAout)
                EAaddr[0] += (ULONG)tmp;
            OutputHexValue(ppchBuf, pMem, 4, TRUE);
            pMem += 4;
            }
        else {
            memmove(&tmp,pMem,sizeof(short));
            if (fEAout)
                EAaddr[0] += tmp;
            OutputHexValue(ppchBuf, pMem, 2, TRUE);
            pMem += 2;
            }
        }

    if (!mode_32 && fEAout) {
        EAaddr[0] &= 0xffff;
        EAaddr[1] &= 0xffff;
    }

    *(*ppchBuf)++ = ']';
}

/*** OutputHexValue - output hex value
*
*   Purpose:
*       Output the value pointed by *ppchBuf of the specified
*       length.  The value is treated as signed and leading
*       zeroes are not printed.  The string is prefaced by a
*       '+' or '-' sign as appropriate.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value (1, 2, and 4 supported)
*       fDisp - set if displacement to output '+'
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void OutputHexValue (char **ppchBuf, char *pchMemBuf, int length, int fDisp)
{
    long    value;
    int     index;
    char    digit[8];

    value = 0;
    if (length == 1)
        value = (long)(*(char *)pchMemBuf);
    else if (length == 2)
        memmove(&value,pchMemBuf,2);
    else
        memmove(&value,pchMemBuf,sizeof(long));

    length <<= 1;               //  shift once to get hex length

    if (value != 0 || !fDisp) {
        if (fDisp)
            if (value < 0 && length == 2) {   //  use neg value for byte
                value = -value;               //    displacement
                *(*ppchBuf)++ = '-';
                }
            else
                *(*ppchBuf)++ = '+';

        *(*ppchBuf)++ = '0';
        *(*ppchBuf)++ = 'x';
        for (index = length - 1; index != -1; index--) {
            digit[index] = (char)(value & 0xf);
            value >>= 4;
            }
        index = 0;
        while (digit[index] == 0 && index < length - 1)
            index++;
        while (index < length)
            *(*ppchBuf)++ = hexdigit[digit[index++]];
        }
}

/*** OutputHexString - output hex string
*
*   Purpose:
*       Output the value pointed by *ppchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       *pchValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*       *ppchMemBuf - pointer update to next memory byte
*
*************************************************************************/

void
OutputHexString (char **ppchBuf, char *pchValue, int length)
{
    unsigned char    chMem;

    pchValue += length;
    while (length--) {
        chMem = *--pchValue;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
        }
}

/*** OutputHexCode - output hex code
*
*   Purpose:
*       Output the code pointed by pchMemBuf of the specified
*       length.  The value is treated as unsigned and leading
*       zeroes are printed.  This differs from OutputHexString
*       in that bytes are printed from low to high addresses.
*
*   Input:
*       *ppchBuf - pointer to text buffer to fill
*       pchMemBuf - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppchBuf - pointer updated to next text character
*
*************************************************************************/

void
OutputHexCode (char **ppchBuf, char *pchMemBuf, int length)
{
    unsigned char    chMem;

    while (length--) {
        chMem = *pchMemBuf++;
        *(*ppchBuf)++ = hexdigit[chMem >> 4];
        *(*ppchBuf)++ = hexdigit[chMem & 0x0f];
        }
}

/*** OutputString - output string
*
*   Purpose:
*       Copy the string into the buffer pointed by *ppBuf.
*
*   Input:
*       *pStr - pointer to string
*
*   Output:
*       *ppBuf points to next character in buffer.
*
*************************************************************************/

void
OutputString (char **ppBuf, char *pStr)
{
    while (*pStr)
        *(*ppBuf)++ = *pStr++;
}

/*** OutputSymbol - output symbolic value
*
*   Purpose:
*       Output the value in outvalue into the buffer
*       pointed by *pBuf.  Express the value as a
*       symbol plus displacment, if possible.
*
*   Input:
*       *ppBuf - pointer to text buffer to fill
*       *pValue - pointer to memory buffer to extract value
*       length - length in bytes of value
*
*   Output:
*       *ppBuf - pointer updated to next text character
*
*************************************************************************/

void
OutputSymbol (HANDLE hProcess, char **ppBuf, char *pValue, int length, int segOvr)
{
    ULONG               displacement;
    ULONG               value;
    char                *szSymName;

    value = 0;
    if (length == 1)
        value = (long)(*(char *)pValue);
    else if (length == 2)
        memmove(&value,pValue,sizeof(short));
    else
        memmove(&value,pValue,sizeof(long));

    EAaddr[0] = value;

    if (SymGetSymFromAddr( hProcess, value, &displacement, sym )) {
        OutputString(ppBuf, sym->Name);
        OutputHexValue(ppBuf, (char *)&displacement, length, TRUE);
        *(*ppBuf)++ = ' ';
        *(*ppBuf)++ = '(';
        OutputHexString(ppBuf, pValue, length);
        *(*ppBuf)++ = ')';
        }
    else
        OutputHexString(ppBuf, pValue, length);
}

/*** X86GetNextOffset - compute offset for trace or step
*
*   Purpose:
*       From a limited disassembly of the instruction pointed
*       by the FIR register, compute the offset of the next
*       instruction for either a trace or step operation.
*
*   Input:
*       fStep - TRUE if step offset returned - FALSE for trace offset
*
*   Returns:
*       step or trace offset if input is TRUE or FALSE, respectively
*       -1 returned for trace flag to be used
*
*************************************************************************/

ULONG
GetNextOffset(
    HANDLE  hProcess,
    ULONG   Address,
    BOOL    fStep
    )
{
    int     L_mode_32;
    int     L_opsize_32;
    int     cBytes = 0;
    char    membuf[MAXL];               //  current instruction buffer
    ULONG   addrReturn;
    USHORT  retAddr[3];                 //  return address buffer
    char    *L_pMem;
    UCHAR   opcode;
    int     fPrefix = TRUE;
    int     fRepPrefix = FALSE;
    int     L_ttt;
    int     L_rm;
    ULONG   instroffset;
    ULONG   pcaddr;
    int     subcode;

    //  read instruction stream bytes into membuf and set mode and
    //      opcode size flags

    if (Address) {
        pcaddr = Address;
    } else {
        pcaddr = (ULONG)GetRegValue(REGEIP);
    }
    instroffset = pcaddr;
    G_mode_32 = TRUE;
    L_mode_32 = L_opsize_32 = (G_mode_32 == 1); /* local addressing mode */

    cBytes = ReadMemory( hProcess, (PVOID) pcaddr, membuf, MAXL );
    if (!cBytes) {
        return (ULONG)-1;
    }

                                        /* move full inst to local buffer */
    L_pMem = membuf;                    /* point to begin of instruction */

    //  read and process any prefixes first

    do {
        opcode = (UCHAR)*L_pMem++;        /* get opcode */
        if (opcode == 0x66)
            L_opsize_32 = !G_mode_32;
        else if (opcode == 0x67)
            L_mode_32 = !G_mode_32;
        else if ((opcode & ~1) == 0xf2)
            fRepPrefix = TRUE;
        else if (opcode != 0xf0 && (opcode & ~0x18) != 0x26
                                && (opcode & ~1) != 0x64)
            fPrefix = FALSE;
        }
    while (fPrefix);

    //  for instructions that alter the TF (trace flag), return the
    //      offset of the next instruction despite the flag of fStep

    if (((opcode & ~0x3) == 0x9c))
        //  9c-9f, pushf, popf, sahf, lahf
        ;

    else if (opcode == 0xcf) {          //  cf - iret - get RA from stack

        addrReturn = (ULONG)GetRegValue(REGESP);
        if (!ReadMemory( hProcess, (PVOID) addrReturn, retAddr, sizeof(retAddr) )) {
            return (ULONG)-1;
        }
        return retAddr[2];
    }
    else if (opcode == 0xc4 && *L_pMem == 0xc4 ) {
            subcode = *(L_pMem+1);
            if ( subcode == 0x50 ||
                 subcode == 0x52 ||
                 subcode == 0x53 ||
                 subcode == 0x54 ||
                 subcode == 0x57 ||
                 subcode == 0x58 ||
                 subcode == 0x5D ) {
                L_pMem += 3;
            } else {
                L_pMem += 2;
            }
    }
    else if (!fStep) {
        instroffset = (ULONG)-1;
    }

    //  repeated string/port instructions

    if (opcode == 0xe8)            //  near direct jump
        L_pMem += (1 + L_opsize_32) * 2;

    else if (opcode == 0x9a)            //  far direct jump
        L_pMem += (2 + L_opsize_32) * 2;

    else if (opcode == 0xcd ||
             (opcode >= 0xe0 && opcode <= 0xe2)) //  loop / int nn instrs
        L_pMem++;

    else if (opcode == 0xff) {          //  indirect call - compute length
        opcode = *L_pMem++;               //  get modRM
        L_ttt = BIT53(opcode);
        if ((L_ttt & ~1) == 2) {
            mod = BIT76(opcode);
            if (mod != 3) {                     //  nonregister operand
                L_rm = BIT20(opcode);
                if (L_mode_32) {
                    if (L_rm == 4)
                        L_rm = BIT20(*L_pMem++);    //  get base from SIB
                    if (mod == 0) {
                        if (L_rm == 5)
                            L_pMem += 4;          //  long direct address
                        }                       //  else register
                    else if (mod == 1)
                        L_pMem++;                 //  register with byte offset
                    else
                        L_pMem += 4;              //  register with long offset
                    }
                else {                          //  16-bit mode
                    if (mod == 0) {
                        if (L_rm == 6)
                            L_pMem += 2;          //  short direct address
                        }
                    else
                        L_pMem += mod;            //  reg, byte, word offset
                    }
                }
            }
        else
            instroffset = (ULONG)-1;            //  0xff, but not call
        }

    else if (!((fRepPrefix && ((opcode & ~3) == 0x6c ||
                               (opcode & ~3) == 0xa4 ||
                               (opcode & ~1) == 0xaa ||
                               (opcode & ~3) == 0xac)) ||
                               opcode == 0xcc || opcode == 0xce))
        instroffset = (ULONG)-1;                //  not repeated string op
                                                //  or int 3 / into

    //  if not enough bytes were read for instruction parse,
    //      just give up and trace the instruction

    if (cBytes < L_pMem - membuf) {
        instroffset = (ULONG)-1;
    }

    //  if not tracing, compute the new instruction offset

    if (instroffset != (ULONG)-1) {
        instroffset += L_pMem - membuf;
    }

    return instroffset;
}

void
OutputHexAddr (LPSTR *ppBuffer, ULONG offset)
{
    OutputHexString(ppBuffer, (char *)&offset, sizeof(ULONG));
}

USHORT
GetSegRegValue (int segOpcode)
{
    ULONG    regnum;

    switch (segOpcode) {
        case 0x26:
            regnum = REGES;
            break;
        case 0x2e:
            regnum = REGCS;
            break;
        case 0x36:
            regnum = REGSS;
            break;
        case 0x64:
            regnum = REGFS;
            break;
        case 0x65:
            regnum = REGGS;
            break;
        case 0x3e:
        default:
            regnum = REGDS;
        }

    return (USHORT)GetRegValue(regnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\ui.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ui.cpp

Abstract:

    All user interface code for APIMON.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "apimonwn.h"
#include <shellapi.h>



#define NUMIMAGES                   13

#define IMAGEWIDTH                  30
#define IMAGEHEIGHT                 28

#define BUTTONWIDTH                 30
#define BUTTONHEIGHT                28

#define SEPHEIGHT                   7
#define HELP_FILE_NAME              "apimon.hlp"
#define MAX_API_WINDOWS             4



DllListWindow               dw;
CountersWindow              cw;
PageFaultWindow             pw;
GraphWindow                 gw;
TraceWindow                 tw;

HINSTANCE                   hInst;
HWND                        hwndFrame;
HWND                        hwndMDIClient;
HWND                        hwndToolbar;
HWND                        hwndStatusbar;
DWORD                       ToolbarHeight;
DWORD                       StatusbarHeight;
UINT_PTR                    ApiMonTimerId;
BOOL                        MonitorRunning;
BOOL                        DebuggeStarted;
DWORD                       BaseTime;
HANDLE                      BreakinEvent;
DWORD                       EndingTick;
DWORD                       StartingTick;
SYSTEMTIME                  StartingLocalTime;
BOOL                        ApiCounterEnabled = TRUE;
CHAR                        ToolTipBuf[256];
HMENU                       hmenuFrame;
HFONT                       hFont;
DWORD                       ChildFocus;
BOOL                        InMenu;
DWORD                       MenuId;
CHAR                        HelpFileName[MAX_PATH];
CHAR                        LogFileName[MAX_PATH];
CHAR                        TraceFileName[MAX_PATH];

TBBUTTON TbButton[] =
    {
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  0, IDM_FILEOPEN,         TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  4, IDM_WRITE_LOG,        TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  7, IDM_START,            TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  8, IDM_STOP,             TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  5, IDM_REFRESH,          TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  9, IDM_CLEAR_COUNTERS,   TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        { 12, IDM_VIEW_TRACE,       TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  2, IDM_FONT,             TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  3, IDM_COLOR,            TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        {  1, IDM_GRAPH,            TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  6, IDM_LEGEND,           TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        { 11, IDM_OPTIONS,          TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 },
        {  0, 0,                    TBSTATE_ENABLED,        TBSTYLE_SEP,    0, 0 },
        { 10, IDM_HELP,             TBSTATE_ENABLED,        TBSTYLE_BUTTON, 0, 0 }

    };

TOOLBAR_STATE ToolbarState[] =
    {
        {  IDM_FILEOPEN,        TRUE,   "A program cannot be opened while another is being monitored" },
        {  IDM_WRITE_LOG,       FALSE,  "The log file cannot be written until the application is started"  },
        {  IDM_START,           FALSE,  "An application cannot be started until one is opened"  },
        {  IDM_STOP,            FALSE,  "The application cannot be stopped until it is started"  },
        {  IDM_REFRESH,         FALSE,  "Counters cannot be refreshed until the application is started"  },
        {  IDM_CLEAR_COUNTERS,  FALSE,  "Counters cannot be cleared until the application is started"  },
        {  IDM_VIEW_TRACE,      FALSE,  "API trace cannot be viewed until the application is started"  },
        {  IDM_FONT,            TRUE,   NULL },
        {  IDM_COLOR,           TRUE,   NULL },
        {  IDM_GRAPH,           FALSE,  "A graph cannot be created with zero counters" },
        {  IDM_LEGEND,          FALSE,  "Graph legends cannot be changed" },
        {  IDM_OPTIONS,         FALSE,  "Options cannot be changed until an application is opened"  },
        {  IDM_HELP,            TRUE,   NULL }
    };

#define MAX_TOOLBAR_STATES (sizeof(ToolbarState)/sizeof(TOOLBAR_STATE))

UINT idPopup[] =
    {
        IDS_MDISYSMENU,     // Maximized MDI child system menu
        IDS_FILEMENU,
        IDS_WINDOWMENU,
        IDS_HELPMENU,
    };

COLORREF CustomColors[] =
    {
        UBLACK,
        DARK_RED,
        DARK_GREEN,
        DARK_YELLOW,
        DARK_BLUE,
        DARK_MAGENTA,
        DARK_CYAN,
        DARK_GRAY,
        LIGHT_GRAY,
        LIGHT_RED,
        LIGHT_GREEN,
        LIGHT_YELLOW,
        LIGHT_BLUE,
        LIGHT_MAGENTA,
        LIGHT_CYAN,
        UWHITE
    };



VOID
FitRectToScreen(
    PRECT prc
    )
{
    INT cxScreen;
    INT cyScreen;
    INT delta;

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    if (prc->right > cxScreen) {
        delta = prc->right - prc->left;
        prc->right = cxScreen;
        prc->left = prc->right - delta;
    }

    if (prc->left < 0) {
        delta = prc->right - prc->left;
        prc->left = 0;
        prc->right = prc->left + delta;
    }

    if (prc->bottom > cyScreen) {
        delta = prc->bottom - prc->top;
        prc->bottom = cyScreen;
        prc->top = prc->bottom - delta;
    }

    if (prc->top < 0) {
        delta = prc->bottom - prc->top;
        prc->top = 0;
        prc->bottom = prc->top + delta;
    }
}

VOID
CenterWindow(
    HWND hwnd,
    HWND hwndToCenterOver
    )
{
    RECT rc;
    RECT rcOwner;
    RECT rcCenter;
    HWND hwndOwner;

    GetWindowRect( hwnd, &rc );

    if (hwndToCenterOver) {
        hwndOwner = hwndToCenterOver;
        GetClientRect( hwndOwner, &rcOwner );
    } else {
        hwndOwner = GetWindow( hwnd, GW_OWNER );
        if (!hwndOwner) {
            hwndOwner = GetDesktopWindow();
        }
        GetWindowRect( hwndOwner, &rcOwner );
    }

    //
    //  Calculate the starting x,y for the new
    //  window so that it would be centered.
    //
    rcCenter.left = rcOwner.left +
            (((rcOwner.right - rcOwner.left) -
            (rc.right - rc.left))
            / 2);

    rcCenter.top = rcOwner.top +
            (((rcOwner.bottom - rcOwner.top) -
            (rc.bottom - rc.top))
            / 2);

    rcCenter.right = rcCenter.left + (rc.right - rc.left);
    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top);

    FitRectToScreen( &rcCenter );

    SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0,
            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
}

VOID
ApiMonTimer(
    HWND  hwnd,
    UINT  msg,
    UINT_PTR  evtid,
    DWORD currtime
    )
{
    cw.Update( FALSE );
    dw.Update( FALSE );
    pw.Update( FALSE );
    gw.Update( FALSE );
    tw.Update( FALSE );
}

DWORD
CreateChildWindows(
    DWORD ChildType
    )
{
    DWORD ChildFocusSave = 0;
    POSITION PosSave = {0};


    if ((ApiMonOptions.CounterPosition.Flags & IS_ZOOMED) ||
        (ApiMonOptions.DllPosition.Flags     & IS_ZOOMED)) {
            //
            // set the flags
            //
            ApiMonOptions.CounterPosition.Flags |= IS_ZOOMED;
            ApiMonOptions.DllPosition.Flags     |= IS_ZOOMED;
            ApiMonOptions.PagePosition.Flags    |= IS_ZOOMED;
    }

    switch( ChildType ) {
        case CHILD_COUNTER:
            if (ApiMonOptions.CounterPosition.Flags & IS_FOCUS) {
                ChildFocusSave = CHILD_COUNTER;
            }
            PosSave = ApiMonOptions.CounterPosition;
            cw.Create();
            cw.ChangePosition( &PosSave );
            cw.ChangeFont( hFont );
            cw.ChangeColor( ApiMonOptions.Color );
            break;

        case CHILD_DLL:
            if (ApiMonOptions.DllPosition.Flags & IS_FOCUS) {
                ChildFocusSave = CHILD_DLL;
            }
            PosSave = ApiMonOptions.DllPosition;
            dw.Create();
            dw.ChangePosition( &PosSave );
            dw.ChangeFont( hFont );
            dw.ChangeColor( ApiMonOptions.Color );
            break;

        case CHILD_PAGE:
            if (ApiMonOptions.PagePosition.Flags & IS_FOCUS) {
                ChildFocusSave = CHILD_PAGE;
            }
            PosSave = ApiMonOptions.PagePosition;
            pw.Create();
            pw.ChangePosition( &PosSave );
            pw.ChangeFont( hFont );
            pw.ChangeColor( ApiMonOptions.Color );
            break;
    }

    return ChildFocusSave;
}

VOID __inline
UpdateStatusBar(
    LPSTR lpszStatusString,
    WORD  partNumber,
    WORD  displayFlags
    )
{
    SendMessage(
        hwndStatusbar,
        SB_SETTEXT,
        partNumber | displayFlags,
        (LPARAM)lpszStatusString
        );
}

VOID
SetMenuState(
    DWORD id,
    DWORD st
    )
{
    EnableMenuItem( hmenuFrame, id, st );
}

PTOOLBAR_STATE __inline
GetToolbarState(
    DWORD Id
    )
{
    for (int i=0; i<MAX_TOOLBAR_STATES; i++) {
        if (ToolbarState[i].Id == Id) {
            return &ToolbarState[i];
        }
    }
    return NULL;
}

VOID
EnableToolbarState(
    DWORD Id
    )
{
    PTOOLBAR_STATE tb = GetToolbarState( Id );
    if (tb) {
        tb->State = TRUE;
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, Id, MAKELONG(1,0) );
        EnableMenuItem( hmenuFrame, Id, MF_ENABLED );
    }
}

VOID
DisableToolbarState(
    DWORD Id
    )
{
    PTOOLBAR_STATE tb = GetToolbarState( Id );
    if (tb) {
        tb->State = FALSE;
        EnableMenuItem( hmenuFrame, Id, MF_GRAYED );
    }
}

VOID
ReallyDisableToolbarState(
    DWORD Id
    )
{
    PTOOLBAR_STATE tb = GetToolbarState( Id );
    if (tb) {
        tb->State = FALSE;
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, Id, 0 );
        EnableMenuItem( hmenuFrame, Id, MF_GRAYED );
    }
}


VOID
StatusBarTimer(
    HWND  hwnd,
    UINT  msg,
    UINT_PTR  evtid,
    DWORD currtime
    )
{
    char        szBuf[16];
    SYSTEMTIME  sysTime;

    GetLocalTime( &sysTime );
    wsprintf(
        szBuf,
        "%2d:%02d:%02d %s",
        (sysTime.wHour == 0 ? 12 :
        (sysTime.wHour <= 12 ? sysTime.wHour : sysTime.wHour -12)),
        sysTime.wMinute,
        sysTime.wSecond,
        (sysTime.wHour < 12 ? "AM":"PM")
        );

    UpdateStatusBar( szBuf, 2, 0 );
}

VOID
InitializeStatusBar(
    HWND hwnd
    )
{
    const cSpaceInBetween = 8;
    RECT rect;
    SIZE size;
    HDC hDC = GetDC( hwnd );
    GetClientRect( hwnd, &rect );
    int ptArray[3];
    ptArray[0] = 0;
    ptArray[1] = 0;
    ptArray[2] = rect.right;
    if (hDC) {
        if (GetTextExtentPoint( hDC, "00:00:00 PM", 12, &size )) {
            ptArray[1] = ptArray[2] - (size.cx) - cSpaceInBetween;
        }
        if (GetTextExtentPoint(hDC, "Time:", 6, &size)) {
            ptArray[0] = ptArray[1] - (size.cx) - cSpaceInBetween;
        }
        ReleaseDC( hwnd, hDC );
    }
    SendMessage(
        hwndStatusbar,
        SB_SETPARTS,
        sizeof(ptArray)/sizeof(ptArray[0]),
        (LPARAM)(LPINT)ptArray
        );
    UpdateStatusBar( "API Monitor", 0, 0 );
    UpdateStatusBar( "Time:", 1, SBT_POPOUT );
}

VOID
SaveWindowPos(
    HWND        hwnd,
    PPOSITION   Pos,
    BOOL        ChildWindow
    )
{
    GetWindowRect( hwnd, &Pos->Rect );

    if (ChildWindow) {
        ScreenToClient( hwndMDIClient, (LPPOINT)&Pos->Rect.left  );
        ScreenToClient( hwndMDIClient, (LPPOINT)&Pos->Rect.right );
    }

    Pos->Flags = 0;
    if (IsIconic( hwnd )) {
        Pos->Flags |= IS_ICONIC;
    } else if (IsZoomed( hwnd )) {
        Pos->Flags |= IS_ZOOMED;
    }
}

VOID
SetWindowPosition(
    HWND        hwnd,
    PPOSITION   Pos
    )
{
    if (Pos->Flags & IS_ICONIC) {
        ShowWindow( hwnd, SW_MINIMIZE );
        return;
    }

    if (Pos->Flags & IS_ZOOMED) {
        ShowWindow( hwnd, SW_MAXIMIZE );
        return;
    }

    if (Pos->Rect.top    == 0 && Pos->Rect.left  == 0 &&
        Pos->Rect.bottom == 0 && Pos->Rect.right == 0) {
            return;
    }

    MoveWindow(
        hwnd,
        Pos->Rect.left,
        Pos->Rect.top,
        Pos->Rect.right  - Pos->Rect.left,
        Pos->Rect.bottom - Pos->Rect.top,
        TRUE
        );
}

VOID
InitializeFrameWindow(
    HWND hwnd
    )
{
    RECT rect;
    hwndToolbar = CreateToolbarEx(
        hwnd,
        WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS,
        IDM_TOOLBAR,
        NUMIMAGES,
        hInst,
        IDB_TOOLBAR,
        TbButton,
        sizeof(TbButton)/sizeof(TBBUTTON),
        BUTTONWIDTH,
        BUTTONHEIGHT,
        IMAGEWIDTH,
        IMAGEHEIGHT,
        sizeof(TBBUTTON)
        );
    SendMessage( hwndToolbar, TB_AUTOSIZE, 0, 0 );
    GetWindowRect( hwndToolbar, &rect );
    ToolbarHeight = rect.bottom - rect.top;
    hwndStatusbar = CreateStatusWindow(
        WS_CHILD | WS_VISIBLE | WS_BORDER,
        "API Monitor",
        hwnd,
        IDM_STATUSBAR
        );
    GetWindowRect( hwndStatusbar, &rect );
    StatusbarHeight = rect.bottom - rect.top;
    InitializeStatusBar( hwnd );
    SetTimer( hwnd, 1, 1000, StatusBarTimer );

    CLIENTCREATESTRUCT ccs = {0};
    ccs.hWindowMenu  = GetSubMenu( GetMenu(hwnd), WINDOWMENU );
    ccs.idFirstChild = IDM_WINDOWCHILD;
    hwndMDIClient = CreateWindow(
        "MDICLIENT",
        NULL,
        WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL,
        0,0,0,0,
        hwnd,
        (HMENU)0xCAC,
        hInst,
        (LPVOID)&ccs
        );
    ShowWindow( hwndMDIClient, SW_SHOWNORMAL );
    BreakinEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    ApiCounterEnabled = TRUE;
}

LRESULT
MenuUpdateStatusBar(
    HWND    hwnd,
    UINT    uMessage,
    WPARAM  wparam,
    LPARAM  lparam
    )
{
    static char szBuffer[128];
    char   szTitle[32];
    LPSTR  lpTitle;
    UINT   nStringID = 0;
    UINT   fuFlags = GET_WM_MENUSELECT_FLAGS(wparam, lparam) & 0xffff;
    UINT   uCmd    = GET_WM_MENUSELECT_CMD(wparam, lparam);
    HMENU  hMenu   = GET_WM_MENUSELECT_HMENU(wparam, lparam);


    szBuffer[0] = 0;

    if (fuFlags == 0xffff && hMenu == NULL) {
        //
        // Menu has been closed
        //
        nStringID = IDS_DESCRIPTION;

    } else if (fuFlags & MFT_SEPARATOR) {
        //
        // Ignore separators
        //
        nStringID = 0;

    } else if (fuFlags & MF_POPUP) {
        //
        // Popup menu
        //
        if (fuFlags & MF_SYSMENU) {
            //
            // System menu
            //
            nStringID = IDS_SYSMENU;
        } else {
            //
            // If there is a maximized MDI child window,
            // its system menu will be added to the main
            // window's menu bar.  Since the string ID for
            // the MDI child's sysmenu is already in the
            // idPopup array, all we need to do is patch up
            // the popup menu index (uCmd) when the child's
            // system menu is NOT present.
            //

            HWND hwndChild = (HWND)SendMessage( hwndMDIClient, WM_MDIGETACTIVE, 0, 0 );

            if (!hwndChild || !IsZoomed(hwndChild)) {
                //
                // No MDI child sysmenu
                //
                uCmd++;
            }
            //
            // Get string ID for popup menu from idPopup array.
            //
            nStringID = ((uCmd < sizeof(idPopup)/sizeof(idPopup[0])) ? idPopup[uCmd] : 0);
        }
    } else {
        //
        // Must be a command item
        //
        // The Window menu has a dynamic part at the bottom
        // where the MDI Client window adds entries for each
        // child window that is open.  By getting the menu
        // item string we can customize the status bar string
        // with the name of the document.
        //

        if (uCmd >= IDM_WINDOWCHILD && uCmd < IDS_HELPMENU) {
            LoadString( hInst, IDM_WINDOWCHILD, szBuffer, sizeof(szBuffer) );
            GetMenuString(
                hMenu,
                uCmd,
                szTitle,
                sizeof(szTitle),
                MF_BYCOMMAND
                );

            lpTitle = szTitle;

            while (*lpTitle && *lpTitle != ' ') {
                lpTitle++;
            }

            lstrcat( szBuffer, lpTitle );

            nStringID = 0;
        } else {
            //
            // String ID == Command ID
            //
            nStringID = uCmd;
        }
    }

    //
    // Load the string if we have an ID
    //
    if (nStringID) {
        LoadString( hInst, nStringID, szBuffer, sizeof(szBuffer) );
    }

    //
    // Finally... send the string to the status bar
    //
    UpdateStatusBar( szBuffer, 0, 0 );

    return 0;
}

BOOL
InitializeProgram(
    LPSTR ProgName,
    LPSTR Arguments
    )
{
    CHAR    FullProgName[MAX_PATH*2];
    CHAR    Drive[MAX_PATH];
    CHAR    Dir[_MAX_DIR];
    CHAR    Fname[_MAX_FNAME];
    CHAR    Ext[_MAX_EXT];
    LPSTR   p;
    DWORD   ChildFocusSave = 0;
    DWORD   rval;


    if (!SearchPath( NULL, ProgName, ".exe", sizeof(FullProgName), FullProgName, &p )) {
        ApiMonOptions.ProgDir[0] = 0;
        ApiMonOptions.ProgName[0] = 0;
        PopUpMsg( "The program could not be located:\n\n%s", ProgName );
        return FALSE;
    }

    _splitpath( FullProgName, Drive, Dir, Fname, Ext );

    strcpy( ApiMonOptions.ProgName, Fname );
    strcat( ApiMonOptions.ProgName, Ext );

    RegInitialize( &ApiMonOptions );

    if (!ApiMonOptions.ProgDir[0]) {
        strcpy( ApiMonOptions.ProgDir,  Drive );
        strcat( ApiMonOptions.ProgDir,  Dir );
    } else {
        strcat( Drive, Dir );
        if (_stricmp( Drive, ApiMonOptions.ProgDir ) != 0) {
            strcpy( ApiMonOptions.ProgDir, Drive );
        }
    }

    if (ApiMonOptions.LogFont.lfFaceName[0]) {
        hFont = CreateFontIndirect( &ApiMonOptions.LogFont );
    }

    *ApiTraceEnabled = ApiMonOptions.Tracing || (KnownApis[0] != 0);

    if (Arguments) {
        strcpy( ApiMonOptions.Arguments, Arguments );
    }

    if (!ApiMonOptions.LastDir[0]) {
        strcpy( ApiMonOptions.LastDir, ApiMonOptions.ProgDir );
    }

    if (ApiMonOptions.FastCounters) {
        *FastCounterAvail = FALSE;
    } else {
        SYSTEM_INFO SystemInfo;
        GetSystemInfo( &SystemInfo );
        *FastCounterAvail = (SystemInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM &&
                             SystemInfo.dwNumberOfProcessors == 1);
    }

    EnableToolbarState( IDM_START );
    EnableToolbarState( IDM_OPTIONS );
    SetMenuState( IDM_SAVE_OPTIONS, MF_ENABLED );

    sprintf( FullProgName, "ApiMon <%s>", ProgName );
    SetWindowText( hwndFrame, FullProgName );

    SetWindowPosition( hwndFrame, &ApiMonOptions.FramePosition );

    rval = CreateChildWindows( CHILD_DLL );
    if (rval) {
        ChildFocusSave = rval;
    }
    rval = CreateChildWindows( CHILD_COUNTER );
    if (rval) {
        ChildFocusSave = rval;
    }
    rval = CreateChildWindows( CHILD_PAGE );
    if (rval) {
        ChildFocusSave = rval;
    }

    switch (ChildFocusSave) {
        case CHILD_COUNTER:
            cw.SetFocus();
            break;

        case CHILD_DLL:
            dw.SetFocus();
            break;

        case CHILD_PAGE:
            pw.SetFocus();
            break;
    }

    if (ApiMonOptions.GoImmediate) {
        PostMessage( hwndFrame, WM_COMMAND, IDM_START, 0 );
    }

    return TRUE;
}

LRESULT CALLBACK
WndProc(
    HWND   hwnd,
    UINT   uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    ULONG           i;
    LPSTR           CmdLine;
    DWORD           ThreadId;
    HANDLE          hThread;
    HANDLE          Handles[2];
    DWORD           WaitObj;
    PTOOLBAR_STATE  ToolbarState;



    switch (uMessage) {
        case WM_CREATE:
            hmenuFrame = GetMenu( hwnd );
            InitializeFrameWindow( hwnd );
            CenterWindow( hwnd, NULL );
            return 0;

        case WM_MOVE:
            SaveWindowPos( hwnd, &ApiMonOptions.FramePosition, FALSE );
            return 0;

        case WM_SIZE:
            SaveWindowPos( hwnd, &ApiMonOptions.FramePosition, FALSE );
            SendMessage( hwndToolbar,   uMessage, wParam, lParam );
            SendMessage( hwndStatusbar, uMessage, wParam, lParam );
            InitializeStatusBar( hwnd );
            if (wParam != SIZE_MINIMIZED) {
                RECT rc;
                GetClientRect( hwnd, &rc );
                rc.top += (ToolbarHeight + SEPHEIGHT);
                rc.bottom -= StatusbarHeight;
                MoveWindow(
                    hwndMDIClient,
                    rc.left,
                    rc.top,
                    rc.right-rc.left,
                    rc.bottom-rc.top,
                    TRUE
                    );
            }
            if (wParam == SIZE_MINIMIZED) {
                KillTimer( hwnd, ApiMonTimerId );
                ApiMonTimerId = 0;
            } else if ((!ApiMonTimerId) && (DebuggeStarted) && (ApiMonOptions.AutoRefresh)) {
                ApiMonTimerId = SetTimer( hwnd, 2, UiRefreshRate, ApiMonTimer );
            }
            return 0;

        case WM_INIT_PROGRAM:
            InitializeProgram( (LPSTR)wParam, (LPSTR)lParam );
            return 0;

        case WM_SETFOCUS:
            RegisterHotKey( hwnd, VK_F1, 0, VK_F1 );
            break;

        case WM_KILLFOCUS:
            UnregisterHotKey( hwnd, VK_F1 );
            break;

        case WM_HOTKEY:
            if (wParam == VK_F1) {
                ProcessHelpRequest( hwnd, 0 );
            }
            return 0;

        case WM_ENTERMENULOOP:
            InMenu = TRUE;
            return 0;

        case WM_EXITMENULOOP:
            InMenu = FALSE;
            return 0;

        case WM_MENUSELECT:
            MenuId = LOWORD(wParam);
            MenuUpdateStatusBar( hwnd, uMessage, wParam, lParam );
            return 0;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                RECT rc;
                GetClientRect( hwnd, &rc );
                rc.top += ToolbarHeight;
                rc.bottom = rc.top + SEPHEIGHT;
                HDC hdc = BeginPaint( hwnd, &ps );
                DrawEdge( hdc, &rc, EDGE_RAISED, BF_TOP | BF_BOTTOM | BF_MIDDLE );
                EndPaint( hwnd, &ps );
            }
            return 0;

        case WM_NOTIFY:
            switch( ((LPNMHDR)lParam)->code ) {
                case TTN_NEEDTEXT:
                    {
                        LPTOOLTIPTEXT lpToolTipText = (LPTOOLTIPTEXT)lParam;
                        LoadString(
                            hInst,
                            (UINT)lpToolTipText->hdr.idFrom,
                            ToolTipBuf,
                            sizeof(ToolTipBuf)
                            );
                        lpToolTipText->lpszText = ToolTipBuf;
                    }
                    return 0;
            }
            break;

        case WM_DESTROY:
            if (LogFileName[0] != 0) {
               LogApiCounts(LogFileName);
               LogFileName[0] = 0;
            }
            else {
                LogApiCounts(ApiMonOptions.LogFileName);
            }

            if (TraceFileName[0] != 0) {
                LogApiTrace(TraceFileName);
                TraceFileName[0] = 0;
            }
            else {
                LogApiTrace(ApiMonOptions.TraceFileName);
            }
            PostQuitMessage( 0 );
            return 0;

        case WM_COMMAND:
            ToolbarState = GetToolbarState( (DWORD)wParam );
            if (ToolbarState) {
                if (!ToolbarState->State) {
                    if (ToolbarState->Msg) {
                        PopUpMsg( ToolbarState->Msg );
                    } else {
                        MessageBeep( MB_ICONEXCLAMATION );
                    }
                    return 0;
                }
            }
            switch( wParam ) {
                case IDM_START:
                    if (MonitorRunning) {
                        SendMessage( hwnd, WM_COMMAND, IDM_STOP, 0 );
                        break;
                    }

                    if (!ApiMonOptions.ProgName[0]) {
                        PopUpMsg( "You must first open a program for monitoring" );
                        break;
                    }

                    DisableToolbarState( IDM_START           );
                    DisableToolbarState( IDM_FILEOPEN        );
                    EnableToolbarState(  IDM_STOP            );
                    EnableToolbarState(  IDM_GRAPH           );
                    EnableToolbarState(  IDM_VIEW_TRACE      );
                    EnableToolbarState(  IDM_CLEAR_COUNTERS  );
                    EnableToolbarState(  IDM_REFRESH         );
                    EnableToolbarState(  IDM_WRITE_LOG       );

                    dw.DeleteAllItems();
                    cw.DeleteAllItems();
                    pw.DeleteAllItems();

                    for (i=0; i<MAX_DLLS; i++) {
                        if (!DllList[i].BaseAddress) {
                            break;
                        }
                        DllList[i].OrigEnable = DllList[i].Enabled;
                    }

                    CmdLine = (LPSTR) MemAlloc(
                        strlen(ApiMonOptions.ProgDir) +
                        strlen(ApiMonOptions.ProgName) +
                        strlen(ApiMonOptions.Arguments) + 32
                        );
                    if (!CmdLine) {
                        PopUpMsg( "Could not allocate memory for command line" );
                        break;
                    }
                    sprintf( CmdLine, "%s%s %s",
                        ApiMonOptions.ProgDir,
                        ApiMonOptions.ProgName,
                        ApiMonOptions.Arguments
                        );
                    hThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)DebuggerThread,
                        (PVOID)CmdLine,
                        0,
                        &ThreadId
                        );
                    if (!hThread) {
                        PopUpMsg( "Could not start the program" );
                        break;
                    }
                    Handles[0] = hThread;
                    Handles[1] = ReleaseDebugeeEvent;
                    WaitObj = WaitForMultipleObjects( 2, Handles, FALSE, INFINITE );
                    if (WaitObj-WAIT_OBJECT_0 == 0) {
                        //
                        // could not launch the debuggee
                        //
                        PopUpMsg( "Could not start the program" );
                        break;
                    }
                    CloseHandle( hThread );
                    MonitorRunning = TRUE;
                    break;

                case IDM_STOP:
                    EnableToolbarState(  IDM_START );
                    DisableToolbarState( IDM_STOP  );

                    if (ApiMonTimerId) {
                        KillTimer( hwnd, ApiMonTimerId );
                    }
                    MonitorRunning = FALSE;
                    break;

                case IDM_REFRESH:
                    ApiMonTimer( hwnd, 0, 0, 0 );
                    break;

                case IDM_OPTIONS:
                    CreateOptionsPropertySheet( hInst, hwnd );
                    break;

                case IDM_EXIT:
                    SendMessage( hwnd, WM_CLOSE, 0, 0 );
                    return 0;

                case IDM_FILEOPEN:
                    {
                        CHAR ProgName[MAX_PATH];
                        if (BrowseForFileName( ProgName, "exe", "Executable Programs" )) {
                            SendMessage( hwnd, WM_INIT_PROGRAM, (WPARAM)ProgName, 0 );
                        }
                    }
                    return 0;

                case IDM_WRITE_LOG:
                    LogApiCounts(ApiMonOptions.LogFileName);
                    LogApiTrace(ApiMonOptions.TraceFileName);
                    return 0;

                case IDM_SAVE_OPTIONS:
                    SaveOptions();
                    return 0;

                case IDM_WINDOWTILE:
                    SendMessage( hwndMDIClient, WM_MDITILE, MDITILE_VERTICAL, 0 );
                    return 0;

                case IDM_WINDOWTILE_HORIZ:
                    SendMessage( hwndMDIClient, WM_MDITILE, MDITILE_HORIZONTAL, 0 );
                    return 0;

                case IDM_WINDOWCASCADE:
                    SendMessage( hwndMDIClient, WM_MDICASCADE, 0, 0 );
                    return 0;

                case IDM_WINDOWICONS:
                    SendMessage( hwndMDIClient, WM_MDIICONARRANGE, 0, 0 );
                    return 0;

                case IDM_FONT:
                    {
                        CHOOSEFONT cf = {0};
                        cf.lStructSize      = sizeof(CHOOSEFONT);
                        cf.hwndOwner        = hwnd;
                        cf.lpLogFont        = &ApiMonOptions.LogFont;
                        cf.Flags            = CF_BOTH | CF_INITTOLOGFONTSTRUCT;
                        if (ChooseFont( &cf )) {
                            HFONT hFontNew = CreateFontIndirect( &ApiMonOptions.LogFont );
                            if (hFontNew) {
                                SaveOptions();
                                cw.ChangeFont( hFontNew );
                                dw.ChangeFont( hFontNew );
                                pw.ChangeFont( hFontNew );
                                gw.ChangeFont( hFontNew );
                                tw.ChangeFont( hFontNew );
                                if (hFont) {
                                    DeleteObject( hFont );
                                }
                                hFont = hFontNew;
                            }
                        }
                    }
                    return 0;

                case IDM_COLOR:
                    {
                        CHOOSECOLOR cc = {0};
                        cc.lStructSize = sizeof(CHOOSECOLOR);
                        cc.hwndOwner = hwnd;
                        cc.Flags = CC_FULLOPEN;
                        cc.lpCustColors = ApiMonOptions.CustColors;
                        if (ApiMonOptions.CustColors[0] == 0) {
                            CopyMemory(
                                ApiMonOptions.CustColors,
                                CustomColors,
                                sizeof(CustomColors)
                                );
                        }
                        if (ChooseColor( &cc )) {
                            ApiMonOptions.Color = cc.rgbResult;
                            SaveOptions();
                            cw.ChangeColor( ApiMonOptions.Color );
                            dw.ChangeColor( ApiMonOptions.Color );
                            pw.ChangeColor( ApiMonOptions.Color );
                            gw.ChangeColor( ApiMonOptions.Color );
                            tw.ChangeColor( ApiMonOptions.Color );
                        }
                    }
                    return 0;

                case IDM_NEW_DLL:
                    CreateChildWindows( CHILD_DLL );
                    break;

                case IDM_NEW_COUNTER:
                    CreateChildWindows( CHILD_COUNTER );
                    break;

                case IDM_NEW_PAGE:
                    CreateChildWindows( CHILD_PAGE );
                    break;

                case IDM_CLEAR_COUNTERS:
                    cw.DeleteAllItems();
                    ClearApiCounters();
                    ClearApiTrace();
                    break;

                case IDM_GRAPH:
                    DisableToolbarState(IDM_GRAPH);
                    gw.Create(TRUE);
                    gw.ChangeFont( hFont );
                    gw.ChangeColor( ApiMonOptions.Color );
                    EnableToolbarState( IDM_LEGEND );
                    break;

                case IDM_LEGEND:
                    PostMessage( GetFocus(), WM_TOGGLE_LEGEND, 0, 0 );
                    break;

                case IDM_VIEW_TRACE:
                    tw.Create();
                    tw.ChangeFont( hFont );
                    tw.ChangeColor( ApiMonOptions.Color );
                    break;

                case IDM_HELP:
                    ProcessHelpRequest( hwnd, 0 );
                    break;

                case IDM_ABOUT:
                    ShellAbout( hwnd, "API Monitor", NULL, NULL );
                    break;

                default:
                    break;
            }
            break;

        case WM_TROJAN_COMPLETE:
            if ((ApiMonOptions.AutoRefresh)) {
                ApiMonTimerId = SetTimer( hwnd, 2, UiRefreshRate, ApiMonTimer );
            }
            GetLocalTime( &StartingLocalTime );
            BaseTime = GetTickCount();
            StartingTick = GetTickCount();
            EndingTick = 0;
            DebuggeStarted = TRUE;
            return 0;

        case WM_UPDATE_COUNTERS:
            cw.Update( TRUE );
            return 0;

        case WM_UPDATE_PAGE:
            pw.Update( TRUE );
            return 0;

        case WM_OPEN_LOG_FILE:
            if (strlen(CmdParamBuffer) >= MAX_PATH)
                return APICTRL_ERR_PARAM_TOO_LONG;

            if (CmdParamBuffer[0] != 0) {
                strcpy(LogFileName, CmdParamBuffer);
                strcpy(TraceFileName, CmdParamBuffer);
                strcat(TraceFileName,".trace");
            }
            else {
                LogFileName[0] = 0;
                TraceFileName[0] = 0;
            }

            ClearApiCounters();
            ClearApiTrace();
            return 0;

        case WM_CLOSE_LOG_FILE:
            if (strlen(CmdParamBuffer) >= MAX_PATH)
                return APICTRL_ERR_PARAM_TOO_LONG;

            if (CmdParamBuffer[0] != 0) {
                strcpy(LogFileName, CmdParamBuffer);
                strcpy(TraceFileName, CmdParamBuffer);
                strcat(TraceFileName,".trace");
            }

            if (LogFileName[0] == 0) {
                return APICTRL_ERR_NULL_FILE_NAME;
            }

            BOOL stat = LogApiCounts(LogFileName);
            stat |= LogApiTrace(TraceFileName);

            LogFileName[0] = 0;
            TraceFileName[0] = 0;

            return (stat ? 0 : APICTRL_ERR_FILE_ERROR);
    }
    return DefFrameProc( hwnd, hwndMDIClient, uMessage, wParam, lParam );
}

HWND
ChildCreate(
    HWND    hwnd
    )
{
    RECT rect;
    GetClientRect( hwnd, &rect );

    HWND hwndList = CreateWindow(
        WC_LISTVIEW,
        "",
        WS_CHILD | LVS_SINGLESEL | LVS_REPORT,
        0,
        0,
        rect.right - rect.left,
        rect.bottom - rect.top,
        hwnd,
        NULL,
        hInst,
        NULL
        );

    ShowWindow( hwndList, SW_SHOW );

    return hwndList;
}

BOOL
WinApp(
    HINSTANCE   hInstance,
    INT         nShowCmd,
    LPSTR       ProgName,
    LPSTR       Arguments,
    BOOL        GoImmediate
    )
{
    WNDCLASSEX  wc;
    MSG         msg;
    HACCEL      hAccelTable;
    LPSTR       p;


    hInst = hInstance;

    if (!SearchPath( NULL, HELP_FILE_NAME, NULL, sizeof(HelpFileName), HelpFileName, &p )) {
        strcpy( HelpFileName, HELP_FILE_NAME );
    }

    wc.cbSize        = sizeof(WNDCLASSEX);
    wc.hIconSm       = (HICON)LoadImage(
                           hInstance,
                           MAKEINTRESOURCE(IDI_APPICON),
                           IMAGE_ICON,
                           16,
                           16,
                           0
                           );
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = WndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszMenuName  = "ApiMon";
    wc.lpszClassName = "ApiMon";

    if (!RegisterClassEx(&wc)) {
        return FALSE;
    }

    cw.Register();
    dw.Register();
    pw.Register();
    gw.Register();
    tw.Register();

    hAccelTable = LoadAccelerators( hInstance, "ApiMon" );

    hwndFrame = CreateWindow(
        "ApiMon",
        "API Monitor",
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        NULL,
        hInstance,
        NULL
        );

    if (!hwndFrame) {
        return FALSE;
    }

    ShowWindow( hwndFrame, nShowCmd );
    UpdateWindow( hwndFrame );

    if (ProgName[0]) {
        PostMessage(
            hwndFrame,
            WM_INIT_PROGRAM,
            (WPARAM)ProgName,
            (LPARAM)Arguments
            );
        if (GoImmediate) {
            PostMessage( hwndFrame, WM_COMMAND, IDM_START, 0 );
        }
    }

    while (GetMessage( &msg, NULL, 0, 0 )) {
        if (!TranslateMDISysAccel( hwndMDIClient, &msg ))
            if (!TranslateAccelerator( msg.hwnd, hAccelTable, &msg )) {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            }
    }

    return TRUE;
}

VOID
__cdecl
PopUpMsg(
    char *format,
    ...
    )
{
    char buf[1024];
    va_list arg_ptr;
    va_start(arg_ptr, format);
    _vsnprintf(buf, sizeof(buf), format, arg_ptr);

    MessageBeep( MB_ICONEXCLAMATION );

    MessageBox(
        hwndFrame,
        buf,
        "ApiMon",
        MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION
        );
}

VOID
Fail(
    UINT Error
    )
{
    char szBuffer[1000];

    if (LoadString( hInst, Error, szBuffer, sizeof(szBuffer) )) {
        PopUpMsg(szBuffer);
    } else {
        LoadString( hInst, ERR_UNKNOWN, szBuffer, sizeof(szBuffer) );
        PopUpMsg(szBuffer, Error);
    }
    ExitProcess(1);
}

VOID
SaveOptions(
    VOID
    )
{
    switch (ChildFocus) {
        case CHILD_COUNTER:
            ApiMonOptions.CounterPosition.Flags |=  IS_FOCUS;
            ApiMonOptions.DllPosition.Flags     &= ~IS_FOCUS;
            ApiMonOptions.PagePosition.Flags    &= ~IS_FOCUS;
            break;

        case CHILD_DLL:
            ApiMonOptions.DllPosition.Flags     |=  IS_FOCUS;
            ApiMonOptions.CounterPosition.Flags &= ~IS_FOCUS;
            ApiMonOptions.PagePosition.Flags    &= ~IS_FOCUS;
            break;

        case CHILD_PAGE:
            ApiMonOptions.PagePosition.Flags    |=  IS_FOCUS;
            ApiMonOptions.CounterPosition.Flags &= ~IS_FOCUS;
            ApiMonOptions.DllPosition.Flags     &= ~IS_FOCUS;
            break;
    }

    RegSave( &ApiMonOptions );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\i386\machine.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    All machine specific code.

Author:

    Wesley Witt (wesw) July-11-1993

Environment:

    User Mode

--*/

#include "apimonp.h"
#pragma hdrstop

#include "reg.h"

extern ULONG ReDirectIat;

#define FLAGIOPL        118
#define FLAGOF          119
#define FLAGDF          120
#define FLAGIF          121
#define FLAGTF          122
#define FLAGSF          123
#define FLAGZF          124
#define FLAGAF          125
#define FLAGPF          126
#define FLAGCF          127
#define FLAGVIP         128
#define FLAGVIF         129

char    szGsReg[]    = "gs";
char    szFsReg[]    = "fs";
char    szEsReg[]    = "es";
char    szDsReg[]    = "ds";
char    szEdiReg[]   = "edi";
char    szEsiReg[]   = "esi";
char    szEbxReg[]   = "ebx";
char    szEdxReg[]   = "edx";
char    szEcxReg[]   = "ecx";
char    szEaxReg[]   = "eax";
char    szEbpReg[]   = "ebp";
char    szEipReg[]   = "eip";
char    szCsReg[]    = "cs";
char    szEflReg[]   = "efl";
char    szEspReg[]   = "esp";
char    szSsReg[]    = "ss";
char    szDiReg[]    = "di";
char    szSiReg[]    = "si";
char    szBxReg[]    = "bx";
char    szDxReg[]    = "dx";
char    szCxReg[]    = "cx";
char    szAxReg[]    = "ax";
char    szBpReg[]    = "bp";
char    szIpReg[]    = "ip";
char    szFlReg[]    = "fl";
char    szSpReg[]    = "sp";
char    szBlReg[]    = "bl";
char    szDlReg[]    = "dl";
char    szClReg[]    = "cl";
char    szAlReg[]    = "al";
char    szBhReg[]    = "bh";
char    szDhReg[]    = "dh";
char    szChReg[]    = "ch";
char    szAhReg[]    = "ah";
char    szIoplFlag[] = "iopl";
char    szFlagOf[]   = "of";
char    szFlagDf[]   = "df";
char    szFlagIf[]   = "if";
char    szFlagTf[]   = "tf";
char    szFlagSf[]   = "sf";
char    szFlagZf[]   = "zf";
char    szFlagAf[]   = "af";
char    szFlagPf[]   = "pf";
char    szFlagCf[]   = "cf";
char    szFlagVip[]  = "vip";
char    szFlagVif[]  = "vif";

REG regname[] = {
        { szGsReg,    REGGS    },
        { szFsReg,    REGFS    },
        { szEsReg,    REGES    },
        { szDsReg,    REGDS    },
        { szEdiReg,   REGEDI   },
        { szEsiReg,   REGESI   },
        { szEbxReg,   REGEBX   },
        { szEdxReg,   REGEDX   },
        { szEcxReg,   REGECX   },
        { szEaxReg,   REGEAX   },
        { szEbpReg,   REGEBP   },
        { szEipReg,   REGEIP   },
        { szCsReg,    REGCS    },
        { szEflReg,   REGEFL   },
        { szEspReg,   REGESP   },
        { szSsReg,    REGSS    },
        { szDiReg,    REGDI    },
        { szSiReg,    REGSI    },
        { szBxReg,    REGBX    },
        { szDxReg,    REGDX    },
        { szCxReg,    REGCX    },
        { szAxReg,    REGAX    },
        { szBpReg,    REGBP    },
        { szIpReg,    REGIP    },
        { szFlReg,    REGFL    },
        { szSpReg,    REGSP    },
        { szBlReg,    REGBL    },
        { szDlReg,    REGDL    },
        { szClReg,    REGCL    },
        { szAlReg,    REGAL    },
        { szBhReg,    REGBH    },
        { szDhReg,    REGDH    },
        { szChReg,    REGCH    },
        { szAhReg,    REGAH    },
        { szIoplFlag, FLAGIOPL },
        { szFlagOf,   FLAGOF   },
        { szFlagDf,   FLAGDF   },
        { szFlagIf,   FLAGIF   },
        { szFlagTf,   FLAGTF   },
        { szFlagSf,   FLAGSF   },
        { szFlagZf,   FLAGZF   },
        { szFlagAf,   FLAGAF   },
        { szFlagPf,   FLAGPF   },
        { szFlagCf,   FLAGCF   },
        { szFlagVip,  FLAGVIP  },
        { szFlagVif,  FLAGVIF  },
};

#define REGNAMESIZE (sizeof(regname) / sizeof(REG))

SUBREG subregname[] = {
        { REGEDI,  0, 0xffff },         //  DI register
        { REGESI,  0, 0xffff },         //  SI register
        { REGEBX,  0, 0xffff },         //  BX register
        { REGEDX,  0, 0xffff },         //  DX register
        { REGECX,  0, 0xffff },         //  CX register
        { REGEAX,  0, 0xffff },         //  AX register
        { REGEBP,  0, 0xffff },         //  BP register
        { REGEIP,  0, 0xffff },         //  IP register
        { REGEFL,  0, 0xffff },         //  FL register
        { REGESP,  0, 0xffff },         //  SP register
        { REGEBX,  0,   0xff },         //  BL register
        { REGEDX,  0,   0xff },         //  DL register
        { REGECX,  0,   0xff },         //  CL register
        { REGEAX,  0,   0xff },         //  AL register
        { REGEBX,  8,   0xff },         //  BH register
        { REGEDX,  8,   0xff },         //  DH register
        { REGECX,  8,   0xff },         //  CH register
        { REGEAX,  8,   0xff },         //  AH register
        { REGEFL, 12,      3 },         //  IOPL level value
        { REGEFL, 11,      1 },         //  OF (overflow flag)
        { REGEFL, 10,      1 },         //  DF (direction flag)
        { REGEFL,  9,      1 },         //  IF (interrupt enable flag)
        { REGEFL,  8,      1 },         //  TF (trace flag)
        { REGEFL,  7,      1 },         //  SF (sign flag)
        { REGEFL,  6,      1 },         //  ZF (zero flag)
        { REGEFL,  4,      1 },         //  AF (aux carry flag)
        { REGEFL,  2,      1 },         //  PF (parity flag)
        { REGEFL,  0,      1 },         //  CF (carry flag)
        { REGEFL, 20,      1 },         //  VIP (virtual interrupt pending)
        { REGEFL, 19,      1 }          //  VIF (virtual interrupt flag)
};

extern CONTEXT CurrContext;
extern HANDLE  CurrProcess;


ULONG
CreateTrojanHorse(
    PUCHAR  Text,
    ULONG   ExceptionAddress
    )
{
    ULONG BpAddr;

    //
    // construct the trojan horse
    //
    // the code looks like the following:
    //
    // |<-- jmp x
    // |    [trojan.dll - null term string]
    // |    [addr of loadlibrary - ulong]
    // |--> push [addr of string]
    //      push [return addr]
    //      jmp [load library]
    //      int 3
    //

    ULONG Address = 0;
    PUCHAR p = Text;
    LPDWORD pp = NULL;


    ULONG i = strlen( TROJANDLL ) + 1;
    //
    // jump around the data
    //
    p[0] = 0xeb;      // jmp
    p[1] = (UCHAR)(i + sizeof(DWORD));     // rel distance
    p += 2;
    //
    // store the trojan dll string
    //
    strcpy( (LPSTR)p, TROJANDLL );
    p += i;
    //
    // store the address of loadlibrarya()
    //
    Address = (ULONG)GetProcAddress(
        GetModuleHandle( KERNEL32 ),
        LOADLIBRARYA
        );
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // push the address of the trojan dll string
    //
    Address = ExceptionAddress + 2;
    p[0] = 0x68;      // push
    p += 1;
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // push the return address
    //
    Address = ExceptionAddress + 33;
    BpAddr = Address;
    p[0] = 0x68;      // push
    p += 1;
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // jump to loadlibrary()
    //
    p[0] = 0xff;
    p[1] = 0x25;      // jmp
    p += 2;
    Address = ExceptionAddress + 2 + strlen( TROJANDLL ) + 1;
    pp = (LPDWORD)p;
    pp[0] = Address;
    //*(LPDWORD)p = Address;
    p += sizeof(DWORD);
    //
    // write the breakpoint instruction
    //
    p[0] = 0xcc;      // breakpoint
    p += 1;

    return BpAddr;
}

VOID
PrintRegisters(
    VOID
    )
{
    printf( "\n" );
    printf(
        "eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\n",
        CurrContext.Eax,
        CurrContext.Ebx,
        CurrContext.Ecx,
        CurrContext.Edx,
        CurrContext.Esi,
        CurrContext.Edi
        );

    printf(
        "eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx %s %s %s %s %s %s %s %s %s %s\n",
        CurrContext.Eip,
        CurrContext.Esp,
        CurrContext.Ebp,
        GetRegFlagValue( FLAGIOPL ),
        GetRegFlagValue( FLAGVIP  ) ? "vip" : "   ",
        GetRegFlagValue( FLAGVIF  ) ? "vif" : "   ",
        GetRegFlagValue( FLAGOF   ) ? "ov" : "nv",
        GetRegFlagValue( FLAGDF   ) ? "dn" : "up",
        GetRegFlagValue( FLAGIF   ) ? "ei" : "di",
        GetRegFlagValue( FLAGSF   ) ? "ng" : "pl",
        GetRegFlagValue( FLAGZF   ) ? "zr" : "nz",
        GetRegFlagValue( FLAGAF   ) ? "ac" : "na",
        GetRegFlagValue( FLAGPF   ) ? "po" : "pe",
        GetRegFlagValue( FLAGCF   ) ? "cy" : "nc"
        );

    printf(
        "cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  gs=%04lx             efl=%08lx\n",
        CurrContext.SegCs,
        CurrContext.SegSs,
        CurrContext.SegDs,
        CurrContext.SegEs,
        CurrContext.SegFs,
        CurrContext.SegGs,
        CurrContext.EFlags
        );
    printf( "\n" );
}

DWORDLONG
GetRegFlagValue(
    ULONG regnum
    )
{
    DWORDLONG value;

    if (regnum < FLAGBASE) {
        value = GetRegValue(regnum);
    } else {
        regnum -= FLAGBASE;
        value = GetRegValue(subregname[regnum].regindex);
        value = (value >> subregname[regnum].shift) & subregname[regnum].mask;
    }
    return value;
}

DWORDLONG
GetRegPCValue(
    PULONG Address
    )
{
    return GetRegValue( REGEIP );
}

DWORDLONG
GetRegValue(
    ULONG RegNum
    )
{
    switch (RegNum) {
        case REGGS:
            return CurrContext.SegGs;
        case REGFS:
            return CurrContext.SegFs;
        case REGES:
            return CurrContext.SegEs;
        case REGDS:
            return CurrContext.SegDs;
        case REGEDI:
            return CurrContext.Edi;
        case REGESI:
            return CurrContext.Esi;
        case REGSI:
            return(CurrContext.Esi & 0xffff);
        case REGDI:
            return(CurrContext.Edi & 0xffff);
        case REGEBX:
            return CurrContext.Ebx;
        case REGEDX:
            return CurrContext.Edx;
        case REGECX:
            return CurrContext.Ecx;
        case REGEAX:
            return CurrContext.Eax;
        case REGEBP:
            return CurrContext.Ebp;
        case REGEIP:
            return CurrContext.Eip;
        case REGCS:
            return CurrContext.SegCs;
        case REGEFL:
            return CurrContext.EFlags;
        case REGESP:
            return CurrContext.Esp;
        case REGSS:
            return CurrContext.SegSs;
        case PREGEA:
            return 0;
        case PREGEXP:
            return 0;
        case PREGRA:
            {
                struct {
                    ULONG   oldBP;
                    ULONG   retAddr;
                } stackRead;
                ReadMemory( CurrProcess, (LPVOID)CurrContext.Ebp, (LPVOID)&stackRead, sizeof(stackRead) );
                return stackRead.retAddr;
            }
        case PREGP:
            return 0;
        case REGDR0:
            return CurrContext.Dr0;
        case REGDR1:
            return CurrContext.Dr1;
        case REGDR2:
            return CurrContext.Dr2;
        case REGDR3:
            return CurrContext.Dr3;
        case REGDR6:
            return CurrContext.Dr6;
        case REGDR7:
            return CurrContext.Dr7;
        default:
            return 0;
        }
}

LONG
GetRegString(
    LPSTR RegString
    )
{
    ULONG   count;

    for (count = 0; count < REGNAMESIZE; count++) {
        if (!strcmp(RegString, regname[count].psz)) {
            return regname[count].value;
        }
    }
    return (ULONG)-1;
}

BOOL
GetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    )
{
    ZeroMemory( Context, sizeof(CONTEXT) );
    Context->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    return GetThreadContext( hThread, Context );
}

BOOL
SetRegContext(
    HANDLE      hThread,
    PCONTEXT    Context
    )
{
    return SetThreadContext( hThread, Context );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\apimon\i386\reg.h ===
#define	REGGS		0
#define	REGFS		1
#define	REGES		2
#define	REGDS		3
#define	REGEDI		4
#define	REGESI		5
#define	REGEBX		6
#define	REGEDX		7
#define	REGECX		8
#define	REGEAX		9
#define	REGEBP		10
#define	REGEIP		11
#define	REGCS		12
#define	REGEFL		13
#define	REGESP		14
#define	REGSS		15

#ifdef	KERNEL
#define REGCR0		16
#define REGCR2		17
#define REGCR3		18
#define REGCR4          19
#endif

#define REGDR0          20
#define REGDR1          21
#define REGDR2          22
#define REGDR3          23
#define REGDR6          24
#define REGDR7          25

#ifdef	KERNEL
#define REGGDTR         26
#define REGGDTL         27
#define REGIDTR         28
#define REGIDTL         29
#define REGTR           30
#define REGLDTR         31
#endif

// Pseudo-registers:
#define	PREGEA		40
#define PREGBASE    PREGEA
#define	PREGEXP		41
#define PREGRA		42
#define PREGP		43
#define	PREGU0		44
#define	PREGU1		45
#define	PREGU2		46
#define	PREGU3		47
#define	PREGU4		48
#define	PREGU5		49
#define	PREGU6		50
#define	PREGU7		51
#define	PREGU8		52
#define	PREGU9		53

#define	FLAGBASE	100
#define	REGDI		100
#define	REGSI		101
#define	REGBX		102
#define	REGDX		103
#define	REGCX		104
#define	REGAX		105
#define	REGBP		106
#define	REGIP		107
#define	REGFL		108
#define	REGSP		109
#define	REGBL		110
#define	REGDL		111
#define	REGCL		112
#define	REGAL		113
#define	REGBH		114
#define	REGDH		115
#define	REGCH		116
#define	REGAH		117
#define	FLAGIOPL	118
#define	FLAGOF		119
#define	FLAGDF		120
#define	FLAGIF		121
#define	FLAGTF		122
#define	FLAGSF		123
#define	FLAGZF		124
#define	FLAGAF		125
#define FLAGPF		126
#define FLAGCF		127

#define REGFIR		REGEIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\help\apimon.hh ===
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
** Help Context Identifiers for APIMON.HH
** Generated by RoboHELP
**
** RoboHELP observes a polite protocol for dealing with this file.
** It will add new identifiers for new context strings that are
** added to the RTF file with the same name.
**
** RoboHELP will also preserve comments which are placed in this
** file, so documentation staff can insert notes to those crazy
** developers and vice versa.
**
** However, the numeric values of the identifiers are stored only
** in this file.  Therefore, if you change the numeric value here,
** it is changed for good.  RoboHELP will not try to change it back.
**
** Normally, RoboHELP will remove the symbols for context strings
** which have been removed from the .RTF file.  However, you can
** set a checkbox in your project setup to prevent RoboHELP from
** doing this.  You may want to do this and make use of the Alias
** capability of the help compiler.
**
*/

#define IDH_ABOUT                       700
#define IDH_CLEAR_COUNTERS              701
#define IDH_COLOR                       702
#define IDH_COMMAND_LINE                703
#define IDH_CONTENTS                    704
#define IDH_DEFSORT_COUNTER             705
#define IDH_DEFSORT_NAME                706
#define IDH_DEFSORT_TIME                707
#define IDH_DISABLE_FAST_COUNTERS       708
#define IDH_DISABLE_HEAP                709
#define IDH_DLLS_OPTIONS                710
#define IDH_ENABLE_COUNTERS             711
#define IDH_ENABLE_TRACING              712
#define IDH_EXIT                        713
#define IDH_FILEOPEN                    714
#define IDH_FNAME_OPTIONS               715
#define IDH_FONT                        716
#define IDH_GO_IMMEDIATE                717
#define IDH_HOW_TO_USE                  718
#define IDH_KNOWN_DLLS                  719
#define IDH_LOG_FILE_NAME               720
#define IDH_MISC_OPTIONS                721
#define IDH_NEW_COUNTER                 722
#define IDH_NEW_DLL                     723
#define IDH_NEW_PAGE                    724
#define IDH_OPTIONS                     725
#define IDH_PAGE_FAULTS                 726
#define IDH_PRELOAD_SYMBOLS             727
#define IDH_SAVE_OPTIONS                728
#define IDH_START                       729
#define IDH_STATUSBAR                   730
#define IDH_STOP                        731
#define IDH_SYMBOL_PATH                 732
#define IDH_TOOLBAR                     733
#define IDH_TRACE_FILE_NAME             734
#define IDH_USE_KNOWN_DLLS              735
#define IDH_WHAT_IS                     736
#define IDH_WINDOWCASCADE               737
#define IDH_WINDOWICONS                 738
#define IDH_WINDOWTILE                  739
#define IDH_WINDOWTILE_HORIZ            740
#define IDH_WRITE_LOG                   741
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\include\apictrl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apictrl.h

Abstract:

    Common types & structures for the ApiCtrl DLL.

Author:

    Rick Swaney (rswaney) 13-Mar-1996

Environment:

    User Mode

--*/

#ifndef _APICTRL_
#define _APICTRL_

//
// Error Codes
//
#define APICTRL_ERR_NO_APIMON_WINDOW    0x80000001  
#define APICTRL_ERR_PARAM_TOO_LONG      0x80000002
#define APICTRL_ERR_NULL_FILE_NAME      0x80000003
#define APICTRL_ERR_FILE_ERROR          0x80000004

//
// Command messages
//
#define WM_OPEN_LOG_FILE    (WM_USER + 200)
#define WM_CLOSE_LOG_FILE   (WM_USER + 201)

//
// Command Buffer mapped file
//
#define CMD_PARAM_BUFFER_NAME  "ApiMonCmdBuf"
#define CMD_PARAM_BUFFER_SIZE  1024
// 
// API Prototypes
//
DWORD
APIENTRY
ApiOpenLogFile( LPSTR pszFileName );

DWORD
APIENTRY
ApiCloseLogFile( LPSTR pszFileName );

#endif // _APICTRL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\include\apimon.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    apimon.h

Abstract:

    Common types & structures for the APIMON projects.

Author:

    Wesley Witt (wesw) 28-June-1995

Environment:

    User Mode

--*/

#ifndef _APIMON_
#define _APIMON_

#ifdef __cplusplus
#define CLINKAGE                        extern "C"
#else
#define CLINKAGE
#endif

#define TROJANDLL                       "apidll.dll"
#define MAX_NAME_SZ                     32
#define MAX_DLLS                        512
#define MEGABYTE                        (1024*1024)
#define MAX_MEM_ALLOC                   (MEGABYTE*32)
#define MAX_APIS                        ((MAX_MEM_ALLOC/2)/sizeof(API_INFO))
#define THUNK_SIZE                      MEGABYTE
#define Align(p,x)                      (((x) & ((p)-1)) ? (((x) & ~((p)-1)) + p) : (x))

#define KERNEL32                        "kernel32.dll"
#define NTDLL                           "ntdll.dll"
#define USER32                          "user32.dll"
#define WNDPROCDLL                      "wndprocs"
#define LOADLIBRARYA                    "LoadLibraryA"
#define LOADLIBRARYW                    "LoadLibraryW"
#define FREELIBRARY                     "FreeLibrary"
#define GETPROCADDRESS                  "GetProcAddress"
#define REGISTERCLASSA                  "RegisterClassA"
#define REGISTERCLASSW                  "RegisterClassW"
#define SETWINDOWLONGA                  "SetWindowLongA"
#define SETWINDOWLONGW                  "SetWindowLongW"
#define ALLOCATEHEAP                    "RtlAllocateHeap"
#define CREATEHEAP                      "RtlCreateHeap"

#if defined(_ALPHA_)

#define UPPER_ADDR(_addr) LOWORD(((LONG_PTR)(_addr) >> 32) + (HIGH_ADDR((_addr)) >> 15))
#define HIGH_ADDR(_addr)  LOWORD(HIWORD((_addr)) + (LOWORD((_addr)) >> 15))
#define LOW_ADDR(_addr)   LOWORD((_addr))

#endif

//
// api table type definitions
//
#define DFLT_TRACE_ARGS  8
#define MAX_TRACE_ARGS   8

//
// Handle type, index corresponds to the entries in the alias array
//

enum Handles { T_HACCEL, T_HANDLE, T_HBITMAP, T_HBRUSH, T_HCURSOR, T_HDC,
        T_HDCLPPOINT, T_HDESK, T_HDWP, T_HENHMETAFILE, T_HFONT, T_HGDIOBJ,
        T_HGLOBAL, T_HGLRC, T_HHOOK, T_HICON, T_HINSTANCE, T_HKL, T_HMENU,
        T_HMETAFILE, T_HPALETTE, T_HPEN, T_HRGN, T_HWINSTA, T_HWND};

#define T_DWORD          101
#define T_LPSTR          102
#define T_LPWSTR         103
#define T_UNISTR         104      // UNICODE string (counted)
#define T_OBJNAME        105      // Name from OBJECT_ATTRIBUTES struct
#define T_LPSTRC         106      // Counted string (count is following arg)
#define T_LPWSTRC        107      // Counted UNICODE string (count is following arg)
#define T_DWORDPTR       108      // Indirect DWORD
#define T_DLONGPTR       109      // Indirect DWORDLONG

// User macro for creating T_DWPTR type with offset encoded in high word
#define T_PDWORD(off) (((off)<<16) + T_DWORDPTR)
#define T_PDLONG(off) (((off)<<16) + T_DLONGPTR)
#define T_PSTR(off)   (((off)<<16) + T_LPSTR)
#define T_PWSTR(off)  (((off)<<16) + T_LPWSTR)

//
// api trace modes
#define API_TRACE        1      // Trace this api
#define API_FULLTRACE    2      // Trace this api and its callees

typedef struct _API_TABLE {
    LPSTR       Name;
    ULONG       RetType;
    ULONG       ArgCount;
    ULONG       ArgType[MAX_TRACE_ARGS];
} API_TABLE, *PAPI_TABLE;

typedef struct _API_MASTER_TABLE {
    LPSTR       Name;
    BOOL        Processed;
    PAPI_TABLE  ApiTable;
} API_MASTER_TABLE, *PAPI_MASTER_TABLE;

typedef struct _API_INFO {
    ULONG       Name;
    ULONG_PTR   Address;
    ULONG_PTR   ThunkAddress;
    ULONG       Count;
    DWORDLONG   Time;
    DWORDLONG   CalleeTime;
    ULONG       NestCount;
    ULONG       TraceEnabled;
    PAPI_TABLE  ApiTable;
    ULONG_PTR   HardFault;
    ULONG_PTR   SoftFault;
    ULONG_PTR   CodeFault;
    ULONG_PTR   DataFault;
    ULONG       Size;
    ULONG       ApiTableIndex;
    ULONG_PTR   DllOffset;
} API_INFO, *PAPI_INFO;

typedef struct _DLL_INFO {
    CHAR        Name[MAX_NAME_SZ];
    ULONG_PTR   BaseAddress;
    ULONG       Size;
    ULONG       ApiCount;
    ULONG       ApiOffset;
    ULONG       Unloaded;
    ULONG       Enabled;
    ULONG       OrigEnable;
    ULONG       Snapped;
    ULONG       InList;
    ULONG       StaticProfile;
    ULONG       Hits;
    ULONG       LoadCount;
} DLL_INFO, *PDLL_INFO;

typedef struct _TRACE_ENTRY {
    ULONG       SizeOfStruct;
    ULONG_PTR   Address;
    ULONG_PTR   ReturnValue;
    ULONG       LastError;
    ULONG_PTR   Caller;
    ULONG       ApiTableIndex;
    DWORDLONG   EnterTime;
    DWORDLONG   Duration;
    ULONG       ThreadNum;
    ULONG       Level;
    ULONG_PTR   Args[MAX_TRACE_ARGS];
} TRACE_ENTRY, *PTRACE_ENTRY;

typedef struct _TRACE_BUFFER {
    ULONG       Size;
    ULONG       Offset;
    ULONG       Count;
    TRACE_ENTRY Entry[1];
} TRACE_BUFFER, *PTRACE_BUFFER;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appcompat\appcompat.h ===
/*
Copyright (c) 1999  Microsoft Corporation

Module Name:

    appcompat.h

Abstract:
    Definition of the ID's for the various controls.

*/

#define FIRSTBUTTON      10
#define IDD_WINNT43      10
#define IDD_WINNT44      11
#define IDD_WINNT45      12
#define IDD_WIN98        13
#define IDD_WIN95        14
#define IDD_NONE         15
#define LASTBUTTON       15

#define IDD_BROWSE      150
#define IDD_LAUNCH      160
#define IDD_CLOSE       170
#define IDD_HELP        180

#define IDD_APPEDIT     200
#define IDD_APPNAME     201

#define IDD_CHECK1      401
#define IDD_CHECK2      402
#define IDD_CHECK3      403
#define IDD_CHECK4      404
#define IDD_DCOMFTM     405
#define IDD_OLDPATH     406


#define IDS_ERROFN      303
#define IDS_ERREDITCTRL 304

#define IDHH_HELP       TEXT("/topics/appcomp.htm")
#define IDHH_CMDSYNTAX  TEXT("/topics/appcomp_syntax.htm")

//#define EXTRA_APP_COMPAT    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\apimon\test\test.c ===
#include <windows.h>
#include <stdio.h>
#include "apimon.h"

HANDLE                  ApiMonMutex;
PVOID                   MemPtr;
PDLL_INFO               DllList;

LPDWORD                 ApiCounter;
LPDWORD                 ApiTraceEnabled;
LPDWORD                 ApiTimingEnabled;
LPDWORD                 FastCounterAvail;
LPDWORD                 ApiOffset;
LPDWORD                 ApiStrings;
LPDWORD                 ApiCount;
LPSTR                   TraceFileName;


PDLL_INFO
AddDllToList(
    HANDLE              hProcess,
    ULONG               DllAddr,
    LPSTR               DllName,
    ULONG               DllSize
    );

ULONG
AddApisForDll(
    HANDLE              hProcess,
    PDLL_INFO           DllInfo
    );



int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    HANDLE      hMap;
    PDLL_INFO   DllInfo;


    hMap = CreateFileMapping(
        (HANDLE)0xffffffff,
        NULL,
        PAGE_READWRITE | SEC_COMMIT,
        0,
        MAX_MEM_ALLOC,
        "ApiWatch"
        );
    if (!hMap) {
        return 1;
    }

    MemPtr = (PUCHAR)MapViewOfFile(
        hMap,
        FILE_MAP_WRITE,
        0,
        0,
        0
        );
    if (!MemPtr) {
        return 1;
    }
    ApiMonMutex = CreateMutex( NULL, FALSE, "ApiMonMutex" );
    if (!ApiMonMutex) {
        return FALSE;
    }

    ApiCounter       = (LPDWORD)MemPtr + 0;
    ApiTraceEnabled  = (LPDWORD)MemPtr + 1;
    ApiTimingEnabled = (LPDWORD)MemPtr + 2;
    FastCounterAvail = (LPDWORD)MemPtr + 3;
    ApiOffset        = (LPDWORD)MemPtr + 4;
    ApiStrings       = (LPDWORD)MemPtr + 5;
    ApiCount         = (LPDWORD)MemPtr + 6;
    TraceFileName    = (LPSTR)((LPDWORD)MemPtr + 7);
    DllList          = (PDLL_INFO)((LPDWORD)MemPtr + 8 + MAX_PATH);

    *ApiOffset       = (MAX_DLLS * sizeof(DLL_INFO)) + ((ULONG)DllList - (ULONG)MemPtr);
    *ApiStrings      = (MAX_APIS * sizeof(API_INFO)) + *ApiOffset;


#if 0
    DllInfo = AddDllToList( NULL,
        HANDLE              hProcess,
        ULONG               DllAddr,
        LPSTR               DllName,
        ULONG               DllSize
        );







#endif

    LoadLibrary( "apidll.dll" );

    return 0;
}

BOOL
ReadMemory(
    HANDLE  hProcess,
    PVOID   Address,
    PVOID   Buffer,
    ULONG   Length
    )
{
    CopyMemory( Buffer, Address, Length );
    return TRUE;
}

PDLL_INFO
FindDllByAddress(
    ULONG DllAddr
    )
{
    ULONG i;
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].BaseAddress == DllAddr) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindDllByName(
    LPSTR DllName
    )
{
    ULONG i;
    for (i=0; i<MAX_DLLS; i++) {
        if (DllList[i].Name[0] &&
            _stricmp( DllList[i].Name, DllName ) == 0) {
                return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
FindAvailDll(
    VOID
    )
{
    ULONG i;
    for (i=0; i<MAX_DLLS; i++) {
        if (!DllList[i].BaseAddress) {
            return &DllList[i];
        }
    }
    return NULL;
}


PDLL_INFO
AddDllToList(
    HANDLE              hProcess,
    ULONG               DllAddr,
    LPSTR               DllName,
    ULONG               DllSize
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    ULONG                   i;
    PDLL_INFO               DllInfo;


    //
    // first look to see if the dll is already in the list
    //
    DllInfo = FindDllByAddress( DllAddr );

    if (!DllSize) {
        //
        // read the pe image headers to get the image size
        //
        if (!ReadMemory(
            hProcess,
            (PVOID) DllAddr,
            &dh,
            sizeof(dh)
            )) {
                return NULL;
        }

        if (dh.e_magic == IMAGE_DOS_SIGNATURE) {
            if (!ReadMemory(
                hProcess,
                (PVOID)(DllAddr + dh.e_lfanew),
                &nh,
                sizeof(nh)
                )) {
                    return NULL;
            }
            DllSize = nh.OptionalHeader.SizeOfImage;
        } else {
            DllSize = 0;
        }
    }

    DllInfo = FindAvailDll();
    if (!DllInfo) {
        return NULL;
    }

    DllInfo->Size = DllSize;
    strncat( DllInfo->Name, DllName, MAX_NAME_SZ-1 );
    DllInfo->BaseAddress = DllAddr;
    DllInfo->InList = FALSE;
    DllInfo->Enabled = TRUE;

    return DllInfo;
}

ULONG
AddApisForDll(
    HANDLE              hProcess,
    PDLL_INFO           DllInfo
    )
{
    IMAGE_DOS_HEADER        dh;
    IMAGE_NT_HEADERS        nh;
    IMAGE_EXPORT_DIRECTORY  expdir;
    PULONG                  names    = NULL;
    PULONG                  addrs    = NULL;
    PUSHORT                 ordinals = NULL;
    PUSHORT                 ordidx   = NULL;
    PAPI_INFO               ApiInfo  = NULL;
    ULONG                   cnt      = 0;
    ULONG                   idx      = 0;
    ULONG                   i;
    ULONG                   j;
    LPSTR                   p;


    if (*ApiCount == MAX_APIS) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)DllInfo->BaseAddress,
        &dh,
        sizeof(dh)
        )) {
            goto exit;
    }

    if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + dh.e_lfanew),
        &nh,
        sizeof(nh)
        )) {
            goto exit;
    }

    if (!nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress +
            nh.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        &expdir,
        sizeof(expdir)
        )) {
            goto exit;
    }

    names = (PULONG) LocalAlloc( LPTR, expdir.NumberOfNames * sizeof(ULONG) );
    addrs = (PULONG) LocalAlloc( LPTR, expdir.NumberOfFunctions * sizeof(ULONG) );
    ordinals = (PUSHORT) LocalAlloc( LPTR, expdir.NumberOfNames * sizeof(USHORT) );
    ordidx = (PUSHORT) LocalAlloc( LPTR, expdir.NumberOfFunctions * sizeof(USHORT) );

    if ((!names) || (!addrs) || (!ordinals) || (!ordidx)) {
        goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNames),
        names,
        expdir.NumberOfNames * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfFunctions),
        addrs,
        expdir.NumberOfFunctions * sizeof(ULONG)
        )) {
            goto exit;
    }

    if (!ReadMemory(
        hProcess,
        (PVOID)(DllInfo->BaseAddress + (ULONG)expdir.AddressOfNameOrdinals),
        ordinals,
        expdir.NumberOfNames * sizeof(USHORT)
        )) {
            goto exit;
    }

    DllInfo->ApiCount = expdir.NumberOfFunctions;
    DllInfo->ApiOffset = *ApiOffset;
    *ApiOffset += (DllInfo->ApiCount * sizeof(API_INFO));
    ApiInfo = (PAPI_INFO)(DllInfo->ApiOffset + (ULONG)DllList);

    if (*ApiCount < MAX_APIS) {
        for (i=0; i<expdir.NumberOfNames; i++) {
            idx = ordinals[i];
            ordidx[idx] = TRUE;
            ApiInfo[i].Count = 0;
            ApiInfo[i].ThunkAddress = 0;
            ApiInfo[i].Address = addrs[idx] + DllInfo->BaseAddress;
            j = 0;
            p = (LPSTR)((LPSTR)MemPtr+*ApiStrings);
            do {
                ReadMemory(
                    hProcess,
                    (PVOID)(DllInfo->BaseAddress + names[i] + j),
                    &p[j],
                    1
                    );
                j += 1;
            } while(p[j-1]);
            ApiInfo[i].Name = *ApiStrings;
            *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
            *ApiCount += 1;
            if (*ApiCount == MAX_APIS) {
                break;
            }
        }
    }
    if (*ApiCount < MAX_APIS) {
        for (i=0,idx=expdir.NumberOfNames; i<expdir.NumberOfFunctions; i++) {
            if (!ordidx[i]) {
                ApiInfo[idx].Count = 0;
                ApiInfo[idx].ThunkAddress = 0;
                ApiInfo[idx].Address = addrs[i] + DllInfo->BaseAddress;
                sprintf(
                    (LPSTR)((LPSTR)MemPtr+*ApiStrings),
                    "Ordinal%d",
                    i
                    );
                ApiInfo[idx].Name = *ApiStrings;
                *ApiStrings += (strlen((LPSTR)((LPSTR)MemPtr+*ApiStrings)) + 1);
                *ApiCount += 1;
                if (*ApiCount == MAX_APIS) {
                    break;
                }
                idx += 1;
            }
        }
    }
    cnt = DllInfo->ApiCount;

exit:
    LocalFree( names );
    LocalFree( addrs );
    LocalFree( ordinals );
    LocalFree( ordidx );

    return cnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\acfileattr.h ===
#ifndef _ACFILEATTR_H
#define _ACFILEATTR_H

#include "windows.h"

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
ReadFileAttributes(
    PSTR pszFile,
    int* pnCount);

VOID
CleanupFileManager(
    HANDLE hFileMgr);

DWORD
GetAttrId(
    int nAttrInd);

BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd);

PSTR
GetAttrName(
    int nAttrInd);

PSTR
GetAttrNameXML(
    int nAttrInd);

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd);

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect);

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd);

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob);

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff);

#ifdef __cplusplus
}
#endif


LPVOID Alloc(SIZE_T cbSize);
BOOL   Free(LPVOID p);

#endif // _ACFILEATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appcompat\apphacks.c ===
// apphacks.c : Defines the entry point for the console application.
//
// This little utility is supposed to allow me a way to enter in data into
// Image File Execution Options without doing it by hand all the time.  Used
// specifically for apphack flags and taking version info out of the EXE to see
// if a match exists

#define UNICODE   1

#include <windows.h>
#include <commdlg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <winver.h>
#include <apcompat.h>





#define MIN_VERSION_RESOURCE	512
#define IMAGE_EXEC_OPTIONS      TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\")

extern TCHAR*  CheckExtension(TCHAR*);
extern VOID    SetRegistryVal(TCHAR* , TCHAR* , PTCHAR,DWORD);
extern VOID    DetailError1  (DWORD );

extern BOOLEAN g_fNotPermanent;
PVOID          g_lpPrevRegSettings;


UINT uVersionInfo[5][8]={  {4,0,1381,VER_PLATFORM_WIN32_NT,3,0,0,0},
                           {4,0,1381,VER_PLATFORM_WIN32_NT,4,0,0,0},
                           {4,0,1381,VER_PLATFORM_WIN32_NT,5,0,0,0},
                           {4,10,1998,VER_PLATFORM_WIN32_WINDOWS,0,0,0,0},
                           {4,0,950,VER_PLATFORM_WIN32_WINDOWS,0,0,0,0}
                           };

PTCHAR  pszVersionInfo[5]={
                           TEXT("Service Pack 3"),
                           TEXT("Service Pack 4"),
                           TEXT("Service Pack 5"),
                           TEXT(""),
                           TEXT("")
                           };

BOOLEAN g_GooAppendFlag;


VOID  SetRegistryValGoo(TCHAR* szTitle, TCHAR* szVal,PUCHAR szBuffer,DWORD dwType,UINT length)
{
  long         lResult;
  TCHAR        szSubKey[MAX_PATH];
  HKEY         hKey;

      wsprintf(szSubKey,
               TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),
               szTitle);

       lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              TEXT("\0"),
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
       if(lResult == ERROR_SUCCESS)
        {

          RegSetValueEx(hKey,
                        szVal,
                        0,
                        dwType,
                        (CONST BYTE*)szBuffer,
                        length);

          RegCloseKey(hKey);
        }
}

VOID DeleteRegistryValueGoo(TCHAR*szTitle)
{
  long         lResult;
  TCHAR        szSubKey[MAX_PATH];
  HKEY         hKey;

      wsprintf(szSubKey,
               TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),
               szTitle);

       lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              KEY_WRITE,
                              &hKey
                              );
       if(lResult == ERROR_SUCCESS)
        {
          RegDeleteValue(hKey,TEXT("ApplicationGoo") );
          RegCloseKey(hKey);
        }
}


/*
 Check whether the registry contains an entry for "applicationgoo" for the given *.exe.
 If it does, check the "resource info." to determine whether they are same.
 If they are the same, don't worry, your work is already done. If not,
 the new one needs to get appended to the old one.
*/
BOOLEAN CheckGooEntry(PVOID pVersionInfo,
                      PAPP_COMPAT_GOO pExistingVersionInfo,
                      BOOL fImageHasResourceInfo,
                      DWORD VersionInfoSize,
                      DWORD dwSize,
                      LARGE_INTEGER *pAppCompatFlag,
                      PAPP_VARIABLE_INFO pOsVersionInfo,
                      ULONG TotalVersionInfoLength,
                      TCHAR* pszPath                             // Executable path.
                      )
{
  BOOLEAN fNeedAppend = FALSE;
  // Added for the addition and deletion from the registry.
  PAPP_COMPAT_GOO       pReplaceAppCompatGoo;
  PPRE_APP_COMPAT_INFO  pAppCompatEntry, pStoredAppCompatEntry = NULL;
  PPRE_APP_COMPAT_INFO  pDestAppCompatEntry, pReplaceAppCompatEntry;
  ULONG                 TotalGooLength, InputCompareLength, ReplaceCopyLength;
  ULONG                 OutputCompareLength, CopyLength, OffSet;
  PVOID                 ResourceInfo;
  UINT                  iLoop = 0;
  BOOL                  fMatchGot = FALSE;
  PVOID                 pExistingAppCompatFlag;
  PVOID                 pExistingOsVersionInfo;
  BOOLEAN               fAppCompatMatch = FALSE, fOsVersionMatch = FALSE;
  TCHAR                 szTitle[MAX_PATH];
  ULONG                 ReplaceGooLength;

  pAppCompatEntry = pExistingVersionInfo ->AppCompatEntry;
  TotalGooLength  = pExistingVersionInfo ->dwTotalGooSize -   \
                    sizeof(pExistingVersionInfo ->dwTotalGooSize);
  //Loop till we get a matching entry in the registry.
  while (TotalGooLength ){
        InputCompareLength = pAppCompatEntry->dwResourceInfoSize;
        ResourceInfo       = pAppCompatEntry + 1;

        if(fImageHasResourceInfo){
           if( InputCompareLength > VersionInfoSize)
              InputCompareLength = VersionInfoSize;

           OutputCompareLength = \
                       (ULONG)RtlCompareMemory(
                                   ResourceInfo,
                                   pVersionInfo,
                                   InputCompareLength
                                   );

        }
        else{
           OutputCompareLength = 0;
        }

        if( InputCompareLength != OutputCompareLength){
          // No match found...Need to continue thru till I find one or exhaust.
           TotalGooLength -= pAppCompatEntry->dwEntryTotalSize;
           (PUCHAR) pAppCompatEntry += pAppCompatEntry->dwEntryTotalSize;
           iLoop++;
           continue;
        }

        // We are a match !!
        pStoredAppCompatEntry = pAppCompatEntry;
        fMatchGot = TRUE;
        // Since we are a match, we won't add the ApplicationGoo but we need to check the
        // ApcompatFlag and the OSVersionInfo.
        if( (!pAppCompatFlag) && (!pOsVersionInfo) )
          break;

        OffSet = sizeof(PRE_APP_COMPAT_INFO) + \
                   pStoredAppCompatEntry->dwResourceInfoSize;
        if(pAppCompatFlag){
           (PUCHAR)pExistingAppCompatFlag = (PUCHAR) ( pStoredAppCompatEntry) + OffSet;
           InputCompareLength = sizeof(LARGE_INTEGER);
           OutputCompareLength = \
                            (ULONG) RtlCompareMemory(
                                       pAppCompatFlag,
                                       pExistingAppCompatFlag,
                                       InputCompareLength
                                       );
           if(OutputCompareLength ==  InputCompareLength)
              fAppCompatMatch = TRUE;
        }


        if(pOsVersionInfo){
           (PUCHAR)pExistingOsVersionInfo = (PUCHAR) (pStoredAppCompatEntry) + OffSet + \
                                                   sizeof(LARGE_INTEGER);
           InputCompareLength = pStoredAppCompatEntry->dwEntryTotalSize - \
                              (sizeof(PRE_APP_COMPAT_INFO) + \
                               pStoredAppCompatEntry->dwResourceInfoSize +\
                               sizeof(LARGE_INTEGER)
                              );
           if(InputCompareLength > TotalVersionInfoLength)
              InputCompareLength = TotalVersionInfoLength;

           OutputCompareLength = \
                            (ULONG) RtlCompareMemory(
                                       pOsVersionInfo,
                                       pExistingOsVersionInfo,
                                       InputCompareLength
                                       );
          if(OutputCompareLength ==  InputCompareLength)
             fOsVersionMatch = TRUE;
        }

        if( ( fOsVersionMatch == TRUE) &&
            ( fAppCompatMatch == TRUE) )
            break;
        else{ // one of these or both are different...
              /*
                The idea here is to replace that part of the AppCompatEntry, which is a
                mis-match. We go ahead and prepare the pReplaceAppCompatEntry
              */
           ReplaceCopyLength = sizeof(PRE_APP_COMPAT_INFO) + \
                        pStoredAppCompatEntry->dwResourceInfoSize + \
                        sizeof(LARGE_INTEGER) + \
                        TotalVersionInfoLength ;
           pReplaceAppCompatEntry = GlobalAlloc(GMEM_FIXED, ReplaceCopyLength);
           RtlCopyMemory((PUCHAR)pReplaceAppCompatEntry, (PUCHAR)pStoredAppCompatEntry, OffSet);
           RtlCopyMemory((PUCHAR)(pReplaceAppCompatEntry) + OffSet,(PUCHAR)pAppCompatFlag,sizeof(LARGE_INTEGER) );
           RtlCopyMemory((PUCHAR)(pReplaceAppCompatEntry)+(OffSet+sizeof(LARGE_INTEGER)),
                                                (PUCHAR)pOsVersionInfo,TotalVersionInfoLength);

           //Now prepare the GOO structure.
           ReplaceGooLength = pExistingVersionInfo ->dwTotalGooSize - \
                              pStoredAppCompatEntry->dwEntryTotalSize + \
                              ReplaceCopyLength;
           pReplaceAppCompatGoo = GlobalAlloc(GMEM_FIXED, ReplaceGooLength);
           pReplaceAppCompatGoo->dwTotalGooSize = ReplaceGooLength;

           pAppCompatEntry = pExistingVersionInfo->AppCompatEntry;
           pDestAppCompatEntry = ((PAPP_COMPAT_GOO)pReplaceAppCompatGoo)->AppCompatEntry;

           ReplaceGooLength -= sizeof(pExistingVersionInfo->dwTotalGooSize);
           while(ReplaceGooLength){
             CopyLength = pAppCompatEntry->dwEntryTotalSize;
             if(pAppCompatEntry != pStoredAppCompatEntry){
                RtlCopyMemory(pDestAppCompatEntry,pAppCompatEntry ,CopyLength);
                (PUCHAR)pDestAppCompatEntry += CopyLength;
             }
             else{
                RtlCopyMemory(pDestAppCompatEntry,pReplaceAppCompatEntry,ReplaceCopyLength);
                pDestAppCompatEntry->dwEntryTotalSize = ReplaceCopyLength;
                (PUCHAR)pDestAppCompatEntry += ReplaceCopyLength;
                (PUCHAR)pAppCompatEntry += pAppCompatEntry->dwEntryTotalSize;
                ReplaceGooLength -= ReplaceCopyLength;
                continue;
             }

             (PUCHAR)pAppCompatEntry += CopyLength;
             ReplaceGooLength -= CopyLength;
            } // End while
           // Delete the key from the registry and add back the updated one.

           GetFileTitle(pszPath,szTitle,MAX_PATH);
           if(CheckExtension(szTitle) == NULL)
             lstrcat(szTitle,TEXT(".exe"));
           DeleteRegistryValueGoo(szTitle);
           SetRegistryValGoo(szTitle,
                             TEXT("ApplicationGoo"),
                             (PUCHAR)pReplaceAppCompatGoo,
                             REG_BINARY,
                             pReplaceAppCompatGoo->dwTotalGooSize
                             );

          GlobalFree(pReplaceAppCompatEntry);
          GlobalFree(pReplaceAppCompatGoo);
        } // Else..

        break;
  } // End while (TotalGooLength )


  if(FALSE == fMatchGot){
    // No match available for this version.
    fNeedAppend = TRUE;
    // Reset the iteration count.
    iLoop  =  0;
  }

  if(g_fNotPermanent){
     // The user has chosen not to make the registry settings permanent and we have the
     // "Append" flag set indicating that there were entries appended to the ApplicationGoo.
     // We need to remove the correct entry for this executable.

     // The idea here is to copy the whole of "ApplicationGoo" to a global buffer leaving just
     // the one that needs to be deleted. Our job is made easier as we have the stored AppCompat
     // entry. We just need to go till there and copy the rest on to the global buffer.

     if(pStoredAppCompatEntry){
        pAppCompatEntry = pExistingVersionInfo->AppCompatEntry;
        TotalGooLength  = pExistingVersionInfo->dwTotalGooSize;
        g_lpPrevRegSettings = (PAPP_COMPAT_GOO)GlobalAlloc(GMEM_FIXED, TotalGooLength );
        ((PAPP_COMPAT_GOO)g_lpPrevRegSettings)->dwTotalGooSize = pExistingVersionInfo->dwTotalGooSize -
                                                                 pStoredAppCompatEntry->dwEntryTotalSize ;
        pDestAppCompatEntry = ((PAPP_COMPAT_GOO)g_lpPrevRegSettings)->AppCompatEntry;
        TotalGooLength -= sizeof(pExistingVersionInfo->dwTotalGooSize);
        while(TotalGooLength){
             CopyLength = pAppCompatEntry->dwEntryTotalSize;
             if(pAppCompatEntry != pStoredAppCompatEntry){
                RtlCopyMemory(pDestAppCompatEntry,pAppCompatEntry ,CopyLength);
                (PUCHAR)pDestAppCompatEntry += CopyLength;
                g_GooAppendFlag = TRUE;
             }

            (PUCHAR)pAppCompatEntry += CopyLength;
            TotalGooLength -= CopyLength;
        } // End while.
     }
     else{ // We do not have a stored AppCompatEntry. This means our target is to remove the
           // the first entry and leave the rest intact. i.e copy the rest onto the global buffer
           // for it to be copied.
           TotalGooLength = pExistingVersionInfo->dwTotalGooSize;
           g_lpPrevRegSettings = (PAPP_COMPAT_GOO)GlobalAlloc(GMEM_FIXED, TotalGooLength );
           RtlCopyMemory(g_lpPrevRegSettings,pExistingVersionInfo, TotalGooLength);
           g_GooAppendFlag = TRUE;
     }
  }

    return fNeedAppend;
  }



int MakeAppCompatGoo(TCHAR* TmpBuffer,LARGE_INTEGER* pAppCompatFlag, UINT uOsVer)
{
	BOOLEAN fImageHasVersionInfo = FALSE;
	BOOLEAN fOsVersionLie = FALSE;
	BOOLEAN fEntryPresent = FALSE;
 	TCHAR Buffer[MAX_PATH];
	TCHAR StringBuffer[MAX_PATH];
	TCHAR RegPath[MAX_PATH];
	TCHAR InChar;
	LONG status;
	HKEY hKey;
	PTCHAR pBuf;
	PTCHAR pAppGooBuf;
	PUCHAR pData;
	PTCHAR OutBuffer;
	PWCHAR uniBuffer;
	DWORD VersionInfoSize;
	DWORD dwHandle;
	DWORD dwBytesWritten;
	DWORD dwType;
	DWORD dwSize;
	ULONG i, j;
	ULONG EXELength;
	ULONG AppCompatHigh;
	ULONG AppCompatLow;
	ULONG TotalGooSize;
	ULONG TotalVersionInfoLength=0;
	ULONG OutBufferSize;
	PVOID lpData;
	PVOID ResourceInfo;
	PVOID VersionInfo;
	PAPP_COMPAT_GOO AppCompatGoo;
	PAPP_VARIABLE_INFO VariableInfo=NULL;
	PAPP_VARIABLE_INFO AppVariableInfo=NULL;
	EFFICIENTOSVERSIONINFOEXW OSVersionInfo, *pOsVersionInfo;

	// Remove the trailing and leading " " if PRESENT.
	    if(*TmpBuffer == TEXT('\"') ){
           lstrcpy(Buffer, TmpBuffer+1);
		   *(Buffer + (lstrlen(Buffer) - 1) )= TEXT('\0');
		 }
		 else
		   	lstrcpy(Buffer, TmpBuffer);
		   	
	// Quick check to see if its got any version info in its header
	VersionInfoSize = GetFileVersionInfoSize(&Buffer[0], &dwHandle);
	if (VersionInfoSize) {
		// It does, so alloc space for it to pull it in below
		VersionInfo = LocalAlloc(GMEM_FIXED, VersionInfoSize);
		if (VersionInfo) {
			// Get the version info
			if (GetFileVersionInfo(&Buffer[0], dwHandle, VersionInfoSize, VersionInfo)) {
				// Set global flag to be inspected later
				fImageHasVersionInfo = TRUE;
			}
		}
	}

	// Enter the app compat flags (decimal) - its defined as a LARGE_INTEGER	
    AppCompatHigh = 0x0;
    AppCompatLow  = 0x0;
    AppCompatLow  = pAppCompatFlag->LowPart;
    AppCompatHigh = pAppCompatFlag->HighPart;

	
	// Determine goo size, start with main goo
	TotalGooSize = sizeof(APP_COMPAT_GOO);

	

	// Add sizeof compatibility flags (large integer)
	TotalGooSize += sizeof(LARGE_INTEGER);
	// if we actually got version information add the length of that.  We take the minimum
	// of whatever the EXE has or 0x200 bytes to try and identify the app.  I've found that
	// anything less than 0x200 bytes doesn't supply enough info to be useful.
	if (fImageHasVersionInfo) {
		VersionInfoSize = min(VersionInfoSize, MIN_VERSION_RESOURCE);
		TotalGooSize += VersionInfoSize;
	}

	// See if they requested version lying, if so we got a bunch more horseshit todo
	if (AppCompatLow & KACF_VERSIONLIE) {
       fOsVersionLie  = TRUE;
	
       OSVersionInfo.dwMajorVersion = uVersionInfo[uOsVer][0];
       OSVersionInfo.dwMinorVersion = uVersionInfo[uOsVer][1];
       OSVersionInfo.dwBuildNumber  = uVersionInfo[uOsVer][2];
       OSVersionInfo.dwPlatformId   = uVersionInfo[uOsVer][3];
       OSVersionInfo.wServicePackMajor = (WORD)uVersionInfo[uOsVer][4];
       OSVersionInfo.wServicePackMinor = (WORD)uVersionInfo[uOsVer][5];
       OSVersionInfo.wSuiteMask      = (WORD)uVersionInfo[uOsVer][6];
       OSVersionInfo.wProductType    = (BYTE)uVersionInfo[uOsVer][7];
       lstrcpy( (TCHAR*) OSVersionInfo.szCSDVersion, pszVersionInfo[uOsVer]);


		// Start with the length of the full struct
		TotalVersionInfoLength = sizeof(EFFICIENTOSVERSIONINFOEXW);
		// subtract the size of the szCSDVersion field	
		TotalVersionInfoLength -= sizeof(OSVersionInfo.szCSDVersion);

				// add the strlen amount plus 1 for the NULL wchar
        TotalVersionInfoLength += lstrlen((TCHAR*)OSVersionInfo.szCSDVersion )*sizeof(WCHAR)+sizeof(WCHAR);

        // Add the size of the variable length structure header (since VerInfo is var length)
		TotalVersionInfoLength += sizeof(APP_VARIABLE_INFO);
		// Add the total version info length to the goo size
		TotalGooSize += TotalVersionInfoLength;
		// Allocate space for the variable length version info
		AppVariableInfo = (PAPP_VARIABLE_INFO) LocalAlloc(GMEM_FIXED, sizeof(APP_VARIABLE_INFO) + TotalVersionInfoLength);
		if (!AppVariableInfo) {
			return -1;
		}
		// fill in the pertinent data in the variable length info header
		AppVariableInfo->dwVariableInfoSize = sizeof(APP_VARIABLE_INFO) + TotalVersionInfoLength;
		AppVariableInfo->dwVariableType = AVT_OSVERSIONINFO;
		// Do a pointer +1 operation here to get past the header to the actual data
		VariableInfo = AppVariableInfo + 1;
		// Copy the actual data in
		memcpy(VariableInfo, &OSVersionInfo, TotalVersionInfoLength);
	
	}

	//
	// See if an entry already exists in the registry.  If so, we'll have to glom
	// this entry into the other already existing one.
	//
	// Get the registry path all figured out
	memset(&RegPath[0], 0, sizeof(RegPath));
	lstrcat(&RegPath[0], IMAGE_EXEC_OPTIONS);
	EXELength = lstrlen(&Buffer[0]);
	pBuf = &Buffer[0];
	pBuf += EXELength;
	// work backward in the path til we find the the last backslash
	while ((*pBuf != '\\') && (pBuf != &Buffer[0])) {
		pBuf--;	
	}
	if (*pBuf == '\\') {
		pBuf++;
	}

	if(CheckExtension(pBuf) == NULL)
     lstrcat(pBuf,TEXT(".exe"));

	// cat the image.exe name to the end of the registry path
	lstrcat(&RegPath[0], pBuf);
	// try to open this key
	status = RegOpenKey(HKEY_LOCAL_MACHINE, &RegPath[0], &hKey);
	if (status == ERROR_SUCCESS) {	
		dwSize = 1;
		// do a query once with small size to figure out how big the binary entry is
		status = RegQueryValueEx(hKey, TEXT("ApplicationGoo"), NULL, &dwType, NULL, &dwSize);
		if( status == ERROR_SUCCESS){
			//
			// There's an entry already there.  Take the size of this Goo entry and add it
			// to the TotalGooSize LESS the size of the first dword in the APP_COMPAT_GOO
			// struct (as there already was one there).
			//
			
		//  Added here after checkin
            if(dwSize > 1){
                lpData = LocalAlloc(GMEM_FIXED, dwSize);
                if(lpData){
                  status = RegQueryValueEx(hKey, TEXT("ApplicationGoo"), NULL, &dwType, (PUCHAR) lpData, &dwSize);
                 // if(VersionInfo) ...Remove this as it is not necessary.
              //    if(fOsVersionLie)
                //    pOsVersionInfo = VariableInfo;

        	      fEntryPresent = CheckGooEntry( VersionInfo,
        			                             (PAPP_COMPAT_GOO)lpData,
        			                             fImageHasVersionInfo,
        			                             VersionInfoSize,
        			                             dwSize,
        			                             pAppCompatFlag,
        			                             AppVariableInfo,
        			                             TotalVersionInfoLength,
        			                             Buffer
        			                            );
     			  }
     		    }	

       // End add


            if(fEntryPresent)
			  TotalGooSize += dwSize - sizeof(AppCompatGoo->dwTotalGooSize);
			
			else{  // Nothing to append....return as it is the same.
			  if(fImageHasVersionInfo)
                LocalFree(VersionInfo);
              if(fOsVersionLie)
                LocalFree(AppVariableInfo);

              return 0;
			}
			
			

	  RegCloseKey(hKey);
	}
   }

	// Allocate the memory for the entire app compat goo
	AppCompatGoo = (PAPP_COMPAT_GOO) LocalAlloc(GMEM_FIXED, TotalGooSize);
	if (!AppCompatGoo) {
		return -1;
	}

	// fill in the total size
	AppCompatGoo->dwTotalGooSize = TotalGooSize;
	// if there was version info for this entry we need to fill that in now, else zero
	if (fImageHasVersionInfo) {
		AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize = VersionInfoSize;
	}
	else {
		AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize = 0;
	}
	AppCompatGoo->AppCompatEntry[0].dwEntryTotalSize = \
		sizeof(AppCompatGoo->AppCompatEntry[0].dwEntryTotalSize) +
		sizeof(AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize) +
		TotalVersionInfoLength +						// In case app needed VER lying
		sizeof(LARGE_INTEGER);							// For app compatibility flags

	// Entry size is whatever it was plus any resource info we've got
	AppCompatGoo->AppCompatEntry[0].dwEntryTotalSize += \
		AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize;
	// do the pointer +1 thing so we can be pointing at the data area
	ResourceInfo = AppCompatGoo->AppCompatEntry + 1;
	// copy the data in
	memcpy(ResourceInfo, VersionInfo, VersionInfoSize);

	// filling in the app compat flags here
	pData = (PUCHAR) ResourceInfo + AppCompatGoo->AppCompatEntry[0].dwResourceInfoSize;
	memcpy(pData, &AppCompatLow, sizeof(AppCompatLow));
	pData += sizeof(AppCompatLow);
	memcpy(pData, &AppCompatHigh, sizeof(AppCompatHigh));
	pData += sizeof(AppCompatHigh);
	// if there was any version resource info, copy that in here too
	if (AppVariableInfo) {
		memcpy(pData, AppVariableInfo, TotalVersionInfoLength);
	}
	pData += TotalVersionInfoLength;
	//
	// If an already existing entry was there, we need to ask append what was there to the
	// tail of the entry.   (i.e. what's already there gets auto appended to the tail).  If
	// someone wants to write a 1-N positioning for entries within the Goo - they'll have to
	// add that support here
	//
	if (fEntryPresent) {
		// Start at offset + 4 cuz the previous Total Goo size must be skipped.
		memcpy(pData, (PUCHAR) lpData+4, dwSize - sizeof(AppCompatGoo->dwTotalGooSize));
	}


    pData = (PUCHAR) AppCompatGoo;
    SetRegistryValGoo(pBuf, TEXT("ApplicationGoo"),pData,REG_BINARY,AppCompatGoo->dwTotalGooSize);


    if(fImageHasVersionInfo)
       LocalFree(VersionInfo);
    if(fOsVersionLie)
       LocalFree(AppVariableInfo);
    if(fEntryPresent)
       LocalFree(lpData);
    LocalFree(AppCompatGoo);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\acfileattr.h ===
#ifndef _ACFILEATTR_H
#define _ACFILEATTR_H

#include "windows.h"

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
ReadFileAttributes(
    PSTR pszFile,
    int* pnCount);

VOID
CleanupFileManager(
    HANDLE hFileMgr);

DWORD
GetAttrId(
    int nAttrInd);

BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd);

PSTR
GetAttrName(
    int nAttrInd);

PSTR
GetAttrNameXML(
    int nAttrInd);

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd);

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect);

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd);

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob);

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff);

#ifdef __cplusplus
}
#endif


LPVOID Alloc(SIZE_T cbSize);
BOOL   Free(LPVOID p);

#endif // _ACFILEATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appcompat\appcompat.c ===
/*

Copyright (c) 1999  Microsoft Corporation

Module Name:

    appcompat.c

Abstract:
    An application to launch a required APP with the
    version and the APPCOMPAT flags set.

*/

/* INCLUDES */

#define UNICODE   1

#include <windows.h>
#include <commdlg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <shellapi.h>
#include <tchar.h>
#include <htmlhelp.h>
#include <apcompat.h>

#include "appcompat.h"


#define MAXRES   256
#define MAXKEY   100
#define MAXDATA  10
#define MAXTITLE 100



INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);
int MakeAppCompatGoo(TCHAR*, LARGE_INTEGER*, UINT);
long DeleteSpecificVal(HKEY );
extern TCHAR* CheckExtension(TCHAR*);
/* Global */
// Pattern string..  MajorVersion, MinorVersion, BuildNumber,ServicePackMajor, ServicePackMinor,
//                   PlatformID, CSDVersion string....
const TCHAR* pVersionVal[] = {
                         TEXT("4,0,1381,3,0,2,Service Pack 3"),
                         TEXT("4,0,1381,4,0,2,Service Pack 4"),
                         TEXT("4,0,1381,5,0,2,Service Pack 5"),
                         TEXT("4,10,1998,0,0,1,"),
                         TEXT("4,0,950,0,0,1,"),
                         NULL
                        };

#define MAXVERNUM   ( sizeof(pVersionVal)/sizeof(TCHAR*) ) - 1

const TCHAR szFilter[] = TEXT("EXE Files (*.EXE)\0*.exe\0") \
                         TEXT("All Files (*.*)\0*.*\0\0");

HINSTANCE g_hInstance;
extern    PVOID    g_lpPrevRegSettings;
BOOL      g_fAppCompatGoo = FALSE;
BOOLEAN   g_fNotPermanent = FALSE;
extern    BOOLEAN g_GooAppendFlag;


// Converts Text to interger.
int TextToInt(
        const TCHAR *nptr
        )
{
        int c;              /* current char */
        int total;          /* current total */
        int sign;           /* if '-', then negative, otherwise positive */

        /* skip whitespace */
        while ( *nptr  == TEXT(' ') )
            ++nptr;

        c = (int)*nptr++;
        sign = c;           /* save sign indication */
        if (c == TEXT('-') || c == TEXT('+') )
            c = (int)*nptr++;    /* skip sign */
        total = 0;

        while ( (c>=TEXT('0')) && (c <= TEXT('9')) ) {
            total = 10 * total + (c - TEXT('0') );     /* accumulate digit */
            c = (int)*nptr++;    /* get next char */
        }

        if (sign == '-')
            return -total;
        else
            return total;   /* return result, negated if necessary */
}


TCHAR* CheckExtension(TCHAR* szTitle)
{
  TCHAR *pCh;
  pCh = szTitle;

  while(*pCh != TEXT('.'))
  {
   if(*pCh == TEXT('\0'))
    break;
   pCh++;
  }
  if(*pCh == TEXT('\0'))
   return NULL;
  else
   {
     pCh++;
     return pCh;
   }
}


VOID GetTitleAndCommandLine(TCHAR* pEditBuf, TCHAR* pszTitle, TCHAR* pszCommandLine)
{
  TCHAR  szTitleAndCommandLine[_MAX_PATH];
  TCHAR* pszTemp, *pszTmpTitle;
  UINT   i = 0;

  lstrcpy(szTitleAndCommandLine, pEditBuf);
  pszTmpTitle = pszTemp = szTitleAndCommandLine;

  if(*pszTemp == TEXT('\"') ){ // The title has quotes(" "). It has command line params.
    pszTemp++;
    while(*pszTemp != TEXT('\"') ){
         pszTemp++;
         if(*pszTemp == TEXT('\0') )
          break;
         if(*pszTemp == TEXT('\\') )
           pszTmpTitle = pszTemp + 1;
     }

  }
  else{ // No quotes(" ")...This means that there are no command line parameters.
      GetFileTitle(pEditBuf,pszTitle,MAX_PATH);
      pszCommandLine = NULL;
      return;
  }

  RtlZeroMemory(pszCommandLine, MAX_PATH);
  if(*pszTemp != TEXT('\0') ){  // There are command line paramaters for the APP.
     *(pszTemp ) = TEXT('\0');
     lstrcpy(pEditBuf, szTitleAndCommandLine);

     // For Paths beginning with a '"' and ending with a '"'.
     if(*pEditBuf == TEXT('\"') )
        lstrcat(pEditBuf, TEXT("\"") );
    // Now copy over the Command line parameters.
     pszTemp++;
     while( (*pszTemp) != TEXT('\0') ){
          *(pszCommandLine + i) = *pszTemp;
          i++;
          pszTemp++;
      }
      *(pszCommandLine + i) = TEXT('\0');
  }

  lstrcpy(pszTitle, pszTmpTitle);
 }

VOID GetFileExtension(TCHAR* pEditBuf, TCHAR* pszTitle,TCHAR* pszCommandLine)
{
   GetTitleAndCommandLine(pEditBuf, pszTitle, pszCommandLine);
   if(CheckExtension(pszTitle) == NULL)
     lstrcat(pszTitle,TEXT(".exe"));
}

TCHAR* GetNextWord(BOOLEAN* pfEndOfLine,TCHAR* pStr)
{
 TCHAR* pCh;

  pCh = pStr;
  //Skip white spaces..
  while((*pCh == TEXT(' ')) || (*pCh == TEXT('\t')))
   pCh++;

   // Fix for Command line parameters (from the command line within " " :)) ).
   if( *pCh == TEXT('\"') ){
      pCh++;
      while( *pCh != TEXT('\0') ) // Scan till the end when the string starts with a '"'.
            pCh++;
      *pfEndOfLine = TRUE;
      return pCh;
   }
   // End ..Fix for Command line parameters (from the command line within " " :)) ).

  while( ((*pCh)!=TEXT('-')) && ((*pCh)!=TEXT('\0')) )
  {
    pCh++;
  }
  if((*pCh) == TEXT('\0'))
      *pfEndOfLine = TRUE;
  else
      *pfEndOfLine = FALSE;

      return pCh;
}

void SkipBlanks(TCHAR* pStr)
{
 TCHAR* pTemp;

  if(*(pStr - 1) == TEXT(' '))
  {
   pTemp = pStr;
   while(*(pTemp - 1) == TEXT(' '))
    pTemp--;
   *pTemp = TEXT('\0');
  }
}

VOID  SetRegistryVal(TCHAR* szTitle, TCHAR* szVal,PTCHAR szBuffer,DWORD dwType)
{
  long         lResult;
  TCHAR        szSubKey[MAXKEY];
  HKEY         hKey;

      wsprintf(szSubKey, TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),szTitle);

       lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              TEXT("\0"),
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
       if(lResult == ERROR_SUCCESS)
        {

          RegSetValueEx(hKey,szVal,
                        0, dwType,(CONST BYTE*)szBuffer, lstrlen(szBuffer) + 1);

          RegCloseKey(hKey);
        }
}

long RestoreRegistryVal(szTitle)
{
  long         lResult;
  TCHAR        szSubKey[MAXKEY];
  HKEY         hKey;

      wsprintf(szSubKey, TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),szTitle);

       lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              TEXT("\0"),
                              0,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              NULL);
       if(lResult == ERROR_SUCCESS)
        {

          lResult = RegSetValueEx(hKey,TEXT("ApplicationGoo"),
                        0, REG_BINARY,(CONST BYTE*)g_lpPrevRegSettings, *((PULONG)g_lpPrevRegSettings) );

          if(ERROR_SUCCESS != lResult)
            MessageBox(NULL,TEXT("Appending ApplicationGoo failed !!"),TEXT(""),IDOK);

          RegCloseKey(hKey);
        }
    return lResult;
}

long DeleteKey(TCHAR* szTitle, BOOL bGooKeyPresent)
{
  long lRet;
  HKEY hKey;

  lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options"),
                       0,
                       KEY_WRITE,
                       &hKey);

  if(ERROR_SUCCESS == lRet){
    if((!g_fAppCompatGoo) &&
      ( TRUE == bGooKeyPresent) ){ // We did not set ApplicationGoo at all. So, we cannot delete it !
       lRet = DeleteSpecificVal(hKey);
       return lRet;
    }
    RegDeleteKey(hKey, szTitle);
    RegCloseKey(hKey);
    // If there was a previous entry of ApplicationGoo in the registry.
    if(g_GooAppendFlag)
      lRet =  RestoreRegistryVal(szTitle);

  }// If ERROR_SUCCESS
 return lRet;
}

long DeleteSpecificVal(HKEY hKey)
{
  if(g_fNotPermanent == TRUE){
     if(g_fAppCompatGoo){
        RegDeleteValue(hKey, TEXT("ApplicationGoo") );
        if(g_GooAppendFlag){
           if( RegSetValueEx(hKey,
                         TEXT("ApplicationGoo"),
                         0,
                         REG_BINARY,
                         (CONST BYTE*)g_lpPrevRegSettings,
                         *((PULONG)g_lpPrevRegSettings)
                          ) != ERROR_SUCCESS )
            MessageBox(NULL,TEXT("Appending ApplicationGoo failed !!"),TEXT(""),IDOK);
         }
      }
   }
  return( RegDeleteValue( hKey,TEXT("DisableHeapLookAside") ) );
}

long CheckAndDeleteKey(TCHAR* szTitle, BOOL Check)
{
  long lResult,lRet = -1;
  TCHAR szSubKey[MAXKEY], szData[MAXDATA], szKeyName[MAXKEY],szResult[MAXDATA];
  int   Size,KeyLength, indx =0;
  HKEY  hKey;
  DWORD dwType;
  BOOLEAN bSpecificKey = FALSE, bGooKeyPresent = FALSE;

  wsprintf(szSubKey,TEXT("software\\microsoft\\windows NT\\currentversion\\Image File Execution Options\\%s"),szTitle);

  lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szSubKey,
                         0,
                         KEY_SET_VALUE | KEY_QUERY_VALUE,
                         &hKey);

  if(ERROR_SUCCESS == lResult){
    Size = sizeof(szData) + 1;
    lResult = RegQueryValueEx(hKey,
                           TEXT("DisableHeapLookAside"),
                           NULL,
                           &dwType,
                           (LPBYTE)szData,
                           &Size);
    if(Check)
      return lResult;

        /*
       This is done to check whether this is the only value under this KEY.
       If there are other values under this key, only this value is deleted
     */
      KeyLength = sizeof(szKeyName) + 1;
      while(RegEnumValue(hKey,
                         indx,
                         szKeyName,
                         &KeyLength,
                         NULL,
                         NULL,
                         NULL,
                         NULL) != ERROR_NO_MORE_ITEMS)
      {
         if(lstrcmpi(szKeyName,TEXT("DisableHeapLookAside"))!=0){
           if(lstrcmpi(szKeyName,TEXT("ApplicationGoo"))!=0 ||
               g_fNotPermanent == FALSE){ // ApplicationGoo is present but it should be permanent...
             bSpecificKey = TRUE;
             lRet = DeleteSpecificVal(hKey);
             break;
           }
           bGooKeyPresent = TRUE;    // If it has come here, then it is equal to "ApplicationGoo"
         }
         indx++;
         KeyLength = sizeof(szKeyName) + 1;
      }
      RegCloseKey(hKey);

      if(!bSpecificKey){
        lRet = DeleteKey(szTitle, bGooKeyPresent);
      }

  }
 return lRet;
}



void DetailError(DWORD dwErrMsg)
{
   LPVOID lpMsgBuf;
   if(FormatMessage(
                 FORMAT_MESSAGE_ALLOCATE_BUFFER |
                 FORMAT_MESSAGE_FROM_SYSTEM     |
                 FORMAT_MESSAGE_IGNORE_INSERTS,
                 NULL,
                 dwErrMsg,
                 MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),
                 (LPTSTR)&lpMsgBuf,
                 0,
                 NULL
                ) != 0){
      MessageBox(NULL, lpMsgBuf, TEXT(""), IDOK);
   }
   LocalFree(lpMsgBuf);
}



VOID ExecuteApp(HWND hWnd, TCHAR* AppName,TCHAR* szTitle,TCHAR* pszCommandLine, BOOLEAN fMask)
{
 SHELLEXECUTEINFO sei;
 MSG              msg;
 static int       cnt = 0;

  memset(&sei, 0, sizeof(SHELLEXECUTEINFO) );
  sei.cbSize = sizeof(SHELLEXECUTEINFO);
  sei.hwnd   = hWnd;
  sei.lpVerb = TEXT("open");
  sei.lpFile = AppName;
  sei.nShow  = SW_SHOWDEFAULT;
  sei.lpParameters = pszCommandLine;

  if(fMask){
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
  }
  if(ShellExecuteEx(&sei) == FALSE) {          /* If the API fails */
    CheckAndDeleteKey(szTitle, FALSE);
    DetailError( GetLastError() );
  }
  else{  // Was successful in launching the application.
    // Wait till the process terminates...
    if(fMask){
      if(NULL != sei.hProcess ){  // The hProcess can be NULL sometimes....
        while(WaitForSingleObject(sei.hProcess, 5000)== WAIT_TIMEOUT){
          while(PeekMessage(&msg, NULL, 0, 0,PM_REMOVE)){
               TranslateMessage(&msg);
               DispatchMessage(&msg);
          }
          cnt++;
          if(cnt == 15)
            break;
        }
        CheckAndDeleteKey(szTitle, FALSE );
        CloseHandle(sei.hProcess);
      }
      else
        MessageBox(NULL, TEXT(" Process Handle is NULL"), TEXT(""), IDOK);
     }
  }


}

VOID SetTempPath(VOID)
{
  TCHAR szEnv[_MAX_PATH],szTemp[_MAX_PATH];
  int   indx1=0,indx2 =0;

  GetEnvironmentVariable(TEXT("TEMP"),szTemp,_MAX_PATH);

  szEnv[0] = szTemp[0];
  lstrcpy(&szEnv[1],TEXT(":\\Temp"));
  if(SetEnvironmentVariable(TEXT("TEMP"), szEnv) == 0){
     DetailError(GetLastError());
  }
}

VOID GetDirectoryPath(LPTSTR pszModulePath,LPTSTR pszDirectoryPath)
{
   TCHAR* pTmp, *pSwap;

   pTmp = (TCHAR*) malloc( sizeof(TCHAR) * (lstrlen((LPCTSTR)pszModulePath) + 1) );
   if(pTmp){
     lstrcpy(pTmp, pszModulePath);
     pSwap = pTmp;
     pTmp += lstrlen((LPCTSTR)pszModulePath);
     while(*pTmp != TEXT('\\') ){
         pTmp--;
     }
     *pTmp = TEXT('\0');
     pTmp  = pSwap;
     lstrcpy(pszDirectoryPath, pTmp);
     free(pTmp);
   }
}

VOID GetHelpPath(LPTSTR pszPath)
{
   TCHAR szFilePath[_MAX_PATH] = {0};

   GetModuleFileName(NULL,szFilePath,_MAX_PATH);
   GetDirectoryPath(szFilePath, pszPath);
   lstrcat(pszPath, TEXT("\\w2rksupp.chm") );
}




/* Main Entry point */

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
  const static TCHAR szAppName [] = TEXT("AppCompat");
  MSG         msg;
  WNDCLASS    wndclass;

 /* Addition for Command line Parameters*/
  TCHAR        *AppName = NULL, *pCh = NULL, *pNextWord=NULL;
  BOOLEAN      fEnd = FALSE, fDisableHeapLookAside = FALSE, fSetTemp = FALSE,fHelpDisplay = FALSE;
  BOOL         fKeepRegistrySetting = FALSE;
  UINT         VersionNum = 5,indx,length;
  HKEY         hKey;
  TCHAR        szTitle[_MAX_PATH], szSubKey[MAXKEY],szKeyName[MAXKEY];
  TCHAR        szCommandLine[_MAX_PATH];
  LPTSTR       pStr;
  long         lResult;
  LPTSTR       lpszCommandLn;
  TCHAR        szDirectoryPath[_MAX_PATH];
  HWND         hHelpWnd;
  static       LARGE_INTEGER AppCompatFlag;
  static       TCHAR  szCurDir[MAX_PATH];

  g_hInstance = hInstance;
  // For Unicode
  lpszCommandLn = GetCommandLine();
  pStr = (TCHAR*)malloc( sizeof(TCHAR) * ( lstrlen((LPCTSTR)lpszCommandLn) + 1) );
  if(pStr != NULL)
  {
    lstrcpy(pStr, (LPCTSTR)lpszCommandLn);
    pCh = pStr;
  }
  else{
      return 0;
  }
  // Skip till the first delimiter
  while(*pCh != TEXT('-') ){
       if(*pCh == TEXT('\0') )
         break;
       pCh++;
  }

  if(*pCh == TEXT('-') )
  {
      pCh++;                             /* If '-' is found, skip to the next
                                            character */
    if(*pCh != TEXT('\0') ){
      do
      {
       pCh++;
       pNextWord =  GetNextWord(&fEnd,pCh);
       switch(LOWORD( CharLower((LPTSTR)*(pCh - 1))) )
       {

        case TEXT('d'):
                                         /* For Disable Heap look-aside */
              fDisableHeapLookAside = TRUE;
              break;

        case TEXT('k'):
                                         /* For Keep the Registry settings */
              fKeepRegistrySetting = TRUE;
              break;

        case TEXT('g'):
                                         /* For GetDiskFreespace in AppCompatGoo registry setting */
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |= KACF_GETDISKFREESPACE;
              break;

#ifdef EXTRA_APP_COMPAT
        case TEXT('f'):                // Pre-Windows 2000 Free Threading Model(FTM).
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |= KACF_FTMFROMCURRENTAPT;
              break;

        case TEXT('o'):
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |=KACF_OLDGETSHORTPATHNAME;
#endif

      case TEXT('t'):
                                         /* For Disable Heap look-aside */
              fSetTemp = TRUE;
              g_fAppCompatGoo = TRUE;
              AppCompatFlag.LowPart |=KACF_GETTEMPPATH;
              break;

      case TEXT('v'):
             SkipBlanks(pNextWord);
             VersionNum = TextToInt((LPCTSTR)pCh) - 1;
             if(VersionNum >= MAXVERNUM) {

               fHelpDisplay = TRUE;
               GetHelpPath(szDirectoryPath);
               hHelpWnd = HtmlHelp(NULL, szDirectoryPath, HH_DISPLAY_TOPIC,
                                              (DWORD_PTR)IDHH_CMDSYNTAX );
               while(IsWindow(hHelpWnd) )
                     Sleep(200);

                return 0;
               //break;
             }
             // Set the appcompatgoo flag .
             if(VersionNum <= (MAXVERNUM - 1)){
                g_fAppCompatGoo = TRUE;
                AppCompatFlag.LowPart |= KACF_VERSIONLIE;
             }

             break;

      case TEXT('x'): // NOTE: To pass command line parameters to the App. pass it in " " after
                     //        -x .  Eg. apcompat -x"yyy.exe " ..Command line params..blah..blah..

            SkipBlanks(pNextWord);
            AppName = (TCHAR*)malloc(sizeof(TCHAR) * ( lstrlen(pCh) + 1) );
            if(AppName != NULL)
              lstrcpy(AppName,pCh);

            break;

      case TEXT('h'):
      default :

            GetHelpPath(szDirectoryPath);
            hHelpWnd = HtmlHelp(GetDesktopWindow(), szDirectoryPath, HH_DISPLAY_TOPIC,
                                              (DWORD_PTR)IDHH_CMDSYNTAX );
          // Loop till the Help window exists.
            while(IsWindow(hHelpWnd) )
                  Sleep(200);

            if(AppName)
              free(AppName);
             return 0;

      } // End switch

      if(fEnd == FALSE)
        pCh = pNextWord+1;

    }while( FALSE == fEnd);
  }

     if((AppName == NULL) ||
         lstrlen(AppName) == 0)/* Return if no Application name given */
     {
           if(FALSE == fHelpDisplay ){
               GetHelpPath(szDirectoryPath);
               hHelpWnd = HtmlHelp(NULL, szDirectoryPath, HH_DISPLAY_TOPIC,
                                              (DWORD_PTR)IDHH_CMDSYNTAX );
               while(IsWindow(hHelpWnd) )
                     Sleep(200);

            }
        return 0;
     }


    memset(szCommandLine, 0, MAX_PATH);
    GetFileExtension(AppName,szTitle,szCommandLine);
    GetDirectoryPath(AppName, szCurDir);
    SetCurrentDirectory(szCurDir);

    if(fDisableHeapLookAside)
    {
       SetRegistryVal(szTitle,TEXT("DisableHeapLookAside"), TEXT("1"),REG_SZ );
    }
  else{
       CheckAndDeleteKey(szTitle,FALSE);
     } //End Else

  if(fSetTemp){
    SetTempPath();
  }

  if(!fKeepRegistrySetting)
      g_fNotPermanent = TRUE;
  if(g_fAppCompatGoo)
   MakeAppCompatGoo(AppName,&AppCompatFlag,VersionNum);

   if(SetEnvironmentVariable(TEXT("_COMPAT_VER_NNN"), pVersionVal[VersionNum]) == 0)
     {
       if( ERROR_ENVVAR_NOT_FOUND != GetLastError() )
         DetailError( GetLastError() );
     }

  // Execute the application.
  if(fKeepRegistrySetting)
    ExecuteApp(NULL, AppName,szTitle,szCommandLine,FALSE);
  else{
    ExecuteApp(NULL, AppName,szTitle,szCommandLine,TRUE);
    }

   if(AppName)
     free(AppName);
   if(pStr)
     free(pStr);

   GlobalFree(g_lpPrevRegSettings);
   return 0;
}

     /* Create a MODAL Dialog */
     DialogBox(hInstance, TEXT("DialogProc"),(HWND)NULL, DialogProc);

    while(GetMessage(&msg, NULL, 0, 0))
    {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
    }
  return (int)msg.wParam ;
}


/* Dialog procedure... */
INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
 int              dCharCnt,indx,length;
 TCHAR            EditCtrlBuf[_MAX_PATH];
 static int       BufCnt;
 TCHAR            FileBuf[_MAX_PATH];
 TCHAR            FileTitle[_MAX_PATH],szCommandLine[MAX_PATH];
 TCHAR            szDirectoryPath[_MAX_PATH];
 static HANDLE    hEditCtrl;
 static HANDLE    hRadioBtn;
 static HANDLE    hBrowseBtn;
 static HANDLE    hLaunchBtn,hCheck1,hCheck2,hCheck3,hCheck4,hDCOMFTM,hOldPathName;
 static const TCHAR*    pEnvVal = NULL;
 OPENFILENAME     ofn;
 HKEY             hKey;
 TCHAR            szTitle[MAXTITLE],szKeyName[MAXKEY],szSubKey[MAXKEY];
 TCHAR            szFileName[_MAX_PATH];
 DWORD            dwEnvSetError;
 static LARGE_INTEGER    AppCompatFlag ;
 static UINT             uOsVerID = IDD_NONE;
 static BOOL      fOfnFlag = FALSE;
 static TCHAR     szCurDir[MAX_PATH];

  switch(uMsg)
  {
   case WM_INITDIALOG:

        hEditCtrl = GetDlgItem(hwndDlg, IDD_APPEDIT);     /* To be used when reading and
                                                             writing from the EDIT control */
        hRadioBtn  = GetDlgItem(hwndDlg, IDD_NONE);
        SendMessage(hRadioBtn , BM_SETCHECK, 1, 0L);
        SetFocus(hEditCtrl);
        return TRUE;

    case WM_CLOSE:
         EndDialog(hwndDlg, 0);
         break;

    case WM_DESTROY:
         PostQuitMessage(0);
         return 0;

    case WM_COMMAND:

       if(FALSE==fOfnFlag){
         if( LOWORD(wParam) == IDD_APPEDIT ){
           if( HIWORD(wParam) == EN_UPDATE){
             GetWindowText(hEditCtrl,EditCtrlBuf, _MAX_PATH);
             /* Check whether the *.exe is present in Registry */
             GetFileExtension(EditCtrlBuf,szTitle,szCommandLine);
             if(CheckAndDeleteKey(szTitle,TRUE) == ERROR_SUCCESS){
               /* The executable already has an entry
                  in the registry */

                  hCheck1  = GetDlgItem(hwndDlg, IDD_CHECK1);
                  SendMessage(hCheck1,BM_SETCHECK, 1, 0L);
             }
             else{ // Uncheck if previously checked only.
                  if( SendMessage(hCheck1,BM_GETCHECK, 0, 0L) )
                     SendMessage(hCheck1,BM_SETCHECK, 0, 0L);
             }
           }
         }
        }

         switch(wParam)
         {
          case IDCANCEL:
               EndDialog(hwndDlg, 0);
               break;

          case IDD_HELP:
               GetHelpPath(szDirectoryPath);
               lstrcat(szDirectoryPath, TEXT("::/topics/appcomp.htm>mainwin") );
               HtmlHelp(GetDesktopWindow(), szDirectoryPath, HH_DISPLAY_TOPIC,(DWORD_PTR) NULL);
               break;
        /*
           For the Browse button, Open the FileOpen dialog and get the
           application path.
           Display the path in the Edit box.

         */
          case IDD_BROWSE:
               GetDlgItemText(hwndDlg, IDD_APPEDIT, EditCtrlBuf, _MAX_PATH);
               memset(&ofn, 0, sizeof(OPENFILENAME) );
               FileBuf[0]         = TEXT('\0');
               /* Initialize the Ofn structure */
               ofn.lStructSize    = sizeof (OPENFILENAME) ;
               ofn.hwndOwner      = hwndDlg;
               ofn.lpstrFilter    = szFilter;
               ofn.lpstrFile      = FileBuf;
               ofn.nMaxFile       = _MAX_PATH ;
               ofn.lpstrInitialDir= EditCtrlBuf;
               ofn.Flags          = OFN_PATHMUSTEXIST |
                                    OFN_FILEMUSTEXIST;

              if( GetOpenFileName (&ofn) != 0){
               /* Got the file name ...*/
               // To put a '"' before and after what is typed...
                 if( (*FileBuf) != TEXT('\"') ){
                    memset(EditCtrlBuf, 0, MAX_PATH);
                    *(EditCtrlBuf) = TEXT('\"');
                    lstrcat(EditCtrlBuf, FileBuf);
                    lstrcat(EditCtrlBuf, TEXT("\""));
                    SetWindowText(hEditCtrl,EditCtrlBuf);
                  }
                 // Set the flag so that anything entered after this will not be taken over by
                 // the Edit control input...
                 fOfnFlag = TRUE;
                 /* Check whether the *.exe is present in Registry */

                  GetFileExtension(FileBuf,szTitle,szCommandLine);
                  if(CheckAndDeleteKey(szTitle,TRUE) == ERROR_SUCCESS){
                      /* The executable already has an entry
                         in the registry */
                      hCheck1  = GetDlgItem(hwndDlg, IDD_CHECK1);
                      SendMessage(hCheck1,BM_SETCHECK, 1, 0L);
                  }
                 /* At this pt. set focus on the 'LAUNCH' button */
                 hLaunchBtn = GetDlgItem(hwndDlg, IDD_LAUNCH);
                 SetFocus(hLaunchBtn);
              }

             break;

        /*
          When any of the Radio buttons in the OS version group is checked,
          get the version ID and store the corresponding COMPAT flag.. in the
          local variable.
         */
          case IDD_WIN95:
          case IDD_WIN98:
          case IDD_WINNT43:
          case IDD_WINNT44:
          case IDD_WINNT45:
          case IDD_NONE:
               if(wParam != IDD_NONE){
                 g_fAppCompatGoo = TRUE;
                 AppCompatFlag.LowPart |= KACF_VERSIONLIE;
               }
               uOsVerID = (UINT)(wParam - FIRSTBUTTON);
               CheckRadioButton(hwndDlg,(int)FIRSTBUTTON,(int)LASTBUTTON,(int)wParam);
               pEnvVal = pVersionVal[wParam - FIRSTBUTTON];
               break;

          case IDD_LAUNCH:
               dCharCnt = GetWindowTextLength( hEditCtrl );
               if(dCharCnt > 0){
                    /*
                       Go in only if something is present in the
                       EDIT box
                    */

                  if(GetWindowText(hEditCtrl, EditCtrlBuf, dCharCnt + 1) == 0){
                     DetailError(GetLastError() );
                  }
                  else{ /* Launch the APP using ShellExecuteEx */
                    memset(szCommandLine, 0, MAX_PATH);
                    GetFileExtension(EditCtrlBuf,szTitle,szCommandLine);
                    GetDirectoryPath(EditCtrlBuf, szCurDir);
                    SetCurrentDirectory(szCurDir);

                    hCheck1  = GetDlgItem(hwndDlg, IDD_CHECK1);
                    if( SendMessage(hCheck1, BM_GETSTATE, 0, 0L)){
                      /* The checkbox has been checked
                         - DisableHeapLookAside */

                       SetRegistryVal(szTitle, TEXT("DisableHeapLookAside"), TEXT("1"),REG_SZ );
                     }
                     else{
                       // If it is not thru the BROWSE button...user has got
                       // here by typing the path in the Edit Ctrl...

                         CheckAndDeleteKey(szTitle,FALSE);
                     }

                     hCheck2  = GetDlgItem(hwndDlg, IDD_CHECK2);
                     if( SendMessage(hCheck2, BM_GETSTATE, 0, 0L)){
                        // Short Temp path.
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |=KACF_GETTEMPPATH;
                        SetTempPath();
                     }

                     hCheck4 = GetDlgItem(hwndDlg, IDD_CHECK4);
                     if( SendMessage(hCheck4, BM_GETSTATE, 0, 0L) ){
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |= KACF_GETDISKFREESPACE;
                     }
               #ifdef EXTRA_APP_COMPAT
                     hDCOMFTM = GetDlgItem(hwndDlg, IDD_DCOMFTM);
                     if( SendMessage(hDCOMFTM, BM_GETSTATE, 0, 0L) ){
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |= KACF_FTMFROMCURRENTAPT;
                     }

                     hOldPathName = GetDlgItem(hwndDlg, IDD_OLDPATH);
                     if( SendMessage(hOldPathName, BM_GETSTATE, 0, 0L) ){
                        g_fAppCompatGoo = TRUE;
                        AppCompatFlag.LowPart |= KACF_OLDGETSHORTPATHNAME;
                     }
               #endif

                     hCheck3  = GetDlgItem(hwndDlg, IDD_CHECK3);
                     if( SendMessage(hCheck3, BM_GETSTATE, 0, 0L) == 0)
                       g_fNotPermanent = TRUE;

                     if(g_fAppCompatGoo)
                       MakeAppCompatGoo(EditCtrlBuf,&AppCompatFlag,uOsVerID);

                  /* Set the ENVIRONMENT Variable "_COMPAT_VER_NNN"
                     flag  with the version checked before calling
                     ShellExecuteEx()
                   */
                    if(SetEnvironmentVariable(TEXT("_COMPAT_VER_NNN"), pEnvVal) == 0){
                          dwEnvSetError = GetLastError();
                          if( ERROR_ENVVAR_NOT_FOUND != dwEnvSetError )
                             DetailError( GetLastError() );
                    }


                   if( g_fNotPermanent){
                      ExecuteApp(hwndDlg, EditCtrlBuf,szTitle,szCommandLine, TRUE);
                   }
                   else{
                         ExecuteApp(hwndDlg, EditCtrlBuf,szTitle,szCommandLine, FALSE);
                       }
                   EndDialog(hwndDlg, 0);
                 }
               }
             break;

          case IDD_CLOSE:
               EndDialog(hwndDlg, 0);
        }

    GlobalFree(g_lpPrevRegSettings);
    return TRUE;
  }
 return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparse.h ===
#ifndef APPPARSE_H
#define APPPARSE_H

#include <windows.h>
#include <stdio.h>

DWORD __stdcall AppParse(char* szAppName, FILE* pFile, bool fRaw, 
              bool fAPILogging, bool fRecurse, bool fVerbose, char* szSearchKey, 
              int iPtolemyID, HANDLE hEvent = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparsecui.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    appparsecui.cpp

 Abstract:

    Command line interface for appparse

    
 History:

    06/27/2000 t-michkr  Created

--*/
#include <windows.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <shfolder.h>
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include "appparse.h"

// These are needed for command line compiling
#define stricmp     _stricmp
#define strnicmp    _strnicmp
#define getche      _getche

// Print a help screen to the console.
void PrintHelp()
{
    printf("Display application import information.\n");
    printf("APPPARSE target [outputfile]");
    printf("[/C] [/R] [/S] [/A] [/V] [/K:func]\n");
    printf("  target     Specifies the target filename or directory to be profiled.\n");
    printf("    A valid directory or binary file must be specified.  In the case of:\n");
    printf("    DIRECTORY   -   All binary files in the directory will be profiled.\n");
    printf("    FILENAME    -   The file and its dependencies will be profiled.\n");
    printf("\n");
    printf("  outputfile Specifies output file name.  Default is [targetfile].XML.\n");
    printf("  /C         Ignore output file, and send output to console.\n");
    printf("  /R         Raw format. (No XML tags, default for non-XML output file.)\n");
    printf("  /S         Profile subfolders.  Only valid when target is a directory.\n");
    printf("  /A         API logging only.\n");

    printf("\n");
    printf("Advanced Features\n");
    printf("  /V       Verbose\n");
    printf("  /K:func    Only return those functions matching the key func (case insensitive, wildcards)\n");
    printf("\n\n");
    printf("Example: appparse \"C:\\Program Files\\foo /V /K:Create*\n");
}

// Get a default Output file name for a path, trim dir and extension info.
char* GetOutputFileName(const char* szPath)
{
    int iOffset = strlen(szPath);
    char* szTemp = 0;

    // If its a drive, use the volume name for output file.
    if(szPath[strlen(szPath)-1] == ':' ||
        (szPath[strlen(szPath)-1] == '\\' &&
        szPath[strlen(szPath)-2] == ':'))
    {
        char szBuffer[MAX_PATH];
        if(GetVolumeInformation(szPath, szBuffer, MAX_PATH, 0, 0, 0, 0, 0))
        {
            szTemp = new char[strlen(szBuffer)+strlen(".xml")+1];
            strcpy(szTemp, szBuffer);
            strcat(szTemp, ".xml");
            return szTemp;
        }
    }

    for(; iOffset >= 0; iOffset--)
    {
        if(szPath[iOffset] == '\\')
        {
            if(iOffset == static_cast<int>(strlen(szPath)))
            {
                strcpy(szTemp, szPath);
                break;
            }
            szTemp = new char[strlen(szPath)-iOffset + 5];
            strcpy(szTemp, &szPath[iOffset+1]);
            break;
        }
    }

    if(iOffset < 0)
    {
        szTemp = new char[strlen(szPath) + 5];
        strcpy(szTemp, szPath);
    }

    for(iOffset = strlen(szTemp); iOffset >= static_cast<int>((strlen(szTemp)-4)); iOffset--)
    {
        if(szTemp[iOffset] == '.')
        {
            szTemp[iOffset] = '\0';
            break;
        }
    }

    strcat(szTemp, ".xml");
    return szTemp;
}

int __cdecl main(int argc, char** argv)
{
    char* szAppName, szOutput[MAX_PATH];
    bool fRaw = false, fAPILogging = false, fVerbose = false,
        fRecurse = false;
    char* szSearch = "*";
    FILE* pFile = 0;

    if(argc < 2)
    {
        PrintHelp();
        return 0;
    }

    if(strnicmp(argv[1], "/?", strlen("/?"))==0)
    {
        PrintHelp();
        return 0;

    }

    // Get command line options
    szAppName = argv[1];    

    int i = 2;

    // Check for output file
    if(argc > 2 && *argv[i] != '/')
    {
        // Output file specified.
        strcpy(szOutput,argv[i]);

        if(!strchr(szOutput, '.'))
            strcat(szOutput, ".xml");
        else
        {
            // Switch to raw output if non XML extension specified.
            if(szOutput[strlen(szOutput)-4] != '.'
                || szOutput[strlen(szOutput)-3] != 'x'
                || szOutput[strlen(szOutput)-2] != 'm'
                || szOutput[strlen(szOutput)-1] != 'l')
            {
                fRaw = true;
            }
        }

        i++;
    }
    else
    {
        // No output specified, just use appname
        strcpy(szOutput,GetOutputFileName(szAppName));
    }


    // Loop through all command line options.
    for(; i < argc; i++)
    {
        // Output to console
        if(strnicmp(argv[i], "/C", 2)==0)
        {
            pFile = stdout;
        }
        // Raw mode, no XML tags.
        else if(strnicmp(argv[i], "/R", 2)==0)
        {
            fRaw = true;
        }
        // Recurse into subdirectories for directory profiling
        else if(strnicmp(argv[i], "/S", 2)==0)
        {
            fRecurse = true;
        }
        // Do not print import module info, just functions.
        else if(strnicmp(argv[i], "/A", 2)==0)
        {
            fAPILogging = true;
        }
        // Verbose mode, print out extended information
        else if(strnicmp(argv[i], "/V", 2)==0)
        {
            fVerbose = true;
        }
        // Use a search key
        else if(strnicmp(argv[i], "/K:", 3)==0)
        {
            if(strlen(argv[i]) == 3)
            {
                if(i == (argc - 1))
                {
                    printf("Missing search string\n");
                    return 0;
                }
                else
                {
                    szSearch = argv[i+1];
                    i++;
                }
            }
            else
            {
                szSearch = &((argv[i])[3]);
            }
        }
        // Print help
        else if(strnicmp(argv[i], "/?", 2)==0)
        {
            PrintHelp();
            return 0;
        }
        else
        {
            printf("Unrecognized option, %s\n", argv[i]);
            return 0;
        }

    }

       // If pFile wasn't already set to stdout
    if(!pFile)
    {
        // Check if it already exists
        if(GetFileAttributes(szOutput) != -1)
        {
            printf("Output file already exists, overwrite? ");

            if(getche() != 'y')
                return 0;
        }

        // Try to open file
        pFile = fopen(szOutput, "wt+");        
        if(!pFile)
        {
            printf("\nUnable to open output file %s\n", szOutput);

            // Try in My Documents folder
            char szBuffer[MAX_PATH+1];
            HRESULT hr = SHGetFolderPath(0, CSIDL_PERSONAL,0, 
                0, szBuffer);

            if(SUCCEEDED(hr))
            {
                if((strlen(szBuffer) + strlen(szOutput) + 1) < MAX_PATH)
                {
                    strcat(szBuffer, "\\");
                    strcat(szBuffer, szOutput);                    

                    if(GetFileAttributes(szBuffer) != -1)
                    {
                        printf("%s already exists, overwrite? ", szBuffer);
                        if(getche() != 'y')
                            return 0;
                    }
                    pFile = fopen(szBuffer, "wt+");
                    if(!pFile)
                    {
                        printf("\nUnable to open output file %s\n", szBuffer);
                        hr = E_FAIL;
                    }
                    else
                        strcpy(szOutput, szBuffer);
                }
                else
                    hr = E_FAIL;
            }
            
            if(FAILED(hr))
            {
                // Try in "temp" directory
                char szBuffer[MAX_PATH + 1];
                if(GetTempPath(MAX_PATH, szBuffer))
                {
                    if((strlen(szBuffer) + strlen(szOutput) + 1) < MAX_PATH)
                    {
                        strcat(szBuffer, szOutput);                        
                        if(GetFileAttributes(szBuffer) != -1)
                        {
                            printf("%s already exists, overwrite? ", szBuffer);
                            if(getche() != 'y')
                                return 0;
                        }
                        
                        pFile = fopen(szBuffer, "wt+");
                        if(!pFile)
                        {
                            printf("\nUnable to open output file\n");
                            return 0;
                        }
                        else
                            strcpy(szOutput, szBuffer);
                    }
                    else
                    {
                        printf("\nUnable to open output file\n");
                        return 0;
                    }
                }
                else
                {
                    printf("\nUnable to open output file\n"); 
                    return 0;
                }
            }
        }
    }

    printf("\nProfiling . . .\n");
    DWORD dwError = AppParse(szAppName, pFile, fRaw, fAPILogging, fRecurse, fVerbose, 
        szSearch, 0);
    
    switch(dwError)
    {    
    case ERROR_SUCCESS:
        if(pFile != stdout)
            printf("Output successfully written to %s.\n", szOutput);
        break;
    case ERROR_FILE_NOT_FOUND:
        printf("The system was not able to find the file specified.\n");
        break;
    default:
        printf("Unknown error\n");
        break;
    }

    if(pFile && pFile != stdout)
        fclose(pFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\appparse.h ===
#ifndef APPPARSE_H
#define APPPARSE_H

#include <windows.h>
#include <stdio.h>

DWORD __stdcall AppParse(char* szAppName, FILE* pFile, bool fRaw, 
              bool fAPILogging, bool fRecurse, bool fVerbose, char* szSearchKey, 
              int iPtolemyID, HANDLE hEvent = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparse.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    appparse.cpp

 Abstract:

    Core Engine for dumping importing information from DLL's
    and executables into an XML file

    Used by command line appparse and web-based appparse

    
 History:

    06/07/2000 t-michkr  Created

--*/

//#define PJOB_SET_ARRAY int

#include "stdafx.h"

#include <windows.h>
#include <delayimp.h>
#include <shlwapi.h>
#include <sfc.h>
#include <lmcons.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <new.h>
#include "acFileAttr.h"


// These are needed for command line compiling
#define stricmp     _stricmp

// Global heap for AppParse.  If 0, Process Heap is used instead.
HANDLE g_hHeap = 0;

// Global search string
char* g_szSearch = "*";

// Whether we are in "verbose" mode, or not.
bool g_fVerbose = false;

// To sort output by DLLs
bool g_fAPILogging = false;

// True if no XML tags are to be printed, false otherwise
bool g_fRaw = false;

// Whether to recurse into subdirectories.
bool g_fRecurse = false;

// Current path relative to start, used by CModule
char g_szCurrentPath[MAX_PATH] = {'\0'};

// Returns true if szFileName is a system DLL (like gdi32, user32, etc.)
bool IsSystemDLL(const char* szFileName);

// Resolve a linker name to a "normal" name (unmangle C++ names, etc.)
void LinkName2Name(char* szLinkName, char* szName);

// Just do indentation, save repetitious code
void Indent(int iLevel, FILE* pFile = stdout);

// Check if function matches global search string
bool MatchFunction(const char* szFunc);

// Go through a directory and profile EXE's.
void ProfileDirectory(char* szDirectory, HANDLE hEvent);

void* __cdecl operator new(size_t size);
void __cdecl operator delete(void* pVal);

// Replace XML reserved characters like > with &gt
void WriteXMLOKString(char* szString, FILE* pFile);

// Parsing history for modules
class CModuleParseStack
{
private:
    struct SNode
    {
        char* szName;
        SNode* pNext;

        SNode()
        {
            szName  = 0;
            pNext   = 0;            
        }

        ~SNode()
        {
            if(szName)
            {
                delete szName;
                szName = 0;
            }
        }
    };
    SNode* m_pList;

public:

    // Constructor, setup empty list.
    CModuleParseStack()
    {
        m_pList = 0;
    }
    
    // Add a name to the top of the parse stack
    void PushName(char* szName)
    {
        assert(!IsBadReadPtr(szName, 1));
        SNode* pNode = new SNode;
        pNode->szName = new char[strlen(szName)+1];
        strcpy(pNode->szName, szName);
        pNode->pNext = m_pList;
        m_pList = pNode;
    }

    // Remove a name from the top of the parse stack
    void Pop()
    {
        assert(m_pList);
        SNode* pTemp = m_pList->pNext;
        delete m_pList;
        m_pList = pTemp;
    }

    // Return true if module has already been parsed
    bool CheckModuleParsed(char* szName)
    {
        assert(!IsBadReadPtr(szName, 1));
        SNode* pNode = m_pList;
        while(pNode)
        {
            if(stricmp(pNode->szName, szName) == 0)
                return true;
            pNode = pNode->pNext;
        }

        return false;
    }

    bool IsEmpty()
    {
        return (m_pList == 0);
    }

    void ClearParseHistory()
    {
        SNode* pNode = m_pList;
        while(pNode)
        {
            SNode* pNext = pNode->pNext;

            delete pNode;
            pNode = pNext;
        }
        m_pList = 0;
    }
};

// CFunction, an imported function and associated information.
class CFunction
{
private:
    // Name of function (if imported by name)
    char* m_szName;

    // Name of function actually pointed to.
    char* m_szForwardName;

    // Ordinal, older style importing
    int m_iOrdinal;

    // Quick lookup info
    int m_iHint;

    // Address of function, if bound
    DWORD m_dwAddress;

    // Whether this function is a delayed import or not.
    bool m_fDelayed;

    // Next function in list
    CFunction* m_pNext;

    // No default construction or copying allowed
    CFunction();
    CFunction operator=(const CFunction&);

public:
    CFunction(char* szName, int iHint, int iOrdinal, DWORD dwAddress, 
        bool fDelayed)
    {
        assert(!IsBadReadPtr(szName, 1));
        m_szName = new char[strlen(szName)+1];
        strcpy(m_szName, szName);
        m_iOrdinal = iOrdinal;
        m_iHint = iHint;
        m_dwAddress = dwAddress;
        m_pNext = 0;
        m_fDelayed = fDelayed;
        m_szForwardName = 0;
    }

    CFunction(const CFunction& fn)
    {
        m_szName = new char[strlen(fn.m_szName)+1];
        strcpy(m_szName, fn.m_szName);
        m_iOrdinal = fn.m_iOrdinal;
        m_iHint = fn.m_iHint;
        m_dwAddress = fn.m_dwAddress;
        m_pNext = 0;
        m_fDelayed = fn.m_fDelayed;

        if(fn.m_szForwardName)
        {
            m_szForwardName = new char[strlen(fn.m_szForwardName)+1];
            strcpy(m_szForwardName, fn.m_szForwardName);
        }
        else
            m_szForwardName = 0;
    }
        
    ~CFunction()
    {
        if(m_szName)
        {
            delete m_szName;
            m_szName = 0;
        }

        if(m_szForwardName)
        {
            delete m_szForwardName;
            m_szForwardName = 0;
        }
    }

    CFunction* Next()
    { return m_pNext; }

    char* Name()
    { return m_szName; }

    void SetForwardName(char* szForward)
    {
        assert(!IsBadReadPtr(szForward, 1));
        m_szForwardName = new char[strlen(szForward)+1];
        strcpy(m_szForwardName, szForward);
    }

    void SetNext(CFunction* pFunc)
    {
        assert(pFunc == 0 || !IsBadReadPtr(pFunc, 1));
        m_pNext = pFunc;
    }

    // Display function info, either to console
    // or to XML file.
    static void WriteHeader(int iIndentLevel, FILE* pFile);
    void WriteFunction(int iIndentLevel, FILE* pFile);
};

// COrdinalImport
// A function imported by ordinal, to be resolved to a CFunction
class COrdinalImport
{
private:
    int m_iOrdinal;
    COrdinalImport* m_pNext;
    bool m_fDelayed;

    COrdinalImport();
    COrdinalImport(const COrdinalImport&);
    COrdinalImport& operator = (const COrdinalImport&);

public:
    COrdinalImport(int iOrd, bool fDelayed = false)
    {
        m_iOrdinal = iOrd;
        m_fDelayed = fDelayed;
    }

    int GetOrdinal()
    { return m_iOrdinal;}
    
    bool GetDelayed()
    { return m_fDelayed; }

    COrdinalImport* Next()
    { return m_pNext; }

    void SetNext(COrdinalImport* pNext)
    { m_pNext = pNext; }
};

// CModule, an executable image with imports
class CModule
{
    friend class CGlobalModuleList;
private:
    // The name of this module (in the form path\foo.exe)
    char* m_szName;

    // The name of this module relative to the starting path
    char* m_szFullName;

    // Base pointer of the image in memory.
    void* m_pvImageBase;

    // DLL's imported by this module.
    CModule* m_pImportedDLLs;

    // Functions imported from this module by its parent.
    CFunction* m_pFunctions;

    // Functions imported by ordinal from this module
    COrdinalImport* m_pOrdinals;

    // Image headers
    PIMAGE_OPTIONAL_HEADER  m_pioh;
    PIMAGE_SECTION_HEADER   m_pish;
    PIMAGE_FILE_HEADER      m_pifh;

    // Next module in a list
    CModule* m_pNext;

    // Text description of any errors that may have occurred
    char* m_szError;

    // Whether or not this module is an OS module
    bool m_fSystem;    
    
    // Version info
    WORD m_wDosDate;
    WORD m_wDosTime;

    int m_nAttrCount;
    char** m_szAttrValues;
    char** m_szAttrNames;

    bool WalkImportTable();
    bool WalkDelayImportTable();

    static void InsertFunctionSorted(CFunction* pFunc, CFunction** ppList);

    bool ResolveForwardedFunctionsAndOrdinals();
    
    bool ParseImportTables();

    void InsertOrdinal(int iOrdinal, bool fDelayed = false);

    CModule* FindChild(char* szName);

    bool Empty();

    void GetAllFunctions(CFunction** ppFunctionList);

    void* RVAToPtr(const void* pAddr)
    { return RVAToPtr(reinterpret_cast<DWORD>(pAddr)); }

    void* RVAToPtr(DWORD dwRVA);

    void GetFileVerInfo(HANDLE hFile, char* szFileName);

  
public:
    CModule(char* szName);
    ~CModule();

    bool ParseModule(HANDLE hEvent);
    void InsertChildModuleSorted(CModule* pcm);

    // Functions to write module info to either the console or an XML file
    void WriteModule(bool fTopLevel, int iIndentLevel, FILE* pFile);
};

// List of all top-level modules being profiled
class CGlobalModuleList
{
private:
    CModule* m_pModules;
public:
    CGlobalModuleList()
    {
        m_pModules = 0;
    }
    ~CGlobalModuleList()
    {
        Clear();        
    }

    void Clear()
    {
        CModule* pMod = m_pModules;
        while(pMod)
        {
            CModule* pNext = pMod->m_pNext;
            delete pMod;
            pMod = pNext;
        }
        m_pModules = 0;
    }

    void InsertModuleSorted(CModule* pMod)
    {
        assert(!IsBadReadPtr(pMod, 1));
        // Special case, insert at front
        if(m_pModules == 0
            || stricmp(m_pModules->m_szFullName, pMod->m_szFullName) > 0)
        {
            pMod->m_pNext = m_pModules;
            m_pModules = pMod;
            return;
        }
        CModule* pPrev = m_pModules;
        CModule* pTemp = m_pModules->m_pNext;

        while(pTemp)
        {
            if(stricmp(pTemp->m_szFullName, pMod->m_szFullName) > 0)
            {
                pMod->m_pNext = pTemp;
                pPrev->m_pNext = pMod;;
                return;
            }
            pPrev = pTemp;
            pTemp = pTemp->m_pNext;
        }

        // Insert at end
        pMod->m_pNext = 0;
        pPrev->m_pNext = pMod;;
    }

    void Write(FILE* pFile, char* szProjectName, int iPtolemyID)
    {
        if(!g_fRaw)
        {
            fprintf(pFile, "<APPPARSERESULTS>\n");
            fprintf(pFile, "<PROJECT NAME=\"%s\" ID=\"%d\">\n", 
                szProjectName, iPtolemyID);
        }

        CModule* pMod = m_pModules;
        while(pMod)
        {
            pMod->WriteModule(true, 0, pFile);
            pMod = pMod->m_pNext;
        }

        if(!g_fRaw)
        {
            fprintf(pFile, "</PROJECT>\n");
            fprintf(pFile, "</APPPARSERESULTS>\n");
        }
    }    
};

// Global parsing history
CModuleParseStack g_ParseStack;

// Empty global module, containing all modules parsed
CGlobalModuleList g_modules;

CModule::CModule(char* szName)
{
    assert(!IsBadReadPtr(szName, 1));
    m_szName = new char[strlen(szName)+1];
    strcpy(m_szName, szName);

    WIN32_FIND_DATA ffd;
    
    // Only give it the full relative path if it is in this directory
    // If elsewhere, give it just the filename.
    HANDLE hSearch = FindFirstFile(szName, &ffd);
    if(hSearch == INVALID_HANDLE_VALUE)
    {
        m_szFullName = new char[strlen(m_szName) + 1];
        strcpy(m_szFullName, m_szName);
    }
    else
    {
        m_szFullName = new char[strlen(m_szName) + strlen(g_szCurrentPath)+1];
        strcpy(m_szFullName, g_szCurrentPath);
        strcat(m_szFullName, m_szName);
        FindClose(hSearch);
    }

    m_pvImageBase = 0;
    m_pImportedDLLs = 0;
    m_pFunctions = 0;
    m_pOrdinals = 0;
    m_pioh = 0;
    m_pish = 0;
    m_pifh = 0;
    m_pNext = 0;
    m_szError = 0;
    m_fSystem = false;
    m_nAttrCount = 0;
    m_szAttrValues = 0;
    m_szAttrNames = 0;
    m_wDosDate = 0;
    m_wDosTime = 0;
}

CModule::~CModule()
{
    if(m_szName)
    {
        delete m_szName;
        m_szName = 0;
    }

    if(m_szFullName)
    {
        delete m_szFullName;
        m_szFullName = 0;
    }    

    CFunction* pFunc = m_pFunctions;
    while(pFunc)
    {
        CFunction* pNext = pFunc->Next();
        delete pFunc;
        pFunc = pNext;
    }
    m_pFunctions = 0;
    
    COrdinalImport* pOrd = m_pOrdinals;
    while(pOrd)
    {
        COrdinalImport* pNext = pOrd->Next();
        delete pOrd;
        pOrd = pNext;
    }
    m_pOrdinals = 0;

    for(int i = 0; i < m_nAttrCount; i++)
    {
        if(m_szAttrNames)
        {
            if(m_szAttrNames[i])
            {
                delete m_szAttrNames[i];
                m_szAttrNames[i] = 0;
            }
        }
        
        if(m_szAttrValues)
        {
            if(m_szAttrValues[i])
            {
                delete m_szAttrValues[i];
                m_szAttrValues[i] = 0;
            }
        }

    }
    if(m_szAttrNames)
    {
        delete m_szAttrNames;
        m_szAttrNames = 0;
    }

    if(m_szAttrValues)
    {
        delete m_szAttrValues;
        m_szAttrValues = 0;
    }
}

// Return true no functions are imported from this module,
// or any of its children modules.
bool CModule::Empty()
{
    if(m_pFunctions != 0 || m_pOrdinals != 0)
        return false;

    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        if(!pMod->Empty())
            return false;
        pMod = pMod->m_pNext;
    }
    return true;
}

// Convert a relative virtual address to an absolute address
void* CModule::RVAToPtr(DWORD dwRVA)
{
    assert(!IsBadReadPtr(m_pifh, sizeof(*m_pifh)));
    assert(!IsBadReadPtr(m_pish, sizeof(*m_pish)));
    assert(!IsBadReadPtr(m_pvImageBase, 1));

    PIMAGE_SECTION_HEADER pish = m_pish;

    // Go through each section
    for (int i = 0; i < m_pifh->NumberOfSections; i++)
    {
        // If it's in this section, computer address and return it.
        if ((dwRVA >= pish->VirtualAddress) &&
            (dwRVA < (pish->VirtualAddress + pish->SizeOfRawData)))
        {
            void* pAddr = 
                reinterpret_cast<void*>(reinterpret_cast<DWORD>(m_pvImageBase) + 
                pish->PointerToRawData + dwRVA - pish->VirtualAddress);
            return pAddr;
        }
        pish++;
    }

    // This indicates an invalid RVA, meaning an invalid image, so
    // throw an exception
    throw;
    return 0;
}

// Return a pointer to the first child matching szName, false otehrwise
CModule* CModule::FindChild(char* szName)
{
    assert(!IsBadReadPtr(szName, 1));
    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        if(stricmp(pMod->m_szName, szName)==0)
            return pMod;

        pMod = pMod->m_pNext;
    }
    return 0;
}

// Add an ordinal import to the module.
void CModule::InsertOrdinal(int iOrdinal, bool fDelayed)
{
    COrdinalImport* pNew = new COrdinalImport(iOrdinal, fDelayed);
 
    pNew->SetNext(m_pOrdinals);
    m_pOrdinals = pNew;
}

// Add an imported function to a function list.
void CModule::InsertFunctionSorted(CFunction* pFunc, CFunction** ppList)
{
    // Special case, insert at front
    if((*ppList)== 0
        || stricmp((*ppList)->Name(), pFunc->Name()) > 0)
    {
        pFunc->SetNext(*ppList);
        (*ppList) = pFunc;
        return;
    }
    CFunction* pPrev = *ppList;
    CFunction* pTemp = (*ppList)->Next();

    while(pTemp)
    {
        // Don't insert duplicates.  This is mainly for API logging only.
        if(strcmp(pTemp->Name(), pFunc->Name())==0)
            return;

        if(stricmp(pTemp->Name(), pFunc->Name()) > 0)
        {
            pFunc->SetNext(pTemp);
            pPrev->SetNext(pFunc);
            return;
        }        

        pPrev = pTemp;
        pTemp = pTemp->Next();
    }

    // Insert at end
    pFunc->SetNext(0);
    pPrev->SetNext(pFunc);
}

// Add a child module to this module.
void CModule::InsertChildModuleSorted(CModule* pcm)
{
    // Special case, insert at front
    if(m_pImportedDLLs == 0
        || stricmp(m_pImportedDLLs->m_szName, pcm->m_szName) > 0)
    {
        pcm->m_pNext = m_pImportedDLLs;
        m_pImportedDLLs = pcm;
        return;
    }
    CModule* pPrev = m_pImportedDLLs;
    CModule* pTemp = m_pImportedDLLs->m_pNext;

    while(pTemp)
    {
        if(stricmp(pTemp->m_szName, pcm->m_szName) > 0)
        {
            pcm->m_pNext = pTemp;
            pPrev->m_pNext = pcm;;
            return;
        }
        pPrev = pTemp;
        pTemp = pTemp->m_pNext;
    }

    // Insert at end
    pcm->m_pNext = 0;
    pPrev->m_pNext = pcm;;
}

// Add all functions imported from this module to the function list
// Used mainly for API logging.
void CModule::GetAllFunctions(CFunction** ppFunctionList)
{
    CFunction* pFunc = m_pFunctions;
    
    while(pFunc)
    {
        // Copy pFunc
        CFunction* pNew = new CFunction(*pFunc);
        InsertFunctionSorted(pNew, ppFunctionList);

        pFunc = pFunc->Next();
    }

    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        pMod->GetAllFunctions(ppFunctionList);
        pMod = pMod->m_pNext;
    }
}

// Go through a modules export table and get forwarding information
// and resolve ordinal imports to name.
bool CModule::ResolveForwardedFunctionsAndOrdinals()
{
    // Get virtual address of export table
    DWORD dwVAImageDir = 
        m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    
    // Get export table info
    PIMAGE_EXPORT_DIRECTORY pied = 
        reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(RVAToPtr(dwVAImageDir));

    DWORD* pdwNames = reinterpret_cast<DWORD*>(RVAToPtr(pied->AddressOfNames));

    WORD* pwOrdinals = reinterpret_cast<WORD*>(RVAToPtr(pied->AddressOfNameOrdinals));

    DWORD* pdwAddresses = reinterpret_cast<DWORD*>(RVAToPtr(pied->AddressOfFunctions));

    // Go through each entry in the export table
    for(unsigned uiHint = 0; uiHint < pied->NumberOfNames; uiHint++)
    {
        // Get function name, ordinal, and address info.
        char* szFunction = reinterpret_cast<char*>(RVAToPtr(pdwNames[uiHint]));
        int ordinal = pied->Base + static_cast<DWORD>(pwOrdinals[uiHint]);
        DWORD dwAddress = pdwAddresses[ordinal-pied->Base];
        char* szForward = 0;
        
        // Check if this function has been forwarded to another DLL
        // Function has been forwarded if address is in this section.
        // NOTE: The DEPENDS 1.0 source says otherwise, but is incorrect.
        if( (dwAddress >= dwVAImageDir) &&
            (dwAddress < (dwVAImageDir + 
            m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)))
            szForward = reinterpret_cast<char*>(RVAToPtr(dwAddress));

        // Check if we have an ordinal import refering to this
        COrdinalImport* pOrd = m_pOrdinals;
        CFunction* pFunc = 0;
        
        // See if we have a matching ordinal import.
        while(pOrd)
        {
            if(pOrd->GetOrdinal() == ordinal)
                break;
            pOrd = pOrd->Next();
        }

        if(pOrd != 0)
        {
            char szTemp[1024];

            // Unmangle forwarded name.
            LinkName2Name(szFunction, szTemp);

            // Check against search string
            if(MatchFunction(szTemp))
            {
                // Insert into module.
                pFunc = new CFunction(szTemp, -1, ordinal, 
                    dwAddress, pOrd->GetDelayed());
                InsertFunctionSorted(pFunc, &m_pFunctions);
            }
        }
        // No matching ordinal import, check normal imports.
        else
        {
            // Duck out early if this function isn't used in the executable.
            pFunc = m_pFunctions;
            while(pFunc)
            {
                if(strcmp(pFunc->Name(), szFunction)==0)
                    break;

                pFunc = pFunc->Next();
            }

            if(pFunc == 0)
                continue;
        }

        // Set forwarding info
        if(szForward && pFunc)
            pFunc->SetForwardName(szForward);
    }

    return true;
}

// Get delayed import info from module.
bool CModule::WalkDelayImportTable()
{
    // Bail early if no delayed import table.
    if(m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].Size == 0)
        return true;

    // Locate the directory section
    DWORD dwVAImageDir = 
        m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress;

    // Get the import descriptor array
    PImgDelayDescr pidd = reinterpret_cast<PImgDelayDescr>(RVAToPtr(dwVAImageDir));

    while(pidd->pINT)
    {
        char* szName;
        if(pidd->grAttrs & 1)        
            szName = reinterpret_cast<char*>(RVAToPtr(pidd->szName));
        else
            szName = reinterpret_cast<char*>(RVAToPtr(pidd->szName - m_pioh->ImageBase));

        PIMAGE_THUNK_DATA pitdf;
        if(pidd->grAttrs & 1)        
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(pidd->pINT));
        else
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(
            reinterpret_cast<DWORD>(pidd->pINT) - 
            static_cast<DWORD>(m_pioh->ImageBase)));

        // Locate child module, or create new if it does not exist.
        CModule* pcm = FindChild(szName);
        if(!pcm)
        {
            pcm = new CModule(szName);
            InsertChildModuleSorted(pcm);
        }

        // Loop through all imported functions
        while(pitdf->u1.Ordinal)
        {
            int iOrdinal;
            int iHint;

            // Check if imported by name or ordinal
            if(!IMAGE_SNAP_BY_ORDINAL(pitdf->u1.Ordinal))
            {
                // Get name import info

                PIMAGE_IMPORT_BY_NAME piibn = 
                    reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(
                    RVAToPtr(pitdf->u1.AddressOfData - m_pioh->ImageBase));

                char* szTemp = reinterpret_cast<char*>(piibn->Name);
                char szBuffer[1024];

                // Unmangle link name
                LinkName2Name(szTemp, szBuffer);                

                // Ordinal info is invalid
                iOrdinal = -1;

                iHint = piibn->Hint;

                // Check against search string
                if(MatchFunction(szBuffer))
                {
                    // Insert into function list
                    CFunction* psf = new CFunction(szBuffer, iHint, iOrdinal,
                        static_cast<DWORD>(-1), true);

                    pcm->InsertFunctionSorted(psf, &pcm->m_pFunctions);
                }
            }
            else
            {
                // Insert a new delayed ordinal import
                iOrdinal = static_cast<int>(IMAGE_ORDINAL(pitdf->u1.Ordinal));

                pcm->InsertOrdinal(iOrdinal, true);
            }

            // Move on to next function
            pitdf++;
        }

        // Move to next delay import descriptor
        pidd++;
    }

    return true;
}

// Determine all functions imported by this module
bool CModule::WalkImportTable()
{
    // Bail out early if no directory
    if(m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0)
        return true;

    // Locate the directory section
    DWORD dwVAImageDir = 
        m_pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;    

    // Get the import descriptor array
    PIMAGE_IMPORT_DESCRIPTOR piid = 
        reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(RVAToPtr(dwVAImageDir));

    // Loop through all imported modules
    while(piid->FirstThunk || piid->OriginalFirstThunk)
    {

        // Get module name
        char* szName = reinterpret_cast<char*>(RVAToPtr(piid->Name));

        // Find child, or create new if it does not exist.
        CModule* pcm = FindChild(szName);
        if(!pcm)
        {
            pcm = new CModule(szName);
            InsertChildModuleSorted(pcm);
        }

        // Get all imports from this module
        PIMAGE_THUNK_DATA pitdf = 0;
        PIMAGE_THUNK_DATA pitda = 0;

        // Check for MS or Borland format
        if(piid->OriginalFirstThunk)
        {
            // MS format, function array is original first thunk
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(piid->OriginalFirstThunk));

            // If the time stamp is set, this module has
            // been bound and the first thunk is the bound address array
            if(piid->TimeDateStamp)
                pitda = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(piid->FirstThunk));
        }
        else
        {
            // Borland format uses first thunk for function array
            pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(RVAToPtr(piid->FirstThunk));
        }

        // Loop through all imported functions
        while(pitdf->u1.Ordinal)
        {
            int iOrdinal;
            int iHint;

            // Determine if imported by ordinal or name
            if(!IMAGE_SNAP_BY_ORDINAL(pitdf->u1.Ordinal))
            {
                // Get name import info
                PIMAGE_IMPORT_BY_NAME piibn = 
                    reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(
                    RVAToPtr(pitdf->u1.AddressOfData));

                // Get function name
                char* szTemp = reinterpret_cast<char*>(piibn->Name);

                // Unmangle
                char szBuffer[1024];
                LinkName2Name(szTemp, szBuffer);                

                iOrdinal = -1;
                iHint = piibn->Hint;

                // Check against search string
                if(MatchFunction(szBuffer))
                {
                    // Insert into function list
                    CFunction* psf = new CFunction(szBuffer, iHint, iOrdinal,
                        pitda ? pitda->u1.Function : static_cast<DWORD>(-1),
                        false);

                    pcm->InsertFunctionSorted(psf, &pcm->m_pFunctions);
                }
            }
            else
            {
                // Insert an ordinal import into the module.
                iOrdinal = static_cast<int>(IMAGE_ORDINAL(pitdf->u1.Ordinal));
                pcm->InsertOrdinal(iOrdinal);
            }

            // Move to next function
            pitdf++;

            if(pitda)
                pitda++;
        }

        // Move to next module
        piid++;
    }

    return true;
}

// Parse all import tables
bool CModule::ParseImportTables()
{
    return (WalkImportTable()
        && WalkDelayImportTable());
}

// Load a module into memory, and parse it.
bool CModule::ParseModule(HANDLE hEvent)
{
    // Cancel parsing if user canceled
    if(hEvent && WaitForSingleObject(hEvent, 0)==WAIT_OBJECT_0) 
        return false;

    bool fSucceeded = false;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = 0;

    bool fPushed = false;

    m_pvImageBase = 0;

    // Wrap in a __try block, because an invalid executable image
    // may have bad pointers in our memory mapped region.
    __try
    {
        // Open the file
        char szFileName[1024];
        char* szJunk;
        if(!SearchPath(0, m_szName, 0, 1024, szFileName, &szJunk))
        {
            m_szError = "Unable to find file";
            __leave;
        }

        hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
            0, OPEN_EXISTING, 0, 0);
        if(hFile == INVALID_HANDLE_VALUE)
        {
            m_szError = "Unable to open file";
            __leave;
        }

        GetFileVerInfo(hFile, szFileName);

        // Map the file into memory
        hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
        if(hMap == 0)
        {
            m_szError = "Unable to map file";
            __leave;
        }

        m_pvImageBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
        if(m_pvImageBase == 0)
        {
            m_szError = "Unable to map file";
            __leave;
        }

        // Get header information and verify this is a valid executable
        // Get the MS-DOS compatible header
        PIMAGE_DOS_HEADER pidh = reinterpret_cast<PIMAGE_DOS_HEADER>(m_pvImageBase);
        if(pidh->e_magic != IMAGE_DOS_SIGNATURE)
        {
            m_szError = "Invalid image, no MS-DOS header";
            __leave;
        }

        // Get the NT header and verify
        PIMAGE_NT_HEADERS pinth = reinterpret_cast<PIMAGE_NT_HEADERS>(
            reinterpret_cast<DWORD>(m_pvImageBase) + pidh->e_lfanew);

        if(pinth->Signature != IMAGE_NT_SIGNATURE)
        {
            // Not a valid Win32 executable, may be a Win16 or OS/2 exe
            m_szError = "Invalid image, no PE signature";
            __leave;
        }

        // Get the other headers
        m_pifh = &pinth->FileHeader;
        m_pioh = &pinth->OptionalHeader;
        m_pish = IMAGE_FIRST_SECTION(pinth);

        // Check if anyone is importing
        // functions from us, and if so resolve
        // function forwarding and ordinals
        if(m_pFunctions || m_pOrdinals)
        {
            if(!ResolveForwardedFunctionsAndOrdinals())
                __leave;
        }

        // Parse import tables (only if not a system DLL or if parsing
        // this module may result in a dependency loop)
        m_fSystem = IsSystemDLL(m_szName);
        if(!m_fSystem && !g_ParseStack.CheckModuleParsed(m_szName))
        {
            // Add to parse stack
            g_ParseStack.PushName(m_szName);
            fPushed = true;

            // Parse
            if(!ParseImportTables())
                __leave;
        }        
        
        // Loop through each DLL imported
        CModule* pModule = m_pImportedDLLs;
        while(pModule)
        {
            // Parse each child module
            pModule->ParseModule(hEvent);                
            pModule = pModule->m_pNext;
        }

        fSucceeded = true;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_szError = "Unable to parse module";
        fSucceeded = false;
    }

    // Cleanup . . .
    if(m_pvImageBase)
        UnmapViewOfFile(m_pvImageBase);

    if(hMap != 0)
        CloseHandle(hMap);

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if(fPushed)
        g_ParseStack.Pop();

    return fSucceeded;
}

void CModule::GetFileVerInfo(HANDLE hFile, char* szFileName)
{
    if(g_fRaw || !g_fVerbose)
        return;

    // Get file version info
    HANDLE hVersionInfo = ReadFileAttributes(szFileName, &m_nAttrCount);

    // Get date info
    BY_HANDLE_FILE_INFORMATION fileInfo;
    GetFileInformationByHandle(hFile, &fileInfo);
    FILETIME ftDate;
    memcpy(&ftDate, &fileInfo.ftLastWriteTime, sizeof(FILETIME));
    
    CoFileTimeToDosDateTime(&ftDate, &m_wDosDate, &m_wDosTime);

    if(m_nAttrCount)
    {
        m_szAttrValues = new char*[m_nAttrCount];
        m_szAttrNames = new char*[m_nAttrCount];
        ZeroMemory(m_szAttrValues, sizeof(char*)*m_nAttrCount);
        ZeroMemory(m_szAttrNames, sizeof(char*)*m_nAttrCount);
        if(hVersionInfo)
            for(int i = 0; i < m_nAttrCount; i++)
            {
                char* szVal = GetAttrValue(hVersionInfo, i);                
                if(szVal)
                {
                    m_szAttrValues[i] = new char[strlen(szVal)+1];
                    strcpy(m_szAttrValues[i], szVal);

                    char* szAttrName = GetAttrNameXML(i);
                    if(szAttrName)
                    {
                        m_szAttrNames[i] = new char[strlen(szAttrName)+1];
                        strcpy(m_szAttrNames[i], szAttrName);
                    }
                }                
            }
    }

    if(hVersionInfo)
        CleanupFileManager(hVersionInfo);
}

// Return true if module is a system DLL, false otherwise
// We use the system file protection system, and assume all system
// files are protected.
bool IsSystemDLL(const char* szFileName)
{
    char szBuffer[1024], *szJunk;

    if(!SearchPath(0, szFileName, 0, 1024, szBuffer, &szJunk))
       return false;

    // Only check DLL's
    if(!StrStrI(szFileName, ".dll"))
        return false;

    wchar_t* wszFileName = new wchar_t[strlen(szBuffer) + 1];
    MultiByteToWideChar(CP_ACP, 0, szBuffer, strlen(szBuffer)+1,
        wszFileName, strlen(szBuffer)+1);

    bool fRet = (SfcIsFileProtected(0, wszFileName) != FALSE);
    delete wszFileName;

    return fRet;
}

// LinkName2Name()
// Resolve name mangling
void LinkName2Name(char* szLinkName, char* szName)
{
    /*
     * the link name is expected like ?Function@Class@@Params
     * to be converted to Class::Function
     */

    static CHAR arrOperators[][8] =
    {
        "",
        "",
        "new",
        "delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!="
    };

    DWORD dwCrr = 0;
    DWORD dwCrrFunction = 0;
    DWORD dwCrrClass = 0;
    DWORD dwSize;
    BOOL  fIsCpp = FALSE;
    BOOL  fHasClass = FALSE;
    BOOL  fIsContructor = FALSE;
    BOOL  fIsDestructor = FALSE;
  
    BOOL  fIsOperator = FALSE;
    DWORD dwOperatorIndex = 0;
    bool fIsStdcall = false, fIsFastcall = false;
    char szFunction[1024];
    char szClass[1024];

    // Unmangle stdcall and fastcall names
    char* szAtSymbol = strrchr(szLinkName, '@');
    fIsFastcall = (szLinkName[0] == '@') && szAtSymbol && isdigit(szAtSymbol[1]);
    fIsStdcall = (szLinkName[0] == '_') && szAtSymbol && isdigit(szAtSymbol[1]);
    if(fIsFastcall || fIsStdcall)
    {
        szLinkName++;

        // Modifying the link name, so make a copy.
        // The file is mapped as read-only, and if it
        // were read/write, changes would be made to the
        // executable.
        char* szTemp = new char[strlen(szLinkName)+1];
        strcpy(szTemp, szLinkName);
        szLinkName = szTemp;

        *(strchr(szLinkName, '@'))= '\0';

        // ?????
        // I think we need to keep going, because it is possible
        // to have C++ name mangling on a stdcall name.
    }


    if (*szLinkName == '@')
        szLinkName++;

    dwSize = lstrlen(szLinkName);

    /*
     * skip '?'
     */
    while (dwCrr < dwSize) {
        if (szLinkName[dwCrr] == '?') {

            dwCrr++;
            fIsCpp = TRUE;
        }
        break;
    }

    /*
     * check to see if this is a special function (like ??0)
     */
    if (fIsCpp) {

        if (szLinkName[dwCrr] == '?') {

            dwCrr++;

            /*
             * the next digit should tell as the function type
             */
            if (isdigit(szLinkName[dwCrr])) {

                switch (szLinkName[dwCrr]) {

                case '0':
                    fIsContructor = TRUE;
                    break;
                case '1':
                    fIsDestructor = TRUE;
                    break;
                default:
                    fIsOperator = TRUE;
                    dwOperatorIndex = szLinkName[dwCrr] - '0';
                    break;
                }
                dwCrr++;
            }
        }
    }

    /*
     * get the function name
     */
    while (dwCrr < dwSize) {

        if (szLinkName[dwCrr] != '@') {

            szFunction[dwCrrFunction] = szLinkName[dwCrr];
            dwCrrFunction++;
            dwCrr++;
        } else {
            break;
        }
    }
    szFunction[dwCrrFunction] = '\0';

    if (fIsCpp) {
        /*
         * skip '@'
         */
        if (dwCrr < dwSize) {

            if (szLinkName[dwCrr] == '@') {
                dwCrr++;
            }
        }

        /*
         * get the class name (if any)
         */
        while (dwCrr < dwSize) {

            if (szLinkName[dwCrr] != '@') {

                fHasClass = TRUE;
                szClass[dwCrrClass] = szLinkName[dwCrr];
                dwCrrClass++;
                dwCrr++;
            } else {
                break;
            }
        }
        szClass[dwCrrClass] = '\0';
    }

    /*
     * print the new name
     */
    if (fIsContructor) {
        sprintf(szName, "%s::%s", szFunction, szFunction);
    } else if (fIsDestructor) {
        sprintf(szName, "%s::~%s", szFunction, szFunction);
    } else if (fIsOperator) {
        sprintf(szName, "%s::operator %s", szFunction, arrOperators[dwOperatorIndex]);
    } else if (fHasClass) {
        sprintf(szName, "%s::%s", szClass, szFunction);
    } else {
        sprintf(szName, "%s", szFunction);
    }

    // stdcall and fastcall unmangling do a slight modification to 
    // the link name, we need to free it here.
    if(fIsStdcall || fIsFastcall)
        delete szLinkName;
}

// Parse a top level module
void ParseHighLevelModule(char* szName, HANDLE hEvent)
{
    // Create a new module
    CModule* pModule = new CModule(szName);

    assert(g_ParseStack.IsEmpty());
    g_ParseStack.ClearParseHistory();

    pModule->ParseModule(hEvent);

    // Add to global module list
    g_modules.InsertModuleSorted(pModule);
}

// Functions to print to console or XML file
// Just do indentation, save repetitious code
void Indent(int iLevel, FILE* pFile)
{
    for(int i = 0; i < iLevel; i++)
        fprintf(pFile, "\t");
}

// Write function header info for raw output
void CFunction::WriteHeader(int iIndentLevel, FILE* pFile)
{
    if(g_fVerbose && g_fRaw)
    {
        Indent(iIndentLevel, pFile);
        fprintf(pFile, "%-40s%-10s%-6s%-8s%-40s%-6s\n", "Name", "Address", "Hint", 
            "Ordinal", "Forwarded to", "Delayed");
    }
}

// Write a function, raw or XML
void CFunction::WriteFunction(int iIndentLevel, FILE* pFile)
{
    Indent(iIndentLevel, pFile);

    if(!g_fRaw)
    {        
        if(g_fVerbose)
        {       
            fprintf(pFile, "<FUNCTION NAME=\"");
            WriteXMLOKString(m_szName, pFile);
            fprintf(pFile, "\" ", m_szName);

            if(m_dwAddress != static_cast<DWORD>(-1))
                fprintf(pFile, "ADDRESS=\"0x%x\" ", m_dwAddress);

            if(m_iHint != -1)
                fprintf(pFile, "HINT=\"%d\" ", m_iHint);
       
            if(m_iOrdinal != -1)
                fprintf(pFile, "ORDINAL=\"%d\" ", m_iOrdinal);
    
            if(m_szForwardName != 0)
            {
                fprintf(pFile, "FORWARD_TO=\"");
                WriteXMLOKString(m_szForwardName, pFile);
                fprintf(pFile, "\" ");
            }

            fprintf(pFile, "DELAYED=\"%s\"/>\n", m_fDelayed ? "true" : "false");
        }
        else
        {
            fprintf(pFile, "<FUNCTION NAME=\"");
            WriteXMLOKString(m_szName, pFile);
            fprintf(pFile, "\"/>\n");
        }
    }
    else
    {
        if(g_fVerbose)
        {
            char szAddress[16] = "N/A";
            if(m_dwAddress != static_cast<DWORD>(-1))
                sprintf(szAddress, "0x%x", m_dwAddress);

            char szOrdinal[16] = "N/A";
            if(m_iOrdinal != -1)
                sprintf(szOrdinal, "0x%x", m_iOrdinal);

            char szHint[16] = "N/A";
            if(m_iHint != -1)
                sprintf(szHint, "%d", m_iHint);

            fprintf(pFile, "%-40s%-10s%-6s%-8s%-40s%-6s\n", m_szName, szAddress, 
                szHint, szOrdinal, m_szForwardName ? m_szForwardName : "N/A", 
                m_fDelayed ? "true" : "false");
        }
        else
        {
            fprintf(pFile, "%s\n", m_szName);
        }
    }
}

// Write an XML-compliant string (no <'s and >'s, replace with &gt, &lt, etc.)
void WriteXMLOKString(char* szString, FILE* pFile)
{ 
    const int c_nChars = 5;
    char acIllegal[] = {'<','>', '&', '\'', '\"'};
    char* szEntities[] = {"&lt;", "&gt;", "&amp;", "&apos;", "&quot;"};

    while(*szString)
    {
        int i;
        for(i = 0; i < c_nChars; i++)
        {
            if(*szString == acIllegal[i])
            {
                fprintf(pFile, szEntities[i]);
                break;
            }
        }
        if(i == c_nChars)
            fputc(*szString, pFile);
        szString++;
    }
}

// Write an entire module as output, either raw or XML.
void CModule::WriteModule(bool fTopLevel, int iIndentLevel, FILE* pFile)
{
    if(Empty() && m_szError == 0)
        return;

    Indent(iIndentLevel, pFile);

    if(!g_fRaw)
    {     
        if(fTopLevel)
            fprintf(pFile, "<EXE NAME=\"");
        else
            fprintf(pFile, "<DLL NAME=\"");
               
        WriteXMLOKString(m_szFullName, pFile);
        fprintf(pFile,"\">\n");
    }
    else
    {
        fprintf(pFile, "%s:\n", m_szFullName);
    }

    if(!g_fRaw && g_fVerbose && (m_nAttrCount || m_wDosDate))
    {
        Indent(iIndentLevel + 1, pFile);
        fprintf(pFile, "<INFO>\n");
        
        // Print out date information        
        Indent(iIndentLevel + 1, pFile);
        fprintf(pFile, "<DATE>%d/%d/%d</DATE>\n", (m_wDosDate & 0x1E0) >> 5,
            m_wDosDate & 0x1F, ((m_wDosDate & 0xFE00) >> 9) + 1980);

        for(int i = 0; i < m_nAttrCount; i++)
        {            
            if(m_szAttrValues[i])
            {                                                
                if(m_szAttrNames[i])
                {
                    if(strlen(m_szAttrNames[i]) != 0)
                    {                        
                        Indent(iIndentLevel+1, pFile);
                        fprintf(pFile, "<");
                        WriteXMLOKString(m_szAttrNames[i], pFile);
                        fprintf(pFile,">");
                        WriteXMLOKString(m_szAttrValues[i], pFile);
                        fprintf(pFile,"</");
                        WriteXMLOKString(m_szAttrNames[i], pFile);
                        fprintf(pFile, ">\n");                                        
                    }
                }                              
            }
            
        }
        
        Indent(iIndentLevel + 1, pFile);
        fprintf(pFile, "</INFO>\n");
    }

    // If an error occured in parsing
    if(m_szError)
    {
        Indent(iIndentLevel+1, pFile);       
        if(!g_fRaw)
        {
            fprintf(pFile, "<ERROR TYPE=\"");
            WriteXMLOKString(m_szError, pFile);
            fprintf(pFile,"\"/>\n");
        }
        else
            fprintf(pFile, "Parse Error: %s\n", m_szError);        
    }

    if(g_fVerbose)
    {
        Indent(iIndentLevel+1, pFile);

        if(m_fSystem)
        {            
            if(!g_fRaw)
                fprintf(pFile, "<SYSTEMMODULE VALUE=\"1\"/>\n");
            else
                fprintf(pFile, "(System Module)\n");
        }
        else
        {
            if(!g_fRaw)
                fprintf(pFile, "<SYSTEMMODULE VALUE =\"0\"/>\n");
            else
                fprintf(pFile, "(Private Module)\n");
        }
    }

    // Print all functions imported from this module

    if(g_fAPILogging && fTopLevel)
    {
        CFunction* pAllFunctions = 0;
        GetAllFunctions(&pAllFunctions);

        if(pAllFunctions)
            pAllFunctions->WriteHeader(iIndentLevel+1, pFile);
        
        while(pAllFunctions)
        {
            CFunction* pOld;
            pAllFunctions->WriteFunction(iIndentLevel+1, pFile);
            pOld = pAllFunctions;
            pAllFunctions = pAllFunctions->Next();
            delete pOld;
        }
    }
    else
    {

        CFunction* pFunc = m_pFunctions;
    
        if(pFunc)
            pFunc->WriteHeader(iIndentLevel, pFile);

        while(pFunc)
        {
            pFunc->WriteFunction(iIndentLevel, pFile);
            pFunc = pFunc->Next();
        }

        CModule* pMod = m_pImportedDLLs;
        while(pMod)
        {
            pMod->WriteModule(false, iIndentLevel + 1, pFile);
            pMod = pMod->m_pNext;
        }
    }

    Indent(iIndentLevel, pFile);
    if(!g_fRaw)
    {
        if(fTopLevel)
            fprintf(pFile, "</EXE>\n");
        else
            fprintf(pFile, "</DLL>\n");
    }

    fprintf(pFile, "\n");

    // Child modules no longer needed, delete
    CModule* pMod = m_pImportedDLLs;
    while(pMod)
    {
        CModule* pNext = pMod->m_pNext;
        delete pMod;
        pMod = pNext;
    }
    m_pImportedDLLs = 0;
}

// Write out the XML header
void WriteXMLHeader(FILE* pFile)
{
    if(g_fRaw)
        return;

    static char* szMonths[] =
    {"",
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"};

    static char* szDays[] = 
    {"Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"};

    SYSTEMTIME st;
    GetLocalTime(&st);

    fprintf(pFile, "<?xml version = \"1.0\"?>\n");
    fprintf(pFile, "<!--\n");
    fprintf(pFile, "\tAppParse Datafile\n");
    fprintf(pFile, "\tGenerated: %s, %s %d, %d %2d:%2d:%2d\n",
        szDays[st.wDayOfWeek], szMonths[st.wMonth], st.wDay, st.wYear,
        st.wHour, st.wMinute, st.wSecond);

    fprintf(pFile, "-->\n\n");
}

// Return true if function name matches search string, false otherwise.
bool MatchFunction(const char* szFunc)
{
    if(strcmp(g_szSearch, "*") == 0)
        return true;

    char* szSearch = g_szSearch;
    while(*szSearch != '\0' && *szFunc != '\0')
    {
        // If we get a ?, we don't care and move on to the next
        // character.
        if(*szSearch == '?')
        {
            szSearch++;
            szFunc++;
            continue;
        }

        // If we have a wildcard, move to next search string and search for substring
        if(*szSearch == '*')
        {
            char* szCurrSearch;
            szSearch++;

            if(*szSearch == '\0')
                return true;

            // Don't change starting point.
            szCurrSearch = szSearch;
            for(;;)
            {
                // We're done if we hit another wildcard
                if(*szCurrSearch == '*' ||
                    *szCurrSearch == '?')
                {
                    // Update the permanent search position.
                    szSearch = szCurrSearch;
                    break;
                }
                // At end of both strings, return true.
                if((*szCurrSearch == '\0') && (*szFunc == '\0'))
                    return true;

                // We never found it
                if(*szFunc == '\0')                     
                    return false;

                // If it doesn't match, start over
                if(toupper(*szFunc) != toupper(*szCurrSearch))
                {
                    // If mismatch on first character
                    // of search string, move to next
                    // character in function string.
                    if(szCurrSearch == szSearch)
                        szFunc++;
                    else
                        szCurrSearch = szSearch;
                }
                else
                {
                    szFunc++;
                    szCurrSearch++;
                }
            }
        }
        else
        {
            if(toupper(*szFunc) != toupper(*szSearch))
            {
                return false;
            }

            szFunc++;
            szSearch++;
        }
    }

    if((*szFunc == 0) && ((*szSearch == '\0') || (strcmp(szSearch,"*")==0)))
        return true;
    else
        return false;
}

// Profile an entire directory
void ProfileDirectory(char* szDirectory, HANDLE hEvent)
{
    if(!SetCurrentDirectory(szDirectory))
        return;
 
    WIN32_FIND_DATA ffd;

    // Find and parse all EXE's.
    HANDLE hSearch = FindFirstFile("*.exe", &ffd);
    if(hSearch != INVALID_HANDLE_VALUE)
    {
        do
        {
            ParseHighLevelModule(ffd.cFileName, hEvent);
            
            // Terminate parsing if user canceled
            if(hEvent && WaitForSingleObject(hEvent, 0)==WAIT_OBJECT_0)
            {
                FindClose(hSearch);
                SetCurrentDirectory("..");
                return;
            }
        }
        while(FindNextFile(hSearch, &ffd));

        FindClose(hSearch);
    }

    // See if we should go deeper into directories.
    if(g_fRecurse)
    {
        hSearch = FindFirstFile("*", &ffd);
        if(hSearch == INVALID_HANDLE_VALUE)
        {
            SetCurrentDirectory("..");
            return;
        }

        do
        {
            if(GetFileAttributes(ffd.cFileName) & FILE_ATTRIBUTE_DIRECTORY)
            {
                // Don't do an infinite recursion.
                if(ffd.cFileName[0] != '.')
                {
                    int nCurrLength = strlen(g_szCurrentPath);
                    strcat(g_szCurrentPath, ffd.cFileName);
                    strcat(g_szCurrentPath, "\\");
                    ProfileDirectory(ffd.cFileName, hEvent);

                    g_szCurrentPath[nCurrLength] = '\0';
                }

                // Terminate search if user signaled
                if(hEvent && WaitForSingleObject(hEvent, 0)==WAIT_OBJECT_0)
                {
                    FindClose(hSearch);
                    SetCurrentDirectory("..");
                    return;
                }
            }
        } while(FindNextFile(hSearch, &ffd));
    }

    FindClose(hSearch);

    SetCurrentDirectory("..");
}


void* __cdecl operator new(size_t size)
{ 
    void* pv = 0;
    
    if(!g_hHeap)
        pv = HeapAlloc(GetProcessHeap(), 0, size);
    else
        pv = HeapAlloc(g_hHeap, 0, size);    

    if(!pv)
    {
        MessageBox(0, TEXT("Out of memory, terminating."), TEXT("ERROR"), 
            MB_OK | MB_ICONERROR);
        exit(-1);
    }

    return pv;
}

void __cdecl operator delete(void* pVal)
{
    if(g_hHeap)
        HeapFree(g_hHeap, 0, pVal);
    else
        HeapFree(GetProcessHeap(), 0, pVal);
}

DWORD __stdcall AppParse(char* szAppName, FILE* pFile, bool fRaw, 
              bool fAPILogging, bool fRecurse, bool fVerbose, char* szSearchKey, 
              int iPtolemyID, HANDLE hEvent)
{    
    g_fRaw = fRaw;
    g_fAPILogging = fAPILogging;
    g_fVerbose = fVerbose;
    g_szSearch = szSearchKey;
    g_fRecurse = fRecurse;

    bool fProfileDirectory = false;
    
    // Check if it is a directory, or a regular file.
    DWORD dwAttributes = GetFileAttributes(szAppName);
    if(dwAttributes != static_cast<DWORD>(-1) && 
        (dwAttributes & FILE_ATTRIBUTE_DIRECTORY))
        fProfileDirectory = true;
 
    // Check for directory profiling
    if(fProfileDirectory)
    {
        // Search for all EXE's in this Directory
        // Remove trailing \, if present
        if(szAppName[strlen(szAppName)-1]== '\\')
            szAppName[strlen(szAppName)-1] = '\0';

        char szBuff[MAX_PATH];
        strcpy(szBuff, szAppName);

        // If we're profiling a drive, don't include
        // the drive letter in the path
        if(szBuff[strlen(szBuff)-1]==':')
        {
                *g_szCurrentPath='\0';
        }
        else
        {
            if(strrchr(szBuff, '\\'))
                strcpy(g_szCurrentPath, strrchr(szBuff, '\\')+1);            
            else
                strcpy(g_szCurrentPath, szBuff);
            strcat(g_szCurrentPath, "\\");
        }
    
        ProfileDirectory(szAppName, hEvent);
    }
    else
    {
        // Maybe they left off the .exe
        if(GetFileAttributes(szAppName) == static_cast<DWORD>(-1))
        {
            char szBuffer[MAX_PATH+1];
            strcpy(szBuffer, szAppName);
            strcat(szBuffer, ".exe");
            dwAttributes = GetFileAttributes(szBuffer);
            if(dwAttributes == static_cast<DWORD>(-1))
            {                                
                return ERROR_FILE_NOT_FOUND;
            }           
            szAppName = szBuffer;
        }

        // Get the directory name
        char szBuffer[MAX_PATH+1];
        strcpy(szBuffer, szAppName);

        char* p;
        for(p = &szBuffer[strlen(szBuffer)]; p != szBuffer; p--)
        {
            if(*p == '\\')
            {
                *p = '\0';
                break;
            }
        }

        if(p != szBuffer)
        {
            SetCurrentDirectory(szBuffer);
            szAppName = p+1;
        }
        
        ParseHighLevelModule(szAppName, hEvent);
    }

    char* szProjectName = "";
    if(fProfileDirectory)
    {
        // If a directory, get the volume name
        if(strrchr(szAppName, '\\'))
            szAppName = strrchr(szAppName, '\\') + 1;

        // If we're profiling a drive, get volume name
        if(szAppName[strlen(szAppName)-1]==':')
        {
            char szBuffer[MAX_PATH];
            if(GetVolumeInformation(szAppName, szBuffer, MAX_PATH, 0, 0,
                0, 0, 0))            
                szProjectName = szBuffer;            
            else
                szProjectName = szAppName;        
        }        
        else    
            szProjectName = szAppName;
    }
    else
    {
        szProjectName = szAppName;
        char* szExtension = strstr(szAppName, ".exe");

        if(szExtension)
            *szExtension = '\0';
    }

    // Only write if there wasn't an event object, or user canceled.
    if(!hEvent || WaitForSingleObject(hEvent, 0) != WAIT_OBJECT_0)
    {
        // Write all output
        WriteXMLHeader(pFile);
        g_modules.Write(pFile, szProjectName, iPtolemyID);
    }

    g_modules.Clear();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\stdafx.h ===
// No Precompiled headers currently used
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\appparseweb.cpp ===
// AppParseWeb.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AppParseWebps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AppParseWeb.h"

#include "AppParseWeb_i.c"
#include "AppParseWrapper.h"

extern HANDLE g_hHeap;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AppParse, CAppParse)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		g_hHeap = HeapCreate(0, 0, 0);
        _Module.Init(ObjectMap, hInstance, &LIBID_APPPARSEWEBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		HeapDestroy(g_hHeap);
        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\appparseweb.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for appparseweb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __appparseweb_h__
#define __appparseweb_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAppParse_FWD_DEFINED__
#define __IAppParse_FWD_DEFINED__
typedef interface IAppParse IAppParse;
#endif 	/* __IAppParse_FWD_DEFINED__ */


#ifndef __AppParse_FWD_DEFINED__
#define __AppParse_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppParse AppParse;
#else
typedef struct AppParse AppParse;
#endif /* __cplusplus */

#endif 	/* __AppParse_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IAppParse_INTERFACE_DEFINED__
#define __IAppParse_INTERFACE_DEFINED__

/* interface IAppParse */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IAppParse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BAF56261-3C9F-44F9-9F30-6922DD29BD81")
    IAppParse : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Parse( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Browse( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_path( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PtolemyID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PtolemyID( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionString( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryDB( 
            long PtolemyID,
            BSTR bstrFunction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppParseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppParse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppParse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppParse * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAppParse * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAppParse * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAppParse * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAppParse * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Parse )( 
            IAppParse * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Browse )( 
            IAppParse * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_path )( 
            IAppParse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_path )( 
            IAppParse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PtolemyID )( 
            IAppParse * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PtolemyID )( 
            IAppParse * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionString )( 
            IAppParse * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectionString )( 
            IAppParse * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryDB )( 
            IAppParse * This,
            long PtolemyID,
            BSTR bstrFunction);
        
        END_INTERFACE
    } IAppParseVtbl;

    interface IAppParse
    {
        CONST_VTBL struct IAppParseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppParse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppParse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppParse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppParse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAppParse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAppParse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAppParse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAppParse_Parse(This)	\
    (This)->lpVtbl -> Parse(This)

#define IAppParse_Browse(This)	\
    (This)->lpVtbl -> Browse(This)

#define IAppParse_get_path(This,pVal)	\
    (This)->lpVtbl -> get_path(This,pVal)

#define IAppParse_put_path(This,newVal)	\
    (This)->lpVtbl -> put_path(This,newVal)

#define IAppParse_get_PtolemyID(This,pVal)	\
    (This)->lpVtbl -> get_PtolemyID(This,pVal)

#define IAppParse_put_PtolemyID(This,newVal)	\
    (This)->lpVtbl -> put_PtolemyID(This,newVal)

#define IAppParse_get_ConnectionString(This,pVal)	\
    (This)->lpVtbl -> get_ConnectionString(This,pVal)

#define IAppParse_put_ConnectionString(This,newVal)	\
    (This)->lpVtbl -> put_ConnectionString(This,newVal)

#define IAppParse_QueryDB(This,PtolemyID,bstrFunction)	\
    (This)->lpVtbl -> QueryDB(This,PtolemyID,bstrFunction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppParse_Parse_Proxy( 
    IAppParse * This);


void __RPC_STUB IAppParse_Parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppParse_Browse_Proxy( 
    IAppParse * This);


void __RPC_STUB IAppParse_Browse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppParse_get_path_Proxy( 
    IAppParse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAppParse_get_path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppParse_put_path_Proxy( 
    IAppParse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppParse_put_path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppParse_get_PtolemyID_Proxy( 
    IAppParse * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IAppParse_get_PtolemyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppParse_put_PtolemyID_Proxy( 
    IAppParse * This,
    /* [in] */ long newVal);


void __RPC_STUB IAppParse_put_PtolemyID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IAppParse_get_ConnectionString_Proxy( 
    IAppParse * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IAppParse_get_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IAppParse_put_ConnectionString_Proxy( 
    IAppParse * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IAppParse_put_ConnectionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IAppParse_QueryDB_Proxy( 
    IAppParse * This,
    long PtolemyID,
    BSTR bstrFunction);


void __RPC_STUB IAppParse_QueryDB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppParse_INTERFACE_DEFINED__ */



#ifndef __APPPARSEWEBLib_LIBRARY_DEFINED__
#define __APPPARSEWEBLib_LIBRARY_DEFINED__

/* library APPPARSEWEBLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_APPPARSEWEBLib;

EXTERN_C const CLSID CLSID_AppParse;

#ifdef __cplusplus

class DECLSPEC_UUID("083BE70B-A07B-46FA-BCB1-8D85D262C699")
AppParse;
#endif
#endif /* __APPPARSEWEBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\appparseweb_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for appparseweb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppParse,0xBAF56261,0x3C9F,0x44F9,0x9F,0x30,0x69,0x22,0xDD,0x29,0xBD,0x81);


MIDL_DEFINE_GUID(IID, LIBID_APPPARSEWEBLib,0x8FD727E1,0xFD34,0x43C5,0xAB,0xD2,0x76,0x1C,0x18,0x60,0xFE,0x2A);


MIDL_DEFINE_GUID(CLSID, CLSID_AppParse,0x083BE70B,0xA07B,0x46FA,0xBC,0xB1,0x8D,0x85,0xD2,0x62,0xC6,0x99);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for appparseweb.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppParse,0xBAF56261,0x3C9F,0x44F9,0x9F,0x30,0x69,0x22,0xDD,0x29,0xBD,0x81);


MIDL_DEFINE_GUID(IID, LIBID_APPPARSEWEBLib,0x8FD727E1,0xFD34,0x43C5,0xAB,0xD2,0x76,0x1C,0x18,0x60,0xFE,0x2A);


MIDL_DEFINE_GUID(CLSID, CLSID_AppParse,0x083BE70B,0xA07B,0x46FA,0xBC,0xB1,0x8D,0x85,0xD2,0x62,0xC6,0x99);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\filebrowser.h ===
#ifndef FILEBROWSER_H
#define FILEBROWSER_H

#include <windows.h>

// Display browse dialog box, and return dir string.  String does
// not need to be freed, will be overwritten by subsequent calls.
PTSTR BrowseForFolder(HWND hwnd, PTSTR szInitialPath);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\appparsewrapper.cpp ===
// AppParse.cpp : Implementation of CAppParse
#include "stdafx.h"
#include "AppParseWeb.h"
#include "AppParseWrapper.h"
#include "AppParse.h"
#include <oledb.h>
#include <shlobj.h>
#include <comdef.h>
#include <rpcdce.h>
#include <msxml.h>
#include <icrsint.h>
#include <assert.h>
#include "filebrowser.h"

// Progress dialog functions
void InitProgressDialog(char* szText, HANDLE hEvent);
void KillProgressDialog();

// Save time by creating only seven ADO objects, and sharing, when parsing information
// into the database.
struct SADOInfo
{
    _ConnectionPtr pConn;
    IADORecordBinding* prbProjects;    
    IADORecordBinding* prbModules;
    IADORecordBinding* prbFuncs;    

    SProjectRecord pr;
    SModuleRecord mr;
    SFunctionRecord fr;
};

// Display an error message, then throw a COM error
void APError(char* szMessage, HRESULT hr)
{
    ::MessageBox(0, szMessage, "AppParse Error", MB_OK | MB_ICONERROR);
    _com_issue_error(hr);
}

// Get text subordinate to another node (e.g., <SIZE>0xabcdefg</SIZE>)
bool GetChildText(IXMLDOMNode* pXMLNode, variant_t* pVtVal)
{
    HRESULT hr;

    IXMLDOMNode* pXMLTextNode   = 0;

    // Try to get first child node, return FALSE if not present
    hr = pXMLNode->get_firstChild(&pXMLTextNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    if(!pXMLTextNode)
        return false;

    // Check if it is a text node.
    DOMNodeType domNodeType;

    hr = pXMLTextNode->get_nodeType(&domNodeType);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    // If so, copy text into variant, otherwise return
    if(domNodeType == NODE_TEXT)
    {        
        hr = pXMLTextNode->get_nodeValue(pVtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        SafeRelease(pXMLTextNode);
        return true;
    }    
    else
    {
        SafeRelease(pXMLTextNode);
        return false;
    }

    SafeRelease(pXMLTextNode);
}

// Convert a Month/Day/Year date into a DB-friendly date.
// A DB Friendly date is a double, indicating number of days since
// 1899 in the whole part, time in the fractional.  We disregard time.
double DateToDBDate(int month, int day, int year)
{
    // Check that the date is even valid.
    assert (month > 0 && month < 13);
    assert(day > 0 && day < 32);
    assert(year > 1899);

    // Quick lookup for number of days in each month.
    int DaysInMonth[] = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    double dbDate = 0;

    // Get full years
    dbDate = (year - 1899 - 1) * 365;

    // Adjust for leap years
    dbDate += ((year-1899-1)/4);
    dbDate -= ((year-1899-1)/100);
    dbDate += ((year-1899-1)/400);

    // Add days for each month.
    for(int i = 1; i < month; i++)
        dbDate += DaysInMonth[i];

    // Add the day of month to total.
    dbDate += day;

    return dbDate;
}

// Get file information for the image from an <INFO> node.
void GetImageInfo(IXMLDOMNode* pXMLInfoNode, SImageFileInfo* pInfo)
{
    HRESULT hr;

    IXMLDOMNode*        pXMLAttrChild   = 0;
    IXMLDOMNodeList*    pXMLChildList   = 0;
    IXMLDOMNode*        pXMLTextNode    = 0;

    // Get list of child nodes and move to first.
    hr = pXMLInfoNode->get_childNodes(&pXMLChildList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLChildList->nextNode(&pXMLAttrChild);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    // As long as there is a child node
    while(pXMLAttrChild)
    {

        // Get thename of the node
        BSTR bstrName;

        hr = pXMLAttrChild->get_nodeName(&bstrName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
        bstr_t bsz(bstrName, false);

        // Extract info based on node type
        if(stricmp(bsz, "DATE")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {               
                int month, day, year;
                sscanf(static_cast<bstr_t>(vtVal), "%d/%d/%d", &month, 
                    &day, &year);

                pInfo->Date = DateToDBDate(month, day, year);
                pInfo->DateStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "SIZE")==0)
        {
            variant_t vtVal;            
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                sscanf(static_cast<bstr_t>(vtVal), "%x", &pInfo->Size);
                pInfo->SizeStatus = adFldOK;                               
            }
        }
        else if(stricmp(bsz, "BIN_FILE_VERSION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->BinFileVersion, static_cast<bstr_t>(vtVal),50);
                pInfo->BinFileVersion[49] = '\0';
                pInfo->BinFileVersionStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "BIN_PRODUCT_VERSION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->BinProductVersion, static_cast<bstr_t>(vtVal),50);
                pInfo->BinProductVersion[49] = '\0';
                pInfo->BinProductVersionStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "CHECKSUM")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                sscanf(static_cast<bstr_t>(vtVal), "%x", &pInfo->CheckSum);
                pInfo->CheckSumStatus = adFldOK;                               
            }
        }
        else if(stricmp(bsz, "COMPANY_NAME")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->CompanyName, static_cast<bstr_t>(vtVal),255);
                pInfo->CompanyName[254] = '\0';
                pInfo->CompanyNameStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "PRODUCT_VERSION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->ProductVersion, static_cast<bstr_t>(vtVal),50);
                pInfo->ProductVersion[49];
                pInfo->ProductVersionStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "PRODUCT_NAME")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->ProductName, static_cast<bstr_t>(vtVal),255);
                pInfo->ProductName[254] = '\0';
                pInfo->ProductNameStatus = adFldOK;
            }
        }
        else if(stricmp(bsz, "FILE_DESCRIPTION")==0)
        {
            variant_t vtVal;
            if(GetChildText(pXMLAttrChild, &vtVal))
            {
                strncpy(pInfo->FileDesc, static_cast<bstr_t>(vtVal),255);
                pInfo->FileDesc[254] = '\0';
                pInfo->FileDescStatus = adFldOK;
            }
        }

        SafeRelease(pXMLAttrChild);

        // Move to next node
        hr = pXMLChildList->nextNode(&pXMLAttrChild);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
    SafeRelease(pXMLChildList);
    SafeRelease(pXMLAttrChild);
    SafeRelease(pXMLTextNode);
}

// Get all info related to a function from XML
void GetFunctionInfo(IXMLDOMNode* pXMLFunctionNode, ULONG lModuleID, SADOInfo* pADOInfo)
{
    HRESULT hr;    
    IXMLDOMNamedNodeMap*    pXMLAttrList= 0;
    IXMLDOMNode*            pXMLAttrNode = 0;

    // Start with no members valid.
    pADOInfo->fr.AddressStatus = pADOInfo->fr.HintStatus = 
        pADOInfo->fr.OrdinalStatus = pADOInfo->fr.ForwardNameStatus = adFldNull;
    
    // Get parent ID
    pADOInfo->fr.ModuleID = lModuleID;

    // Get all attribute nodes
    hr = pXMLFunctionNode->get_attributes(&pXMLAttrList);
    if(FAILED(hr) || !pXMLAttrList)
        APError("Unable to parse XML output", hr);

    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
    if(FAILED(hr) || !pXMLAttrNode)
        APError("Unable to parse XML output", hr);

    // Loop through the list.
    while(pXMLAttrNode)
    {
        BSTR bszName;
        variant_t vtVal;

        // Get attribute name and value.
        hr = pXMLAttrNode->get_nodeName(&bszName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        hr = pXMLAttrNode->get_nodeValue(&vtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        bstr_t bsz(bszName, false);
        bstr_t bszVal = vtVal;
        
        // Copy info into struct
        if(stricmp(static_cast<PSTR>(bsz), "NAME")==0)
        {            
            strncpy(pADOInfo->fr.Name, static_cast<PSTR>(bszVal), 255);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "HINT")== 0)
        {
            pADOInfo->fr.HintStatus = adFldOK;
            pADOInfo->fr.Hint = atoi(bszVal);
        }
        else if (stricmp(static_cast<PSTR>(bsz), "ORDINAL") == 0)
        {
            pADOInfo->fr.OrdinalStatus = adFldOK;
            pADOInfo->fr.Ordinal = atoi(bszVal);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "ADDRESS") == 0)
        {
            pADOInfo->fr.AddressStatus = adFldOK;
            pADOInfo->fr.Address = atoi(bszVal);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "FORWARD_TO")==0)
        {
            pADOInfo->fr.ForwardNameStatus = adFldOK;
            strncpy(pADOInfo->fr.ForwardName, bszVal, 255);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "DELAYED") == 0)
        {
            pADOInfo->fr.Delayed = (stricmp(bszVal, "true")==0);
        }

        SafeRelease(pXMLAttrNode);
        hr = pXMLAttrList->nextNode(&pXMLAttrNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
    
    // Add a new record to the database.
    hr = pADOInfo->prbFuncs->AddNew(&pADOInfo->fr);
    if(FAILED(hr))
        APError("Unable to add new function record to database", hr);
        
    SafeRelease(pXMLAttrList);
    SafeRelease(pXMLAttrNode);
}

// Get all info related to a module.
void GetModuleInfo(IXMLDOMNode* pXMLModuleNode, ULONG lParentID, SADOInfo* pADOInfo, 
                   HANDLE hEvent, bool fTopLevel = false)
{
    if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
        return;

    HRESULT hr;
    IXMLDOMNode*            pXMLChildNode = 0;
    IXMLDOMNodeList*        pXMLNodeList = 0;
    IXMLDOMNamedNodeMap*    pXMLAttrList= 0;
    IXMLDOMNode*            pXMLAttrNode = 0;    
    
    // All members are initially invalid.
    pADOInfo->mr.info.BinFileVersionStatus = 
        pADOInfo->mr.info.BinProductVersionStatus =
        pADOInfo->mr.info.CheckSumStatus = 
        pADOInfo->mr.info.CompanyNameStatus = 
        pADOInfo->mr.info.DateStatus = 
        pADOInfo->mr.info.FileDescStatus = 
        pADOInfo->mr.info.ProductNameStatus = 
        pADOInfo->mr.info.ProductVersionStatus =
        pADOInfo->mr.info.SizeStatus = 
        pADOInfo->mr.ParentIDStatus = 
        pADOInfo->mr.PtolemyIDStatus = adFldNull;
    
    // Copy parent ID
    pADOInfo->mr.ParentID = lParentID;

    // Check appropriate parent.
    if(fTopLevel)
        pADOInfo->mr.PtolemyIDStatus = adFldOK;
    else
        pADOInfo->mr.ParentIDStatus = adFldOK;

    // Get attributes
    hr = pXMLModuleNode->get_attributes(&pXMLAttrList);
    if(FAILED(hr) || !pXMLAttrList)
        APError("Unable to parse XML output", hr);

    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
    if(FAILED(hr) || !pXMLAttrNode)
        APError("Unable to parse XML output", hr);

    // Loop through attribute list.
    while(pXMLAttrNode)
    {
        BSTR bszName;
        variant_t vtVal;

        // Get attribute name and value.
        hr = pXMLAttrNode->get_nodeName(&bszName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        hr = pXMLAttrNode->get_nodeValue(&vtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        bstr_t bsz(bszName, false);
        if(stricmp(static_cast<PSTR>(bsz), "NAME")==0)
        {
            bstr_t bszTemp = vtVal;            
            strncpy(pADOInfo->mr.Name, static_cast<PSTR>(bszTemp), 100);
        }

        SafeRelease(pXMLAttrNode);
        hr = pXMLAttrList->nextNode(&pXMLAttrNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    // Get info block, if present, for this module.
    hr = pXMLModuleNode->get_childNodes(&pXMLNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        DOMNodeType domNodeType;

        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bstr;
            hr = pXMLChildNode->get_nodeName(&bstr);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);

            bstr_t bszName(bstr, false);

            // If info node, get info block.
            if(stricmp(bszName, "Info") == 0)
                GetImageInfo(pXMLChildNode, &pADOInfo->mr.info);
            // Otherwise, if a systemmodule node, get systemmodule state.
            else if(stricmp(bszName, "SYSTEMMODULE")==0)
            {
                hr = pXMLChildNode->get_attributes(&pXMLAttrList);
                if(FAILED(hr) || !pXMLAttrList)
                    APError("Unable to parse XML output", hr);

                hr = pXMLAttrList->nextNode(&pXMLAttrNode);
                if(FAILED(hr) || !pXMLAttrNode)
                    APError("Unable to parse XML output", hr);

                while(pXMLAttrNode)
                {
                    BSTR bszAttrName;
                    variant_t vtVal;

                    hr = pXMLAttrNode->get_nodeName(&bszAttrName);
                    if(FAILED(hr))
                        APError("Unable to parse XML output", hr);

                    hr = pXMLAttrNode->get_nodeValue(&vtVal);
                    if(FAILED(hr))
                        APError("Unable to parse XML output", hr);

                    bstr_t bsz(bszAttrName, false);
                    if(stricmp(static_cast<PSTR>(bsz), "VALUE")==0)
                    {
                        bstr_t bszTemp = vtVal;            
                        pADOInfo->mr.SysMod = atoi(bszTemp);                                               
                    }

                    SafeRelease(pXMLAttrNode);
                    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
                    if(FAILED(hr))
                        APError("Unable to parse XML output", hr);
                }
            }
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
  
    // Add a new module record to the database
    hr = pADOInfo->prbModules->AddNew(&pADOInfo->mr);
    if(FAILED(hr))
        APError("Unable to new module record to database", hr);

    ULONG lThisModuleID = pADOInfo->mr.ModuleID;

    // Get all functions's imported by this module, and DLL's
    hr = pXMLModuleNode->get_childNodes(&pXMLNodeList);
    if(FAILED(hr))        
        APError("Unable to parse XML output", hr);

    hr = pXMLNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        DOMNodeType domNodeType;

        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bstr;
            hr = pXMLChildNode->get_nodeName(&bstr);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);

            bstr_t bszName(bstr, false);

            if(stricmp(bszName, "Function") == 0)
                GetFunctionInfo(pXMLChildNode, lThisModuleID, pADOInfo);
            else if(stricmp(bszName, "DLL") == 0)
                GetModuleInfo(pXMLChildNode, lThisModuleID, pADOInfo, hEvent);
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    SafeRelease(pXMLChildNode);
    SafeRelease(pXMLNodeList);
    SafeRelease(pXMLAttrList);
    SafeRelease(pXMLAttrNode);    
}

// Get project information from XML
void GetProjectInfo(IXMLDOMNode* pXMLProjectNode, SADOInfo* pADOInfo, HANDLE hEvent)
{
    if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
        return;

    HRESULT hr;
    IXMLDOMNamedNodeMap*    pXMLAttrList= 0;
    IXMLDOMNode*            pXMLAttrNode = 0;
    IXMLDOMNode*            pXMLChildNode = 0;
    IXMLDOMNodeList*        pXMLNodeList = 0;       

    pADOInfo->pr.PtolemyID = -1;
    pADOInfo->pr.Name[0] = '\0';

    // Get name and ptolemy id attributes
    hr = pXMLProjectNode->get_attributes(&pXMLAttrList);
    if(FAILED(hr) || !pXMLAttrList)
        APError("Unable to parse XML output", hr);

    hr = pXMLAttrList->nextNode(&pXMLAttrNode);
    if(FAILED(hr) || !pXMLAttrNode)
        APError("Unable to parse XML output", hr);

    while(pXMLAttrNode)
    {
        BSTR bszName;
        variant_t vtVal;

        hr = pXMLAttrNode->get_nodeName(&bszName);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        hr = pXMLAttrNode->get_nodeValue(&vtVal);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        bstr_t bsz(bszName, false);
        if(stricmp(static_cast<PSTR>(bsz), "NAME")==0)
        {
            bstr_t bszTemp = vtVal;
            strncpy(pADOInfo->pr.Name, static_cast<PSTR>(bszTemp), 100);
        }
        else if(stricmp(static_cast<PSTR>(bsz), "ID") == 0)
        {
            bstr_t bszTemp = vtVal;
            pADOInfo->pr.PtolemyID = atoi(static_cast<PSTR>(bszTemp));
        }

        SafeRelease(pXMLAttrNode);
        hr = pXMLAttrList->nextNode(&pXMLAttrNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    hr = pADOInfo->prbProjects->AddNew(&pADOInfo->pr);
    if(FAILED(hr))
        APError("Unable to add new project record to database", hr);
    
    // Parse all Exe's included in this project
    hr = pXMLProjectNode->get_childNodes(&pXMLNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        DOMNodeType domNodeType;

        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bstr;
            hr = pXMLChildNode->get_nodeName(&bstr);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);

            bstr_t bszName(bstr, false);

            if(stricmp(bszName, "EXE") == 0)
                GetModuleInfo(pXMLChildNode, pADOInfo->pr.PtolemyID, pADOInfo, hEvent, true);
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }    
    
    SafeRelease(pXMLAttrList);
    SafeRelease(pXMLAttrNode);
    SafeRelease(pXMLNodeList);
    SafeRelease(pXMLChildNode);
}

// Functions for walking an XML DOM object and storing
// information to the database
void ParseXMLWriteDB(const char* szXML, const char* szConnect, HANDLE hEvent)
{
    HRESULT hr;

    // Get DOM object associated with Projects node
    IXMLDOMDocument*    pXMLDoc = 0;    
    IXMLDOMNode*        pXMLRootNode = 0;
    IXMLDOMNode*        pXMLChildNode = 0;
    IXMLDOMNode*        pXMLProjectNode = 0;

    IXMLDOMNodeList*    pXMLChildNodeList = 0;

    // Create all ADO objects needed.
    SADOInfo adoInfo;    

    _ConnectionPtr pConn = 0;
    _RecordsetPtr pRSProjects = 0;
    _RecordsetPtr pRSModules = 0;    
    _RecordsetPtr pRSFuncs = 0;

    pConn.CreateInstance(__uuidof(Connection));
    pRSProjects.CreateInstance(__uuidof(Recordset));
    pRSModules.CreateInstance(__uuidof(Recordset));    
    pRSFuncs.CreateInstance(__uuidof(Recordset));

    hr = pRSProjects->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&adoInfo.prbProjects));
    if(FAILED(hr))
        APError("Unable to retrieve ADO Recordset interface", hr);
    
    hr = pRSModules->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&adoInfo.prbModules));
    if(FAILED(hr))
        APError("Unable to retrieve ADO Recordset interface", hr);

    hr = pRSFuncs->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&adoInfo.prbFuncs));
    if(FAILED(hr))
        APError("Unable to retrieve ADO Recordset interface", hr);

    pConn->Open(szConnect, "", "", adConnectUnspecified);

    pConn->BeginTrans();

    pRSProjects->Open("Projects", variant_t((IDispatch*)pConn, true),
        adOpenKeyset, adLockOptimistic, adCmdTable);

    pRSModules->Open("Modules", variant_t((IDispatch*)pConn, true),
        adOpenKeyset, adLockOptimistic, adCmdTable);
    
    pRSFuncs->Open("Functions", variant_t((IDispatch*)pConn, true),
        adOpenKeyset, adLockOptimistic, adCmdTable);
    
    adoInfo.pConn = pConn;    
    
    adoInfo.pr.Name[0] = '\0';
    adoInfo.pr.PtolemyID = -1;
    
    adoInfo.mr.info.BinFileVersionStatus = 
        adoInfo.mr.info.BinProductVersionStatus =
        adoInfo.mr.info.CheckSumStatus = 
        adoInfo.mr.info.CompanyNameStatus = 
        adoInfo.mr.info.DateStatus = 
        adoInfo.mr.info.FileDescStatus = 
        adoInfo.mr.info.ProductNameStatus = 
        adoInfo.mr.info.ProductVersionStatus =
        adoInfo.mr.info.SizeStatus = 
        adoInfo.mr.ParentIDStatus = 
        adoInfo.mr.PtolemyIDStatus = 
        adoInfo.fr.AddressStatus = 
        adoInfo.fr.HintStatus = 
        adoInfo.fr.OrdinalStatus = 
        adoInfo.fr.ForwardNameStatus = adFldNull;

    hr = adoInfo.prbProjects->BindToRecordset(&adoInfo.pr);
    if(FAILED(hr))
        APError("Unable to bind ADO recordset", hr);

    hr = adoInfo.prbModules->BindToRecordset(&adoInfo.mr);
    if(FAILED(hr))
        APError("Unable to bind ADO recordset", hr);
    
    hr = adoInfo.prbFuncs->BindToRecordset(&adoInfo.fr);
    if(FAILED(hr))
        APError("Unable to bind ADO recordset", hr);

    hr = CoCreateInstance(CLSID_DOMDocument, 0, CLSCTX_INPROC_SERVER,
        IID_IXMLDOMDocument, reinterpret_cast<void**>(&pXMLDoc));
    if(FAILED(hr))    
        APError("Unable to create IE XML DOM object", hr);

    VARIANT_BOOL fSuccess;
    hr = pXMLDoc->load(variant_t(szXML), &fSuccess);
    if(FAILED(hr) || fSuccess == VARIANT_FALSE)
        APError("Unable to load XML output", hr);

    // Walk the tree until we find the top-level project node
    // which is the only top-level node we care about.
    hr = pXMLDoc->QueryInterface(IID_IXMLDOMNode, 
        reinterpret_cast<void**>(&pXMLRootNode));

    if(FAILED(hr))
        APError("Unable to retrieve IE XML interface", hr);

    hr = pXMLRootNode->get_childNodes(&pXMLChildNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLChildNodeList->nextNode(&pXMLChildNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLChildNode)
    {
        // Check if this is the projects node.
        DOMNodeType domNodeType;
        hr = pXMLChildNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bszName;
            hr = pXMLChildNode->get_nodeName(&bszName);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);


            _bstr_t bsz(bszName, false);
            if(stricmp(static_cast<PSTR>(bsz), "AppParseResults")==0)
            {                
                break;
            }            
        }

        SafeRelease(pXMLChildNode);
        hr = pXMLChildNodeList->nextNode(&pXMLChildNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }

    SafeRelease(pXMLChildNodeList);

    // No child node, record not found.
    if(!pXMLChildNode)    
        APError("Unable to parse XML output", hr);    

    // Locate project node in that.
    hr = pXMLChildNode->get_childNodes(&pXMLChildNodeList);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    hr = pXMLChildNodeList->nextNode(&pXMLProjectNode);
    if(FAILED(hr))
        APError("Unable to parse XML output", hr);

    while(pXMLProjectNode)
    {
        // Check if this is the projects node.
        DOMNodeType domNodeType;
        hr = pXMLProjectNode->get_nodeType(&domNodeType);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);

        if(domNodeType == NODE_ELEMENT)
        {
            BSTR bszName;
            hr = pXMLProjectNode->get_nodeName(&bszName);
            if(FAILED(hr))
                APError("Unable to parse XML output", hr);


            _bstr_t bsz(bszName, false);
            if(stricmp(static_cast<PSTR>(bsz), "Project")==0)
            {
                GetProjectInfo(pXMLProjectNode, &adoInfo, hEvent);
            }            
        }

        SafeRelease(pXMLProjectNode);
        hr = pXMLChildNodeList->nextNode(&pXMLProjectNode);
        if(FAILED(hr))
            APError("Unable to parse XML output", hr);
    }
    
    pRSProjects->UpdateBatch(adAffectAll);   

    pRSModules->UpdateBatch(adAffectAll);
    
    pRSFuncs->UpdateBatch(adAffectAll);

    // Important, skip commit if cancel was clicked by user.
    if(WaitForSingleObject(hEvent, 0) != WAIT_OBJECT_0)     
        pConn->CommitTrans();

    pRSProjects->Close();

    pRSModules->Close();    
    
    pRSFuncs->Close();

    pConn->Close();

    SafeRelease(adoInfo.prbProjects);
    SafeRelease(adoInfo.prbModules);    
    SafeRelease(adoInfo.prbFuncs);
    
    SafeRelease(pXMLChildNodeList);
    SafeRelease(pXMLChildNode);
    SafeRelease(pXMLRootNode);
    SafeRelease(pXMLDoc);

}

/////////////////////////////////////////////////////////////////////////////
// CAppParse
STDMETHODIMP CAppParse::Parse()
{
    if(!m_szPath)
    {
        ::MessageBox(0, TEXT("Please select a path to profile"), TEXT("AppParse"),
            MB_OK | MB_ICONERROR);
        return S_OK;
    }

    if(m_ID == -1)
    {
        ::MessageBox(0, TEXT("Please enter a Ptolemy ID"), TEXT("AppParse"),
            MB_OK | MB_ICONERROR);
        return S_OK;
    }    

    // Show the progress dialog (reset the event to cancel)
    ResetEvent(m_hEvent);
    InitProgressDialog("Parsing, please do not close your browser window.", m_hEvent);

    // Generate a unique temp file name
    GUID guid;
    unsigned char* szUUID;

    char szFileName[MAX_PATH];

    HRESULT hr = CoCreateGuid(&guid);
    if(FAILED(hr))
        return hr;

    UuidToString(&guid, &szUUID);

    GetTempPath(MAX_PATH, szFileName);
    strcat(szFileName, reinterpret_cast<char*>(szUUID));
    strcat(szFileName, ".xml");

    FILE* pFile = fopen(szFileName, "wb");
    if(!pFile)
        APError("Unable to open output file", E_FAIL);

    // Parse the application
    AppParse(m_szPath, pFile, false, false, true, true, 
        "*", m_ID);

    fclose(pFile);

    RpcStringFree(&szUUID);

    // If user didn't cancel . . .
    if(WaitForSingleObject(m_hEvent, 0) != WAIT_OBJECT_0)
    {
            
        // Write results to DB
        try
        {
            ParseXMLWriteDB(szFileName, m_szConnect, m_hEvent);
        }
        catch(_com_error& e)
        {    
            ::MessageBox(0, (LPCSTR)e.ErrorMessage(), "COM Error", MB_OK);
        }
    }
    
    // Terminate temp file
    DeleteFile(szFileName);

    // Remove progress dialog box.
    KillProgressDialog();

    return S_OK;
}

STDMETHODIMP CAppParse::Browse()
{
    PTSTR szPath = BrowseForFolder(0, 0);

    if(!szPath)
        return S_FALSE;

    if(m_szPath)
        delete m_szPath;

    m_szPath = new char[strlen(szPath)+1];
    strcpy(m_szPath,szPath);    

    return S_OK;
}

STDMETHODIMP CAppParse::get_path(BSTR *pVal)
{
    if(m_szPath)
    {
        OLECHAR* sz;
        sz = new OLECHAR[strlen(m_szPath)+1];
        MultiByteToWideChar(CP_ACP, 0, m_szPath, -1, sz, strlen(m_szPath)+1);
        *pVal = SysAllocString(sz);
        delete sz;
    }
    else
        *pVal = SysAllocString(L"");

    return S_OK;
}

STDMETHODIMP CAppParse::put_path(BSTR newVal)
{
    if(m_szPath)
    {
        delete m_szPath;
        m_szPath = 0;
    }

    _bstr_t bstrGhostLoc(newVal);
    LPSTR szGhostLoc = (LPSTR)bstrGhostLoc;
    m_szPath = new char[strlen(szGhostLoc)+1];
    strcpy(m_szPath, szGhostLoc);

    return S_OK;
}

STDMETHODIMP CAppParse::get_PtolemyID(long *pVal)
{
    *pVal = m_ID;
    return S_OK;
}

STDMETHODIMP CAppParse::put_PtolemyID(long newVal)
{
    m_ID = newVal;
    return S_OK;
}

STDMETHODIMP CAppParse::get_ConnectionString(BSTR *pVal)
{
    if(m_szConnect)
    {
        OLECHAR* sz;
        sz = new OLECHAR[strlen(m_szConnect)+1];
        MultiByteToWideChar(CP_ACP, 0, m_szConnect, -1, sz, strlen(m_szConnect)+1);
        *pVal = SysAllocString(sz);
        delete sz;
    }
    else
        *pVal = SysAllocString(L"");


    return S_OK;
}

STDMETHODIMP CAppParse::put_ConnectionString(BSTR newVal)
{
    if(m_szConnect)
    {
        delete m_szConnect;
        m_szConnect = 0;
    }

    _bstr_t bstrGhostLoc(newVal);
    LPSTR szGhostLoc = (LPSTR)bstrGhostLoc;
    m_szConnect = new char[strlen(szGhostLoc)+1];
    strcpy(m_szConnect, szGhostLoc);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AppParseWeb.rc
//
#define IDS_PROJNAME                    100
#define IDB_APPPARSE                    101
#define IDR_APPPARSE                    102
#define IDD_PROGRESS                    201
#define IDC_PROGRESS                    201
#define IDC_PROGRESSTEXT                202
#define IDR_PARSING                     203
#define IDC_BROWSE                      204
#define IDC_ANIMHOLDER                  204
#define IDC_DIRTREE                     205
#define IDC_CANCELBUTTON                205
#define IDC_FILELISTCOMBO               206
#define IDD_BROWSE                      207

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D7EF5D73_EB40_4E3F_8191_79E24E5A68A2__INCLUDED_)
#define AFX_STDAFX_H__D7EF5D73_EB40_4E3F_8191_79E24E5A68A2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D7EF5D73_EB40_4E3F_8191_79E24E5A68A2__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\appparsewrapper.h ===
// AppParse.h : Declaration of the CAppParse

#ifndef __APPPARSE_H_
#define __APPPARSE_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <windows.h>
#include <icrsint.h>
#include <oledb.h>

#import "C:\Program Files\Common Files\System\ADO\msado15.dll" \
    no_namespace rename("EOF", "EndOfFile")

void APError(char* szMessage, HRESULT hr);

/////////////////////////////////////////////////////////////////////////////
// CAppParse
class ATL_NO_VTABLE CAppParse : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IAppParse, &IID_IAppParse, &LIBID_APPPARSEWEBLib>,
	public CComControl<CAppParse>,
	public IPersistStreamInitImpl<CAppParse>,
	public IOleControlImpl<CAppParse>,
	public IOleObjectImpl<CAppParse>,
	public IOleInPlaceActiveObjectImpl<CAppParse>,
	public IViewObjectExImpl<CAppParse>,
	public IOleInPlaceObjectWindowlessImpl<CAppParse>,
	public IPersistStorageImpl<CAppParse>,
	public ISpecifyPropertyPagesImpl<CAppParse>,
	public IQuickActivateImpl<CAppParse>,
	public IDataObjectImpl<CAppParse>,
	public IProvideClassInfo2Impl<&CLSID_AppParse, NULL, &LIBID_APPPARSEWEBLib>,
    public CComCoClass<CAppParse, &CLSID_AppParse>,
    public IObjectSafetyImpl<CAppParse, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IObjectSafetyImpl<CAppParse, INTERFACESAFE_FOR_UNTRUSTED_DATA>

{
private:
    char* m_szConnect;
    char* m_szPath;
    long    m_ID;	

    HANDLE m_hEvent;
public:
	CAppParse()
	{
        m_hEvent = 0;

        m_szConnect = 0;
        m_szPath = 0;
        m_ID = -1;
        m_hEvent = CreateEvent(0, TRUE, FALSE, 0);
        if(!m_hEvent)
            APError("Unable to create kernel object", E_FAIL);
	}

    ~CAppParse()
    {
        if(m_hEvent)
            CloseHandle(m_hEvent);

        if(m_szPath)
            delete m_szPath;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_APPPARSE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAppParse)
	COM_INTERFACE_ENTRY(IAppParse)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CAppParse)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CAppParse)
	CHAIN_MSG_MAP(CComControl<CAppParse>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IAppParse
public:	
	STDMETHOD(QueryDB)(long PtolemyID, BSTR bstrFunction);
	STDMETHOD(get_ConnectionString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ConnectionString)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_PtolemyID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_PtolemyID)(/*[in]*/ long newVal);
	STDMETHOD(get_path)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_path)(/*[in]*/ BSTR newVal);
	STDMETHOD(Browse)();
	STDMETHOD(Parse)();

	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL 3.0 : AppParse");
		TextOut(di.hdcDraw, 
			(rc.left + rc.right) / 2, 
			(rc.top + rc.bottom) / 2, 
			pszText, 
			lstrlen(pszText));

		return S_OK;
	}
};

// All information associated with an EXE or DLL.
struct SImageFileInfo
{
    int DateStatus;
    double Date;
    
    int SizeStatus;
    int Size;
    int BinFileVersionStatus;
    CHAR BinFileVersion[50];

    int BinProductVersionStatus;
    CHAR BinProductVersion[50];

    int CheckSumStatus;
    ULONG CheckSum;

    int CompanyNameStatus;
    CHAR CompanyName[255];

    int ProductVersionStatus;
    CHAR ProductVersion[50];

    int ProductNameStatus;
    CHAR ProductName[255];

    int FileDescStatus;
    CHAR FileDesc[255];
};

// Record bindings, eases associating database records with C++ structures.

// A Project record, a single entry in the "Projects" table
struct SProjectRecord : public CADORecordBinding
{
BEGIN_ADO_BINDING(SProjectRecord)

	// All fields optional
    ADO_NUMERIC_ENTRY2(1, adInteger, PtolemyID, 5, 0, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY4(2, adVarChar, Name, 255, TRUE)

END_ADO_BINDING()
    
	// A unique identifier for this project.
    ULONG PtolemyID;
	
	// A user-friendly name for the project
    CHAR Name[255];
};

// A Module (EXE or DLL) record
struct SModuleRecord : public CADORecordBinding
{
    BEGIN_ADO_BINDING(SModuleRecord)

    // Query the autonumber DllID, don't change
    ADO_NUMERIC_ENTRY2(1, adInteger, ModuleID, 5, 0, FALSE)

    // At least one of these fields must be present
    ADO_NUMERIC_ENTRY(2, adInteger, ParentID, 5, 0, PtolemyIDStatus, TRUE)
    ADO_NUMERIC_ENTRY(3, adInteger, ParentID, 5, 0, ParentIDStatus, TRUE)

    // Required fields    
    ADO_VARIABLE_LENGTH_ENTRY4(4, adVarChar, Name, 255, TRUE)
    ADO_FIXED_LENGTH_ENTRY2(5, adBoolean, SysMod, TRUE)

    // Optional fields
    ADO_FIXED_LENGTH_ENTRY(6, adDate, info.Date, info.DateStatus, TRUE)
    ADO_NUMERIC_ENTRY(7, adInteger, info.Size, 5, 0, info.SizeStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(8, adVarChar, info.BinFileVersion, 50,
        info.BinFileVersionStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(9, adVarChar, info.BinProductVersion, 50,
        info.BinProductVersionStatus, TRUE)
    ADO_NUMERIC_ENTRY(10, adInteger, info.CheckSum, 5, 0, info.CheckSumStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(11, adVarChar, info.CompanyName, 255, info.CompanyNameStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(12, adVarChar, info.ProductVersion, 50, info.ProductVersionStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(13, adVarChar, info.ProductName, 255, info.ProductNameStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(14, adVarChar, info.FileDesc, 255, info.FileDescStatus, TRUE)

END_ADO_BINDING()

public:

	// Unique ID for this entry (autonumber, done by DB)
    ULONG ModuleID;
    
	// Whether this module belongs to a project or 
	// is a child of another module
    int PtolemyIDStatus;
    int ParentIDStatus;

	// Parent's ID (either Ptolemy or Module)
    ULONG ParentID;

	// Filename of this module.
    CHAR Name[255];

	// File info
    SImageFileInfo info;

	// Whether or not this is a "system" module (like kernel32, user, gdi, advapi, etc.)
    DWORD SysMod;
};

// A Function Record
struct SFunctionRecord : public CADORecordBinding
{
BEGIN_ADO_BINDING(SFunctionRecord)

    // Required fields
    ADO_NUMERIC_ENTRY2(1, adInteger, FunctionID, 5, 0, FALSE)
    ADO_NUMERIC_ENTRY2(2, adInteger, ModuleID, 5, 0, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY4(3, adVarChar, Name, 255, TRUE)

    ADO_FIXED_LENGTH_ENTRY2(8, adBoolean, Delayed, TRUE)

    // Optional fields
    ADO_NUMERIC_ENTRY(4, adInteger, Address, 5,0,AddressStatus, TRUE)
    ADO_NUMERIC_ENTRY(5, adInteger, Ordinal, 5, 0, OrdinalStatus, TRUE)
    ADO_NUMERIC_ENTRY(6, adInteger, Hint, 5, 0, HintStatus, TRUE)
    ADO_VARIABLE_LENGTH_ENTRY2(7, adVarChar, ForwardName, 255, 
        ForwardNameStatus, TRUE)
    

END_ADO_BINDING()

public:

	// Unique ID for this function (autonumber, given by the DB)
    ULONG FunctionID;

	// Parent module
    ULONG ModuleID;

	// Imported function name
    CHAR Name[255];

	// Address, if bound
    int AddressStatus;
    ULONG Address;

	// Ordinal, if ordinal import
    int OrdinalStatus;
    ULONG Ordinal;

	// Hint, if name import
    int HintStatus;
    ULONG Hint;

	// Forwarded name (e.g., HeapAlloc->RtlAllocateHeap)
    int ForwardNameStatus;
    CHAR ForwardName[255];

	// Whether this is a delayed import or not.
    DWORD Delayed;
};

// "Safely" release a COM object.
template<class T>
inline void SafeRelease(T& obj)
{
    if(obj)
	{
        obj->Release();
		obj = 0;
	}
}

#endif //__APPPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\querydb.cpp ===
// QueryDB.cpp: Database querying methods.
#include "stdafx.h"
#include "AppParseWeb.h"
#include "AppParseWrapper.h"
#include <oledb.h>
#include <comdef.h>
#include <mshtml.h>
#include <assert.h>

// Progress dialog functions
void InitProgressDialog(char* szText, HANDLE hEvent);
void KillProgressDialog();

// Return true if name matches search string, false otherwise.
bool MatchName(char* szString, char* szSearchIn);

// Tree used to represent parse information
class CTreeNode
{
private:    
    enum {c_Root, c_Project, c_Module, c_Function} m_eType;
    
    int m_nChildren;
    CTreeNode** m_ppChildren;

	// Relevent info retrieved from DB
    union
    {
        struct
        {
            char szName[256];
            long lPtolemyID;
        } m_ProjectInfo;

        struct
        {
            char szName[256];
        } m_ModuleInfo;

        struct
        {
            char szName[256];
        } m_FunctionInfo;
    };    

	// HTML generation members

	// Unique table and div ID's.
	static int m_iCurrDiv;
	static int m_iCurrTab;

	// Amount of space set aside for HTML content.
	static int m_iAllocSize;

	// Pointer to HTML content.
	static char* m_szHTML;
	// Pointer to where the more HTML should be inserted.
	static char* m_szCurrHTML;

	// Pointer a few kilobytes before the end of the HTML buffer, reaching
	// here means we should allocate more space.
	static char* m_szFencePost;

	// True if this node or one of its subtrees contains the function, false otherwise.
    bool ContainsFunction(char* szFuncName)
    {  
        if(m_eType == c_Function)
            return MatchName(m_FunctionInfo.szName, szFuncName);

        for(int i = 0; i < m_nChildren; i++)
        {
            if(m_ppChildren[i]->ContainsFunction(szFuncName))
                    return true;                            
        }

        return false;
    }

	// Write all HTML output
	void WriteHTML()
    {
        static int iDepth = 0;        
        switch(m_eType)
        {
        case c_Root:
            break;
        case c_Project:

            // Create a new table and Div in the project
            m_iCurrTab++;
            m_iCurrDiv++;

            wsprintf(m_szCurrHTML,
                "<table ID = TAB%d border = 1 width = 100%% style=\"float:right\">\n"
                "<tr>\n<td width=1%%>\n"
                "<input type=\"button\" ID=DIV%dButton value = \"+\" "
                "onClick=\"ShowItem(\'DIV%d\')\">"
                "</td>\n"
                "<td>%s</td><td width=20%%>%d</td>\n</tr>\n"
                "</table>\n"
                "<DIV ID=DIV%d style=\"display:none;\">\n",
                m_iCurrTab, m_iCurrDiv, m_iCurrDiv, 
                m_ProjectInfo.szName, m_ProjectInfo.lPtolemyID,
                m_iCurrDiv);
            
            m_szCurrHTML += strlen(m_szCurrHTML);
                                                                                
            break;
        case c_Module:
            // Create a new table and div in the project
            m_iCurrTab++;
            m_iCurrDiv++;

            wsprintf(m_szCurrHTML, 
                "<table ID = TAB%d border = 1 width = %d%% style=\"float:right\">\n"
                "<tr>\n<td width=1%%>"
                "<input type=\"button\" ID=DIV%dButton value = \"+\" "
                "onClick=\"ShowItem(\'DIV%d\')\">"
                "</td>\n"
                "<td>%s</td>\n</tr>\n"
                "</table>\n"
                "<DIV ID=DIV%d style=\"display:none;\">\n",
                m_iCurrTab, 100-iDepth*5, m_iCurrDiv, m_iCurrDiv,
                m_ModuleInfo.szName, m_iCurrDiv );

            m_szCurrHTML += strlen(m_szCurrHTML);                        
                                                                       
            break;
        case c_Function:
            // Create a new table in the project
            m_iCurrTab++;
            wsprintf(m_szCurrHTML, 
                "<table ID = TAB%d border = 1 width = %d%% style=\"float:right\">\n"
                "<tr>"
                "<td>%s</td>\n</tr>\n"
                "</table>\n",
                m_iCurrTab, 100-iDepth*5, m_FunctionInfo.szName);
            m_szCurrHTML += strlen(m_szCurrHTML);
            break;
        default:
            assert(0);
            break;
        }

		// Put in all the HTML for the children
        if(m_ppChildren)
        {
            iDepth++;
            for(int i = 0; i < m_nChildren; i++)            
                m_ppChildren[i]->WriteHTML();

            iDepth--;
        }

        switch(m_eType)
        {
        case c_Function:
        case c_Root:
            break;
        case c_Project:
        case c_Module:        
            wsprintf(m_szCurrHTML, "</DIV>\n");
            m_szCurrHTML += strlen(m_szCurrHTML);
            break;        
        }

        // Check if we should allocate more
        if(m_szCurrHTML > m_szFencePost)
        {
            m_iAllocSize *= 2;
            char* szNewBuffer = new char[m_iAllocSize];
            m_szFencePost = &szNewBuffer[m_iAllocSize - 2 * 1024];
            strcpy(szNewBuffer, m_szHTML);
            m_szCurrHTML = &szNewBuffer[strlen(szNewBuffer)];
            delete m_szHTML;
            m_szHTML = szNewBuffer;
        }

    }
public:
    CTreeNode()
    {		
        m_eType = c_Root;
        m_nChildren = 0;
        m_ppChildren = 0;
		assert(m_eType < 50);
    }

    CTreeNode(SProjectRecord pr)
    {
        m_eType = c_Project;
        m_nChildren = 0;
        m_ppChildren = 0;
        strcpy(m_ProjectInfo.szName, pr.Name);
        m_ProjectInfo.lPtolemyID = pr.PtolemyID;		
		assert(m_eType < 50);
    }

    CTreeNode(SModuleRecord mr)
    {
        m_eType = c_Module;
        m_nChildren = 0;
        m_ppChildren = 0;
        strcpy(m_ModuleInfo.szName, mr.Name);
		assert(m_eType < 50);
    }

    CTreeNode(SFunctionRecord fr)
    {
        m_eType = c_Function;
        m_nChildren = 0;
        m_ppChildren = 0;
        strcpy(m_FunctionInfo.szName, fr.Name);
		assert(m_eType < 50);
    }

    ~CTreeNode()
    {		
        RemoveChildren();
    }

	// Remove tree nodes that contain no nodes matching the search criteria.
	// Returns true if node should be removed, false otherwise.
    bool Prune(char* szFunc)
    {
		assert(m_eType < 50);
		// Go through each child
        for(int i = 0; i < m_nChildren; i++)
        {
			// Check if needs to be removed
            if(m_ppChildren[i]->Prune(szFunc))
            {
                // Remove this child.
                delete m_ppChildren[i];
                m_ppChildren[i] = 0;
            }
        }


		// Update the child list
        int nChildren = 0;
        for(i = 0; i < m_nChildren; i++)
        {
            if(m_ppChildren[i])
                nChildren++;
        }

        if(nChildren)
        {
            CTreeNode** pNew = new CTreeNode*[nChildren];
            int iCurr = 0;
            for(i = 0; i < m_nChildren; i++)
            {
                if(m_ppChildren[i])
                {
                    pNew[iCurr++] = m_ppChildren[i];
                }
            }

            delete m_ppChildren;
            m_ppChildren = pNew;

            assert(iCurr == nChildren);
        }
        else
        {
            if(m_ppChildren)
            {
                delete m_ppChildren;
                m_ppChildren = 0;
            }
        }

        m_nChildren = nChildren;

		// If we contain no children and we're not a function, we should be removed.
        if(m_nChildren == 0 && m_eType != c_Function)
            return true;

		// Return whether we don't contain the function or not.
        return !ContainsFunction(szFunc);            
    }    

	// Return a string representing the HTML representation of this tree.
	char* GetHTML()
	{
		// Should only be called on root.
		assert(m_eType == c_Root);		

		// Initially reserve space for 64K of HTML.
		m_iAllocSize = 64 * 1024;
		if(m_szHTML)
			delete m_szHTML;

        m_szHTML = new char[m_iAllocSize];
        m_szHTML[0] = '\0';
        m_szCurrHTML = m_szHTML;
        m_szFencePost = &m_szHTML[m_iAllocSize - 2 * 1024];

		// Fill it with the HTML for this node and all child nodes.
		WriteHTML();		

		char* szRet = m_szHTML;
		
		m_szHTML = 0;
		
		return szRet;
	}

	// Remove all children from this node.
    void RemoveChildren()
    {
		assert(m_eType < 50);
        while(m_nChildren)
        {
            delete m_ppChildren[m_nChildren-1];
            m_ppChildren[m_nChildren-1] = 0;
            m_nChildren--;
        }
        if(m_ppChildren)
            delete m_ppChildren;

        m_ppChildren = 0;
		assert(m_eType < 50);
    }

	// Insert a new child.
    void InsertChild(CTreeNode* pNew)
    {
        assert(pNew);
		assert(pNew->m_eType < 50);
        m_nChildren++;
        CTreeNode** pNewList = new CTreeNode*[m_nChildren];
        
        if(m_ppChildren)
        {
            memcpy(pNewList, m_ppChildren, (m_nChildren-1)*sizeof(CTreeNode*));
            delete m_ppChildren;
        }
        m_ppChildren = pNewList;
        m_ppChildren[m_nChildren-1] = pNew;
		assert(m_eType < 50);
    }
};

// Define the static members of CTreeNode
int CTreeNode::m_iCurrDiv = 0;
int CTreeNode::m_iCurrTab = 0;
int CTreeNode::m_iAllocSize = 0;
char* CTreeNode::m_szHTML = 0;
char* CTreeNode::m_szCurrHTML = 0;
char* CTreeNode::m_szFencePost = 0;

// Global tree info.
CTreeNode g_InfoTreeRoot;

// Return true if name matches search string, false otherwise.
bool MatchName(char* szString, char* szSearchIn)
{
	if(strcmp(szSearchIn, "*") == 0)
		return true;

    char* szSearch = szSearchIn;
	while(*szSearch != '\0' && *szString != '\0')
	{
		// If we get a ?, we don't care and move on to the next
		// character.
		if(*szSearch == '?')
		{
			szSearch++;
			szString++;
			continue;
		}

		// If we have a wildcard, move to next search string and search for substring
		if(*szSearch == '*')
		{
			char* szCurrSearch;
			szSearch++;

			if(*szSearch == '\0')
				return true;

			// Don't change starting point.
			szCurrSearch = szSearch;
			for(;;)
			{
				// We're done if we hit another wildcard
				if(*szCurrSearch == '*' ||
					*szCurrSearch == '?')
				{
					// Update the permanent search position.
					szSearch = szCurrSearch;
					break;
				}
				// At end of both strings, return true.
				if((*szCurrSearch == '\0') && (*szString == '\0'))
					return true;

				// We never found it
				if(*szString == '\0')						
					return false;

				// If it doesn't match, start over
				if(toupper(*szString) != toupper(*szCurrSearch))
				{
					// If mismatch on first character
					// of search string, move to next
					// character in function string.
					if(szCurrSearch == szSearch)
						szString++;
					else
						szCurrSearch = szSearch;
				}
				else
				{
					szString++;
					szCurrSearch++;
				}
			}
		}
		else
		{
			if(toupper(*szString) != toupper(*szSearch))
			{
				return false;
			}

			szString++;
			szSearch++;
		}
	}

	if((*szString == 0) && ((*szSearch == '\0') || (strcmp(szSearch,"*")==0)))
		return true;
	else
		return false;
}

// Add all functions from a module to the tree.
void BuildFunctions(long lParentID, CTreeNode* pParent, _ConnectionPtr pConn)
{
    _RecordsetPtr pFunctions = 0;
    pFunctions.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];

	// Open a recordset of all functions that match
    wsprintf(szQuery, "SELECT * FROM FUNCTIONS WHERE MODULEID = %d", lParentID);    
        
    pFunctions->Open(szQuery, variant_t((IDispatch*)pConn, true), adOpenKeyset, 
        adLockOptimistic, adCmdText);


	// Bind the record set to a local structure.
    IADORecordBinding* pRBFunctions = 0;
    HRESULT hr = pFunctions->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBFunctions));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SFunctionRecord fr;

    hr = pRBFunctions->BindToRecordset(&fr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

	// Go through each record in the set
    VARIANT_BOOL fEOF;
    pFunctions->get_EndOfFile(&fEOF);
    while(!fEOF)
    {		
		// Create a new node.
        CTreeNode* pNewNode = new CTreeNode(fr);
        pParent->InsertChild(pNewNode);        
                
        pFunctions->MoveNext();
        pFunctions->get_EndOfFile(&fEOF);
    }

    pFunctions->Close();

    SafeRelease(pRBFunctions);
}


// Add all modules to the tree.
void BuildModules(long lParentID, CTreeNode* pParent, bool fTopLevel,
                  _ConnectionPtr pConn, HANDLE hEvent)
{
	// Check if we should termiante early.
	if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
		return;

    _RecordsetPtr pModules = 0;
    pModules.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];
    
	// Get recordset that matches
    if(fTopLevel)
        wsprintf(szQuery, "SELECT * FROM MODULES WHERE PTOLEMYID = %d", lParentID);
    else
        wsprintf(szQuery, "SELECT * FROM MODULES WHERE PARENTID = %d", lParentID);

        
    pModules->Open(szQuery, variant_t((IDispatch*)pConn, true), adOpenKeyset, 
        adLockOptimistic, adCmdText);


    IADORecordBinding* pRBModules = 0;
    HRESULT hr = pModules->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBModules));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SModuleRecord mr;

    hr = pRBModules->BindToRecordset(&mr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

	// Go through each record
    VARIANT_BOOL fEOF;
    pModules->get_EndOfFile(&fEOF);
    while(!fEOF)
    {
		// Insert into tree
        CTreeNode* pNewNode = new CTreeNode(mr);
        pParent->InsertChild(pNewNode);

		// Build all child modules
        BuildModules(mr.ModuleID, pNewNode, false, pConn, hEvent);

		// Build all functions
        BuildFunctions(mr.ModuleID, pNewNode, pConn);
                
        pModules->MoveNext();
        pModules->get_EndOfFile(&fEOF);
    }

    pModules->Close();

    SafeRelease(pRBModules);
}

// Add a project to the tree
void BuildProjects(long PtolemyID, char* szFunc, _ConnectionPtr pConn, HANDLE hEvent)
{
    assert(PtolemyID > 0);

	// Check if we should terminate early
	if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
		return;

    _RecordsetPtr pProjects = 0;
    pProjects.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];   
    
	// Get a recordset that matches
    wsprintf(szQuery, "SELECT * FROM PROJECTS WHERE PTOLEMYID = %d", PtolemyID);
    
    pProjects->Open(szQuery, variant_t((IDispatch*)pConn, true),adOpenKeyset, 
        adLockOptimistic, adCmdText);

    IADORecordBinding* pRBProjects = 0;
    HRESULT hr = pProjects->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBProjects));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SProjectRecord pr;

    hr = pRBProjects->BindToRecordset(&pr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

    VARIANT_BOOL fEOF;
    pProjects->get_EndOfFile(&fEOF);
    while(!fEOF)
    {
		// Insert the node at the root.
        CTreeNode* pNewNode = new CTreeNode(pr);
        g_InfoTreeRoot.InsertChild(pNewNode);

		// Get all child modules
        BuildModules(pr.PtolemyID, pNewNode, true, pConn, hEvent);

		// Save memory by trimming tree now.
        pNewNode->Prune(szFunc);        
                
        pProjects->MoveNext();
        pProjects->get_EndOfFile(&fEOF);
    }

    pProjects->Close();

    SafeRelease(pRBProjects);
}

long GetModulePtolemy(long lModuleID, _ConnectionPtr pConn)
{
    _RecordsetPtr pModules = 0;
    pModules.CreateInstance(__uuidof(Recordset));
    char szQuery[1024];

	// Get a single record recordset containing the module.
    wsprintf(szQuery, "SELECT * FROM MODULES WHERE MODULEID = %d", lModuleID);
        
    pModules->Open(szQuery, variant_t((IDispatch*)pConn, true), adOpenKeyset, 
        adLockOptimistic, adCmdText);

    IADORecordBinding* pRBModules = 0;
    HRESULT hr = pModules->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBModules));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SModuleRecord mr;

    hr = pRBModules->BindToRecordset(&mr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);
    

	// Either return ptolemy ID, if valid, otherwise call on parent module.
    long lParent = mr.ParentID;
    if(mr.ParentIDStatus != adFldNull)
    {
        pModules->Close();
        SafeRelease(pRBModules);        
        return GetModulePtolemy(lParent, pConn);
    }
    else
    {
        pModules->Close();
        SafeRelease(pRBModules);        
        return lParent;
    }
}
    
long GetFuncPtolemy(SFunctionRecord fr, _ConnectionPtr pConn)
{
    return GetModulePtolemy(fr.ModuleID, pConn);
}

// Build a list projects that contain a function that matches szFunc.
void BuildProjectsFromFunction(char* szFunc, _ConnectionPtr pConn, HANDLE hEvent)
{
	// Check if we should terminate early.
	if(WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
		return;

    _RecordsetPtr pFunctions = 0;
    pFunctions.CreateInstance(__uuidof(Recordset));
    char* szQuery = "SELECT * FROM FUNCTIONS";   
    
    pFunctions->Open(szQuery, variant_t((IDispatch*)pConn, true),adOpenKeyset, 
        adLockOptimistic, adCmdText);

    IADORecordBinding* pRBFunctions = 0;
    HRESULT hr = pFunctions->QueryInterface(__uuidof(IADORecordBinding), 
        reinterpret_cast<void**>(&pRBFunctions));
    if(FAILED(hr))
        APError("Unable to acquire record binding interface", hr);

    SFunctionRecord fr;

    hr = pRBFunctions->BindToRecordset(&fr);
    if(FAILED(hr))
        APError("Unable to bind recordset", hr);

    VARIANT vtBookMark;
    hr = pFunctions->get_Bookmark(&vtBookMark);
    if(FAILED(hr))
        APError("Unable to get recordset bookmark", hr);

	// Do a search for the function
    char szFind[512];
	int FunctionList[1024] = {0};
    wsprintf(szFind, "Name like \'%s\'", szFunc);
    pFunctions->Find(szFind, 0, adSearchForward, vtBookMark);	
    while(!pFunctions->EndOfFile)
    {

        // Get which module imports this function
        long lPtolemy = GetFuncPtolemy(fr, pConn);
        assert(lPtolemy > 0);
        
		// Make sure we haven't already touched this module.
		bool fInUse = false;
		for(int i = 0; i < 1024; i++)
		{
			if(FunctionList[i] == 0)
			{
				FunctionList[i] = lPtolemy;
				break;
			}
			else if(FunctionList[i] == lPtolemy)
			{
				fInUse = true;
			}			
		}
		if(!fInUse)
			BuildProjects(lPtolemy, szFunc, pConn, hEvent);

        hr = pFunctions->get_Bookmark(&vtBookMark);
        if(FAILED(hr))
            APError("Unable to acquire recordset bookmark", hr);
        pFunctions->Find(szFind, 1, adSearchForward, vtBookMark);
    }
    
    SafeRelease(pRBFunctions);
    pFunctions->Close();
}

STDMETHODIMP CAppParse::QueryDB(long PtolemyID, BSTR bstrFunction)
{
	assert(m_hEvent);

    try
    {
		// Start cancelation dialog
		ResetEvent(m_hEvent);
        InitProgressDialog("Querying database . . .", m_hEvent);
        
		bstr_t bszFunctionSearch = bstrFunction;
        
        char* szFunctionSearch = static_cast<char*>(bszFunctionSearch);    

        HRESULT hr;

        _ConnectionPtr pConn = 0;
    
        pConn.CreateInstance(__uuidof(Connection));

		// Connect to the DB
        pConn->Open(m_szConnect, "","", adConnectUnspecified);
		
		// Build projects
        if(PtolemyID > 0)
            BuildProjects(PtolemyID, szFunctionSearch, pConn, m_hEvent);
        else
            BuildProjectsFromFunction(szFunctionSearch, pConn, m_hEvent);

        pConn->Close();

		// Check if results should be shown.
        if(WaitForSingleObject(m_hEvent, 0) == WAIT_OBJECT_0)
		{
			g_InfoTreeRoot.RemoveChildren();
			KillProgressDialog();
			return S_OK;
		}

		// Trim the tree down.
        g_InfoTreeRoot.Prune(szFunctionSearch);

		// Get our container document.
        CComPtr<IOleContainer> pContainer = 0;

        m_spClientSite->GetContainer(&pContainer);
        CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> pDoc(pContainer);
        if(!pDoc)       
			APError("Unable to acquire container HTML document", E_FAIL);

        CComPtr<IHTMLElementCollection> pElements;
        pDoc->get_all(&pElements);
        CComPtr<IDispatch> pDispatch = 0;

		// Get the element that will contain all HTML output (the "Results" DIV)
        hr = pElements->item(variant_t("Results"), variant_t(0L), &pDispatch);

        if(FAILED(hr) || !pDispatch)
            return E_FAIL;
        
        CComQIPtr<IHTMLElement, &IID_IHTMLElement> pDivElem(pDispatch);
                   
		// Get HTML representation of tree.
        char* szHTML = g_InfoTreeRoot.GetHTML();

		// Convert to wide characters
        OLECHAR* oszInnerHTML = new OLECHAR[strlen(szHTML) + 1];

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szHTML, 
            -1, oszInnerHTML,
            (strlen(szHTML)+1)*sizeof(OLECHAR));

		delete szHTML;

		// Convert to a BSTR
        BSTR bszInnerHTML = SysAllocString(oszInnerHTML);
        delete oszInnerHTML;

		// Write the HTML into the document.
        hr = pDivElem->put_innerHTML(bszInnerHTML);
        if(FAILED(hr))
            APError("Unable to write HTML to container document", hr);
        
        SysFreeString(bszInnerHTML);
    }
    catch(_com_error& e)
    {       
        ::MessageBox(0, (LPCSTR)e.ErrorMessage(), "COM Error", MB_OK);
    }

    g_InfoTreeRoot.RemoveChildren();
    KillProgressDialog();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\browsedlg.cpp ===
// BrowseDlg.cpp
// Dialog box to enable user to select a directory and/or files.

// Author: t-michkr (June 22, 2000)

#include <windows.h>
#include "stdafx.h"


// We make use of some Win2K specific controls

#include <shellapi.h>
#include <shlwapi.h>
#include <tchar.h>
#include <assert.h>
#include "filebrowser.h"
#include "resource.h"
#include "commctrl.h"

// Display browse dialog box, and return dir string.
PSTR BrowseForFolder(HWND hwnd, PSTR szInitialPath, UINT uiFlags);

// Expand a tree item to include sub items.
void AddTreeSubItems(HWND hwTree, HTREEITEM hParent);

// Remove a tree item's subitems
void RemoveTreeSubItems(HWND hwTree, HTREEITEM hParent);

void CheckTreeSubItems(HWND hwTree, HTREEITEM hChild);

// Given a path, select the appropriate item in the tree.
// If path is invalid, it will expand as much as possible 
// (until invalid element appears)
void SelectItemFromFullPath(HWND hwTree, PTSTR szPath);

// Get full item path.  Assumes szPath is a buffer of MAX_PATH size,
// initialized with '\0'.
void GetItemPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath);

// Browse dialog proc
BOOL CALLBACK BrowseDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

// Browse dialog box message handlers.
BOOL HandleInitBrowse(HWND hwnd);
void HandleBrowseCommand(HWND hwnd, UINT uiCtrlID, UINT uiNotify, HWND hwChild);
void HandleBrowseNotify(HWND hwnd, void* pvArg);

// Buffer to hold returned path
static TCHAR s_szPathBuffer[MAX_PATH];
static PTSTR s_szInitialPath = 0;
static HIMAGELIST s_himlSystem = 0;

// Create browse dialog box, and return a path string, or
// NULL if cancel was selected.
PTSTR BrowseForFolder(HWND hwnd, PTSTR szInitialPath)
{
    CoInitialize(0);

    s_szInitialPath = szInitialPath;

    PTSTR szRet = reinterpret_cast<TCHAR*>(DialogBox(_Module.GetModuleInstance(), 
        MAKEINTRESOURCE(IDD_BROWSE), hwnd, BrowseDialogProc));

    CoUninitialize();
    return szRet;
}

// Browse dialog box proc.
BOOL CALLBACK BrowseDialogProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uiMsg)
    {
    case WM_INITDIALOG:
        return HandleInitBrowse(hwnd);
        break;
    case WM_COMMAND:
        HandleBrowseCommand(hwnd, LOWORD(wParam), HIWORD(wParam),
            reinterpret_cast<HWND>(lParam));
        break;
    case WM_NOTIFY:
        HandleBrowseNotify(hwnd, reinterpret_cast<void*>(lParam));
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

// Dialog box initialization, init tree and root tree items.
BOOL HandleInitBrowse(HWND hwnd)
{
    // Get the treeview control
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);
    if(!hwTree)
        return FALSE;

    SHFILEINFO sfi;

    TreeView_SetImageList(hwTree, reinterpret_cast<HIMAGELIST>(SHGetFileInfo(TEXT("C:\\"),
        0,&sfi, sizeof(SHFILEINFO), SHGFI_SYSICONINDEX | SHGFI_SMALLICON)), 
        TVSIL_NORMAL);

    // Get all user drives
    DWORD dwLength = GetLogicalDriveStrings(0,0);
    if(dwLength == 0)
        return FALSE;

    TCHAR* szDrives = new TCHAR[dwLength+1];
    if(!szDrives)     
        return FALSE;    

    GetLogicalDriveStrings(dwLength, szDrives);
    TCHAR* szCurrDrive = szDrives;

    // Go through each drive
    while(*szCurrDrive)
    {
        // Only pay attention to fixed drives (non-network, non-CD, non-floppy)
        if(GetDriveType(szCurrDrive) == DRIVE_FIXED)           
        {
            SHGetFileInfo(szCurrDrive, 0, &sfi, sizeof(sfi), 
                SHGFI_SYSICONINDEX);

            // Get rid of the terminating '\'
            szCurrDrive[lstrlen(szCurrDrive)-1] = TEXT('\0');

            // Insert a disk drive item into the tree root.
            TVINSERTSTRUCT tvis;
            tvis.hParent = TVI_ROOT;
            tvis.hInsertAfter = TVI_LAST;
            tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE| TVIF_TEXT;
            tvis.itemex.iImage = sfi.iIcon;
            tvis.itemex.iSelectedImage = sfi.iIcon;
            tvis.itemex.pszText = szCurrDrive;
            tvis.itemex.cchTextMax = lstrlen(szCurrDrive);

            HTREEITEM hTreeItem = TreeView_InsertItem(hwTree, &tvis);
            
            assert(hTreeItem);

            // Add subitems to the item
            AddTreeSubItems(hwTree, hTreeItem);

            // Move to next drive
            szCurrDrive += lstrlen(szCurrDrive) + 2;
        }
        else        
            // Move to next drive.
            szCurrDrive += lstrlen(szCurrDrive) + 1;
    }

    delete szDrives;

    // Select the first element.
    HTREEITEM hItem = TreeView_GetChild(hwTree, TVI_ROOT);
    TreeView_SelectItem(hwTree, hItem);

    // Force tree to update, and restore original focus
    SetFocus(hwTree);
    SetFocus(GetDlgItem(hwnd, IDOK));

    return TRUE;
}

// Catch notification messages, so we can control expansion/collapsing.
void HandleBrowseNotify(HWND hwnd, void* pvArg)
{
    // Get tree control
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);
    HWND hwFileList = GetDlgItem(hwnd, IDC_FILELISTCOMBO);
    if(!hwTree || !hwFileList)
    {
        DestroyWindow(GetParent(hwnd));
        return;
    }

    HTREEITEM hItem;
    TCHAR szPath[MAX_PATH] = TEXT("\0");

    // Get notification headers
    NMHDR* pHdr = reinterpret_cast<NMHDR*>(pvArg);
    LPNMTREEVIEW pnmTreeView = reinterpret_cast<LPNMTREEVIEW>(pvArg);    

    switch(pHdr->code)
    {
        // Expanding or collapsing, called for each child.
    case TVN_ITEMEXPANDED:

        // If we're expanding, get the sub items of all children
        if(pnmTreeView->action & TVE_EXPAND)
        {
            // Switch our parent to an open folder icon.
            if(TreeView_GetParent(hwTree, pnmTreeView->itemNew.hItem))
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX | SHGFI_OPENICON);

                TVITEMEX tvitemex;
                tvitemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvitemex.hItem = pnmTreeView->itemNew.hItem;
                tvitemex.iImage = sfi.iIcon;
                tvitemex.iSelectedImage = sfi.iIcon;

                TreeView_SetItem(hwTree, &tvitemex);
            }

            // Add all sub-items to this item.
            AddTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);

            // Go through each child, and and check if expansion should be allowed
            HTREEITEM hChild = TreeView_GetChild(hwTree, pnmTreeView->itemNew.hItem);
            while(hChild != NULL)
            {
                CheckTreeSubItems(hwTree, hChild);                
                hChild = TreeView_GetNextSibling(hwTree, hChild);
            }
        }
        else if(pnmTreeView->action & TVE_COLLAPSE)
        {
            // Switch parent to a closed icon.
            if(TreeView_GetParent(hwTree, pnmTreeView->itemNew.hItem))
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX | SHGFI_OPENICON);

                TVITEMEX tvitemex;
                tvitemex.mask = TVIF_IMAGE |  TVIF_SELECTEDIMAGE | TVIF_HANDLE;
                tvitemex.hItem = pnmTreeView->itemNew.hItem;
                tvitemex.iImage = sfi.iIcon;
                tvitemex.iSelectedImage = sfi.iIcon;

                TreeView_SetItem(hwTree, &tvitemex);
            }

            // Remove all subitems for every child.
            RemoveTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);
            CheckTreeSubItems(hwTree, pnmTreeView->itemNew.hItem);            
        }
        break;
    case TVN_SELCHANGED:

        // Only bother updating edit box if the tree has the focus
        if(GetFocus() == hwTree)
        {
            GetItemPath(hwTree, pnmTreeView->itemNew.hItem, szPath);
            SetWindowText(hwFileList, szPath);         
        }

        break;

        // When treeview gains focus, make sure file list and tree view
        // selection are in sync.
    case NM_SETFOCUS:        
        hItem = TreeView_GetSelection(hwTree);        

        GetItemPath(hwTree, hItem, szPath);
        SetWindowText(hwFileList, szPath);         
        break;
    }
}

// Handle a command message.
void HandleBrowseCommand(HWND hwnd, UINT uiCtrlID, UINT uiNotify, HWND hwCtrl)
{
    HWND hwTree = GetDlgItem(hwnd, IDC_DIRTREE);    
    HTREEITEM hSelected;
    TVITEMEX tvItem;

    TCHAR szPath[MAX_PATH];

    switch(uiCtrlID)
    {
        // Get path of item, and return it.
    case IDOK:               
        // Retrieve item from tree view.
        hSelected = TreeView_GetSelection(hwTree);
        if(!hSelected)
        {
            MessageBeep(0);
            break;
        }
        
        s_szPathBuffer[0] = TEXT('\0');
        
        GetItemPath(hwTree, hSelected, s_szPathBuffer);
        if(s_szPathBuffer[lstrlen(s_szPathBuffer)-1]== TEXT('\\'))
            s_szPathBuffer[lstrlen(s_szPathBuffer)-1] = TEXT('\0');

        // Validate the path
        if(GetFileAttributes(s_szPathBuffer)==static_cast<DWORD>(-1))
            ::MessageBox(0, TEXT("Invalid Path"), TEXT("ERROR"), 
            MB_OK | MB_ICONINFORMATION);
        else 
            EndDialog(hwnd, reinterpret_cast<INT_PTR>(s_szPathBuffer));        

        break;

    case IDCANCEL:
        // User selected cancel, just return null.
        EndDialog(hwnd, 0);
        break;

    case IDC_FILELISTCOMBO:
        switch(uiNotify)
        {
        case CBN_EDITCHANGE:
            SendMessage(hwCtrl, WM_GETTEXT, MAX_PATH, 
                reinterpret_cast<LPARAM>(szPath));

            SelectItemFromFullPath(hwTree, szPath);
            break;

        case CBN_DROPDOWN:            
            // clear the combo box.
            SendMessage(hwCtrl, CB_RESETCONTENT, 0, 0);

            // Fill the combo box with all the lowest level items under
            // treeview selection
            hSelected = TreeView_GetSelection(hwTree);
            tvItem.mask = TVIF_STATE | TVIF_HANDLE;
            tvItem.hItem = hSelected;            

            TreeView_GetItem(hwTree, &tvItem);

            if(tvItem.state & TVIS_EXPANDED)
            {
                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hSelected, szPath);

                SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                    reinterpret_cast<LPARAM>(szPath));

                HTREEITEM hItem = TreeView_GetChild(hwTree, tvItem.hItem);
                while(hItem)
                {
                    szPath[0] = TEXT('\0');
                    GetItemPath(hwTree, hItem, szPath);
                    SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(szPath));
                    hItem = TreeView_GetNextSibling(hwTree, hItem);
                }
            }
            else
            {
                HTREEITEM hItem;
                hItem = TreeView_GetParent(hwTree, tvItem.hItem);
                hItem = TreeView_GetChild(hwTree, hItem);
  
                while(hItem)
                {
                    szPath[0] = TEXT('\0');
                    GetItemPath(hwTree, hItem, szPath);
                    SendMessage(hwCtrl, CB_ADDSTRING, 0, 
                        reinterpret_cast<LPARAM>(szPath));
                    hItem = TreeView_GetNextSibling(hwTree, hItem);
                }
            }

            break;
        }
        break;
    };
}

// Expand an item to get its full path.
void GetItemPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath)
{
    assert(hwTree);
    assert(hItem);
    assert(szPath);
    assert(szPath[0] == TEXT('\0'));

    // Recurse to get parent's path.
    HTREEITEM hParent = TreeView_GetParent(hwTree, hItem);
    if(hParent)
    {
        GetItemPath(hwTree, hParent, szPath);
        lstrcat(szPath, TEXT("\\"));
    }

    // Get item text, concatenate on current path..
    TVITEMEX tvItem;

    tvItem.mask = TVIF_TEXT | TVIF_HANDLE;
    tvItem.hItem = hItem;
    tvItem.pszText = szPath + lstrlen(szPath);
    tvItem.cchTextMax = MAX_PATH - lstrlen(szPath);
    
    TreeView_GetItem(hwTree, &tvItem);
}

// Remove all subitems below an element.
void RemoveTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);
    
    // Go through each child and delete.
    HTREEITEM hChild = TreeView_GetChild(hwTree, hParent);
    while(hChild != NULL)
    {
        HTREEITEM hSibling = TreeView_GetNextSibling(hwTree, hChild);

        // Recursively delete all subitems in this child.
        RemoveTreeSubItems(hwTree, hChild);

        // Remove this item.
        TreeView_DeleteItem(hwTree, hChild);

        // Move to next.
        hChild = hSibling;        
    }
}

// Add items below an element.
void AddTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);

    // Clear-out (to ensure we don't add items twice)
    RemoveTreeSubItems(hwTree, hParent);

    // Do an early out if the item has already been expanded
    TVITEMEX tvitem;
    tvitem.mask = TVIF_CHILDREN | TVIF_HANDLE;
    tvitem.hItem = hParent;
    TreeView_GetItem(hwTree, &tvitem);
    if(tvitem.cChildren)
        return;
    
    // Do a search on all directories
    TCHAR szPath[MAX_PATH] = TEXT("");
    GetItemPath(hwTree, hParent, szPath);

    WIN32_FIND_DATA findData;

    lstrcat(szPath, TEXT("\\*.*"));

    HANDLE hSearch = FindFirstFile(szPath, &findData);
    if(hSearch == INVALID_HANDLE_VALUE)
        return;

    do
    {
        // Ignore if a relative directory (. or ..)
        // or if no select files were selected and it is not a directory
        // otherwise
        if(findData.cFileName[0] != TEXT('.'))
        {
            if(StrStrI(findData.cFileName, ".exe") || (
                findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                SHFILEINFO sfi;

                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hParent, szPath);
                lstrcat(szPath, TEXT("\\"));
                lstrcat(szPath, findData.cFileName);
                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX);
            
                // Insert an item representing this directory.
                TVINSERTSTRUCT tvis;
                tvis.hParent = hParent;
                tvis.hInsertAfter = TVI_SORT;
                tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
                tvis.itemex.iImage = sfi.iIcon;
                tvis.itemex.iSelectedImage = sfi.iIcon;
                tvis.itemex.pszText = findData.cFileName;
                tvis.itemex.cchTextMax = lstrlen(findData.cFileName);

                TreeView_InsertItem(hwTree, &tvis);
            }
        }        

        // Move to next file.
    } while(FindNextFile(hSearch, &findData));

    FindClose(hSearch);
}

void CheckTreeSubItems(HWND hwTree, HTREEITEM hParent)
{
    assert(hwTree);

    // Do a search on all directories
    TCHAR szPath[MAX_PATH] = TEXT("");
    GetItemPath(hwTree, hParent, szPath);

    WIN32_FIND_DATA findData;

    lstrcat(szPath, TEXT("\\*.*"));

    HANDLE hSearch = FindFirstFile(szPath, &findData);
    if(hSearch == INVALID_HANDLE_VALUE)
        return;

    do
    {
        // Ignore if a relative directory (. or ..)
        // or if no select files were selected and it is not a directory
        // otherwise
        if((findData.cFileName[0] != TEXT('.')))
        {
            if(StrStrI(findData.cFileName, ".exe") || (
                findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                SHFILEINFO sfi;

                szPath[0] = TEXT('\0');
                GetItemPath(hwTree, hParent, szPath);
                lstrcat(szPath, TEXT("\\"));
                lstrcat(szPath, findData.cFileName);
                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), 
                    SHGFI_SYSICONINDEX);
            
                // Insert an item representing this directory.
                TVINSERTSTRUCT tvis;
                tvis.hParent = hParent;
                tvis.hInsertAfter = TVI_SORT;
                tvis.itemex.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
                tvis.itemex.iImage = sfi.iIcon;
                tvis.itemex.iSelectedImage = sfi.iIcon;
                tvis.itemex.pszText = findData.cFileName;
                tvis.itemex.cchTextMax = lstrlen(findData.cFileName);

                TreeView_InsertItem(hwTree, &tvis);

                FindClose(hSearch);
                return;
            }
        }        

        // Move to next file.
    } while(FindNextFile(hSearch, &findData));

    FindClose(hSearch);
}

// Given a relative path and a tree item, select a subitem from the relative path.
// Returns true if item successfully selected, false otherwise.
bool SelectSubitemFromPartialPath(HWND hwTree, HTREEITEM hItem, PTSTR szPath)
{
    bool fExpandIt = false;
    TCHAR* szPathDelim = _tcschr(szPath, TEXT('\\'));

    if(szPathDelim)
    {
        if(szPathDelim == szPath)
            return false;
        *szPathDelim = TEXT('\0');
        if(szPathDelim[1] == TEXT('\0'))
        {
            szPathDelim = 0;
            fExpandIt = true;
        }
    }

    // Find this path.
    HTREEITEM hClosestChild = 0;
    HTREEITEM hChild = TreeView_GetChild(hwTree, hItem);
    while(hChild)
    {
        TCHAR szItemPath[MAX_PATH];

        TVITEMEX tvitem;
        tvitem.mask = TVIF_HANDLE | TVIF_TEXT;
        tvitem.hItem = hChild;
        tvitem.pszText = szItemPath;
        tvitem.cchTextMax = MAX_PATH;

        TreeView_GetItem(hwTree, &tvitem);

        if(lstrcmpi(szPath,tvitem.pszText) == 0)
            break;
        else if((StrStrI(tvitem.pszText, szPath) == tvitem.pszText) && !fExpandIt)
        {
            hClosestChild = hChild;
            break;
        }

        hChild = TreeView_GetNextSibling(hwTree, hChild);
    }

    if(!hChild)
    {
        if(!hClosestChild)
            return false;
        else
        {
            hChild = hClosestChild;
            szPathDelim = 0;
        }
    }

    // If nothing more on the path, select this item,
    // or expand and continue
    if(szPathDelim == 0)
    {
        if(fExpandIt)        
            TreeView_Expand(hwTree, hChild, TVE_EXPAND);

        TreeView_SelectItem(hwTree, hChild);
    }
    else
    {
        if(fExpandIt)        
            TreeView_Expand(hwTree, hChild, TVE_EXPAND);        

        if(!SelectSubitemFromPartialPath(hwTree, hChild, szPathDelim+1))
            return false;
    }

    return true;
}

// Given a path, select the appropriate item in the tree.
// If path is invalid, it will expand as much as possible 
// (until invalid element appears)
// szPath is trashed.
void SelectItemFromFullPath(HWND hwTree, PTSTR szPath)
{
    if(!SelectSubitemFromPartialPath(hwTree, 0, szPath))
        TreeView_SelectItem(hwTree, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\appparse\appparseweb\progdialog.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <commctrl.h>
#include "resource.h"

HANDLE g_hThread = 0;
DWORD g_dwThreadID = 0;

char szProgressText[512];
INT_PTR CALLBACK ProgressDlgProc(HWND hwndDlg, UINT uiMsg, WPARAM wParam, 
                                 LPARAM lParam)
{     
	static HANDLE hEvent;
    switch(uiMsg)
    {
    case WM_INITDIALOG:
		hEvent = reinterpret_cast<HANDLE>(lParam);
        return TRUE;
 
    case WM_COMMAND:
		if(LOWORD(wParam)==IDC_CANCELBUTTON)
			SetEvent(hEvent);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DWORD WINAPI ThreadProc(PVOID hEvent)
{
    HWND hwDlg = CreateDialogParam(_Module.GetModuleInstance(), 
        MAKEINTRESOURCE(IDD_PROGRESS), 0, ProgressDlgProc,
		reinterpret_cast<LPARAM>(hEvent));

    ShowWindow(hwDlg, SW_SHOWNORMAL);

    // Add the animation control.
    HWND hwChild;
    RECT rcChild;    
    POINT pt;

    HWND hwAnim = Animate_Create(hwDlg, 50, 
        WS_CHILD | ACS_CENTER | ACS_TRANSPARENT, _Module.GetModuleInstance());

    hwChild = GetDlgItem(hwDlg, IDC_ANIMHOLDER);
    GetWindowRect(hwChild, &rcChild);    

    DestroyWindow(hwChild);
    pt.x = rcChild.left;
    pt.y = rcChild.top;
    ScreenToClient(hwDlg, &pt);
    SetWindowPos(hwAnim, 0, pt.x, pt.y, rcChild.right-rcChild.left,
        rcChild.bottom - rcChild.top, SWP_NOZORDER);

    Animate_Open(hwAnim, MAKEINTRESOURCE(IDR_PARSING));    

    Animate_Play(hwAnim, 0, -1, -1);

    hwChild = GetDlgItem(hwDlg, IDC_PROGRESSTEXT);
    ::SetWindowText(hwChild, szProgressText);

    ShowWindow(hwAnim, SW_SHOW);
    MSG msg;
    while(GetMessage(&msg, 0, 0, 0))
    {
        if(msg.message == WM_USER + 1)
            break;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return 0;
}

void InitProgressDialog(char* szText, HANDLE hEvent)
{
    strcpy(szProgressText, szText);
    g_hThread = CreateThread(0, 0, ThreadProc, reinterpret_cast<void*>(hEvent), 
		0, &g_dwThreadID);
}

void KillProgressDialog()
{
    if(g_hThread)
    {
        while(!PostThreadMessage(g_dwThreadID, WM_USER+1, 0, 0))
            Sleep(0);

        CloseHandle(g_hThread);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1all\defs.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

extern int linedirective;
extern int lineno;
extern char filename[];
extern char outfilename[];
extern char incfilename[];
extern FILE *fout, *finc;
extern char *startsym;
extern char *prefix;
typedef struct item_s {
    int isnonterm;
    int isexternal;
    char *tag;
    char *identifier;
    char *altidentifier;
    char **args;
    struct item_s **items;
    int empty;
    int checked;
} item_t;
extern item_t symbols[];
extern int nsymbols;
extern item_t *items[];
extern int nitems;

struct bounds_s {
	unsigned lower;   /* 0 for no lower bound */
	unsigned upper;   /* 0 for no upper bound */
};
struct rhs_s {
	enum { eCCode, eItem, eSequence, eNode, eBounded, eAlternative } type;
	union {
		struct {
			char *ccode;
			int line;
			int column;
			char *file;
		} ccode;
		struct {
			char *identifier;
			char *args;
		} item;
		struct {
			struct rhs_s *element;
			struct rhs_s *next;
		} sequence, alternative;
		struct {
			struct rhs_s *left;
			struct rhs_s *right;
		} node;
		struct {
			struct bounds_s bounds;
			struct rhs_s *items;
		} bounded;
	} u;
};
struct token_s {
	char *identifier;
	char *altidentifier;
};
struct nterm_s {
	char *identifier;
	char **tags;
};
struct lhs_s {
	char *identifier;
	char *args;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1all\all.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include "defs.h"
#include "parser.h"

int linedirective = 1;
int constargs = 0;
char *conststr = "";
char *ll = "ll";
char *LL = "LL";
int outline = 1;
char outfilename[256];
char incfilename[256];
FILE *fout, *finc;
char *startsym = NULL;
char *prefix = "";
item_t symbols[4096];
int nsymbols = 0;
item_t *items[32768];
int nitems = 0;
char *tags[256];
int ntags = 0;
item_t *check[4096];
int ncheck = 0;
int expected_lr = 0;
int found_lr = 0;
int optimizer = 0;
char *usetypes = NULL;
char *USETYPES = NULL;

/* list for checking for left-recursions */
typedef struct rhslst_s {
    struct rhslst_s *next;
    struct rhs_s *rhs;
} rhslst_t;

item_t *get_symbol(char *identifier);
char *convert(char *ccode);
int output_rhs2(char *identifier, struct rhs_s *rhs, int *number, int depth, int *count, int *nextcount);
void add_rules2(item_t **istk, int istkp, rhslst_t *c);
void check_lr(item_t *symbol);

#ifndef HAS_GETOPT
extern int getopt(int argc, char **argv, const char *opts);
extern char *optarg;
extern int optind;
#endif

void open_file(char *file);

/* print an error message */
void
error(LLPOS *pos, char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    llverror(stderr, pos, fmt, args);
    va_end(args);
}

/* error function required by parser generator */
void
llverror(FILE *f, LLPOS *pos, char *fmt, va_list args)
{
    if (pos && pos->line && pos->file)
    fprintf(f, "Error at line %d of \"%s\": ", pos->line,
        pos->file);
    vfprintf(f, fmt, args);
    putc('\n', f);
    exit(1);
}

/* write to c file, count lines for #line directive */
void
output(char *fmt, ...)
{
    char buf[32768];
    char *p;
    va_list args;

    va_start(args, fmt);
    vsprintf(buf, fmt, args);
    fputs(buf, fout);
#if 1
    fflush(fout);
#endif
    for (p = buf; (p = strchr(p, '\n')); ) {
        outline++;
    p++;
    }
    va_end(args);
}

/* emit #line directive for lines of generated file */
void
output_line()
{
    fprintf(fout, "#line %d \"%s\"\n", ++outline, outfilename);
}

/* write to h file */
void
incput(char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    vfprintf(finc, fmt, args);
#if 1
    fflush(fout);
#endif
    va_end(args);
}

/* emit a call for one item into c file */
void
output_call(int number, item_t *item, char *args)
{
    char *ident;
    char *pre;

    /* get identifier of item */
    if (item->altidentifier)
    ident = item->altidentifier;
    else
    ident = item->identifier;

    /* terminal symbol? then use llterm(), otherwise name of non-terminal */
    if (!item->isnonterm) {

    /* if identifier is a single character, then use these character as */
    /* token value, otherwise add prefix to get the name of the #define */
    if (*ident == '\'')
        pre = "";
    else
        pre = prefix;

    /* call llterm to check the next token; */
    /* if item has a tag, use an LLSTYPE argument to get the item's val */
    if (item->tag) {
        output("%sterm(%s%s, &%slval, &%sstate_%d, &%sstate_%d)",
        ll, pre, ident, ll, ll, number - 1, ll, number);
    } else {
        output("%sterm(%s%s, (%sSTYPE *)0, &%sstate_%d, &%sstate_%d)",
        ll, pre, ident, LL, ll, number - 1, ll, number);
    }
    } else {

    /* call non-terminal function for parsing the non-terminal; */
    /* if item has a tag, use an tagtyped argument to get the item's val; */
    /* if item has arguments, add this argument list */
    if (item->tag) {
        if (*args)
        output("%s_%s(&%satt_%d, &%sstate_%d, &%sstate_%d, %s)",
            ll, ident, ll, number, ll, number - 1, ll, number, args);
        else
        output("%s_%s(&%satt_%d, &%sstate_%d, &%sstate_%d)",
            ll, ident, ll, number, ll, number - 1, ll, number);
    } else {
        if (*args)
        output("%s_%s(&%sstate_%d, &%sstate_%d, %s)",
            ll, ident, ll, number - 1, ll, number, args);
        else
        output("%s_%s(&%sstate_%d, &%sstate_%d)",
            ll, ident, ll, number - 1, ll, number);
    }
    }
}

/* emit all actions needed for parsing a rhs */
void
output_rhs(char *identifier, struct rhs_s *rhs)
{
    int count[32], nextcount = 2;
    int i, number = 1;
    count[1] = 1;

    /* we need a state and some debugs when entering */
    output("%sSTATE %sstate_0;\n", LL, ll);
    output("%sDEBUG_ENTER(\"%s\");\n", LL, identifier);
    output("\n%sstate_0 = *%sin;\n", ll, ll);

    /* one define for the LLFAILED() macro */
    output("#undef failed\n#define failed failed1\n");

    /* output rhs parsing actions */
    i = output_rhs2(identifier, rhs, &number, 1, count, &nextcount);

    /* print needed closing braces */
    if (i) {
    for (; i > 0; i--)
        output("}");
    output("\n");
    }

    /* leave (successful) this parsing function */
    output("%sDEBUG_LEAVE(\"%s\", 1);\n", LL, identifier);
    output("return 1;\n");

    /* leave unsuccessful this parsing function */
    output("failed1: %sDEBUG_LEAVE(\"%s\", 0);\n", LL, identifier);
    output("return 0;\n");
}

/* emit actions needed for parsing a rhs */
int
output_rhs2(char *identifier, struct rhs_s *rhs, int *number, int depth, int *count, int *nextcount)
{
    int i, j, n;
    item_t *item;
    struct rhs_s *r;

    /* empty rule? then completed */
    if (!rhs) {
    output("*%sout = %sstate_%d;\n", ll, ll, *number - 1);
    return 0;
    }

    /* check type of rhs */
    switch (rhs->type) {
    case eCCode:

    /* some C code statements shall be inserted: */
    /* prefixed by #line directive if desired, dump the code, and */
    /* use another #line directive to reference the generated file again */
    /* return 1 brace which need to be closed */
    if (linedirective)
        output("#line %d \"%s\"\n", rhs->u.ccode.line, rhs->u.ccode.file);
    output("{%s\n", convert(rhs->u.ccode.ccode));
    if (linedirective)
        output_line();
    return 1;

    case eItem:

    /* one item shall be parsed: */
    /* get vars for a new state and for the item's value (if needed), */
    /* dump the call for parsing the item, branch to the corresponding */
    /* failed label if the parsing failed, copy the item's value if */
    /* there's any and increment the number of the items */
    /* return 1 brace which need to be closed */
    output("{%sSTATE %sstate_%d;", LL, ll, *number);
    item = get_symbol(rhs->u.item.identifier);
    if (item->tag)
        output("%s %satt_%d;", item->tag, ll, *number);
    output("\nif (!");
    output_call(*number, item, rhs->u.item.args);
    output(") goto failed%d;\n", count[depth]);
    if (!item->isnonterm && item->tag) {
        for (i = 0; i < ntags; i++)
        if (!strcmp(tags[i], item->tag))
            break;
        if (i >= ntags)
        output("%satt_%d = %slval;\n", ll, *number, ll);
        else
        output("%satt_%d = %slval._%s;\n", ll, *number, ll, item->tag);
    }
    (*number)++;
    return 1;

    case eSequence:

    /* a sequence of items shall be parsed: */
    /* output all items of this sequence and return the counted number of */
    /* braces to be closed */
    /* dump copy of last output state before last ccode or at end */
    i = j = 0;
    for (; rhs; rhs = rhs->u.sequence.next) {
        if (!j) {
        for (r = rhs; r; r = r->u.sequence.next) {
            if (r->u.sequence.element->type != eCCode)
            break;
        }
        if (!r) {
            output("*%sout = %sstate_%d;\n", ll, ll, *number - 1);
            j = 1;
        }
        }
        i += output_rhs2(identifier, rhs->u.sequence.element, number,
        depth, count, nextcount);
    }
    if (!j)
        output("*%sout = %sstate_%d;\n", ll, ll, *number - 1);
    return i;

    case eAlternative:

    /* a list of alternatives shall be parsed: */
    /* if there's only one alternative, parse this one alternative */
    /* otherwise we need to emit some backtracking code: */
    /* - a define for the LLFAILED macro */
    /* - a current position into the input stream, */
    /* - a current stack position for the backtracking, */
    /* - a stack check (and resize if required), */
    /* - a switch statement for the alternatives, */
    /* - a case entry for each alternative, */
    /* - a debug statement for each alternative, */
    /* - the actions of each alternative, */
    /* - closing braces for the actions */
    /* - a default case in the switch statement for failure of parsing */
    /*   by any alternative */
    /* - a failed label for start of backtracking */
    /* - code for backtracking (resetting the position into the input */
    /*   stream, resetting the stack position */
    /* - two braces later be closed */
    if (!rhs->u.alternative.next)
        return output_rhs2(identifier, rhs->u.alternative.element, number,
        depth, count, nextcount);
    count[depth + 1] = (*nextcount)++;
    output("#undef failed\n#define failed failed%d\n",
        count[depth + 1]);
    output("{unsigned %spos%d = %scpos, %sstp%d = %scstp;\n",
        ll, depth, ll, ll, depth, ll);
    output("%sCHECKSTK;\n", LL);
    output("for (;;) {\n");
    output("switch (%sstk[%scstp++]) {\n", ll, ll);
    n = *number;
    j = 1;
    for (; rhs; rhs = rhs->u.alternative.next) {
        output("case %d: case -%d:\n", j, j);
        output("%sDEBUG_ALTERNATIVE(\"%s\", %d);\n", LL, identifier, j);
        i = output_rhs2(identifier, rhs->u.alternative.element, number,
        depth + 1, count, nextcount);
        output("break;\n");
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
        *number = n;
        j++;
    }
    output("default:\n");
    output("%sstk[--%scstp] = 1;\n", ll, ll);
    output("goto failed%d;\n", count[depth]);
    output("failed%d:\n", count[depth + 1]);
    output("%sDEBUG_BACKTRACKING(\"%s\");\n", LL, identifier);
    output("if (%sstk[--%scstp] < 0) %sstk[%scstp] = 0; else %sstk[%scstp]++;\n", ll, ll, ll, ll, ll, ll);
    output("%scpos = %spos%d; %scstp = %sstp%d;\n", ll, ll, depth, ll, ll, depth);
    output("continue;\n");
    output("} break;\n");
    return 2;

#if 0
    case eBounded:

    /* this code does not work due to a design bug I wanted to parse */
    /* EBNF repetions; will fix it when I've time or need */
    count[depth + 1] = (*nextcount)++;
    output("#undef failed\n#define failed failed%d\n",
        count[depth + 1]);
    output("{unsigned %spos%d = %scpos, %sstp%d = %scstp;\n",
        ll, depth, ll, ll, depth, ll);
    output("int %sm, %sn, %ss, %sl = %d, %su = ",
        ll, ll, ll, ll, rhs->u.bounded.bounds.lower, ll);
    if (rhs->u.bounded.bounds.upper)
        output("%d;\n", rhs->u.bounded.bounds.upper);
    else
        output("INT_MAX - 1;\n");
    if (rhs->u.bounded.items->type == eNode)
        output("int %sf = 1;\n", ll);
    output("%sCHECKSTK;\n", LL);
    output("%ss = (%sstk[%scstp] > 0 ? 1 : -1);\n", ll, ll, ll);
    output("if (!(%sn = %sstk[%scstp++]) || %sn * %ss > %su - %sl + 1) {\n",
        ll, ll, ll, ll, ll, ll, ll);
    output("%sstk[--%scstp] = 1; %scpos = %spos%d; %scstp = %sstp%d; goto failed%d; }\n",
        ll, ll, ll, ll, depth, ll, ll, depth, count[depth]);
    output("for (%sm = %sn = %su + 1 - %sn * %ss; %sn; %sn--) {\n",
        ll, ll, ll, ll, ll, ll, ll);
    output("%sDEBUG_ITERATION(\"%s\", %sm - %sn + 1);\n",
        LL, identifier, ll, ll);
    n = *number;
    if (rhs->u.bounded.items->type == eNode) {
        output("if (!%sf) {\n", ll);
        i = output_rhs2(identifier, rhs->u.bounded.items->u.node.left,
        number, depth + 1, count, nextcount) + 1;
        output("%sf = 1;\n", ll);
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
        i = output_rhs2(identifier, rhs->u.bounded.items->u.node.right,
        number, depth + 1, count, nextcount);
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
        output("%sf = 0;\n", ll);
    } else {
        i = output_rhs2(identifier, rhs->u.bounded.items, number,
        depth + 1, count, nextcount);
        if (i) {
        for (; i > 0; i--)
            output("}");
        output("\n");
        }
    }
    *number = n;
    output("} failed%d:\n", count[depth + 1]);
    if (rhs->u.bounded.items->type == eNode) {
        output("if (%sf || %sm - %sn < %sl || (%sstk[%sstp%d] < 0 && %sn)) {\n",
        ll, ll, ll, ll, ll, ll, depth, ll);
    } else {
        output("if (%sm - %sn < %sl || (%sstk[%sstp%d] < 0 && %sn)) {\n",
        ll, ll, ll, ll, ll, depth, ll);
    }
    output("%sstk[%sstp%d] = 1; %scpos = %spos%d; %scstp = %sstp%d; goto failed%d; }\n",
        ll, ll, depth, ll, ll, depth, ll, ll, depth, count[depth]);
    output("%sstk[%sstp%d] = (%su - %sm + %sn + 1) * %ss;\n",
        ll, ll, depth, ll, ll, ll, ll);
    return 1;
#endif
    }
    abort();
    /*NOTREACHED*/
}

/* save the name of the start symbol */
void
set_start(char *startstr)
{
    startsym = startstr;
}

/* save the prefix to be used for the #defines of the terminals */
void
set_prefix(char *prefixstr)
{
    prefix = prefixstr;
}

/* save the prefix to be used for the generated functions, macros and types */
void
set_module(char *modulestr)
{
    char *p;

    ll = strdup(modulestr);
    for (p = ll; *p; p++)
    *p = (char)tolower(*p);
    LL = strdup(modulestr);
    for (p = LL; *p; p++)
    *p = (char)toupper(*p);
}

/* find the tag in the list of tag declarations or add it if it's new */
char *
find_tag(char *tag)
{
    int i;

    for (i = 0; i < ntags; i++)
    if (!strcmp(tags[i], tag))
        return tags[i];
    return tags[ntags++] = tag;
}

/* create an lhs symbol or an terminal symbol */
item_t *
create_symbol(int isnonterm, int isexternal, char *tag, char *identifier, char *altidentifier,
    char **args)
{
    symbols[nsymbols].isnonterm = isnonterm;
    symbols[nsymbols].isexternal = isexternal;
    symbols[nsymbols].tag = tag;
    symbols[nsymbols].identifier = identifier;
    symbols[nsymbols].altidentifier = altidentifier;
    symbols[nsymbols].args = args;
    symbols[nsymbols].items = NULL;
    symbols[nsymbols].empty = 0;
    return symbols + nsymbols++;
}

/* search a symbol */
item_t *
find_symbol(char *identifier)
{
    int i;

    for (i = 0; i < nsymbols; i++) {
    if (!strcmp(symbols[i].identifier, identifier))
        return symbols + i;
    }
    return NULL;
}

/* search a symbol or add it if it's new */
item_t *
get_symbol(char *identifier)
{
    item_t *item;
    char *ident;

    item = find_symbol(identifier);
    if (!item) {
    if (*identifier == '\"') {
        ident = strdup(identifier + 1);
        ident[strlen(ident) - 1] = 0;
        item = create_symbol(0, 0, NULL, identifier, ident, NULL);
    } else {
        item = create_symbol(*identifier != '\'', 0, NULL, identifier, NULL,
        NULL);
    }
    }
    return item;
}

/* start the definition of the rhs of a symbol */
void
start_rule(item_t *symbol)
{
    if (!symbol->isnonterm)
    error(NULL, "symbol %s is a terminal\n", symbol->identifier);
    if (symbol->items)
    error(NULL, "symbol %s twice defined\n", symbol->identifier);
    symbol->items = items + nitems;
}

/* add rhs items of one alternative to current definition */
void
add_items(item_t **i, int n)
{
    if (nitems + n + 1 > sizeof(items) / sizeof(*items))
    error(NULL, "out of item space\n");
    while (n--)
    items[nitems++] = *i++;
    items[nitems++] = (item_t *)1; /* end-of-alternative */
}

/* finish current definition */
void
end_rule(item_t *item)
{
    if (nitems >= sizeof(items) / sizeof(*items))
    error(NULL, "out of item space\n");
    items[nitems++] = NULL; /* end-of-definition */
}

/* save the rules for lr-recursion search */
void
add_rules(item_t *item, struct rhs_s *rhs)
{
    item_t *istk[64];
    rhslst_t l;

    start_rule(item);
    l.next = NULL;
    l.rhs = rhs;
    add_rules2(istk, 0, &l);
    end_rule(item);
}

/* save the rules for lr-recursion search */
void
add_rules2(item_t **istk, int istkp, rhslst_t *c)
{
    struct rhs_s *rhs;
    item_t *item;
    rhslst_t l, ll;

    if (!c) {
    add_items(istk, istkp);
    return;
    }
    rhs = c->rhs;
    c = c->next;
    if (!rhs) {
    add_rules2(istk, istkp, c);
    return;
    }
    switch (rhs->type) {
    case eCCode:
    add_rules2(istk, istkp, c);
    break;
    case eItem:
    item = get_symbol(rhs->u.item.identifier);
    istk[istkp++] = item;
    add_rules2(istk, istkp, c);
    break;
    case eSequence:
    if (rhs->u.sequence.next) {
        l.next = c;
        l.rhs = rhs->u.sequence.next;
        ll.next = &l;
        ll.rhs = rhs->u.sequence.element;
        add_rules2(istk, istkp, &ll);
    } else {
        l.next = c;
        l.rhs = rhs->u.sequence.element;
        add_rules2(istk, istkp, &l);
    }
    break;
    case eAlternative:
    l.next = c;
    l.rhs = rhs->u.alternative.element;
    add_rules2(istk, istkp, &l);
    if (rhs->u.alternative.next) {
        l.rhs = rhs->u.alternative.next;
        add_rules2(istk, istkp, &l);
    }
    break;
#if 0
    case eBounded:
    if (rhs->u.bounded.items->type == eNode) {
        if (!rhs->u.bounded.bounds.lower)
        add_rules2(istk, istkp, c);
        if (rhs->u.bounded.bounds.lower <= 1 &&
            (rhs->u.bounded.bounds.upper >= 1 ||
        !rhs->u.bounded.bounds.upper)) {
        l.next = c;
        l.rhs = rhs->u.bounded.items->u.node.right;
        add_rules2(istk, istkp, &l);
        }
        if (rhs->u.bounded.bounds.lower <= 2 &&
        (rhs->u.bounded.bounds.upper >= 2 ||
        !rhs->u.bounded.bounds.upper)) {
        l.next = c;
        l.rhs = rhs->u.bounded.items->u.node.right;
        ll.next = &l;
        ll.rhs = rhs->u.bounded.items->u.node.left;
        lll.next = &ll;
        lll.rhs = rhs->u.bounded.items->u.node.right;
        add_rules2(istk, istkp, &lll);
        }
    } else {
        if (!rhs->u.bounded.bounds.lower)
        add_rules2(istk, istkp, c);
        if (rhs->u.bounded.bounds.lower <= 1 &&
            (rhs->u.bounded.bounds.upper >= 1 ||
        !rhs->u.bounded.bounds.upper)) {
        l.next = c;
        l.rhs = rhs->u.bounded.items;
        add_rules2(istk, istkp, &l);
        }
    }
    break;
    case eNode:
    abort();
#endif
    }
}

/* convert some C code containing special vars ($1..$n, $$, $<1..$<n, $<<, */
/* $>1..$>n, $>>, @1..@n, @@) into real C code */
char *
convert(char *ccode)
{
    static char buffer[4096];
    char *p = buffer;

    while (*ccode) {
    if (*ccode == '$') {
        if (ccode[1] == '$') {
        sprintf(p, "(*%sret)", ll);
        p += strlen(p);
        ccode += 2;
        continue;
        } else if (ccode[1] == '<') {
            if (ccode[2] == '<') {
            sprintf(p, "(*%sin)", ll);
            p += strlen(p);
            ccode += 3;
            continue;
        } else if (isdigit(ccode[2])) {
            sprintf(p, "%sstate_%d",
            ll, strtol(ccode + 2, &ccode, 10) - 1);
            p += strlen(p);
            continue;
        }
        } else if (ccode[1] == '>') {
            if (ccode[2] == '>') {
            sprintf(p, "(*%sout)", ll);
            p += strlen(p);
            ccode += 3;
            continue;
        } else if (isdigit(ccode[2])) {
            sprintf(p, "%sstate_%d", ll, strtol(ccode + 2, &ccode, 10));
            p += strlen(p);
            continue;
        }
        } else if (isdigit(ccode[1])) {
        sprintf(p, "%satt_%d", ll, strtol(ccode + 1, &ccode, 10));
        p += strlen(p);
        continue;
        } else {
        ccode++;
        sprintf(p, "%sarg_", ll);
        p += strlen(p);
        }
    } else if (*ccode == '@') {
        if (ccode[1] == '@') {
        sprintf(p, "%sstate_0.pos", ll);
        p += strlen(p);
        ccode += 2;
        continue;
        } else if (isdigit(ccode[1])) {
        sprintf(p, "%sstate_%d.pos", ll, strtol(ccode + 1, &ccode, 10));
        p += strlen(p);
        continue;
        }
    }
    *p++ = *ccode++;
    }
    *p = 0;
    return strdup(buffer);
}

/* create start of include file */
void
create_inc()
{
    int i, termnr;

    if (usetypes) {
    incput("typedef %sSTYPE %sSTYPE;\n", USETYPES, LL);
    incput("typedef %sTERM %sTERM;\n", USETYPES, LL);
    } else {
    incput("typedef union %sSTYPE{\n", LL);
    for (i = 0; i < ntags; i++)
        incput("\t%s _%s;\n", tags[i], tags[i]);
    incput("} %sSTYPE;\n", LL);
    incput("typedef struct %sTERM {\n", LL);
    incput("\tint token;\n");
    incput("\t%sSTYPE lval;\n", LL);
    incput("\t%sPOS pos;\n", LL);
    incput("} %sTERM;\n", LL);
    }
    incput("void %sscanner(%sTERM **tokens, unsigned *ntokens);\n", ll, LL);
    incput("int %sparser(%sTERM *tokens, unsigned ntokens, %s%sSTATE *%sin, %sSTATE *llout);\n",
    ll, LL, conststr, LL, ll, LL);
    incput("void %sprinterror(FILE *f);\n", ll);
    incput("void %sverror(FILE *f, %sPOS *pos, char *fmt, va_list args);\n",
    ll, LL);
    incput("void %serror(FILE *f, %sPOS *pos, char *fmt, ...);\n", ll, LL);
    incput("int %sgettoken(int *token, %sSTYPE *lval, %sPOS *pos);\n",
    ll, LL, LL);
    incput("#if %sDEBUG > 0\n", LL);
    incput("void %sdebug_init();\n", ll);
    incput("#endif\n");
    if (!usetypes) {
    termnr = 257;
    for (i = 0; i < nsymbols; i++) {
        if (!symbols[i].isnonterm && *symbols[i].identifier != '\'')
        incput("#define %s%s %d\n", prefix,
            symbols[i].altidentifier ? symbols[i].altidentifier :
            symbols[i].identifier, termnr++);
    }
    }
}

/* create start of c file */
void
create_vardefs()
{
    output("#include <stdio.h>\n");
    output("#include <stdlib.h>\n");
    output("#include <stdarg.h>\n");
    output("#include <limits.h>\n");
    output("#include \"%s\"\n\n", incfilename);
    output("int %scpos;\n", ll);
    output("int *%sstk;\n", ll);
    output("unsigned %sstksize;\n", ll);
    output("unsigned %scstp = 1;\n", ll);
    output("%sTERM *%stokens;\n", LL, ll);
    output("int %sntokens;\n", ll);
    output("char %serrormsg[256];\n", ll);
    output("%sPOS %serrorpos;\n", LL, ll);
    output("int %sepos;\n", ll);
    output("%sSTYPE %slval;\n", LL, ll);
    output("\n");
    output("int %sterm(int token, %sSTYPE *lval, %s%sSTATE *%sin, %sSTATE *%sout);\n", ll, LL, conststr, LL, ll, LL, ll);
    output("void %sfailed(%sPOS *pos, char *fmt, ...);\n", ll, LL);
    output("void %sresizestk();\n", ll);
    output("#define %sCHECKSTK do{if (%scstp + 1 >= %sstksize) %sresizestk();}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll);
    output("#define %sFAILED(_err) do{%sfailed _err; goto failed;}while(/*CONSTCOND*/0)\n", LL, ll);
    output("#define %sCUTOFF do{unsigned i; for (i = %sstp; i < %scstp; i++) if (%sstk[i] > 0) %sstk[i] = -%sstk[i];}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll, ll, ll);
    output("#define %sCUTTHIS do{if (%sstk[%sstp] > 0) %sstk[%sstp] = -%sstk[%sstp];}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll, ll, ll, ll);
    output("#define %sCUTALL do{unsigned i; for (i = 0; i < %scstp; i++) if (%sstk[i] > 0) %sstk[i] = -%sstk[i];}while(/*CONSTCOND*/0)\n", LL, ll, ll, ll, ll);
    output("\n");
    output("#if %sDEBUG > 0\n", LL);
    output("int %sdebug;\n", ll);
    output("int last_linenr;\n");
    output("char *last_file = \"\";\n");
    output("#define %sDEBUG_ENTER(_ident) %sdebug_enter(_ident)\n", LL, ll);
    output("#define %sDEBUG_LEAVE(_ident,_succ) %sdebug_leave(_ident,_succ)\n", LL, ll);
    output("#define %sDEBUG_ALTERNATIVE(_ident,_alt) %sdebug_alternative(_ident,_alt)\n", LL, ll);
    output("#define %sDEBUG_ITERATION(_ident,_num) %sdebug_iteration(_ident,_num)\n", LL, ll);
    output("#define %sDEBUG_TOKEN(_exp,_pos) %sdebug_token(_exp,_pos)\n", LL, ll);
    output("#define %sDEBUG_ANYTOKEN(_pos) %sdebug_anytoken(_pos)\n", LL, ll);
    output("#define %sDEBUG_BACKTRACKING(_ident) %sdebug_backtracking(_ident)\n", LL, ll);
    output("void %sdebug_init();\n", ll);
    output("void %sdebug_enter(char *ident);\n", ll);
    output("void %sdebug_leave(char *ident, int succ);\n", ll);
    output("void %sdebug_alternative(char *ident, int alt);\n", ll);
    output("void %sdebug_token(int expected, unsigned pos);\n", ll);
    output("void %sdebug_anytoken(unsigned pos);\n", ll);
    output("void %sdebug_backtracking(char *ident);\n", ll);
    output("void %sprinttoken(%sTERM *token, char *identifier, FILE *f);\n", ll, LL);
    output("#else\n");
    output("#define %sDEBUG_ENTER(_ident)\n", LL);
    output("#define %sDEBUG_LEAVE(_ident,_succ)\n", LL);
    output("#define %sDEBUG_ALTERNATIVE(_ident,_alt)\n", LL);
    output("#define %sDEBUG_ITERATION(_ident,_num)\n", LL);
    output("#define %sDEBUG_TOKEN(_exp,_pos)\n", LL);
    output("#define %sDEBUG_ANYTOKEN(_pos)\n", LL);
    output("#define %sDEBUG_BACKTRACKING(_ident)\n", LL);
    output("#endif\n");
    output("\n");
}

/* create end of c file */
void
create_trailer()
{
    int i, j;
    char *p, *q;
    char buffer[256];

    if (startsym) {
    output("int\n");
    output("%sparser(%sTERM *tokens, unsigned ntokens, %s%sSTATE *%sin, %sSTATE *%sout)\n", ll, LL, conststr, LL, ll, LL, ll);
    output("{\n");
    output("unsigned i;\n");
    output("%sDEBUG_ENTER(\"%sparser\");\n", LL, ll);
    output("%stokens = tokens; %sntokens = ntokens;\n", ll, ll);
    output("for (i = 0; i < %sstksize; i++) %sstk[i] = 1;\n", ll, ll);
    output("%scstp = 1; %scpos = 0; %sepos = 0; *%serrormsg = 0;\n",
        ll, ll, ll, ll);
    output("#if %sDEBUG > 0\n", LL);
    output("last_linenr = 0; last_file = \"\";\n");
    output("#endif\n");
    output("{unsigned %spos1 = %scpos, %sstp1 = %scstp;\n", ll, ll, ll, ll);
    output("%sCHECKSTK;\n", LL);
    output("for (;;) {\n");
    output("switch (%sstk[%scstp++]) {\n", ll, ll);
    output("case 1: case -1:\n");
    output("if (!%s_%s(%sin, %sout)) goto failed2;\n",
        ll, startsym, ll, ll);
    output("if (%scpos != %sntokens) goto failed2;\n", ll, ll);
    output("break;\n");
    output("default:\n");
    output("%sstk[--%scstp] = 1;\n", ll, ll);
    output("goto failed1;\n");
    output("failed2:\n");
    output("%sDEBUG_BACKTRACKING(\"%sparser\");\n", LL, ll);
    output("if (%sstk[--%scstp] < 0) %sstk[%scstp] = 0; else %sstk[%scstp]++;\n", ll, ll, ll, ll, ll, ll);
    output("%scpos = %spos1; %scstp = %sstp1;\n", ll, ll, ll, ll);
    output("continue;\n");
    output("} break;\n");
    output("}}\n");
    output("%sDEBUG_LEAVE(\"%sparser\", 1);\n", LL, ll);
    output("return 1;\n");
    output("failed1:\n");
    output("%sDEBUG_LEAVE(\"%sparser\", 0);\n", LL, ll);
    output("return 0;\n");
    output("}\n");
    output("\n");
    }
    output("int\n");
    output("%sterm(int token, %sSTYPE *lval, %s%sSTATE *%sin, %sSTATE *%sout)\n", ll, LL, conststr, LL, ll, LL, ll);
    output("{\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tif (%sdebug > 0 && (%stokens[%scpos].pos.line > last_linenr || strcmp(%stokens[%scpos].pos.file, last_file))) {\n", ll, ll, ll, ll, ll);
    output("\tfprintf(stderr, \"File \\\"%%s\\\", Line %%5d                    \\r\",\n");
    output("\t\t%stokens[%scpos].pos.file, %stokens[%scpos].pos.line);\n", ll, ll, ll, ll);
    output("\tlast_linenr = %stokens[%scpos].pos.line / 10 * 10 + 9;\n", ll, ll);
    output("\tlast_file = %stokens[%scpos].pos.file;\n", ll, ll);
    output("\t}\n");
    output("#endif\n");
    output("\tif (%sstk[%scstp] != 1 && %sstk[%scstp] != -1) {\n", ll, ll, ll, ll);
    output("\t\t%sDEBUG_BACKTRACKING(\"%sterm\");\n", LL, ll);
    output("\t\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\t\treturn 0;\n");
    output("\t}\n");
    output("\t%sDEBUG_TOKEN(token, %scpos);\n", LL, ll);
    output("\tif (%scpos < %sntokens && %stokens[%scpos].token == token) {\n", ll, ll, ll, ll);
    output("\t\tif (lval)\n");
    output("\t\t\t*lval = %stokens[%scpos].lval;\n", ll, ll);
    output("\t\t*%sout = *%sin;\n", ll, ll);
    output("\t\t%sout->pos = %stokens[%scpos].pos;\n", ll, ll, ll);
    output("\t\t%scpos++;\n", ll);
    output("\t\t%sCHECKSTK;\n", LL);
    output("\t\t%scstp++;\n", ll);
    output("\t\treturn 1;\n");
    output("\t}\n");
    output("\t%sfailed(&%stokens[%scpos].pos, NULL);\n", ll, ll, ll);
    output("\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\treturn 0;\n");
    output("}\n");
    output("\n");
    output("int\n");
    output("%sanyterm(%sSTYPE *lval, %s%sSTATE *%sin, %sSTATE *%sout)\n", ll, LL, conststr, LL, ll, LL, ll);
    output("{\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tif (%sdebug > 0 && (%stokens[%scpos].pos.line > last_linenr || strcmp(%stokens[%scpos].pos.file, last_file))) {\n", ll, ll, ll, ll, ll);
    output("\tfprintf(stderr, \"File \\\"%%s\\\", Line %%5d                    \\r\",\n");
    output("\t\t%stokens[%scpos].pos.file, %stokens[%scpos].pos.line);\n", ll, ll, ll, ll);
    output("\tlast_linenr = %stokens[%scpos].pos.line / 10 * 10 + 9;\n", ll, ll);
    output("\tlast_file = %stokens[%scpos].pos.file;\n", ll, ll);
    output("\t}\n");
    output("#endif\n");
    output("\tif (%sstk[%scstp] != 1 && %sstk[%scstp] != -1) {\n", ll, ll, ll, ll);
    output("\t\t%sDEBUG_BACKTRACKING(\"%sanyterm\");\n", LL, ll);
    output("\t\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\t\treturn 0;\n");
    output("\t}\n");
    output("\t%sDEBUG_ANYTOKEN(%scpos);\n", LL, ll);
    output("\tif (%scpos < %sntokens) {\n", ll, ll);
    output("\t\tif (lval)\n");
    output("\t\t\t*lval = %stokens[%scpos].lval;\n", ll, ll);
    output("\t\t*%sout = *%sin;\n", ll, ll);
    output("\t\t%sout->pos = %stokens[%scpos].pos;\n", ll, ll, ll);
    output("\t\t%scpos++;\n", ll);
    output("\t\t%sCHECKSTK;\n", LL);
    output("\t\t%scstp++;\n", ll);
    output("\t\treturn 1;\n");
    output("\t}\n");
    output("\t%sfailed(&%stokens[%scpos].pos, NULL);\n", ll, ll, ll);
    output("\t%sstk[%scstp] = 1;\n", ll, ll);
    output("\treturn 0;\n");
    output("}\n");
    output("void\n");
    output("%sscanner(%sTERM **tokens, unsigned *ntokens)\n", ll, LL);
    output("{\n");
    output("\tunsigned i = 0;\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tint line = -1;\n");
    output("#endif\n");
    output("\n");
    output("\t*ntokens = 1024;\n");
    output("\t*tokens = (%sTERM *)malloc(*ntokens * sizeof(%sTERM));\n", LL, LL);
    output("\twhile (%sgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {\n", ll);
    output("#if %sDEBUG > 0\n", LL);
    output("\t\tif (%sdebug > 0 && (*tokens)[i].pos.line > line) {\n", ll);
    output("\t\t\tline = (*tokens)[i].pos.line / 10 * 10 + 9;\n");
    output("\t\t\tfprintf(stderr, \"File \\\"%%s\\\", Line %%5d                    \\r\",\n");
    output("\t\t\t\t(*tokens)[i].pos.file, (*tokens)[i].pos.line);\n");
    output("\t\t}\n");
    output("#endif\n");
    output("\t\tif (++i >= *ntokens) {\n");
    output("\t\t\t*ntokens *= 2;\n");
    output("\t\t\t*tokens = (%sTERM *)realloc(*tokens, *ntokens * sizeof(%sTERM));\n", LL, LL);
    output("\t\t}\n");
    output("\t}\n");
    output("\t(*tokens)[i].token = 0;\n");
    output("\t*ntokens = i;\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\t%sdebug_init();\n", ll);
    output("#endif\n");
    output("\t%sresizestk();\n", ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%sfailed(%sPOS *pos, char *fmt, ...)\n", ll, LL);
    output("{\n");
    output("\tva_list args;\n");
    output("\n");
    output("\tva_start(args, fmt);\n");
    output("\tif (%scpos > %sepos || %scpos == %sepos && !*%serrormsg) {\n", ll, ll, ll, ll, ll);
    output("\t\t%sepos = %scpos;\n", ll, ll);
    output("\t\tif (fmt)\n");
    output("\t\t\tvsprintf(%serrormsg, fmt, args);\n", ll);
    output("\t\telse\n");
    output("\t\t\t*%serrormsg = 0;\n", ll);
    output("\t\t%serrorpos = *pos;\n", ll);
    output("\t}\n");
    output("\tva_end(args);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sprinterror(FILE *f)\n", ll);
    output("{\n");
    output("#if %sDEBUG > 0\n", LL);
    output("\tfputs(\"                                \\r\", stderr);\n");
    output("#endif\n");
    output("\tif (*%serrormsg)\n", ll);
    output("\t\t%serror(f, &%serrorpos, %serrormsg);\n", ll, ll, ll);
    output("\telse\n");
    output("\t\t%serror(f, &%serrorpos, \"Syntax error\");\n", ll, ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%serror(FILE *f, %sPOS *pos, char *fmt, ...)\n", ll, LL);
    output("{\n");
    output("\tva_list args;\n");
    output("\tva_start(args, fmt);\n");
    output("\t%sverror(f, pos, fmt, args);\n", ll);
    output("\tva_end(args);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sresizestk()\n", ll);
    output("{\n");
    output("\tunsigned i;\n");
    output("\n");
    output("\tif (%scstp + 1 >= %sstksize) {\n", ll, ll);
    output("\t\ti = %sstksize;\n", ll);
    output("\t\tif (!%sstksize)\n", ll);
    output("\t\t\t%sstk = (int *)malloc((%sstksize = 4096) * sizeof(int));\n", ll, ll);
    output("\t\telse\n");
    output("\t\t\t%sstk = (int *)realloc(%sstk, (%sstksize *= 2) * sizeof(int));\n", ll, ll, ll);
    output("\t\tfor (; i < %sstksize; i++)\n", ll);
    output("\t\t\t%sstk[i] = 1;\n", ll);
    output("\t}\n");
    output("}\n");
    output("\n");
    output("#if %sDEBUG > 0\n", LL);
    output("int %sdepth;\n", ll);
    output("char *%stokentab[] = {\n", ll);
    for (i = 0; i < 257; i++) {
    if (i == 0)
        output("\"EOF\"");
    else if (i == '\\' || i == '\"')
        output(",\"'\\%c'\"", i);
    else if (i >= 32 && i < 127)
        output(",\"'%c'\"", i);
    else if (i < 257)
        output(",\"#%d\"", i);
    if ((i % 8) == 7)
        output("\n");
    }
    for (j = 0; j < nsymbols; j++) {
    if (!symbols[j].isnonterm && *symbols[j].identifier != '\'') {
        for (p = symbols[j].identifier, q = buffer; *p; p++) {
        if (*p == '\"' || *p == '\\')
            *q++ = '\\';
        *q++ = *p;
        }
        *q = 0;
        output(",\"%s\"", buffer);
        if ((i++ % 8) == 7)
        output("\n");
    }
    }
    if (i % 8)
    output("\n");
    output("};\n");
    output("\n");
    output("void\n");
    output("%sdebug_init()\n", ll);
    output("{\n");
    output("\tchar *p;\n");
    output("\tp = getenv(\"%sDEBUG\");\n", LL);
    output("\tif (p)\n");
    output("\t\t%sdebug = atoi(p);\n", ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_enter(char *ident)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\"/--- trying rule %%s\\n\", ident);\n");
    output("\t%sdepth++;\n", ll);
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_leave(char *ident, int succ)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\t%sdepth--;\n", ll);
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tif (succ)\n");
    output("\t\tprintf(\"\\\\--- succeeded to apply rule %%s\\n\", ident);\n");
    output("\telse\n");
    output("\t\tprintf(\"\\\\--- failed to apply rule %%s\\n\", ident);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_alternative(char *ident, int alt)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth - 1; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\">--- trying alternative %%d for rule %%s\\n\", alt, ident);\n");
    output("}\n");
    output("\n");
    output("%sdebug_iteration(char *ident, int num)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth - 1; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\">--- trying iteration %%d for rule %%s\\n\", num, ident);\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_token(int expected, unsigned pos)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tif (pos < %sntokens && expected == %stokens[pos].token)\n", ll, ll);
    output("\t\tprintf(\"   found token \");\n");
    output("\telse\n");
    output("\t\tprintf(\"   expected token %%s, found token \", %stokentab[expected]);\n", ll);
    output("\tif (pos >= %sntokens)\n", ll);
    output("\t\tprintf(\"<EOF>\");\n");
    output("\telse\n");
    output("\t\t%sprinttoken(%stokens + pos, %stokentab[%stokens[pos].token], stdout);\n", ll, ll, ll, ll);
    output("\tputchar('\\n');\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_anytoken(unsigned pos)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\"   found token \");\n");
    output("\tif (pos >= %sntokens)\n", ll);
    output("\t\tprintf(\"<EOF>\");\n");
    output("\telse\n");
    output("\t\t%sprinttoken(%stokens + pos, %stokentab[%stokens[pos].token], stdout);\n", ll, ll, ll, ll);
    output("\tputchar('\\n');\n");
    output("}\n");
    output("\n");
    output("void\n");
    output("%sdebug_backtracking(char *ident)\n", ll);
    output("{\n");
    output("\tint i;\n");
    output("\n");
    output("\tif (%sdebug < 2)\n", ll);
    output("\t\treturn;\n");
    output("\tfor (i = 0; i < %sdepth; i++)\n", ll);
    output("\t\tfputs(\"| \", stdout);\n");
    output("\tprintf(\"   backtracking rule %%s\\n\", ident);\n");
    output("}\n");
    output("\n");
    output("#endif\n");
}

/* search for left recursion and complain about if they are unexpected */
void
search_leftrecursion()
{
    int i;
    item_t **item;
    int done;
    int empty;

    /* check for missing rules */
    for (i = 0; i < nsymbols; i++) {
    if (symbols[i].isnonterm && !symbols[i].isexternal && !symbols[i].items)
        error(NULL, "missing rule for symbol %s\n", symbols[i].identifier);
    }

    /* mark rules that may be empty */
    do {
    done = 1;
    for (i = 0; i < nsymbols; i++) {
        if (symbols[i].empty || !symbols[i].isnonterm ||
        symbols[i].isexternal)
        continue;
        item = symbols[i].items;
        do {
        empty = 1;
        for (; *item != (item_t *)1; item++) {
            if (!(*item)->empty)
            empty = 0;
        }
        item++;
        if (empty) {
            symbols[i].empty = 1;
            done = 0;
        }
        } while (*item);
    }
    } while (!done);

    /* check every rule for left recursion */
    for (i = 0; i < nsymbols; i++)
    symbols[i].checked = 0;
    for (i = 0; i < nsymbols; i++) {
    if (!symbols[i].checked)
        check_lr(symbols + i);
    }
    if (found_lr > expected_lr) {
    fprintf(stderr, "Found %d left recursions, exiting\n", found_lr);
    exit(1);
    }
}

/* check one rule for left recursion */
void
check_lr(item_t *symbol)
{
    int i;
    item_t **item;
    int try_flag;

    if (!symbol->isnonterm || symbol->isexternal)
    return;
    for (i = 0; i < ncheck; i++) {
    if (check[i] == symbol) {
        if (++found_lr > expected_lr) {
        fprintf(stderr, "Error: found left recursion: ");
        for (; i < ncheck; i++)
            fprintf(stderr, "%s->", check[i]->identifier);
        fprintf(stderr, "%s\n", symbol->identifier);
        }
        return;
    }
    }
    check[ncheck++] = symbol;
    item = symbol->items;
    do {
    try_flag = 1;
    for (; *item != (item_t *)1; item++) {
        if (try_flag)
        check_lr(*item);
        try_flag = try_flag && (*item)->empty;
    }
    item++;
    } while (*item);
    ncheck--;
}

/* main program */
int
__cdecl main(int argc, char **argv)
{
    extern int optind;
    int c;
    LLSTATE in, out;
    LLTERM *tokens;
    unsigned ntokens;
    char *p;

    /* parse option args */
    while ((c = getopt(argc, argv, "i:Olt:c")) != EOF) {
        switch (c) {
    case 'i':
        expected_lr = atoi(optarg);
        break;
    case 'l':
        linedirective = 0;
        break;
    case 'O':
        optimizer = 1;
        break;
    case 't':
        usetypes = strdup(optarg);
        for (p = usetypes; *p; p++)
        *p = (char)tolower(*p);
        USETYPES = strdup(optarg);
        for (p = USETYPES; *p; p++)
        *p = (char)toupper(*p);
        break;
    case 'c':
        constargs = 1;
        conststr = "const ";
        break;
    default:
    usage:
        fprintf(stderr, "Usage: %s [-i #ignore_lr] [-l] [-c] [-t from_prefix] filename.ll\n", argv[0]);
        exit(1);
    }
    }
    if (argc != optind + 1)
        goto usage;

    /* open input file and output files */
    open_file(argv[optind]);
    strcpy(outfilename, argv[optind]);
    if (strlen(outfilename) > 3 &&
    !strcmp(outfilename + strlen(outfilename) - 3, ".ll"))
    outfilename[strlen(outfilename) - 3] = 0;
    strcat(outfilename, ".c");
    fout = fopen(outfilename, "w");
    if (!fout) {
    perror(outfilename);
    exit(1);
    }
    fprintf(fout, "/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */\n\n");
    strcpy(incfilename, argv[optind]);
    if (strlen(incfilename) > 3 &&
    !strcmp(incfilename + strlen(incfilename) - 3, ".ll"))
    incfilename[strlen(incfilename) - 3] = 0;
    strcat(incfilename, ".h");
    finc = fopen(incfilename, "w");
    if (!finc) {
    perror(incfilename);
    exit(1);
    }
    fprintf(finc, "/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */\n\n");

    /* scan and parse the parser description */
    llscanner(&tokens, &ntokens);
    if (!llparser(tokens, ntokens, &in, &out))
    llprinterror(stderr);

    /* check for left recursions */
    search_leftrecursion();

    /* optimize */
    if (optimizer)
    /*create_firstsets()*/ ;

    /* create end of c file and header file */
    create_trailer();
    create_inc();

    /* finished! */
    fclose(fout);
    fclose(finc);
    return 0;
}

/* why is this function not in MS libc? */
#ifndef HAS_GETOPT
char *optarg;
int optind = 1;
static int optpos = 1;

int getopt(int argc, char **argv, const char *options) {
    char *p, *q;

    optarg = NULL;

    /* find start of next option */
    do {
        if (optind >= argc)
        return EOF;
        if (*argv[optind] != '-' && *argv[optind] != '/')
            return EOF;
        p = argv[optind] + optpos++;
    if (!*p) {
        optind++;
        optpos = 1;
    }
    } while (!*p);

    /* find option in option string */
    q = strchr(options, *p);
    if (!q)
    return '?';

    /* set optarg for parameterized option and adjust optind and optpos for next call */
    if (q[1] == ':') {
    if (p[1]) {
        optarg = p + 1;
        optind++;
        optpos = 1;
    } else if (++optind < argc) {
        optarg = argv[optind];
        optind++;
        optpos = 1;
    } else {
        return '?';
    }
    }

    /* return found option */
    return *p;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1all\parser.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

typedef char *string;
typedef char **strings;
typedef int integer;
typedef char *ccode;
typedef struct bounds_s bounds;
typedef struct rhs_s *rhs;
typedef struct token_s token;
typedef struct nterm_s nterm;
typedef struct lhs_s lhs;
typedef struct LLPOS {
	int line;
	int column;
	char *file;
} LLPOS;
typedef struct LLSTATE {
	LLPOS pos;
} LLSTATE;
int ll_main(LLSTATE *llin, LLSTATE *llout);
int ll_declsect(LLSTATE *llin, LLSTATE *llout);
int ll_decl(LLSTATE *llin, LLSTATE *llout);
int ll_tokens(LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_tokens2(LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_token(token *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_nterms(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext);
int ll_nterms2(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext);
int ll_nterm(nterm *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag);
int ll_tags(strings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_tag(string *llret, LLSTATE *llin, LLSTATE *llout);
int ll_union(LLSTATE *llin, LLSTATE *llout);
int ll_state(LLSTATE *llin, LLSTATE *llout);
int ll_state1(LLSTATE *llin, LLSTATE *llout);
int ll_rulesect(LLSTATE *llin, LLSTATE *llout);
int ll_rule(LLSTATE *llin, LLSTATE *llout);
int ll_lhs(lhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_rhss(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_rhss2(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_items(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_item(rhs *llret, LLSTATE *llin, LLSTATE *llout);
int ll_extension(bounds *llret, LLSTATE *llin, LLSTATE *llout);
int ll_lhsargs(string *llret, LLSTATE *llin, LLSTATE *llout, string llarg_ide);
int ll_lhsarglist(string *llret, LLSTATE *llin, LLSTATE *llout, strings llarg_tags, string llarg_ide);
int ll_args(string *llret, LLSTATE *llin, LLSTATE *llout);
int ll_arglist(string *llret, LLSTATE *llin, LLSTATE *llout);
int ll_csect(LLSTATE *llin, LLSTATE *llout);
typedef union LLSTYPE{
	string _string;
	ccode _ccode;
	token _token;
	integer _integer;
	nterm _nterm;
	strings _strings;
	lhs _lhs;
	rhs _rhs;
	bounds _bounds;
} LLSTYPE;
typedef struct LLTERM {
	int token;
	LLSTYPE lval;
	LLPOS pos;
} LLTERM;
void llscanner(LLTERM **tokens, unsigned *ntokens);
int llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout);
void llprinterror(FILE *f);
void llverror(FILE *f, LLPOS *pos, char *fmt, va_list args);
void llerror(FILE *f, LLPOS *pos, char *fmt, ...);
int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos);
#if LLDEBUG > 0
void lldebug_init();
#endif
#define IDENTIFIER 257
#define ARG 258
#define CCODE 259
#define TAGDEF 260
#define PERCENT_PERCENT 261
#define PERCENT_TOKEN 262
#define PERCENT_TYPE 263
#define PERCENT_EXTERNAL 264
#define PERCENT_UNION 265
#define PERCENT_STATE 266
#define PERCENT_START 267
#define PERCENT_PREFIX 268
#define PERCENT_MODULE 269
#define PERCENT_LBRACE 270
#define PERCENT_RBRACE 271
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1all\parser.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#line 4 "parser.ll"
#include <stdio.h>
#include <string.h>
#include "defs.h"

#define MAXTAGS 16

extern char *find_tag(char *);
extern item_t *find_symbol(char *);
extern item_t *get_symbol(char *);
extern char *convert(char *);
extern item_t *create_symbol(int isnonterm, int isexternal, char *tag, char *identifier, char *altidentifier, char **args);
extern char *conststr;
extern char *ll;
extern char *LL;
extern char *usetypes;
extern char *USETYPES;

void output(char *fmt, ...);
void output_line();
void output_rhs(char *identifier, struct rhs_s *rhs);
void incput(char *fmt, ...);
void create_vardefs();
void set_start(char *startstr);
void set_prefix(char *prefixstr);
void set_module(char *modulestr);
void add_rules(item_t *item, struct rhs_s *rhs);

#line 30 "parser.c"


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "parser.h"

int llcpos;
int *llstk;
unsigned llstksize;
unsigned llcstp = 1;
LLTERM *lltokens;
int llntokens;
char llerrormsg[256];
LLPOS llerrorpos;
int llepos;
LLSTYPE lllval;

int llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout);
void llfailed(LLPOS *pos, char *fmt, ...);
void llresizestk();
#define LLCHECKSTK do{if (llcstp + 1 >= llstksize) llresizestk();}while(/*CONSTCOND*/0)
#define LLFAILED(_err) do{llfailed _err; goto failed;}while(/*CONSTCOND*/0)
#define LLCUTOFF do{unsigned i; for (i = llstp; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)
#define LLCUTTHIS do{if (llstk[llstp] > 0) llstk[llstp] = -llstk[llstp];}while(/*CONSTCOND*/0)
#define LLCUTALL do{unsigned i; for (i = 0; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)

#if LLDEBUG > 0
int lldebug;
int last_linenr;
char *last_file = "";
#define LLDEBUG_ENTER(_ident) lldebug_enter(_ident)
#define LLDEBUG_LEAVE(_ident,_succ) lldebug_leave(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt) lldebug_alternative(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num) lldebug_iteration(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos) lldebug_token(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos) lldebug_anytoken(_pos)
#define LLDEBUG_BACKTRACKING(_ident) lldebug_backtracking(_ident)
void lldebug_init();
void lldebug_enter(char *ident);
void lldebug_leave(char *ident, int succ);
void lldebug_alternative(char *ident, int alt);
void lldebug_token(int expected, unsigned pos);
void lldebug_anytoken(unsigned pos);
void lldebug_backtracking(char *ident);
void llprinttoken(LLTERM *token, char *identifier, FILE *f);
#else
#define LLDEBUG_ENTER(_ident)
#define LLDEBUG_LEAVE(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos)
#define LLDEBUG_BACKTRACKING(_ident)
#endif

int ll_main(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("main");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_declsect(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(PERCENT_PERCENT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!ll_rulesect(&llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(PERCENT_PERCENT, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;
if (!ll_csect(&llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
}}}}}
LLDEBUG_LEAVE("main", 1);
return 1;
failed1: LLDEBUG_LEAVE("main", 0);
return 0;
}

int ll_declsect(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("declsect");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("declsect", 1);
{LLSTATE llstate_1;
if (!ll_decl(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_declsect(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("declsect", 2);
*llout = llstate_0;
#line 94 "parser.ll"
{create_vardefs(); 
#line 144 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("declsect");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("declsect", 1);
return 1;
failed1: LLDEBUG_LEAVE("declsect", 0);
return 0;
}

int ll_decl(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("decl");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("decl", 1);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TOKEN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_tokens(&llstate_1, &llstate_2, NULL)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("decl", 2);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TOKEN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_tag(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_tokens(&llstate_2, &llstate_3, llatt_2)) goto failed2;
*llout = llstate_3;
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("decl", 3);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_nterms(&llstate_1, &llstate_2, NULL, 0)) goto failed2;
*llout = llstate_2;
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("decl", 4);
{LLSTATE llstate_1;
if (!llterm(PERCENT_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_tag(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_nterms(&llstate_2, &llstate_3, llatt_2, 0)) goto failed2;
*llout = llstate_3;
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("decl", 5);
{LLSTATE llstate_1;
if (!llterm(PERCENT_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_nterms(&llstate_1, &llstate_2, NULL, 1)) goto failed2;
*llout = llstate_2;
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("decl", 6);
{LLSTATE llstate_1;
if (!llterm(PERCENT_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_tag(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_nterms(&llstate_2, &llstate_3, llatt_2, 1)) goto failed2;
*llout = llstate_3;
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("decl", 7);
{LLSTATE llstate_1;
if (!llterm(PERCENT_UNION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_union(&llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
#line 104 "parser.ll"
{output("\n"); 
#line 251 "parser.c"
break;
}}}}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("decl", 8);
{LLSTATE llstate_1;
if (!llterm(PERCENT_STATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!ll_state(&llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
#line 106 "parser.ll"
{output("\n"); 
#line 267 "parser.c"
break;
}}}}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("decl", 9);
{LLSTATE llstate_1;
if (!llterm(PERCENT_PREFIX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
*llout = llstate_2;
#line 108 "parser.ll"
{set_prefix(llatt_2); 
#line 280 "parser.c"
break;
}}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("decl", 10);
{LLSTATE llstate_1;
if (!llterm(PERCENT_MODULE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
*llout = llstate_2;
#line 110 "parser.ll"
{set_module(llatt_2); 
#line 293 "parser.c"
break;
}}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("decl", 11);
{LLSTATE llstate_1;
if (!llterm(PERCENT_LBRACE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;ccode llatt_2;
if (!llterm(CCODE, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._ccode;
{LLSTATE llstate_3;
if (!llterm(PERCENT_RBRACE, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 112 "parser.ll"
{if (linedirective)
			output("#line %d \"%s\"\n", llstate_2.pos.line, llstate_2.pos.file);
		    output("%s", llatt_2);
		    if (linedirective)
			output_line();
		
#line 313 "parser.c"
break;
}}}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("decl", 12);
{LLSTATE llstate_1;
if (!llterm(PERCENT_START, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
*llout = llstate_2;
#line 119 "parser.ll"
{set_start(llatt_2); 
#line 326 "parser.c"
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("decl");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("decl", 1);
return 1;
failed1: LLDEBUG_LEAVE("decl", 0);
return 0;
}

int ll_tokens(LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tokens");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;token llatt_1;
if (!ll_token(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed1;
{LLSTATE llstate_2;
if (!ll_tokens2(&llstate_1, &llstate_2, llarg_tag)) goto failed1;
*llout = llstate_2;
#line 123 "parser.ll"
{create_symbol(0, 0, llarg_tag, llatt_1.identifier, llatt_1.altidentifier,
			NULL);
		
#line 363 "parser.c"
}}}
LLDEBUG_LEAVE("tokens", 1);
return 1;
failed1: LLDEBUG_LEAVE("tokens", 0);
return 0;
}

int ll_tokens2(LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tokens2");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("tokens2", 1);
{LLSTATE llstate_1;token llatt_1;
if (!ll_token(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed2;
{LLSTATE llstate_2;
if (!ll_tokens2(&llstate_1, &llstate_2, llarg_tag)) goto failed2;
*llout = llstate_2;
#line 129 "parser.ll"
{create_symbol(0, 0, llarg_tag, llatt_1.identifier, llatt_1.altidentifier,
			NULL);
		
#line 397 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("tokens2", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("tokens2");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("tokens2", 1);
return 1;
failed1: LLDEBUG_LEAVE("tokens2", 0);
return 0;
}

int ll_token(token *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("token");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("token", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm('=', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;string llatt_3;
if (!llterm(IDENTIFIER, &lllval, &llstate_2, &llstate_3)) goto failed2;
llatt_3 = lllval._string;
*llout = llstate_3;
#line 136 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).altidentifier = llatt_3; 
#line 448 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("token", 2);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
*llout = llstate_1;
#line 138 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).altidentifier = NULL; 
#line 459 "parser.c"
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("token");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("token", 1);
return 1;
failed1: LLDEBUG_LEAVE("token", 0);
return 0;
}

int ll_nterms(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("nterms");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;nterm llatt_1;
if (!ll_nterm(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed1;
{LLSTATE llstate_2;
if (!ll_nterms2(&llstate_1, &llstate_2, llarg_tag, llarg_ext)) goto failed1;
*llout = llstate_2;
#line 142 "parser.ll"
{create_symbol(1, llarg_ext, llarg_tag, llatt_1.identifier, NULL, llatt_1.tags);
#line 494 "parser.c"
}}}
LLDEBUG_LEAVE("nterms", 1);
return 1;
failed1: LLDEBUG_LEAVE("nterms", 0);
return 0;
}

int ll_nterms2(LLSTATE *llin, LLSTATE *llout, string llarg_tag, integer llarg_ext)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("nterms2");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("nterms2", 1);
{LLSTATE llstate_1;nterm llatt_1;
if (!ll_nterm(&llatt_1, &llstate_0, &llstate_1, llarg_tag)) goto failed2;
{LLSTATE llstate_2;
if (!ll_nterms2(&llstate_1, &llstate_2, llarg_tag, llarg_ext)) goto failed2;
*llout = llstate_2;
#line 146 "parser.ll"
{create_symbol(1, llarg_ext, llarg_tag, llatt_1.identifier, NULL, llatt_1.tags);
#line 526 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("nterms2", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("nterms2");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("nterms2", 1);
return 1;
failed1: LLDEBUG_LEAVE("nterms2", 0);
return 0;
}

int ll_nterm(nterm *llret, LLSTATE *llin, LLSTATE *llout, string llarg_tag)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("nterm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._string;
{LLSTATE llstate_2;strings llatt_2;
if (!ll_tags(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
#line 151 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).tags = llatt_2; 
#line 566 "parser.c"
}}}
LLDEBUG_LEAVE("nterm", 1);
return 1;
failed1: LLDEBUG_LEAVE("nterm", 0);
return 0;
}

int ll_tags(strings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tags");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("tags", 1);
{LLSTATE llstate_1;string llatt_1;
if (!ll_tag(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;strings llatt_2;
if (!ll_tags(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
#line 155 "parser.ll"
{(*llret) = llatt_2;
		    memmove((*llret) + 1, (*llret),
			(MAXTAGS - 1) * sizeof(char *));
		    (*llret)[0] = llatt_1;
		
#line 602 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("tags", 2);
*llout = llstate_0;
#line 161 "parser.ll"
{(*llret) = (char **)malloc(MAXTAGS * sizeof(char *));
		    memset((*llret), 0, MAXTAGS * sizeof(char *));
		
#line 612 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("tags");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("tags", 1);
return 1;
failed1: LLDEBUG_LEAVE("tags", 0);
return 0;
}

int ll_tag(string *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("tag");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("tag", 1);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!llterm(IDENTIFIER, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._string;
{LLSTATE llstate_3;
if (!llterm('>', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 167 "parser.ll"
{(*llret) = find_tag(llatt_2); 
#line 658 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("tag", 2);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('>', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
#line 169 "parser.ll"
{(*llret) = (char *)malloc(strlen(LL) + 6);
		    sprintf((*llret), "%sSTYPE", LL);
		
#line 672 "parser.c"
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("tag");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("tag", 1);
return 1;
failed1: LLDEBUG_LEAVE("tag", 0);
return 0;
}

int ll_union(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("union");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("union", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(TAGDEF, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(';', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
#line 175 "parser.ll"
{if (!usetypes) incput("typedef %s;\n", llatt_1); 
#line 715 "parser.c"
{LLSTATE llstate_3;
if (!ll_union(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("union", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("union");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("union", 1);
return 1;
failed1: LLDEBUG_LEAVE("union", 0);
return 0;
}

int ll_state(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("state");

llstate_0 = *llin;
#undef failed
#define failed failed1
#line 181 "parser.ll"
{if (usetypes) {
			incput("typedef %sPOS %sPOS;\n", USETYPES, LL);
			incput("typedef %sSTATE %sSTATE;\n", USETYPES, LL);
		    } else {
			incput("typedef struct %sPOS {\n", LL);
			incput("\tint line;\n");
			incput("\tint column;\n");
			incput("\tchar *file;\n");
			incput("} %sPOS;\n", LL);
			incput("typedef struct %sSTATE {\n", LL);
			incput("\t%sPOS pos;\n", LL);
		    }
		
#line 764 "parser.c"
{LLSTATE llstate_1;
if (!ll_state1(&llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
#line 195 "parser.ll"
{if (!usetypes) incput("} %sSTATE;\n", LL); 
#line 770 "parser.c"
}}}
LLDEBUG_LEAVE("state", 1);
return 1;
failed1: LLDEBUG_LEAVE("state", 0);
return 0;
}

int ll_state1(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("state1");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("state1", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(TAGDEF, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(';', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
#line 199 "parser.ll"
{if (!usetypes) incput("\t%s;\n", llatt_1); 
#line 802 "parser.c"
{LLSTATE llstate_3;
if (!ll_state1(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("state1", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("state1");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("state1", 1);
return 1;
failed1: LLDEBUG_LEAVE("state1", 0);
return 0;
}

int ll_rulesect(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rulesect");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("rulesect", 1);
{LLSTATE llstate_1;
if (!ll_rule(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_rulesect(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("rulesect", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("rulesect");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("rulesect", 1);
return 1;
failed1: LLDEBUG_LEAVE("rulesect", 0);
return 0;
}

int ll_rule(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rule");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;lhs llatt_1;
if (!ll_lhs(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
#line 211 "parser.ll"
{item_t *item = find_symbol(llatt_1.identifier);
		    /* XXX check llatt_1.args against item */
		    if (!item)
			item = create_symbol(1, 0, NULL, llatt_1.identifier,
			    NULL, NULL);
		    if (item->tag) {
			if (llatt_1.args) {
			    output("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout, %s)\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll, llatt_1.args);
			    incput("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout, %s);\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll, llatt_1.args);
			} else {
			    output("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout)\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll);
			    incput("int %s_%s(%s *%sret, %s%sSTATE *%sin, %sSTATE *%sout);\n",
			    	ll, llatt_1.identifier, item->tag, ll, conststr, LL,
				ll, LL, ll);
			}
		    } else {
			if (llatt_1.args) {
			    output("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout, %s)\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll, llatt_1.args);
			    incput("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout, %s);\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll, llatt_1.args);
			} else {
			    output("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout)\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll);
			    incput("int %s_%s(%s%sSTATE *%sin, %sSTATE *%sout);\n",
			    	ll, llatt_1.identifier, conststr, LL,
				ll, LL, ll);
			}
		    }
		    output("{\n");
		    output("unsigned %sstp = %scstp;\n", ll, ll);
		    output_rhs(llatt_1.identifier, llatt_2);
		    output("}\n");
		    output("\n");
		    add_rules(item, llatt_2);
		
#line 934 "parser.c"
}}}}
LLDEBUG_LEAVE("rule", 1);
return 1;
failed1: LLDEBUG_LEAVE("rule", 0);
return 0;
}

int ll_lhs(lhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("lhs");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._string;
{LLSTATE llstate_2;string llatt_2;
if (!ll_lhsargs(&llatt_2, &llstate_1, &llstate_2, llatt_1)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(':', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
#line 259 "parser.ll"
{(*llret).identifier = llatt_1; (*llret).args = llatt_2; 
#line 961 "parser.c"
}}}}
LLDEBUG_LEAVE("lhs", 1);
return 1;
failed1: LLDEBUG_LEAVE("lhs", 0);
return 0;
}

int ll_rhss(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rhss");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;rhs llatt_1;
if (!ll_items(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss2(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
#line 263 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eAlternative;
		    (*llret)->u.alternative.element = llatt_1;
		    (*llret)->u.alternative.next = llatt_2;
		
#line 989 "parser.c"
}}}
LLDEBUG_LEAVE("rhss", 1);
return 1;
failed1: LLDEBUG_LEAVE("rhss", 0);
return 0;
}

int ll_rhss2(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("rhss2");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("rhss2", 1);
{LLSTATE llstate_1;
if (!llterm('|', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_items(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;rhs llatt_3;
if (!ll_rhss2(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 271 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eAlternative;
		    (*llret)->u.alternative.element = llatt_2;
		    (*llret)->u.alternative.next = llatt_3;
		
#line 1027 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("rhss2", 2);
*llout = llstate_0;
#line 277 "parser.ll"
{(*llret) = NULL; 
#line 1035 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("rhss2");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("rhss2", 1);
return 1;
failed1: LLDEBUG_LEAVE("rhss2", 0);
return 0;
}

int ll_items(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("items");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("items", 1);
{LLSTATE llstate_1;rhs llatt_1;
if (!ll_item(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;bounds llatt_2;
if (!ll_extension(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;rhs llatt_3;
if (!ll_items(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 281 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eSequence;
		    if (llatt_2.lower != 1 || llatt_2.upper != 1) {
			(*llret)->u.sequence.element =
			    (struct rhs_s *)malloc(sizeof(struct rhs_s));
			(*llret)->u.sequence.element->type = eBounded;
			(*llret)->u.sequence.element->u.bounded.items = llatt_1;
			(*llret)->u.sequence.element->u.bounded.bounds = llatt_2;
		    } else {
			(*llret)->u.sequence.element = llatt_1;
		    }
		    (*llret)->u.sequence.next = llatt_3;
		
#line 1092 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("items", 2);
*llout = llstate_0;
#line 295 "parser.ll"
{(*llret) = NULL; 
#line 1100 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("items");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("items", 1);
return 1;
failed1: LLDEBUG_LEAVE("items", 0);
return 0;
}

int ll_item(rhs *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("item");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("item", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(IDENTIFIER, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;string llatt_2;
if (!ll_args(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
#line 299 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eItem;
		    (*llret)->u.item.identifier = llatt_1;
		    (*llret)->u.item.args = llatt_2;
		
#line 1148 "parser.c"
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("item", 2);
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(']', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 305 "parser.ll"
{(*llret) = llatt_2;
		
#line 1163 "parser.c"
break;
}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("item", 3);
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;rhs llatt_2;
if (!ll_rhss(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(':', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;rhs llatt_4;
if (!ll_rhss(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;
if (!llterm(']', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed2;
*llout = llstate_5;
#line 308 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eNode;
		    (*llret)->u.node.left = llatt_2;
		    (*llret)->u.node.right = llatt_4;
		
#line 1185 "parser.c"
break;
}}}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("item", 4);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;ccode llatt_2;
if (!llterm(CCODE, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._ccode;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 314 "parser.ll"
{(*llret) = (struct rhs_s *)malloc(sizeof(struct rhs_s));
		    (*llret)->type = eCCode;
		    (*llret)->u.ccode.ccode = llatt_2;
		    (*llret)->u.ccode.line = llstate_2.pos.line;
		    (*llret)->u.ccode.column = llstate_2.pos.column;
		    (*llret)->u.ccode.file = llstate_2.pos.file;
		
#line 1206 "parser.c"
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("item");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("item", 1);
return 1;
failed1: LLDEBUG_LEAVE("item", 0);
return 0;
}

int ll_extension(bounds *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("extension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("extension", 1);
{LLSTATE llstate_1;
if (!llterm('+', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
#line 324 "parser.ll"
{(*llret).lower = 1;
		    (*llret).upper = 0;
		
#line 1249 "parser.c"
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("extension", 2);
{LLSTATE llstate_1;
if (!llterm('*', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
#line 328 "parser.ll"
{(*llret).lower = 0;
		    (*llret).upper = 0;
		
#line 1261 "parser.c"
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("extension", 3);
{LLSTATE llstate_1;
if (!llterm('?', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
#line 332 "parser.ll"
{(*llret).lower = 0;
		    (*llret).upper = 1;
		
#line 1273 "parser.c"
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("extension", 4);
*llout = llstate_0;
#line 336 "parser.ll"
{(*llret).lower = 1;
		    (*llret).upper = 1;
		
#line 1283 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("extension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("extension", 1);
return 1;
failed1: LLDEBUG_LEAVE("extension", 0);
return 0;
}

int ll_lhsargs(string *llret, LLSTATE *llin, LLSTATE *llout, string llarg_ide)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("lhsargs");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("lhsargs", 1);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
#line 342 "parser.ll"
{item_t *item;
		    item = find_symbol(llarg_ide);
		    if (!item || !item->args || !*item->args) {
			fprintf(stderr,
			    "%s has not been declared to have arguments\n",
			    llarg_ide);
			exit(1);
		    }
		
#line 1331 "parser.c"
{LLSTATE llstate_2;string llatt_2;
if (!ll_lhsarglist(&llatt_2, &llstate_1, &llstate_2, item->args, llarg_ide)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 352 "parser.ll"
{(*llret) = llatt_2; 
#line 1339 "parser.c"
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("lhsargs", 2);
*llout = llstate_0;
#line 354 "parser.ll"
{item_t *item;
		    item = find_symbol(llarg_ide);
		    if (item && item->args && *item->args) {
			fprintf(stderr,
			    "%s has not been declared to have no arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    (*llret) = NULL;
		
#line 1356 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("lhsargs");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("lhsargs", 1);
return 1;
failed1: LLDEBUG_LEAVE("lhsargs", 0);
return 0;
}

int ll_lhsarglist(string *llret, LLSTATE *llin, LLSTATE *llout, strings llarg_tags, string llarg_ide)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("lhsarglist");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("lhsarglist", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;string llatt_3;
if (!ll_lhsarglist(&llatt_3, &llstate_2, &llstate_3, llarg_tags+1, llarg_ide)) goto failed2;
*llout = llstate_3;
#line 367 "parser.ll"
{if (!*llarg_tags) {
			fprintf(stderr,
			    "%s has not been declared to have so much arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    (*llret) = (char *)malloc(strlen(llatt_1) + strlen(llatt_3) +
			strlen(*llarg_tags) + strlen(conststr) + 10);
		    sprintf((*llret), "%s%s %sarg_%s, %s",
			conststr, *llarg_tags, ll, llatt_1, llatt_3);
		
#line 1412 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("lhsarglist", 2);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
*llout = llstate_1;
#line 379 "parser.ll"
{if (!*llarg_tags) {
			fprintf(stderr,
			    "%s has not been declared to have so much arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    if (llarg_tags[1]) {
			fprintf(stderr,
			    "%s has not been declared to have so less arguments\n",
			    llarg_ide);
			exit(1);
		    }
		    (*llret) = (char *)malloc(strlen(llatt_1) + strlen(*llarg_tags) +
		    	strlen(conststr) + 8);
		    sprintf((*llret), "%s%s %sarg_%s", conststr, *llarg_tags, ll, llatt_1);
		
#line 1438 "parser.c"
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("lhsarglist");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("lhsarglist", 1);
return 1;
failed1: LLDEBUG_LEAVE("lhsarglist", 0);
return 0;
}

int ll_args(string *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("args");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("args", 1);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;string llatt_2;
if (!ll_arglist(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 398 "parser.ll"
{(*llret) = llatt_2; 
#line 1483 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("args", 2);
*llout = llstate_0;
#line 400 "parser.ll"
{(*llret) = ""; 
#line 1491 "parser.c"
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("args");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("args", 1);
return 1;
failed1: LLDEBUG_LEAVE("args", 0);
return 0;
}

int ll_arglist(string *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("arglist");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("arglist", 1);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;string llatt_3;
if (!ll_arglist(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
#line 404 "parser.ll"
{char *p = convert(llatt_1);
		    (*llret) = (char *)malloc(strlen(p) + strlen(llatt_3) + 3);
		    strcpy((*llret), p);
		    strcat((*llret), ", ");
		    strcat((*llret), llatt_3);
		
#line 1542 "parser.c"
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("arglist", 2);
{LLSTATE llstate_1;string llatt_1;
if (!llterm(ARG, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._string;
*llout = llstate_1;
#line 411 "parser.ll"
{(*llret) = convert(llatt_1); 
#line 1553 "parser.c"
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("arglist");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("arglist", 1);
return 1;
failed1: LLDEBUG_LEAVE("arglist", 0);
return 0;
}

int ll_csect(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("csect");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("csect", 1);
{LLSTATE llstate_1;ccode llatt_1;
if (!llterm(CCODE, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._ccode;
*llout = llstate_1;
#line 417 "parser.ll"
{if (linedirective)
			output("#line %d \"%s\"\n", llstate_1.pos.line, llstate_1.pos.file);
		    output("%s\n", llatt_1);
		    if (linedirective)
			output_line();
		
#line 1600 "parser.c"
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("csect", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("csect");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("csect", 1);
return 1;
failed1: LLDEBUG_LEAVE("csect", 0);
return 0;
}

#line 426 "parser.ll"

#line 1625 "parser.c"
int
llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout)
{
unsigned i;
LLDEBUG_ENTER("llparser");
lltokens = tokens; llntokens = ntokens;
for (i = 0; i < llstksize; i++) llstk[i] = 1;
llcstp = 1; llcpos = 0; llepos = 0; *llerrormsg = 0;
#if LLDEBUG > 0
last_linenr = 0; last_file = "";
#endif
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
if (!ll_main(llin, llout)) goto failed2;
if (llcpos != llntokens) goto failed2;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("llparser");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("llparser", 1);
return 1;
failed1:
LLDEBUG_LEAVE("llparser", 0);
return 0;
}

int
llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_TOKEN(token, llcpos);
	if (llcpos < llntokens && lltokens[llcpos].token == token) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}

int
llanyterm(LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llanyterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_ANYTOKEN(llcpos);
	if (llcpos < llntokens) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}
void
llscanner(LLTERM **tokens, unsigned *ntokens)
{
	unsigned i = 0;
#if LLDEBUG > 0
	int line = -1;
#endif

	*ntokens = 1024;
	*tokens = (LLTERM *)malloc(*ntokens * sizeof(LLTERM));
	while (llgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {
#if LLDEBUG > 0
		if (lldebug > 0 && (*tokens)[i].pos.line > line) {
			line = (*tokens)[i].pos.line / 10 * 10 + 9;
			fprintf(stderr, "File \"%s\", Line %5d                    \r",
				(*tokens)[i].pos.file, (*tokens)[i].pos.line);
		}
#endif
		if (++i >= *ntokens) {
			*ntokens *= 2;
			*tokens = (LLTERM *)realloc(*tokens, *ntokens * sizeof(LLTERM));
		}
	}
	(*tokens)[i].token = 0;
	*ntokens = i;
#if LLDEBUG > 0
	lldebug_init();
#endif
	llresizestk();
}

void
llfailed(LLPOS *pos, char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	if (llcpos > llepos || llcpos == llepos && !*llerrormsg) {
		llepos = llcpos;
		if (fmt)
			vsprintf(llerrormsg, fmt, args);
		else
			*llerrormsg = 0;
		llerrorpos = *pos;
	}
	va_end(args);
}

void
llprinterror(FILE *f)
{
#if LLDEBUG > 0
	fputs("                                \r", stderr);
#endif
	if (*llerrormsg)
		llerror(f, &llerrorpos, llerrormsg);
	else
		llerror(f, &llerrorpos, "Syntax error");
}

void
llerror(FILE *f, LLPOS *pos, char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	llverror(f, pos, fmt, args);
	va_end(args);
}

void
llresizestk()
{
	unsigned i;

	if (llcstp + 1 >= llstksize) {
		i = llstksize;
		if (!llstksize)
			llstk = (int *)malloc((llstksize = 4096) * sizeof(int));
		else
			llstk = (int *)realloc(llstk, (llstksize *= 2) * sizeof(int));
		for (; i < llstksize; i++)
			llstk[i] = 1;
	}
}

#if LLDEBUG > 0
int lldepth;
char *lltokentab[] = {
"EOF","#1","#2","#3","#4","#5","#6","#7"
,"#8","#9","#10","#11","#12","#13","#14","#15"
,"#16","#17","#18","#19","#20","#21","#22","#23"
,"#24","#25","#26","#27","#28","#29","#30","#31"
,"' '","'!'","'\"'","'#'","'$'","'%'","'&'","'''"
,"'('","')'","'*'","'+'","','","'-'","'.'","'/'"
,"'0'","'1'","'2'","'3'","'4'","'5'","'6'","'7'"
,"'8'","'9'","':'","';'","'<'","'='","'>'","'?'"
,"'@'","'A'","'B'","'C'","'D'","'E'","'F'","'G'"
,"'H'","'I'","'J'","'K'","'L'","'M'","'N'","'O'"
,"'P'","'Q'","'R'","'S'","'T'","'U'","'V'","'W'"
,"'X'","'Y'","'Z'","'['","'\\'","']'","'^'","'_'"
,"'`'","'a'","'b'","'c'","'d'","'e'","'f'","'g'"
,"'h'","'i'","'j'","'k'","'l'","'m'","'n'","'o'"
,"'p'","'q'","'r'","'s'","'t'","'u'","'v'","'w'"
,"'x'","'y'","'z'","'{'","'|'","'}'","'~'","#127"
,"#128","#129","#130","#131","#132","#133","#134","#135"
,"#136","#137","#138","#139","#140","#141","#142","#143"
,"#144","#145","#146","#147","#148","#149","#150","#151"
,"#152","#153","#154","#155","#156","#157","#158","#159"
,"#160","#161","#162","#163","#164","#165","#166","#167"
,"#168","#169","#170","#171","#172","#173","#174","#175"
,"#176","#177","#178","#179","#180","#181","#182","#183"
,"#184","#185","#186","#187","#188","#189","#190","#191"
,"#192","#193","#194","#195","#196","#197","#198","#199"
,"#200","#201","#202","#203","#204","#205","#206","#207"
,"#208","#209","#210","#211","#212","#213","#214","#215"
,"#216","#217","#218","#219","#220","#221","#222","#223"
,"#224","#225","#226","#227","#228","#229","#230","#231"
,"#232","#233","#234","#235","#236","#237","#238","#239"
,"#240","#241","#242","#243","#244","#245","#246","#247"
,"#248","#249","#250","#251","#252","#253","#254","#255"
,"#256","IDENTIFIER","ARG","CCODE","TAGDEF","PERCENT_PERCENT","PERCENT_TOKEN","PERCENT_TYPE"
,"PERCENT_EXTERNAL","PERCENT_UNION","PERCENT_STATE","PERCENT_START","PERCENT_PREFIX","PERCENT_MODULE","PERCENT_LBRACE","PERCENT_RBRACE"
};

void
lldebug_init()
{
	char *p;
	p = getenv("LLDEBUG");
	if (p)
		lldebug = atoi(p);
}

void
lldebug_enter(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("/--- trying rule %s\n", ident);
	lldepth++;
}

void
lldebug_leave(char *ident, int succ)
{
	int i;

	if (lldebug < 2)
		return;
	lldepth--;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (succ)
		printf("\\--- succeeded to apply rule %s\n", ident);
	else
		printf("\\--- failed to apply rule %s\n", ident);
}

void
lldebug_alternative(char *ident, int alt)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying alternative %d for rule %s\n", alt, ident);
}

lldebug_iteration(char *ident, int num)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying iteration %d for rule %s\n", num, ident);
}

void
lldebug_token(int expected, unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (pos < llntokens && expected == lltokens[pos].token)
		printf("   found token ");
	else
		printf("   expected token %s, found token ", lltokentab[expected]);
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_anytoken(unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   found token ");
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_backtracking(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   backtracking rule %s\n", ident);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1all\scanner.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "defs.h"
#include "parser.h"

#define IS_IDENT(c) (isalpha(c) || c == '_' || c == '\'' || c == '\"')

#ifdef YYDEBUG
extern int yydebug;
#endif

enum {
    DeclSection,
    Union,
    Union1,
    State,
    State1,
    CCode,
    RuleSection,
    Arg,
    Action,
    CSection,
    End
} state;

int bufferpos;
char *buffer = 0;
int buffersize = 0;

char *line = 0;
int linesize = 0;
int linelen = 0;
char *cptr;
int meteof = 0;
int lineno;
char filename[256];
FILE *fin;

void error(LLPOS *pos, char *fmt, ...);

void
addchar(char c)
{
    if (bufferpos >= buffersize) {
    if (!buffersize) {
        buffersize = 4096;
        buffer = (char *)malloc(buffersize);
    } else {
        buffersize <<= 1;
        buffer = (char *)realloc(buffer, buffersize);
    }
    if (!buffer)
        error(NULL, "Out of memory");
    }
    buffer[bufferpos++] = c;
}

void
memmove_fwd(char *dst, char *src, int len)
{
    while (len--)
    *dst++ = *src++;
}

int
read_line()
{
    int nread;
    int left;

    if (!linesize) {
    linesize = 4096;
    cptr = line = (char *)malloc(linesize);
    linelen = 0;
    }
    if (!linelen && meteof)
    return 0;
    if (linelen && (cptr <= line || cptr > line + linelen || cptr[-1] != '\n'))
    abort();
    left = linelen - (int)(cptr - line);
    if (left && memchr(cptr, '\n', left))
    return 1;
    linelen = left;
    if (left)
    memmove_fwd(line, cptr, left);
    cptr = line;
    while ((!linelen || !memchr(line, '\n', linelen)) && !meteof) {
    if (linesize - linelen < 2048) {
        linesize <<= 1;
        line = (char *)realloc(line, linesize);
        cptr = line;
    }
    nread = fread(line + linelen, 1, linesize - linelen, fin);
    if (nread < linesize - linelen)
        meteof = 1;
    linelen += nread;
    }
    return linelen > 0;
}

int
get_line()
{
    int depth = 0;
    char *p;

    for (;;) {
    if (!read_line())
        return 0;
    if (!strncmp(cptr, "#line ", 6)) {
        lineno = strtol(cptr + 6, &cptr, 10) - 1;
        while (isspace(*cptr) && *cptr != '\n')
            cptr++;
        if (*cptr == '\"') {
            cptr++;
            for (p = filename; *cptr != '\n' && *cptr != '\"';) {
            *p++ = *cptr++;
        }
        *p = 0;
        }
        cptr = strchr(cptr, '\n') + 1;
        continue;
    }
    lineno++;
    if (!strncmp(cptr, "%comment", 8)) {
        cptr = strchr(cptr, '\n') + 1;
        depth++;
        continue;
    }
    if (!strncmp(cptr, "%endcomment", 11)) {
        cptr = strchr(cptr, '\n') + 1;
        depth--;
        continue;
    }
    if (!depth)
        return 1;
    cptr = strchr(cptr, '\n') + 1;
    }
}

int
read_char()
{
    for (;;) {
    if (!cptr) {
        if (!get_line())
        return EOF;
        continue;
    }
    if (*cptr == '\n') {
        cptr++;
        if (!get_line())
        return EOF;
        continue;
    }
    if (isspace(*cptr)) {
        cptr++;
        continue;
    }
    if (*cptr == '/' && cptr[1] == '/') {
        cptr = strchr(cptr, '\n') + 1;
        continue;
    }
    if (*cptr == '/' && cptr[1] == '*') {
        cptr += 2;
        do {
        while (*cptr != '*') {
            if (*cptr++ == '\n') {
            if (!get_line())
                error(NULL, "Unexpected EOF");
            }
        }
        } while (*++cptr != '/');
        cptr++;
        continue;
    }
    break;
    }
    return *cptr;
}

void
get_identifier(LLPOS *pos)
{
    int quote;

    bufferpos = 0;
    addchar(*cptr);
    if (*cptr == '\'' || *cptr == '\"') {
    quote = *cptr++;
    while (*cptr != quote) {
        if (*cptr == '\n')
        error(pos, "Missing closing quote");
        addchar(*cptr);
        if (*cptr++ == '\\')
        addchar(*cptr++);
    }
    addchar(*cptr++);
    } else {
    cptr++;
    while (isalnum(*cptr) || *cptr == '_')
        addchar(*cptr++);
    }
    addchar(0);
}

int
get_token(LLSTYPE *lval, LLPOS *pos)
{
    int c;
    int depth;

    c = read_char();
    pos->line = lineno;
    pos->column = cptr ? (int)(cptr - line) - 1 : 0;
    pos->file = strdup(filename);

    switch (state) {
    case DeclSection:
    if (!strncmp(cptr, "%%", 2)) {
        state = RuleSection;
        cptr += 2;
        return PERCENT_PERCENT;
    }
    if (!strncmp(cptr, "%token", 6)) {
        cptr += 6;
        return PERCENT_TOKEN;
    }
    if (!strncmp(cptr, "%type", 5)) {
        cptr += 5;
        return PERCENT_TYPE;
    }
    if (!strncmp(cptr, "%external", 9)) {
        cptr += 9;
        return PERCENT_EXTERNAL;
    }
    if (!strncmp(cptr, "%start", 6)) {
        cptr += 6;
        return PERCENT_START;
    }
    if (!strncmp(cptr, "%union", 6)) {
        state = Union;
        cptr += 6;
        return PERCENT_UNION;
    }
    if (!strncmp(cptr, "%state", 6)) {
        state = State;
        cptr += 6;
        return PERCENT_STATE;
    }
    if (!strncmp(cptr, "%prefix", 7)) {
        cptr += 7;
        return PERCENT_PREFIX;
    }
    if (!strncmp(cptr, "%module", 7)) {
        cptr += 7;
        return PERCENT_MODULE;
    }
    if (!strncmp(cptr, "%{", 2)) { /*}*/
        state = CCode;
        cptr += 2;
        return PERCENT_LBRACE;
    }
    if (!strncmp(cptr, "%}", 2)) { /*{*/
        cptr += 2;
        return PERCENT_RBRACE;
    }
    if (c == '<' || c == '>' || c == '=') {
        return *cptr++;
    }
    if (IS_IDENT(c)) {
        get_identifier(pos);
        lval->_string = strdup(buffer);
        return IDENTIFIER;
    }
    break;
    case Union:
    if (c == '{') { /*}*/
        state = Union1;
        cptr++;
        return c;
    }
        break;
    case Union1:
    bufferpos = 0;
    if (c == '}') { /*{*/
        state = DeclSection;
        cptr++;
        return c;
    }
    if (c == ';') {
        cptr++;
        return c;
    }
    while (*cptr != ';') {
        addchar(*cptr++);
        if (*cptr == '\n') {
        cptr++;
        if (!get_line())
            error(pos, "Unexpected EOF");
        }
    }
    addchar(0);
    lval->_string = strdup(buffer);
    return TAGDEF;
    case State:
    if (c == '{') { /*}*/
        state = State1;
        cptr++;
        return c;
    }
        break;
    case State1:
    bufferpos = 0;
    if (c == '}') { /*{*/
        state = DeclSection;
        cptr++;
        return c;
    }
    if (c == ';') {
        cptr++;
        return c;
    }
    while (*cptr != ';') {
        addchar(*cptr++);
        if (*cptr == '\n') {
        cptr++;
        if (!get_line())
            error(pos, "Unexpected EOF");
        }
    }
    addchar(0);
    lval->_string = strdup(buffer);
    return TAGDEF;
    case CCode:
    bufferpos = 0;
    for (;;) {
        if (*cptr == '%' && cptr[1] == '}') /*{*/
        break;
        addchar(*cptr);
        if (*cptr++ == '\n') {
        if (!get_line())
            error(pos, "Unexpected EOF");
        }
    }
    state = DeclSection;
    addchar(0);
    lval->_ccode = strdup(buffer);
    return CCODE;
    case RuleSection:
    if (IS_IDENT(c)) {
        get_identifier(pos);
        lval->_string = strdup(buffer);
        return IDENTIFIER;
    }
    if (c == '(') {
        state = Arg;
        cptr++;
        return c;
    }
    if (c == ':' || c == ';' || c == '|' || c == '}' || c == '+' ||
        c == '*' || c == '?' || c == '[' || c == ']') { /*{*/
        cptr++;
        return c;
    }
    if (c == '%' && cptr[1] == '%') {
        state = CSection;
        cptr += 2;
        return PERCENT_PERCENT;
    }
    if (c == '{') {
        state = Action;
        cptr++;
        return c;
    }
    break;
    case Arg:
    if (c == ')') {
        state = RuleSection;
        cptr++;
        return c;
    }
    if (c == ',') {
        cptr++;
        return c;
    }
    bufferpos = 0;
    depth = 0;
    for (;;) {
        switch (*cptr) {
        case '(':
        depth++;
        addchar(*cptr++);
        continue;
        case ')':
        if (depth > 0) {
            depth--;
            addchar(*cptr++);
            continue;
        }
        break;
        case ',':
        if (depth > 0) {
            addchar(*cptr++);
            continue;
        }
        break;
        case '\n':
        error(pos, "Unterminated argument");
        /*NOTREACHED*/
        default:
        addchar(*cptr++);
        continue;
        }
        break;
    }
    addchar(0);
    lval->_string = strdup(buffer);
    return ARG;
    case Action:
    bufferpos = 0;
    depth = 0;
    for (;;) {
        switch (*cptr) {
        case '{': /*}*/
        depth++;
        addchar(*cptr++);
        continue;
        case '}': /*{*/
        if (depth > 0) {
            depth--;
            addchar(*cptr++);
            continue;
        }
        break;
        case '\'':
        case '\"':
        c = *cptr++;
        addchar((char)c);
        while (*cptr != c) {
            addchar(*cptr);
            if (*cptr == '\n') {
            cptr++;
            get_line();
            continue;
            }
            if (*cptr == '\\')
            addchar(*++cptr);
            cptr++;
        }
        addchar((char)c);
        cptr++;
        continue;
        case '\n':
        addchar(*cptr++);
        if (!get_line())
            error(pos, "Unexpected EOF");
        continue;
        default:
        addchar(*cptr++);
        continue;
        }
        break;
    }
    state = RuleSection;
    addchar(0);
    lval->_ccode = strdup(buffer);
    return CCODE;
    case CSection:
    bufferpos = 0;
    if (c != EOF) {
        do {
        do {
            addchar(*cptr);
        } while (*cptr++ != '\n');
        } while (get_line());
    }
    state = End;
    addchar(0);
    lval->_ccode = strdup(buffer);
    return CCODE;
    case End:
    return EOF;
    }
    error(pos, "Syntax error");
    return EOF;
    /*NOTREACHED*/
}

void
open_file(char *file)
{
    strcpy(filename, file);
    lineno = 0;
    fin = fopen(filename, "r");
    if (!fin) {
    perror(file);
    exit(1);
    }
}

int
llgettoken(int *token, LLSTYPE *lval, LLPOS *pos)
{
    *token = get_token(lval, pos);
    return *token != EOF;
}

void
llprinttoken(LLTERM *token, char *identifier, FILE *f)
{
    switch (token->token) {
    case IDENTIFIER:
    printf("scanner: delivering token IDENTIFIER(%s)\n", token->lval._string);
    break;
    case ARG:
    printf("scanner: delivering token ARG(%s)\n", token->lval._string);
    break;
    case CCODE:
    printf("scanner: delivering token CCODE(%s)\n", token->lval._ccode);
    break;
    case TAGDEF:
    printf("scanner: delivering token TAGDEF(%s)\n", token->lval._string);
    break;
    case PERCENT_PERCENT:
    printf("scanner: delivering token %%%%\n");
    break;
    case PERCENT_TOKEN:
    printf("scanner: delivering token %%token\n");
    break;
    case PERCENT_TYPE:
    printf("scanner: delivering token %%type\n");
    break;
    case PERCENT_UNION:
    printf("scanner: delivering token %%union\n");
    break;
    case PERCENT_START:
    printf("scanner: delivering token %%start\n");
    break;
    case PERCENT_PREFIX:
    printf("scanner: delivering token %%prefix\n");
    break;
    case PERCENT_LBRACE:
    printf("scanner: delivering token %%{\n");
    break;
    case PERCENT_RBRACE:
    printf("scanner: delivering token %%}\n");
    break;
    case EOF:
    printf("scanner: delivering token EOF\n");
    break;
    default:
    printf("scanner: delivering token %c\n", token->token);
    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\builtin.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_BUILTIN_H_
#define _ASN1C_BUILTIN_H_

extern Type_t *Builtin_Type_Null;
extern Type_t *Builtin_Type_Boolean;
extern Type_t *Builtin_Type_Integer;
extern Type_t *Builtin_Type_PositiveInteger;
extern Type_t *Builtin_Type_ObjectIdentifier;
extern Type_t *Builtin_Type_ObjectDescriptor;
extern Type_t *Builtin_Type_Open;
extern Type_t *Builtin_Type_BitString;
extern Type_t *Builtin_Type_OctetString;
extern Type_t *Builtin_Type_UTF8String;
extern Type_t *Builtin_Type_BMPString;
extern Type_t *Builtin_Type_GeneralString;
extern Type_t *Builtin_Type_GraphicString;
extern Type_t *Builtin_Type_IA5String;
extern Type_t *Builtin_Type_ISO646String;
extern Type_t *Builtin_Type_NumericString;
extern Type_t *Builtin_Type_PrintableString;
extern Type_t *Builtin_Type_TeletexString;
extern Type_t *Builtin_Type_T61String;
extern Type_t *Builtin_Type_UniversalString;
extern Type_t *Builtin_Type_VideotexString;
extern Type_t *Builtin_Type_VisibleString;
extern Type_t *Builtin_Type_CharacterString;
extern Type_t *Builtin_Type_GeneralizedTime;
extern Type_t *Builtin_Type_UTCTime;
extern Type_t *Builtin_Type_Real;
extern Type_t *Builtin_Type_External;
extern Type_t *Builtin_Type_EmbeddedPdv;
extern Value_t *Builtin_Value_Null;
extern Value_t *Builtin_Value_Integer_0;
extern Value_t *Builtin_Value_Integer_1;
extern Value_t *Builtin_Value_Integer_2;
extern Value_t *Builtin_Value_Integer_10;
extern ObjectClass_t *Builtin_ObjectClass_TypeIdentifier;
extern ObjectClass_t *Builtin_ObjectClass_AbstractSyntax;
extern ModuleIdentifier_t *Builtin_Module;
extern ModuleIdentifier_t *Builtin_Character_Module;
extern AssignmentList_t Builtin_Assignments;
extern AssignedObjIdList_t Builtin_ObjIds;

extern void InitBuiltin();

#endif // _ASN1C_BUILTIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\ber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

void ExamineBERType(AssignmentList_t ass, Type_t *type, char *ideref);
void ExamineBERType_Boolean(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Integer(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Enumerated(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Real(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_BitString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_OctetString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UTF8String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Null(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_External(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_BMPString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GeneralString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GraphicString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_IA5String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ISO646String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_NumericString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_PrintableString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_TeletexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_T61String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UniversalString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_VideotexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_VisibleString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_UTCTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Open(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_SequenceSet(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Choice(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_InstanceOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);
void ExamineBERType_Reference(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info);

/* examine all types and extract informations needed for BER encoding */
void
ExamineBER(AssignmentList_t ass)
{
    Assignment_t *a;

    /* examine all assignments */
    for (a = ass; a; a = a->Next) {

	/* examine types */
	switch (a->Type) {
	case eAssignment_Type:
	    ExamineBERType(ass, a->U.Type.Type, GetName(a));
	    break;
	}
    }
}

/* extract some type informations needed for BER encoding */
void
ExamineBERType(AssignmentList_t ass, Type_t *type, char *ideref)
{
    BERTypeInfo_t *info;

    info = &type->BERTypeInfo;
    info->pPrivateDirectives = &type->PrivateDirectives;

    /* get tags to en-/decode */
    if (IsReferenceType(type) && IsStructuredType(GetType(ass, type))) {
	info->Tags = type->Tags;
    } else {
	info->Tags = type->AllTags;
    }

    /* get the type to be examined */
    if (IsReferenceType(type) && !IsStructuredType(GetType(ass, type)))
	type = GetType(ass, type);

    /* initialize the BER informations */
    info->Identifier = ideref;
    info->Rules = type->Rules;
    info->Flags = type->Flags;
    info->NOctets = 0;
    info->SubIdentifier = NULL;
    info->SubType = NULL;
    info->Data = eBERSTIData_Null;

    /* BER informations are type specific ... */
    switch (type->Type) {
    case eType_Boolean:
	ExamineBERType_Boolean(ass, type, info);
	break;
    case eType_Integer:
	ExamineBERType_Integer(ass, type, info);
	break;
    case eType_Enumerated:
	ExamineBERType_Enumerated(ass, type, info);
	break;
    case eType_Real:
	ExamineBERType_Real(ass, type, info);
	break;
    case eType_BitString:
	ExamineBERType_BitString(ass, type, info);
	break;
    case eType_OctetString:
	ExamineBERType_OctetString(ass, type, info);
	break;
    case eType_UTF8String:
	ExamineBERType_UTF8String(ass, type, info);
	break;
    case eType_Null:
	ExamineBERType_Null(ass, type, info);
	break;
    case eType_EmbeddedPdv:
	ExamineBERType_EmbeddedPdv(ass, type, info);
	break;
    case eType_External:
	ExamineBERType_External(ass, type, info);
	break;
    case eType_ObjectIdentifier:
	ExamineBERType_ObjectIdentifier(ass, type, info);
	break;
    case eType_BMPString:
	ExamineBERType_BMPString(ass, type, info);
	break;
    case eType_GeneralString:
	ExamineBERType_GeneralString(ass, type, info);
	break;
    case eType_GraphicString:
	ExamineBERType_GraphicString(ass, type, info);
	break;
    case eType_IA5String:
	ExamineBERType_IA5String(ass, type, info);
	break;
    case eType_ISO646String:
	ExamineBERType_ISO646String(ass, type, info);
	break;
    case eType_NumericString:
	ExamineBERType_NumericString(ass, type, info);
	break;
    case eType_PrintableString:
	ExamineBERType_PrintableString(ass, type, info);
	break;
    case eType_TeletexString:
	ExamineBERType_TeletexString(ass, type, info);
	break;
    case eType_T61String:
	ExamineBERType_T61String(ass, type, info);
	break;
    case eType_UniversalString:
	ExamineBERType_UniversalString(ass, type, info);
	break;
    case eType_VideotexString:
	ExamineBERType_VideotexString(ass, type, info);
	break;
    case eType_VisibleString:
	ExamineBERType_VisibleString(ass, type, info);
	break;
    case eType_CharacterString:
	ExamineBERType_UnrestrictedString(ass, type, info);
	break;
    case eType_GeneralizedTime:
	ExamineBERType_GeneralizedTime(ass, type, info);
	break;
    case eType_UTCTime:
	ExamineBERType_UTCTime(ass, type, info);
	break;
    case eType_ObjectDescriptor:
	ExamineBERType_ObjectDescriptor(ass, type, info);
	break;
    case eType_Open:
	ExamineBERType_Open(ass, type, info);
	break;
    case eType_Sequence:
    case eType_Set:
	ExamineBERType_SequenceSet(ass, type, info);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ExamineBERType_SequenceSetOf(ass, type, info);
	break;
    case eType_Choice:
	ExamineBERType_Choice(ass, type, info);
	break;
    case eType_InstanceOf:
	ExamineBERType_InstanceOf(ass, type, info);
	break;
    case eType_RestrictedString:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Selection:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Reference:
	ExamineBERType_Reference(ass, type, info);
	break;
    case eType_FieldReference:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    }
}

/*
 * Description of the fields of BERTypeInfo_t:
 *   info.
 *	Identifier	complete name of the type
 *	Rules		encoding directive rules
 *	Flags		encoding flags
 *	NOctets		size of string characters/integer type
 *	Data		data type of value
 *	SubIdentifier	complete name of the subtype
 *	SubType		the subtype itself
 *	Tags		tag list of the type
 *
 * NOTES:
 *	The encoding is mostly controlled by following arguments:
 *	- Data, the type: one of:
 *	  eBERSTIData_Null, eBERSTIData_Boolean,
 *	  eBERSTIData_Integer, eBERSTIData_Unsigned,
 *	  eBERSTIData_Real, eBERSTIData_BitString, eBERSTIData_RZBBitString,
 *	  eBERSTIData_OctetString, eBERSTIData_SequenceOf, eBERSTIData_SetOf,
 *	  eBERSTIData_Sequence, eBERSTIData_Set, eBERSTIData_Choice,
 *	  eBERSTIData_ObjectIdentifier, eBERSTIData_ObjectIdEncoded, eBERSTIData_String,
 *	  eBERSTIData_ZeroString, eBERSTIData_Reference, eBERSTIData_External,
 *	  eBERSTIData_EmbeddedPdv, eBERSTIData_UnrestrictedString
 *
 *	Following arguments contain variable/function names in the generated
 *	code:
 *	- Identifier, the name of the current type
 *	- SubIdentifier, the name of the subtype
 *
 *	Following values require additional arguments:
 *	- Data == eBERSTIData_Reference
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	- Data == eBERSTIData_*String
 *	  -> NOctets, the size of the string characters
 *	- Data == eBERSTIData_Integer || Data == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || Data == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 *	- Data == eBERSTIData_SequenceOf || Data == eBERSTIData_SetOf
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */

/*
 * BOOLEAN:
 *
 *	Data == eBERSTIData_Boolean
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Boolean(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_Boolean;
    info->NOctets = GetOctets(GetBooleanType());
}

/*
 * INTEGER:
 *
 *	Data == eBERSTIData_Integer ||
 *	Data == eBERSTIData_Unsigned
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Integer(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    int32_t sign;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetIntegerType(ass, type, &sign));
    info->Data = sign > 0 ? eBERSTIData_Unsigned : eBERSTIData_Integer;
}

/*
 * ENUMERATED:
 *
 *	Data == eBERSTIData_Integer ||
 *	Data == eBERSTIData_Unsigned
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Enumerated(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    int32_t sign;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetEnumeratedType(ass, type, &sign));
    info->Data = sign > 0 ? eBERSTIData_Unsigned : eBERSTIData_Integer;
}

/*
 * REAL:
 *
 *	Data == eBERSTIData_Real
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Real(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = GetOctets(GetRealType(type));
    info->Data = eBERSTIData_Real;
}

/*
 * BIT STRING:
 *
 *	Data == eBERSTIData_BitString ||
 *	Data == eBERSTIData_RZBBitString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_BitString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to RZBBitString/BitString */
    if (type->U.BitString.NamedNumbers)
	info->Data = eBERSTIData_RZBBitString;
    else
	info->Data = eBERSTIData_BitString;
}

/*
 * OCTET STRING:
 *
 *	Data == eBERSTIData_OctetString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_OctetString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to OctetString */
    info->Data = eBERSTIData_OctetString;
}

void
ExamineBERType_UTF8String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    /* set Data to UTF8String */
    info->Data = eBERSTIData_UTF8String;
}

/*
 * NULL:
 *
 *	Data == eBERSTIData_Null
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Null(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_Null;
}

/*
 * EMBEDDED PDV:
 *
 *	Data == eBERSTIData_EmbeddedPdv
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_EmbeddedPdv;
}

/*
 * EXTERNAL:
 *
 *	Data == eBERSTIData_External
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_External(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_External;
}

/*
 * OBJECT IDENTIFIER:
 *
 *	Data == eBERSTIData_ObjectIdEncoded || eBERSTIData_ObjectIdentifier
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = type->PrivateDirectives.fOidPacked ? eBERSTIData_ObjectIdEncoded : eBERSTIData_ObjectIdentifier;
}

/*
 * *String:
 *
 *	Data == eBERSTIData_String ||
 *	Data == eBERSTIData_ZeroString
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_*String
 *	  -> NOctets, the size of the string characters
 */

void
ExamineBERType_BMPString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_GeneralString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_GraphicString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_IA5String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_ISO646String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_NumericString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_PrintableString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_TeletexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_T61String(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_UniversalString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

void
ExamineBERType_VideotexString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t noctets, zero;

    GetStringType(ass, type, &noctets, &zero); // to make hack directives become effective
    info->Data = eBERSTIData_MultibyteString;
    info->NOctets = 1;
}

void
ExamineBERType_VisibleString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Data = zero ? eBERSTIData_ZeroString : eBERSTIData_String;
}

/*
 * CHARACTER STRING:
 *
 *	Data == eBERSTIData_UnrestrictedString
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_EmbeddedPdv ||
 *	  Data == eBERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExamineBERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_UnrestrictedString;
}

/*
 * GeneralizedTime:
 *
 *	Data == eBERSTIData_GeneralizedTime
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_GeneralizedTime;
}

/*
 * UTCTime:
 *
 *	Data == eBERSTIData_UTCTime
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_UTCTime(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->Data = eBERSTIData_UTCTime;
}

/*
 * ObjectDescriptor:
 *
 *	Data == eBERSTIData_ZeroString
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Data = eBERSTIData_ZeroString;
}

/*
 * OpenType:
 *
 *	Data == eBERSTIData_Open
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_Open(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Data = eBERSTIData_Open;
}

/*
 * SEQUENCE/SET:
 *
 *	Data == eBERSTIData_Sequence ||
 *	Data == eBERSTIData_Set
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_SequenceSet(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->Data = (type->Type == eType_Sequence) ?
	eBERSTIData_Sequence : eBERSTIData_Set;

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * SEQUENCE OF/SET OF:
 *
 *	Data == eBERSTIData_SequenceOf ||
 *	Data == eBERSTIData_SetOf
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_SequenceOf || dat == eBERSTIData_SetOf
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */
void
ExamineBERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    char idebuf[256];

    /* set data type and Alignment */
    info->Data = (type->Type == eType_SequenceOf ?
	eBERSTIData_SequenceOf : eBERSTIData_SetOf);

    /* set SubType, SubIdentifier */
    info->SubType = type->U.SS.Type;
    info->SubIdentifier = GetTypeName(ass, info->SubType);

    /* examine subtype */
    sprintf(idebuf, "%s_%s", info->Identifier,
	type->Type == eType_SequenceOf ? "Sequence" : "Set");
    ExamineBERType(ass, type->U.SS.Type, strdup(idebuf));
}

/*
 * CHOICE:
 *
 *	Data == eBERSTIData_Choice
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Integer || dat == eBERSTIData_Unsigned ||
 *	  Data == eBERSTIData_Boolean || dat == eBERSTIData_Choice
 *	  -> NOctets, the size of the integer type
 */
void
ExamineBERType_Choice(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->NOctets = GetOctets(GetChoiceType(type));
    info->Data = eBERSTIData_Choice;

    /* examine types of alternatives */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * INSTANCE OF:
 *
 *	Data == eBERSTIData_Sequence
 *
 * Additional arguments:
 *
 *	none
 */
void
ExamineBERType_InstanceOf(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    info->Data = eBERSTIData_Sequence;

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExamineBERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * Reference:
 *
 *	Data == eBERSTIData_Reference
 *
 * Additional arguments:
 *
 *	- Data == eBERSTIData_Reference
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 */
void
ExamineBERType_Reference(AssignmentList_t ass, Type_t *type, BERTypeInfo_t *info)
{
    Assignment_t *a;

    info->Data = eBERSTIData_Reference;
    a = GetAssignment(ass, FindAssignment(ass, eAssignment_Type,
	type->U.Reference.Identifier, type->U.Reference.Module));
    info->SubIdentifier = GetName(a);
    info->SubType = a->U.Type.Type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\builtin.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

Type_t *Builtin_Type_Null;
Type_t *Builtin_Type_Boolean;
Type_t *Builtin_Type_Integer;
Type_t *Builtin_Type_PositiveInteger;
Type_t *Builtin_Type_ObjectIdentifier;
Type_t *Builtin_Type_ObjectDescriptor;
Type_t *Builtin_Type_Open;
Type_t *Builtin_Type_BitString;
Type_t *Builtin_Type_OctetString;
Type_t *Builtin_Type_UTF8String;
Type_t *Builtin_Type_BMPString;
Type_t *Builtin_Type_GeneralString;
Type_t *Builtin_Type_GraphicString;
Type_t *Builtin_Type_IA5String;
Type_t *Builtin_Type_ISO646String;
Type_t *Builtin_Type_NumericString;
Type_t *Builtin_Type_PrintableString;
Type_t *Builtin_Type_TeletexString;
Type_t *Builtin_Type_T61String;
Type_t *Builtin_Type_UniversalString;
Type_t *Builtin_Type_VideotexString;
Type_t *Builtin_Type_VisibleString;
Type_t *Builtin_Type_CharacterString;
Type_t *Builtin_Type_GeneralizedTime;
Type_t *Builtin_Type_UTCTime;
Type_t *Builtin_Type_Real;
Type_t *Builtin_Type_External;
Type_t *Builtin_Type_EmbeddedPdv;
Value_t *Builtin_Value_Null;
Value_t *Builtin_Value_Integer_0;
Value_t *Builtin_Value_Integer_1;
Value_t *Builtin_Value_Integer_2;
Value_t *Builtin_Value_Integer_10;
ObjectClass_t *Builtin_ObjectClass_AbstractSyntax;
ObjectClass_t *Builtin_ObjectClass_TypeIdentifier;
ModuleIdentifier_t *Builtin_Module;
AssignmentList_t Builtin_Assignments;
AssignedObjIdList_t Builtin_ObjIds;

/* create a type with a given tag */
static Type_t *
NewTaggedType(Type_e type, TagType_e tag, uint32_t val)
{
    Type_t *ty;
    Tag_t *ta;
    Value_t *va;

    ty = NewType(type);
    ty->Tags = ta = NewTag(tag);
    ta->Tag = va = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&va->U.Integer.Value, val);
    return ty;
}

/* create a type with a given permitted alphabet constraint */
/* n is the number of character ranges, the lower and upper characters */
/* of these ranges will follow in the vararg list */
static Type_t *
NewTypeWithPermittedAlphabetConstraint(Type_e type, int n, ...)
{
    va_list args;
    Type_t *ty;
    Value_t *va;
    Constraint_t **cc;
    ElementSetSpec_t *s, **ss;
    char32_t lo, up;
    int i;

    va_start(args, n);

    /* create type with permitted alphabet constraint */
    ty = NewType(type);
    cc = &ty->Constraints;
    *cc = NewConstraint();
    (*cc)->Root = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    (*cc)->Root->U.SubtypeElement.SubtypeElement =
    NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
    cc = &(*cc)->Root->U.SubtypeElement.SubtypeElement->
    U.PermittedAlphabet.Constraints;
    *cc = NewConstraint();
    ss = &(*cc)->Root;

    /* n character ranges will be needed */
    for (i = 0; i < n; i++) {

    /* get the lower and upper character of one range */
    lo = va_arg(args, char32_t);
    up = va_arg(args, char32_t);

    /* create an element set spec for this range */
    s = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    s->U.SubtypeElement.SubtypeElement =
        NewSubtypeElement(eSubtypeElement_ValueRange);
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Lower.Flags = 0;
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Lower.Value = va =
        NewValue(NULL, ty);
    va->U.RestrictedString.Value.length = 1;
    va->U.RestrictedString.Value.value =
        (char32_t *)malloc(sizeof(char32_t));
    *va->U.RestrictedString.Value.value = lo;
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Upper.Flags = 0;
    s->U.SubtypeElement.SubtypeElement->U.ValueRange.Upper.Value = va =
        NewValue(NULL, ty);
    va->U.RestrictedString.Value.length = 1;
    va->U.RestrictedString.Value.value =
        (char32_t *)malloc(sizeof(char32_t));
    *va->U.RestrictedString.Value.value = up;

    /* setup for next range or last range */
    if (i < n - 1) {
        *ss = NewElementSetSpec(eElementSetSpec_Union);
        (*ss)->U.Union.Elements1 = s;
        ss = &(*ss)->U.Union.Elements2;
    } else {
        *ss = s;
    }
    }
    return ty;
}

/* initialize internally needed builtin types, values, information object */
/* classes and object identifier components */
void
InitBuiltin()
{
    Type_t *ty;
    Component_t *co1, *co2, *co3, *co4, *co5, *co6;
    Assignment_t *a;
    AssignedObjId_t *oi0, *oi1, *oi2, *oi0_0, *oi0_1, *oi0_2, *oi0_3, *oi0_4,
    *oi1_0, *oi1_2, *oi1_3, **oi;
    String_t *s1, *s2;
    int i;
    FieldSpec_t *fs1, *fs2, *fs3;
    Constraint_t *c;
    SubtypeElement_t *s;
    SyntaxSpec_t *sy1, *sy2, *sy3, *sy4, *sy5, *sy6, *sy7, *sy8;

    /* allocate a builtin module name */
    Builtin_Assignments = NULL;
    Builtin_Module = NewModuleIdentifier();
    Builtin_Module->Identifier = "<Internal>";

    /* allocate basic ASN.1 types */
    Builtin_Type_Null = NewType(eType_Null);
    Builtin_Type_Boolean = NewType(eType_Boolean);
    Builtin_Type_Integer = NewType(eType_Integer);
    Builtin_Type_ObjectIdentifier = NewType(eType_ObjectIdentifier);
    Builtin_Type_Open = NewType(eType_Open);
    Builtin_Type_BitString = NewType(eType_BitString);
    Builtin_Type_OctetString = NewType(eType_OctetString);
    Builtin_Type_UTF8String = NewType(eType_UTF8String);
    Builtin_Type_ObjectDescriptor = NewTypeWithPermittedAlphabetConstraint(
    eType_ObjectDescriptor, 1, 0x00, 0xff);
    Builtin_Type_BMPString = NewTypeWithPermittedAlphabetConstraint(
    eType_BMPString, 1, 0x0000, 0xffff);
    Builtin_Type_GeneralString = NewTypeWithPermittedAlphabetConstraint(
    eType_GeneralString, 1, 0x00, 0xff);
    Builtin_Type_GraphicString = NewTypeWithPermittedAlphabetConstraint(
    eType_GraphicString, 1, 0x00, 0xff);
    Builtin_Type_IA5String = NewTypeWithPermittedAlphabetConstraint(
    eType_IA5String, 1, 0x00, 0x7f);
    Builtin_Type_ISO646String = NewTypeWithPermittedAlphabetConstraint(
    eType_ISO646String, 1, 0x20, 0x7e);
    Builtin_Type_NumericString = NewTypeWithPermittedAlphabetConstraint(
    eType_NumericString, 2, 0x20, 0x20, 0x30, 0x39);
    Builtin_Type_PrintableString = NewTypeWithPermittedAlphabetConstraint(
    eType_PrintableString, 7, 0x20, 0x20, 0x27, 0x29, 0x2b, 0x3a,
    0x3d, 0x3d, 0x3f, 0x3f, 0x41, 0x5a, 0x61, 0x7a);
    Builtin_Type_TeletexString = NewTypeWithPermittedAlphabetConstraint(
    eType_TeletexString, 1, 0x00, 0xff);
    Builtin_Type_T61String = NewTypeWithPermittedAlphabetConstraint(
    eType_T61String, 1, 0x00, 0xff);
    Builtin_Type_UniversalString = NewTypeWithPermittedAlphabetConstraint(
    eType_UniversalString, 1, 0x00000000, 0xffffffff);
    Builtin_Type_VideotexString = NewTypeWithPermittedAlphabetConstraint(
    eType_VideotexString, 1, 0x00, 0xff);
    Builtin_Type_VisibleString = NewTypeWithPermittedAlphabetConstraint(
    eType_VisibleString, 1, 0x20, 0x7e);
    Builtin_Type_GeneralizedTime = NewTypeWithPermittedAlphabetConstraint(
    eType_GeneralizedTime, 1, 0x20, 0x7e);
    Builtin_Type_UTCTime = NewTypeWithPermittedAlphabetConstraint(
    eType_UTCTime, 1, 0x20, 0x7e);

    /* allocate basic ASN.1 values */
    Builtin_Value_Null = NewValue(NULL, Builtin_Type_Null);
    Builtin_Value_Integer_0 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_0->U.Integer.Value, 0);
    Builtin_Value_Integer_1 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_1->U.Integer.Value, 1);
    Builtin_Value_Integer_2 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_2->U.Integer.Value, 2);
    Builtin_Value_Integer_10 = NewValue(NULL, Builtin_Type_Integer);
    intx_setuint32(&Builtin_Value_Integer_10->U.Integer.Value, 10);

    /* allocate a positive integer type */
    Builtin_Type_PositiveInteger = NewType(eType_Integer);
    Builtin_Type_PositiveInteger->Constraints = c = NewConstraint();
    c->Root = NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.SubtypeElement.SubtypeElement = s =
    NewSubtypeElement(eSubtypeElement_ValueRange);
    s->U.ValueRange.Lower.Flags = 0;
    s->U.ValueRange.Lower.Value = Builtin_Value_Integer_0;
    s->U.ValueRange.Upper.Flags = eEndPoint_Max;

#ifndef NO_BUILTIN
    /* REAL */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("mantissa", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 1);
    ty->Constraints = c = NewConstraint();
    c->Root = NewElementSetSpec(eElementSetSpec_Union);
    c->Root->U.Union.Elements1 =
    NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.Union.Elements1->U.SubtypeElement.SubtypeElement = s =
    NewSubtypeElement(eSubtypeElement_SingleValue);
    s->U.SingleValue.Value = Builtin_Value_Integer_2;
    c->Root->U.Union.Elements2 =
    NewElementSetSpec(eElementSetSpec_SubtypeElement);
    c->Root->U.Union.Elements2->U.SubtypeElement.SubtypeElement = s =
    NewSubtypeElement(eSubtypeElement_SingleValue);
    s->U.SingleValue.Value = Builtin_Value_Integer_10;
    co2->U.Normal.NamedType = NewNamedType("base", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 2);
    co3->U.Normal.NamedType = NewNamedType("exponent", ty);
    Builtin_Type_Real = NewType(eType_Real);
    Builtin_Type_Real->U.Real.Components = co1;

    /* EXTERNAL.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "<ASN1external_identification_syntaxes_t>";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "<ASN1external_identification_syntaxes_t>";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("<syntaxes>", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
    "ASN1external_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("<transfer-syntax>", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("<fixed>", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_BitString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1external_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EXTERNAL */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Optional);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1external_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_ObjectDescriptor, eTagType_Implicit, 1);
    co2->U.Optional.NamedType = NewNamedType("data-value-descriptor", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1external_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co3->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_External = NewType(eType_External);
    Builtin_Type_External->U.External.Components = co1;
    Builtin_Type_External->U.External.Optionals = 1;

    /* EMBEDDED PDV.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_syntaxes_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_identification_syntaxes_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("syntaxes", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
    "ASN1embeddedpdv_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("fixed", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_BitString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1embeddedpdv_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* EMBEDDED PDV */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1embeddedpdv_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co2->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_EmbeddedPdv = NewType(eType_EmbeddedPdv);
    Builtin_Type_EmbeddedPdv->U.EmbeddedPdv.Components = co1;

    /* CHARACTER STRING.identification.syntaxes */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("abstract", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_syntaxes_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.identification.context-negotiation */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Integer, eTagType_Implicit, 0);
    co1->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Implicit, 1);
    co2->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewType(eType_Sequence);
    ty->U.Sequence.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_context_negotiation_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.identification */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    co3 = co2->Next = NewComponent(eComponent_Normal);
    co4 = co3->Next = NewComponent(eComponent_Normal);
    co5 = co4->Next = NewComponent(eComponent_Normal);
    co6 = co5->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 0);
    ty->U.Reference.Identifier = "ASN1characterstring_identification_syntaxes_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("syntaxes", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("syntax", ty);
    ty = NewTaggedType(eType_Integer, eTagType_Explicit, 2);
    co3->U.Normal.NamedType = NewNamedType("presentation-context-id", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Explicit, 3);
    ty->U.Reference.Identifier =
    "ASN1characterstring_identification_context_negotiation_t";
    ty->U.Reference.Module = Builtin_Module;
    co4->U.Normal.NamedType = NewNamedType("context-negotiation", ty);
    ty = NewTaggedType(eType_ObjectIdentifier, eTagType_Explicit, 4);
    co5->U.Normal.NamedType = NewNamedType("transfer-syntax", ty);
    ty = NewTaggedType(eType_Null, eTagType_Explicit, 5);
    co6->U.Normal.NamedType = NewNamedType("fixed", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_identification_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING.data-value */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Open, eTagType_Explicit, 0);
    co1->U.Normal.NamedType = NewNamedType("notation", ty);
    ty = NewTaggedType(eType_OctetString, eTagType_Explicit, 1);
    co2->U.Normal.NamedType = NewNamedType("encoded", ty);
    ty = NewType(eType_Choice);
    ty->U.Choice.Components = co1;
    a = NewAssignment(eAssignment_Type);
    a->U.Type.Type = ty;
    a->Identifier = "ASN1characterstring_data_value_t";
    a->Module = Builtin_Module;
    a->Next = Builtin_Assignments;
    Builtin_Assignments = a;

    /* CHARACTER STRING */
    co1 = NewComponent(eComponent_Normal);
    co2 = co1->Next = NewComponent(eComponent_Normal);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 0);
    ty->U.Reference.Identifier = "ASN1characterstring_identification_t";
    ty->U.Reference.Module = Builtin_Module;
    co1->U.Normal.NamedType = NewNamedType("identification", ty);
    ty = NewTaggedType(eType_Reference, eTagType_Implicit, 2);
    ty->U.Reference.Identifier = "ASN1characterstring_data_value_t";
    ty->U.Reference.Module = Builtin_Module;
    co2->U.Normal.NamedType = NewNamedType("data-value", ty);
    Builtin_Type_CharacterString = NewType(eType_CharacterString);
    Builtin_Type_CharacterString->U.CharacterString.Components = co1;

    /* ABSTRACT-SYNTAX */
    fs1 = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs2 = fs1->Next = NewFieldSpec(eFieldSpec_Type);
    fs3 = fs2->Next = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs1->Identifier = "&id";
    fs1->U.FixedTypeValue.Type = Builtin_Type_ObjectIdentifier;
    fs1->U.FixedTypeValue.Unique = 1;
    fs1->U.FixedTypeValue.Optionality = NewOptionality(eOptionality_Normal);
    fs2->Identifier = "&Type";
    fs2->U.Type.Optionality = NewOptionality(eOptionality_Normal);
    fs3->U.FixedTypeValue.Type = ty = NewType(eType_BitString);
    ty->U.BitString.NamedNumbers = NewNamedNumber(eNamedNumber_Normal);
    ty->U.BitString.NamedNumbers->U.Normal.Identifier =
    "handles-invalid-encodings";
    ty->U.BitString.NamedNumbers->U.Normal.Value = Builtin_Value_Integer_0;
    fs3->U.FixedTypeValue.Optionality =
    NewOptionality(eOptionality_Default_Value);
    fs3->U.FixedTypeValue.Optionality->U.Value = NewValue(NULL, ty);
    sy1 = NewSyntaxSpec(eSyntaxSpec_Field);
    sy2 = sy1->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy3 = sy2->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy4 = sy3->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy5 = sy4->Next = NewSyntaxSpec(eSyntaxSpec_Optional);
    sy6 = sy5->U.Optional.SyntaxSpec = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy7 = sy6->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy8 = sy7->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy1->U.Field.Field = "&Type";
    sy2->U.Literal.Literal = "IDENTIFIED";
    sy3->U.Literal.Literal = "BY";
    sy4->U.Field.Field = "&id";
    sy6->U.Literal.Literal = "HAS";
    sy7->U.Literal.Literal = "PROPERTY";
    sy8->U.Field.Field = "&property";
    Builtin_ObjectClass_AbstractSyntax =
    NewObjectClass(eObjectClass_ObjectClass);
    Builtin_ObjectClass_AbstractSyntax->U.ObjectClass.FieldSpec = fs1;
    Builtin_ObjectClass_AbstractSyntax->U.ObjectClass.SyntaxSpec = sy1;

    /* TYPE-IDENTIFIER */
    fs1 = NewFieldSpec(eFieldSpec_FixedTypeValue);
    fs2 = fs1->Next = NewFieldSpec(eFieldSpec_Type);
    fs1->Identifier = "&id";
    fs1->U.FixedTypeValue.Type = Builtin_Type_ObjectIdentifier;
    fs1->U.FixedTypeValue.Unique = 1;
    fs1->U.FixedTypeValue.Optionality = NewOptionality(eOptionality_Normal);
    fs2->Identifier = "&Type";
    fs2->U.Type.Optionality = NewOptionality(eOptionality_Normal);
    sy1 = NewSyntaxSpec(eSyntaxSpec_Field);
    sy2 = sy1->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy3 = sy2->Next = NewSyntaxSpec(eSyntaxSpec_Literal);
    sy4 = sy3->Next = NewSyntaxSpec(eSyntaxSpec_Field);
    sy1->U.Field.Field = "&Type";
    sy2->U.Literal.Literal = "IDENTIFIED";
    sy3->U.Literal.Literal = "BY";
    sy4->U.Field.Field = "&id";
    Builtin_ObjectClass_TypeIdentifier =
    NewObjectClass(eObjectClass_ObjectClass);
    Builtin_ObjectClass_TypeIdentifier->U.ObjectClass.FieldSpec = fs1;
    Builtin_ObjectClass_TypeIdentifier->U.ObjectClass.SyntaxSpec = sy1;
#endif

    /* object identifiers components */

#ifndef NO_OBJID
    Builtin_ObjIds = oi0 = NewAssignedObjId();
    oi0->Next = oi1 = NewAssignedObjId();
    oi1->Next = oi2 = NewAssignedObjId();

    /* { itu-t(0) }, { ccitt(0) } */
    oi0->Number = 0;
    oi0->Names = s1 = NewString();
    s1->Next = s2 = NewString();
    s1->String = "itu-t";
    s2->String = "ccitt";

    /* { iso(1) } */
    oi1->Number = 1;
    oi1->Names = s1 = NewString();
    s1->String = "iso";

    /* { joint-iso-itu-t(2) }, { joint-iso-ccitt(2) } */
    oi2->Number = 2;
    oi2->Names = s1 = NewString();
    s1->Next = s2 = NewString();
    s1->String = "joint-iso-itu-t";
    s2->String = "joint-iso-ccitt";

    oi0->Child = oi0_0 = NewAssignedObjId();
    oi0_0->Next = oi0_1 = NewAssignedObjId();
    oi0_1->Next = oi0_2 = NewAssignedObjId();
    oi0_2->Next = oi0_3 = NewAssignedObjId();
    oi0_3->Next = oi0_4 = NewAssignedObjId();

    /* { itu-t recommendation(0) } */
    oi0_0->Number = 0;
    oi0_0->Names = s1 = NewString();
    s1->String = "recommendation";

    /* { itu-t question(1) } */
    oi0_1->Number = 1;
    oi0_1->Names = s1 = NewString();
    s1->String = "question";

    /* { itu-t administration(2) } */
    oi0_2->Number = 2;
    oi0_2->Names = s1 = NewString();
    s1->String = "administration";

    /* { itu-t network-operator(3) } */
    oi0_3->Number = 3;
    oi0_3->Names = s1 = NewString();
    s1->String = "network-operator";

    /* { itu-t identified-organization(4) } */
    oi0_4->Number = 4;
    oi0_4->Names = s1 = NewString();
    s1->String = "identified-organization";

    /* { itu-t recommendation a(1) } .. { itu-t recommendation z(26) } */
    oi = &oi0_0->Child;
    for (i = 'a'; i <= 'z'; i++) {
    *oi = NewAssignedObjId();
    (*oi)->Number = i - 'a' + 1;
    (*oi)->Names = s1 = NewString();
    s1->String = (char *)malloc(2);
    s1->String[0] = (char)i;
    s1->String[1] = 0;
    oi = &(*oi)->Next;
    }

    oi1->Child = oi1_0 = NewAssignedObjId();
    oi1_0->Next = oi1_2 = NewAssignedObjId();
    oi1_2->Next = oi1_3 = NewAssignedObjId();

    /* { iso standard(0) } */
    oi1_0->Number = 0;
    oi1_0->Names = s1 = NewString();
    s1->String = "standard";

    /* { iso member-body(2) } */
    oi1_2->Number = 2;
    oi1_2->Names = s1 = NewString();
    s1->String = "member-body";

    /* { iso identified-organization(3) } */
    oi1_3->Number = 3;
    oi1_3->Names = s1 = NewString();
    s1->String = "identified-organization";
#endif

    /* initialize ASN1-CHARACTER-MODULE */
    InitBuiltinASN1CharacterModule();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\asn1.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifndef HAS_GETOPT
extern int getopt(int argc, char **argv, const char *opts);
extern char *optarg;
extern int optind;
#endif

int pass;

/* if ForceAllTypes is set, asn1c will generate encoding functions for */
/* all types (default: only for sequence/set/choice/sequence of/set of) */
int ForceAllTypes = 0;

/* type to use for unconstrained integers/semiconstrained signed integers */
char *IntegerRestriction = "ASN1int32_t";

/* type to use for semiconstrained unsigned integers */
char *UIntegerRestriction = "ASN1uint32_t";

/* type to use for real */
char *RealRestriction = "double";

/* output language */
Language_e g_eProgramLanguage = eLanguage_C;

/* alignment of encoding */
Alignment_e Alignment = eAlignment_Aligned;

/* encoding to generate code for */
Encoding_e g_eEncodingRule = eEncoding_Packed;

/* subencoding to generate code for */
SubEncoding_e g_eSubEncodingRule = eSubEncoding_Basic;

/* target compiler supports 64 bit integers */
int Has64Bits = 0;

/* zero out allocated buffers for decoded data */
int g_fDecZeroMemory = 1;

/* debug module name */
int g_nDbgModuleName = 0;

/* source file and header file pointers */
FILE *g_finc, *g_fout;

// default tag type in this module
TagType_e g_eDefTagType = eTagType_Unknown;

/* original main module name without postfixed _Module */
char *g_pszOrigModuleName = NULL;
char *g_pszOrigModuleNameLowerCase = NULL;

/* enable long name (prefixed with module name for imported) */
int g_fLongNameForImported = 0;

// extra struct type name postfixed with _s, and its original name is its pointer type.
int g_fExtraStructPtrTypeSS = 0;

// the default structure type for Sequence Of and Set Of
TypeRules_e g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
TypeRules_e g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;

// ignore the assertion
int g_fNoAssert = 0;

// object identifier is 16-node array
int g_fOidArray = 0;

// case based optimizer switch
int g_fCaseBasedOptimizer = 1;

// enable in-file directive
int g_fMicrosoftExtensions = 1;

// all platforms: little endian (default) and big endian
int g_fAllEndians = 0;

// directive begin, end, AND
int g_chDirectiveBegin = '#';
int g_chDirectiveEnd = '#';
int g_chDirectiveAND = '&';

// postfix
char *g_pszApiPostfix = "ID";
char *g_pszChoicePostfix = "choice";
char *g_pszOptionPostfix = "option";

// option value
char *g_pszOptionValue = "option_bits";

// invisble file array
int g_cGhostFiles = 0;
GhostFile_t g_aGhostFiles[16];

int _cdecl main(int argc, char **argv)
{
    FILE *finc, *fout;
    char *p;
    int c, chInvalidDir;
    LLSTATE in, out;
    UndefinedSymbol_t *lastundef;
    Assignment_t *a, **aa;
    LLTERM *tokens;
    unsigned ntokens;
    int fSupported;
    char *psz;
    char incfilename[256], outfilename[256], module[256];

    /* parse options */
    // if an option is followed by ':', then it has a parameter.
    while ((c = getopt(argc, argv, "ab:c:d:e:fg:hil:mn:o:p:q:s:t:uv:wy")) != EOF)
    {
        chInvalidDir = 0;
        switch (c)
        {
        case 'a':

            /* enable for all platforms: little endian and big endian */
            g_fAllEndians = 1;
            break;

        case 'b':

            /* maximum number of bits of target machine */
            if (atoi(optarg) == 32) {
                Has64Bits = 0;
                break;
            }
            if (atoi(optarg) == 64) {
                Has64Bits = 1;
                break;
            }
            fprintf(stderr, "Bad number of bits specified.\n");
            MyExit(1);
            /*NOTREACHED*/

        case 'c':

            // Choice postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszChoicePostfix = psz;
            }
            break;

        case 'd':

            // sequence of and set of data structure types
            if (! stricmp(optarg, "linked") || ! stricmp(optarg, "slinked"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
            }
            else
            if (! stricmp(optarg, "lenptr"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_LengthPointer;
            }
            else
            if (! stricmp(optarg, "dlinked"))
            {
                g_eDefTypeRuleSS_NonSized = eTypeRules_DoublyLinkedList;
            }
            else
            {
                goto usage;
            }
            break;

        case 'e':

            /* encoding to generate code for */
            if (!stricmp(optarg, "packed"))
            {
                g_eEncodingRule = eEncoding_Packed;
            }
            else
            if (!stricmp(optarg, "basic"))
            {
                g_eEncodingRule = eEncoding_Basic;
            }
            else
            if (!stricmp(optarg, "per"))
            {
                g_eEncodingRule = eEncoding_Packed;
                Alignment = eAlignment_Aligned;
            }
            else
            if (!stricmp(optarg, "cer"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Canonical;
            }
            else
            if (!stricmp(optarg, "der"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Distinguished;
            }
            else
            if (!stricmp(optarg, "ber"))
            {
                g_eEncodingRule = eEncoding_Basic;
                g_eSubEncodingRule = eSubEncoding_Basic;
            }
            else
            {
                fprintf(stderr, "Bad encoding specified.\n");
                fprintf(stderr, "Allowed encodings are:\n");
                fprintf(stderr, "- packed (default)\n");
                fprintf(stderr, "- basic\n");
                MyExit(1);
                /*NOTREACHED*/
            }
            break;

        case 'f':

            /* force generation of encoding/decoding functions for all types */
            ForceAllTypes = 1;
            break;

        case 'g':

            /* ghost asn1 files */
            g_aGhostFiles[g_cGhostFiles].pszFileName = strdup(optarg);
            g_aGhostFiles[g_cGhostFiles++].pszModuleName = NULL;
            break;

        case 'h':

            goto usage;

        case 'i':

            /* ignore assertion */
            g_fNoAssert = 1;
            break;

        case 'l':

            /* set output language */
            if (!stricmp(optarg, "c")) {
                g_eProgramLanguage = eLanguage_C;
                break;
            }
            if (!stricmp(optarg, "c++") || !stricmp(optarg, "cpp")) {
                g_eProgramLanguage = eLanguage_Cpp;
                break;
            }
            goto usage;

        case 'm':

            /* enable Microsoft extension */
            g_fMicrosoftExtensions = 1;
            break;

        case 'n':

            /* debug module name */
            g_nDbgModuleName = 0;
            {
                int len = strlen(optarg);
                if (len > 4)
                    len = 4;
                memcpy(&g_nDbgModuleName, optarg, len);
            }
            break;

        case 'o':

            // Option postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszOptionPostfix = psz;
            }
            break;

        case 'p':

            // API postfix
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszApiPostfix = psz;
            }
            break;

        case 'q':

            // sequence of and set of data structure types
            if (! stricmp(optarg, "linked") || ! stricmp(optarg, "slinked"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_SinglyLinkedList;
            }
            else
            if (! stricmp(optarg, "lenptr"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_LengthPointer;
            }
            else
            if (! stricmp(optarg, "array"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;
            }
            else
            if (! stricmp(optarg, "pointer"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_PointerToElement | eTypeRules_FixedArray;
            }
            else
            if (! stricmp(optarg, "dlinked"))
            {
                g_eDefTypeRuleSS_Sized = eTypeRules_DoublyLinkedList;
            }
            else
            {
                goto usage;
            }
            break;

        case 's':

            /* set subencoding */
            if (!stricmp(optarg, "aligned"))
            {
                Alignment = eAlignment_Aligned;
            }
            else
            if (!stricmp(optarg, "unaligned"))
            {
                Alignment = eAlignment_Unaligned;
            }
            else
            if (!stricmp(optarg, "cer"))
            {
                g_eSubEncodingRule = eSubEncoding_Canonical;
            }
            else
            if (!stricmp(optarg, "der"))
            {
                g_eSubEncodingRule = eSubEncoding_Distinguished;
            }
            else
            if (!stricmp(optarg, "basic"))
            {
                g_eSubEncodingRule = eSubEncoding_Basic;
            }
            else
            {
                fprintf(stderr, "Bad sub-encoding specified.\n");
                fprintf(stderr, "Allowed sub-encodings are:\n");
                fprintf(stderr, "- aligned (default) or unaligned\n");
                fprintf(stderr, "- basic (default), cer or der\n");
                MyExit(1);
                /*NOTREACHED*/
            }
            break;

        case 't':

            /* specify type to use for unconstrained/semiconstrained types */
            p = strchr(optarg, '=');
            if (!p)
                goto usage;
            *p++ = 0;
            if (!stricmp(optarg, "integer")) {
                if (!stricmp(p, "ASN1int32_t")) {
                    IntegerRestriction = "ASN1int32_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint32_t")) {
                    IntegerRestriction = "ASN1uint32_t";
                    break;
                }
                if (!stricmp(p, "ASN1int64_t")) {
                    IntegerRestriction = "ASN1int64_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint64_t")) {
                    IntegerRestriction = "ASN1uint64_t";
                    break;
                }
                if (!stricmp(p, "ASN1intx_t")) {
                    IntegerRestriction = "ASN1intx_t";
                    break;
                }
            }
            if (!stricmp(optarg, "unsigned")) {
                if (!stricmp(p, "ASN1int32_t")) {
                    UIntegerRestriction = "ASN1int32_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint32_t")) {
                    UIntegerRestriction = "ASN1uint32_t";
                    break;
                }
                if (!stricmp(p, "ASN1int64_t")) {
                    UIntegerRestriction = "ASN1int64_t";
                    break;
                }
                if (!stricmp(p, "ASN1uint64_t")) {
                    UIntegerRestriction = "ASN1uint64_t";
                    break;
                }
                if (!stricmp(p, "ASN1intx_t")) {
                    UIntegerRestriction = "ASN1intx_t";
                    break;
                }
            }
            if (!stricmp(optarg, "real")) {
                if (!stricmp(p, "double")) {
                    RealRestriction = "double";
                    break;
                }
                if (!stricmp(p, "ASN1real_t")) {
                    RealRestriction = "ASN1real_t";
                    break;
                }
            }
            goto usage;

        case 'u':

            // no case-based optimizer
            g_fCaseBasedOptimizer = 0;
            break;

        case 'v':

            // Option value
            psz = strdup(optarg);
            if (psz && isalpha(*psz))
            {
                g_pszOptionValue = psz;
            }
            break;

        case 'w':

            // --#OID ARRAY#--
            g_fOidArray = 1;
            break;

        case 'y':

            /* enable long name (prefixed with module name for imported) */
            g_fLongNameForImported = 1;
            break;

        default:

            chInvalidDir = c;

        usage:
            fprintf(stderr,"ASN.1 Compiler V1.0\n");
            fprintf(stderr, "Copyright (C) Microsoft Corporation, U.S.A., 1997-1998. All rights reserved.\n");
            fprintf(stderr, "Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved.\n");
            if (chInvalidDir)
            {
                fprintf(stderr, "Invalid option  -%c\n", chInvalidDir);
            }
            else
            {
                fprintf(stderr, "Usage: %s [options] [imported.asn1 ...] main.asn1\n", argv[0]);
                fprintf(stderr, "Options:\n");
                fprintf(stderr, "-h\t\tthis help\n");
                fprintf(stderr, "-z\t\tzero out allocated buffers for decoded data\n");
                fprintf(stderr, "-x\t\tbridge APIs\n");
                fprintf(stderr, "-a\t\textra type definition for structure\n");
                fprintf(stderr, "-n name\t\tmodule name for debugging purpose\n");
                // fprintf(stderr, "-l language\tgenerate code for <language> (c (default), c++)\n");
                // fprintf(stderr, "-b 64\t\tenable 64 bit support\n");
                fprintf(stderr, "-e encoding\tuse <encoding> as encoding rule\n");
                fprintf(stderr,     "\t\t(possible values: packed (default), basic)\n");
                fprintf(stderr, "-s subencoding\tuse <subencoding> as subencoding rules\n");
                fprintf(stderr,     "\t\t(possible values: aligned (default) or unaligned,\n");
                fprintf(stderr,     "\t\tbasic (default), canonical or distinguished)\n");
                fprintf(stderr, "-t type=rest.\trestrict/unrestrict a unconstrained/semiconstrained type:\n");
                fprintf(stderr,     "\t\tinteger=type\tuse <type> (ASN1[u]int32_t, ASN1[u]int64_t or\n\t\t\t\tASN1intx_t) for unconstrained integers\n\t\t\t\t(default: ASN1int32_t)\n");
                fprintf(stderr,     "\t\tunsigned=type\tuse <type> (ASN1[u]int32_t, ASN1[u]int64_t or\n\t\t\t\tASN1intx_t) for positive semiconstrained\n\t\t\t\tintegers (default: ASN1uint32_t)\n");
                fprintf(stderr,     "\t\treal=type\tuse <type> (double or ASN1real_t) for\n\t\t\t\tunconstrained floating point numbers\n\t\t\t\t(default: double)\n");
            }
            MyExit(1);
        }
    }

    /* check if any modules are given */
    if (argc < optind + 1)
        goto usage;

    /* check for unsupported encoding */
    fSupported = TRUE;
    if (g_eEncodingRule == eEncoding_Packed)
    {
        if (Alignment != eAlignment_Aligned || g_eSubEncodingRule != eSubEncoding_Basic)
        {
            fSupported = FALSE;
        }
    }
    else
    if (g_eEncodingRule == eEncoding_Basic)
    {
        // if (Alignment != eAlignment_Aligned || g_eSubEncodingRule == eSubEncoding_Distinguished)
        if (Alignment != eAlignment_Aligned)
        {
            fSupported = FALSE;
        }
    }
    if (! fSupported)
    {
        fprintf(stderr, "Encoding not implemented (yet)\n");
        MyExit(1);
    }

    /* initialize */
    InitBuiltin();

    /* scan file(s) */
#if defined(LLDEBUG) && LLDEBUG > 0
    pass = 1;
    fprintf(stderr, "Pass 1: Scanning input file\n");
#endif
    readfiles(argv + optind);
    llscanner(&tokens, &ntokens);

    /* setup initial state */
    in.Assignments = Builtin_Assignments;
    in.AssignedObjIds = Builtin_ObjIds;
    in.Undefined = NULL;
    in.BadlyDefined = NULL;
    in.Module = NULL;
    in.MainModule = NULL;
    in.Imported = NULL;
    in.TagDefault = eTagType_Unknown;
    in.ExtensionDefault = eExtensionType_None;
    lastundef = NULL;

    /* parse the modules */
    do {
#if defined(LLDEBUG) && LLDEBUG > 0
        fprintf(stderr, "Pass %d: Parsing                    \n", ++pass);
#endif

        /* parse modules */
        if (!llparser(tokens, ntokens, &in, &out)) {
            llprinterror(stderr);
            MyExit(1);
        }

        /* if undefined symbols remain the same as in previous pass */
        /* than print these undefined symbols and MyExit */
        if (!CmpUndefinedSymbolList(out.Assignments, out.Undefined, lastundef))
            UndefinedError(out.Assignments, out.Undefined, out.BadlyDefined);

        /* setup data for next pass */
        in = out;
        aa = &in.Assignments;
        for (a = Builtin_Assignments; a; a = a->Next) {
            *aa = DupAssignment(a);
            aa = &(*aa)->Next;
        }
        *aa = NewAssignment(eAssignment_NextPass);
        aa = &(*aa)->Next;
        *aa = out.Assignments;
        lastundef = out.Undefined;
        in.Undefined = NULL;
        in.BadlyDefined = NULL;

        /* continue parsing until no undefined symbols left */
    } while (lastundef);

    /* build internal information */
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Pass %d: Building internal information                    \n", ++pass);
#endif
    Examination(&out.Assignments, out.MainModule);
    ExaminePER(out.Assignments);
    ExamineBER(out.Assignments);

    // remember who is the local duplicate of imported types
    for (a = out.Assignments; a; a = a->Next)
    {
        a->fImportedLocalDuplicate = IsImportedLocalDuplicate(out.Assignments, out.MainModule, a) ? 1 : 0;
    }

    /* create file names and open files */
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Pass %d: Code generation                    \n", ++pass);
#endif

    // create module name
    StripModuleName(module, argv[argc - 1]);

    // create inc file and out file names
    strcpy(incfilename, module);
    strcat(incfilename, ".h");
    strcpy(outfilename, module);
    strcat(outfilename, ".c");
    for (p = module; *p; p++)
        *p = (char)toupper(*p);
    finc = fopen(incfilename, "w");
    if (!finc) {
        perror(incfilename);
        MyExit(1);
    }
    fout = fopen(outfilename, "w");
    if (!fout) {
        perror(outfilename);
        MyExit(1);
    }

    // lonchanc: change the full path name to file name only
    {
        char *psz = strrchr(module, '\\');
        if (psz)
        {
            strcpy(module, psz+1);
        }
    }

    // save the original module names
    g_pszOrigModuleName = strdup(module);
    g_pszOrigModuleNameLowerCase = strdup(module);
    {
        char *psz;
        for (psz = g_pszOrigModuleNameLowerCase; *psz; psz++)
        {
            *psz = (char)tolower(*psz);
        }
    }

    // lonchanc: append "_Module" to module name
    strcat(module, "_Module");

    /* code generation */
    g_finc = finc;
    g_fout = fout;
    GenInc(out.Assignments, finc, module);
    GenPrg(out.Assignments, fout, module, incfilename);

    setoutfile(finc);
    output("\n#ifdef __cplusplus\n");
    outputni("} /* extern \"C\" */\n");
    output("#endif\n\n");
    output("#endif /* _%s_H_ */\n", module);
    setoutfile(fout);

    /* finitialize */
    fclose(finc);
    fclose(fout);
#if defined(LLDEBUG) && LLDEBUG > 0
    fprintf(stderr, "Finished. \n");
#endif
    return 0;
}

/* why is this function not in MS libc? */
#ifndef HAS_GETOPT
char *optarg;
int optind = 1;
static int optpos = 1;

/* get the next option from the command line arguments */
int getopt(int argc, char **argv, const char *options) {
    char *p, *q;

    optarg = NULL;

    /* find start of next option */
    do {
        if (optind >= argc)
            return EOF;
        if (*argv[optind] != '-' && *argv[optind] != '/')
            return EOF;
        p = argv[optind] + optpos++;
        if (!*p) {
            optind++;
            optpos = 1;
        }
    } while (!*p);

    /* find option in option string */
    q = strchr(options, *p);
    if (!q)
        return '?';

    /* set optarg for parameterized option and adjust optind and optpos for next call */
    if (q[1] == ':') {
        if (p[1]) {
            optarg = p + 1;
            optind++;
            optpos = 1;
        } else if (++optind < argc) {
            optarg = argv[optind];
            optind++;
            optpos = 1;
        } else {
            return '?';
        }
    }

    /* return found option */
    return *p;
}
#endif


void StripModuleName(char *pszDst, char *pszSrc)
{
    strcpy(pszDst, pszSrc);
    if (!strcmp(pszDst + strlen(pszDst) - 5, ".asn1"))
        pszDst[strlen(pszDst) - 5] = 0;
    else if (!strcmp(pszDst + strlen(pszDst) - 4, ".asn"))
        pszDst[strlen(pszDst) - 4] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\char.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


/* check if a 16 bit character is a space */
int
ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int
ASN1str16len(ASN1char16_t *p)
{
    int len;

    for (len = 0; *p; p++)
	len++;
    return len;
}

/* check if a 32 bit character is a space */
int
ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int
ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
	len++;
    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\defs.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"


/* allocate a new value of type _T, copy *_src and return this duplicate */
#define RETDUP(_T, _src) _T *ret; ret = (_T *)malloc(sizeof(_T)); *ret = *(_src); return ret

/* constructor of Assignment_t */
Assignment_t *
NewAssignment(Assignment_e type)
{
    Assignment_t *ret;

    ret = (Assignment_t *)malloc(sizeof(Assignment_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Assignment_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Module = NULL;
    // ret->Flags = 0;
    // ret->fImportedLocalDuplicate = 0;
    // ret->fGhost = 0;
    ret->eDefTagType = eTagType_Unknown;
    ret->Type = type;
    switch (type) {
    case eAssignment_Undefined:
        break;
    case eAssignment_ModuleIdentifier:
        break;
    case eAssignment_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eAssignment_Value:
        // ret->U.Value.Value = NULL;
        break;
    case eAssignment_ObjectClass:
        // ret->U.ObjectClass.ObjectClass = NULL;
        break;
    case eAssignment_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eAssignment_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    case eAssignment_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }
    return ret;
}

/* copy constructor of Assignment_t */
Assignment_t *
DupAssignment(Assignment_t *src)
{
    RETDUP(Assignment_t, src);
}

/* find an assignment by name+moduleidentifier in an assignment list */
Assignment_t *
FindAssignment(AssignmentList_t ass, Assignment_e type, char *identifier, ModuleIdentifier_t *module)
{
    Assignment_t *a;
    Assignment_e at;

    for (a = ass; a; a = a->Next) {
        if (a->Type == eAssignment_NextPass)
            continue;
        if (type == eAssignment_Undefined) {
            at = eAssignment_Undefined;
        } else {
            at = GetAssignmentType(ass, a);
        }
        if (at == type &&
            !strcmp(a->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, a->Module, module))
            return a;
    }
    return NULL;
}

/* find an exported assignment by name+moduleidentifier in an assignment list */
Assignment_t *
FindExportedAssignment(AssignmentList_t ass, Assignment_e type, char *identifier, ModuleIdentifier_t *module)
{
    Assignment_t *a;
    Assignment_e at;

    for (a = ass; a; a = a->Next) {
        if (a->Type == eAssignment_NextPass ||
            !(a->Flags & eAssignmentFlags_Exported))
            continue;
        if (type == eAssignment_Undefined) {
            at = eAssignment_Undefined;
        } else {
            at = GetAssignmentType(ass, a);
        }
        if (at == type &&
            !strcmp(a->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, a->Module, module))
            return a;
    }
    return NULL;
}

/* find an assignment by name+moduleidentifier in an assignment list */
/* do not use assignments of previous parsing passes */
Assignment_t *
FindAssignmentInCurrentPass(AssignmentList_t ass, char *identifier, ModuleIdentifier_t *module)
{
    for (; ass; ass = ass->Next) {
        if (ass->Type == eAssignment_NextPass)
            return NULL;
        if (!strcmp(ass->Identifier, identifier) &&
            !CmpModuleIdentifier(ass, ass->Module, module))
            return ass;
    }
    return NULL;
}

/* resolve assignment references */
Assignment_t *
GetAssignment(AssignmentList_t ass, Assignment_t *a)
{
    while (a && a->Type == eAssignment_Reference) {
        a = FindAssignment(ass, eAssignment_Undefined,
            a->U.Reference.Identifier, a->U.Reference.Module);
    }
    return a;
}

/* get type of an assignment */
Assignment_e
GetAssignmentType(AssignmentList_t ass, Assignment_t *a)
{
    a = GetAssignment(ass, a);
    return a ? a->Type : eAssignment_Undefined;
}

/* assign a type */
/* lhs must be an type reference */
/* returns 0 if type is already defined in current parser pass */
int
AssignType(AssignmentList_t *ass, Type_t *lhs, Type_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eType_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Type &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    // propagate the directives from rhs to lhs
    PropagatePrivateDirectives(lhs, &(rhs->PrivateDirectives));
    // create new assignment
    a = NewAssignment(eAssignment_Type);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Type.Type = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a value */
/* lhs must be an value reference */
/* returns 0 if value is already defined in current parser pass */
int
AssignValue(AssignmentList_t *ass, Value_t *lhs, Value_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Value &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Value);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Value.Value = rhs;
    ASSERT(rhs);
    if (rhs->Type && rhs->Type->Type == eType_ObjectIdentifier)
    {
        AddDefinedOID(a->Identifier, rhs);
    }
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object class */
/* lhs must be an object class reference */
/* returns 0 if object class is already defined in current parser pass */
int
AssignObjectClass(AssignmentList_t *ass, ObjectClass_t *lhs, ObjectClass_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObjectClass_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ObjectClass &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_ObjectClass);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.ObjectClass.ObjectClass = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object */
/* lhs must be an object reference */
/* returns 0 if object is already defined in current parser pass */
int
AssignObject(AssignmentList_t *ass, Object_t *lhs, Object_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObject_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Object &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Object);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Object.Object = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a object set */
/* lhs must be an object set reference */
/* returns 0 if type is already defined in current parser pass */
int
AssignObjectSet(AssignmentList_t *ass, ObjectSet_t *lhs, ObjectSet_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eObjectSet_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ObjectSet &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_ObjectSet);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.ObjectSet.ObjectSet = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* assign a macro */
/* lhs must be an macro reference */
/* returns 0 if macro is already defined in current parser pass */
int
AssignMacro(AssignmentList_t *ass, Macro_t *lhs, Macro_t *rhs)
{
    Assignment_t *a;

    if (lhs->Type != eMacro_Reference)
        MyAbort();
    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_Macro &&
            !strcmp(a->Identifier, lhs->U.Reference.Identifier) &&
            !CmpModuleIdentifier(*ass, a->Module, lhs->U.Reference.Module))
            return 0;
    }
    a = NewAssignment(eAssignment_Macro);
    a->Identifier = lhs->U.Reference.Identifier;
    a->Module = lhs->U.Reference.Module;
    a->U.Macro.Macro = rhs;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* define a module identifier */
/* returns 0 if module identifier is already defined in current parser pass */
int
AssignModuleIdentifier(AssignmentList_t *ass, ModuleIdentifier_t *module)
{
    Assignment_t *a;

    for (a = *ass; a && a->Type != eAssignment_NextPass; a = a->Next) {
        if (a->Type == eAssignment_ModuleIdentifier &&
            !CmpModuleIdentifier(*ass, a->Module, module))
            return 0;
    }
    a = NewAssignment(eAssignment_ModuleIdentifier);
    a->Identifier = "<module>";
    a->Module = module;
    a->Next = *ass;
    *ass = a;
    return 1;
}

/* constructor of UndefinedSymbol_t */
UndefinedSymbol_t *
NewUndefinedSymbol(UndefinedSymbol_e type, Assignment_e reftype)
{
    UndefinedSymbol_t *ret;

    ret = (UndefinedSymbol_t *)malloc(sizeof(UndefinedSymbol_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(UndefinedSymbol_t));
    ret->Type = type;
    ret->U.Symbol.ReferenceType = reftype;
    // ret->U.Symbol.Identifier = NULL;
    // ret->U.Symbol.Module = NULL;
    // ret->Next = NULL;
    return ret;
}

/* constructor of UndefinedSymbol_t */
UndefinedSymbol_t *
NewUndefinedField(UndefinedSymbol_e type, ObjectClass_t *oc, Settings_e reffieldtype)
{
    UndefinedSymbol_t *ret;

    if (oc->Type != eObjectClass_Reference)
        MyAbort();
    ret = (UndefinedSymbol_t *)malloc(sizeof(UndefinedSymbol_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(UndefinedSymbol_t));
    ret->Type = type;
    ret->U.Field.ReferenceFieldType = reffieldtype;
    // ret->U.Field.Identifier = NULL;
    // ret->U.Field.Module = NULL;
    ret->U.Field.ObjectClass = oc;
    // ret->Next = NULL;
    return ret;
}

/* find an undefined symbol by type/name/moduleidentifier in a list of */
/* undefined symbols */
UndefinedSymbol_t *
FindUndefinedSymbol(AssignmentList_t ass, UndefinedSymbolList_t u, Assignment_e type, char *ide, ModuleIdentifier_t *mod)
{
    for (; u; u = u->Next) {
        if (u->Type != eUndefinedSymbol_SymbolNotDefined &&
            u->Type != eUndefinedSymbol_SymbolNotExported)
            continue;
        if ((type == eAssignment_Undefined ||
            u->U.Symbol.ReferenceType == eAssignment_Undefined ||
            u->U.Symbol.ReferenceType == type) &&
            !strcmp(u->U.Symbol.Identifier, ide) &&
            !CmpModuleIdentifier(ass, u->U.Field.Module, mod))
            return u;
    }
    return NULL;
}

/* find an undefined field by type/objectclass/name/moduleidentifier in a */
/* list of undefined symbols */
UndefinedSymbol_t *
FindUndefinedField(AssignmentList_t ass, UndefinedSymbolList_t u, Settings_e fieldtype, ObjectClass_t *oc, char *ide, ModuleIdentifier_t *mod)
{
    for (; u; u = u->Next) {
        if (u->Type != eUndefinedSymbol_FieldNotDefined &&
            u->Type != eUndefinedSymbol_FieldNotExported)
            continue;
        if ((fieldtype == eSetting_Undefined ||
            u->U.Field.ReferenceFieldType == eSetting_Undefined ||
            u->U.Field.ReferenceFieldType == fieldtype) &&
            !strcmp(u->U.Field.Identifier, ide) &&
            GetObjectClass(ass, oc) ==
            GetObjectClass(ass, u->U.Field.ObjectClass) &&
            !CmpModuleIdentifier(ass, u->U.Field.Module, mod))
            return u;
    }
    return NULL;
}

/* constructor of Type_t */
Type_t *
NewType(Type_e type)
{
    Type_t *ret;

    ret = (Type_t *)malloc(sizeof(Type_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Type_t));
    ret->Type = type;
    // ret->Tags = NULL;
    // ret->AllTags = NULL;
    // ret->FirstTags = NULL;
    // ret->Constraints = NULL;
    // ret->Directives = NULL;
    // ret->Flags = 0;
    ret->Rules = eTypeRules_Normal;
    ret->TagDefault = eTagType_Unknown;
    ret->ExtensionDefault = eExtensionType_None;
    ret->PERConstraints.Value.Type = eExtension_Unconstrained;
    // ret->PERConstraints.Value.Root = NULL;
    // ret->PERConstraints.Value.Additional = NULL;
    ret->PERConstraints.Size.Type = eExtension_Unconstrained;
    // ret->PERConstraints.Size.Root = NULL;
    // ret->PERConstraints.Size.Additional = NULL;
    ret->PERConstraints.PermittedAlphabet.Type = eExtension_Unconstrained;
    // ret->PERConstraints.PermittedAlphabet.Root = NULL;
    // ret->PERConstraints.PermittedAlphabet.Additional = NULL;
    // ret->PrivateDirectives = { 0 };
    switch (type) {
    case eType_Boolean:
        break;
    case eType_Integer:
    case eType_Enumerated:
    case eType_BitString:
        // ret->U.IEB.NamedNumbers = NULL;
        break;
    case eType_OctetString:
    case eType_UTF8String:
        break;
    case eType_Null:
        break;
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_Real:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_CharacterString:
    case eType_InstanceOf:
        // ret->U.SSC.Components = NULL;
        // ret->U.SSC.Optionals = 0;
        // ret->U.SSC.Alternatives = 0;
        // ret->U.SSC.Extensions = 0;
        // ret->U.SSC.Autotag[0] = 0;
        // ret->U.SSC.Autotag[1] = 0;
        break;
    case eType_SequenceOf:
    case eType_SetOf:
        // ret->U.SS.Type = NULL;
        // ret->U.SS.Directives = NULL;
        break;
    case eType_Selection:
        // ret->U.Selection.Identifier = NULL;
        // ret->U.Selection.Type = NULL;
        break;
    case eType_ObjectIdentifier:
        break;
    case eType_BMPString:
        break;
    case eType_GeneralString:
        break;
    case eType_GraphicString:
        break;
    case eType_IA5String:
        break;
    case eType_ISO646String:
        break;
    case eType_NumericString:
        break;
    case eType_PrintableString:
        break;
    case eType_TeletexString:
        break;
    case eType_T61String:
        break;
    case eType_UniversalString:
        break;
    case eType_VideotexString:
        break;
    case eType_VisibleString:
        break;
    case eType_GeneralizedTime:
        break;
    case eType_UTCTime:
        break;
    case eType_ObjectDescriptor:
        break;
    case eType_Undefined:
        break;
    case eType_RestrictedString:
        break;
    case eType_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    case eType_FieldReference:
        // ret->U.FieldReference.ObjectClass = NULL;
        // ret->U.FieldReference.Identifier = NULL;
        break;
    case eType_Macro:
        // ret->U.Macro.Macro = NULL;
        // ret->U.Macro.LocalAssignments = NULL;
        break;
    }
    return ret;
}

/* copy constructor of Type_t */
Type_t *
DupType(Type_t *src)
{
    RETDUP(Type_t, src);
}

/* resolve field reference */
FieldSpec_t *
GetReferencedFieldSpec(AssignmentList_t ass, Type_t *type, ObjectClass_t **objectclass)
{
    FieldSpec_t *fs;
    ObjectClass_t *oc;

    if (type->Type != eType_FieldReference)
        MyAbort();
    oc = type->U.FieldReference.ObjectClass;
    oc = GetObjectClass(ass, oc);
    if (!oc)
        return NULL;
    fs = GetFieldSpec(ass, FindFieldSpec(oc->U.ObjectClass.FieldSpec,
        type->U.FieldReference.Identifier));
    if (!fs)
        return NULL;
    if (fs->Type == eFieldSpec_Object)
        oc = fs->U.Object.ObjectClass;
    else if (fs->Type == eFieldSpec_ObjectSet)
        oc = fs->U.ObjectSet.ObjectClass;
    else
        return NULL;
    if (objectclass)
        *objectclass = oc;
    return GetFieldSpec(ass, fs);
}

/* resolve type reference */
Type_t *
GetReferencedType(AssignmentList_t ass, Type_t *type)
{
    Assignment_t *a;
    FieldSpec_t *fs;

    switch (type->Type) {
    case eType_Reference:
        a = FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier,
            type->U.Reference.Module);
        a = GetAssignment(ass, a);
        if (!a)
            return NULL;
        return a->U.Type.Type;
    case eType_FieldReference:
        fs = GetReferencedFieldSpec(ass, type, NULL);
        if (!fs)
            return NULL;
        switch (fs->Type) {
        case eFieldSpec_FixedTypeValue:
            return fs->U.FixedTypeValue.Type;
        case eFieldSpec_FixedTypeValueSet:
            return fs->U.FixedTypeValueSet.Type;
        case eFieldSpec_Type:
        case eFieldSpec_VariableTypeValue:
        case eFieldSpec_VariableTypeValueSet:
            return Builtin_Type_Open;
        default:
            return NULL;
        }
        /*NOTREACHED*/
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    return NULL;
}

/* constructor of Component_t */
Component_t *
NewComponent(Components_e type)
{
    Component_t *ret;

    ret = (Component_t *)malloc(sizeof(Component_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Component_t));
    ret->Type = type;
    // ret->Next = NULL;
    switch (type) {
    case eComponent_Normal:
        // ret->U.Normal.NamedType = NULL;
        break;
    case eComponent_Optional:
        // ret->U.Optional.NamedType = NULL;
        break;
    case eComponent_Default:
        // ret->U.Default.NamedType = NULL;
        // ret->U.Default.Value = NULL;
        break;
    case eComponent_ComponentsOf:
        // ret->U.ComponentsOf.Type = NULL;
        break;
    case eComponent_ExtensionMarker:
        /*ret->U.ExtensionMarker.ExceptionSpec = NULL;*/
        break;
    }
    return ret;
}

/* copy constructor of Component_t */
Component_t *
DupComponent(Component_t *src)
{
    RETDUP(Component_t, src);
}

/* find a component by name in a list of components */
Component_t *
FindComponent(AssignmentList_t ass, ComponentList_t components, char *identifier)
{
    Component_t *c;
    NamedType_t *namedType;

    while (components) {
        switch (components->Type) {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            namedType = components->U.NOD.NamedType;
            if (namedType && !strcmp(namedType->Identifier, identifier))
                return components;
            break;
        case eComponent_ComponentsOf:
            switch (GetTypeType(ass, components->U.ComponentsOf.Type)) {
            case eType_Sequence:
            case eType_Set:
            case eType_Choice:
            case eType_External:
            case eType_EmbeddedPdv:
            case eType_CharacterString:
            case eType_Real:
            case eType_InstanceOf:
                c = FindComponent(ass,
                    GetType(ass, components->U.ComponentsOf.Type)->
                    U.SSC.Components, identifier);
                if (c)
                    return c;
                break;
            default:
                break;
            }
            break;
        }
        components = components->Next;
    }
    return NULL;
}

/* constructor of NamedType_t */
NamedType_t *
NewNamedType(char *identifier, Type_t *type)
{
    NamedType_t *ret;

    ret = (NamedType_t *)malloc(sizeof(NamedType_t));
    if (! ret)
        return NULL;

    ret->Type = type;
    ret->Identifier = identifier;
    return ret;
}

/* constructor of NamedValue_t */
NamedValue_t *
NewNamedValue(char *identifier, Value_t *value)
{
    NamedValue_t *ret;

    ret = (NamedValue_t *)malloc(sizeof(NamedValue_t));
    if (! ret)
        return NULL;

    ret->Next = NULL;
    ret->Value = value;
    ret->Identifier = identifier;
    return ret;
}

/* copy constructor of NamedValue_t */
NamedValue_t *
DupNamedValue(NamedValue_t *src)
{
    RETDUP(NamedValue_t, src);
}

/* find a named value by name in a list of named values */
NamedValue_t *
FindNamedValue(NamedValueList_t namedValues, char *identifier)
{
    for (; namedValues; namedValues = namedValues->Next) {
        if (!strcmp(namedValues->Identifier, identifier))
            return namedValues;
    }
    return NULL;
}

/* constructor of NamedNumber_t */
NamedNumber_t *
NewNamedNumber(NamedNumbers_e type)
{
    NamedNumber_t *ret;

    ret = (NamedNumber_t *)malloc(sizeof(NamedNumber_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedNumber_t));
    // ret->Next = NULL;
    ret->Type = type;
    switch (type) {
    case eNamedNumber_Normal:
        // ret->U.Normal.Identifier = NULL;
        // ret->U.Normal.Value = NULL;
        break;
    case eNamedNumber_ExtensionMarker:
        /*XXX*/
        break;
    }
    return ret;
}

/* copy constructor of NamedNumber_t */
NamedNumber_t *
DupNamedNumber(NamedNumber_t *src)
{
    RETDUP(NamedNumber_t, src);
}

/* find a named number by name in a list of named numbers */
NamedNumber_t *
FindNamedNumber(NamedNumberList_t namedNumbers, char *identifier)
{
    for (; namedNumbers; namedNumbers = namedNumbers->Next) {
        switch (namedNumbers->Type) {
        case eNamedNumber_Normal:
            if (!strcmp(namedNumbers->U.Normal.Identifier, identifier))
                return namedNumbers;
            break;
        case eNamedNumber_ExtensionMarker:
            break;
        }
    }
    return NULL;
}

/* constructor of Value_t */
Value_t *
NewValue(AssignmentList_t ass, Type_t *type)
{
    Value_t *ret;

    ret = (Value_t *)malloc(sizeof(Value_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Value_t));
    // ret->Next = NULL;
    ret->Type = type;
    if (type) {
        // ret->Flags = 0;
        switch (GetTypeType(ass, type)) {
        case eType_Boolean:
            // ret->U.Boolean.Value = 0;
            break;
        case eType_Integer:
            ret->U.Integer.Value.length = 1;
            ret->U.Integer.Value.value = (octet_t *)malloc(1);
            // ret->U.Integer.Value.value[0] = 0;
            break;
        case eType_Enumerated:
            // ret->U.Enumerated.Value = 0;
            break;
        case eType_Real:
            ret->U.Real.Value.type = eReal_Normal;
            intx_setuint32(&ret->U.Real.Value.mantissa, 0);
            intx_setuint32(&ret->U.Real.Value.exponent, 0);
            ret->U.Real.Value.base = 2;
            break;
        case eType_BitString:
            // ret->U.BitString.Value.length = 0;
            // ret->U.BitString.Value.value = NULL;
            break;
        case eType_OctetString:
        case eType_UTF8String:
            // ret->U.OctetString.Value.length = 0;
            // ret->U.OctetString.Value.value = NULL;
            break;
        case eType_Null:
            break;
        case eType_SequenceOf:
        case eType_SetOf:
            // ret->U.SS.Values = NULL;
            break;
        case eType_Sequence:
        case eType_Set:
        case eType_Choice:
        case eType_EmbeddedPdv:
        case eType_External:
        case eType_CharacterString:
        case eType_InstanceOf:
            // ret->U.SSC.NamedValues = NULL;
            break;
        case eType_Selection:
            break;
        case eType_ObjectIdentifier:
            break;
        case eType_BMPString:
            break;
        case eType_GeneralString:
            break;
        case eType_GraphicString:
            break;
        case eType_IA5String:
            break;
        case eType_ISO646String:
            break;
        case eType_NumericString:
            break;
        case eType_PrintableString:
            break;
        case eType_TeletexString:
            break;
        case eType_T61String:
            break;
        case eType_UniversalString:
            break;
        case eType_VideotexString:
            break;
        case eType_VisibleString:
            break;
        case eType_GeneralizedTime:
            break;
        case eType_UTCTime:
            break;
        case eType_ObjectDescriptor:
            break;
        case eType_Undefined:
            break;
        }
    } else {
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
    }
    return ret;
}

/* copy constructor of Value_t */
Value_t *
DupValue(Value_t *src)
{
    RETDUP(Value_t, src);
}

/* constructor of ValueSet_t */
ValueSet_t *
NewValueSet()
{
    ValueSet_t *ret;

    ret = (ValueSet_t *)malloc(sizeof(ValueSet_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ValueSet_t));
    // ret->Elements = NULL;
    return ret;
}

/* copy constructor of ValueSet_t */
ValueSet_t *
DupValueSet(ValueSet_t *src)
{
    RETDUP(ValueSet_t, src);
}

/* constructor of Macro_t */
Macro_t *
NewMacro(Macro_e type)
{
    Macro_t *ret;

    ret = (Macro_t *)malloc(sizeof(Macro_t));
    if (! ret)
        return NULL;

    ret->Type = type;
    return ret;
}

/* copy constructor of Macro_t */
Macro_t *
DupMacro(Macro_t *src)
{
    RETDUP(Macro_t, src);
}

/* constructor of MacroProduction_t */
MacroProduction_t *
NewMacroProduction(MacroProduction_e type)
{
    MacroProduction_t *ret;

    ret = (MacroProduction_t *)malloc(sizeof(MacroProduction_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(MacroProduction_t));
    ret->Type = type;
    switch (type) {
    case eMacroProduction_Alternative:
        // ret->U.Alternative.Production1 = NULL;
        // ret->U.Alternative.Production2 = NULL;
        break;
    case eMacroProduction_Sequence:
        // ret->U.Sequence.Production1 = NULL;
        // ret->U.Sequence.Production2 = NULL;
        break;
    case eMacroProduction_AString:
        // ret->U.AString.String = NULL;
        break;
    case eMacroProduction_ProductionReference:
        // ret->U.ProductionReference.Reference = NULL;
        break;
    case eMacroProduction_String:
    case eMacroProduction_Identifier:
    case eMacroProduction_Number:
    case eMacroProduction_Empty:
        break;
    case eMacroProduction_Type:
        // ret->U.Type.LocalTypeReference = NULL;
        break;
    case eMacroProduction_Value:
        // ret->U.Value.LocalTypeReference = NULL;
        // ret->U.Value.LocalValueReference = NULL;
        // ret->U.Value.Type = NULL;
        break;
    case eMacroProduction_LocalTypeAssignment:
        // ret->U.LocalTypeAssignment.LocalTypeReference = NULL;
        // ret->U.LocalTypeAssignment.Type = NULL;
        break;
    case eMacroProduction_LocalValueAssignment:
        // ret->U.LocalValueAssignment.LocalValueReference = NULL;
        // ret->U.LocalValueAssignment.Value = NULL;
        break;
    }
    return ret;
}

/* copy constructor of MacroProduction_t */
MacroProduction_t *
DupMacroProduction(MacroProduction_t *src)
{
    RETDUP(MacroProduction_t, src);
}

/* constructor of NamedMacroProduction_t */
NamedMacroProduction_t *
NewNamedMacroProduction()
{
    NamedMacroProduction_t *ret;

    ret = (NamedMacroProduction_t *)malloc(sizeof(NamedMacroProduction_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedMacroProduction_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Production = NULL;
    return ret;
}

/* copy constructor of NamedMacroProduction */
NamedMacroProduction_t *
DupNamedMacroProduction(NamedMacroProduction_t *src)
{
    RETDUP(NamedMacroProduction_t, src);
}

/* constructor of MacroLocalAssignment_t */
MacroLocalAssignment_t *
NewMacroLocalAssignment(MacroLocalAssignment_e type)
{
    MacroLocalAssignment_t *ret;

    ret = (MacroLocalAssignment_t *)malloc(sizeof(MacroLocalAssignment_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(MacroLocalAssignment_t));
    // ret->Next = NULL;
    ret->Type = type;
    // ret->Identifier = NULL;
    switch (type) {
    case eMacroLocalAssignment_Type:
        // ret->U.Type = NULL;
        break;
    case eMacroLocalAssignment_Value:
        // ret->U.Value = NULL;
        break;
    }
    return ret;
}

/* copy constructor of MacroLocalAssignment_t */
MacroLocalAssignment_t *
DupMacroLocalAssignment(MacroLocalAssignment_t *src)
{
    RETDUP(MacroLocalAssignment_t, src);
}

/* find a macrolocalassignment by name in a list of macrolocalassignments */
MacroLocalAssignment_t *
FindMacroLocalAssignment(MacroLocalAssignmentList_t la, char *ide)
{
    for (; la; la = la->Next) {
        if (!strcmp(la->Identifier, ide))
            break;
    }
    return la;
}

/* constructor of EndPoint_t */
EndPoint_t *
NewEndPoint()
{
    EndPoint_t *ret;

    ret = (EndPoint_t *)malloc(sizeof(EndPoint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(EndPoint_t));
    // ret->Flags = 0;
    // ret->Value = NULL;
    return ret;
}

/* constructor of Constraint_t */
Constraint_t *
NewConstraint()
{
    Constraint_t *ret;

    ret = (Constraint_t *)malloc(sizeof(Constraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Constraint_t));
    ret->Type = eExtension_Unextended;
    // ret->Root = NULL;
    // ret->Additional = NULL;
    return ret;
}

/* copy constructor of Constraint_t */
Constraint_t *DupConstraint(Constraint_t *src)
{
    RETDUP(Constraint_t, src);
}

/* constructor of ElementSetSpec_t */
ElementSetSpec_t *
NewElementSetSpec(ElementSetSpec_e type)
{
    ElementSetSpec_t *ret;

    ret = (ElementSetSpec_t *)malloc(sizeof(ElementSetSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ElementSetSpec_t));
    ret->Type = type;
    switch (type) {
    case eElementSetSpec_AllExcept:
        // ret->U.AllExcept.Elements = NULL;
        break;
    case eElementSetSpec_Union:
        // ret->U.Union.Elements1 = NULL;
        // ret->U.Union.Elements2 = NULL;
        break;
    case eElementSetSpec_Intersection:
        // ret->U.Intersection.Elements1 = NULL;
        // ret->U.Intersection.Elements2 = NULL;
        break;
    case eElementSetSpec_Exclusion:
        // ret->U.Exclusion.Elements1 = NULL;
        // ret->U.Exclusion.Elements2 = NULL;
        break;
    case eElementSetSpec_SubtypeElement:
        // ret->U.SubtypeElement.SubtypeElement = NULL;
        break;
    case eElementSetSpec_ObjectSetElement:
        // ret->U.ObjectSetElement.ObjectSetElement = NULL;
        break;
    default:
        MyAbort();
    }
    return ret;
}

/* constructor of SubtypeElement_t */
SubtypeElement_t *
NewSubtypeElement(SubtypeElement_e type)
{
    SubtypeElement_t *ret;

    ret = (SubtypeElement_t *)malloc(sizeof(SubtypeElement_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(SubtypeElement_t));
    ret->Type = type;
    switch (type) {
    case eSubtypeElement_ValueRange:
        ret->U.ValueRange.Lower.Flags = eEndPoint_Min;
        // ret->U.ValueRange.Lower.Value = NULL;
        ret->U.ValueRange.Upper.Flags = eEndPoint_Max;
        // ret->U.ValueRange.Upper.Value = NULL;
        break;
    case eSubtypeElement_Size:
        // ret->U.Size.Constraints = NULL;
        break;
    case eSubtypeElement_SingleValue:
        // ret->U.SingleValue.Value = NULL;
        break;
    case eSubtypeElement_PermittedAlphabet:
        // ret->U.PermittedAlphabet.Constraints = NULL;
        break;
    case eSubtypeElement_ContainedSubtype:
        // ret->U.ContainedSubtype.Type = NULL;
        break;
    case eSubtypeElement_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eSubtypeElement_SingleType:
        // ret->U.SingleType.Constraints = NULL;
        break;
    case eSubtypeElement_FullSpecification:
        // ret->U.FullSpecification.NamedConstraints = NULL;
        break;
    case eSubtypeElement_PartialSpecification:
        // ret->U.PartialSpecification.NamedConstraints = NULL;
        break;
    case eSubtypeElement_ElementSetSpec:
        // ret->U.ElementSetSpec.ElementSetSpec = NULL;
        break;
    }
    return ret;
}

/* constructor of ObjectSetElement_t */
ObjectSetElement_t *NewObjectSetElement(ObjectSetElement_e type)
{
    ObjectSetElement_t *ret;

    ret = (ObjectSetElement_t *)malloc(sizeof(ObjectSetElement_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectSetElement_t));
    ret->Type = type;
    switch (type) {
    case eObjectSetElement_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eObjectSetElement_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    case eObjectSetElement_ElementSetSpec:
        // ret->U.ElementSetSpec.ElementSetSpec = NULL;
        break;
    }
    return ret;
}

/* constructor of ValueConstraint_t */
ValueConstraint_t *
NewValueConstraint()
{
    ValueConstraint_t *ret;

    ret = (ValueConstraint_t *)malloc(sizeof(ValueConstraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ValueConstraint_t));
    // ret->Next = NULL;
    // ret->Lower.Flags = ret->Upper.Flags = 0;
    // ret->Lower.Value = ret->Upper.Value = NULL;
    return ret;
}

/* constructor of NamedConstraint_t */
NamedConstraint_t *
NewNamedConstraint()
{
    NamedConstraint_t *ret;

    ret = (NamedConstraint_t *)malloc(sizeof(NamedConstraint_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(NamedConstraint_t));
    // ret->Next = NULL;
    // ret->Identifier = NULL;
    // ret->Constraint = NULL;
    ret->Presence = ePresence_Normal;
    return ret;
}

/* constructor of Tag_t */
Tag_t *
NewTag(TagType_e type)
{
    Tag_t *tag;

    tag = (Tag_t *)malloc(sizeof(Tag_t));
    if (! tag)
        return NULL;

    memset(tag, 0, sizeof(Tag_t));
    tag->Type = type;
    tag->Class = eTagClass_Unknown;
    // tag->Tag = NULL;
    // tag->Next = NULL;
    return tag;
}

/* copy constructor of Tag_t */
Tag_t *
DupTag(Tag_t *src)
{
    RETDUP(Tag_t, src);
}

/* constructor of Directive_t */
Directive_t *
NewDirective(Directives_e type)
{
    Directive_t *ret;

    ret = (Directive_t *)malloc(sizeof(Directive_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Directive_t));
    ret->Type = type;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of Directive_t */
Directive_t *
DupDirective(Directive_t *src)
{
    RETDUP(Directive_t, src);
}

/* constructor of ModuleIdentifier_t */
ModuleIdentifier_t *
NewModuleIdentifier()
{
    ModuleIdentifier_t *ret;

    ret = (ModuleIdentifier_t *)malloc(sizeof(ModuleIdentifier_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ModuleIdentifier_t));
    // ret->Identifier = NULL;
    // ret->ObjectIdentifier = NULL;
    return ret;
}

/* constructor of ObjectClass_t */
ObjectClass_t *
NewObjectClass(ObjectClass_e type)
{
    ObjectClass_t *ret;

    ret = (ObjectClass_t *)malloc(sizeof(ObjectClass_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectClass_t));
    ret->Type = type;
    switch (type) {
    case eObjectClass_ObjectClass:
        // ret->U.ObjectClass.FieldSpec = NULL;
        // ret->U.ObjectClass.SyntaxSpec = NULL;
        break;
    case eObjectClass_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }

    return ret;
}

/* constructor of Object_t */
Object_t *
NewObject(Object_e type)
{
    Object_t *ret;

    ret = (Object_t *)malloc(sizeof(Object_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Object_t));
    ret->Type = type;
    switch (type) {
    case eObject_Object:
        // ret->U.Object.ObjectClass = NULL;
        // ret->U.Object.Settings = NULL;
        break;
    case eObject_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    }

    return ret;
}

/* constructor of ObjectSet_t */
ObjectSet_t *
NewObjectSet(ObjectSet_e type)
{
    ObjectSet_t *ret;

    ret = (ObjectSet_t *)malloc(sizeof(ObjectSet_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(ObjectSet_t));
    ret->Type = type;
    switch (type) {
    case eObjectSet_ObjectSet:
        // ret->U.ObjectSet.ObjectClass = NULL;
        // ret->U.ObjectSet.Elements = NULL;
        break;
    case eObjectSet_Reference:
        // ret->U.Reference.Identifier = NULL;
        // ret->U.Reference.Module = NULL;
        break;
    case eObjectSet_ExtensionMarker:
        // ret->U.ExtensionMarker.ObjectClass = NULL;
        // ret->U.ExtensionMarker.Elements = NULL;
        break;
    }

    return ret;
}

/* constructor of Setting_t */
Setting_t *
NewSetting(Settings_e type)
{
    Setting_t *ret;

    ret = (Setting_t *)malloc(sizeof(Setting_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Setting_t));
    ret->Type = type;
    // ret->Identifier = NULL;
    // ret->Next = NULL;
    switch (type) {
    case eSetting_Type:
        // ret->U.Type.Type = NULL;
        break;
    case eSetting_Value:
        // ret->U.Value.Value = NULL;
        break;
    case eSetting_ValueSet:
        // ret->U.ValueSet.ValueSet = NULL;
        break;
    case eSetting_Object:
        // ret->U.Object.Object = NULL;
        break;
    case eSetting_ObjectSet:
        // ret->U.ObjectSet.ObjectSet = NULL;
        break;
    }

    return ret;
}

/* copy constructor of Setting_t */
Setting_t *
DupSetting(Setting_t *src)
{
    RETDUP(Setting_t, src);
}

/* get the type of a setting */
Settings_e
GetSettingType(Setting_t *se)
{
    return se ? se->Type : eSetting_Undefined;
}

/* find a setting by name in a list of settings */
Setting_t *
FindSetting(SettingList_t se, char *identifier)
{
    for (; se; se = se->Next) {
        if (!strcmp(se->Identifier, identifier))
            return se;
    }
    return NULL;
}

/* constructor of FieldSpec_t */
FieldSpec_t *
NewFieldSpec(FieldSpecs_e type)
{
    FieldSpec_t *ret;

    ret = (FieldSpec_t *)malloc(sizeof(FieldSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(FieldSpec_t));
    ret->Type = type;
    // ret->Identifier = NULL;
    // ret->Next = NULL;
    switch (type) {
    case eFieldSpec_Type:
        // ret->U.Type.Optionality = NULL;
        break;
    case eFieldSpec_FixedTypeValue:
        // ret->U.FixedTypeValue.Type = NULL;
        // ret->U.FixedTypeValue.Unique = 0;
        // ret->U.FixedTypeValue.Optionality = NULL;
        break;
    case eFieldSpec_VariableTypeValue:
        // ret->U.VariableTypeValue.Fields = NULL;
        // ret->U.VariableTypeValue.Optionality = NULL;
        break;
    case eFieldSpec_FixedTypeValueSet:
        // ret->U.FixedTypeValueSet.Type = NULL;
        // ret->U.FixedTypeValueSet.Optionality = NULL;
        break;
    case eFieldSpec_VariableTypeValueSet:
        // ret->U.VariableTypeValueSet.Fields = NULL;
        // ret->U.VariableTypeValueSet.Optionality = NULL;
        break;
    case eFieldSpec_Object:
        // ret->U.Object.ObjectClass = NULL;
        // ret->U.Object.Optionality = NULL;
        break;
    case eFieldSpec_ObjectSet:
        // ret->U.ObjectSet.ObjectClass = NULL;
        // ret->U.ObjectSet.Optionality = NULL;
        break;
    default:
        MyAbort();
    }

    return ret;
}

/* copy constructor of FieldSpec_t */
FieldSpec_t *
DupFieldSpec(FieldSpec_t *src)
{
    RETDUP(FieldSpec_t, src);
}

/* find a fieldspec by name in a list of fieldspecs */
FieldSpec_t *
FindFieldSpec(FieldSpecList_t fs, char *identifier)
{
    if (!identifier)
        return NULL;
    for (; fs; fs = fs->Next) {
        if (!strcmp(fs->Identifier, identifier))
            return fs;
    }
    return NULL;
}

/* constructor of Optionality_t */
Optionality_t *
NewOptionality(Optionality_e type)
{
    Optionality_t *ret;

    ret = (Optionality_t *)malloc(sizeof(Optionality_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(Optionality_t));
    ret->Type = type;
    switch (type) {
    case eOptionality_Normal:
        break;
    case eOptionality_Optional:
        break;
    case eOptionality_Default_Type:
        // ret->U.Type = NULL;
        break;
    case eOptionality_Default_Value:
        // ret->U.Value = NULL;
        break;
    case eOptionality_Default_ValueSet:
        // ret->U.ValueSet = NULL;
        break;
    case eOptionality_Default_Object:
        // ret->U.Object = NULL;
        break;
    case eOptionality_Default_ObjectSet:
        // ret->U.ObjectSet = NULL;
        break;
    }

    return ret;
}

/* constructor of String_t */
String_t *
NewString()
{
    String_t *ret;

    ret = (String_t *)malloc(sizeof(String_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(String_t));
    // ret->String = NULL;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of String_t */
String_t *
DupString(String_t *src)
{
    RETDUP(String_t, src);
}

/* find a string by name in a string list */
String_t *
FindString(StringList_t list, char *string)
{
    for (; list; list = list->Next) {
        if (!strcmp(list->String, string))
            return list;
    }
    return NULL;
}

/* constructor of StringModule_t */
StringModule_t *
NewStringModule()
{
    StringModule_t *ret;

    ret = (StringModule_t *)malloc(sizeof(StringModule_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(StringModule_t));
    // ret->String = NULL;
    // ret->Module = NULL;
    // ret->Next = NULL;
    return ret;
}

/* copy constructor of StringModule_t */
StringModule_t *
DupStringModule(StringModule_t *src)
{
    RETDUP(StringModule_t, src);
}

/* find a stringmodule by name/module in a list of stringmodules */
StringModule_t *
FindStringModule(AssignmentList_t ass, StringModuleList_t list, char *string, ModuleIdentifier_t *module)
{
    for (; list; list = list->Next) {
        if (!strcmp(list->String, string) &&
            !CmpModuleIdentifier(ass, list->Module, module))
            return list;
    }
    return NULL;
}

/* constructor of SyntaxSpec_t */
SyntaxSpec_t *
NewSyntaxSpec(SyntaxSpecs_e type)
{
    SyntaxSpec_t *ret;

    ret = (SyntaxSpec_t *)malloc(sizeof(SyntaxSpec_t));
    if (! ret)
        return NULL;

    memset(ret, 0, sizeof(SyntaxSpec_t));
    // ret->Next = NULL;
    ret->Type = type;
    switch (type) {
    case eSyntaxSpec_Literal:
        // ret->U.Literal.Literal = NULL;
        break;
    case eSyntaxSpec_Field:
        // ret->U.Field.Field = NULL;
        break;
    case eSyntaxSpec_Optional:
        // ret->U.Optional.SyntaxSpec = NULL;
        break;
    }
    return ret;
}

/* copy constructor of SyntaxSpec_t */
SyntaxSpec_t *
DupSyntaxSpec(SyntaxSpec_t *src)
{
    RETDUP(SyntaxSpec_t, src);
}

/* check if a type depends on other types which would be declared later */
/* returns 1 if the type depends on a type of the unknown list and */
/* therefore has to be defined later */
/* returns 0 if the type can be defined now */
int
Depends(AssignmentList_t known, AssignmentList_t unknown, Type_t *type, Type_t *parent)
{
    Type_t *reftype;
    int isunknown = 0;

    /* no dependency if no type is referenced */
    if (type->Type != eType_Reference && type->Type != eType_FieldReference)
        return 0;

    /* get the directly referenced type */
    reftype = GetReferencedType(known, type);
    if (!reftype) {
        reftype = GetReferencedType(unknown, type);
        isunknown = 1;
    }
    if (!reftype)
        MyAbort();

    // fix intermediate pdu
    if (IsStructuredType(reftype) || IsSequenceType(reftype) || IsReferenceType(reftype))
    {
        reftype->Flags |= eTypeFlags_MiddlePDU;
    }

    /* no dependency if a structured type is referenced by use of pointer */
    /* because a 'struct XXX_s *' can be used */
    if (IsStructuredType(reftype) && (type->Rules & eTypeRules_IndirectMask))
        return 0;

    /* no dependency if a structured type is referenced in an length-pointer */
    /* type, because a 'struct XXX_s *values' can be used */
    if (IsStructuredType(reftype) && (parent->Rules & eTypeRules_LengthPointer))
        return 0;

    // special case for pointer related components
    if (! isunknown && IsStructuredType(reftype) &&
        (parent->Rules & eTypeRules_LinkedListMask))
        return 0;

    // special case for SequenceOf and SetOf because they are using Pxxx.
    if ((reftype->Type == eType_SequenceOf || reftype->Type == eType_SetOf) &&
        (reftype->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement)))
       // && (type->Rules & eTypeRules_IndirectMask))
        return 0;

    /* return true if referenced type is unknown up to now */
    return isunknown;
}

/* sort the assignments */
/* obtain an order usable by C type definitions */
void
SortAssignedTypes(AssignmentList_t *a)
{
    Assignment_t *list, *curr, *next, **prev, **last;
    int depends;
    Component_t *components;
    Type_t *type;
    int flag;
    int structured;

    /* list will contain the unordered assignments */
    list = *a;

    /* *a is the ordered list of assignments */
    *a = NULL;

    /* last will be used for appending to the list of ordered assignments */
    last = a;

    /* at first try to dump all non-structured types */
    structured = 0;

    /* we have to move all elements of the unordered assignment list into */
    /* the list of the ordered assignments */
    while (list) {

        /* flag if any assignment has been moved */
        flag = 0;

        /* examine every element in the unordered list */
        for (prev = &list, curr = list; curr; ) {

            /* flag if the current type depends on another type and */
            /* therefore cannot be moved now */
            depends = 0;

            /* only types will need dependencies */
            if (curr->Type == eAssignment_Type) {

                /* examine the current type */
                switch (curr->U.Type.Type->Type) {
                case eType_Sequence:
                case eType_Set:
                case eType_Choice:
                case eType_External:
                case eType_EmbeddedPdv:
                case eType_CharacterString:
                case eType_Real:
                case eType_InstanceOf:
                    
                    /* structured types shall not be moved in the first pass */
                    if (!structured) {
                        depends = 1;
                        break;
                    }

                    /* examine all components of the current type */
                    for (components = curr->U.Type.Type->U.SSC.Components;
                        components && !depends; components = components->Next) {

                        switch (components->Type) {
                        case eComponent_Normal:
                        case eComponent_Optional:
                        case eComponent_Default:
                            
                            /* check if the type of the component depends */
                            /* on an undefined type */
                            type = components->U.NOD.NamedType->Type;
                            depends |= Depends(*a, list, type,
                                curr->U.Type.Type);
                            break;

                        case eComponent_ComponentsOf:

                            /* components of should have been already */
                            /* resolved */
                            MyAbort();
                            /*NOTREACHED*/

                        case eComponent_ExtensionMarker:
                            break;
                        }
                    }
                    break;

                case eType_SequenceOf:
                case eType_SetOf:

                    /* structured types shall not be moved in the first pass */
                    if (!structured) {
                        depends = 1;
                        break;
                    }

                    /* check if the type of the elements depends on an */
                    /* undefined type */
                    type = curr->U.Type.Type->U.SS.Type;
                    depends |= Depends(*a, list, type, curr->U.Type.Type);
                    break;

                case eType_Reference:

                    /* check if the referenced type depends on an */
                    /* undefined type */
                    type = curr->U.Type.Type;
                    depends |= Depends(*a, list, type, curr->U.Type.Type);
                    break;
                }
            }

            /* move assignment into ordered assignment list if there's no */
            /* unresolved dependency */
            if (!depends) {
                next = curr->Next;
                *last = curr;
                curr->Next = NULL;
                last = &curr->Next;
                curr = next;
                *prev = curr;
                flag = 1;
            } else {
                prev = &curr->Next;
                curr = curr->Next;
            }
        }

        /* if no types have been moved, allow examination of structured types */
        /* if already allowed structured types, MyAbort because of cyclic */
        /* type definitions */
        if (!flag) {
            if (!structured) {
                structured = 1;
            } else {
            if (! curr || ! curr->Next)
            {
                        error(E_recursive_type_definition, NULL);
            }
            }
        }
    }
}

// --- The following is added by Microsoft ---

static const char *c_aReservedWords[] =
{
    // special for C language
    "__asm",
    "__based",
    "__cdecl",
    "__declspec",
    "__except",
    "__fastcall",
    "__finally",
    "__inline",
    "__int16",
    "__int32",
    "__int64",
    "__int8",
    "__leave",
    "__multiple_inheritance",
    "__single_inheritance",
    "__stdcall",
    "__try",
    "__uuidof",
    "__virtual_inheritance",
    "auto",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "const_cast",
    "continue",
    "default",
    "delete",
    "dllexport",
    "dllimport",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "main",
    "mutable",
    "naked",
    "namespace",
    "new",
    "operator",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_cast",
    "struct",
    "switch",
    "template",
    "this",
    "thread",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "uuid",
    "virtual",
    "void",
    "volatile",
    "while",
    "wmain",
    "xalloc"
};
int IsReservedWord ( char *psz )
{
    int cWords = sizeof(c_aReservedWords) / sizeof(c_aReservedWords[0]);
    const char **ppszWord;
    for (ppszWord = &c_aReservedWords[0]; cWords--; ppszWord++)
    {
        if (strcmp(psz, *ppszWord) == 0)
            return 1;
    }
    return 0;
}

typedef struct ConflictNameList_s
{
    struct ConflictNameList_s   *next;
    char                        *pszName;
    unsigned int                cInstances;
}   ConflictNameList_t;
static ConflictNameList_t *g_pEnumNameList = NULL;      // ENUMERATED
static ConflictNameList_t *g_pOptNameList = NULL;       // OPTIONAL
static ConflictNameList_t *g_pChoiceNameList = NULL;    // CHOICE

void KeepConflictNames ( ConflictNameList_t **ppListHead, char *pszName )
{
    ConflictNameList_t *p;
    char *psz;
    char szName[256];

    strcpy(&szName[0], pszName);
    for (psz = &szName[0]; *psz; psz++)
    {
        if (*psz == '-')
            *psz = '_';
    }

    for (p = *ppListHead; p; p = p->next)
    {
        if (strcmp(p->pszName, &szName[0]) == 0)
        {
            p->cInstances++;
            return;
        }
    }

    p = (ConflictNameList_t *) malloc(sizeof(ConflictNameList_t));
    if (p)
    {
        memset(p, 0, sizeof(ConflictNameList_t));
        p->next = *ppListHead;
        *ppListHead = p;
        p->cInstances = 1;
        p->pszName = strdup(&szName[0]);
    }
}

void KeepEnumNames ( char *pszEnumName )
{
    KeepConflictNames(&g_pEnumNameList, pszEnumName);
}
void KeepOptNames ( char *pszOptName )
{
    KeepConflictNames(&g_pOptNameList, pszOptName);
}
void KeepChoiceNames ( char *pszChoiceName )
{
    KeepConflictNames(&g_pChoiceNameList, pszChoiceName);
}

unsigned int GetConflictNameInstanceCount ( ConflictNameList_t *pListHead, char *pszName )
{
    ConflictNameList_t *p;
    for (p = pListHead; p; p = p->next)
    {
        if (strcmp(p->pszName, pszName) == 0)
        {
            return p->cInstances;
        }
    }
    return 0;
}

int DoesEnumNameConflict ( char *pszEnumName )
{
    return (GetConflictNameInstanceCount(g_pEnumNameList, pszEnumName) > 2); // counted twice
}
int DoesOptNameConflict ( char *pszOptName )
{
    return (GetConflictNameInstanceCount(g_pOptNameList, pszOptName) > 2); // counted twice
}
int DoesChoiceNameConflict ( char *pszChoiceName )
{
    return (GetConflictNameInstanceCount(g_pChoiceNameList, pszChoiceName) > 2); // counted twice
}


int IsImportedLocalDuplicate(AssignmentList_t ass, ModuleIdentifier_t *pMainModule, Assignment_t *curr)
{
    if (0 == CmpModuleIdentifier(ass, curr->Module, pMainModule))
    {
        Assignment_t *a;
        for (a = ass; a; a = a->Next)
        {
            if (a->Flags & eAssignmentFlags_LongName)
            {
                if (0 == strcmp(a->Identifier, curr->Identifier))
                {
                    if (0 != CmpModuleIdentifier(ass, a->Module, curr->Module))
                    {
                        return 1;
                    }
                }
            }
        }
    }
    return 0;
}



DefinedObjectID_t *g_pDefinedObjectIDs = NULL;

Value_t *GetDefinedOIDValue ( char *pszName )
{
    if (pszName)
    {
        DefinedObjectID_t *p;
        for (p = g_pDefinedObjectIDs; p; p = p->next)
        {
            if (strcmp(pszName, p->pszName) == 0)
            {
                return p->pValue;
            }
        }
    }
    return NULL;
}

void AddDefinedOID ( char *pszName, Value_t *pValue )
{
    // add it only when it does not exist
    if (! GetDefinedOIDValue(pszName))
    {
        DefinedObjectID_t *p;
        p = (DefinedObjectID_t *) malloc(sizeof(DefinedObjectID_t));
        if (p)
        {
            p->next = g_pDefinedObjectIDs;
            p->pszName = pszName;
            p->pValue = pValue;
            g_pDefinedObjectIDs = p;
        }
    }
}


void PropagatePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc )
{
    if (pSrc && pDst)
    {
        if (! pDst->PrivateDirectives.pszTypeName)
        {
            pDst->PrivateDirectives.pszTypeName = pSrc->pszTypeName;
        }
        if (! pDst->PrivateDirectives.pszFieldName)
        {
            pDst->PrivateDirectives.pszFieldName = pSrc->pszFieldName;
        }
        if (! pDst->PrivateDirectives.pszValueName)
        {
            pDst->PrivateDirectives.pszValueName = pSrc->pszValueName;
        }
        pDst->PrivateDirectives.fPublic |= pSrc->fPublic;
        pDst->PrivateDirectives.fIntx |= pSrc->fIntx;
        pDst->PrivateDirectives.fLenPtr |= pSrc->fLenPtr;
        pDst->PrivateDirectives.fPointer |= pSrc->fPointer;
        pDst->PrivateDirectives.fArray |= pSrc->fArray;
        pDst->PrivateDirectives.fNoCode |= pSrc->fNoCode;
        pDst->PrivateDirectives.fNoMemCopy |= pSrc->fNoMemCopy;
        pDst->PrivateDirectives.fOidPacked |= pSrc->fOidPacked;
        pDst->PrivateDirectives.fOidArray |= pSrc->fOidArray;
        pDst->PrivateDirectives.fSLinked |= pSrc->fSLinked;
        pDst->PrivateDirectives.fDLinked |= pSrc->fDLinked;
    }
}


void PropagateReferenceTypePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc )
{
    if (pSrc && pDst)
    {
        pDst->PrivateDirectives.fPublic |= pSrc->fPublic;
        pDst->PrivateDirectives.fIntx |= pSrc->fIntx;
        pDst->PrivateDirectives.fLenPtr |= pSrc->fLenPtr;
        pDst->PrivateDirectives.fPointer |= pSrc->fPointer;
        pDst->PrivateDirectives.fArray |= pSrc->fArray;
        pDst->PrivateDirectives.fNoCode |= pSrc->fNoCode;
        pDst->PrivateDirectives.fNoMemCopy |= pSrc->fNoMemCopy;
        pDst->PrivateDirectives.fOidPacked |= pSrc->fOidPacked;
        pDst->PrivateDirectives.fOidArray |= pSrc->fOidArray;
        pDst->PrivateDirectives.fSLinked |= pSrc->fSLinked;
        pDst->PrivateDirectives.fDLinked |= pSrc->fDLinked;
    }
}


char *GetPrivateValueName(PrivateDirectives_t *pPrivateDirectives, char *pszDefValueName)
{
    return pPrivateDirectives->pszValueName ? pPrivateDirectives->pszValueName : pszDefValueName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\chrmodul.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

extern char32_t chrtab[];
ModuleIdentifier_t *Builtin_Character_Module;

void
InitBuiltinASN1CharacterModule()
{
	ModuleIdentifier_t *mid;
	Assignment_t *as;
	Value_t *va;
	Type_t *ty;
	Constraint_t *co;
	ElementSetSpec_t *es, **esp;
	SubtypeElement_t *se;

	Builtin_Character_Module = mid = NewModuleIdentifier();
	mid->Identifier = "ASN1-CHARACTER-MODULE";
	mid->ObjectIdentifier = NewValue(NULL, Builtin_Type_ObjectIdentifier);
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.length = 5;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value = (objectnumber_t *)malloc(5 * sizeof(objectnumber_t));
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[0] = 2;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[1] = 1;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[2] = 0;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[3] = 0;
	mid->ObjectIdentifier->U.ObjectIdentifier.Value.value[4] = 0;
#ifndef NO_CHRMODULE
	as = NewAssignment(eAssignment_ModuleIdentifier);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "<module>";
	as->Module = mid;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "nul";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 1;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "soh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 2;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "stx";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 3;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "etx";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 4;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "eot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 5;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "enq";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 6;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ack";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 7;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "bel";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 8;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "bs";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 9;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ht";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 10;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "lf";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 11;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vt";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 12;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ff";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 13;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "cr";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 14;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "so";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 15;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "si";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 16;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dle";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 17;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc1";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 18;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc2";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 19;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc3";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 20;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dc4";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 21;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "nak";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 22;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "syn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 23;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "etb";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 24;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "can";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 25;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "em";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 26;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "sub";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 27;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "esc";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 28;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is4";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 29;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is3";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 30;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is2";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 31;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "is1";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_IA5String);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 32;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "del";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 33;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "space";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 34;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "exclamationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 35;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "quotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 36;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "numberSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 37;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "dollarSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 38;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "percentSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 39;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "ampersand";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 40;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "apostrophe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 41;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftParenthesis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 42;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightParenthesis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 43;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "asterisk";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 44;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "plusSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 45;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "comma";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 46;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "hyphen-minus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 47;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "fullStop";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 48;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "solidus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 49;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitZero";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 50;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitOne";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 51;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 52;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitThree";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 53;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitFour";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 54;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 55;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 56;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitSeven";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 57;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitEight";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 58;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "digitNine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 59;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "colon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 60;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "semicolon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 61;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "less-thanSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 62;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "equalsSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 63;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "greater-thanSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 64;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "questionMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 65;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "commercialAt";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 66;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterA";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 67;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterB";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 68;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterC";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 69;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 70;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 71;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterF";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 72;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterG";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 73;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterH";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 74;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 75;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 76;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterK";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 77;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterL";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 78;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 79;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterN";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 80;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 81;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterP";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 82;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterQ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 83;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterR";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 84;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 85;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterT";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 86;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterU";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 87;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterV";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 88;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterW";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 89;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterX";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 90;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterY";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 91;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 92;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftSquareBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 93;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "reverseSolidus";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 94;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightSquareBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 95;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "circumflexAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 96;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "lowLine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 97;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "graveAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 98;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterA";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 99;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterB";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 100;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterC";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 101;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 102;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 103;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterF";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 104;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterG";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 105;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterH";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 106;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 107;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 108;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterK";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 109;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterL";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 110;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 111;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterN";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 112;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 113;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterP";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 114;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterQ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 115;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterR";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 116;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 117;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterT";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 118;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterU";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 119;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterV";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 120;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterW";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 121;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterX";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 122;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterY";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 123;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 124;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "leftCurlyBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 125;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "verticalLine";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 126;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "rightCurlyBracket";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 127;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "tilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 33;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 127;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "BasicLatin";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 128;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "no-breakSpace";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 129;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "invertedExclamationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 130;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "centSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 131;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "poundSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 132;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "currencySign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 133;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "yenSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 134;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "brokenBar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 135;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "sectionSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 136;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "diaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 137;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "copyrightSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 138;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "feminineOrdinalIndicator";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 139;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "left-pointingDoubleAngleQuotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 140;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "notSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 141;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "softHyphen";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 142;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "registeredSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 143;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "macron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 144;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "degreeSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 145;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "plus-minusSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 146;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 147;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptThree";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 148;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "acuteAccent";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 149;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "microSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 150;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "pilcrowSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 151;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "middleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 152;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "cedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 153;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "superscriptOne";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 154;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "masculineOrdinalIndicator";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 155;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "right-pointingDoubleAngleQuotationMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 156;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vulgarFractionOneQuarter";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 157;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "vulgarFractionOneHalf";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 158;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "valgarFractionThreeQuarters";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 159;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "invertedQuestionMark";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 160;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 161;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 162;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 163;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 164;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 165;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 166;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 167;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 168;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 169;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 170;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 171;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 172;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 173;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 174;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 175;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 176;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEth";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 177;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 178;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 179;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 180;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 181;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 182;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 183;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "multiplicationSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 184;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 185;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 186;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 187;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 188;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 189;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 190;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterThorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 191;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSharpS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 192;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 193;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 194;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 195;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 196;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 197;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 198;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 199;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 200;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 201;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 202;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 203;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 204;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 205;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 206;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 207;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 208;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEth";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 209;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 210;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 211;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 212;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 213;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 214;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 215;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "divisionSign";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 216;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 217;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 218;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 219;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 220;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 221;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 222;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterThorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 223;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 128;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 223;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "Latin-1Supplement";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 224;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 225;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 226;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 227;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 228;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 229;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 230;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 231;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 232;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 233;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 234;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 235;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 236;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 237;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 238;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 239;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 240;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 241;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 242;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 243;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 244;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 245;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 246;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 247;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 248;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 249;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 250;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 251;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 252;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 253;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 254;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 255;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 256;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 257;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 258;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 259;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 260;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterHWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 261;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 262;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterHWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 263;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 264;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 265;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 266;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 267;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 268;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 269;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 270;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 271;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 272;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 273;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDotlessI";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 274;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLigatureIj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 275;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLigatureIj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 276;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterJWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 277;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 278;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 279;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 280;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKra";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 281;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 282;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 283;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 284;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 285;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 286;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 287;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithMiddleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 288;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithMiddleDot";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 289;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 290;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 291;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 292;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 293;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 294;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 295;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 296;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 297;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNPrecededByApostrophe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 298;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEng";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 299;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEng";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 300;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 301;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 302;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 303;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 304;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 305;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 306;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLigatureOe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 307;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLigatureOe";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 308;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 309;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 310;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 311;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 312;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 313;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 314;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 315;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 316;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 317;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 318;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 319;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 320;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 321;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterSWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 322;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 323;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithCedilla";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 324;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 325;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 326;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 327;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 328;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 329;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 330;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 331;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 332;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 333;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 334;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 335;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithRingAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 336;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 337;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDoubleAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 338;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 339;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 340;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterWWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 341;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterWWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 342;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 343;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithCircumflex";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 344;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithDiaeresis";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 345;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 346;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 347;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 348;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithDotAbove";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 349;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 350;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 351;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLongS";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 224;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 351;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "LatinExtended-a";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 352;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterBWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 353;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterBWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 354;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterBWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 355;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterBWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 356;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 357;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneSix";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 358;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOpenO";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 359;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterCWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 360;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterCWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 361;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAfricanD";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 362;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 363;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 364;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDWithTopbar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 365;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTurnedDelta";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 366;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterReverseE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 367;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterSchwa";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 368;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOpenE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 369;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterFWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 370;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterFWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 371;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 372;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGamma";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 373;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterHv";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 374;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIota";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 375;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 376;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 377;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 378;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLWithBar";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 379;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLambdaWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 380;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTurnedM";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 381;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithLeftHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 382;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNWithLongRightLeg";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 383;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithMiddleTilde";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 384;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 385;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 386;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOi";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 387;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOi";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 388;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterPWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 389;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterPWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 390;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterYr";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 391;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 392;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneTwo";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 393;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEsh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 394;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterReversedEshLoop";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 395;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithPalatalHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 396;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 397;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 398;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterTWithRetroflexHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 399;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 400;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithHorn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 401;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUpsilon";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 402;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterVWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 403;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterYWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 404;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterYWithHook";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 405;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterZWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 406;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterZWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 407;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzh";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 408;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzhReversed";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 409;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhReversed";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 410;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhWithTail";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 411;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterTwoWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 412;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterToneFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 413;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterToneFive";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 414;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterInvertedGlottalStopWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 415;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterWynn";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 416;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterDentalClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 417;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterLateralClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 418;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterAlveolarClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 419;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinLetterRetroflexClick";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 420;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDzWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 421;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithSmallLetterZWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 422;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDzWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 423;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 424;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterLWithSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 425;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterLj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 426;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 427;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterNWithSmallLetterJ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 428;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterNj";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 429;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 430;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 431;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 432;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 433;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 434;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 435;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 436;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 437;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 438;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 439;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 440;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 441;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 442;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 443;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDiaeresisAndGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 444;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDiaeresisAndGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 445;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterTurnedE";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 446;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 447;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDiaeresisAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 448;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDotAboveAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 449;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDotAboveAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 450;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAeWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 451;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAeWithMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 452;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 453;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithStroke";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 454;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 455;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 456;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterKWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 457;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterKWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 458;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 459;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithOgonek";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 460;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithOgonekAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 461;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithOgonekAndMacron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 462;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEzhWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 463;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEzhWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 464;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterJWithCaron";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 465;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDz";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 466;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterDWithSmallLetterZ";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 467;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterDz";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 468;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterGWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 469;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterGWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 470;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithRingAboveAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 471;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithRingAboveAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 472;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAeWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 473;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAeWithAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 474;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithStrokeAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 475;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithStrokeAndAcute";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 476;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 477;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 478;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterAWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 479;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterAWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 480;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 481;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 482;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterEWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 483;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterEWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 484;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 485;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 486;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterIWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 487;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterIWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 488;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 489;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 490;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterOWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 491;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterOWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 492;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 493;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 494;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterRWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 495;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterRWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 496;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 497;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithDoubleGrave";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 498;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinCapitalLetterUWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	va = NewValue(NULL, Builtin_Type_BMPString);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 499;
	as = NewAssignment(eAssignment_Value);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "latinSmallLetterUWithInvertedBreve";
	as->Module = mid;
	as->U.Value.Value = va;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	*esp = NewElementSetSpec(eElementSetSpec_Union);
	(*esp)->U.Union.Elements1 = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 352;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
esp = &(*esp)->U.Union.Elements2;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_ValueRange);
	se->U.ValueRange.Lower.Flags = 0;
	se->U.ValueRange.Lower.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	se->U.ValueRange.Upper.Flags = 0;
	se->U.ValueRange.Upper.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 499;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "LatinExtended-b";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
	ty = NewType(eType_BMPString);
	ty->Constraints = co = NewConstraint();
	co->Root = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	se->U.PermittedAlphabet.Constraints = co = NewConstraint();
	esp = &co->Root;
	(*esp) = es = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	es->U.SubtypeElement.SubtypeElement = se = NewSubtypeElement(eSubtypeElement_SingleValue);
	se->U.SingleValue.Value = va = NewValue(NULL, ty);
	va->U.RestrictedString.Value.length = 1;
	va->U.RestrictedString.Value.value = chrtab + 0;
	as = NewAssignment(eAssignment_Type);
	as->Flags = eAssignmentFlags_Exported | eAssignmentFlags_LongName;
	as->Identifier = "Level3";
	as->Module = mid;
	as->U.Type.Type = ty;
	as->Next = Builtin_Assignments;
	Builtin_Assignments = as;
#endif /* NO_CHRMODULE */
}

char32_t chrtab[] = {
	0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	127, 32, 33, 34, 35, 36, 37, 38,
	39, 40, 41, 42, 43, 44, 45, 46,
	47, 48, 49, 50, 51, 52, 53, 54,
	55, 56, 57, 58, 59, 60, 61, 62,
	63, 64, 65, 66, 67, 68, 69, 70,
	71, 72, 73, 74, 75, 76, 77, 78,
	79, 80, 81, 82, 83, 84, 85, 86,
	87, 88, 89, 90, 91, 92, 93, 94,
	95, 96, 97, 98, 99, 100, 101, 102,
	103, 104, 105, 106, 107, 108, 109, 110,
	111, 112, 113, 114, 115, 116, 117, 118,
	119, 120, 121, 122, 123, 124, 125, 126,
	160, 161, 162, 163, 164, 165, 166, 167,
	168, 169, 170, 171, 172, 173, 174, 175,
	176, 177, 178, 179, 180, 181, 182, 183,
	184, 185, 186, 187, 188, 189, 190, 191,
	192, 193, 194, 195, 196, 197, 198, 199,
	200, 201, 202, 203, 204, 205, 206, 207,
	208, 209, 210, 211, 212, 213, 214, 215,
	216, 217, 218, 219, 220, 221, 222, 223,
	224, 225, 226, 227, 228, 229, 230, 231,
	232, 233, 234, 235, 236, 237, 238, 239,
	240, 241, 242, 243, 244, 245, 246, 247,
	248, 249, 250, 251, 252, 253, 254, 255,
	256, 257, 258, 259, 260, 261, 262, 263,
	264, 265, 266, 267, 268, 269, 270, 271,
	272, 273, 274, 275, 276, 277, 278, 279,
	280, 281, 282, 283, 284, 285, 286, 287,
	288, 289, 290, 291, 292, 293, 294, 295,
	296, 297, 298, 299, 300, 301, 302, 303,
	304, 305, 306, 307, 308, 309, 310, 311,
	312, 313, 314, 315, 316, 317, 318, 319,
	320, 321, 322, 323, 324, 325, 326, 327,
	328, 329, 330, 331, 332, 333, 334, 335,
	336, 337, 338, 339, 340, 341, 342, 343,
	344, 345, 346, 347, 348, 349, 350, 351,
	352, 353, 354, 355, 356, 357, 358, 359,
	360, 361, 362, 363, 364, 365, 366, 367,
	368, 369, 370, 371, 372, 373, 374, 375,
	376, 377, 378, 379, 380, 381, 382, 383,
	384, 385, 386, 387, 388, 389, 390, 391,
	392, 393, 394, 395, 396, 397, 398, 399,
	400, 401, 402, 403, 404, 405, 406, 407,
	408, 409, 410, 411, 412, 413, 414, 415,
	416, 417, 418, 419, 420, 421, 422, 423,
	424, 425, 426, 427, 428, 429, 430, 431,
	432, 433, 434, 435, 436, 437, 438, 439,
	440, 441, 442, 443, 444, 445, 446, 447,
	448, 449, 450, 451, 452, 453, 454, 455,
	456, 457, 458, 459, 460, 461, 462, 463,
	464, 465, 466, 467, 468, 469, 470, 471,
	472, 473, 474, 475, 476, 477, 478, 479,
	480, 481, 482, 483, 484, 485, 486, 487,
	488, 489, 490, 491, 492, 493, 494, 495,
	496, 497, 498, 499, 500, 501, 506, 507,
	508, 509, 510, 511, 512, 513, 514, 515,
	516, 517, 518, 519, 520, 521, 522, 523,
	524, 525, 526, 527, 528, 529, 530, 531,
	532, 533, 534, 535
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\error.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"

/* MyAbort by an error message */
void
error(int errornr, LLPOS *pos)
{
    char errbuf[256];

    switch (errornr) {
    case E_systemerror:
	strcpy(errbuf, strerror(errno));
	break;
    case E_COMPONENTS_OF_in_extension:
	strcpy(errbuf, "`COMPONENTS OF' may not be used in extensions");
	break;
    case E_applied_COMPONENTS_OF_to_bad_type:
	strcpy(errbuf, "`COMPONENTS OF' must be applied to SEQUENCE/SET/CHOICE type");
	break;
    case E_COMPONENTS_OF_extended_type:
	strcpy(errbuf, "`COMPONENTS OF' can only be applied to unextended types");
	break;
    case E_bad_component_in_selectiontype:
	strcpy(errbuf, "unknown component in selection type");
	break;
    case E_selection_of_bad_type:
	strcpy(errbuf, "selection type can only be applied to SEQUENCE/SET/CHOICE types");
	break;
    case E_recursive_type_definition:
	strcpy(errbuf, "recursive type definition, introduce --<POINTER>-- to break recursion");
	break;
    case E_undefined_typereference:
	strcpy(errbuf, "undefined type reference");
	break;
    case E_unterminated_string:
	strcpy(errbuf, "unterminated string constant");
	break;
    case E_bad_character:
	strcpy(errbuf, "bad character in file");
	break;
    case E_duplicate_tag:
	strcpy(errbuf, "duplicate tag in sequence/set/choice type");
	break;
    case E_bad_directive:
	strcpy(errbuf, "directive does not fit to given type");
	break;
    case E_constraint_too_complex:
	strcpy(errbuf, "constraint is too complex");
	break;
    default:
	sprintf(errbuf, "unknown error 0x%x", errornr);
	break;
    }
    ASSERT(0);
    llerror(stderr, pos, "%s", errbuf);
    /*NOTREACHED*/
}

/* print an error message: */
/* print the file name, the line number, the line and mark the column where */
/* the error occured and terminate unsuccessful */
void
llverror(FILE *f, LLPOS *pos, char *fmt, va_list args)
{
    char *p, *q;
    int i;

    if (pos) {
	p = file;
	for (i = 1; i < pos->line; i++) {
	    p = strchr(p, '\n');
	    if (!p)
		break;
	    p++;
	}
	if (pos && pos->file)
	    fprintf(f, "File %s, line %d:\n", pos->file, pos->line);
	if (p && (q = strchr(p, '\n'))) {
	    if (q[-1] == '\r')
		q--;
	    fprintf(f, "%.*s\n", q - p, p);
	    for (i = 0; i < pos->column - 1; i++)
		putc(p[i] == '\t' ? '\t' : ' ', f);
	    fprintf(f, "^ ");
	}
    }
    vfprintf(f, fmt, args);
    putc('\n', f);
    MyExit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\error.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_ERROR_H_
#define _ASN1C_ERROR_H_

#define E_success				0
#define E_systemerror				1
#define E_COMPONENTS_OF_in_extension		2
#define E_applied_COMPONENTS_OF_to_bad_type	3
#define E_COMPONENTS_OF_extended_type		4
#define E_bad_component_in_selectiontype	5
#define E_selection_of_bad_type			6
#define E_recursive_type_definition		7
#define E_undefined_typereference		8
#define E_unterminated_string			9
#define E_bad_character				10
#define E_duplicate_tag				11
#define E_bad_directive				12
#define E_constraint_too_complex		13

void error(int errornr, LLPOS *pos);

#endif // _ASN1C_ERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\examine.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "error.h"
#include "util.h"

typedef enum {
    eNull, eSingle, eMultiple, eString
} RepresentationGroup_e;

void BuildTypeFlags(AssignmentList_t ass, Type_t *type);
Type_t *RebuildTypeWithoutSelectionType(AssignmentList_t ass, Type_t *type);

/* name the sub types of a type */
/* returns 1 if any naming has been performed */
int
NameSubType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    Type_t *subtype;
    int ret = 0;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:

	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:

		/* do not name unstructured types */
		if (!IsStructuredType(components->U.NOD.NamedType->Type))
		    break;

		/* name the type of the component and use a type */
		/* reference instead */
		strcpy(p, components->U.NOD.NamedType->Identifier);
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		AssignType(ass, subtype, components->U.NOD.NamedType->Type);
		components->U.NOD.NamedType->Type = subtype;
		if (components->Type == eComponent_Default)
		    components->U.NOD.Value->Type = subtype;
		ret = 1;
		break;
	    }
	}
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	
	/* already named? */
	if (type->U.SS.Type->Type == eType_Reference)
	    break;

	/* name the type of the elements and use a type reference instead */
	strcpy(p, type->Type == eType_SequenceOf ? "Seq" : "Set");
	n = Identifier2C(name);
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type->U.SS.Type);
	type->U.SS.Type = subtype;
	ret = 1;
	break;

    case eType_Selection:

	/* do not name unstructured types */
	if (!IsStructuredType(type->U.Selection.Type))
	    break;

	/* name the type of the selected type and use a type reference */
	/* instead */
	strcpy(p, "Sel");
	n = Identifier2C(name);
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type->U.Selection.Type);
	type->U.Selection.Type = subtype;
	ret = 1;
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the default value of a type */
/* return 1 if any naming has been performed */
int
NameValueOfType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    Value_t *subvalue;
    int ret = 0;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:

	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Default:

		/* already named? */
		if (!components->U.NOD.Value->Type)
		    break;

		/* name the value of the default component and use a value */
		/* reference instead */
		strcpy(p, components->U.NOD.NamedType->Identifier);
		strcat(p, "_default");
		n = Identifier2C(name);
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = n;
		subvalue->U.Reference.Module = module;
		AssignValue(ass, subvalue, components->U.NOD.Value);
		components->U.NOD.Value = subvalue;
		ret = 1;
		break;
	    }
	}
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the types of typefields of the settings of an object */
/* return 1 if any naming has been performed */
int
NameSettings(AssignmentList_t *ass, char *identifier, SettingList_t se, ModuleIdentifier_t *module)
{
    int ret = 0;
    char name[256], *n;
    char *p;
    Type_t *subtype;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    /* check all settings */
    for (; se; se = se->Next) {
	strcpy(p, se->Identifier + 1);
	switch (se->Type) {
	case eSetting_Type:

	    /* name field type if not already named */
	    if (se->U.Type.Type->Type != eType_Reference) {
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		ret = AssignType(ass, subtype, se->U.Type.Type);
	    }

	    /* mark field type for generation */
	    se->U.Type.Type->Flags |= eTypeFlags_GenAll;
	    break;
	}
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the default types of typefields of the field specs of an object class */
/* return 1 if any naming has been performed */
int
NameDefaultTypes(AssignmentList_t *ass, char *identifier, ObjectClass_t *oc, SettingList_t se, ModuleIdentifier_t *module)
{
    int ret = 0;
    char name[256], *n;
    char *p;
    Type_t *subtype;
    FieldSpec_t *fs;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);
    oc = GetObjectClass(*ass, oc);

    /* check all field specs */
    for (fs = oc->U.ObjectClass.FieldSpec; fs; fs = fs->Next) {
	strcpy(p, fs->Identifier + 1);
	switch (fs->Type) {
	case eFieldSpec_Type:

	    /* check if typefield has a default type */
	    if (fs->U.Type.Optionality->Type != eOptionality_Default_Type ||
	        FindSetting(se, fs->Identifier))
		break;

	    /* name field type if not already named */
	    if (fs->U.Type.Optionality->U.Type->Type != eType_Reference) {
		n = Identifier2C(name);
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = n;
		subtype->U.Reference.Module = module;
		ret = AssignType(ass, subtype, fs->U.Type.Optionality->U.Type);
	    }

	    /* mark field type for generation */
	    fs->U.Type.Optionality->U.Type->Flags |= eTypeFlags_GenAll;
	    break;
	}
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the types of type fields of an object and the default types of */
/* typefields of the field specs of an object class */
/* return 1 if any naming has been performed */
int
NameSettingsOfObject(AssignmentList_t *ass, char *identifier, Object_t *object, ModuleIdentifier_t *module)
{
    int ret = 0;

    switch (object->Type) {
    case eObject_Object:
	ret = NameSettings(ass, identifier, object->U.Object.Settings,
	    module);
	ret |= NameDefaultTypes(ass, identifier, object->U.Object.ObjectClass,
	    object->U.Object.Settings, module);
	break;
    }

    /* return 1 if any naming has been performed */
    return ret;
}

/* name the identification value of embedded pdv/character string types */
void
NameIdentificationValueOfType(AssignmentList_t *ass, char *identifier, Type_t *type, ModuleIdentifier_t *module)
{
    char name[256], *n;
    char *p;
    Component_t *components;
    NamedValue_t *namedValues;
    Value_t *subvalue;

    /* build the prefix for the subtypes */
    strcpy(name, identifier);
    strcat(name, "_");
    p = name + strlen(name);

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	
	/* check all components */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		strcpy(p, components->U.NOD.NamedType->Identifier);
		NameIdentificationValueOfType(ass, name,
		    components->U.NOD.NamedType->Type, module);
		break;
	    }
	}
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* check the subtype */
	strcpy(p, type->Type == eType_SequenceOf ? "Seq" : "Set");
	NameIdentificationValueOfType(ass, name, type->U.SS.Type, module);
	break;

    case eType_EmbeddedPdv:
    case eType_CharacterString:

	/* check if type has a fixed identification syntaxes constraint */
	namedValues = GetFixedIdentification(*ass, type->Constraints);
	if (namedValues && !strcmp(namedValues->Identifier, "syntaxes")) {

	    /* name the identification and use a value reference instead */
	    for (namedValues = namedValues->Value->U.SSC.NamedValues;
		namedValues; namedValues = namedValues->Next) {
		strcpy(p, "identification_syntaxes_");
		strcat(p, namedValues->Identifier);
		n = Identifier2C(name);
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = n;
		subvalue->U.Reference.Module = module;
		AssignValue(ass, subvalue, namedValues->Value);
	    }
	}
	break;
    }
}

/* name the type of a value */
/* returns 1 if any naming has been performed */
int
NameTypeOfValue(AssignmentList_t *ass, char *identifier, Value_t *value, ModuleIdentifier_t *module)
{
    Type_t *type;
    char name[256], *n;
    Type_t *subtype;
    int ret = 0;

    type = value->Type;

    /* do not name types of value references or unstructured types */
    if (type && IsStructuredType(type)) {

	/* build the prefix for the subtype */
	strcpy(name, identifier);
	strcat(name, "_");
	strcat(name, "Type");
	n = Identifier2C(name);

	/* name the type and use a type reference instead */
	subtype = NewType(eType_Reference);
	subtype->U.Reference.Identifier = n;
	subtype->U.Reference.Module = module;
	AssignType(ass, subtype, type);
	value->Type = subtype;
	ret = 1;
    }
    return ret;
}

/* replace any components of by the components of the referenced type */
ComponentList_t
RebuildComponentsWithoutComponentsOf(AssignmentList_t ass, ComponentList_t components)
{
    Component_t *newcomponents, *subcomponents, **pcomponents;
    Type_t *subtype;
    int ext;

    ext = 0;
    pcomponents = &newcomponents;
    for (; components; components = components->Next) {
	switch (components->Type) {
	case eComponent_ComponentsOf:

	    /* components of should not be used in an extension */
	    if (ext)
		error(E_COMPONENTS_OF_in_extension, NULL);

	    /* get the components of the referenced type */
	    subtype = GetType(ass, components->U.ComponentsOf.Type);
	    switch (subtype->Type) {
	    case eType_Sequence:
	    case eType_Set:
	    case eType_Choice:
	    case eType_External:
	    case eType_EmbeddedPdv:
	    case eType_CharacterString:
	    case eType_Real:
	    case eType_InstanceOf:
		subcomponents = subtype->U.SSC.Components;
		break;
	    default:
		error(E_applied_COMPONENTS_OF_to_bad_type, NULL);
	    }

	    /* get the real components of the referenced type */
	    /*XXX self-referencing components of types will idle forever */
	    *pcomponents = RebuildComponentsWithoutComponentsOf(ass,
		subcomponents);

	    /* find end of components of referenced type */
	    while (*pcomponents) {
		if ((*pcomponents)->Type == eComponent_ExtensionMarker)
		    error(E_COMPONENTS_OF_extended_type, NULL);
		pcomponents = &(*pcomponents)->Next;
	    }
	    break;

	case eComponent_ExtensionMarker:

	    /* copy extension marker */
	    ext = 1;
	    *pcomponents = DupComponent(components);
	    pcomponents = &(*pcomponents)->Next;
	    break;
	default:

	    /* copy other components */
	    *pcomponents = DupComponent(components);
	    pcomponents = &(*pcomponents)->Next;
	    break;
	}
    }

    /* terminate and return component list */
    *pcomponents = NULL;
    return newcomponents;
}

/* replace any components of by the components of the referenced type */
Type_t *
RebuildTypeWithoutComponentsOf(AssignmentList_t ass, Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	type->U.SSC.Components =
	    RebuildComponentsWithoutComponentsOf(ass, type->U.SSC.Components);
	break;
    }
    return type;
}

/* replace any selection type by the component of the selected type */
ComponentList_t
RebuildComponentsWithoutSelectionType(AssignmentList_t ass, ComponentList_t components)
{
    Component_t *c;

    for (c = components; c; c = c->Next) {
	switch (c->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    c->U.NOD.NamedType->Type = RebuildTypeWithoutSelectionType(
		ass, c->U.NOD.NamedType->Type);
	    break;
	}
    }
    return components;
}

/* replace any selection type by the component of the selected type */
Type_t *RebuildTypeWithoutSelectionType(AssignmentList_t ass, Type_t *type)
{
    Type_t *subtype;
    Component_t *components;

    switch (type->Type) {
    case eType_Selection:
	subtype = GetType(ass, type->U.Selection.Type);
	switch (subtype->Type) {
	case eType_Sequence:
	case eType_Set:
	case eType_Choice:
	case eType_External:
	case eType_EmbeddedPdv:
	case eType_CharacterString:
	case eType_Real:
	case eType_InstanceOf:

	    /* get the components of the referenced type */
	    components = FindComponent(ass, subtype->U.SSC.Components,
		type->U.Selection.Identifier);
	    if (!components)
		error(E_bad_component_in_selectiontype, NULL);

	    /* get the real type of the referenced type */
	    /*XXX self-referencing selection types will idle forever */
	    type = RebuildTypeWithoutSelectionType(ass,
		components->U.NOD.NamedType->Type);
	    break;
	default:
	    error(E_selection_of_bad_type, NULL);
	}
	break;

    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	type->U.SSC.Components =
	    RebuildComponentsWithoutSelectionType(ass, type->U.SSC.Components);
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	type->U.SS.Type = RebuildTypeWithoutSelectionType(ass, type->U.SS.Type);
	break;
    }
    return type;
}

/* mark a type for autotagging */
void
MarkTypeForAutotagging(AssignmentList_t ass, Type_t *type)
{
    Component_t *components;
    int ext;

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	ext = 0;

	/* set flags for autotagging */
	type->U.SSC.Autotag[0] = 1;
	type->U.SSC.Autotag[1] = 1;

	/* reset flags for autotagging if a tag has been used */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		if (GetTag(ass, components->U.NOD.NamedType->Type))
		    type->U.SSC.Autotag[ext] = 0;
		break;
	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    case eComponent_ComponentsOf:
		break;
	    }
	}
	break;
    }
}

/* autotag a marked type */
void
AutotagType(AssignmentList_t ass, Type_t *type)
{
    Component_t *components;
    Type_t *subtype;
    int ext;
    int tag;
    Tag_t *tags;

    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
	ext = 0;

	/* tag number to use */
	tag = 0;

	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = components->U.NOD.NamedType->Type;
		tags = subtype->Tags;

		/* check if type needs autotagging */
		if (!tags &&
		    type->TagDefault == eTagType_Automatic &&
		    type->U.SSC.Autotag[ext]) {

		    /* create a tagged version of the type */
		    components->U.NOD.NamedType->Type = subtype =
			DupType(subtype);

		    /* use explicit tag for choice components types and */
		    /* for open type and dummy reference, implicit tag */
		    /* otherwise */
		    if (subtype->Type == eType_Choice ||
			subtype->Type == eType_Open
			/*XXX || DummyReference*/) {
			subtype->Tags = NewTag(eTagType_Explicit);
		    } else {
			subtype->Tags = NewTag(eTagType_Implicit);
		    }
		    subtype->Tags->Tag = NewValue(NULL, Builtin_Type_Integer);
		    intx_setuint32(&subtype->Tags->Tag->U.Integer.Value,
			tag++);
		}
		break;

	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    }
	}
	break;
    }
}

/* mark constraints extendable */
void
AutoextendConstraints(Constraint_t *constraints)
{
    if (!constraints)
	return;
    if (constraints->Type == eExtension_Unextended)
	constraints->Type = eExtension_Extendable;
}

/* autoextend a type if desired */
void
AutoextendType(AssignmentList_t ass, Type_t *type)
{
    Component_t *c, **cc;
    Type_t *subtype;
    int ext;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    /* auto extending wanted? */
    if (type->ExtensionDefault != eExtensionType_Automatic)
	return;

    /* check all sub types */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:

	/* extend a sequence/set/choice type */
	ext = 0;
	for (cc = &type->U.SSC.Components, c = *cc; c;
	    c = c->Next, cc = &(*cc)->Next) {
	    *cc = DupComponent(c);
	    switch (c->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		AutoextendType(ass, subtype);
		break;
	    case eComponent_ExtensionMarker:
		ext = 1;
		break;
	    }
	}
	if (!ext) {
	    *cc = NewComponent(eComponent_ExtensionMarker);
	    cc = &(*cc)->Next;
	}
	*cc = NULL;
	break;

    case eType_SequenceOf:
    case eType_SetOf:
	subtype = type->U.SS.Type;
	AutoextendType(ass, subtype);
	break;
    }

    /* mark type as extendable */
    AutoextendConstraints(type->Constraints);
}

/* set the tag type of unspecified tags to explicit or implicit, */
/* create list of all tags (including the type's universal tag and the */
/* tags of the referenced type if applicable), */
/* and create list of first tags (esp. for choice types) */
void
BuildTags(AssignmentList_t ass, Type_t *type, TagType_e eParentDefTagType)
{
    Tag_t *t, *t2, **tt;
    Component_t *components;
    Type_t *reftype;
    Type_e te;
    uint32_t i;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    // update default tag type
	if (type->TagDefault == eTagType_Unknown &&
	    (eParentDefTagType == eTagType_Explicit || eParentDefTagType == eTagType_Implicit))
	{
		type->TagDefault = eParentDefTagType;
	}

    /* set tag type of unspecified tags to explicit or implicit */
    /* use explicit tags when: */
    /* - TagDefault indicates explicit tags, */
    /* - Type is choice/open type/dummy reference and no other explicit tag */
    /*   will follow */
    te = GetTypeType(ass, type);
	if (type->Tags)
	{
		for (tt = &type->Tags, t = type->Tags; t; tt = &(*tt)->Next, t = t->Next)
		{
			*tt = DupTag(t);
			if ((*tt)->Type == eTagType_Unknown)
			{
				for (t2 = t->Next; t2; t2 = t2->Next)
				{
				    if (t2->Type != eTagType_Implicit)
					    break;
				}
				if (type->TagDefault == eTagType_Explicit ||
				    (!t2 && (te == eType_Choice || te == eType_Open /*XXX || DummyReference*/)))
				{
				    (*tt)->Type = eTagType_Explicit;
				}
				else
				{
				    (*tt)->Type = eTagType_Implicit;
				}
			}
		}
	}

    /* copy given tags to AllTags list */
    for (tt = &type->AllTags, t = type->Tags;
         t;
	     tt = &(*tt)->Next, t = t->Next)
	{
    	*tt = DupTag(t);
    }

    /* build tags of subtypes and copy tags of reference type */
    switch (type->Type)
    {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
    	for (components = type->U.SSC.Components;
    	     components;
    	     components = components->Next)
    	{
    	    switch (components->Type)
    	    {
    	    case eComponent_Normal:
    	    case eComponent_Optional:
    	    case eComponent_Default:
    		    BuildTags(ass, components->U.NOD.NamedType->Type, type->TagDefault);
    		    break;
    	    }
    	}
    	break;
    case eType_SequenceOf:
    case eType_SetOf:
    	BuildTags(ass, type->U.SS.Type, eTagType_Unknown);
	    break;
    case eType_Reference:
    	reftype = GetReferencedType(ass, type);
    	BuildTags(ass, reftype, type->TagDefault);
    	for (t = reftype->AllTags; t; tt = &(*tt)->Next, t = t->Next)
    	{
    	    *tt = DupTag(t);
    	}
    	break;
    }

    /* add the type's universal tag to the AllTags list if the type is */
    /* not an internal type */
    if (!(type->Type & 0x8000))
    {
    	*tt = NewTag(eTagType_Implicit);
    	(*tt)->Class = eTagClass_Universal;
    	(*tt)->Tag = NewValue(NULL, Builtin_Type_Integer);
    	intx_setuint32(&(*tt)->Tag->U.Integer.Value, type->Type & 0x1f);
    }

    /* build list of FirstTags containing the possible tag values of the type */
    tt = &type->FirstTags;
    if (type->AllTags)
    {
    	/* if type has any tags, only the first tag is needed */
    	*tt = DupTag(type->AllTags);
    	tt = &(*tt)->Next;
    }
    else
    {
    	/* otherwise we have to examine the type */
    	switch (type->Type)
    	{
    	case eType_Choice:

    	    /* get the first tags of all components of a choice as FirstTags */
    	    for (components = type->U.SSC.Components;
    	         components;
    		     components = components->Next)
    		{
        		switch (components->Type)
        		{
        		case eComponent_Normal:
        		case eComponent_Optional:
        		case eComponent_Default:
        		    for (t = components->U.NOD.NamedType->Type->FirstTags;
        		         t;
        			     t = t->Next)
        			{
            			*tt = DupTag(t);
            			tt = &(*tt)->Next;
        		    }
        		    break;
        		}
    	    }
    	    break;

    	case eType_Open:

    	    /* create a list of all tags for open type */
    	    for (i = 1; i < 0x20; i++)
    	    {
        		*tt = NewTag(eTagType_Unknown);
        		(*tt)->Class = eTagClass_Unknown;
        		(*tt)->Tag = NewValue(NULL, Builtin_Type_Integer);
        		intx_setuint32(&(*tt)->Tag->U.Integer.Value, i);
        		tt = &(*tt)->Next;
    	    }
    	    break;

    	case eType_Reference:

    	    /* get the tags of the referenced type */
    	    for (t = reftype->FirstTags; t; t = t->Next)
    	    {
        		*tt = DupTag(t);
        		tt = &(*tt)->Next;
    	    }
    	    break;
    	}
    }
    *tt = NULL;
}

/* get the smallest tag of a tag list */
Tag_t *
FindSmallestTag(AssignmentList_t ass, TagList_t tags)
{
    Tag_t *mintag, *t;

    mintag = tags;
    for (t = tags->Next; t; t = t->Next) {
	if (mintag->Class > t->Class ||
	    mintag->Class == t->Class && intx_cmp(
	    &GetValue(ass, mintag->Tag)->U.Integer.Value,
	    &GetValue(ass, t->Tag)->U.Integer.Value) > 0)
	    mintag = t;
    }
    return mintag;
}

/* compare two tags by tag class and tag value */
int
CmpTags(const void *p1, const void *p2, void *ctx)
{
    Tag_t *tags1 = (Tag_t *)p1;
    Tag_t *tags2 = (Tag_t *)p2;
    Assignment_t *ass = (Assignment_t *)ctx;

    if (tags1->Class != tags2->Class)
	return tags1->Class - tags2->Class;
    return intx2uint32(&GetValue(ass, tags1->Tag)->U.Integer.Value) -
	intx2uint32(&GetValue(ass, tags2->Tag)->U.Integer.Value);
}

/* compare two components by their smallest tag */
int
CmpComponentsBySmallestTag(const void *p1, const void *p2, void *ctx)
{
    Component_t *c1 = (Component_t *)p1;
    Component_t *c2 = (Component_t *)p2;
    Assignment_t *ass = (Assignment_t *)ctx;
    Tag_t *tags1, *tags2;

    tags1 = FindSmallestTag(ass, c1->U.NOD.NamedType->Type->FirstTags);
    tags2 = FindSmallestTag(ass, c2->U.NOD.NamedType->Type->FirstTags);
    if (tags1->Class != tags2->Class)
	return tags1->Class - tags2->Class;
    return intx2uint32(&tags1->Tag->U.Integer.Value) -
	intx2uint32(&tags2->Tag->U.Integer.Value);
}

/* sort the components of a set or choice by their smallest tag */
void
SortTypeTags(AssignmentList_t ass, Type_t *type)
{
    Component_t **pcomponents, *extensions;

    switch (type->Type) {
    case eType_Set:
    case eType_Choice:
	/* remove extensions */
	for (pcomponents = &type->U.SSC.Components; *pcomponents;
	    pcomponents = &(*pcomponents)->Next) {
	    if ((*pcomponents)->Type == eComponent_ExtensionMarker)
		break;
	}
	extensions = *pcomponents;
	*pcomponents = NULL;

	/* sort extension root */
	qsortSL((void **)&type->U.SSC.Components, offsetof(Component_t, Next),
	    CmpComponentsBySmallestTag, ass);

	/* sort extensions */
	if (extensions && extensions->Next)
	    qsortSL((void **)&extensions->Next, offsetof(Component_t, Next),
		CmpComponentsBySmallestTag, ass);

	/* merge extension root and extensions */
	for (pcomponents = &type->U.SSC.Components; *pcomponents;
	    pcomponents = &(*pcomponents)->Next) {}
	*pcomponents = extensions;
	break;
    }
}

/* check if two lists of tags have common tags */
void
CheckCommonTags(AssignmentList_t ass, TagList_t tags1, TagList_t tags2)
{
    Tag_t *t1, *t2;
    int ret;

    qsortSL((void **)&tags1, offsetof(Tag_t, Next), CmpTags, ass);
    qsortSL((void **)&tags2, offsetof(Tag_t, Next), CmpTags, ass);
    for (t1 = tags1, t2 = tags2; t1 && t2; ) {
	ret = CmpTags((const void *)t1, (const void *)t2, (void *)ass);
	if (ret == 0) {
	    error(E_duplicate_tag, NULL);
	} else if (ret < 0) {
	    t1 = t1->Next;
	} else {
	    t2 = t2->Next;
	}
    }
}

/* check if a list of tags and the first tags of components have common tags */
void
CheckTagsInComponents(AssignmentList_t ass, TagList_t tags, ComponentList_t components, int untilnormal)
{
    for (; components; components = components->Next) {
	switch (components->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    CheckCommonTags(ass, tags,
		components->U.NOD.NamedType->Type->FirstTags);
	    if (untilnormal && components->Type == eComponent_Normal)
		return;
	    break;
	}
    }
}

/* check for common tags */
void
CheckTags(AssignmentList_t ass, Type_t *type)
{
    Component_t *c;
    Type_t *subtype;
    Tag_t *tag;

    switch (type->Type) {
    case eType_Sequence:

	/* check for common tags in a sequence: */
	/* the first tags of an optional/default component and the first */
	/* tags of the following components (up to and including the next */
	/* non-optional/non-default component) must not have common first */
	/* tags */
	for (c = type->U.Sequence.Components; c; c = c->Next) {
	    switch (c->Type) {
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		tag = subtype->FirstTags;
		CheckTagsInComponents(ass, tag, c->Next, 1);
		break;
	    }
	}
	break;

    case eType_Set:
    case eType_Choice:

	/* check for common tags in a set/choice: */
	/* the first tags of all components must be destinct */
	for (c = type->U.Sequence.Components; c; c = c->Next) {
	    switch (c->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		subtype = c->U.NOD.NamedType->Type;
		tag = subtype->FirstTags;
		CheckTagsInComponents(ass, tag, c->Next, 0);
		break;
	    }
	}
	break;
    }
}

/* build the list of PER-visible constraints */
void BuildConstraints(AssignmentList_t ass, Type_t *type)
{
    Type_t *reftype;
    Constraint_t *cons, *c1, *c2;
    Component_t *components;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    switch (type->Type) {
    case eType_Reference:

	/* create an intersection of the constraints of the reference type */
	/* and the constraints of the referenced type */
	reftype = GetReferencedType(ass, type);
	BuildConstraints(ass, reftype);
	c1 = reftype->Constraints;
	c2 = type->Constraints;
	if (c1) {
	    if (c2) {
		IntersectConstraints(&cons, c1, c2);
	    } else {
		cons = c1;
	    }
	} else {
	    cons = c2;
	}
	type->Constraints = cons;

	/* get the PER-visible constraints */
	GetPERConstraints(ass, cons, &type->PERConstraints);
	break;

    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:

	/* build the constraints of any component */
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		reftype = components->U.NOD.NamedType->Type;
		BuildConstraints(ass, reftype);
		break;
	    }
	}

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* build the constraints of the subtype */
	reftype = type->U.SS.Type;
	BuildConstraints(ass, reftype);

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;

    default:

	/* get the PER-visible constraints */
	GetPERConstraints(ass, type->Constraints, &type->PERConstraints);
	break;
    }
}

/* build type flags from the directives */
void BuildDirectives(AssignmentList_t ass, Type_t *type, int isComponent)
{
    int pointer = 0;
    TypeRules_e rule = 0;
    RepresentationGroup_e grp;
    int32_t noctets;
    uint32_t zero;
    Directive_t *d;
    Component_t *components;
    Type_t *reftype;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;

    /* get directive group which may be applied to the type */
    switch (type->Type)
    {
    case eType_Boolean:
    case eType_Integer:
    case eType_ObjectIdentifier:
    case eType_ObjectDescriptor:
    case eType_External:
    case eType_Real:
    case eType_Enumerated:
    case eType_EmbeddedPdv:
    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
    case eType_UTCTime:
    case eType_GeneralizedTime:
    case eType_Choice:
    case eType_BitString:
    case eType_OctetString:
        grp = eSingle;
        break;
    case eType_Reference:
        grp = eSingle;
        break;
    case eType_CharacterString:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
    case eType_UTF8String:
        grp = eString;
        /*XXX rule = zero ? eTypeRules_ZeroTerminated : eTypeRules_FixedArray;
          for upperconstrained size */
        // lonchanc: it was eTypeRules_LengthPointer
        if (type->PrivateDirectives.fLenPtr)
        {
            rule = eTypeRules_LengthPointer;
        }
        else
        if (type->PrivateDirectives.fArray)
        {
            rule = eTypeRules_FixedArray;
        }
        else
        {
            GetStringType(ass, type, &noctets, &zero);
            rule = zero ? eTypeRules_ZeroTerminated : eTypeRules_LengthPointer;
        }
        break;
    case eType_Null:
        grp = eNull;
        break;
    case eType_SequenceOf:
    case eType_SetOf:
        grp = eMultiple;
        // lonchanc: it was eTypeRules_LengthPointer
        if (type->PrivateDirectives.fSLinked)
        {
            rule = eTypeRules_SinglyLinkedList;
        }
        else
        if (type->PrivateDirectives.fLenPtr)
        {
            rule = eTypeRules_LengthPointer;
        }
        else
        if (type->PrivateDirectives.fArray)
        {
            rule = eTypeRules_FixedArray;
        }
        else
        if (type->PrivateDirectives.fPointer)
        {
            rule = eTypeRules_PointerToElement | eTypeRules_FixedArray;
        }
        else
        if (type->PrivateDirectives.fDLinked)
        {
            rule = eTypeRules_DoublyLinkedList;
        }
        else
        {
            if (eExtension_Unconstrained == type->PERConstraints.Size.Type)
            {
                rule = g_eDefTypeRuleSS_NonSized;
            }
            else
            {
                rule = g_eDefTypeRuleSS_Sized;
            }
        }
        break;
    case eType_Selection:
	MyAbort();
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort();
	/*NOTREACHED*/
    }

    /* parse list of directives */
    for (d = type->Directives; d; d = d->Next) {
	switch (d->Type) {
	case eDirective_LengthPointer:
	    if (grp != eString)
		error(E_bad_directive, NULL);
	    rule = eTypeRules_LengthPointer;
	    break;
	case eDirective_ZeroTerminated:
	    if (grp != eString)
		error(E_bad_directive, NULL);
	    rule = eTypeRules_ZeroTerminated;
	    break;
	case eDirective_Pointer:
	    if (!isComponent)
		error(E_bad_directive, NULL);
	    pointer = eTypeRules_Pointer;
	    break;
	case eDirective_NoPointer:
	    if (!isComponent)
		error(E_bad_directive, NULL);
	    pointer = 0;
	    break;
	}
    }

    /* parse list of size directives of sequence of/set of */
    if (type->Type == eType_SequenceOf || type->Type == eType_SetOf) {
	for (d = type->U.SS.Directives; d; d = d->Next) {
	    switch (d->Type) {
	    case eDirective_FixedArray:
		rule = eTypeRules_FixedArray;
		break;
	    case eDirective_DoublyLinkedList:
		rule = eTypeRules_DoublyLinkedList;
		break;
	    case eDirective_SinglyLinkedList:
		rule = eTypeRules_SinglyLinkedList;
		break;
	    case eDirective_LengthPointer:
		rule = eTypeRules_LengthPointer;
		break;
	    }
	}
    }

    /* lists are always pointered, no additional pointer needed */
    if (rule & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
	pointer = 0;

    /* set type flags according to directive rule and pointer flag */
    type->Rules = rule | pointer;

    /* build directives of subtypes */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	components = type->U.SSC.Components;
	for (; components; components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		reftype = components->U.NOD.NamedType->Type;
		BuildDirectives(ass, reftype, 1);
		break;
	    case eComponent_ExtensionMarker:
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	reftype = type->U.SS.Type;
	BuildDirectives(ass, reftype, 0);
	break;
    }
}

/* build type flags and counters for components */
/* will set eTypeFlags_Null if type has only null components */
/* will set eTypeFlags_Simple if type has only simple components */
/* will count optional/default components in the extension root (optionals) */
/* will count components in the extension root (alternatives) */
/* will count components in the extension (extensions) */
void
BuildComponentsTypeFlags(AssignmentList_t ass, ComponentList_t components, TypeFlags_e *flags, uint32_t *alternatives, uint32_t *optionals, uint32_t *extensions)
{
    int extended = 0;
    TypeFlags_e f = eTypeFlags_Null | eTypeFlags_Simple;

    while (components) {
	switch (components->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    BuildTypeFlags(ass, components->U.NOD.NamedType->Type);
	    if (!(components->U.NOD.NamedType->Type->Flags & eTypeFlags_Null))
		f &= ~eTypeFlags_Null;
	    if ((components->U.NOD.NamedType->Type->Rules &
		eTypeRules_Pointer) ||
		!(components->U.NOD.NamedType->Type->Flags & eTypeFlags_Simple))
		f &= ~eTypeFlags_Simple;
	    if (extended) {
		if (extensions)
		    (*extensions)++;
	    } else {
		if (alternatives)
		    (*alternatives)++;
		if (optionals && components->Type != eComponent_Normal)
		    (*optionals)++;
	    }
	    break;
	case eComponent_ExtensionMarker:
	    f |= eTypeFlags_ExtensionMarker;
	    extended = 1;
	    break;
	}
	components = components->Next;
    }
    *flags |= f;
}

/* build type flags and count components of sequence/set/choice types */
void
BuildTypeFlags(AssignmentList_t ass, Type_t *type)
{
    Assignment_t *a;
    Type_t *subtype;
    char *itype;
    int32_t sign;

    /* already done? */
    if (type->Flags & eTypeFlags_Done)
	return;
    type->Flags |= eTypeFlags_Done;


    switch (type->Type) {
    case eType_Null:

	/* null is null and simple */
	type->Flags |= eTypeFlags_Null | eTypeFlags_Simple;
	break;

    case eType_Boolean:
    case eType_Enumerated:

	/* boolean and enumerated are simple if no pointer is used  */
	if (!(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Integer:

	/* integer is simple if no pointer is used and no intx_t is used */
	itype = GetIntegerType(ass, type, &sign);
	if (strcmp(itype, "ASN1intx_t") && !(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Real:

	/* real is simple if no pointer is used and no real_t is used */
	itype = GetRealType(type);
	if (strcmp(itype, "ASN1real_t") && !(type->Rules & eTypeRules_Pointer))
	    type->Flags |= eTypeFlags_Simple;
	break;

    case eType_Sequence:
    case eType_Set:

	/* build type flags and counters for the components */
	BuildComponentsTypeFlags(ass, type->U.SSC.Components, &type->Flags,
	    NULL, &type->U.SSC.Optionals, &type->U.Sequence.Extensions);

	/* an extended type or a type containing optionals is not null */
	if ((type->Flags & eTypeFlags_ExtensionMarker) || type->U.SSC.Optionals)
	    type->Flags &= ~eTypeFlags_Null;
	break;

    case eType_SequenceOf:
    case eType_SetOf:

	/* never null nor simple */
    	BuildTypeFlags(ass, type->U.SS.Type);
    	break;

    case eType_Choice:

	/* build type flags and counters for the components */
	BuildComponentsTypeFlags(ass, type->U.Choice.Components, &type->Flags,
	    &type->U.Choice.Alternatives, NULL, &type->U.Choice.Extensions);

	/* a choice of nulls with more than one alternative or extensions */
	/* is not null because an offset has to be encoded */
	/* set the nullchoice flag instead */
	if ((type->Flags & eTypeFlags_Null) && 
	    ((type->Flags & eTypeFlags_ExtensionMarker) ||
	    type->U.Choice.Alternatives > 1)) {
	    type->Flags &= ~eTypeFlags_Null;
	    type->Flags |= eTypeFlags_NullChoice;
	}
	break;

    case eType_Reference:

	/* get the flags of the referenced type */
	a = FindAssignment(ass, eAssignment_Type,
	    type->U.Reference.Identifier, type->U.Reference.Module);
	a = GetAssignment(ass, a);
	subtype = a->U.Type.Type;
	BuildTypeFlags(ass, subtype);
	type->Flags = subtype->Flags;
	break;
    }
}

/* Mark non-structured types (or all types if wanted) for generation */
void MarkTypeForGeneration(AssignmentList_t ass, Type_t *type, TypeFlags_e needed)
{
    Assignment_t *a;
    Component_t *components;

    /* already done? */
    if (type->Flags & eTypeFlags_Done) {
	type->Flags |= needed;
	return;
    }
    type->Flags |= eTypeFlags_Done | needed;

    if (!IsStructuredType(GetType(ass, type)) && !ForceAllTypes) {

	/* generate type only */
	type->Flags |= eTypeFlags_GenType;
    } else {
	
	if (type->Flags & eTypeFlags_Simple) {

	    /* generate encoding/decoding/compare */
	    type->Flags |= eTypeFlags_GenSimple;
	} else {

	    /* generate encoding/decoding/free/compare */
	    type->Flags |= eTypeFlags_GenAll;
	}
    }

    /* mark subtypes for generation */
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		MarkTypeForGeneration(ass, components->U.NOD.NamedType->Type,
		    needed);
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	MarkTypeForGeneration(ass, type->U.SS.Type,
	    needed | eTypeFlags_GenCompare);
	break;
    case eType_Reference:
	a = FindAssignment(ass, eAssignment_Type,
	    type->U.Reference.Identifier, type->U.Reference.Module);
	a = GetAssignment(ass, a);
	MarkTypeForGeneration(ass, a->U.Type.Type, needed);
	break;
    }
}

/* mark a value for generation */
void
MarkValueForGeneration(AssignmentList_t ass, Value_t *value)
{

    /* already done? */
    if (value->Flags & eValueFlags_Done)
	return;
    value->Flags |= eValueFlags_GenAll | eValueFlags_Done;

    /* mark type of value for generation */
    if (value->Type)
	MarkTypeForGeneration(ass, value->Type, 0);
}

/* mark assignments for generation */
void
MarkForGeneration(AssignmentList_t ass, ModuleIdentifier_t *mainmodule, Assignment_t *a)
{
    /* builtin elements need not to be generated */
    if (!CmpModuleIdentifier(ass, a->Module, Builtin_Module) ||
        !CmpModuleIdentifier(ass, a->Module, Builtin_Character_Module))
	return;

    /* non-main module elements will require long names and are only */
    /* generated if they are referenced by elements of the main module */
    if (CmpModuleIdentifier(ass, a->Module, mainmodule)) {
	a->Flags |= eAssignmentFlags_LongName;
	return;
    }

    /* mark type/value for generation */
    switch (a->Type) {
    case eAssignment_Type:
	MarkTypeForGeneration(ass, a->U.Type.Type, 0);
	break;
    case eAssignment_Value:
	MarkValueForGeneration(ass, a->U.Value.Value);
	break;
    }
}

/* clear done flags of types */
void
ClearTypeDone(Type_t *type)
{
    Component_t *components;

    type->Flags &= ~eTypeFlags_Done;
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		ClearTypeDone(components->U.NOD.NamedType->Type);
		break;
	    }
	}
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ClearTypeDone(type->U.SS.Type);
	break;
    }
}

/* clear done flags of values */
void
ClearValueDone(Value_t *value)
{
    value->Flags &= ~eValueFlags_Done;
    if (value->Type)
	ClearTypeDone(value->Type);
}

/* clear done flags of assignments */
void
ClearDone(AssignmentList_t ass)
{
    for (; ass; ass = ass->Next) {
	switch (ass->Type) {
	case eAssignment_Type:
	    ClearTypeDone(ass->U.Type.Type);
	    break;
	case eAssignment_Value:
	    ClearValueDone(ass->U.Value.Value);
	    break;
	}
    }
}

/* examination of assignments */
void Examination(AssignmentList_t *ass, ModuleIdentifier_t *mainmodule)
{
    Assignment_t *a, *nexta, **aa;
    Type_t *subtype;
    Value_t *subvalue;
    ObjectClass_t *subobjclass;
    Object_t *subobject;
    ObjectSet_t *subobjset;
    int redo;

    /* drop results of previous passes */
    for (aa = ass; *aa;) {
	if ((*aa)->Type == eAssignment_NextPass)
	    *aa = NULL;
	else
	    aa = &(*aa)->Next;
    }

    /* reverse order of assignments to get the original order */
    for (a = *ass, *ass = NULL; a; a = nexta) {
	nexta = a->Next;
	a->Next = *ass;
	*ass = a;
    }

    /* replace references from IMPORT by corresponding type-/value-/...-refs */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Reference) {
	    a->Type = GetAssignmentType(*ass, a);
	    switch (a->Type) {
	    case eAssignment_Type:
		subtype = NewType(eType_Reference);
		subtype->U.Reference.Identifier = a->U.Reference.Identifier;
		subtype->U.Reference.Module = a->U.Reference.Module;
		a->U.Type.Type = subtype;
		break;
	    case eAssignment_Value:
		subvalue = NewValue(NULL, NULL);
		subvalue->U.Reference.Identifier = a->U.Reference.Identifier;
		subvalue->U.Reference.Module = a->U.Reference.Module;
		a->U.Value.Value = subvalue;
		break;
	    case eAssignment_ObjectClass:
		subobjclass = NewObjectClass(eObjectClass_Reference);
		subobjclass->U.Reference.Identifier = a->U.Reference.Identifier;
		subobjclass->U.Reference.Module = a->U.Reference.Module;
		a->U.ObjectClass.ObjectClass = subobjclass;
		break;
	    case eAssignment_Object:
		subobject = NewObject(eObject_Reference);
		subobject->U.Reference.Identifier = a->U.Reference.Identifier;
		subobject->U.Reference.Module = a->U.Reference.Module;
		a->U.Object.Object = subobject;
		break;
	    case eAssignment_ObjectSet:
		subobjset = NewObjectSet(eObjectSet_Reference);
		subobjset->U.Reference.Identifier = a->U.Reference.Identifier;
		subobjset->U.Reference.Module = a->U.Reference.Module;
		a->U.ObjectSet.ObjectSet = subobjset;
		break;
	    default:
		MyAbort();
	    }
	}
    }

    /* name types in types, values in types, types of values, types of objects*/
    do {
	redo = 0;
	for (a = *ass; a; a = a->Next) {
	    switch (a->Type) {
	    case eAssignment_Type:
		redo |= NameSubType(ass, Identifier2C(a->Identifier),
		    a->U.Type.Type, a->Module);
		redo |= NameValueOfType(ass, Identifier2C(a->Identifier),
		    a->U.Type.Type, a->Module);
		break;
	    case eAssignment_Value:
		redo |= NameTypeOfValue(ass, Identifier2C(a->Identifier),
		    a->U.Value.Value, a->Module);
		break;
	    case eAssignment_Object:
		redo |= NameSettingsOfObject(ass,
		    Identifier2C(a->Identifier),
		    a->U.Object.Object, a->Module);
		break;
	    }
	}
    } while (redo);

    /* name identification of embedded pdv/character strings */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    NameIdentificationValueOfType(ass, Identifier2C(a->Identifier),
		a->U.Type.Type, a->Module);
    }

    /* mark types that will be automatically tagged */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    MarkTypeForAutotagging(*ass, a->U.Type.Type);
    }

    /* replace components of by corresponding components */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    a->U.Type.Type = RebuildTypeWithoutComponentsOf(*ass,
		a->U.Type.Type);
    }

    /* replace selection types by corresponding component types */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    a->U.Type.Type = RebuildTypeWithoutSelectionType(*ass,
		a->U.Type.Type);
    }

    /* perform automatic tagging */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    AutotagType(*ass, a->U.Type.Type);
    }

    /* perform automatic extension */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    AutoextendType(*ass, a->U.Type.Type);
    }

    /* build tags of Sequence/Set/Choice/InstanceOf */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next)
	{
		if (a->Type == eAssignment_Type)
		{
			switch (a->U.Type.Type->Type)
			{
			case eType_Sequence:
			case eType_Set:
			case eType_Choice:
			case eType_InstanceOf:
				BuildTags(*ass, a->U.Type.Type, a->eDefTagType);
				break;
			}
		}
    }

    /* build tags of other types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next)
	{
		if (a->Type == eAssignment_Type)
		{
			switch (a->U.Type.Type->Type)
			{
			case eType_Sequence:
			case eType_Set:
			case eType_Choice:
			case eType_InstanceOf:
				break;
			default:
			    BuildTags(*ass, a->U.Type.Type, a->eDefTagType);
				break;
			}
		}
    }

    /* sort set and choice types by tag */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    SortTypeTags(*ass, a->U.Type.Type);
    }

    /* check for duplicate tags */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    CheckTags(*ass, a->U.Type.Type);
    }

    /* derive constraints of referenced types to referencing types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildConstraints(*ass, a->U.Type.Type);
    }

    /* derive constraints of referenced types to referencing types of values */
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Value)
	    BuildConstraints(*ass, GetValue(*ass, a->U.Value.Value)->Type);
    }

    /* examine directives of types */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildDirectives(*ass, a->U.Type.Type, 0);
    }

    /* examine types to be empty/simple/choice of nulls */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	if (a->Type == eAssignment_Type)
	    BuildTypeFlags(*ass, a->U.Type.Type);
    }

    /* mark types and values that shall be generated */
    ClearDone(*ass);
    for (a = *ass; a; a = a->Next) {
	MarkForGeneration(*ass, mainmodule, a);
    }

    /* sort assignments so that no forward references will be needed */
    SortAssignedTypes(ass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\defs.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_DEFS_H_
#define _ASN1C_DEFS_H_

typedef struct Assignment_s Assignment_t;
typedef struct UndefinedSymbol_s UndefinedSymbol_t;
typedef struct AssignedObjId_s AssignedObjId_t;
typedef struct AssignedModules_s AssignedModules_t;
typedef struct Type_s Type_t;
typedef struct Tag_s Tag_t;
typedef struct EndPoint_s EndPoint_t;
typedef struct ElementSetSpec_s ElementSetSpec_t;
typedef struct SubtypeElement_s SubtypeElement_t;
typedef struct ObjectSetElement_s ObjectSetElement_t;
typedef struct Constraint_s Constraint_t;
typedef struct NamedConstraint_s NamedConstraint_t;
typedef struct PERConstraint_s PERConstraint_t;
typedef struct PERConstraints_s PERConstraints_t;
typedef struct ValueConstraint_s ValueConstraint_t;
typedef struct NamedNumber_s NamedNumber_t;
typedef struct NamedType_s NamedType_t;
typedef struct NamedValue_s NamedValue_t;
typedef struct Component_s Component_t;
typedef struct Value_s Value_t;
typedef struct ValueSet_s ValueSet_t;
typedef struct Macro_s Macro_t;
typedef struct MacroProduction_s MacroProduction_t;
typedef struct NamedMacroProduction_s NamedMacroProduction_t;
typedef struct MacroLocalAssignment_s MacroLocalAssignment_t;
typedef struct Quadruple_s Quadruple_t;
typedef struct Tuple_s Tuple_t;
typedef struct Directive_s Directive_t;
typedef struct ModuleIdentifier_s ModuleIdentifier_t;
typedef struct NamedObjIdValue_s NamedObjIdValue_t;
typedef struct ObjectClass_s ObjectClass_t;
typedef struct Object_s Object_t;
typedef struct ObjectSet_s ObjectSet_t;
typedef struct Optionality_s Optionality_t;
typedef struct FieldSpec_s FieldSpec_t;
typedef struct SyntaxSpec_s SyntaxSpec_t;
typedef struct Setting_s Setting_t;
typedef struct String_s String_t;
typedef struct StringModule_s StringModule_t;
typedef struct PERSimpleTypeInfo_s PERSimpleTypeInfo_t;
typedef struct PERTypeInfo_s PERTypeInfo_t;
typedef struct BERTypeInfo_s BERTypeInfo_t;
typedef struct Arguments_s Arguments_t;

typedef Assignment_t *AssignmentList_t;
typedef AssignedObjId_t *AssignedObjIdList_t;
typedef Tag_t *TagList_t;
typedef NamedConstraint_t *NamedConstraintList_t;
typedef NamedNumber_t *NamedNumberList_t;
typedef ValueConstraint_t *ValueConstraintList_t;
typedef Component_t *ComponentList_t;
typedef NamedValue_t *NamedValueList_t;
typedef Directive_t *DirectiveList_t;
typedef Setting_t *SettingList_t;
typedef SyntaxSpec_t *SyntaxSpecList_t;
typedef FieldSpec_t *FieldSpecList_t;
typedef UndefinedSymbol_t *UndefinedSymbolList_t;
typedef NamedObjIdValue_t *NamedObjIdValueList_t;
typedef Value_t *ValueList_t;
typedef NamedMacroProduction_t *NamedMacroProductionList_t;
typedef MacroLocalAssignment_t *MacroLocalAssignmentList_t;
typedef String_t *StringList_t;
typedef StringModule_t *StringModuleList_t;

/* --- undefined element --- */

#define UNDEFINED_VALUE 1UL
#define UNDEFINED(_ptr) ((unsigned long)(_ptr) == UNDEFINED_VALUE)
#define DEFINED(_ptr) ((_ptr) && !UNDEFINED(_ptr))

/* --- Tag --- */

typedef enum {
    eTagType_Implicit,
    eTagType_Explicit,
    eTagType_Automatic,
    eTagType_Unknown
} TagType_e;

typedef enum {
    eTagClass_Universal          = 0x00,
    eTagClass_Application        = 0x40,
    eTagClass_Unknown            = 0x80,
    eTagClass_Private            = 0xc0
} TagClass_e;

struct Tag_s {
    TagList_t Next;
    TagType_e Type;
    TagClass_e Class;
    Value_t *Tag;
};

Tag_t *NewTag(TagType_e type);
Tag_t *DupTag(Tag_t *src);

/* --- Extension --- */

typedef enum {
    eExtension_Unconstrained,
    eExtension_Unextended,
    eExtension_Extendable,
    eExtension_Extended
} Extension_e;

/* --- Assignment --- */

typedef enum {
    eAssignment_Undefined,
    eAssignment_ModuleIdentifier,
    eAssignment_Type,
    eAssignment_Value,
    eAssignment_ObjectClass,
    eAssignment_Object,
    eAssignment_ObjectSet,
    eAssignment_Macro,
    eAssignment_Reference,
    eAssignment_NextPass
} Assignment_e;

typedef enum {
    eAssignmentFlags_Exported = 1,
    eAssignmentFlags_LongName = 2
} AssignmentFlags_e;

struct Assignment_s {
    AssignmentList_t Next;
    char *Identifier;
    ModuleIdentifier_t *Module;
    Assignment_e Type;
    AssignmentFlags_e Flags;
    int fImportedLocalDuplicate;
    int fGhost;
    TagType_e eDefTagType;
    union {
            struct {
            Type_t *Type;
        } Type;
        struct {
            Value_t *Value;
        } Value;
        struct {
            ObjectClass_t *ObjectClass;
        } ObjectClass;
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
        struct {
            Macro_t *Macro;
        } Macro;
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
        } Reference;
    } U;
};

Assignment_t *NewAssignment(Assignment_e type);
Assignment_t *DupAssignment(Assignment_t *src);
Assignment_t *FindAssignment(AssignmentList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
Assignment_t *FindExportedAssignment(AssignmentList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
Assignment_t *FindAssignmentInCurrentPass(AssignmentList_t a, char *ide, ModuleIdentifier_t *mod);
Assignment_t *GetAssignment(AssignmentList_t ass, Assignment_t *a);
Assignment_e GetAssignmentType(AssignmentList_t ass, Assignment_t *a);
int AssignType(AssignmentList_t *ass, Type_t *lhs, Type_t *rhs);
int AssignValue(AssignmentList_t *ass, Value_t *lhs, Value_t *rhs);
int AssignModuleIdentifier(AssignmentList_t *ass, ModuleIdentifier_t *module);

/* --- AssignedObjIds --- */

struct AssignedObjId_s {
    AssignedObjIdList_t Next;
    StringList_t Names;
    uint32_t Number;
    AssignedObjId_t *Child;
};

AssignedObjId_t *NewAssignedObjId(void);
AssignedObjId_t *DupAssignedObjId(AssignedObjId_t *src);

typedef struct DefinedObjectID_s
{
    struct DefinedObjectID_s    *next;
    char                        *pszName;
    Value_t                     *pValue;
}
    DefinedObjectID_t;

extern DefinedObjectID_t *g_pDefinedObjectIDs;
Value_t *GetDefinedOIDValue ( char *pszName );
void AddDefinedOID ( char *pszName, Value_t *pValue );

/* --- TypeRules --- */

typedef enum {
    eTypeRules_Normal = 0x00,
    eTypeRules_Pointer = 0x01, // lonchanc: don't know what it is
    eTypeRules_SinglyLinkedList = 0x02, // --<LINKED>--
    eTypeRules_DoublyLinkedList = 0x04,
    eTypeRules_LengthPointer = 0x08, // --<UNBOUNDED>--
    eTypeRules_FixedArray = 0x10, // default
    eTypeRules_PointerToElement = 0x20, // --<POINTER>--
    eTypeRules_ZeroTerminated = 0x40,

    eTypeRules_LinkedListMask = (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList),
    eTypeRules_PointerArrayMask = (eTypeRules_LengthPointer | eTypeRules_FixedArray),
    eTypeRules_PointerMask = (eTypeRules_LengthPointer | eTypeRules_PointerToElement),
    eTypeRules_IndirectMask = (eTypeRules_Pointer | eTypeRules_LinkedListMask | eTypeRules_PointerMask),
} TypeRules_e;

/* --- TypeFlags --- */

typedef enum {
    eTypeFlags_Null = 1,        /* type is not present in C, 'cause it's NULL */
    eTypeFlags_NullChoice = 2,        /* type is CHOICE with NULL-alternatives */
    eTypeFlags_ExtensionMarker = 4, /* type is extended */
    eTypeFlags_Simple = 8,        /* type has empty freefn, memcpy copyfn */
    eTypeFlags_Done = 0x10,
    eTypeFlags_GenType = 0x20,        /* generate a type */
    eTypeFlags_GenEncode = 0x40,        /* generate an encoding fn */
    eTypeFlags_GenDecode = 0x80,        /* generate a decoding fn */
    eTypeFlags_GenFree = 0x100,        /* generate a free fn */
    eTypeFlags_GenCheck = 0x200,        /* generate a check fn */
    eTypeFlags_GenCompare = 0x400,/* generate a cmp fn */
    eTypeFlags_GenCopy = 0x800,        /* generate a copy fn */
    eTypeFlags_GenPrint = 0x1000,        /* generate a print fn */
    eTypeFlags_GenPdu = 0x2000,        /* generate a pdu number */
    eTypeFlags_GenAll = 0x20+0x40+0x80+0x100+0x400+0x2000,
    eTypeFlags_GenSimple = 0x20+0x40+0x80+0x400+0x2000,
    eTypeFlags_MiddlePDU = 0x8000,
} TypeFlags_e;

/* ------ hack directives ------ */

typedef struct PrivateDirectives_s
{
    char   *pszTypeName;
    char   *pszFieldName;
    char   *pszValueName;
    int     fSLinked;
    int     fDLinked;
    int     fPublic;
    int     fLenPtr;
    int     fPointer; // pointer to fixed array, in PER SeqOf/SetOf only
    int     fArray;
    int     fIntx;
    int     fNoCode;
    int     fNoMemCopy;
    int     fOidPacked;
    int     fOidArray;
} PrivateDirectives_t;

void PropagatePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc );
void PropagateReferenceTypePrivateDirectives ( Type_t *pDst, PrivateDirectives_t *pSrc );
char *GetPrivateValueName(PrivateDirectives_t *pPrivateDirectives, char *pszDefValueName);

/* --- ExtensionType --- */

typedef enum {
    eExtensionType_Automatic,
    eExtensionType_None
} ExtensionType_e;

/* --- PERConstraint --- */

struct PERConstraint_s {
    Extension_e Type;
    ValueConstraintList_t Root;
    ValueConstraintList_t Additional;
};

/* --- PERConstraints --- */

struct PERConstraints_s {
    PERConstraint_t Value;
    PERConstraint_t Size;
    PERConstraint_t PermittedAlphabet;
};

/* --- PERSimpleTypeInfo --- */

typedef enum {
    ePERSTIConstraint_Unconstrained,
    ePERSTIConstraint_Semiconstrained,
    ePERSTIConstraint_Upperconstrained,
    ePERSTIConstraint_Constrained
} PERSTIConstraint_e;

typedef enum {
    ePERSTIAlignment_BitAligned,
    ePERSTIAlignment_OctetAligned
} PERSTIAlignment_e;

typedef enum {
    ePERSTIData_Null,
    ePERSTIData_Boolean,
    ePERSTIData_Unsigned,
    ePERSTIData_Integer,
    ePERSTIData_Real,
    ePERSTIData_BitString,
    ePERSTIData_RZBBitString,
    ePERSTIData_OctetString,
    ePERSTIData_UTF8String,
    ePERSTIData_SequenceOf,
    ePERSTIData_SetOf,
    ePERSTIData_ObjectIdentifier,
    ePERSTIData_NormallySmall,
    ePERSTIData_String,
    ePERSTIData_TableString,
    ePERSTIData_ZeroString,
    ePERSTIData_ZeroTableString,
    ePERSTIData_Reference,
    ePERSTIData_Extension,
    ePERSTIData_External,
    ePERSTIData_EmbeddedPdv,
    ePERSTIData_MultibyteString,
    ePERSTIData_UnrestrictedString,
    ePERSTIData_GeneralizedTime,
    ePERSTIData_UTCTime,
    ePERSTIData_Open
} PERSTIData_e;

typedef enum {
    ePERSTILength_NoLength,
    ePERSTILength_Length,
    ePERSTILength_BitLength,
    ePERSTILength_SmallLength,
    ePERSTILength_InfiniteLength
} PERSTILength_e;

struct PERSimpleTypeInfo_s {
    PERSTIData_e Data;                        /* data type of value */
    char *TableIdentifier;                /* name of stringtable to use */
    ValueConstraintList_t Table;        /* stringtable values */
    Type_t *SubType;                        /* subtype */
    char *SubIdentifier;                /* name of subtype */
    NamedValue_t *Identification;        /* identification of EMB.PDV/CH.STR */
    PERSTIConstraint_e Constraint;        /* constraint of type values */
    intx_t LowerVal;                        /* lower bound of type values */
    intx_t UpperVal;                        /* upper bound of type values */
    uint32_t NBits;                        /* number of bits to use */
    PERSTIAlignment_e Alignment;        /* alignment for encoded value */
    PERSTILength_e Length;                /* type of length encoding */
    PERSTIConstraint_e LConstraint;        /* constraint of length */
    uint32_t LLowerVal;                        /* lower bound of length */
    uint32_t LUpperVal;                        /* upper bound of length */
    uint32_t LNBits;                        /* number of bits to use for length */
    PERSTIAlignment_e LAlignment;        /* alignment for encoded length */
    uint32_t cbFixedSizeBitString;      // number of bits in the bit string of fixed size
};

/* --- PERTypeInfo --- */

typedef enum {
    eBERSTIData_Null,
    eBERSTIData_Boolean,
    eBERSTIData_Unsigned,
    eBERSTIData_Integer,
    eBERSTIData_Real,
    eBERSTIData_BitString,
    eBERSTIData_RZBBitString,
    eBERSTIData_OctetString,
    eBERSTIData_UTF8String,
    eBERSTIData_SequenceOf,
    eBERSTIData_SetOf,
    eBERSTIData_Choice,
    eBERSTIData_Sequence,
    eBERSTIData_Set,
    eBERSTIData_ObjectIdentifier,
    eBERSTIData_ObjectIdEncoded,
    eBERSTIData_String,
    eBERSTIData_ZeroString,
    eBERSTIData_Reference,
    eBERSTIData_External,
    eBERSTIData_EmbeddedPdv,
    eBERSTIData_MultibyteString,
    eBERSTIData_UnrestrictedString,
    eBERSTIData_GeneralizedTime,
    eBERSTIData_UTCTime,
    eBERSTIData_Open
} BERSTIData_e;

struct PERTypeInfo_s {
    char *Identifier;                        /* the complete name of the type */
    TypeFlags_e Flags;                        /* encoding flags */
    TypeRules_e Rules;                        /* encoding directive rules */
    intx_t **EnumerationValues;                /* values of enumeration */
    int32_t NOctets;                        /* size of string chars/integer type */
    Extension_e Type;                        /* extension type */
    PERSimpleTypeInfo_t Root;                /* info for the extension root */
    PERSimpleTypeInfo_t Additional;        /* info for the extensions */
    PrivateDirectives_t *pPrivateDirectives;
};

/* --- BERTypeInfo --- */

struct BERTypeInfo_s {
    char *Identifier;                        /* the complete name of the type */
    TypeFlags_e Flags;                        /* encoding flags */
    TypeRules_e Rules;                        /* encoding directive rules */
    int32_t NOctets;                        /* size of string chars/integer type */
    BERSTIData_e Data;                        /* data type of value */
    Type_t *SubType;                        /* subtype */
    char *SubIdentifier;                /* name of subtype */
    TagList_t Tags;                        /* tags of this type */
    PrivateDirectives_t *pPrivateDirectives;
};

/* --- Type --- */

/* bit 0..4:  universal tag;
   bit 14:    internal bit to distingish types using same universal tag;
   bit 15:    set for internal types */
typedef enum {
    eType_Boolean                = 0x0001,
    eType_Integer                = 0x0002,
    eType_BitString                = 0x0003,
    eType_OctetString                = 0x0004,
    eType_Null                        = 0x0005,
    eType_ObjectIdentifier        = 0x0006,
    eType_ObjectDescriptor        = 0x0007,
    eType_External                = 0x0008,
    eType_InstanceOf                = 0x4008,
    eType_Real                        = 0x0009,
    eType_Enumerated                = 0x000a,
    eType_EmbeddedPdv                = 0x000b,
    eType_UTF8String                = 0x000c,
    eType_Sequence                = 0x0010,
    eType_SequenceOf                = 0x4010,
    eType_Set                        = 0x0011,
    eType_SetOf                        = 0x4011,
    eType_NumericString                = 0x0012,
    eType_PrintableString        = 0x0013,
    eType_TeletexString                = 0x0014,
    eType_T61String                = 0x4014,
    eType_VideotexString        = 0x0015,
    eType_IA5String                = 0x0016,
    eType_UTCTime                = 0x0017,
    eType_GeneralizedTime        = 0x0018,
    eType_GraphicString                = 0x0019,
    eType_VisibleString                = 0x001a,
    eType_ISO646String                = 0x401a,
    eType_GeneralString                = 0x001b,
    eType_UniversalString        = 0x001c,
    eType_CharacterString        = 0x001d,
    eType_BMPString                = 0x001e,
    eType_Choice                = 0x8000,
    eType_Selection                = 0x8001,
    eType_Reference                = 0x8002,
    eType_FieldReference        = 0x8003,
    eType_RestrictedString        = 0x8004,
    eType_Open                        = 0x8005,
    eType_Undefined                = 0x8006,
    eType_Macro                        = 0x8007
} Type_e;

struct Type_s {
    TagList_t Tags;
    TagList_t AllTags;
    TagList_t FirstTags;
    Constraint_t *Constraints;
    DirectiveList_t Directives;
    Type_e Type;
    TypeFlags_e Flags;
    TypeRules_e Rules;
    PERConstraints_t PERConstraints;
    PERTypeInfo_t PERTypeInfo;
    BERTypeInfo_t BERTypeInfo;
    TagType_e TagDefault;
    ExtensionType_e ExtensionDefault;
    PrivateDirectives_t PrivateDirectives;
    union {
        struct {
            NamedNumberList_t NamedNumbers;
        } Integer, Enumerated, BitString, IEB;
        struct {
            ComponentList_t Components;
            uint32_t Optionals;     /* not for Choice */
            uint32_t Alternatives;  /* only for Choice */
            uint32_t Extensions;
            uint8_t  Autotag[2];
        } Sequence, Set, Choice, SSC,
          Real, External, EmbeddedPdv, CharacterString, InstanceOf;
        struct {
            Type_t *Type;
            DirectiveList_t Directives;
        } SequenceOf, SetOf, SS;
        struct {
            char *Identifier;
            Type_t *Type;
        } Selection;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
        struct {
            ObjectClass_t *ObjectClass;
            char *Identifier;
        } FieldReference;
        struct {
            Macro_t *Macro;
            MacroLocalAssignmentList_t LocalAssignments;
        } Macro;
    } U;
};
#define UndefType ((Type_t *)UNDEFINED_VALUE)

Type_t *NewType(Type_e type);
Type_t *DupType(Type_t *src);
Assignment_t *GetAssignedExternalType(AssignmentList_t *a, ModuleIdentifier_t *module, char *identifier);
Type_t *GetType(AssignmentList_t ass, Type_t *type);
Type_e GetTypeType(AssignmentList_t ass, Type_t *type);
TypeRules_e GetTypeRules(AssignmentList_t ass, Type_t *type);
int IsRestrictedString(Type_e type);
int IsStructuredType(Type_t *type);
int IsSequenceType(Type_t *type);
int IsReferenceType(Type_t *type);
Type_t *GetReferencedType(AssignmentList_t a, Type_t *type);

/* --- EndPoint --- */

typedef enum {
    eEndPoint_Min = 1,
    eEndPoint_Max = 2,
    eEndPoint_Open = 4
} EndPoint_e;

struct EndPoint_s {
    EndPoint_e Flags;
    Value_t *Value;
};

EndPoint_t *NewEndPoint();
EndPoint_t *GetLowerEndPoint(AssignmentList_t ass, EndPoint_t *e);
EndPoint_t *GetUpperEndPoint(AssignmentList_t ass, EndPoint_t *e);
int CmpLowerEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CmpUpperEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CmpLowerUpperEndPoint(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);
int CheckEndPointsJoin(AssignmentList_t ass, EndPoint_t *v1, EndPoint_t *v2);

/* --- Constraint --- */

struct Constraint_s {
    Extension_e Type;
    ElementSetSpec_t *Root;
    ElementSetSpec_t *Additional;
    /*XXX exception spec */
};

Constraint_t *NewConstraint();
Constraint_t *DupConstraint(Constraint_t *src);
void IntersectConstraints(Constraint_t **ret, Constraint_t *c1, Constraint_t *c2);

/* --- ElementSetSpec --- */

typedef enum {
    eElementSetSpec_AllExcept,
    eElementSetSpec_Union,
    eElementSetSpec_Intersection,
    eElementSetSpec_Exclusion,
    eElementSetSpec_SubtypeElement,
    eElementSetSpec_ObjectSetElement
} ElementSetSpec_e;

struct ElementSetSpec_s {
    ElementSetSpec_e Type;
    union {
        struct {
            ElementSetSpec_t *Elements;
        } AllExcept;
        struct {
            ElementSetSpec_t *Elements1;
            ElementSetSpec_t *Elements2;
        } Union, Intersection, Exclusion, UIE;
        struct {
            SubtypeElement_t *SubtypeElement;
        } SubtypeElement;
        struct {
            ObjectSetElement_t *ObjectSetElement;
        } ObjectSetElement;
    } U;
};

ElementSetSpec_t *NewElementSetSpec(ElementSetSpec_e type);
ElementSetSpec_t *DupElementSetSpec(ElementSetSpec_t *src);

/* --- SubtypeElement --- */

typedef enum {
    eSubtypeElement_ValueRange,
    eSubtypeElement_Size,
    eSubtypeElement_SingleValue,
    eSubtypeElement_PermittedAlphabet,
    eSubtypeElement_ContainedSubtype,
    eSubtypeElement_Type,
    eSubtypeElement_SingleType,
    eSubtypeElement_FullSpecification,
    eSubtypeElement_PartialSpecification,
    eSubtypeElement_ElementSetSpec
} SubtypeElement_e;

struct SubtypeElement_s {
    SubtypeElement_e Type;
    union {
        struct {
            EndPoint_t Lower;
            EndPoint_t Upper;
        } ValueRange;
        struct {
            Constraint_t *Constraints;
        } Size, PermittedAlphabet, SingleType, SPS;
        struct {
            Value_t *Value;
        } SingleValue;
        struct {
            Type_t *Type;
        } ContainedSubtype;
        struct {
            Type_t *Type;
        } Type;
        struct {
            NamedConstraintList_t NamedConstraints;
        } FullSpecification, PartialSpecification, FP;
        struct {
            ElementSetSpec_t *ElementSetSpec;
        } ElementSetSpec;
    } U;
};

SubtypeElement_t *NewSubtypeElement(SubtypeElement_e type);
SubtypeElement_t *DupSubtypeElement(SubtypeElement_t *src);

/* --- ObjectSetElement --- */

typedef enum {
    eObjectSetElement_Object,
    eObjectSetElement_ObjectSet,
    eObjectSetElement_ElementSetSpec
} ObjectSetElement_e;

struct ObjectSetElement_s {
    ObjectSetElement_e Type;
    union {
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
        struct {
            ElementSetSpec_t *ElementSetSpec;
        } ElementSetSpec;
    } U;
};

ObjectSetElement_t *NewObjectSetElement(ObjectSetElement_e type);
ObjectSetElement_t *DupObjectSetElement(ObjectSetElement_t *src);

/* --- NamedConstraints --- */

typedef enum {
    ePresence_Present,
    ePresence_Absent,
    ePresence_Optional,
    ePresence_Normal
} Presence_e;

struct NamedConstraint_s {
    NamedConstraintList_t Next;
    char *Identifier;
    Constraint_t *Constraint;
    Presence_e Presence;
};

NamedConstraint_t *NewNamedConstraint(void);
NamedConstraint_t *DupNamedConstraint(NamedConstraint_t *src);

/* --- NamedNumber --- */

typedef enum {
    eNamedNumber_Normal,
    eNamedNumber_ExtensionMarker
} NamedNumbers_e;

struct NamedNumber_s {
    NamedNumberList_t Next;
    NamedNumbers_e Type;
    union {
        struct {
            char *Identifier;
            Value_t *Value;
        } Normal;
        struct {
            int dummy; /* ExceptionSpec */
        } ExtensionMarker;
    } U;
};

NamedNumber_t *NewNamedNumber(NamedNumbers_e type);
NamedNumber_t *DupNamedNumber(NamedNumber_t *src);
NamedNumber_t *FindNamedNumber(NamedNumberList_t numbers, char *identifier);

/* --- ValueConstraints --- */

struct ValueConstraint_s {
    ValueConstraintList_t Next;
    EndPoint_t Lower;
    EndPoint_t Upper;
};

ValueConstraint_t *NewValueConstraint();
ValueConstraint_t *DupValueConstraint(ValueConstraint_t *src);
int CountValues(AssignmentList_t ass, ValueConstraintList_t v, intx_t *n);
int HasNoValueConstraint(ValueConstraintList_t v);
int HasNoSizeConstraint(AssignmentList_t ass, ValueConstraintList_t v);
int HasNoPermittedAlphabetConstraint(AssignmentList_t ass, ValueConstraintList_t v);
NamedValue_t *GetFixedIdentification(AssignmentList_t ass, Constraint_t *constraints);

/* --- NamedType --- */

struct NamedType_s {
    char *Identifier;
    Type_t *Type;
};

NamedType_t *NewNamedType(char *identifier, Type_t *type);
NamedType_t *DupNamedType(NamedType_t *src);

/* --- Components --- */

typedef enum {
    eComponent_Normal,
    eComponent_Optional,
    eComponent_Default,
    eComponent_ComponentsOf,
    eComponent_ExtensionMarker
} Components_e;

struct Component_s {
    ComponentList_t Next;
    Components_e Type;
    union {
        struct {
            NamedType_t *NamedType;
            Value_t *Value; /* only Default */
        } Normal, Optional, Default, NOD;
        struct {
            Type_t *Type;
        } ComponentsOf;
        struct {
            int dummy; /* ExceptionSpec */
        } ExtensionMarker;
    } U;
};

Component_t *NewComponent(Components_e type);
Component_t *DupComponent(Component_t *src);
Component_t *FindComponent(AssignmentList_t ass, ComponentList_t components, char *identifier);

/* --- NamedValues --- */

struct NamedValue_s {
    NamedValueList_t Next;
    char *Identifier;
    Value_t *Value;
};

NamedValue_t *NewNamedValue(char *identifier, Value_t *value);
NamedValue_t *DupNamedValue(NamedValue_t *src);
NamedValue_t *FindNamedValue(NamedValueList_t namedValues, char *identifier);

/* --- NamedObjIdValue --- */

typedef enum {
    eNamedObjIdValue_NameForm,
    eNamedObjIdValue_NumberForm,
    eNamedObjIdValue_NameAndNumberForm
} NamedObjIdValue_e;

struct NamedObjIdValue_s {
    NamedObjIdValueList_t Next;
    NamedObjIdValue_e Type;
    char *Name;
    uint32_t Number;
};

NamedObjIdValue_t *NewNamedObjIdValue(NamedObjIdValue_e type);
NamedObjIdValue_t *DupNamedObjIdValue(NamedObjIdValue_t *src);
int GetAssignedObjectIdentifier(AssignedObjIdList_t *aoi, Value_t *parent, NamedObjIdValueList_t named, Value_t **val);

/* --- asn1c_objectidentifier_t --- */

typedef struct asn1c_objectidentifier_s
{
    ASN1uint32_t        length;
    objectnumber_t     *value;
}   asn1c_objectidentifier_t;

/* --- Value --- */

typedef enum {
    eValueFlags_GenValue = 1, /* generate value definition */
    eValueFlags_GenExternValue = 2, /* generate external value declaration */
    eValueFlags_GenAll = 3,
    eValueFlags_Done = 4      /* examination done */
} ValueFlags_e;

struct Value_s {
    Value_t *Next;
    Type_t *Type;
    ValueFlags_e Flags;
    union {
        struct {
            uint32_t Value;
        } Boolean;
        struct {
            intx_t Value;
        } Integer;
        struct {
            uint32_t Value;
        } Enumerated;
        struct {
            real_t Value;
        } Real;
        struct {
            bitstring_t Value;
        } BitString;
        struct {
            octetstring_t Value;
        } OctetString;
        struct {
            ASN1wstring_t Value;
        } UTF8String;
        struct {
            NamedValueList_t NamedValues;
        } Sequence, Set, Choice, SSC,
          External, EmbeddedPdv, CharacterString, InstanceOf;
        struct {
            ValueList_t Values;
        } SequenceOf, SetOf, SS;
        struct {
            asn1c_objectidentifier_t Value;
        } ObjectIdentifier;
        struct {
            char32string_t Value;
        } RestrictedString, ObjectDescriptor;
        struct {
            generalizedtime_t Value;
        } GeneralizedTime;
        struct {
            utctime_t Value;
        } UTCTime;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};
#define UndefValue ((Value_t *)UNDEFINED_VALUE)

Value_t *NewValue(AssignmentList_t ass, Type_t *type);
Value_t *DupValue(Value_t *src);
Value_t *GetValue(AssignmentList_t ass, Value_t *value);
Assignment_t *GetAssignedExternalValue(AssignmentList_t *a, ModuleIdentifier_t *module, char *identifier);
int CmpValue(AssignmentList_t ass, Value_t *v1, Value_t *v2);
int SubstractValues(AssignmentList_t ass, intx_t *dst, Value_t *src1, Value_t *src2);

/* --- ValueSet --- */

struct ValueSet_s {
    ElementSetSpec_t *Elements;
    Type_t *Type;
};

ValueSet_t *NewValueSet();
ValueSet_t *DupValueSet(ValueSet_t *src);

/* --- Macro --- */

typedef enum {
    eMacro_Macro,
    eMacro_Reference
} Macro_e;

struct Macro_s {
    Macro_e Type;
    union {
        struct {
            MacroProduction_t *TypeProduction;
            MacroProduction_t *ValueProduction;
            NamedMacroProductionList_t SupportingProductions;
        } Macro;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

Macro_t *NewMacro(Macro_e type);
Macro_t *DupMacro(Macro_t *src);
Macro_t *GetMacro(AssignmentList_t ass, Macro_t *src);

/* --- MacroProduction --- */

typedef enum {
    eMacroProduction_Alternative,
    eMacroProduction_Sequence,
    eMacroProduction_AString,
    eMacroProduction_ProductionReference,
    eMacroProduction_String,
    eMacroProduction_Identifier,
    eMacroProduction_Number,
    eMacroProduction_Empty,
    eMacroProduction_Type,
    eMacroProduction_Value,
    eMacroProduction_LocalTypeAssignment,
    eMacroProduction_LocalValueAssignment
} MacroProduction_e;

struct MacroProduction_s {
    MacroProduction_e Type;
    union {
        struct {
            MacroProduction_t *Production1;
            MacroProduction_t *Production2;
        } Alternative, Sequence;
        struct {
            char *String;
        } AString;
        struct {
            char *Reference;
        } ProductionReference;
        struct {
            char *LocalTypeReference;
        } Type;
        struct {
            char *LocalValueReference;
            char *LocalTypeReference;
            Type_t *Type;
        } Value;
        struct {
            char *LocalTypeReference;
            Type_t *Type;
        } LocalTypeAssignment;
        struct {
            char *LocalValueReference;
            Value_t *Value;
        } LocalValueAssignment;
    } U;
};
#define UndefProduction ((MacroProduction_t *)UNDEFINED_VALUE)

MacroProduction_t *NewMacroProduction(MacroProduction_e type);
MacroProduction_t *DupMacroProduction(MacroProduction_t *src);

/* --- NamedMacroProduction --- */

struct NamedMacroProduction_s {
    NamedMacroProductionList_t Next;
    char *Identifier;
    MacroProduction_t *Production;
};

NamedMacroProduction_t *NewNamedMacroProduction();
NamedMacroProduction_t *DupNamedMacroProduction(NamedMacroProduction_t *src);

/* --- MacroLocalAssignment --- */

typedef enum {
    eMacroLocalAssignment_Type,
    eMacroLocalAssignment_Value
} MacroLocalAssignment_e;

struct MacroLocalAssignment_s {
    MacroLocalAssignmentList_t Next;
    char *Identifier;
    MacroLocalAssignment_e Type;
    union {
        Type_t *Type;
        Value_t *Value;
    } U;
};

MacroLocalAssignment_t *NewMacroLocalAssignment(MacroLocalAssignment_e type);
MacroLocalAssignment_t *DupMacroLocalAssignment(MacroLocalAssignment_t *src);
MacroLocalAssignment_t *FindMacroLocalAssignment(MacroLocalAssignmentList_t la, char *ide);

/* --- Quadruple --- */

struct Quadruple_s {
    uint32_t Group;
    uint32_t Plane;
    uint32_t Row;
    uint32_t Cell;
};

/* --- Tuple --- */

struct Tuple_s {
    uint32_t Column;
    uint32_t Row;
};

/* --- Directive --- */

typedef enum {
    eDirective_None,
    eDirective_FixedArray,
    eDirective_DoublyLinkedList,
    eDirective_SinglyLinkedList,
    eDirective_LengthPointer,
    eDirective_ZeroTerminated,
    eDirective_Pointer,
    eDirective_NoPointer
} Directives_e;

struct Directive_s {
    DirectiveList_t Next;
    Directives_e Type;
    /* may be extended in future ... */
};

Directive_t *NewDirective(Directives_e type);
Directive_t *DupDirective(Directive_t *src);

/* --- ModuleIdentifier --- */

struct ModuleIdentifier_s {
    char *Identifier;
    Value_t *ObjectIdentifier;
};

ModuleIdentifier_t *NewModuleIdentifier(void);
ModuleIdentifier_t *DupModuleIdentifier(ModuleIdentifier_t *src);
int CmpModuleIdentifier(AssignmentList_t ass, ModuleIdentifier_t *mod1, ModuleIdentifier_t *mod2);

/* --- ObjectClass --- */

typedef enum {
    eObjectClass_ObjectClass,
    eObjectClass_Reference,
    eObjectClass_FieldReference
} ObjectClass_e;

struct ObjectClass_s {
    ObjectClass_e Type;
    union {
        struct {
            FieldSpecList_t FieldSpec;
            SyntaxSpecList_t SyntaxSpec;
        } ObjectClass;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
        struct {
            ObjectClass_t *ObjectClass;
            char *Identifier;
        } FieldReference;
    } U;
};

ObjectClass_t *NewObjectClass(ObjectClass_e type);
ObjectClass_t *DupObjectClass(ObjectClass_t *src);
ObjectClass_t *GetObjectClass(AssignmentList_t ass, ObjectClass_t *oc);
int AssignObjectClass(AssignmentList_t *ass, ObjectClass_t *lhs, ObjectClass_t *rhs);
Assignment_t *GetAssignedExternalObjectClass(ModuleIdentifier_t *module, char *identifier);

/* --- Object --- */

typedef enum {
    eObject_Object,
    eObject_Reference
} Object_e;

struct Object_s {
    Object_e Type;
    union {
        struct {
            ObjectClass_t *ObjectClass;
            SettingList_t Settings;
        } Object;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

Object_t *NewObject(Object_e type);
Object_t *DupObject(Object_t *src);
Object_t *GetObject(AssignmentList_t ass, Object_t *src);
int AssignObject(AssignmentList_t *ass, Object_t *lhs, Object_t *rhs);
Assignment_t *GetAssignedExternalObject(ModuleIdentifier_t *module, char *identifier);

/* --- ObjectSet --- */

typedef enum {
    eObjectSet_ObjectSet,
    eObjectSet_Reference,
    eObjectSet_ExtensionMarker
} ObjectSet_e;

struct ObjectSet_s {
    ObjectSet_e Type;
    union {
        struct {
            ObjectClass_t *ObjectClass;
            ElementSetSpec_t *Elements; /* only for ObjectSet */
        } ObjectSet, ExtensionMarker, OE;
        struct {
            ModuleIdentifier_t *Module;
            char *Identifier;
        } Reference;
    } U;
};

ObjectSet_t *NewObjectSet(ObjectSet_e type);
ObjectSet_t *DupObjectSet(ObjectSet_t *src);
ObjectSet_t *GetObjectSet(AssignmentList_t ass, ObjectSet_t *src);
int AssignObjectSet(AssignmentList_t *ass, ObjectSet_t *lhs, ObjectSet_t *rhs);
Assignment_t *GetAssignedExternalObjectSet(ModuleIdentifier_t *module, char *identifier);

/* --- Settings --- */

typedef enum {
    eSetting_Type,
    eSetting_Value,
    eSetting_ValueSet,
    eSetting_Object,
    eSetting_ObjectSet,
    eSetting_Undefined
} Settings_e;

struct Setting_s {
    SettingList_t Next;
    Settings_e Type;
    char *Identifier;
    union {
        struct {
            Type_t *Type;
        } Type;
        struct {
            Value_t *Value;
        } Value;
        struct {
            ValueSet_t *ValueSet;
        } ValueSet;
        struct {
            Object_t *Object;
        } Object;
        struct {
            ObjectSet_t *ObjectSet;
        } ObjectSet;
    } U;
};

Setting_t *NewSetting(Settings_e type);
Setting_t *DupSetting(Setting_t *src);
Settings_e GetSettingType(Setting_t *src);
Setting_t *FindSetting(SettingList_t se, char *identifier);

/* --- SyntaxSpec --- */

typedef enum {
    eSyntaxSpec_Literal,
    eSyntaxSpec_Field,
    eSyntaxSpec_Optional
} SyntaxSpecs_e;

struct SyntaxSpec_s {
    SyntaxSpecList_t Next;
    SyntaxSpecs_e Type;
    union {
        struct {
            char *Literal;
        } Literal;
        struct {
            char *Field;
        } Field;
        struct {
            SyntaxSpecList_t SyntaxSpec;
        } Optional;
    } U;
};
#define UndefSyntaxSpecs ((SyntaxSpec_t *)UNDEFINED_VALUE)

SyntaxSpec_t *NewSyntaxSpec(SyntaxSpecs_e type);
SyntaxSpec_t *DupSyntaxSpec(SyntaxSpec_t *src);

/* --- Optionality --- */

typedef enum {
    eOptionality_Normal,
    eOptionality_Optional,
    eOptionality_Default_Type,
    eOptionality_Default_Value,
    eOptionality_Default_ValueSet,
    eOptionality_Default_Object,
    eOptionality_Default_ObjectSet
} Optionality_e;

struct Optionality_s {
    Optionality_e Type;
    union {
        Type_t *Type;                        /* only for Default_Type */
        Value_t *Value;                        /* only for Default_Value */
        ValueSet_t *ValueSet;                /* only for Default_ValueSet */
        Object_t *Object;                /* only for Default_Object */
        ObjectSet_t *ObjectSet;                /* only for Default_ObjectSet */
    } U;
};

Optionality_t *NewOptionality(Optionality_e opt);
Optionality_t *DupOptionality(Optionality_t *src);

/* --- FieldSpec --- */

typedef enum {
    eFieldSpec_Type,
    eFieldSpec_FixedTypeValue,
    eFieldSpec_VariableTypeValue,
    eFieldSpec_FixedTypeValueSet,
    eFieldSpec_VariableTypeValueSet,
    eFieldSpec_Object,
    eFieldSpec_ObjectSet,
    eFieldSpec_Undefined
} FieldSpecs_e;

struct FieldSpec_s {
    FieldSpecList_t Next;
    FieldSpecs_e Type;
    char *Identifier;
    union {
        struct {
            Optionality_t *Optionality;
        } Type;
        struct {
            Type_t *Type;
            uint32_t Unique;
            Optionality_t *Optionality;
        } FixedTypeValue;
        struct {
            StringList_t Fields;
            Optionality_t *Optionality;
        } VariableTypeValue;
        struct {
            Type_t *Type;
            Optionality_t *Optionality;
        } FixedTypeValueSet;
        struct {
            StringList_t Fields;
            Optionality_t *Optionality;
        } VariableTypeValueSet;
        struct {
            ObjectClass_t *ObjectClass;
            Optionality_t *Optionality;
        } Object;
        struct {
            ObjectClass_t *ObjectClass;
            Optionality_t *Optionality;
        } ObjectSet;
    } U;
};

FieldSpec_t *NewFieldSpec(FieldSpecs_e type);
FieldSpec_t *DupFieldSpec(FieldSpec_t *src);
FieldSpec_t *GetFieldSpec(AssignmentList_t ass, FieldSpec_t *fs);
FieldSpecs_e GetFieldSpecType(AssignmentList_t ass, FieldSpec_t *fs);
FieldSpec_t *FindFieldSpec(FieldSpecList_t fs, char *identifier);

/* --- UndefinedSymbol --- */

typedef enum {
    eUndefinedSymbol_SymbolNotDefined,
    eUndefinedSymbol_SymbolNotExported,
    eUndefinedSymbol_FieldNotDefined,
    eUndefinedSymbol_FieldNotExported
} UndefinedSymbol_e;

struct UndefinedSymbol_s {
    UndefinedSymbolList_t Next;
    UndefinedSymbol_e Type;
    union {
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
            Assignment_e ReferenceType;
        } Symbol;
        struct {
            char *Identifier;
            ModuleIdentifier_t *Module;
            Settings_e ReferenceFieldType;
            ObjectClass_t *ObjectClass;
        } Field;
    } U;
};

UndefinedSymbol_t *NewUndefinedSymbol(UndefinedSymbol_e type, Assignment_e reftype);
UndefinedSymbol_t *NewUndefinedField(UndefinedSymbol_e type, ObjectClass_t *oc, Settings_e reffieldtype);
int CmpUndefinedSymbol(AssignmentList_t ass, UndefinedSymbol_t *u1, UndefinedSymbol_t *u2);
int CmpUndefinedSymbolList(AssignmentList_t ass, UndefinedSymbolList_t u1, UndefinedSymbolList_t u2);
UndefinedSymbol_t *FindUndefinedSymbol(AssignmentList_t ass, UndefinedSymbolList_t a, Assignment_e type, char *ide, ModuleIdentifier_t *mod);
UndefinedSymbol_t *FindUndefinedField(AssignmentList_t ass, UndefinedSymbolList_t u, Settings_e fieldtype, ObjectClass_t *oc, char *ide, ModuleIdentifier_t *mod);

/* --- String --- */

struct String_s {
    StringList_t Next;
    char *String;
};
String_t *NewString(void);
String_t *DupString(String_t *src);
String_t *FindString(StringList_t list, char *str);
#define EXPORT_ALL ((String_t *)1)

/* --- StringModule --- */

struct StringModule_s {
    StringModuleList_t Next;
    char *String;
    ModuleIdentifier_t *Module;
};
StringModule_t *NewStringModule(void);
StringModule_t *DupStringModule(StringModule_t *src);
StringModule_t *FindStringModule(AssignmentList_t ass, StringModuleList_t list, char *str, ModuleIdentifier_t *module);
#define IMPORT_ALL ((StringModule_t *)1)

/* --- Language --- */

typedef enum {
    eLanguage_C,
    eLanguage_Cpp
} Language_e;

/* --- Alignment --- */

typedef enum {
    eAlignment_Unaligned,
    eAlignment_Aligned
} Alignment_e;

/* --- Encoding --- */

typedef enum {
    eEncoding_Basic,
    eEncoding_Packed
} Encoding_e;

/* --- SubEncoding --- */

typedef enum {
    eSubEncoding_Basic = 'B',
    eSubEncoding_Canonical = 'C',
    eSubEncoding_Distinguished = 'D'
} SubEncoding_e;

/* --- generation entities --- */

typedef enum { eStringTable, eEncode, eDecode, eCheck, ePrint, eFree, eCompare, eCopy } TypeFunc_e;
typedef enum { eDecl, eDefh, eDefn, eInit, eFinit } ValueFunc_e;

struct Arguments_s {
    char *enccast;
    char *encfunc;
    char *Pencfunc;
    char *deccast;
    char *decfunc;
    char *Pdecfunc;
    char *freecast;
    char *freefunc;
    char *Pfreefunc;
    char *cmpcast;
    char *cmpfunc;
    char *Pcmpfunc;
};

/* --- ghost file --- */

typedef struct GhostFile_s {
    char    *pszFileName;
    char    *pszModuleName;
}
    GhostFile_t;

/* --- utility functions --- */

char *GetIntType(AssignmentList_t ass, EndPoint_t *lower, EndPoint_t *upper, int32_t *sign);
char *GetIntegerType(AssignmentList_t ass, Type_t *type, int32_t *sign);
char *GetRealType(Type_t *type);
char *GetBooleanType(void);
char *GetEnumeratedType(AssignmentList_t ass, Type_t *type, int32_t *sign);
char *GetChoiceType(Type_t *type);
char *GetStringType(AssignmentList_t ass, Type_t *type, int32_t *noctets, uint32_t *zero);
uint32_t GetIntBits(intx_t *range);

void GetPERConstraints(AssignmentList_t ass, Constraint_t *constraints, PERConstraints_t *per);

char *Identifier2C(char *identifier);
char *Reference(char *expression);
char *Dereference(char *expression);

extern int ForceAllTypes;
extern char *IntegerRestriction;
extern char *UIntegerRestriction;
extern char *RealRestriction;
extern int Has64Bits;
extern Language_e g_eProgramLanguage;
extern Encoding_e g_eEncodingRule;
extern Alignment_e Alignment;
extern SubEncoding_e g_eSubEncodingRule;

int GetUndefined(AssignmentList_t ass, UndefinedSymbol_t *undef);
void UndefinedError(AssignmentList_t ass, UndefinedSymbolList_t undef, UndefinedSymbolList_t baddef);

extern FILE *g_finc, *g_fout;

void InitBuiltin();
void InitBuiltinASN1CharacterModule();
void Examination(AssignmentList_t *ass, ModuleIdentifier_t *mainmodule);
void GenInc(AssignmentList_t ass, FILE *finc, char *module);
void GenPrg(AssignmentList_t ass, FILE *fprg, char *module, char *incfilename);
void GenFuncSequenceSetDefaults(AssignmentList_t ass, char *valref, ComponentList_t components, char *obuf, TypeFunc_e et);
void GenFuncSequenceSetOptionals(AssignmentList_t ass, char *valref, ComponentList_t components, uint32_t optionals, uint32_t extensions, char *obuf, TypeFunc_e et);
void GenPERHeader();
void GenPERInit(AssignmentList_t ass, char *module);
void GenPERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);
void GenBERHeader();
void GenBERInit(AssignmentList_t ass, char *module);
void GenBERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);

void GetMinMax(AssignmentList_t ass, ValueConstraintList_t constraints,
    EndPoint_t *lower, EndPoint_t *upper);
char *GetTypeName(AssignmentList_t ass, Type_t *type);
char *PGetTypeName(AssignmentList_t ass, Type_t *type);
char *GetValueName(AssignmentList_t ass, Value_t *value);
char *GetObjectClassName(AssignmentList_t ass, ObjectClass_t *oc);
char *GetName(Assignment_t *a);
char *PGetName(AssignmentList_t ass, Assignment_t *a);
Tag_t *GetTag(AssignmentList_t ass, Type_t *type);
int32_t GetOctets(char *inttype);
void AutotagType(AssignmentList_t ass, Type_t *type);
void SortAssignedTypes(AssignmentList_t *ass);
void ExamineBER(AssignmentList_t ass);
void ExaminePER(AssignmentList_t ass);
void GetBERPrototype(Arguments_t *args);
void GetPERPrototype(Arguments_t *args);

int String2GeneralizedTime(generalizedtime_t *time, char32string_t *string);
int String2UTCTime(utctime_t *time, char32string_t *string);

FieldSpec_t *GetObjectClassField(AssignmentList_t ass, ObjectClass_t *oc, char *field);
FieldSpec_t *GetFieldSpecFromObjectClass(AssignmentList_t ass, ObjectClass_t *oc, StringList_t fields);
Setting_t *GetSettingFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Setting_t *GetSettingFromSettings(AssignmentList_t ass, SettingList_t se, StringList_t sl);

ObjectClass_t *GetObjectClassFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems);
Value_t *GetValueFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ValueSet_t *GetValueSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Type_t *GetTypeFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
Object_t *GetObjectFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ObjectSet_t *GetObjectSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl);
ElementSetSpec_t *ConvertElementSetSpecToElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl));
ElementSetSpec_t *ConvertObjectSetToElementSetSpec(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl));
ValueSet_t *GetValueSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl);
ObjectSet_t *GetObjectSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl);
Type_t *GetTypeOfValueSet(AssignmentList_t ass, ValueSet_t *vs);
int IsPSetOfType(AssignmentList_t ass, Assignment_t *a);


// --- The following is added by Microsoft ---

int IsReservedWord ( char *psz );
void KeepEnumNames ( char *pszEnumName );
void KeepOptNames ( char *pszOptName );
void KeepChoiceNames ( char *pszChoiceName );
int DoesEnumNameConflict ( char *pszEnumName );
int DoesOptNameConflict ( char *pszOptName );
int DoesChoiceNameConflict ( char *pszChoiceName );

void SetDirective(char *psz);
void PrintVerbatim(void);

/* ------ char.c ------ */

int ASN1is16space(ASN1char16_t c);
int ASN1str16len(ASN1char16_t *p);
int ASN1is32space(ASN1char32_t c);
int ASN1str32len(ASN1char32_t *p);

int IsImportedLocalDuplicate(AssignmentList_t ass, ModuleIdentifier_t *pMainModule, Assignment_t *curr);

extern TagType_e g_eDefTagType;

extern TypeRules_e g_eDefTypeRuleSS_NonSized;
extern TypeRules_e g_eDefTypeRuleSS_Sized;
extern int g_fOidArray;

extern char *g_pszOrigModuleNameLowerCase;
extern int g_fLongNameForImported;
extern int g_fExtraStructPtrTypeSS;

extern int g_fMicrosoftExtensions;

extern int g_chDirectiveBegin;
extern int g_chDirectiveEnd;
extern int g_chDirectiveAND;

extern char *g_pszApiPostfix;
extern char *g_pszChoicePostfix;
extern char *g_pszOptionPostfix;
extern char *g_pszOptionValue;

extern void StripModuleName(char *pszDst, char *pszSrc);

extern int g_cGhostFiles;
extern GhostFile_t g_aGhostFiles[16];

#endif // _ASN1C_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\geninc.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

const ASN1uint32_t c_BitMaskMap[sizeof(ASN1uint32_t) * 8] =
{
#ifdef USE_BIG_ENDIAN
        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,

        0x800000,   0x400000,   0x200000,   0x100000,
        0x080000,   0x040000,   0x020000,   0x010000,

        0x8000,     0x4000,     0x2000,     0x1000,
        0x0800,     0x0400,     0x0200,     0x0100,

        0x80,       0x40,       0x20,       0x10,
        0x08,       0x04,       0x02,       0x01,
#else // little endian 
        0x80,       0x40,       0x20,       0x10,
        0x08,       0x04,       0x02,       0x01,

        0x8000,     0x4000,     0x2000,     0x1000,
        0x0800,     0x0400,     0x0200,     0x0100,

        0x800000,   0x400000,   0x200000,   0x100000,
        0x080000,   0x040000,   0x020000,   0x010000,

        0x80000000, 0x40000000, 0x20000000, 0x10000000,
        0x08000000, 0x04000000, 0x02000000, 0x01000000,
#endif
};

void GenComponents(AssignmentList_t ass, ComponentList_t components,
    char *identifier, char *completeidentifier, int *choiceoffset,
    int *optionaloffset);
void GenType(AssignmentList_t ass, char *identifier, char *completeidentifier,
    Type_t *type, int withmodule, int pointer, int array, int fTypeDef);

void GenEnumeration(AssignmentList_t ass, ComponentList_t components,
    char *identifier, char *completeidentifier, int *choiceoffset,
    int *optionaloffset);

int NotInFunTbl(Assignment_t *a);

unsigned g_cPDUs = 0;

unsigned g_cOptionValueSize = 0;

extern int g_fAllEndians;

/* generate include file */
void
GenInc(AssignmentList_t ass, FILE *finc, char *module)
{
    Assignment_t *a;
    char *identifier;
    int offset, i;
    Type_t *type, *subtype;
    Value_t *value;
    unsigned npdu;
    char *pszPrivateValueName;
    unsigned cOptionValueSizeSave;

    setoutfile(finc);

    module = Identifier2C(module);

    // print verbatim
    PrintVerbatim();

    /* file header */
    output("#ifndef _%s_H_\n", module);
    output("#define _%s_H_\n\n", module);

    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("#include \"msper.h\"\n");
        break;
    case eEncoding_Basic:
        output("#include \"msber.h\"\n");
        break;
    default:
        ASSERT(0);
        break;
    }
    output("\n");

    for (i = 0; i < g_cGhostFiles; i++)
    {
        StripModuleName(g_aGhostFiles[i].pszFileName, g_aGhostFiles[i].pszFileName);
        strcat(g_aGhostFiles[i].pszFileName, ".h");
        output("#include \"%s\"\n", g_aGhostFiles[i].pszFileName);
    }
    if (g_cGhostFiles)
    {
        output("\n");
    }

    // ghost all the data structures from the ghost asn1 files
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;
        if (type->Flags & eTypeFlags_Null)
            continue;
        if (!(type->Flags & eTypeFlags_GenType))
            continue;
        if (a->Module && a->Module->Identifier)
        {
            for (i = 0; i < g_cGhostFiles; i++)
            {
                if (! strcmp(a->Module->Identifier, g_aGhostFiles[i].pszModuleName))
                {
                    a->fGhost = 1;
                    break;
                }
            }
        }
    }

    /* language dependent interface */
    switch (g_eProgramLanguage) {
    case eLanguage_C:
        // output("#include \"cinterf.h\"\n\n");
        output("#ifdef __cplusplus\n");
        outputni("extern \"C\" {\n");
        output("#endif\n\n");
        break;
    case eLanguage_Cpp:
        // output("#include \"cppinterf.h\"\n\n");
        // break;
    default:
        ASSERT(0);
        break;
    }

    /* create endian independent macros */
    if (g_fAllEndians)
    {
        output("#ifdef ASN1_BIG_ENDIAN\n");
        output("#define ASN1_LITE_TO_BIGE_16(n16)    ((((n16) & 0xFF) << 8)  | (((n16) & 0xFF00) >> 8))\n");
        output("#define ASN1_LITE_TO_BIGE_32(n32)    ((((n32) & 0xFF) << 24) | (((n32) & 0xFF00) << 8)) | (((n32) & 0xFF0000) >> 8) | (((n32) & 0xFF000000) >> 24)\n");
        output("#define ASN1_ENDIAN_16(n16)         ASN1_LITE_TO_BIGE_16(n16)\n");
        output("#define ASN1_ENDIAN_32(n32)         ASN1_LITE_TO_BIGE_32(n32)\n");
        output("#else\n");
        output("#define ASN1_ENDIAN_16(n16)         (n16)\n");
        output("#define ASN1_ENDIAN_32(n32)         (n32)\n");
        output("#endif // ASN1_BIG_ENDIAN\n\n");
    }

    /* typedefs for sequence of/set of with list representation */
    npdu = 0;
    for (a = ass; a; a = a->Next) {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;
        if (type->Flags & eTypeFlags_Null)
            continue;
        if (!(type->Flags & eTypeFlags_GenType))
            continue;
        if (a->fGhost)
            continue;
        identifier = GetName(a);
        switch (type->Type) {
        case eType_SequenceOf:
        case eType_SetOf:
            if (GetTypeRules(ass, type) & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement))
            {
                if (g_fExtraStructPtrTypeSS)
                {
                    output("typedef struct %s_s * P%s;\n",
                        identifier, identifier);
                }
                else
                {
                    output("typedef struct %s * P%s;\n",
                        identifier, identifier);
                }
                output("\n");
            }
            break;
        default:
            break;
        }
    }

    /* other type definitions */
    for (a = ass; a; a = a->Next) {
        if (a->Type != eAssignment_Type)
            continue;
        type = a->U.Type.Type;

        /* skip null type */
        if (type->Flags & eTypeFlags_Null)
        {
                if (type->Type == eType_Sequence)
                {
                        identifier = GetName(a);
                        output("typedef struct %s {\n", identifier);
                        output("char placeholder;\n");
                        output("} %s;\n\n", identifier);
                }
                continue;
        }

        /* type definition wanted? */
        if (!(type->Flags & eTypeFlags_GenType))
            continue;

        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
            continue;

        if (a->fGhost)
            continue;

        /* assign an id number to the type */
        identifier = GetName(a);

        /* write type definitions */
        switch (type->Type) {
        case eType_Sequence:
        case eType_Set:
        case eType_InstanceOf:

            // save
            cOptionValueSizeSave = g_cOptionValueSize;

            // generate scope-free enumeration
            offset = 0;
            GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use struct for sequence/set/instanceof type */
            /* add a bit field for optional components */
            output("typedef struct %s {\n", identifier);
            if (type->U.SSC.Optionals || type->U.SSC.Extensions) {
                int cOctets = (type->U.SSC.Optionals + 7) / 8 +
                              (type->U.SSC.Extensions + 7) / 8;
                g_cOptionValueSize = (cOctets <= 2) ? 16 : 32;
                output("union {\nASN1uint%u_t %s;\nASN1octet_t o[%d];\n};\n",
                    g_cOptionValueSize, g_pszOptionValue, cOctets);
            }
            offset = 0;
            GenComponents(ass, type->U.SSC.Components,
                identifier, identifier, NULL, &offset);
            output("} %s;\n", identifier);

            // restore
            g_cOptionValueSize = cOptionValueSizeSave;
            break;

        case eType_Choice:

            // generate scope-free enumeration
            offset = 0;
            GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use a struct of an selector and a union for choice type */
            output("typedef struct %s {\n", identifier);
            // output("%s o;\n", GetChoiceType(type));
            output("ASN1choice_t choice;\n");
            if (!(type->Flags & eTypeFlags_NullChoice))
                output("union {\n");
            offset = ASN1_CHOICE_BASE;
            GenComponents(ass, type->U.Choice.Components,
                identifier, identifier, &offset, NULL);
            if (!(type->Flags & eTypeFlags_NullChoice))
                output("} u;\n");
            output("} %s;\n", identifier);
            break;

        case eType_SequenceOf:
        case eType_SetOf:

            //
            // LONCHANC: The following two lines of code do not apply to
            // SEQUENCE OF and SET OF.
            //
            // generate scope-free enumeration
            // offset = 0;
            // GenEnumeration(ass, type->U.SSC.Components, identifier, identifier, NULL, &offset);

            /* use a struct of length+values for sequence of/set of with */
            /* length-pointer representation */
            /* use a struct of next+value for sequence of/set of with */
            /* singly-linked-list representation */
            /* use a struct of next+prev+value for sequence of/set of with */
            /* doubly-linked-list representation */
            subtype = type->U.SS.Type;
            if (g_fExtraStructPtrTypeSS &&
                (type->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement)))
            {
                output("typedef struct %s_s {\n", identifier);
            }
            else
            {
                output("typedef struct %s {\n", identifier);
            }
            // fix (xyz..MAX) problem.
            if (type->Rules == eTypeRules_FixedArray && type->PERTypeInfo.Root.LUpperVal == 0)
            {
                type->Rules &= ~ eTypeRules_FixedArray;
                type->Rules |= g_eDefTypeRuleSS_NonSized;
                type->PERTypeInfo.Rules &= ~ eTypeRules_FixedArray;
                type->PERTypeInfo.Rules |= g_eDefTypeRuleSS_NonSized;
                type->BERTypeInfo.Rules &= ~ eTypeRules_FixedArray;
                type->BERTypeInfo.Rules |= g_eDefTypeRuleSS_NonSized;
            }
            pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            if (type->Rules & eTypeRules_FixedArray)
            {
                output("ASN1uint32_t count;\n");
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, type->PERTypeInfo.Root.LUpperVal, 0);
            }
            else
            if (type->Rules & eTypeRules_LengthPointer)
            {
                output("ASN1uint32_t count;\n");
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 1, 0, 0);
            }
            else
            if (type->Rules & eTypeRules_DoublyLinkedList)
            {
                output("P%s next;\n", identifier);
                output("P%s prev;\n", identifier);
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, 0, 0);
            }
            else
            if (type->Rules & eTypeRules_SinglyLinkedList)
            {
                output("P%s next;\n", identifier);
                GenType(ass, pszPrivateValueName, pszPrivateValueName, subtype,
                    0, 0, 0, 0);
            }
            else
            {
                MyAbort();
            }
            if (type->Rules & eTypeRules_LinkedListMask)
            {
                if (g_fExtraStructPtrTypeSS)
                {
                    output("} %s_Element, *%s;\n", identifier, identifier);
                }
                else
                {
                    output("} %s_Element;\n", identifier);
                }
            } else {
                output("} %s;\n", identifier);
            }
            break;

        default:

            /* use the builtin type for other types */
            output("typedef ");
            GenType(ass, a->Identifier, identifier, type, 1, 0, 0, 1);
            break;
        }

        if (! NotInFunTbl(a))
        {
            output("#define %s_%s %u\n", identifier, g_pszApiPostfix, npdu);
            switch (type->Type)
            {
            case eType_SequenceOf:
            case eType_SetOf:
                if (type->Rules & eTypeRules_LinkedListMask)
                {
                    output("#define SIZE_%s_%s_%u sizeof(%s_Element)\n", module, g_pszApiPostfix, npdu, identifier);
                    break;
                }
                // intentionally fall through
            default:
                output("#define SIZE_%s_%s_%u sizeof(%s)\n", module, g_pszApiPostfix, npdu, identifier);
                break;
            }
            npdu++;
        }

        output("\n");
    }

    /* write extern declarations for values */
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Value)
            continue;

        /* extern value wanted? */
        if (!(a->U.Value.Value->Flags & eValueFlags_GenExternValue))
            continue;
        value = GetValue(ass, a->U.Value.Value);

        /* skip value of null type */
        if (value->Type->Flags & eTypeFlags_Null)
            continue;

        /* output an extern declaration */
        switch (value->Type->Type)
        {
        case eType_ObjectIdentifier:
            if (value->Type->PrivateDirectives.fOidPacked)
            {
                output("extern ASN1encodedOID_t %s;\n", GetName(a));
                break;
            }
            else
            if (value->Type->PrivateDirectives.fOidArray || g_fOidArray)
            {
                output("extern ASN1objectidentifier2_t %s;\n", GetName(a));
                break;
            }
            // intentionally fall through
        default:
            output("extern %s %s;\n", GetTypeName(ass, value->Type), GetName(a));
            break;
        }
    }
    output("\n");

    /* write vars, functions and macros for the interface */
    output("extern ASN1module_t %s;\n", module);
    output("extern void ASN1CALL %s_Startup(void);\n", module);
    output("extern void ASN1CALL %s_Cleanup(void);\n", module);
    output("\n");

    output("/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */\n");

    g_cPDUs = npdu;
}

/* generate a type */
void
GenType(AssignmentList_t ass, char *identifier, char *completeidentifier, Type_t *type, int withmodule, int pointer, int array, int fTypeDef)
{
    char *ptr, *pszOldEnumName;
    NamedNumber_t *namedNumbers;
        char arr[20];
    char modide[256];

    /* skip null type */
    // if (type->Flags & eTypeFlags_Null)
        // return;

    /* get type name */
    ptr = pointer ? "*" : "";
    if (array)
        sprintf(arr, "[%u]", array);
    else
        arr[0] = '\0';
    identifier = Identifier2C(identifier);
    if (withmodule)
        sprintf(modide, "%s%s%s", ptr, completeidentifier, arr);
    else
        sprintf(modide, "%s%s%s", ptr, identifier, arr);

    /* output type declaration */
    switch (type->Type) {
    case eType_Reference:

        /* use struct ..._s syntax for pointer to structured type */
        if (pointer && IsStructuredType(GetReferencedType(ass, type))) {
            output("struct %s %s;\n", GetTypeName(ass, type), modide);
        } else {
            char *psz = PGetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_OctetString:
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained &&
                (! type->PrivateDirectives.fLenPtr))
            {
                if (strcmp(completeidentifier, modide) == 0)
                {
                    output("struct %s {\nASN1uint32_t length;\nASN1octet_t value[%u];\n} %s;\n",
                        modide, type->PERTypeInfo.Root.LUpperVal, modide);
                }
                else
                {
                    output("struct %s_%s {\nASN1uint32_t length;\nASN1octet_t value[%u];\n} %s;\n",
                        completeidentifier, modide, type->PERTypeInfo.Root.LUpperVal, modide);
                }
            }
            else
            {
                char *psz = GetTypeName(ass, type);
                char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
                output("%s %s%s;\n", psz, modide, psz2);
            }
        }
        else
        {
            // only support unbounded in BER
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_UTF8String:
        {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_InstanceOf:
    case eType_SequenceOf:
    case eType_SetOf:

    case eType_Boolean:
    case eType_Real:
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_ObjectDescriptor:
    case eType_BMPString:
    case eType_UniversalString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_EmbeddedPdv:
    case eType_Open:

        /* use struct ..._s syntax for pointer to structured type */
        if (pointer && IsStructuredType(type)) {
            output("struct %s %s;\n", GetTypeName(ass, type), modide);
        } else {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
        break;

    case eType_NumericString:
    case eType_PrintableString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GraphicString:
    case eType_GeneralString:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_T61String:
    case eType_TeletexString:
    case eType_CharacterString:
#ifdef ENABLE_CHAR_STR_SIZE
    {
        char *psz = GetTypeName(ass, type);
        if (g_eEncodingRule == eEncoding_Packed &&
            type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained &&
            strcmp(psz, "ASN1char_t") == 0)
        {
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s[%u];\n", psz, modide, psz2, type->PERTypeInfo.Root.LUpperVal + 1);
        }
        else
        {
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }
    }
#else
    {
        char *psz = GetTypeName(ass, type);
        char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
        output("%s %s%s;\n", psz, modide, psz2);
    }
#endif
        break;

    case eType_Enumerated:

        /* use name of the type */
    if (fTypeDef)
    {
        if (type->PrivateDirectives.pszTypeName)
        {
            output("enum %s {\n", type->PrivateDirectives.pszTypeName);
            pszOldEnumName = type->PrivateDirectives.pszTypeName;
        }
        else
        {
                output("enum %s {\n", modide);
            pszOldEnumName = "";
        }

            /* dump named numbers */
            namedNumbers = type->U.IEB.NamedNumbers;
            while (namedNumbers) {
                switch (namedNumbers->Type) {
                case eNamedNumber_Normal:
                    if (intxisuint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                        char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                        if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                        {
                    output("%s_%s = %u,\n", *pszOldEnumName ? pszOldEnumName : modide, psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                        }
                        else
                        {
                            output("%s = %u,\n", psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                    } else if (intxisint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                        char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                        if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                        {
                            output("%s_%s = %d,\n", *pszOldEnumName ? pszOldEnumName : modide, psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                else
                {
                            output("%s = %d,\n", psz,
                                intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value));
                    }
                    }
                    break;
                case eNamedNumber_ExtensionMarker:
                    break;
                }
                namedNumbers = namedNumbers->Next;
            }

            output("} %s;\n", type->PrivateDirectives.pszTypeName ? type->PrivateDirectives.pszTypeName : modide);
    }
    else
    {
        if (type->PrivateDirectives.pszTypeName)
        {
            pszOldEnumName = type->PrivateDirectives.pszTypeName;
        }
        else
        {
            pszOldEnumName = modide;
        }

        output("%s %s;\n", pszOldEnumName, modide);
    }
    break;

    case eType_Integer:

        /* use name of the type */
        {
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }

        /* dump named numbers */
        namedNumbers = type->U.IEB.NamedNumbers;
        while (namedNumbers) {
            switch (namedNumbers->Type) {
            case eNamedNumber_Normal:
                if (intxisuint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    output("#define %s_%s %u\n", completeidentifier,
                        Identifier2C(namedNumbers->U.Normal.Identifier),
                        intx2uint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value));
                } else if (intxisint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    output("#define %s_%s %d\n", completeidentifier,
                        Identifier2C(namedNumbers->U.Normal.Identifier),
                        intx2uint32(&GetValue(ass,
                        namedNumbers->U.Normal.Value)->U.Integer.Value));
                }
                break;
            case eNamedNumber_ExtensionMarker:
                break;
            }
            namedNumbers = namedNumbers->Next;
        }
        break;

    case eType_BitString: // lonchanc: split from eType_Integer

        /* use name of the type */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.cbFixedSizeBitString)
            {
                output("ASN1uint%u_t %s;\n",
                    type->PERTypeInfo.Root.cbFixedSizeBitString * 8, modide);
            }
            else
            {
                char *psz = GetTypeName(ass, type);
                char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
                output("%s %s%s;\n", psz, modide, psz2);
            }
        }
        else
        {
            // only support unbounded in BER
            char *psz = GetTypeName(ass, type);
            char *psz2 = (0 == strcmp(psz, modide)) ? "_dont_care" : "";
            output("%s %s%s;\n", psz, modide, psz2);
        }

        /* dump named numbers */
        namedNumbers = type->U.IEB.NamedNumbers;
        while (namedNumbers) {
            switch (namedNumbers->Type) {
            case eNamedNumber_Normal:
                if (intxisuint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                    ASN1uint32_t idx = intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value);
                    if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                    {
                        output("#define %s_%s 0x%lx\n", completeidentifier,
                                psz, c_BitMaskMap[idx]);
                    }
                    else
                    {
                        output("#define %s 0x%lx\n", psz, c_BitMaskMap[idx]);
                    }
                } else if (intxisint32(&GetValue(ass,
                    namedNumbers->U.Normal.Value)->U.Integer.Value)) {
                    char *psz = Identifier2C(namedNumbers->U.Normal.Identifier);
                    ASN1uint32_t idx = intx2uint32(&GetValue(ass,
                                namedNumbers->U.Normal.Value)->U.Integer.Value);
                    if (IsReservedWord(psz) || DoesEnumNameConflict(psz))
                    {
                        output("#define %s_%s 0x%lx\n", completeidentifier,
                                psz, c_BitMaskMap[idx]);
                    }
                    else
                    {
                        output("#define %s 0x%lx\n", psz, c_BitMaskMap[idx]);
                    }
                }
                break;
            case eNamedNumber_ExtensionMarker:
                break;
            }
            namedNumbers = namedNumbers->Next;
        }
        break;

    case eType_Null:
        break;

    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* write declarations for components */
void
GenComponents(AssignmentList_t ass, ComponentList_t components, char *identifier, char *completeidentifier, int *choiceoffset, int *optionaloffset)
{
    NamedType_t *namedType;
    int extended = 0;
    char cidebuf[256];

    /* add dummy for empty components */
    if (components && !components->Next &&
        components->Type == eComponent_ExtensionMarker) {
        output("char placeholder;\n");
        return;
    }

    /* write a declaration for every component */
    for (; components; components = components->Next) {
        switch (components->Type) {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            /* write a selector for optional/default components */
            namedType = components->U.NOD.NamedType;
            if ((extended && optionaloffset) ||
                components->Type == eComponent_Optional ||
                components->Type == eComponent_Default)
           {
                char *psz;
                // construct the option value
                char szOptionValue[64];
                if (g_fAllEndians)
                {
                    sprintf(szOptionValue, "ASN1_ENDIAN_%u(0x%lx)", g_cOptionValueSize, c_BitMaskMap[*optionaloffset]);
                }
                else
                {
                    sprintf(szOptionValue, "0x%lx", c_BitMaskMap[*optionaloffset]);
                }

                psz = Identifier2C(namedType->Identifier);
                if (IsReservedWord(psz) || DoesOptNameConflict(psz))
                // lonchanc: do we always put in _preset definition after extended mark???
                // yes, we do. take an example of Setup-UUIE in q931asn.asn.
                // but, the extension mark does not have option-flag definition associated.
                // || (extended && optionaloffset))
                {
                    output("#define %s_%s_%s %s\n",
                        identifier, psz, g_pszOptionPostfix,
                        &szOptionValue[0]);
                }
                else
                {
                    output("#define %s_%s %s\n",
                        psz, g_pszOptionPostfix,
                        &szOptionValue[0]);
                }
                (*optionaloffset)++;
            }
            /* write a selector for choice alternatives */
            if (choiceoffset)
            {
                char *psz = Identifier2C(namedType->Identifier);
                if (IsReservedWord(psz) || DoesChoiceNameConflict(psz))
                {
                    output("#define %s_%s_%s %d\n",
                        identifier, psz, g_pszChoicePostfix,
                        *choiceoffset);
                }
                else
                {
                    output("#define %s_%s %d\n",
                        psz, g_pszChoicePostfix,
                        *choiceoffset);
                }
                (*choiceoffset)++;
            }            
            /* write the declaration itself */
            sprintf(cidebuf, "%s_%s", completeidentifier,
                Identifier2C(namedType->Identifier));
            GenType(ass, namedType->Identifier, cidebuf, namedType->Type,
                0, GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer, 0, 0);
            break;

        case eComponent_ExtensionMarker:

            /* update the offset when an extension marker is met for a */
            /* sequence/set type */
            extended = 1;
            // lonchanc: however, the code generated by TELES handles this properly.
            // moreover, the code requires it to be rounded up.
            // as a result, we should enable this feature.
            if (optionaloffset)
                *optionaloffset = (*optionaloffset + 7) & ~7;
            break;
        }
    }
}

// The following is added by Microsoft

/* write enumerations for components */
void
GenEnumeration(AssignmentList_t ass, ComponentList_t components, char *identifier, char *completeidentifier, int *choiceoffset, int *optionaloffset)
{
    NamedType_t *namedType;
    int extended = 0;
    char cidebuf[256];

    /* write a declaration for every component */
    for (; components; components = components->Next)
    {
        switch (components->Type)
        {
        case eComponent_Normal:
        case eComponent_Optional:
        case eComponent_Default:
            namedType = components->U.NOD.NamedType;
            if (namedType && namedType->Type && namedType->Type->Type == eType_Enumerated)
            {
                output("typedef ");
                /* write the declaration itself */
                sprintf(cidebuf, "%s_%s", completeidentifier,
                    Identifier2C(namedType->Identifier));
                    GenType(ass, namedType->Identifier, cidebuf, namedType->Type,
                    0, GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer, 0, 1);
            }
        break;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\hackdir.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifdef MS_DIRECTIVE

extern int g_fPrivateDir_FieldNameToken;
extern int g_fPrivateDir_TypeNameToken;
extern int g_fPrivateDir_ValueNameToken;

extern int g_fPrivateDir_SLinked;
extern int g_fPrivateDir_DLinked;
extern int g_fPrivateDir_Public;
extern int g_fPrivateDir_Intx;
extern int g_fPrivateDir_LenPtr;
extern int g_fPrivateDir_Pointer;
extern int g_fPrivateDir_Array;
extern int g_fPrivateDir_NoMemCopy;
extern int g_fPrivateDir_NoCode;
extern int g_fPrivateDir_OidPacked;
extern int g_fPrivateDir_OidArray;

extern char g_szPrivateDirectedFieldName[64];
extern char g_szPrivateDirectedTypeName[64];
extern char g_szPrivateDirectedValueName[64];

extern int PrivateDirectives_Input ( void );
extern void GetPrivateDirective ( int *p );

#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\genber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

// encode
#define LEN_OFFSET_STR2     "nExplTagLenOff"
#define LEN_OFFSET_STR      "nLenOff"

// decode
#define DECODER_NAME        "dd"
#define STREAM_END_NAME     "di"
#define DECODER_NAME2       "pExplTagDec"
#define STREAM_END_NAME2    "pbExplTagDataEnd"

void GenBERFuncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref, char *tagref);
void GenBERStringTableSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref);
void GenBEREncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref);
void GenBEREncGenericUnextended(
    AssignmentList_t ass,
    BERTypeInfo_t *info,
    char *valref,
    char *lenref,
    char *encref,
    char *tagref);
void GenBERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, BERTypeInfo_t *, int *);
void GenBERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref);
void GenBERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref);
void GenBERDecSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref);
void GenBERDecGenericUnextended(
    AssignmentList_t ass,
    BERTypeInfo_t *info,
    char *valref,
    char *lenref,
    char *encref,
    char *tagref);

extern int g_fDecZeroMemory;
extern int g_nDbgModuleName;
extern int g_fCaseBasedOptimizer;
extern int g_fNoAssert;

extern unsigned g_cPDUs;

int IsComponentOpenType(Component_t *com)
{
    if (eType_Open == com->U.NOD.NamedType->Type->Type)
    {
        return 1;
    }
    if (eType_Reference == com->U.NOD.NamedType->Type->Type)
    {
        if (eBERSTIData_Open == com->U.NOD.NamedType->Type->BERTypeInfo.Data)
        {
            return 1;
        }
    }
    return 0;
}

Component_t * FindOpenTypeComponent(ComponentList_t components)
{
    Component_t *com = NULL;
    for (com = components; com; com = com->Next)
    {
        if (IsComponentOpenType(com))
        {
            break;
        }
    }
    return com;
}

/* write header needed for BER encodings */
void
GenBERHeader()
{
//    output("#include \"berfnlib.h\"\n");
}

/* set prototypes and function args of BER functions */
void
GetBERPrototype(Arguments_t *args)
{
    args->enccast = "ASN1encoding_t, ASN1uint32_t, void *";
    args->encfunc = "ASN1encoding_t enc, ASN1uint32_t tag, %s *val";
    args->Pencfunc = "ASN1encoding_t enc, ASN1uint32_t tag, P%s *val";
    args->deccast = "ASN1decoding_t, ASN1uint32_t, void *";
    args->decfunc = "ASN1decoding_t dec, ASN1uint32_t tag, %s *val";
    args->Pdecfunc = "ASN1decoding_t dec, ASN1uint32_t tag, P%s *val";
    args->freecast = "void *";
    args->freefunc = "%s *val";
    args->Pfreefunc = "P%s *val";
    args->cmpcast = "void *, void *";
    args->cmpfunc = "%s *val1, %s *val2";
    args->Pcmpfunc = "P%s *val1, P%s *val2";
}

/* write initialization function needed for BER encodings */
void
GenBERInit(AssignmentList_t ass, char *module)
{
    char *pszRule;
    switch (g_eSubEncodingRule)
    {
    default:
    case eSubEncoding_Basic:
        pszRule = "ASN1_BER_RULE_BER";
        break;
    case eSubEncoding_Canonical:
        pszRule = "ASN1_BER_RULE_CER";
        break;
    case eSubEncoding_Distinguished:
        pszRule = "ASN1_BER_RULE_DER";
        break;
    }
    output("%s = ASN1_CreateModule(0x%x, %s, %s, %d, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x%lx);\n",
        module,
        ASN1_THIS_VERSION,
        pszRule,
        g_fNoAssert ? "ASN1FLAGS_NOASSERT" : "ASN1FLAGS_NONE",
        g_cPDUs,
        g_nDbgModuleName);
}

/* convert a tag to an uint32_t: */
/* bits  0..29: tag value */
/* bits 30..31: tag class */
uint32_t
Tag2uint32(AssignmentList_t ass, Tag_t *tag)
{
    uint32_t tagvalue;
    uint32_t tagclass;

    tagvalue = intx2uint32(&GetValue(ass, tag->Tag)->U.Integer.Value);
    tagclass = tag->Class; /* multiple of 0x40 */
    return (tagclass << 24) | tagvalue;
}

/* generate encoding of a tag */
uint32_t GenBEREncTag(char *pszLenOffName, AssignmentList_t ass, BERTypeInfo_t *info, char *encref, char **tagref)
{
    Tag_t *tag;
    uint32_t tagvalue;
    uint32_t neoc;
    char tagbuf[64];
    int first;

    neoc = 0;
    first = 1;
    if (*tagref)
        strcpy(tagbuf, *tagref);
    else
        strcpy(tagbuf, "0");

    /* we have to examine all tags */
    for (tag = info->Tags; tag; tag = tag ? tag->Next : NULL) {

        /* get value of tag */
        tagvalue = Tag2uint32(ass, tag);
        while (tag && tag->Type == eTagType_Implicit)
            tag = tag->Next;

        /* get tag */
        if (first && *tagref) {
            sprintf(tagbuf, "%s ? %s : 0x%x", *tagref, *tagref, tagvalue);
        } else {
            sprintf(tagbuf, "0x%x", tagvalue);
        }

        /* encode explicit tag */
        if (tag) {
            char szLenOff[24];
            sprintf(&szLenOff[0], "%s%u", pszLenOffName, neoc);
            outputvar("ASN1uint32_t %s;\n", &szLenOff[0]);
            output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagbuf, &szLenOff[0]);
            output("return 0;\n");
            neoc++;
            strcpy(tagbuf, "0");
        }
        first = 0;
    }

    /* return last implicit tag */
    *tagref = strdup(tagbuf);

    return neoc;
}

/* generate encoding of end of tag */
void
GenBEREncTagEnd(char *pszLenOffName, uint32_t neoc, char *encref)
{
    while (neoc--)
    {
        char szLenOff[24];
        sprintf(&szLenOff[0], "%s%u", pszLenOffName, neoc);
        outputvar("ASN1uint32_t %s;\n", &szLenOff[0]);
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, &szLenOff[0]);
        output("return 0;\n");
    }
}

/* generate decoding of a tag */
uint32_t
GenBERDecTag(char *pszDecoderName, char *pszOctetPtrName, AssignmentList_t ass, BERTypeInfo_t *info, char **encref, char **tagref)
{
    Tag_t *tag;
    uint32_t tagvalue;
    uint32_t depth;
    char encbuf[16];
    char tagbuf[64];
    int first;

    depth = 0;
    first = 1;
    if (*tagref)
        strcpy(tagbuf, *tagref);
    else
        strcpy(tagbuf, "0");

    /* we have to examine all tags */
    for (tag = info->Tags; tag; tag = tag ? tag->Next : NULL) {

        /* get value of tag */
        tagvalue = Tag2uint32(ass, tag);
        while (tag && tag->Type == eTagType_Implicit)
            tag = tag->Next;

        /* get tag */
        if (first && *tagref) {
            sprintf(tagbuf, "%s ? %s : 0x%x", *tagref, *tagref, tagvalue);
        } else {
            sprintf(tagbuf, "0x%x", tagvalue);
        }
        
        /* decode explicit tag */
        if (tag)
        {
            char szDecName[24];
            char szPtrName[24];
            sprintf(&szDecName[0], "%s%u", pszDecoderName, depth);
            sprintf(&szPtrName[0], "%s%u", pszOctetPtrName, depth);
            outputvar("ASN1decoding_t %s;\n",&szDecName[0]);
            outputvar("ASN1octet_t *%s;\n", &szPtrName[0]);
            output("if (!ASN1BERDecExplicitTag(%s, %s, &%s, &%s))\n",
                *encref, tagbuf, &szDecName[0], &szPtrName[0]);
            output("return 0;\n");
            *encref = strdup(&szDecName[0]);
            depth++;
            strcpy(tagbuf, "0");
        }
        first = 0;
    }

    /* return last implicit tag */
    *tagref = strdup(tagbuf);

    return depth;
}

/* generate decoding of end of tag */
void
GenBERDecTagEnd(char *pszDecoderName, char *pszOctetPtrName, uint32_t depth, char *encref)
{
    char szDecName[24];
    char szPtrName[24];
    uint32_t i;

    for (i = 0; i < depth; i++)
    {
        sprintf(&szDecName[0], "%s%u", pszDecoderName, depth - i - 1);
        sprintf(&szPtrName[0], "%s%u", pszOctetPtrName, depth - i - 1);
        if (i != depth - 1)
        {
            output("if (!ASN1BERDecEndOfContents(%s%u, %s, %s))\n",
                pszDecoderName, depth - i - 2, &szDecName[0], &szPtrName[0]);
        }
        else
        {
            output("if (!ASN1BERDecEndOfContents(%s, %s, %s))\n",
                encref, &szDecName[0], &szPtrName[0]);
        }
        output("return 0;\n");
    }
}

/* generate function body for a type */
void GenBERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *encref;
    char *valref;

    /* get some informations */
    type = at->U.Type.Type;
    switch (et) {
    case eStringTable:
        valref = encref = "";
        break;
    case eEncode:
        encref = "enc";
        valref = "val";
        break;
    case eDecode:
        encref = "dec";
        valref = "val";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
    case eType_SequenceOf:
    case eType_SetOf:
        GenBERFuncSimpleType(ass, &type->BERTypeInfo, Dereference(valref), et, encref, "tag");
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        GenBERFuncSequenceSetType(ass, module, at, valref, encref, et, "tag");
        break;

    case eType_Choice:
        GenBERFuncChoiceType(ass, module, at, valref, encref, et, "tag");
        break;

    case eType_Selection:
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate function body for components */
void GenBERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, BERTypeInfo_t *info, int *pfContainOpenTypeComWithDefTags)
{
    BERSTIData_e data = info->Data;
    Component_t *com;
    NamedType_t *namedType;
    char *ide;
    int conditional, inextension;
    uint32_t flg;
    Tag_t *tags;
    unsigned int first_tag, last_tag;
    int fDefTags;
    int fOpenTypeComponent;
    char valbuf[256];
    char typebuf[256];

    *pfContainOpenTypeComWithDefTags = 0;

    /* emit components */
    inextension = 0;
    for (com = components; com; com = com->Next)
    {
        fDefTags = 0; // safety net
        fOpenTypeComponent = 0; // safety net

        /* check for extension marker */
        if (com->Type == eComponent_ExtensionMarker) {
            inextension = 1;

            /* update index into optional field for sequence/set */
            if (data != eBERSTIData_Choice)
                optindex = (optindex + 7) & ~7;
            continue;
        }

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);

        /* check if optional/default component is present or choice is */
        /* selected*/
        conditional = 0;
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            if (data == eBERSTIData_Choice) {
                output("case %d:\n", optindex);
                conditional = 1;
                optindex++;
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    output("if (%s[%u] & 0x%x) {\n", oref,
                        optindex / 8, 0x80 >> (optindex & 7));
                    conditional = 1;
                    optindex++;
                }
            }
            break;
        case eDecode:
            if (data == eBERSTIData_Sequence &&
                com->Type != eComponent_Optional &&
                com->Type != eComponent_Default &&
                !inextension)
                break;

            fOpenTypeComponent = IsComponentOpenType(com);
            if (fOpenTypeComponent)
            {
                const unsigned int c_nDefFirstTag = 0x80000001;
                const unsigned int c_nDefLastTag  = 0x8000001f;
                unsigned int nTag = c_nDefFirstTag;
                tags = com->U.NOD.NamedType->Type->FirstTags;
                first_tag = Tag2uint32(ass, com->U.NOD.NamedType->Type->FirstTags);
                fDefTags = 1; // initial value
                while (tags->Next)
                {
                    fDefTags = fDefTags && (Tag2uint32(ass, tags) == nTag++);
                    tags = tags->Next;
                }
                last_tag = Tag2uint32(ass, tags);
                fDefTags = fDefTags && (c_nDefFirstTag == first_tag) && (c_nDefLastTag == last_tag);
                *pfContainOpenTypeComWithDefTags = *pfContainOpenTypeComWithDefTags || fDefTags;
            }
            if (data == eBERSTIData_Sequence)
            {
                if (fOpenTypeComponent)
                {
                    outputvar("ASN1uint32_t t;\n");
                    output("if (ASN1BERDecPeekTag(%s, &t)) {\n", encref);
                }
                else
                {
                    outputvar("ASN1uint32_t t;\n");
                    output("ASN1BERDecPeekTag(%s, &t);\n", encref);
                }
                if (! fDefTags)
                {
                    output("if (");
                }
                flg = 0;
            }
            if (eBERSTIData_Sequence == data && fDefTags && fOpenTypeComponent)
            {
            #if 0
                if (first_tag == last_tag)
                {
                    output("0x%x == t", first_tag);
                }
                else
                {
                    output("0x%x <= t && t <= 0x%x", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            if (eBERSTIData_Set == data && fDefTags && fOpenTypeComponent)
            {
                output("default:\n");
            #if 1
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("#error \"Untagged open type cannot be in the SET construct with an extension mark.\nPlease manually fix the source code.\"");
                    output("ASSERT(0); /* Untagged open type cannot be in the SET construct with an extension mark */\n");
                    output("if (1) {\n");
                }
            #else
                if (first_tag == last_tag)
                {
                    output("if (0x%x == t) {\n", first_tag);
                }
                else
                {
                    output("if (0x%x <= t && t <= 0x%x) {\n", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            if (eBERSTIData_Choice == data && fDefTags && fOpenTypeComponent)
            {
                output("default:\n");
            #if 1
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("#error \"Untagged open type cannot be in the CHOICE construct with an extension mark.\nPlease manually fix the source code.\"");
                    output("ASSERT(0); /* Untagged open type cannot be in the CHOICE construct with an extension mark */\n");
                    output("if (1) {\n");
                }
            #else
                if (first_tag == last_tag)
                {
                    output("if (0x%x == t) {\n", first_tag);
                }
                else
                {
                    output("if (0x%x <= t && t <= 0x%x) {\n", first_tag, last_tag);
                }
            #endif
                conditional = 1;
            }
            else
            {
                for (tags = com->U.NOD.NamedType->Type->FirstTags; tags; tags = tags->Next)
                {
                    switch (data)
                    {
                    case eBERSTIData_Choice:
                        output("case 0x%x:\n", Tag2uint32(ass, tags));
                        break;
                    case eBERSTIData_Set:
                        output("case 0x%x:\n", Tag2uint32(ass, tags));
                        break;
                    case eBERSTIData_Sequence:
                        if (flg)
                            output(" || ");
                        output("t == 0x%x", Tag2uint32(ass, tags));
                        flg = 1;
                        break;
                    default:
                        if (flg)
                            output(" || ");
                        output("t == 0x%x", Tag2uint32(ass, tags));
                        flg = 1;
                        break;
                    }
                }
            }
            if (data == eBERSTIData_Choice) {
                output("(%s)->choice = %d;\n", valref, optindex);
                conditional = 1;
                optindex++;
                break;
            } else {
                if (data == eBERSTIData_Sequence)
                {
                    if (! fDefTags)
                    {
                        output(") {\n");
                    }
                }
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    output("%s[%u] |= 0x%x;\n", oref,
                        optindex / 8, 0x80 >> (optindex & 7));
                    optindex++;
                }
                conditional = 1;
            }
            break;
        }

        /* dereference pointer if pointer directive used */
        if (data == eBERSTIData_Choice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->u.%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->u.%s", valref, ide);
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->%s", valref, ide);
        }

        /* allocate memory if decoding and pointer directive used */
        if (et == eDecode &&
            (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) &&
            !(GetType(ass, namedType->Type)->Flags & eTypeFlags_Null)) {
            sprintf(typebuf, "%s *",
                GetTypeName(ass, namedType->Type));
            output("if (!(%s = (%s)ASN1DecAlloc(%s, sizeof(%s))))\n",
                Reference(valbuf), typebuf, encref, valbuf);
            output("return 0;\n");
        }

        /* handle subtype value */
        GenBERFuncSimpleType(ass, &namedType->Type->BERTypeInfo,
            valbuf, et, encref, NULL);

        if (eDecode == et && fOpenTypeComponent)
        {
            if (eBERSTIData_Set == data && fDefTags)
            {
                if (info->Flags & eTypeFlags_ExtensionMarker)
                {
                    output("} else {\n");
                    output("if (!ASN1BERDecSkip(%s))\n", encref);
                    output("return 0;\n");
                    output("}\n");
                }
            }
            else
            if (eBERSTIData_Sequence == data)
            {
                if (! fDefTags)
                {
                    output("}\n");
                }
            }
        }
        /* end of check for presence of optional/default component */
        if (data == eBERSTIData_Set && et == eDecode ||
            data == eBERSTIData_Choice)
        {
            if (conditional)
                output("break;\n");
        }
        else
        {
            if (conditional)
                output("}\n");
        }
    }
}

/* generate function body for sequence/set type */
void
GenBERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref)
{
    Type_t *type = at->U.Type.Type;
    BERTypeInfo_t *info = &type->BERTypeInfo;
    uint32_t optionals, extensions;
    ComponentList_t components;
    char *oldencref;
    char *oldencref2;
    uint32_t neoc, depth;
    int fContainOpenTypeComWithDefTags = 0;
    char obuf[256];
    
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;

    /* handle tag and length */
    switch (et) {
    case eEncode:
        neoc = GenBEREncTag(LEN_OFFSET_STR2, ass, info, encref, &tagref);
        outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
        output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
        output("return 0;\n");
        // neoc++;
        break;
    case eDecode:
        outputvar("ASN1decoding_t dd;\n");
        outputvar("ASN1octet_t *di;\n");
        oldencref = encref;
        depth = GenBERDecTag(DECODER_NAME2, STREAM_END_NAME2, ass, info, &encref, &tagref);
        oldencref2 = encref;
        output("if (!ASN1BERDecExplicitTag(%s, %s, &dd, &di))\n",
            encref, tagref);
        output("return 0;\n");
        encref = "dd";
        if (optionals || extensions)
            output("ZeroMemory((%s)->o, %d);\n", valref,
                (optionals + 7) / 8 + (extensions + 7) / 8);
        break;
    }

    /* set/clear missing bits in optional/default bit field */
    GenFuncSequenceSetOptionals(ass, valref, components, optionals, extensions,
        obuf, et);

    /* create switch statement */
    if (et == eDecode) {
        switch (info->Data) {
        case eBERSTIData_Set:
            outputvar("ASN1uint32_t t;\n");
            output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);
            output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
            output("return 0;\n");
            output("switch (t) {\n");
            break;
        }
    }

    /* emit components */
    GenBERFuncComponents(ass, module, 0, components,
        valref, encref, obuf, et, info, &fContainOpenTypeComWithDefTags);

    /* end of switch statement */
    if (et == eDecode) {
        switch (info->Data) {
        case eBERSTIData_Set:
            // if (NULL == FindOpenTypeComponent(components))
            if (! fContainOpenTypeComWithDefTags)
            {
                output("default:\n");
                if (info->Flags & eTypeFlags_ExtensionMarker) {
                    output("if (!ASN1BERDecSkip(%s))\n", encref);
                    output("return 0;\n");
                    output("break;\n");
                } else {
                    output("ASN1DecSetError(%s, ASN1_ERR_CORRUPT);\n", encref);
                    output("return 0;\n");
                }
            }
            output("}\n");
            output("}\n");
            break;
        }
    }

    /* some user-friendly assignments for non-present optional/default */
    /* components */
    GenFuncSequenceSetDefaults(ass, valref, components, obuf, et);

    /* generate end of contents */
    switch (et) {
    case eEncode:
        /* encode the end-of-contents octets */
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
        output("return 0;\n");

        GenBEREncTagEnd(LEN_OFFSET_STR2, neoc, encref);
        break;
    case eDecode:
        if ((info->Flags & eTypeFlags_ExtensionMarker) &&
            info->Data != eBERSTIData_Set) {
            output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);
            output("if (!ASN1BERDecSkip(%s))\n", encref);
            output("return 0;\n");
            output("}\n");
        }
        output("if (!ASN1BERDecEndOfContents(%s, dd, di))\n", oldencref2);
        output("return 0;\n");
        GenBERDecTagEnd(DECODER_NAME2, STREAM_END_NAME2, depth, oldencref);
        break;
    }
}

/* generate function body for choice type */
// lonchanc: we should re-visit the work about ASN1_CHOICE_BASE.
// the change for BER is not complete!!! BUGBUG
void
GenBERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et, char *tagref)
{
    Type_t *type;
    BERTypeInfo_t *info;
    Component_t *components, *c;
    uint32_t neoc, depth;
    char *oldencref;
    uint32_t ncomponents;
    int fContainOpenTypeComWithDefTags = 0;

    /* get some informations */
    type = at->U.Type.Type;
    info = &type->BERTypeInfo;
    components = type->U.SSC.Components;
    for (c = components, ncomponents = 0; c; c = c->Next) {
        switch (c->Type) {
        case eComponent_Normal:
            ncomponents++;
            break;
        }
    }

    /* encode explicit tags */
    switch (et) {
    case eEncode:
        neoc = GenBEREncTag(LEN_OFFSET_STR2, ass, info, encref, &tagref);
        break;
    case eDecode:
        oldencref = encref;
        depth = GenBERDecTag(DECODER_NAME2, STREAM_END_NAME2, ass, info, &encref, &tagref);
        break;
    }

    /* create switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        output("switch ((%s)->choice) {\n", valref);
        break;
    case eDecode:
        outputvar("ASN1uint32_t t;\n");
        output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
        output("return 0;\n");
        output("switch (t) {\n");
        break;
    }

    /* generate components */
    GenBERFuncComponents(ass, module, ASN1_CHOICE_BASE, components,
        valref, encref, NULL, et, info, &fContainOpenTypeComWithDefTags);

    /* end of switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        // debug purpose
        output("default:\n\t/* impossible */\n");
        output("ASN1EncSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        output("}\n");
        break;
    case eDecode:
        if (fContainOpenTypeComWithDefTags)
        {
            if (info->Flags & eTypeFlags_ExtensionMarker)
            {
                output("} else {\n");
                output("(%s)->choice = %d;\n", valref, ASN1_CHOICE_BASE + ncomponents); /* unknown extens.*/
                output("if (!ASN1BERDecSkip(%s))\n", encref);
                output("return 0;\n");
                output("}\n");
                output("break;\n");
            }
        }
        else
        {
            output("default:\n");
            if (info->Flags & eTypeFlags_ExtensionMarker) {
                output("(%s)->choice = %d;\n", valref, ASN1_CHOICE_BASE + ncomponents); /* unknown extens.*/
                output("if (!ASN1BERDecSkip(%s))\n", encref);
                output("return 0;\n");
                output("break;\n");
            } else {
                output("ASN1DecSetError(%s, ASN1_ERR_CORRUPT);\n", encref);
                output("return 0;\n");
            }
        }
        output("}\n");
        break;
    }

    /* generate end of contents */
    switch (et) {
    case eEncode:
        GenBEREncTagEnd(LEN_OFFSET_STR2, neoc, encref);
        break;
    case eDecode:
        GenBERDecTagEnd(DECODER_NAME2, STREAM_END_NAME2, depth, oldencref);
    }
}

/* generate function body for simple type */
void
GenBERFuncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref, char *tagref)
{
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
        GenBEREncSimpleType(ass, info, valref, encref, tagref);
        break;
    case eDecode:
        GenBERDecSimpleType(ass, info, valref, encref, tagref);
        break;
    }
}

/* generate encoding statements for a simple value */
void
GenBEREncSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref)
{
    char *lenref;
    char lenbuf[256], valbuf[256];
    BERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Data) {
    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:
    case eBERSTIData_OctetString:
    case eBERSTIData_UTF8String:
    case eBERSTIData_String:

        /* length and value of bit string, octet string and string */
        if (*valref != '*')
        {
            sprintf(lenbuf, "(%s).length", valref);
            sprintf(valbuf, "(%s).value", valref);
        }
        else
        {
            sprintf(lenbuf, "(%s)->length", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
        }
        lenref = lenbuf;
        valref = valbuf;

        /* check for remove-zero-bits bit string */
        if (inf.Data == eBERSTIData_RZBBitString) {
            outputvar("ASN1uint32_t r;\n");
            output("r = %s;\n", lenref);
            output("ASN1BEREncRemoveZeroBits(&r, %s);\n",
                valref);
            lenref = "r";
        }
        break;

    case eBERSTIData_SequenceOf:
    case eBERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            sprintf(lenbuf, "(%s)->count", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            lenref = "t";
        }
        else
        {
            MyAbort();
        }
        break;

    case eBERSTIData_ZeroString:

        /* length of a zero-terminated string value */
        outputvar("ASN1uint32_t t;\n");
        output("t = lstrlenA(%s);\n", valref);
        lenref = "t";
        break;

    case eBERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (BerOptCase_IsBoolean(&inf))
            {
                break;
            }
        }

        /* value of a boolean value */
        sprintf(valbuf, "(%s) ? 255 : 0", valref);
        valref = valbuf;
        inf.Data = eBERSTIData_Unsigned;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* generate the encoding of the value */
    GenBEREncGenericUnextended(ass, &inf, valref, lenref, encref, tagref);
}

/* generate encoding statements for a simple value (after some special */
/* handling has been done) */
void
GenBEREncGenericUnextended(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *lenref, char *encref, char *tagref)
{
    uint32_t neoc;
    char *p;
    char valbuf[256];

    /* encode tags */
    neoc = GenBEREncTag(LEN_OFFSET_STR, ass, info, encref, &tagref);

    /* encode length and value */
    switch (info->Data) {
    case eBERSTIData_Null:

        /* encode null value */
        output("if (!ASN1BEREncNull(%s, %s))\n", encref, tagref);
        output("return 0;\n");
        break;

    case eBERSTIData_Unsigned:
    case eBERSTIData_Integer:

        /* encode integer value; check for intx_t representation */
        if (info->NOctets) {
            if (info->Data == eBERSTIData_Unsigned) {
                output("if (!ASN1BEREncU32(%s, %s, %s))\n",
                    encref, tagref, valref);
            } else {
                output("if (!ASN1BEREncS32(%s, %s, %s))\n",
                    encref, tagref, valref);
            }
            output("return 0;\n");
        } else {
            output("if (!ASN1BEREncSX(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Real:

        /* encode real value; check for real_t representation */
        if (info->NOctets)
            output("if (!ASN1BEREncDouble(%s, %s, %s))\n",
                encref, tagref, valref);
        else
            output("if (!ASN1BEREncReal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:

        /* encode bit string value */
        output("if (!ASN1%cEREncBitString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_OctetString:

        /* encode octet string value */
        output("if (!ASN1%cEREncOctetString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_UTF8String:

        /* encode octet string value */
        output("if (!ASN1%cEREncUTF8String(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_SetOf:

        /* encoding of a set of value */
        if (eSubEncoding_Canonical      == g_eSubEncodingRule ||
            eSubEncoding_Distinguished  == g_eSubEncodingRule)
        {
            /* encoding of a set of value for DER/CER */

            /* lists will require an additional iterator */
            if (info->Rules &
                (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
            {
                outputvar("P%s f;\n", info->Identifier);
            }

            /* encode the tag and infinite-length first */
            outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
            output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
            output("return 0;\n");

            /* create the SetOf block */
            outputvar("void *pBlk;\n");
            output("if (!ASN1DEREncBeginBlk(%s, ASN1_DER_SET_OF_BLOCK, &pBlk))\n", encref);
            output("return 0;\n");

            /* encode all elements */
            /* get the name of the elements */
            /* advance the iterator for lists */
            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
            }
            else if (info->Rules & eTypeRules_LinkedListMask)
            {
                output("for (f = %s; f; f = f->next) {\n", valref);
                sprintf(valbuf, "f->value");
            }
            else
            {
                MyAbort();
            }

            /* create the secondary encoder structure */
            outputvar("ASN1encoding_t enc2;\n");
            output("if (!ASN1DEREncNewBlkElement(pBlk, &enc2))\n");
            output("return 0;\n");

            /* encode the element */
            GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
                eEncode, "enc2", NULL);

            /* create the secondary encoder structure */
            output("if (!ASN1DEREncFlushBlkElement(pBlk))\n");
            output("return 0;\n");

            /* end of loop */
            output("}\n");

            /* create the secondary encoder structure */
            output("if (!ASN1DEREncEndBlk(pBlk))\n");
            output("return 0;\n");

            /* encode the end-of-contents octets */
            output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
            output("return 0;\n");
            break;
        }

        /*FALLTHROUGH*/

    case eBERSTIData_SequenceOf:

        /* encoding of a sequence of value */

        /* lists will require an additional iterator */
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            outputvar("P%s f;\n", info->Identifier);
        }

        /* encode the tag and infinite-length first */
        outputvar("ASN1uint32_t %s;\n", LEN_OFFSET_STR);
        output("if (!ASN1BEREncExplicitTag(%s, %s, &%s))\n", encref, tagref, LEN_OFFSET_STR);
        output("return 0;\n");

        /* encode all elements */
        /* get the name of the elements */
        /* advance the iterator for lists */
        if (info->Rules & eTypeRules_PointerArrayMask)
        {
            outputvar("ASN1uint32_t i;\n");
            output("for (i = 0; i < %s; i++) {\n", lenref);
            sprintf(valbuf, "(%s)[i]", valref);
        }
        else if (info->Rules & eTypeRules_LinkedListMask)
        {
            output("for (f = %s; f; f = f->next) {\n", valref);
            sprintf(valbuf, "f->value");
        }
        else
		{
            MyAbort();
		}

        /* encode the element */
        GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
            eEncode, encref, NULL);

        /* end of loop */
        output("}\n");

        /* encode the end-of-contents octets */
        output("if (!ASN1BEREncEndOfContents(%s, %s))\n", encref, LEN_OFFSET_STR);
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdentifier:

        /* encode an object identifier value */
        if (info->pPrivateDirectives->fOidArray  || g_fOidArray)
        {
            output("if (!ASN1BEREncObjectIdentifier2(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1BEREncObjectIdentifier(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdEncoded:

        /* encode an encoded object identifier value */
        output("if (!ASN1BEREncEoid(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_String:
    case eBERSTIData_ZeroString:

        /* encode a string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1%cEREnc%sString(%s, %s, %s, %s))\n",
            g_eSubEncodingRule, p, encref, tagref, lenref, valref);
        output("return 0;\n");
        break;

    case eBERSTIData_External:

        /* encode an external value */
        output("if (!ASN1BEREncExternal(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_EmbeddedPdv:

        /* encode an embedded pdv value */
        output("if (!ASN1BEREncEmbeddedPdv(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_MultibyteString:

        /* encode a multibyte string value */
        if (info->Rules & eTypeRules_LengthPointer)
        {
            output("if (!ASN1%cEREncMultibyteString(%s, %s, %s))\n",
                g_eSubEncodingRule, encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1%cEREncZeroMultibyteString(%s, %s, %s))\n",
                g_eSubEncodingRule, encref, tagref, valref);
        }
        output("return 0;\n");
        break;

    case eBERSTIData_UnrestrictedString:

        /* encode an character string value */
        output("if (!ASN1BEREncCharacterString(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_GeneralizedTime:

        /* encode a generalized time value */
        output("if (!ASN1%cEREncGeneralizedTime(%s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTCTime:

        /* encode a utc time value */
        output("if (!ASN1%cEREncUTCTime(%s, %s, %s))\n",
            g_eSubEncodingRule, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Open:
        
        /* encode an open type value */
        output("if (!ASN1BEREncOpenType(%s, %s))\n",
            encref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Reference:

        /* call other encoding function for reference types */
        output("if (!ASN1Enc_%s(%s, %s, %s))\n",
            Identifier2C(info->SubIdentifier),
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Boolean:
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1BEREncBool(%s, %s, %s))\n", encref, tagref, valref);
            output("return 0;\n");
        }
        break;
    }

    /* encode the end of tag octets */
    GenBEREncTagEnd(LEN_OFFSET_STR, neoc, encref);
}

/* generate decoding statements for a simple value */
void
GenBERDecSimpleType(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *encref, char *tagref)
{
    char valbuf[256], lenbuf[256];
    char *lenref;
    BERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Data) {
    case eBERSTIData_SequenceOf:
    case eBERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            sprintf(lenbuf, "(%s)->count", Reference(valref));
            sprintf(valbuf, "(%s)->value", Reference(valref));
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            /* use a loop for sequence of/set of value with */
            /* list representation */
            outputvar("P%s *f;\n", inf.Identifier);
            lenref = NULL;
        }
        else
        {
            MyAbort();
        }
        break;

    case eBERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (BerOptCase_IsBoolean(&inf))
            {
                break;
            }
        }

        /* boolean value */
        inf.Data = eBERSTIData_Unsigned;
        lenref = NULL;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* generate the decoding of the value */
    GenBERDecGenericUnextended(ass, &inf, valref, lenref, encref, tagref);
}

/* generate decoding statements for a simple value (after some special */
/* handling has been done) */
void
GenBERDecGenericUnextended(AssignmentList_t ass, BERTypeInfo_t *info, char *valref, char *lenref, char *encref, char *tagref)
{
    uint32_t depth;
    char *p;
    char *oldencref;
    char *oldencref2;
    char valbuf[256];

    /* decode tags */
    oldencref = encref;
    depth = GenBERDecTag(DECODER_NAME, STREAM_END_NAME, ass, info, &encref, &tagref);

    /* decode length and value */
    switch (info->Data) {
    case eBERSTIData_Null:

        /* decode null value */
        output("if (!ASN1BERDecNull(%s, %s))\n", encref, tagref);
        output("return 0;\n");
        break;

    case eBERSTIData_Integer:

        /* decode integer value; check for intx_t representation */
        if (!info->NOctets) {
            output("if (!ASN1BERDecSXVal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        } else {
            output("if (!ASN1BERDecS%dVal(%s, %s, %s))\n",
                info->NOctets * 8, encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Unsigned:
        if (!info->NOctets) {
            output("if (!ASN1BERDecSXVal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
            output("return 0;\n");
        } else {
            unsigned long cBits = info->NOctets * 8;
            if (32 == cBits)
            {
                output("if (!ASN1BERDecU32Val(%s, %s, (ASN1uint32_t *) %s))\n",
                    encref, tagref, Reference(valref));
            }
            else
            {
                output("if (!ASN1BERDecU%uVal(%s, %s, %s))\n",
                    cBits, encref, tagref, Reference(valref));
            }
            output("return 0;\n");
        }
        break;

    case eBERSTIData_Real:

        /* decode real value; check for real_t representation */
        if (info->NOctets)
            output("if (!ASN1BERDecDouble(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        else
            output("if (!ASN1BERDecReal(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_BitString:
    case eBERSTIData_RZBBitString:

        /* decode bit string value */
        output("if (!ASN1BERDecBitString%s(%s, %s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_OctetString:

        /* decode octet string value */
        output("if (!ASN1BERDecOctetString%s(%s, %s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTF8String:

        /* decode octet string value */
        output("if (!ASN1BERDecUTF8String(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_SetOf:
    case eBERSTIData_SequenceOf:

        /* encoding of a set of/sequence of value */
        outputvar("ASN1decoding_t dd;\n");
        outputvar("ASN1octet_t *di;\n");

        /* decode the tag and length first */
        output("if (!ASN1BERDecExplicitTag(%s, %s, &dd, &di))\n",
            encref, tagref);
        output("return 0;\n");

        oldencref2 = encref;
        encref = "dd";
        outputvar("ASN1uint32_t t;\n");
        if (info->Rules & eTypeRules_LengthPointer)
		{
            /* get length and value of sequence of/set of value with */
            /* length-pointer representation */
            outputvar("ASN1uint32_t n;\n");
            output("%s = n = 0;\n", lenref);
            output("%s = NULL;\n", valref);
        }
		else
        if (info->Rules & eTypeRules_FixedArray)
		{
            /* get length and value of sequence of/set of value with */
			/* fixed-array representation*/
            output("%s = 0;\n", lenref);
		}
		else
		if (info->Rules & eTypeRules_SinglyLinkedList)
		{
            /* use additional iterator for sequence of/set of value with */
            /* singly-linked-list representation */
            outputvar("P%s *f;\n", info->Identifier);
            output("f = %s;\n", Reference(valref));

        }
		else
		if (info->Rules & eTypeRules_DoublyLinkedList)
		{
            /* use additional iterator and iterator pointer for sequence of/ */
            /* set of value with doubly-linked-list representation */
            outputvar("P%s *f;\n", info->Identifier);
            outputvar("%s b;\n", info->Identifier);
            output("f = %s;\n", Reference(valref));
            output("b = NULL;\n");
        }

        /* decode while not constructed is not empty */
        output("while (ASN1BERDecNotEndOfContents(%s, di)) {\n", encref);

        /* get next tag */
        output("if (!ASN1BERDecPeekTag(%s, &t))\n", encref);
        output("return 0;\n");

        if (info->Rules & eTypeRules_PointerArrayMask)
        {
            if (info->Rules & eTypeRules_LengthPointer)
            {
                /* resize allocated array if it is too small */
                output("if (%s >= n) {\n", lenref);
                output("void *pvASN1DecRealloc;\n");
                output("n = n ? (n << 1) : 16;\n");
                output("if (!(pvASN1DecRealloc = ASN1DecRealloc(%s, %s, n * sizeof(%s))))\n",
                    encref,
                    valref, Dereference(valref));
                output("return 0;\n");
                output("%s = (%s *) pvASN1DecRealloc;\n",
                    valref, GetTypeName(ass, info->SubType));
                output("}\n");
            }
            /* get the name of the value */
            sprintf(valbuf, "(%s)[%s]", valref, lenref);
        }
        else
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            /* allocate one element */
            output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                info->Identifier, encref);
            output("return 0;\n");

            /* get the name of the value */
            sprintf(valbuf, "(*f)->value");
        }

        /* decode the element */
        GenBERFuncSimpleType(ass, &info->SubType->BERTypeInfo, valbuf,
            eDecode, encref, NULL);

        if (info->Rules &
            (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {

            /* advance the length of the array contents */
            output("(%s)++;\n", lenref);

        } else if (info->Rules & eTypeRules_SinglyLinkedList) {

            /* adjust the pointer for the next element */
            output("f = &(*f)->next;\n");

        } else if (info->Rules & eTypeRules_DoublyLinkedList) {

            /* adjust the pointer for the next element and */
            /* update the back pointer */
            output("(*f)->prev = b;\n");
            output("b = *f;\n");
            output("f = &b->next;\n");
        }

        /* end of loop */
        output("}\n");

        if (info->Rules & eTypeRules_LengthPointer)
        {
        #if 0 // lonchanc: no need to shrink the memory thru realloc
            // lonchanc: no need to allocate memory for eTypeRules_FixedArray
            /* resize allocated array to real size */
            output("if (n != %s) {\n", lenref);
            output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, %s * sizeof(%s))))\n",
                valref, GetTypeName(ass, info->SubType), encref,
                valref, lenref, Dereference(valref));
            output("return 0;\n");
            output("}\n");
        #endif // 0
        }
        else
        if (info->Rules & eTypeRules_LinkedListMask)
        {
            /* terminate the list */
            output("*f = NULL;\n");
        }

        /* decode end-of-contents */
        output("if (!ASN1BERDecEndOfContents(%s, dd, di))\n", oldencref2);
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdentifier:

        if (info->pPrivateDirectives->fOidArray || g_fOidArray)
        {
            /* decode an object identifier value */
            output("if (!ASN1BERDecObjectIdentifier2(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            /* decode an object identifier value */
            output("if (!ASN1BERDecObjectIdentifier(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_ObjectIdEncoded:

        /* decode an encoded object identifier value */
        output("if (!ASN1BERDecEoid(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_String:

        /* decode a string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1BERDec%sString(%s, %s, %s))\n",
            p, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_ZeroString:

        /* decode a zero-termianted string value */
        if (info->NOctets == 1) {
            p = "Char";
        } else if (info->NOctets == 2) {
            p = "Char16";
        } else if (info->NOctets == 4) {
            p = "Char32";
        } else
            MyAbort();
        output("if (!ASN1BERDecZero%sString(%s, %s, %s))\n",
            p, encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_External:

        /* decode an external value */
        output("if (!ASN1BERDecExternal(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_EmbeddedPdv:

        /* decode an embedded pdv value */
        output("if (!ASN1BERDecEmbeddedPdv(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_MultibyteString:

        /* decode a multibyte string value */
        if (info->Rules & eTypeRules_LengthPointer)
        {
            output("if (!ASN1BERDecMultibyteString(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        else
        {
            output("if (!ASN1BERDecZeroMultibyteString(%s, %s, %s))\n",
                encref, tagref, Reference(valref));
        }
        output("return 0;\n");
        break;

    case eBERSTIData_UnrestrictedString:

        /* decode an character string value */
        output("if (!ASN1BERDecCharacterString(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_GeneralizedTime:

        /* decode a generalized time value */
        output("if (!ASN1BERDecGeneralizedTime(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_UTCTime:

        /* decode a utc time value */
        output("if (!ASN1BERDecUTCTime(%s, %s, %s))\n",
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Reference:

        /* call other encoding function for reference types */
        output("if (!ASN1Dec_%s(%s, %s, %s))\n",
            Identifier2C(info->SubIdentifier),
            encref, tagref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Open:

        /* decode an open type value */
        output("if (!ASN1BERDecOpenType%s(%s, %s))\n",
            info->pPrivateDirectives->fNoMemCopy ? "2" : "",
            encref, Reference(valref));
        output("return 0;\n");
        break;

    case eBERSTIData_Boolean:
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1BERDecBool(%s, %s, %s))\n", encref, tagref, Reference(valref));
            output("return 0;\n");
        }
        break;
    }

    /* check length/get eoc for explicit tags */
    GenBERDecTagEnd(DECODER_NAME, STREAM_END_NAME, depth, oldencref);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\genprg.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

void GenFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et);
void GenFuncComponents(AssignmentList_t ass, char *module, Type_t *type, char *ideref, uint32_t optindex, ComponentList_t components, char *valref1, char *valref2, TypeFunc_e et, int inextension, int inchoice);
void GenFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et);
void GenFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et);
void GenFuncSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2, TypeFunc_e et);
void GenFreeSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref);
void GenCompareSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2);
void GenCompareExpression(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2);
void GenFuncValue(AssignmentList_t ass, Assignment_t *at, ValueFunc_e cod);
void GenDeclGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenDefhGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenDefnGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
void GenInitGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t);
extern unsigned g_cPDUs;
extern char *g_pszOrigModuleNameLowerCase;
extern int g_fLongNameForImported;
extern int g_fNoAssert;
extern int g_fCaseBasedOptimizer;

extern uint32_t Tag2uint32(AssignmentList_t ass, Tag_t *tag);

int NotInFunTbl(Assignment_t *a)
{
    if (a->Type != eAssignment_Type)
    {
        return 1;
    }

    if (a->U.Type.Type->PrivateDirectives.fPublic)
    {
        return 0;
    }

    return ((a->U.Type.Type->Flags & eTypeFlags_Null) ||
            !(a->U.Type.Type->Flags & eTypeFlags_GenType) ||
            !(a->U.Type.Type->Flags & eTypeFlags_GenPdu) ||
            (a->U.Type.Type->Flags & eTypeFlags_MiddlePDU));
}

/* generate c file */
void
GenPrg(AssignmentList_t ass, FILE *fout, char *module, char *incfilename)
{
    Assignment_t *a;
    TypeFunc_e et;
    ValueFunc_e ev;
    Arguments_t args;
    unsigned i;
    char *pszFunParam;
    char *identifier;
    char funcbuf[256];

    setoutfile(fout);

    // print verbatim
    PrintVerbatim();

    /* file header */
    output("#include <windows.h>\n");
    output("#include \"%s\"\n", incfilename);
    switch (g_eEncodingRule) {
    case eEncoding_Packed:
        GenPERHeader();
        GetPERPrototype(&args);
        pszFunParam = "x,y";
        break;
    case eEncoding_Basic:
        GenBERHeader();
        GetBERPrototype(&args);
        pszFunParam = "x,y,z";
        break;
    default:
        MyAbort();
    }

    output("\n");

    output("ASN1module_t %s = NULL;\n", module);
    output("\n");

    /* write function prototypes */
    for (et = eStringTable; et <= eCopy; et++)
    {
        for (a = ass; a; a = a->Next)
        {
            if (a->Type != eAssignment_Type)
                continue;
            if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
                continue;
            if (a->U.Type.Type->PrivateDirectives.fPublic)
            {
                a->U.Type.Type->Flags |= eTypeFlags_GenEncode;
                a->U.Type.Type->Flags |= eTypeFlags_GenDecode;
                a->U.Type.Type->Flags |= eTypeFlags_GenFree;
                a->U.Type.Type->Flags |= eTypeFlags_GenCompare;
            }
            else
            {
                if ((GetType(ass, a->U.Type.Type)->Flags & eTypeFlags_Null) ||
                    !(a->U.Type.Type->Flags & eTypeFlags_GenType) ||
                    !(a->U.Type.Type->Flags & eTypeFlags_GenPdu))
                    continue;
            }
            switch (et)
            {
            case eStringTable:
                continue;
            case eEncode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pencfunc : args.encfunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Enc_%s(%s)      0\n", identifier, pszFunParam);
                }
                else
                {
                    output("static int ASN1CALL ASN1Enc_%s(%s);\n", identifier, funcbuf);
                }
                break;
            case eDecode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pdecfunc : args.decfunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Dec_%s(%s)      0\n", identifier, pszFunParam);
                }
                else
                {
                    output("static int ASN1CALL ASN1Dec_%s(%s);\n", identifier, funcbuf);
                }
                break;
            case eCheck:
                continue;
            case ePrint:
                continue;
            case eFree:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
                    (a->U.Type.Type->Flags & eTypeFlags_Simple))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pfreefunc : args.freefunc, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Free_%s(x)     \n", identifier);
                }
                else
                {
                    output("static void ASN1CALL ASN1Free_%s(%s);\n", identifier, funcbuf);
                }
                break;
#ifdef ENABLE_COMPARE
            case eCompare:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
                    continue;
                identifier = GetName(a);
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pcmpfun : args.cmpfunc, identifier, identifier);
                if (a->U.Type.Type->PrivateDirectives.fNoCode)
                {
                    output("#define ASN1Compare_%s(x,y)      0\n", identifier);
                }
                else
                {
                    output("static int ASN1CALL ASN1Compare_%s(%s);\n", identifier, funcbuf);
                }
                break;
#endif // ENABLE_COMPARE
            case eCopy:
                continue;
            }
        }
    }
    output("\n");

    /* write a table containing the encode function addresses */
    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("typedef ASN1PerEncFun_t ASN1EncFun_t;\n");
        break;
    case eEncoding_Basic:
        output("typedef ASN1BerEncFun_t ASN1EncFun_t;\n");
        break;
    default:
        output("typedef int (ASN1CALL *ASN1EncFun_t)(%s);\n", args.enccast);
        break;
    }
    output("static const ASN1EncFun_t encfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next) {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode)) {
            ASSERT(0);
            output("(ASN1EncFun_t) NULL,\n");
            continue;
        }
        output("(ASN1EncFun_t) ASN1Enc_%s,\n", GetName(a));
    }
    output("};\n");

    /* write a table containing the decode function addresses */
    switch (g_eEncodingRule)
    {
    case eEncoding_Packed:
        output("typedef ASN1PerDecFun_t ASN1DecFun_t;\n");
        break;
    case eEncoding_Basic:
        output("typedef ASN1BerDecFun_t ASN1DecFun_t;\n");
        break;
    default:
        output("typedef int (ASN1CALL *ASN1DecFun_t)(%s);\n", args.deccast);
        break;
    }
    output("static const ASN1DecFun_t decfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
        {
            ASSERT(0);
            output("(ASN1DecFun_t) NULL,\n");
            continue;
        }
        output("(ASN1DecFun_t) ASN1Dec_%s,\n", GetName(a));
    }
    output("};\n");

    /* write a table containing the free function addresses */
    output("static const ASN1FreeFun_t freefntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
            (a->U.Type.Type->Flags & eTypeFlags_Simple))
        {
            output("(ASN1FreeFun_t) NULL,\n");
            continue;
        }
        output("(ASN1FreeFun_t) ASN1Free_%s,\n", GetName(a));
    }
    output("};\n");

#ifdef ENABLE_COMPARE
    /* write a table containing the compare function addresses */
    output("typedef int (ASN1CALL *ASN1CmpFun_t)(%s);\n", args.cmpcast);
    output("static const ASN1CmpFun_t cmpfntab[%u] = {\n", g_cPDUs);
    for (a = ass; a; a = a->Next)
    {
        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;
        if (NotInFunTbl(a))
            continue;
        if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
        {
            ASSERT(0);
            output("(ASN1CmpFun_t) NULL,\n");
            continue;
        }
        output("(ASN1CmpFun_t) ASN1Compare_%s,\n", GetName(a));
    }
    output("};\n");
    output("\n");
#endif // ENABLE_COMPARE

    /* write a table containing the sizeof pdu structures */
    output("static const ULONG sizetab[%u] = {\n", g_cPDUs);
    for (i = 0; i < g_cPDUs; i++)
    {
        output("SIZE_%s_%s_%u,\n", module, g_pszApiPostfix, i);
    }
    output("};\n");
    output("\n");

    /* handle values in 4 steps: */
    /* 1. write forward declarations, */
    /* 2. write definitions of value components, */
    /* 3. write definitions of values, */
    /* 4. write assignments into the initialization function */
    for (ev = eDecl; ev <= eFinit; ev++)
    {
        switch (ev)
        {
        case eDecl:
            output("/* forward declarations of values: */\n");
            break;
        case eDefh:
            output("/* definitions of value components: */\n");
            break;
        case eDefn:
            output("/* definitions of values: */\n");
            break;
        case eInit:
            output("\nvoid ASN1CALL %s_Startup(void)\n", module);
            output("{\n");
            switch (g_eEncodingRule)
            {
            case eEncoding_Packed:
                GenPERInit(ass, module);
                break;
            case eEncoding_Basic:
                GenBERInit(ass, module);
                break;
            }
            break;
        case eFinit:
            output("\nvoid ASN1CALL %s_Cleanup(void)\n", module);
            output("{\n");
            output("ASN1_CloseModule(%s);\n", module);
            output("%s = NULL;\n", module);
            break;
        }
        for (a = ass; a; a = a->Next)
        {
            if (a->Type != eAssignment_Value)
                continue;
            if (GetValue(ass, a->U.Value.Value)->Type->Flags & eTypeFlags_Null)
                continue;
            switch (ev)
            {
            case eDecl:
            case eDefh:
            case eDefn:
            case eInit:
            case eFinit:
                if (!(a->U.Value.Value->Flags & eValueFlags_GenValue))
                    continue;
                break;
            }
            GenFuncValue(ass, a, ev);
        }
        if (ev == eInit || ev == eFinit) {
            output("}\n");
        }
    }
    output("\n");

    /* generate the type functions for all assignments as wanted */
    for (a = ass; a; a = a->Next)
    {
        if (a->Type != eAssignment_Type)
            continue;

        /* skip null types */
        if (a->U.Type.Type->Flags & eTypeFlags_Null)
            continue;

        if ((! g_fLongNameForImported) && a->fImportedLocalDuplicate)
           continue;

        if (a->U.Type.Type->PrivateDirectives.fNoCode)
            continue;

        /* generate the functions */
        identifier = GetName(a);
        for (et = eStringTable; et <= eCopy; et++)
        {
            switch (et)
            {
            case eStringTable:
                if (!(a->U.Type.Type->Flags &
                    (eTypeFlags_GenEncode | eTypeFlags_GenDecode)))
                    continue;
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                break;
            case eEncode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenEncode))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pencfunc : args.encfunc, identifier);
                output("static int ASN1CALL ASN1Enc_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                output("return 1;\n");
                output("}\n\n");
                break;
            case eDecode:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenDecode))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pdecfunc : args.decfunc, identifier);
                output("static int ASN1CALL ASN1Dec_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                switch (g_eEncodingRule)
                {
                case eEncoding_Packed:
                    GenPERFuncType(ass, module, a, et);
                    break;
                case eEncoding_Basic:
                    GenBERFuncType(ass, module, a, et);
                    break;
                }
                output("return 1;\n");
                output("}\n\n");
                break;
            case eCheck:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCheck))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            case ePrint:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenPrint))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            case eFree:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenFree) ||
                    (a->U.Type.Type->Flags & eTypeFlags_Simple))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pfreefunc : args.freefunc, identifier);
                output("static void ASN1CALL ASN1Free_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                output("if (val) {\n");  // opening the null pointer check
                GenFuncType(ass, module, a, et);
                output("}\n"); // closing the null pointer check
                output("}\n\n");
                break;
#ifdef ENABLE_COMPARE
            case eCompare:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCompare))
                    continue;
                sprintf(funcbuf, IsPSetOfType(ass, a) ? args.Pcmpfunc : args.cmpfunc, identifier);
                output("static int ASN1CALL ASN1Compare_%s(%s)\n",
                    identifier, funcbuf);
                output("{\n");
                outputvar("int ret;\n");
                GenFuncType(ass, module, a, et);
                output("return 0;\n");
                output("}\n\n");
                break;
#endif // ENABLE_COMPARE
            case eCopy:
                if (!(a->U.Type.Type->Flags & eTypeFlags_GenCopy))
                    continue;
                GenFuncType(ass, module, a, et);
                break;
            }
        }
    }
}

/* generate function encoding-independent type-specific functions */
void
GenFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *ideref;
    char *valref1, *valref2;

    /* get some informations */
    type = at->U.Type.Type;
    ideref = GetName(at);
    switch (et) {
    case eCompare:
        valref1 = "val1";
        valref2 = "val2";
        break;
    default:
        valref1 = "val";
        valref2 = "";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
        /* generate function for a simple type */
        GenFuncSimpleType(ass, type, ideref, Dereference(valref1), Dereference(valref2), et);
        break;

    case eType_SequenceOf:
    case eType_SetOf:
        /* generate function for seq-of and set-of */
        GenFuncSimpleType(ass, type, ideref, Dereference(valref1), Dereference(valref2), et);
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        /* generate function for a sequence/set/instanceof type */
        GenFuncSequenceSetType(ass, module, at, valref1, valref2, et);
        break;

    case eType_Choice:
        /* generate function for a choice type */
        GenFuncChoiceType(ass, module, at, valref1, valref2, et);
        break;

    case eType_Selection:
        MyAbort();
        /*NOTREACHED*/

    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate encoding-independent statements for components of a */
/* sequence/set/choice type */
void
GenFuncComponents(AssignmentList_t ass, char *module, Type_t *type, char *ideref, uint32_t optindex, ComponentList_t components, char *valref1, char *valref2, TypeFunc_e et, int inextension, int inchoice)
{
    Component_t *com;
    NamedType_t *namedType;
    char *ide, idebuf[256];
    char valbuf1[256], valbuf2[256], valbuf3[256];
    int skip;

    /* emit components of extension root */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker)
            break;

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);
        sprintf(idebuf, "%s_%s", ideref, ide);

        /* skip unnecessary elements */
        switch (et) {
        case eFree:
            skip = (namedType->Type->Flags & eTypeFlags_Simple);
            break;
        default:
            skip = 0;
            break;
        }

        /* dereference pointer if pointer directive used */
        if (inchoice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) {
                sprintf(valbuf1, "*(%s)->u.%s", valref1, ide);
                sprintf(valbuf2, "*(%s)->u.%s", valref2, ide);
            } else {
                sprintf(valbuf1, "(%s)->u.%s", valref1, ide);
                sprintf(valbuf2, "(%s)->u.%s", valref2, ide);
            }
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) {
                sprintf(valbuf1, "*(%s)->%s", valref1, ide);
                sprintf(valbuf2, "*(%s)->%s", valref2, ide);
            } else {
                sprintf(valbuf1, "(%s)->%s", valref1, ide);
                sprintf(valbuf2, "(%s)->%s", valref2, ide);
            }
        }

        /* check if optional/default component is present */
        if (!skip) {
            if (inchoice) {
                switch (et) {
                case eFree:
                    output("case %d:\n", optindex);
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                    if ((GetTypeRules(ass, namedType->Type) &
                        eTypeRules_Pointer) &&
                        !(GetType(ass, namedType->Type)->Flags &
                        eTypeFlags_Null))
                        output("ASN1Free(%s);\n", Reference(valbuf1));
                    output("break;\n");
                    break;
                default:
                    output("case %d:\n", optindex);
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                    output("break;\n");
                    break;
                }
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    switch (et) {
                    case eFree:
                        output("if ((%s)->o[%u] & 0x%x) {\n", valref1,
                            optindex / 8, 0x80 >> (optindex & 7));
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        if ((GetTypeRules(ass, namedType->Type) &
                            eTypeRules_Pointer) &&
                            !(GetType(ass, namedType->Type)->Flags &
                            eTypeFlags_Null))
                            output("ASN1Free(%s);\n", Reference(valbuf1));
                        output("}\n");
                        break;
                    case eCompare:
                        sprintf(valbuf3, "%s_default", idebuf);
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref1,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref2,
                            optindex / 8, 0x80 >> (optindex & 7));
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        output("} else {\n");
                        if (com->Type == eComponent_Default) {
                            GenFuncSimpleType(ass, namedType->Type, idebuf,
                                valbuf1, valbuf3, et);
                        } else {
                            output("return 1;\n");
                        }
                        output("}\n");
                        output("} else {\n");
                        output("if (((%s)->o[%u] & 0x%x)) {\n", valref2,
                            optindex / 8, 0x80 >> (optindex & 7));
                        if (com->Type == eComponent_Default) {
                            GenFuncSimpleType(ass, namedType->Type, idebuf,
                                valbuf3, valbuf2, et);
                        } else {
                            output("return 1;\n");
                        }
                        output("}\n");
                        output("}\n");
                        break;
                    default:
                        GenFuncSimpleType(ass, namedType->Type, idebuf,
                            valbuf1, valbuf2, et);
                        break;
                    }
                } else {
                    GenFuncSimpleType(ass, namedType->Type, idebuf,
                        valbuf1, valbuf2, et);
                }
            }
        }
        if (inchoice ||
            com->Type == eComponent_Optional ||
            com->Type == eComponent_Default ||
            inextension)
            optindex++;
    }
}

/* generate encoding-independent statements for sequence/set type */
void
GenFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et)
{
    uint32_t optionals, extensions;
    Component_t *components, *com;
    Type_t *type;
    char *ideref;

    type = at->U.Type.Type;
    ideref = GetName(at);
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;

    /* emit components of extension root */
    GenFuncComponents(ass, module, type, ideref, 0,
        components, valref1, valref2, et, 0, 0);

    /* handle extensions */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        if (extensions) {

            /* get start of extensions */
            for (com = components; com; com = com->Next) {
                if (com->Type == eComponent_ExtensionMarker) {
                    com = com->Next;
                    break;
                }
            }

            /* emit components of extension */
            GenFuncComponents(ass, module, type, ideref, (optionals + 7) & ~7,
                com, valref1, valref2, et, 1, 0);
        }
    }
}

/* generate encoding-independent statements for choice type */
void
GenFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref1, char *valref2, TypeFunc_e et)
{
    Type_t *type;
    char *ideref;
    char valbuf1[256], valbuf2[256];
    uint32_t alternatives;
    Component_t *components, *com;

    /* get some informations */
    type = at->U.Type.Type;
    ideref = GetName(at);
    alternatives = type->U.SSC.Alternatives;
    components = type->U.SSC.Components;

    /* encode choice selector */
    sprintf(valbuf1, "(%s)->choice", valref1);
    sprintf(valbuf2, "(%s)->choice", valref2);
    GenFuncSimpleType(ass, type, ideref, valbuf1, valbuf2, et);

    /* finished if choice only contains NULL alternatives or if choice */
    /* contains no data to free */
    if ((type->Flags & eTypeFlags_NullChoice) ||
        (et == eFree && (type->Flags & eTypeFlags_Simple)))
        return;

    /* create switch statement */
    output("switch ((%s)->choice) {\n", valref1);

    /* generate components of extension root */
    GenFuncComponents(ass, module, type, ideref, ASN1_CHOICE_BASE,
        type->U.SSC.Components, valref1, valref2, et, 0, 1);

    /* get start of extensions */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker) {
            com = com->Next;
            break;
        }
    }

    /* generate components of extension */
    GenFuncComponents(ass, module, type, ideref, ASN1_CHOICE_BASE + alternatives,
        com, valref1, valref2, et, 1, 1);

    /* end of switch statement */
    output("}\n");
}

/* generate encoding-independent statements for a simple type */
void
GenFuncSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2, TypeFunc_e et)
{
    switch (et) {
    case eFree:
        GenFreeSimpleType(ass, type, ideref, valref1);
        break;
#ifdef ENABLE_COMPARE
    case eCompare:
        GenCompareSimpleType(ass, type, ideref, valref1, valref2);
        break;
#endif // ENABLE_COMPARE
    }
}

/* generate free statements for a simple type */
void
GenFreeSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref)
{
    char idebuf[256];
    char valbuf[256];
    char valbuf2[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;

    if (type->Flags & eTypeFlags_Simple)
        return;
    if (type->Type == eType_Reference && !IsStructuredType(GetType(ass, type)))
        type = GetType(ass, type);

    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:

        /* check if we have to free an intx_t value */
        itype = GetTypeName(ass, type);
        if (!strcmp(itype, "ASN1intx_t"))
            output("ASN1intx_free(%s);\n", Reference(valref));
        break;

    case eType_BitString:

        /* free bit string value */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.cbFixedSizeBitString == 0)
            {
                output("ASN1bitstring_free(%s);\n", Reference(valref));
            }
        }
        else
        {
            // only support unbounded in BER
            if (! type->PrivateDirectives.fNoMemCopy)
            {
                output("ASN1bitstring_free(%s);\n", Reference(valref));
            }
        }
        break;

    case eType_OctetString:

        /* free octet string value */
        if (g_eEncodingRule == eEncoding_Packed)
        {
            if (type->PERTypeInfo.Root.LConstraint != ePERSTIConstraint_Constrained ||
                type->PrivateDirectives.fLenPtr)
            {
                output("ASN1octetstring_free(%s);\n", Reference(valref));
            }
        }
        else
        {
            // only support unbounded in BER
            if (! type->PrivateDirectives.fNoMemCopy)
            {
                output("ASN1octetstring_free(%s);\n", Reference(valref));
            }
        }
        break;

    case eType_UTF8String:

        /* free octet string value */
        output("ASN1utf8string_free(%s);\n", Reference(valref));
        break;

    case eType_ObjectIdentifier:

        /* free object identifier value */
        if (type->PrivateDirectives.fOidPacked)
        {
            output("ASN1BEREoid_free(%s);\n", Reference(valref));
        }
        else
        if (! (type->PrivateDirectives.fOidArray || g_fOidArray))
        {
            output("ASN1objectidentifier_free(%s);\n", Reference(valref));
        }
        break;

    case eType_External:

        /* free external value */
        output("ASN1external_free(%s);\n", Reference(valref));
        break;

    case eType_Real:

        /* free real value */
        output("ASN1real_free(%s);\n", Reference(valref));
        break;

    case eType_EmbeddedPdv:

        /* free embedded pdv value */
        output("ASN1embeddedpdv_free(%s);\n", Reference(valref));
        break;

    case eType_SetOf:

        /* create name of identifier */
        sprintf(idebuf, "%s_Set", ideref);
        goto FreeSequenceSetOf;

    case eType_SequenceOf:

        /* create name of identifier */
        sprintf(idebuf, "%s_Sequence", ideref);
    FreeSequenceSetOf:

        if (type->Rules & eTypeRules_FixedArray)
        {
            char *pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            /* free components of sequence of/set of */
            if (! (type->Rules & eTypeRules_PointerToElement))
                valref = Reference(valref);
            if (!(type->U.SS.Type->Flags & eTypeFlags_Simple)) {
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < (%s)->count; i++) {\n", valref);
                sprintf(valbuf, "(%s)->%s[i]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf, "", eFree);
                output("}\n");
            }
        }
        else
        if (type->Rules & eTypeRules_LengthPointer)
        {
            char *pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
            /* free components of sequence of/set of */
            if (! (type->Rules & eTypeRules_PointerToElement))
                valref = Reference(valref);
            if (!(type->U.SS.Type->Flags & eTypeFlags_Simple)) {
                sprintf(valbuf2, "(%s)->%s[0]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf2, "", eFree);
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 1; i < (%s)->count; i++) {\n", valref);
                sprintf(valbuf2, "(%s)->%s[i]", valref, pszPrivateValueName);
                GenFuncSimpleType(ass, type->U.SS.Type, idebuf, valbuf2, "", eFree);
                output("}\n");
            }
            // lonchanc: no need to check length because we zero out decoded buffers.
            // output("if ((%s)->count)\n", valref);
            output("ASN1Free((%s)->%s);\n", valref, pszPrivateValueName);
        }
        else
        if (type->Rules & eTypeRules_LinkedListMask)
        {
            char szPrivateValueName[68];

            if (g_fCaseBasedOptimizer)
            {
                if (g_eEncodingRule == eEncoding_Packed &&
                    PerOptCase_IsTargetSeqOf(&type->PERTypeInfo))
                {
                    // generate the iterator
                    PERTypeInfo_t *info = &type->PERTypeInfo;
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Free_%s_ElmFn", info->Identifier);
                    sprintf(szElmFnDecl, "void ASN1CALL %s(P%s val)",
                        szElmFn, info->Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    output("ASN1PERFreeSeqOf((ASN1iterator_t **) %s, (ASN1iterator_freefn) %s);\n",
                        Reference(valref), szElmFn);
                    output("}\n"); // closing the null pointer check
                    output("}\n\n"); // end of iterator body


                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    output("if (val) {\n"); // opening the null pointer check
                    sprintf(&szPrivateValueName[0], "val->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                    GenFuncSimpleType(ass, type->U.SS.Type, idebuf,
                        &szPrivateValueName[0], "", eFree);
                    // output("}\n"); // closing the null pointer check. lonchanc: closed by caller
                    // end of element body
                    return;
                }
            }

            /* free components of sequence of/set of */
            outputvar("P%s f, ff;\n", ideref);
            output("for (f = %s; f; f = ff) {\n", valref);
            sprintf(&szPrivateValueName[0], "f->%s", type->PrivateDirectives.pszValueName ? type->PrivateDirectives.pszValueName : "value");
            GenFuncSimpleType(ass, type->U.SS.Type, idebuf,
                &szPrivateValueName[0], "", eFree);
            output("ff = f->next;\n");

            /* free list entry of sequence of/set of */
            output("ASN1Free(f);\n");
            output("}\n");
        }
        break;

    case eType_ObjectDescriptor:

        /* free object descriptor value */
        output("ASN1ztcharstring_free(%s);\n", valref);
        break;

    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
#ifdef ENABLE_CHAR_STR_SIZE
                if (g_eEncodingRule == eEncoding_Packed &&
                    type->PERTypeInfo.NOctets == 1 &&
                        type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    // it is an array, no need to free it.
                    break;
                }
#endif

    case eType_BMPString:
    case eType_RestrictedString:

        /* free string value */
        GetStringType(ass, type, &noctets, &zero);
        if (zero) {
            switch (noctets) {
            case 1:
                output("ASN1ztcharstring_free(%s);\n", valref);
                break;
            case 2:
                output("ASN1ztchar16string_free(%s);\n", valref);
                break;
            case 4:
                output("ASN1ztchar32string_free(%s);\n", valref);
                break;
            }
        } else {
            switch (noctets) {
            case 1:
                output("ASN1charstring_free(%s);\n", Reference(valref));
                break;
            case 2:
                output("ASN1char16string_free(%s);\n", Reference(valref));
                break;
            case 4:
                output("ASN1char32string_free(%s);\n", Reference(valref));
                break;
            }
        }
        break;

    case eType_CharacterString:

        /* free character string value */
        output("ASN1characterstring_free(%s);\n", Reference(valref));
        break;

    case eType_Reference:

        /* call free function of referenced type */
        output("ASN1Free_%s(%s);\n",
            GetTypeName(ass, type), Reference(valref));
        break;

    case eType_Open:

        /* free open type value */
        if (g_eEncodingRule == eEncoding_Packed || (! type->PrivateDirectives.fNoMemCopy))
        {
            output("ASN1open_free(%s);\n", Reference(valref));
        }
        break;
    }
}

/* generate compare statements for a simple type */
/*ARGSUSED*/
#ifdef ENABLE_COMPARE
void
GenCompareSimpleType(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2)
{
    /* skip null type */
    if (type->Flags & eTypeFlags_Null)
        return;

    /* compare the values and return difference if different */
    output("if ((ret = (");
    GenCompareExpression(ass, type, ideref, valref1, valref2);
    output(")))\n");
    output("return ret;\n");
}
#endif // ENABLE_COMPARE

/* generate compare expression for two values of simple type */
/*ARGSUSED*/
#ifdef ENABLE_COMPARE
void
GenCompareExpression(AssignmentList_t ass, Type_t *type, char *ideref, char *valref1, char *valref2)
{
    PERSTIData_e dat;
    uint32_t noctets;
    char *itype;
    char *subide;
    char *pszPrivateValueName;

    /*XXX switch to PER-independent field */
    dat = type->PERTypeInfo.Root.Data;
    noctets = type->PERTypeInfo.NOctets;

    switch (dat) {
    case ePERSTIData_Null:

        /* null values equal */
        output("0");
        break;

    case ePERSTIData_Boolean:

        /* boolean values have to be converted to 0/1 values before */
        /* comparison */
        output("!!%s - !!%s", valref1, valref2);
        break;

    case ePERSTIData_Integer:
    case ePERSTIData_Unsigned:

        /* substract integer values */
        if (noctets) {
            if (noctets <= 4)
                output("%s - %s", valref1, valref2);
            else
                output("%s < %s ? -1 : %s > %s ? 1 : 0",
                    valref1, valref2, valref1, valref2);
        } else {
            output("ASN1intx_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
        }
        break;

    case ePERSTIData_Real:

        /* compare real values */
        itype = GetTypeName(ass, type);
        if (!strcmp(itype, "ASN1real_t"))
            output("ASN1real_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
        else
            output("ASN1double_cmp(%s, %s)",
                valref1, valref2);
        break;

    case ePERSTIData_BitString:

        /* compare bit string values */
        output("ASN1bitstring_cmp(%s, %s, 0)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_RZBBitString:

        /* compare remove-zero-bit bit string values */
        output("ASN1bitstring_cmp(%s, %s, 1)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_OctetString:

        /* compare octet string values */
        output("ASN1octetstring_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_UTF8String:

        /* compare octet string values */
        output("ASN1utf8string_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_ObjectIdentifier:

        /* compare object identifier values */
        output("ASN1objectidentifier_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* compare string values */
        switch (noctets) {
        case 1:
            output("ASN1charstring_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        case 2:
            output("ASN1char16string_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        case 4:
            output("ASN1char32string_cmp(%s, %s)",
                Reference(valref1), Reference(valref2));
            break;
        }
        break;

    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:

        /* compare zero-terminated string values */
        switch (noctets) {
        case 1:
            output("ASN1ztcharstring_cmp(%s, %s)",
                valref1, valref2);
            break;
        case 2:
            output("ASN1ztchar16string_cmp(%s, %s)",
                valref1, valref2);
            break;
        case 4:
            output("ASN1ztchar32string_cmp(%s, %s)",
                valref1, valref2);
            break;
        }
        break;

    case ePERSTIData_SequenceOf:

        /* compare sequence of values by use of a comparison function */
        /* use element comparison function as argument */
        subide = GetTypeName(ass, type->U.SS.Type);
        pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
        if (type->Rules & eTypeRules_PointerArrayMask)
        {
            output("ASN1sequenceoflengthpointer_cmp((%s)->count, (%s)->%s, (%s)->count, (%s)->%s, sizeof(%s), (int (*)(void *, void *))ASN1Compare_%s)",
                Reference(valref1), Reference(valref1), pszPrivateValueName,
                Reference(valref2), Reference(valref2), pszPrivateValueName, subide, subide);
        }
        else
        if (type->Rules & eTypeRules_SinglyLinkedList)
        {
            output("ASN1sequenceofsinglylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        if (type->Rules & eTypeRules_DoublyLinkedList)
        {
            output("ASN1sequenceofdoublylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        {
            MyAbort();
        }
        break;

    case ePERSTIData_SetOf:

        /* compare set of values by use of a comparison function */
        /* use element comparison function as argument */
        subide = GetTypeName(ass, type->U.SS.Type);
        pszPrivateValueName = GetPrivateValueName(&type->PrivateDirectives, "value");
        if (type->Rules & eTypeRules_PointerArrayMask)
        {
            output("ASN1setoflengthpointer_cmp((%s)->count, (%s)->%s, (%s)->count, (%s)->%s, sizeof(%s), (int (*)(void *, void *))ASN1Compare_%s)",
                Reference(valref1), Reference(valref1), pszPrivateValueName,
                Reference(valref2), Reference(valref2), pszPrivateValueName, subide, subide);
        }
        else
        if (type->Rules & eTypeRules_SinglyLinkedList)
        {
            output("ASN1setofsinglylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        if (type->Rules & eTypeRules_DoublyLinkedList)
        {
            output("ASN1setofdoublylinkedlist_cmp(%s, %s, offsetof(%s_Element, %s), (ASN1int32_t (*)(void *, void *))ASN1Compare_%s)",
                valref1, valref2, ideref, pszPrivateValueName, subide);
        }
        else
        {
            MyAbort();
        }
        break;

    case ePERSTIData_Reference:

        /* call compare function of referenced value */
        output("ASN1Compare_%s(%s, %s)",
            GetTypeName(ass, type), Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_External:

        /* compare external values */
        output("ASN1external_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_EmbeddedPdv:

        /* compare embedded pdv values */
        output("ASN1embeddedpdv_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_MultibyteString:

        /* compare multibyte string values */
        output("ASN1ztcharstring_cmp(%s, %s)",
            valref1, valref2);
        break;

    case ePERSTIData_UnrestrictedString:

        /* compare character string values */
        output("ASN1characterstring_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_GeneralizedTime:

        /* compare generalized time values */
        output("ASN1generalizedtime_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_UTCTime:

        /* compare utc time values */
        output("ASN1utctime_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;

    case ePERSTIData_Open:

        /* compare open type values */
        output("ASN1open_cmp(%s, %s)",
            Reference(valref1), Reference(valref2));
        break;
    }
}
#endif // ENABLE_COMPARE

/* generate encoding-independent statements for better optional flags of */
/* a sequence/set value */
void
GenFuncSequenceSetOptionals(AssignmentList_t ass, char *valref, ComponentList_t components, uint32_t optionals, uint32_t extensions, char *obuf, TypeFunc_e et)
{
    uint32_t optindex, inextension, oflg;
    Component_t *com;
    char *ide;
    char *itype;
    int flg;
    int32_t sign, noctets;
    uint32_t zero;

    sprintf(obuf, "(%s)->o", valref);
    oflg = 0;
    if (et == eEncode) {
        optindex = 0;
        inextension = 0;
        for (com = components; com; com = com->Next) {
            switch (com->Type) {
            case eComponent_Normal:

                /* non-optional fields in an extension will be mandatory, */
                /* so we can set the optional flag always. */
                if (inextension) {
                    if (!oflg) {
                        outputvar("ASN1octet_t o[%u];\n",
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        output("CopyMemory(o, (%s)->o, %u);\n", valref,
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        strcpy(obuf, "o");
                        oflg = 1;
                    }
                    output("%s[%u] |= 0x%x;\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    optindex++;
                }
                break;

            case eComponent_Optional:

                /* optional pointers with value null are absent, so we */
                /* will clear the optional flag */
                ide = Identifier2C(com->U.Optional.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        if (!oflg) {
                            outputvar("ASN1octet_t o[%u];\n",
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            output("CopyMemory(o, (%s)->o, %u);\n", valref,
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            strcpy(obuf, "o");
                            oflg = 1;
                        }
                        output("if (!(%s)->%s)\n", valref, ide);
                        output("o[%u] &= ~0x%x;\n", valref, optindex / 8,
                            0x80 >> (optindex & 7));
                    }
                    break;
                }
                optindex++;
                break;

            case eComponent_Default:

                /* default pointers with value null are absent, so we */
                /* will clear the optional flag */
                ide = Identifier2C(com->U.Default.NamedType->Identifier);
                switch (com->U.Default.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Default.NamedType->Type) &
                        eTypeRules_Pointer) {
                        if (!oflg) {
                            outputvar("ASN1octet_t o[%u];\n",
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            output("CopyMemory(o, (%s)->o, %u);\n", valref,
                                (optionals + 7) / 8 + (extensions + 7) / 8);
                            strcpy(obuf, "o");
                            oflg = 1;
                        }
                        output("if (!(%s)->%s)\n", valref, ide);
                        output("o[%u] &= ~0x%x;\n", valref, optindex / 8,
                            0x80 >> (optindex & 7));
                    }
                    break;
                }

                /* if the given value is the default value, we can (BER) */
                /* or have to (CER) clear the corresponding optional flag */
                flg = 1;
                if (!oflg) {
                    switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                    case eType_Choice:
                        if (!(GetType(ass, com->U.Default.NamedType->Type)->
                            Flags & eTypeFlags_NullChoice)) {
                            if (g_eSubEncodingRule == eSubEncoding_Canonical)
                                MyAbort(); /*XXX*/
                            flg = 0;
                        }
                        break;
                    case eType_Sequence:
                    case eType_Set:
                    case eType_InstanceOf:
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort(); /*XXX*/
                        flg = 0;
                        break;
                    case eType_SequenceOf:
                    case eType_SetOf:
                        if (GetValue(ass, com->U.Default.Value)->U.SS.Values) {
                            if (g_eSubEncodingRule == eSubEncoding_Canonical)
                                MyAbort();
                            flg = 0;
                        }
                        break;
                    }
                    if (flg) {
                        outputvar("ASN1octet_t o[%u];\n",
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        output("CopyMemory(o, (%s)->o, %u);\n", valref,
                            (optionals + 7) / 8 + (extensions + 7) / 8);
                        strcpy(obuf, "o");
                        oflg = 1;
                    }
                }
                switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                case eType_Boolean:
                    output("if (%s(%s)->%s)\n",
                        GetValue(ass,
                        com->U.Default.Value)->U.Boolean.Value ?  "" : "!",
                        valref, ide);
                    break;
                case eType_Integer:
                    itype = GetIntegerType(ass,
                        GetType(ass, com->U.Default.NamedType->Type),
                        &sign);
                    if (!strcmp(itype, "ASN1intx_t")) {
                        output("if (!ASN1intx_cmp(&(%s)->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else if (sign > 0) {
                        output("if ((%s)->%s == %u)\n", valref, ide,
                            intx2uint32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    } else {
                        output("if ((%s)->%s == %d)\n", valref, ide,
                            intx2int32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    }
                    break;
                case eType_BitString:
                    if (GetValue(ass, com->U.Default.Value)->
                        U.BitString.Value.length) {
                        output("if (!ASN1bitstring_cmp(&%s->%s, &%s, %d))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value),
                            !!GetType(ass, com->U.Default.NamedType->Type)->
                            U.BitString.NamedNumbers);
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_OctetString:
                    if (GetValue(ass, com->U.Default.Value)->U.OctetString.
                        Value.length) {
                        output("if (!ASN1octetstring_cmp(&%s->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_UTF8String:
                    if (GetValue(ass, com->U.Default.Value)->U.UTF8String.
                        Value.length) {
                        output("if (!ASN1utf8string_cmp(&%s->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_Null:
                    break;
                case eType_ObjectIdentifier:
                    if (GetValue(ass, com->U.Default.Value)->U.
                        ObjectIdentifier.Value.length) {
                        output("if (!ASN1objectidentifier%s_cmp(&%s->%s, &%s))\n",
                            com->U.Default.NamedType->Type->PrivateDirectives.fOidArray ? "2" : "",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        output("if (!(%s)->%s.length)\n", valref, ide);
                    }
                    break;
                case eType_ObjectDescriptor:
                    output("if (!strcmp((%s)->%s, %s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_External:
                    output("if (!ASN1external_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_Real:
                    itype = GetTypeName(ass, com->U.Default.NamedType->Type);
                    if (!strcmp(itype, "ASN1real_t")) {
                        output("if (!ASN1real_cmp(&(%s)->%s, &%s))\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    }
                    else
                    {
                        output("if ((%s)->%s == %g)\n",
                            valref, ide,
                            real2double(&GetValue(ass,
                            com->U.Default.Value)->U.Real.Value));
                    }
                    break;
                case eType_Enumerated:
                    output("if ((%s)->%s == %u)\n", valref, ide,
                        GetValue(ass, com->U.Default.Value)->
                        U.Enumerated.Value);
                    break;
                case eType_EmbeddedPdv:
                    output("if (!ASN1embeddedpdv_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_NumericString:
                case eType_PrintableString:
                case eType_TeletexString:
                case eType_T61String:
                case eType_VideotexString:
                case eType_IA5String:
                case eType_GraphicString:
                case eType_VisibleString:
                case eType_ISO646String:
                case eType_GeneralString:
                case eType_UniversalString:
                case eType_BMPString:
                case eType_RestrictedString:
                    GetStringType(ass, com->U.Default.NamedType->Type,
                        &noctets, &zero);
                    if (zero) {
                        switch (noctets) {
                        case 1:
                            output("if (!strcmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 2:
                            output("if (!ASN1str16cmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 4:
                            output("if (!ASN1str32cmp((%s)->%s, %s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        default:
                            MyAbort();
                        }
                    } else {
                        switch (noctets) {
                        case 1:
                            output("if (!ASN1charstring_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 2:
                            output("if (!ASN1char16string_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        case 4:
                            output("if (!ASN1char32string_cmp(&(%s)->%s, &%s))\n",
                                valref, ide,
                                GetValueName(ass, com->U.Default.Value));
                            break;
                        default:
                            MyAbort();
                        }
                    }
                    break;
                case eType_CharacterString:
                    output("if (!ASN1characterstring_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_UTCTime:
                    output("if (!ASN1utctime_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_GeneralizedTime:
                    output("if (!ASN1generalizedtime_cmp(&(%s)->%s, &%s))\n",
                        valref, ide,
                        GetValueName(ass, com->U.Default.Value));
                    break;
                case eType_Choice:
                    if (GetType(ass, com->U.Default.NamedType->Type)->Flags
                        & eTypeFlags_NullChoice) {
                        output("if ((%s)->%s.o == %s.o)\n",
                            valref, ide,
                            GetValueName(ass, com->U.Default.Value));
                    } else {
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort(); /*XXX*/
                        flg = 0;
                    }
                    break;
                case eType_Sequence:
                case eType_Set:
                case eType_InstanceOf:
                    if (g_eSubEncodingRule == eSubEncoding_Canonical)
                        MyAbort(); /*XXX*/
                    flg = 0;
                    break;
                case eType_SequenceOf:
                case eType_SetOf:
                    if (!GetValue(ass, com->U.Default.Value)->U.SS.Values) {
                        output("if (!(%s)->%s.count)\n", valref, ide);
                    } else {
                        if (g_eSubEncodingRule == eSubEncoding_Canonical)
                            MyAbort();
                        flg = 0;
                    }
                    break;
                default:
                    MyAbort();
                }
                if (flg)
                    output("%s[%u] &= ~0x%x;\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                optindex++;
                break;

            case eComponent_ExtensionMarker:

                /* update the optional index for extensions */
                optindex = (optindex + 7) & ~7;
                inextension = 1;
                break;
            }
        }
    }
}

/* generate encoding-independent statements for better optional values of */
/* a sequence/set value */
void
GenFuncSequenceSetDefaults(AssignmentList_t ass, char *valref, ComponentList_t components, char *obuf, TypeFunc_e et)
{
    uint32_t optindex, inextension;
    Component_t *com;
    char *ide;
    char *itype;
    int32_t sign;

    if (et == eDecode) {
        optindex = 0;
        inextension = 0;
        for (com = components; com; com = com->Next) {
            switch (com->Type) {
            case eComponent_Normal:

                /* all values in an extension are optional */
                if (!inextension)
                    break;
                /*FALLTHROUGH*/

            case eComponent_Optional:

                /* clear the pointer if the component is not present */
                ide = Identifier2C(com->U.Optional.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        output("if (!(%s[%u] & 0x%x))\n", obuf,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("(%s)->%s = NULL;\n", valref, ide);
                    }
                    break;
                }
                optindex++;
                break;

            case eComponent_Default:

                /* clear the pointer if the component is not present */
                ide = Identifier2C(com->U.Default.NamedType->Identifier);
                switch (com->U.Optional.NamedType->Type->Type) {
                case eType_Reference:
                    if (GetTypeRules(ass, com->U.Optional.NamedType->Type) &
                        eTypeRules_Pointer) {
                        output("if (!(%s[%u] & 0x%x))\n", obuf,
                            optindex / 8, 0x80 >> (optindex & 7));
                        output("(%s)->%s = NULL;\n", valref, ide);
                    }
                    break;
                }

                /* set the element to the default value if it is simple */
                /* and not present */
                switch (GetTypeType(ass, com->U.Default.NamedType->Type)) {
                case eType_Boolean:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    output("(%s)->%s = %u;\n",
                        valref, ide, GetValue(ass, com->U.Default.Value)->
                        U.Boolean.Value);
                    break;
                case eType_Integer:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    itype = GetIntegerType(ass,
                        GetType(ass, com->U.Default.NamedType->Type),
                        &sign);
                    if (!strcmp(itype, "ASN1intx_t")) {
                        /*EMPTY*/
                    } else if (sign > 0) {
                        output("(%s)->%s = %u;\n", valref, ide,
                            intx2uint32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    } else {
                        output("(%s)->%s = %d;\n", valref, ide,
                            intx2int32(&GetValue(ass, com->U.Default.Value)
                            ->U.Integer.Value));
                    }
                    break;
                case eType_Enumerated:
                    output("if (!(%s[%u] & 0x%x))\n", obuf, optindex / 8,
                        0x80 >> (optindex & 7));
                    output("(%s)->%s = %u;\n", valref, ide,
                        GetValue(ass, com->U.Default.Value)->
                        U.Enumerated.Value);
                    break;
                }
                optindex++;
                break;

            case eComponent_ExtensionMarker:

                /* update the optional index for extensions */
                optindex = (optindex + 7) & ~7;
                inextension = 1;
                break;
            }
        }
    }
}

/* generate values */
void
GenFuncValue(AssignmentList_t ass, Assignment_t *av, ValueFunc_e ev)
{
    char *ideref;
    char *typeref;
    Type_t *t;

    ideref = GetName(av);
    t = GetValue(ass, av->U.Value.Value)->Type;
    typeref = GetTypeName(ass, t);
    switch (ev) {
    case eDecl:
        GenDeclGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eDefh:
        GenDefhGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eDefn:
        GenDefnGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eInit:
        GenInitGeneric(ass, ideref, typeref, av->U.Value.Value, t);
        break;
    case eFinit:
        break;
    }
}

/* generate forward declarations */
void
GenDeclGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
#if 0 // duplicate in the generated header file
    switch (t->Type)
    {
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidArray || g_fOidArray)
        {
            output("extern ASN1objectidentifier2_t *%s;\n", ideref);
            break;
        }
        // intentionally fall through
    default:
        output("extern %s %s;\n", typeref, ideref);
        break;
    }
#endif // 0
    outputvalue0(ass, ideref, typeref, value);
}

/* generate definitions of value components */
void
GenDefhGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
    outputvalue1(ass, ideref, typeref, value);
}

/* generate definitions of values */
void
GenDefnGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    value = GetValue(ass, value);
    switch (t->Type)
    {
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidPacked ||
            t->PrivateDirectives.fOidArray || g_fOidArray)
        {
            // lonchanc: intentionally comment out the lines below
            // output("ASN1objectidentifier2_t *%s = ", ideref);
            // break;
            return;
        }
        // intentionally fall through
    default:
        output("%s %s = ", typeref, ideref);
        break;
    }
    outputvalue2(ass, ideref, value);
    output(";\n");
}

/* generate assignments into the initialization function */
/*ARGSUSED*/
void
GenInitGeneric(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value, Type_t *t)
{
    outputvalue3(ass, ideref, ideref, value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\ident.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

char ident1[] = "$Copyright: Microsoft ASN.1 Compiler V1.0 $";
char ident2[] = "$Copyright: Copyright (C) Microsoft Corporation, 1997. All rights reserved. $";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\hackdir.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "hackdir.h"

#ifdef MS_DIRECTIVE
int g_fPrivateDir_FieldNameToken = 0;
int g_fPrivateDir_TypeNameToken = 0;
int g_fPrivateDir_ValueNameToken = 0;
int g_fPrivateDir_SLinked = 0;
int g_fPrivateDir_DLinked = 0;
int g_fPrivateDir_Public = 0;
int g_fPrivateDir_Intx = 0;
int g_fPrivateDir_LenPtr = 0;
int g_fPrivateDir_Pointer = 0;
int g_fPrivateDir_Array = 0;
int g_fPrivateDir_NoCode = 0;
int g_fPrivateDir_NoMemCopy = 0;
int g_fPrivateDir_OidPacked = 0;
int g_fPrivateDir_OidArray = 0;
char g_szPrivateDirectedFieldName[64];
char g_szPrivateDirectedTypeName[64];
char g_szPrivateDirectedValueName[64];

int My_toupper ( int ch )
{
    if ('a' <= ch && ch <= 'z')
    {
        ch = (ch - 'a' + 'A');
    }
    return ch;
}

int PrivateDirectives_MatchSymbol ( int *p, char *psz )
{
    int c = *p;
    int fMatched = 1;

    while (*psz != '\0')
    {
        if (My_toupper(c) != *psz++)
        {
            fMatched = 0;
            break;
        }
        c = PrivateDirectives_Input();
    }
    *p = c;
    return fMatched;
}

void PrivateDirectives_SkipSpace ( int *p )
{
    int c = *p;
    while (isspace(c))
    {
        c = PrivateDirectives_Input();
    }
    *p = c;
}

void PrivateDirectives_GetSymbol ( int *p, char *psz )
{
    int c = *p;
    while (c == '_' || isalnum(c))
    {
        *psz++ = (char)c;
        c = PrivateDirectives_Input();
    }
    *psz = '\0';
    *p = c;
}

void PrivateDirectives_IgnoreSymbol ( int *p )
{
    int c = *p;
    while (c == '_' || isalnum(c))
    {
        c = PrivateDirectives_Input();
    }
    *p = c;
}

void GetMicrosoftDirective ( int *p )
{
    int c = *p;

    // loop through to get all directives
    while (c != g_chDirectiveEnd)
    {
        if (c == g_chDirectiveAND)
        {
            c = PrivateDirectives_Input();
            PrivateDirectives_SkipSpace(&c);
        }

        switch (My_toupper(c))
        {
        case 'A': // possible ARRAY
            if (PrivateDirectives_MatchSymbol(&c, "ARRAY"))
            {
                g_fPrivateDir_Array = 1;
            }
            break;

        case 'D': // possible DLINKED
            if (PrivateDirectives_MatchSymbol(&c, "DLINKED"))
            {
                g_fPrivateDir_DLinked = 1;
            }
            break;

        case 'F': // possible FNAME
            if (PrivateDirectives_MatchSymbol(&c, "FIELD"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedFieldName[0]);
                g_fPrivateDir_FieldNameToken = 0;
            }
            break;

        case 'I': // possible INTX
            if (PrivateDirectives_MatchSymbol(&c, "INTX"))
            {
                g_fPrivateDir_Intx = 1;
            }
            break;

        case 'L': // possible LENPTR
            if (PrivateDirectives_MatchSymbol(&c, "LENPTR"))
            {
                g_fPrivateDir_LenPtr = 1;
            }
            break;

        case 'N': // possible NO MEMCPY (or NOMEMCPY) or NO CODE (or NOCODE)
            if (PrivateDirectives_MatchSymbol(&c, "NO"))
            {
                // skip over possible spaces
                PrivateDirectives_SkipSpace(&c);
                switch (My_toupper(c))
                {
                case 'C':
                    if (PrivateDirectives_MatchSymbol(&c, "CODE")) // CODE
                    {
                        g_fPrivateDir_NoCode = 1;
                    }
                    break;
                case 'M':
                    if (PrivateDirectives_MatchSymbol(&c, "MEMCPY")) // MEMCPY
                    {
                        g_fPrivateDir_NoMemCopy = 1;
                    }
                    break;
                }
            }
            break;

        case 'O': // possible OID ARRAY (or OIDARRAY) or OID PACKED (or OIDPACKED)
            if (PrivateDirectives_MatchSymbol(&c, "OID"))
            {
                // skip over possible spaces
                PrivateDirectives_SkipSpace(&c);
                switch (My_toupper(c))
                {
                case 'A':
                    if (PrivateDirectives_MatchSymbol(&c, "ARRAY")) // ARRAY
                    {
                        g_fPrivateDir_OidArray = 1;
                    }
                    break;
                case 'P':
                    if (PrivateDirectives_MatchSymbol(&c, "PACKED")) // PACKED
                    {
                        g_fPrivateDir_OidPacked = 1;
                    }
                    break;
                }
            }
            break;

        case 'P': // possible POINTER or PUBLIC
            c = PrivateDirectives_Input();
            switch (My_toupper(c))
            {
            case 'O':
                if (PrivateDirectives_MatchSymbol(&c, "OINTER")) // POINTER
                {
                    g_fPrivateDir_Pointer = 1;
                }
                break;
            case 'U':
                if (PrivateDirectives_MatchSymbol(&c, "UBLIC")) // PUBLIC
                {
                    g_fPrivateDir_Public = 1;
                }
                break;
            }
            break;

        case 'S': // possible SLINKED
            if (PrivateDirectives_MatchSymbol(&c, "SLINKED"))
            {
                g_fPrivateDir_SLinked = 1;
            }
            break;

        case 'T': // possible TNAME
            if (PrivateDirectives_MatchSymbol(&c, "TYPE"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedTypeName[0]);
                g_fPrivateDir_TypeNameToken = 0;
            }
            break;

        case 'V': // possible VNAME
            if (PrivateDirectives_MatchSymbol(&c, "VALUE"))
            {
                // c should be a space now
                PrivateDirectives_SkipSpace(&c);
                // c should be a double quote now
                if (c == '"')
                {
                    c = PrivateDirectives_Input();
                }
                // c should be the first char of name
                PrivateDirectives_GetSymbol(&c, &g_szPrivateDirectedValueName[0]);
                g_fPrivateDir_ValueNameToken = 0;
            }
            break;

        default:
            goto MyExit;
        }

        // determine if we should stay in the loop
        // skip over the ending double quote
        if (c == '"')
        {
            c = PrivateDirectives_Input();
        }
        // skip over unknown directives
        PrivateDirectives_IgnoreSymbol(&c);
        // skip over possible spaces
        PrivateDirectives_SkipSpace(&c);
    }

    // now, c is >. we need to advance to --
    c = PrivateDirectives_Input();

    // now, c should be -

MyExit:

    // return the current character
    *p = c;
}


void GetPrivateDirective ( int *p )
{
    GetMicrosoftDirective(p);
}


typedef struct Verbatim_s
{
    struct Verbatim_s   *next;
    char                pszVerbatim[1];
}
    Verbatim_t;

Verbatim_t *g_VerbatimList = NULL;

void RememberVerbatim(char *pszVerbatim)
{
    int cb = strlen(pszVerbatim) + 1;
    Verbatim_t *p = (Verbatim_t *) malloc(sizeof(Verbatim_t) + cb);
    if (p)
    {
        memcpy(p->pszVerbatim, pszVerbatim, cb);
        p->next = NULL;
        if (g_VerbatimList)
        {
            Verbatim_t *q;
            for (q = g_VerbatimList; q->next; q = q->next)
                ;
            q->next = p;
        }
        else
        {
            g_VerbatimList = p;
        }
    }
}

void PrintVerbatim(void)
{
    Verbatim_t *p;
    for (p = g_VerbatimList; p; p = p->next)
    {
        output("/* %s */\n", p->pszVerbatim);
    }
    if (g_VerbatimList)
    {
        output("\n");
    }
}

int CompareDirective(char *pszDirective, char *pszInput)
{
    int rc;
    int len = strlen(pszDirective);
    char ch = pszInput[len];
    pszInput[len] = '\0';
    rc = strcmpi(pszDirective, pszInput);
    pszInput[len] = ch;
    return rc;
}

void SetDirective(char *pszInput)
{
    // verbatim strings
    const char szComment[] = "COMMENT";
    if (! CompareDirective((char *) &szComment[0], pszInput))
    {
        pszInput += sizeof(szComment) - 1;
        if (isspace(*pszInput))
        {
            pszInput++;
            if ('"' == *pszInput++)
            {
                char *pszEnd = strchr(pszInput, '"');
                if (pszEnd)
                {
                    *pszEnd = '\0';
                    RememberVerbatim(pszInput);
                    *pszEnd = '"';
                }
            }
        }
        return;
    }

    // object identifier
    if (! CompareDirective("OID ARRAY", pszInput))
    {
        g_fOidArray = 1;
        return;
    }

    // set of/sequence of w/o size constraint
    if (! CompareDirective("SS.basic SLINKED", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_SinglyLinkedList;
        return;
    }
    if (! CompareDirective("SS.basic DLINKED", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_DoublyLinkedList;
        return;
    }
    if (! CompareDirective("SS.basic LENPTR", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_LengthPointer;
        return;
    }
    if (! CompareDirective("SS.basic ARRAY", pszInput))
    {
        g_eDefTypeRuleSS_NonSized = eTypeRules_FixedArray;
        return;
    }

    // set of/sequence of w/ size constraint
    if (! CompareDirective("SS.sized SLINKED", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_SinglyLinkedList;
        return;
    }
    if (! CompareDirective("SS.sized DLINKED", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_DoublyLinkedList;
        return;
    }
    if (! CompareDirective("SS.sized LENPTR", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_LengthPointer;
        return;
    }
    if (! CompareDirective("SS.sized ARRAY", pszInput))
    {
        g_eDefTypeRuleSS_Sized = eTypeRules_FixedArray;
        return;
    }

    // set extra pointer type for SS construct, its struct name will be postfixed with _s
    if (! CompareDirective("SS.struct EXTRA-PTR-TYPE", pszInput))
    {
        g_fExtraStructPtrTypeSS = 1;
        return;
    }
}

#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\genper.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "optcase.h"

void GenPERFuncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref);
void GenPERStringTableSimpleType(AssignmentList_t ass, PERTypeInfo_t *info);

void GenPEREncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref);
void GenPEREncGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref);
void GenPERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et);
void GenPERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et);

void GenPERDecSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref);
void GenPERDecGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref);

int IsUnconstrainedInteger(PERSimpleTypeInfo_t *sinfo);

extern int g_fDecZeroMemory;
extern int g_nDbgModuleName;
extern unsigned g_cPDUs;
extern int g_fCaseBasedOptimizer;
extern int g_fNoAssert;


/* write header needed for PER encodings */
void
GenPERHeader()
{
//    output("#include \"perfnlib.h\"\n");
}

/* set prototypes and function args of PER functions */
void
GetPERPrototype(Arguments_t *args)
{
    args->enccast = "ASN1encoding_t, void *";
    args->encfunc = "ASN1encoding_t enc, %s *val";
    args->Pencfunc = "ASN1encoding_t enc, P%s *val";
    args->deccast = "ASN1decoding_t, void *";
    args->decfunc = "ASN1decoding_t dec, %s *val";
    args->Pdecfunc = "ASN1decoding_t dec, P%s *val";
    args->freecast = "void *";
    args->freefunc = "%s *val";
    args->Pfreefunc = "P%s *val";
    args->cmpcast = "void *, void *";
    args->cmpfunc = "%s *val1, %s *val2";
    args->Pcmpfunc = "P%s *val1, P%s *val2";
}

/* write initialization function needed for PER encodings */
void
GenPERInit(AssignmentList_t ass, char *module)
{
    output("%s = ASN1_CreateModule(0x%x, ASN1_PER_RULE_ALIGNED, %s, %d, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x%lx);\n",
        module,
        ASN1_THIS_VERSION,
        g_fNoAssert ? "ASN1FLAGS_NOASSERT" : "ASN1FLAGS_NONE",
        g_cPDUs,
        g_nDbgModuleName);
}

/* generate function body for a type */
void GenPERFuncType(AssignmentList_t ass, char *module, Assignment_t *at, TypeFunc_e et)
{
    Type_t *type;
    char *encref;
    char *valref;

    /* get some informations */
    type = at->U.Type.Type;
    switch (et) {
    case eStringTable:
        valref = encref = "";
        break;
    case eEncode:
        encref = "enc";
        valref = "val";
        break;
    case eDecode:
        encref = "dec";
        valref = "val";
        break;
    }

    /* function body */
    switch (type->Type) {
    case eType_Boolean:
    case eType_Integer:
    case eType_Enumerated:
    case eType_Real:
    case eType_BitString:
    case eType_OctetString:
    case eType_UTF8String:
    case eType_Null:
    case eType_EmbeddedPdv:
    case eType_External:
    case eType_ObjectIdentifier:
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_CharacterString:
    case eType_GeneralizedTime:
    case eType_UTCTime:
    case eType_ObjectDescriptor:
    case eType_RestrictedString:
    case eType_Open:
    case eType_Reference:
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, Dereference(valref), et, encref);
        break;

    case eType_SequenceOf:
    case eType_SetOf:
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, Dereference(valref), et, encref);
        break;

    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
        GenPERFuncSequenceSetType(ass, module, at, valref, encref, et);
        break;

    case eType_Choice:
        GenPERFuncChoiceType(ass, module, at, valref, encref, et);
        break;

    case eType_Selection:
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
}

/* generate function body for components */
void
GenPERFuncComponents(AssignmentList_t ass, char *module, uint32_t optindex, ComponentList_t components, char *valref, char *encref, char *oref, TypeFunc_e et, int inextension, int inchoice)
{
    Component_t *com;
    NamedType_t *namedType;
    char *ide;
    char valbuf[256];
    char typebuf[256];
    int conditional, skip;

    /* get a parented encoding_t/decoding_t for sequence/set */
    if (inextension && !inchoice) {
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            outputvar("ASN1encoding_t ee;\n");
            output("if (ASN1_CreateEncoder(%s->module, &ee, NULL, 0, %s) < 0)\n",
                encref, encref);
            output("return 0;\n");
            break;
        case eDecode:
            outputvar("ASN1decoding_t dd;\n");
            break;
        }
    }

    /* emit components of extension root */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker)
            break;

        /* get some information */
        namedType = com->U.NOD.NamedType;
        ide = Identifier2C(namedType->Identifier);

        /* skip unnecessary elements */
        skip = (namedType->Type->Flags & eTypeFlags_Null) && !inextension;

        /* check if optional/default component is present or choice is */
        /* selected */
        conditional = 0;
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
        case eDecode:
            if (inchoice) {
            // lonchanc: we should not skip any case in Decode
            // because we cannot tell skipped cases from extension.
            // on the other hand, in Encode, we'd better not either.
            // when people put in customization in extension,
            // we cannot tell as well.
                if (skip)
                {
                    output("case %d:\nbreak;\n", optindex);
                }
                else
                {
                    output("case %d:\n", optindex);
                    conditional = 1;
                }
                optindex++;
            } else {
                if (com->Type == eComponent_Optional ||
                    com->Type == eComponent_Default ||
                    inextension) {
                    if (!skip) {
                        output("if (%s[%u] & 0x%x) {\n", oref,
                            optindex / 8, 0x80 >> (optindex & 7));
                        conditional = 1;
                    }
                    optindex++;
                }
            }
            break;
        }

        /* get a parented encoding_t/decoding_t for choice */
        if (inextension && inchoice) {
            /* get a parented encoding_t/decoding_t */
            switch (et) {
            case eStringTable:
                break;
            case eEncode:
                outputvar("ASN1encoding_t ee;\n");
                output("if (ASN1_CreateEncoder(%s->module, &ee, NULL, 0, %s) < 0)\n",
                    encref, encref);
                output("return 0;\n");
                break;
            case eDecode:
                outputvar("ASN1decoding_t dd;\n");
                break;
            }
        }

        /* dereference pointer if pointer directive used */
        if (inchoice) {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->u.%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->u.%s", valref, ide);
        } else {
            if (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer)
                sprintf(valbuf, "*(%s)->%s", valref, ide);
            else
                sprintf(valbuf, "(%s)->%s", valref, ide);
        }

        /* allocate memory if decoding and pointer directive used */
        if (et == eDecode &&
            (GetTypeRules(ass, namedType->Type) & eTypeRules_Pointer) &&
            !(GetType(ass, namedType->Type)->Flags & eTypeFlags_Null)) {
            sprintf(typebuf, "%s *",
                GetTypeName(ass, namedType->Type));
            output("if (!(%s = (%s)ASN1DecAlloc(%s, sizeof(%s))))\n",
                Reference(valbuf), typebuf, encref, valbuf);
            output("return 0;\n");
        }

        /* handle subtype value */
        if (!skip) {
            if (!inextension) {
                GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                    valbuf, et, encref);
            } else {
                switch (et) {
                case eStringTable:
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, encref);
                    break;
                case eEncode:
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, "ee");
                        // lonchanc: added the following API to replace the following
                        // chunk of code.
                        output("if (!ASN1PEREncFlushFragmentedToParent(ee))\n");
                    // output("if (!ASN1PEREncFlush(ee))\n");
                    // output("return 0;\n");
                    // output("if (!ASN1PEREncFragmented(%s, ee->len, ee->buf, 8))\n",
                        // encref);
                    output("return 0;\n");
                    break;
                case eDecode:
                    outputvar("ASN1octet_t *db;\n");
                    outputvar("ASN1uint32_t ds;\n");
                    output("if (!ASN1PERDecFragmented(%s, &ds, &db, 8))\n",
                        encref);
                    output("return 0;\n");
                    output("if (ASN1_CreateDecoderEx(%s->module, &dd, db, ds, %s, ASN1DECODE_AUTOFREEBUFFER) < 0)\n",
                        encref, encref);
                    output("return 0;\n");
                    GenPERFuncSimpleType(ass, &namedType->Type->PERTypeInfo,
                        valbuf, et, "dd");
                    output("ASN1_CloseDecoder(dd);\n");
                    // output("DecMemFree(%s, db);\n", encref);
                    break;
                }
            }
        }

        /* drop the parented encoding_t/decoding_t for choice */
        if (inextension && inchoice) {
            if (et == eEncode) {
                output("ASN1_CloseEncoder2(ee);\n");
            }
        }

        /* end of check for presence of optional/default component */
        if (inchoice) {
            if (conditional)
                output("break;\n");
        } else {
            if (conditional)
                output("}\n");
        }
    }

    /* drop the parented encoding_t/decoding_t for sequence/set */
    if (inextension && !inchoice) {
        if (et == eEncode) {
            output("ASN1_CloseEncoder2(ee);\n");
        }
    }
}

/* generate function body for sequence/set type */
void GenPERFuncSequenceSetType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et)
{
    uint32_t optionals, extensions;
    Component_t *components, *com;
    PERTypeInfo_t inf;
    Type_t *type;
    char valbuf[256];
    int conditional;
    char obuf[256];

    type = at->U.Type.Type;
    optionals = type->U.SSC.Optionals;
    extensions = type->U.SSC.Extensions;
    components = type->U.SSC.Components;
    inf.Identifier = NULL;
    inf.Flags = 0;
    inf.Rules = 0;
    inf.EnumerationValues = NULL;
    inf.NOctets = 0;
    inf.Type = eExtension_Unextended;
    inf.Root.TableIdentifier = NULL;
    inf.Root.Table = NULL;
    inf.Root.Data = ePERSTIData_Extension;
    inf.Root.SubType = NULL;
    inf.Root.SubIdentifier = NULL;
    inf.Root.NBits = 0;
    inf.Root.Constraint = ePERSTIConstraint_Unconstrained;
    intx_setuint32(&inf.Root.LowerVal, 0);
    intx_setuint32(&inf.Root.UpperVal, 0);
    inf.Root.Alignment = ePERSTIAlignment_BitAligned;
    inf.Root.Length = ePERSTILength_NoLength;
    inf.Root.LConstraint = ePERSTIConstraint_Unconstrained;
    inf.Root.LLowerVal = 0;
    inf.Root.LUpperVal = 0;
    inf.Root.LNBits = 0;
    inf.Root.LAlignment = ePERSTIAlignment_OctetAligned;

    /* set/clear missing bits in optional/default bit field */
    GenFuncSequenceSetOptionals(ass, valref, components,
        optionals, extensions, obuf, et);

    /* emit/get extension bit if needed */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        switch (et) {
        case eStringTable:
            break;
        case eEncode:
            if (type->Flags & eTypeFlags_ExtensionMarker) {
                if (!extensions) {
                    if (g_fCaseBasedOptimizer)
                    {
                        output("if (!ASN1PEREncExtensionBitClear(%s))\n", encref);
                    }
                    else
                    {
                        output("if (!ASN1PEREncBitVal(%s, 1, 0))\n", encref);
                    }
                    output("return 0;\n");
                } else {
                    outputvar("ASN1uint32_t y;\n");
                    output("y = ASN1PEREncCheckExtensions(%d, %s + %d);\n",
                        extensions, strcmp(obuf, "o") ? obuf : "(val)->o", (optionals + 7) / 8);
                    output("if (!ASN1PEREncBitVal(%s, 1, y))\n",
                        encref);
                    output("return 0;\n");
                }
            }
            break;
        case eDecode:
            if (type->Flags & eTypeFlags_ExtensionMarker) {
                outputvar("ASN1uint32_t y;\n");
                if (g_fCaseBasedOptimizer)
                {
                    output("if (!ASN1PERDecExtensionBit(%s, &y))\n", encref);
                }
                else
                {
                    output("if (!ASN1PERDecBit(%s, &y))\n", encref);
                }
                output("return 0;\n");
            }
            break;
        }
    }

    /* emit/get bit field of optionals */
    if (optionals) {
        inf.Root.NBits = optionals;
        inf.Root.Length = ePERSTILength_NoLength;
        if (optionals >= 0x10000)
            MyAbort();
        GenPERFuncSimpleType(ass, &inf, obuf, et, encref);
    }

    /* emit components of extension root */
    GenPERFuncComponents(ass, module, 0, components,
        valref, encref, obuf, et, 0, 0);

    /* handle extensions */
    if (type->Flags & eTypeFlags_ExtensionMarker) {
        conditional = 0;
        if (!extensions) {

            /* skip unknown extension bit field */
            if (et == eDecode) {
                output("if (y) {\n");
                inf.Root.NBits = 1;
                inf.Root.Length = ePERSTILength_SmallLength;
                inf.Root.LConstraint = ePERSTIConstraint_Semiconstrained;
                inf.Root.LLowerVal = 1;
                if (g_fCaseBasedOptimizer)
                {
                    output("if (!ASN1PERDecSkipNormallySmallExtensionFragmented(%s))\n",
                            encref);
                    output("return 0;\n");
                    output("}\n");
                    goto FinalTouch;
                }
                else
                {
                    GenPERFuncSimpleType(ass, &inf, NULL, et, encref);
                    conditional = 1;
                }
            }

        } else {

            /* check if extension bit is set */
            switch (et) {
            case eStringTable:
                break;
            case eEncode:
                output("if (y) {\n");
                conditional = 1;
                break;
            case eDecode:
                output("if (!y) {\n");
                output("ZeroMemory(%s + %d, %d);\n", obuf,
                    (optionals + 7) / 8, (extensions + 7) / 8);
                output("} else {\n");
                conditional = 1;
                break;
            }

            /* emit/get bit field of extensions */
            inf.Root.NBits = extensions;
            inf.Root.Length = ePERSTILength_SmallLength;
            inf.Root.LConstraint = ePERSTIConstraint_Semiconstrained;
            inf.Root.LLowerVal = 1;
            sprintf(valbuf, "%s + %d", obuf, (optionals + 7) / 8);
            GenPERFuncSimpleType(ass, &inf, valbuf, et, encref);

            /* get start of extensions */
            for (com = components; com; com = com->Next) {
                if (com->Type == eComponent_ExtensionMarker) {
                    com = com->Next;
                    break;
                }
            }

            /* emit components of extension */
            GenPERFuncComponents(ass, module, (optionals + 7) & ~7, com,
                valref, encref, obuf, et, 1, 0);
        }

        /* skip unknown extensions */
        if (et == eDecode) {
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t e;\n");
            output("for (i = 0; i < e; i++) {\n");
            output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                encref);
            output("return 0;\n");
            output("}\n");
        }

        /* end of extension handling */
        if (conditional)
            output("}\n");
    }

FinalTouch:

    /* some user-friendly assignments for non-present optional/default */
    /* components */
    GenFuncSequenceSetDefaults(ass, valref, components, obuf, et);
}

/* generate function body for choice type */
void GenPERFuncChoiceType(AssignmentList_t ass, char *module, Assignment_t *at, char *valref, char *encref, TypeFunc_e et)
{
    Type_t *type;
    char valbuf[256];
    uint32_t alternatives;
    Component_t *components, *com;
    int fOptimizeCase = 0;

    /* get some informations */
    type = at->U.Type.Type;
    alternatives = type->U.SSC.Alternatives;
    components = type->U.SSC.Components;

    /* encode choice selector */
    switch (et) {
    case eStringTable:
        sprintf(valbuf, "(%s)->choice", valref);
        break;
    case eEncode:
        sprintf(valbuf, "(%s)->choice", valref);
        if (g_fCaseBasedOptimizer)
        {
            switch (type->PERTypeInfo.Type)
            {
            case eExtension_Unconstrained:
                break;
            case eExtension_Unextended: // no extension mark at all
                output("if (!ASN1PEREncSimpleChoice(%s, %s, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extendable: // extension mark exists, but no choice appears after the mark
                output("if (!ASN1PEREncSimpleChoiceEx(%s, %s, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extended: // extension mark exists, but some choices appear after the mark
                output("if (!ASN1PEREncComplexChoice(%s, %s, %u, %u))\n",
                        encref, valbuf, type->PERTypeInfo.Root.NBits, intx2uint32(&(type->PERTypeInfo.Additional.LowerVal)));
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            }
        }
        if (ASN1_CHOICE_BASE)
        {
            sprintf(valbuf, "(%s)->choice - %d", valref, ASN1_CHOICE_BASE);
        }
        break;
    case eDecode:
        sprintf(valbuf, "(%s)->choice", valref);
        if (g_fCaseBasedOptimizer)
        {
            switch (type->PERTypeInfo.Type)
            {
            case eExtension_Unconstrained:
                break;
            case eExtension_Unextended: // no extension mark at all
                output("if (!ASN1PERDecSimpleChoice(%s, %s, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extendable: // extension mark exists, but no choice appears after the mark
                output("if (!ASN1PERDecSimpleChoiceEx(%s, %s, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits);
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            case eExtension_Extended: // extension mark exists, but some choices appear after the mark
                output("if (!ASN1PERDecComplexChoice(%s, %s, %u, %u))\n",
                        encref, Reference(valbuf), type->PERTypeInfo.Root.NBits, intx2uint32(&(type->PERTypeInfo.Additional.LowerVal)));
                output("return 0;\n");
                fOptimizeCase = 1;
                break;
            }
        }
        break;
    }

    if (! fOptimizeCase)
    {
        if (eDecode == et)
        {
            output("%s = %d;\n", valbuf, ASN1_CHOICE_INVALID);
        }
        GenPERFuncSimpleType(ass, &type->PERTypeInfo, valbuf, et, encref);

        // lonchanc: in case of decoding, we need to increment choice value
        // by the amount of ASN1_CHOICE_BASE
        if (et == eDecode && ASN1_CHOICE_BASE)
        {
            output("(%s)->choice += %d;\n", valref, ASN1_CHOICE_BASE);
        }
    }

    /* finished if choice only contains NULL alternatives or if choice */
    /* contains no data to free */
    if (type->Flags & eTypeFlags_NullChoice)
        return;

    /* create switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eDecode:
    case eEncode:
        output("switch ((%s)->choice) {\n", valref);
        break;
    }

    /* generate components of extension root */
    GenPERFuncComponents(ass, module, ASN1_CHOICE_BASE, components,
        valref, encref, NULL, et, 0, 1);

    /* get start of extensions */
    for (com = components; com; com = com->Next) {
        if (com->Type == eComponent_ExtensionMarker) {
            com = com->Next;
            break;
        }
    }

    /* generate components of extension */
    GenPERFuncComponents(ass, module, ASN1_CHOICE_BASE + alternatives, com,
        valref, encref, NULL, et, 1, 1);

    /* skip unknown extensions */
    if (et == eDecode && (type->Flags & eTypeFlags_ExtensionMarker)) {
        output("case %d:\n\t/* extension case */\n", ASN1_CHOICE_INVALID + 1);
        output("if (!ASN1PERDecSkipFragmented(%s, 8))\n", encref);
        output("return 0;\n");
        output("break;\n");
    }

    // debug purpose
    switch (et)
    {
    case eEncode:
        output("default:\n\t/* impossible */\n");
        output("ASN1EncSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        break;
    case eDecode:
        output("default:\n\t/* impossible */\n");
        output("ASN1DecSetError(%s, ASN1_ERR_CHOICE);\n", encref);
        output("return 0;\n");
        break;
    }

    /* end of switch statement */
    switch (et) {
    case eStringTable:
        break;
    case eEncode:
    case eDecode:
        output("}\n");
        break;
    }
}

/* generate function body for simple type */
void
GenPERFuncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, TypeFunc_e et, char *encref)
{
    switch (et) {
    case eStringTable:
        GenPERStringTableSimpleType(ass, info);
        break;
    case eEncode:
        GenPEREncSimpleType(ass, info, valref, encref);
        break;
    case eDecode:
        GenPERDecSimpleType(ass, info, valref, encref);
        break;
    }
}

/* generate string table for a simple type */
void
GenPERStringTableSimpleType(AssignmentList_t ass, PERTypeInfo_t *info)
{
    ValueConstraint_t *pc;
    uint32_t i, n, lo, up;

    switch (info->Root.Data) {
    case ePERSTIData_String:
    case ePERSTIData_TableString:
    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:
        if (info->Root.TableIdentifier) {
            if (!strcmp(info->Root.TableIdentifier, "ASN1NumericStringTable"))
                break;
            output("static ASN1stringtableentry_t %sEntries[] = {\n",
                info->Root.TableIdentifier);
            i = n = 0;
            for (pc = info->Root.Table; pc; pc = pc->Next) {
                lo = GetValue(ass, pc->Lower.Value)->
                    U.RestrictedString.Value.value[0];
                up = GetValue(ass, pc->Upper.Value)->
                    U.RestrictedString.Value.value[0];
                output("{ %u, %u, %u }, ", lo, up, n);
                n += (up - lo) + 1;
                i++;
                if ((i & 3) == 3 || !pc->Next)
                    output("\n");
            }
            output("};\n");
            output("\n");
            output("static ASN1stringtable_t %s = {\n",
                info->Root.TableIdentifier);
            output("%d, %sEntries\n", i, info->Root.TableIdentifier);
            output("};\n");
            output("\n");
        }
        break;

    case ePERSTIData_SetOf:
    case ePERSTIData_SequenceOf:
        GenPERFuncSimpleType(ass, &info->Root.SubType->PERTypeInfo, "", eStringTable, "");
        break;
    }
}

/* generate encoding statements for a simple value */
void
GenPEREncSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref)
{
    uint32_t i;
    char lbbuf[256], ubbuf[256];
    char *lenref;
    char lenbuf[256], valbuf[256];
    char *p;
    PERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Root.Data) {
    case ePERSTIData_BitString:
    case ePERSTIData_RZBBitString:

        if (inf.Root.cbFixedSizeBitString)
        {
            sprintf(lenbuf, "%u", inf.Root.LUpperVal);
            sprintf(valbuf, "&(%s)", valref);
            lenref = lenbuf;
            valref = valbuf;
            break;
        }

        // lonchanc: intentionally fall through

    case ePERSTIData_OctetString:

        if (g_fCaseBasedOptimizer)
        {
            if (inf.Root.Data == ePERSTIData_OctetString && inf.Type == eExtension_Unextended)
            {
                switch (inf.Root.Length)
                {
                case ePERSTILength_NoLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal == inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // fixed size constraint, eg. OCTET STRING (SIZE (8))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PEREncOctetString_FixedSizeEx(%s, %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        else
                        {
                            output("if (!ASN1PEREncOctetString_FixedSize(%s, (ASN1octetstring2_t *) %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_Length:
                    break;
                case ePERSTILength_BitLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal < inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // variable size constraint, eg. OCTET STRING (SIZE (4..16))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PEREncOctetString_VarSizeEx(%s, %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        else
                        {
                            output("if (!ASN1PEREncOctetString_VarSize(%s, (ASN1octetstring2_t *) %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_SmallLength:
                    break;
                case ePERSTILength_InfiniteLength: // no size constraint, eg OCTET STRING
                    /* encode octet string in fragmented format */
                    output("if (!ASN1PEREncOctetString_NoSize(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                    return;
                } // switch
            } // if
        }

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_UTF8String:

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* length and value of bit string, octet string and string */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_SequenceOf:
    case ePERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            if (inf.Rules & eTypeRules_PointerToElement)
            {
                sprintf(lenbuf, "(%s)->count", valref);
                sprintf(valbuf, "(%s)->%s", valref, GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            else
            {
                sprintf(lenbuf, "(%s)->count", Reference(valref));
                sprintf(valbuf, "(%s)->%s", Reference(valref), GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            /* use a loop for sequence of/set of value with */
            /* list representation */

            if (g_fCaseBasedOptimizer)
            {
                if (PerOptCase_IsTargetSeqOf(&inf))
                {
                    // generate the iterator
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Enc_%s_ElmFn", inf.Identifier);
                    sprintf(szElmFnDecl, "int ASN1CALL %s(ASN1encoding_t %s, P%s val)",
                        szElmFn, encref, inf.Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    if ((inf.Root.LLowerVal == 0 && inf.Root.LUpperVal == 0) ||
                        (inf.Root.LUpperVal >= 64 * 1024)
                       )
                    {
                        output("return ASN1PEREncSeqOf_NoSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_encfn) %s);\n",
                            encref, Reference(valref), szElmFn);
                    }
                    else
                    {
                        if (inf.Root.LLowerVal == inf.Root.LUpperVal)
                            MyAbort();
                        output("return ASN1PEREncSeqOf_VarSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_encfn) %s, %u, %u, %u);\n",
                            encref, Reference(valref), szElmFn,
                            inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                    }
                    output("}\n\n"); // end of iterator body

                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    sprintf(valbuf, "val->%s", GetPrivateValueName(inf.pPrivateDirectives, "value"));
                    GenPERFuncSimpleType(ass, &inf.Root.SubType->PERTypeInfo, valbuf,
                        eEncode, encref);
                    // end of element body
                    return;
                }
            }

            outputvar("ASN1uint32_t t;\n");
            outputvar("P%s f;\n", inf.Identifier);
            output("for (t = 0, f = %s; f; f = f->next)\n", valref);
            output("t++;\n");
            lenref = "t";

        } else {
            MyAbort();
        }
        break;

    case ePERSTIData_ZeroString:
    case ePERSTIData_ZeroTableString:

        /* length of a zero-terminated string value */
        outputvar("ASN1uint32_t t;\n");
        output("t = lstrlenA(%s);\n", valref);
        lenref = "t";
        break;

    case ePERSTIData_Boolean:

        /* value of a boolean value */

        if (g_fCaseBasedOptimizer)
        {
            if (PerOptCase_IsBoolean(&inf.Root))
            {
                lenref = NULL;
                break;
            }
        }

        sprintf(valbuf, "(%s) ? 1 : 0", valref);
        valref = valbuf;
        lenref = NULL;
        inf.Root.Data = ePERSTIData_Unsigned;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* map enumeration values */
    if (inf.EnumerationValues) {
        outputvar("ASN1uint32_t u;\n");
        output("switch (%s) {\n", valref);
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", intx2uint32(inf.EnumerationValues[i]));
            output("u = %u;\n", i);
            output("break;\n");
        }
        output("}\n");
        valref = "u";
        inf.NOctets = 4;
    }

    /* check for extended values */
    if (inf.Type == eExtension_Extended) {
        switch (inf.Root.Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            switch (inf.Root.Constraint) {
            case ePERSTIConstraint_Unconstrained:
                inf.Type = eExtension_Extendable;
                break;
            case ePERSTIConstraint_Semiconstrained:
                if (inf.NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", inf.Identifier);
                    outputvarintx(lbbuf, &inf.Root.LowerVal);
                    output("if (ASN1intx_cmp(%s, &%s) >= 0) {\n",
                        Reference(valref), lbbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s >= %d) {\n",
                        valref, intx2int32(&inf.Root.LowerVal));
                } else {
                    if (intx2uint32(&inf.Root.LowerVal) > 0) {
                        output("if (%s >= %u) {\n",
                            valref, intx2uint32(&inf.Root.LowerVal));
                    } else {
                        inf.Type = eExtension_Extendable;
                    }
                }
                break;
            case ePERSTIConstraint_Upperconstrained:
                if (inf.NOctets == 0) {
                    sprintf(ubbuf, "%s_ub", inf.Identifier);
                    outputvarintx(ubbuf, &inf.Root.UpperVal);
                    output("if (ASN1intx_cmp(%s, &%s) <= 0) {\n",
                        Reference(valref), ubbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s <= %d) {\n",
                        valref, intx2int32(&inf.Root.UpperVal));
                } else {
                    output("if (%s <= %u) {\n",
                        valref, intx2uint32(&inf.Root.UpperVal));
                }
                break;
            case ePERSTIConstraint_Constrained:
                if (inf.NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", inf.Identifier);
                    sprintf(ubbuf, "%s_ub", inf.Identifier);
                    outputvarintx(lbbuf, &inf.Root.LowerVal);
                    outputvarintx(ubbuf, &inf.Root.UpperVal);
                    output("if (ASN1intx_cmp(%s, &%s) >= 0 && ASN1intx_cmp(%s, &%s) <= 0) {\n",
                        Reference(valref), lbbuf, Reference(valref), ubbuf);
                } else if (inf.Root.Data == ePERSTIData_Integer) {
                    output("if (%s >= %d && %s <= %d) {\n",
                        valref, intx2int32(&inf.Root.LowerVal),
                        valref, intx2int32(&inf.Root.UpperVal));
                } else {
                    if (intx2uint32(&inf.Root.LowerVal) > 0) {
                        output("if (%s >= %u && %s <= %u) {\n",
                            valref, intx2uint32(&inf.Root.LowerVal),
                            valref, intx2uint32(&inf.Root.UpperVal));
                    } else {
                        output("if (%s <= %u) {\n",
                            valref, intx2uint32(&inf.Root.UpperVal));
                    }
                }
                break;
            }
            break;
        case ePERSTIData_SequenceOf:
        case ePERSTIData_SetOf:
        case ePERSTIData_OctetString:
        case ePERSTIData_UTF8String:
        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:
        case ePERSTIData_Extension:
            switch (inf.Root.LConstraint) {
            case ePERSTIConstraint_Semiconstrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u) {\n",
                        lenref, inf.Root.LLowerVal);
                } else {
                    inf.Type = eExtension_Extendable;
                }
                break;
            case ePERSTIConstraint_Constrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u && %s <= %u) {\n",
                        lenref, inf.Root.LLowerVal, lenref, inf.Root.LUpperVal);
                } else {
                    output("if (%s <= %u) {\n",
                        lenref, inf.Root.LUpperVal);
                }
                break;
            }
            break;
        case ePERSTIData_String:
        case ePERSTIData_TableString:
        case ePERSTIData_ZeroString:
        case ePERSTIData_ZeroTableString:
            inf.Type = eExtension_Extendable;
            switch (inf.Root.LConstraint) {
            case ePERSTIConstraint_Semiconstrained:
                if (inf.Root.LLowerVal != 0) {
                    output("if (%s >= %u",
                        lenref, inf.Root.LLowerVal);
                    inf.Type = eExtension_Extended;
                }
                break;
            case ePERSTIConstraint_Constrained:
                output("if (%s >= %u && %s <= %u",
                    lenref, inf.Root.LLowerVal, lenref, inf.Root.LUpperVal);
                inf.Type = eExtension_Extended;
                break;
            }
            if (inf.Root.TableIdentifier) {
                if (inf.Type == eExtension_Extended)
                    output(" && ");
                else
                    output("if (");
                if (inf.NOctets == 1) {
                    p = "Char";
                } else if (inf.NOctets == 2) {
                    p = "Char16";
                } else if (inf.NOctets == 4) {
                    p = "Char32";
                } else
                    MyAbort();
                output("ASN1PEREncCheckTable%sString(%s, %s, %s)",
                    p, lenref, valref, Reference(inf.Root.TableIdentifier));
                inf.Type = eExtension_Extended;
            }
            if (inf.Type == eExtension_Extended)
                output(") {\n");
            break;
        }
    }

    /* encode unset extension bit */
    if (inf.Type > eExtension_Unextended) {
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PEREncExtensionBitClear(%s))\n", encref);
        }
        else
        {
            output("if (!ASN1PEREncBitVal(%s, 1, 0))\n", encref);
        }
        output("return 0;\n");
    }

    /* encode unextended value (of extension root) */
    GenPEREncGenericUnextended(ass, &inf, &inf.Root, valref, lenref, encref);

    /* type is extended? */
    if (inf.Type == eExtension_Extended) {
        output("} else {\n");

        /* encode set extension bit */
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PEREncExtensionBitSet(%s))\n", encref);
        }
        else
        {
            output("if (!ASN1PEREncBitVal(%s, 1, 1))\n", encref);
        }
        output("return 0;\n");

        /* encode extended value (of extension addition) */
        GenPEREncGenericUnextended(ass, &inf, &inf.Additional, valref, lenref, encref);
        output("}\n");
    }
}

/* generate encoding statements for a simple value (after some special */
/* handling has been done, esp. the evaluation of the extension) */
void GenPEREncGenericUnextended(AssignmentList_t ass, PERTypeInfo_t *info, PERSimpleTypeInfo_t *sinfo, char *valref, char *lenref, char *encref)
{
    char valbuf[256];
    char *lvref, lvbuf[256];
    char lbbuf[256];
    char *p;

    /* check for empty field */
    if (sinfo->NBits == 0)
        return;

    /* initial calculations for value encoding: */
    /* substract lower bound of constraint/semiconstraint value */
    /* for Integer and NormallySmall */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (!info->NOctets) {

                /* calculate value-lowerbound for intx_t values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    sprintf(lbbuf, "%s_lb", info->Identifier);
                    outputvar("ASN1intx_t newval;\n");
                    outputvarintx(lbbuf, &sinfo->LowerVal);
                    output("ASN1intx_sub(&newval, %s, &%s);\n",
                        Reference(valref), lbbuf);
                    valref = "newval";
                }
            } else if (sinfo->Data == ePERSTIData_Integer) {

                /* calculate value-lowerbound for intx_t values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0)) {
                    char szLowB[24];
                    sprintf(&szLowB[0], "%d", intx2int32(&sinfo->LowerVal));
                    if (szLowB[0] == '-')
                        sprintf(valbuf, "%s + %s", valref, &szLowB[1]); // minus minus become plus
                    else
                        sprintf(valbuf, "%s - %s", valref, &szLowB[0]);
                    valref = valbuf;
                }
            } else {

                /* calculate value-lowerbound for integer values */
                if (intx_cmp(&sinfo->LowerVal, &intx_0)) {
                    sprintf(valbuf, "%s - %u", valref, intx2uint32(&sinfo->LowerVal));
                    valref = valbuf;
                }
            }

            /* semiconstraint/constraint values will be encoded as unsigned */
            if (sinfo->Data == ePERSTIData_Integer)
                sinfo->Data = ePERSTIData_Unsigned;
            break;
        }
        break;
    }

    /* general rules */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned &&
        sinfo->Length == ePERSTILength_BitLength &&
        !(sinfo->LNBits & 7))
        sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* octet alignment will be given by length */
    if (sinfo->Length == ePERSTILength_InfiniteLength &&
        (sinfo->Data == ePERSTIData_Integer && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_Unsigned && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_BitString ||
        sinfo->Data == ePERSTIData_RZBBitString ||
        sinfo->Data == ePERSTIData_Extension ||
        sinfo->Data == ePERSTIData_OctetString ||
        sinfo->Data == ePERSTIData_UTF8String ||
        sinfo->Data == ePERSTIData_SequenceOf ||
        sinfo->Data == ePERSTIData_SetOf ||
        sinfo->Data == ePERSTIData_String ||
        sinfo->Data == ePERSTIData_TableString ||
        sinfo->Data == ePERSTIData_ZeroString ||
        sinfo->Data == ePERSTIData_ZeroTableString) ||
        sinfo->Data == ePERSTIData_ObjectIdentifier ||
        sinfo->Data == ePERSTIData_Real ||
        sinfo->Data == ePERSTIData_GeneralizedTime ||
        sinfo->Data == ePERSTIData_UTCTime ||
        sinfo->Data == ePERSTIData_External ||
        sinfo->Data == ePERSTIData_EmbeddedPdv ||
        sinfo->Data == ePERSTIData_MultibyteString ||
        sinfo->Data == ePERSTIData_UnrestrictedString ||
        sinfo->Data == ePERSTIData_Open)
        sinfo->LAlignment = sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* alignment will be done by encoding fn */
    if (sinfo->Length == ePERSTILength_NoLength ||
        sinfo->Length == ePERSTILength_SmallLength)
        sinfo->LAlignment = ePERSTIAlignment_BitAligned;
                                /* no alignment of no/small length */

    /* special initial calculations */
    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* remove trailing zero-bits */
        outputvar("ASN1uint32_t r;\n");
        output("r = %s;\n", lenref);
        output("ASN1PEREncRemoveZeroBits(&r, %s, %u);\n",
            valref, sinfo->LLowerVal);
        if (sinfo->LLowerVal) {
            outputvar("ASN1uint32_t s;\n");
            output("s = r < %u ? %u : r;\n", sinfo->LLowerVal, sinfo->LLowerVal);
            lenref = "s";
        } else {
            lenref = "r";
        }
            break;
    }

    if (g_fCaseBasedOptimizer)
    {
        // lonchanc: special handling for macro operations
        if (PerOptCase_IsSignedInteger(sinfo))
        {
            output("if (!ASN1PEREncInteger(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsUnsignedInteger(sinfo))
        {
            output("if (!ASN1PEREncUnsignedInteger(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsUnsignedShort(sinfo))
        {
            output("if (!ASN1PEREncUnsignedShort(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
        if (PerOptCase_IsBoolean(sinfo))
        {
            output("if (!ASN1PEREncBoolean(%s, %s))\n", encref, valref);
            output("return 0;\n");
            return;
        }
    }

    /* initial calculations for length: */
    /* get length of integer numbers if length req. */
    switch (sinfo->Length) {
    case ePERSTILength_BitLength:
    case ePERSTILength_InfiniteLength:
        switch (sinfo->Constraint) {
        case ePERSTIConstraint_Unconstrained:
        case ePERSTIConstraint_Upperconstrained:
            switch (sinfo->Data) {
            case ePERSTIData_Integer:
            case ePERSTIData_Unsigned:
                if (info->NOctets != 0) {
                    outputvar("ASN1uint32_t l;\n");
                    if (sinfo->Data == ePERSTIData_Integer)
                        output("l = ASN1int32_octets(%s);\n", valref);
                    else
                        output("l = ASN1uint32_octets(%s);\n", valref);
                    lenref = "l";
                } else {
                    if (sinfo->Length != ePERSTILength_InfiniteLength) {
                        outputvar("ASN1uint32_t l;\n");
                        output("l = ASN1intx_octets(%s);\n",
                            Reference(valref));
                        lenref = "l";
                    }
                }
                break;
            }
            break;
        case ePERSTIConstraint_Semiconstrained:
        case ePERSTIConstraint_Constrained:
            switch (sinfo->Data) {
            case ePERSTIData_Integer:
            case ePERSTIData_Unsigned:
                if (info->NOctets != 0) {
                    outputvar("ASN1uint32_t l;\n");
                    output("l = ASN1uint32_uoctets(%s);\n", valref);
                    lenref = "l";
                } else {
                    if (sinfo->Length != ePERSTILength_InfiniteLength) {
                        outputvar("ASN1uint32_t l;\n");
                        output("l = ASN1intx_uoctets(%s);\n",
                            Reference(valref));
                        lenref = "l";
                    }
                }
                break;
            }
            break;
        }
        break;
    }

    /* initial settings for length enconding: */
    /* substract lower bound of length from length */
    if (sinfo->LLowerVal != 0 && lenref) {
        sprintf(lvbuf, "%s - %u", lenref, sinfo->LLowerVal);
        lvref = lvbuf;
    } else {
        lvref = lenref;
    }

    /* length encoding */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned) {
        output("ASN1PEREncAlignment(%s);\n", encref);
    }
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* not length used */
        break;

    case ePERSTILength_BitLength:

        /* length will be encoded in a bit field */
        output("if (!ASN1PEREncBitVal(%s, %u, %s))\n",
            encref, sinfo->LNBits, lvref);
        output("return 0;\n");
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case: encode length only for integer values, */
        /* other length encodings will be the encoding function */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, 8, %s))\n",
                    encref, lvref);
                output("return 0;\n");
            }
            break;
        }
        break;
    }

    /* special initial calculations */
    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* real length of the bit string */
        lenref = "r";
        break;
    }

    /* value encoding */
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* encode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PEREncAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode the value as bit field */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PEREncBitIntx(%s, %u, %s))\n",
                    encref, sinfo->NBits, Reference(valref));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_NormallySmall:

            /* encode the value as normally small number */
            output("if (!ASN1PEREncNormallySmall(%s, %s))\n",
                encref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode bit string in a bit field */
            output("if (!ASN1PEREncBits(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode octet string in a bit field */
            output("if (!ASN1PEREncBits(%s, %s * 8, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode octet string in a bit field */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_Extension:

            /* encode extension bits in a bit field */
            output("if (!ASN1PEREncBits(%s, %u, %s))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:

            /* same as BitLength encoding */
            goto SetOfEncoding;

        case ePERSTIData_SequenceOf:

            /* same as BitLength encoding */
            goto SequenceOfEncoding;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:

            /* same as BitLength encoding */
            goto StringEncoding;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:

            /* same as BitLength encoding */
            goto TableStringEncoding;

        case ePERSTIData_Reference:

            /* call encoding function of referenced type */
            output("if (!ASN1Enc_%s(%s, %s))\n",
                Identifier2C(sinfo->SubIdentifier),
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_Real:

            /* encode real value */
            if (info->NOctets)
                output("if (!ASN1PEREncDouble(%s, %s))\n",
                    encref, valref);
            else
                output("if (!ASN1PEREncReal(%s, %s))\n",
                    encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_GeneralizedTime:

            /* encode generalized time value */
            output("if (!ASN1PEREncGeneralizedTime(%s, %s, %d))\n",
                encref, Reference(valref), sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_UTCTime:

            /* encode utc time value */
            output("if (!ASN1PEREncUTCTime(%s, %s, %d))\n",
                encref, Reference(valref), sinfo->NBits);
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_BitLength:

        /* encode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PEREncAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode the value as bit field */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %s * 8, %s))\n",
                    encref, lenref, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PEREncBitIntx(%s, %s * 8, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode the value as bit field */
            output("if (!ASN1PEREncBits(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode the value as bit field */
            output("if (!ASN1PEREncBits(%s, %s * 8, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode the value as bit field */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:
        SetOfEncoding:

            /* skip null set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            /* canonical PER? */
            if (g_eSubEncodingRule == eSubEncoding_Canonical) {

                /* encode the elements one by one and sort them */
                outputvar("ASN1uint32_t i;\n");
                outputvar("ASN1encoding_t e, *p;\n");
                if (info->Rules &
                    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
                    MyAbort(); /*XXX*/
                output("if (%s) {\n", lenref);
                output("e = p = (ASN1encoding_t)malloc(%s * sizeof(ASN1encoding_t));\n",
                    lenref);
                output("ZeroMemory(b, %s * sizeof(ASN1encoding_t));\n", lenref);
                output("for (i = 0; i < %s; i++, p++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eEncode, encref);
                output("}\n");
                output("qsort(e, %s, sizeof(ASN1encoding_t), ASN1PEREncCmpEncodings);\n",
                    lenref);
                output("}\n");

                /* then dump them */
                output("for (p = e, i = 0; i < %s; i++, p++) {\n", lenref);
                output("if (!ASN1PEREncBits(%s, (p->pos - p->buf) * 8 + p->bit, p->buf))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                break;
            }

            /* again in non-canonical PER: */
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:
        SequenceOfEncoding:

            /* skip null sequence of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                /* loop over all elements */
                outputvar("ASN1uint32_t i;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);

            }
            else
            if (info->Rules & eTypeRules_LinkedListMask)
            {
                /* iterate over all elements */
                outputvar("P%s f;\n", info->Identifier);
                output("for (f = %s; f; f = f->next) {\n", valref);
                sprintf(valbuf, "f->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
            }

            /* encode the element */
            GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf,
                eEncode, encref);

            /* loop end */
            output("}\n");
            break;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:
        StringEncoding:

            /* encode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREnc%sString(%s, %s, %s, %u))\n",
                p, encref, lenref, valref, sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:
        TableStringEncoding:

            /* encode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncTable%sString(%s, %s, %s, %u, %s))\n",
                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_InfiniteLength:
        /* infinite length case */

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* encode an integer in fragmented format */
            if (info->NOctets != 0) {
                output("if (!ASN1PEREncBitVal(%s, %s * 8, %s))\n",
                    encref, lenref, valref);
                output("return 0;\n");
            } else {
                if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PEREncFragmentedIntx(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PEREncFragmentedUIntx(%s, %s))\n",
                        encref, Reference(valref));
                    output("return 0;\n");
                }
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* encode bit string in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %s, %s, 1))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_OctetString:

            /* encode octet string in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %s, %s, 8))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UTF8String:

            /* encode octet string in fragmented format */
            output("if (!ASN1PEREncUTF8String(%s, %s, %s))\n",
                encref, lenref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_Extension:

            /* encode extension bits in fragmented format */
            output("if (!ASN1PEREncFragmented(%s, %u, %s, 1))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_SetOf:

            /* skip null set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            /* canonical PER? */
            if (g_eSubEncodingRule == eSubEncoding_Canonical) {

                /* encode the elements one by one and sort them */
                outputvar("ASN1uint32_t i;\n");
                outputvar("ASN1uint32_t j, n = 0x4000;\n");
                outputvar("ASN1encoding_t e, *p;\n");
                if (info->Rules &
                    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
                    MyAbort(); /*XXX*/
                output("if (%s) {\n", lenref);
                output("e = p = (ASN1encoding_t)malloc(%s * sizeof(ASN1encoding_t));\n",
                    lenref);
                output("ZeroMemory(b, %s * sizeof(ASN1encoding_t));\n", lenref);
                output("for (i = 0; i < %s; i++, p++) {\n", lenref);
                sprintf(valbuf, "(%s)[i]", valref);
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eEncode, encref);
                output("}\n");
                output("qsort(e, %s, sizeof(ASN1encoding_t), ASN1PEREncCmpEncodings);\n",
                    lenref);
                output("}\n");

                /* then dump them */
                output("for (p = e, i = 0; i < %s; i += n) {\n", lenref);
                output("if (!ASN1PEREncFragmentedLength(&n, %s, %s - i))\n",
                    encref, lenref);
                output("return 0;\n");
                output("for (j = 0; j < n; p++, j++) {\n");
                output("if (!ASN1PEREncBits(%s, (p->pos - p->buf) * 8 + p->bit, p->buf))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                output("}\n");
                output("}\n");
                output("if (n >= 0x4000) {\n");
                output("if (!ASN1PEREncFragmentedLength(&n, %s, 0))\n",
                    encref);
                output("return 0;\n");
                output("}\n");
                break;
            }

            /* again in non-canonical PER: */
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:

            /* skip null sequence of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t j, n = 0x4000;\n");

            if (info->Rules &
                (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {

                /* additional iterator needed */
                outputvar("P%s f;\n", info->Identifier);
                output("f = %s;\n", valref);
            }

            /* encode all elements */
            output("for (i = 0; i < %s;) {\n", lenref);

            /* encode fragmented length */
            output("if (!ASN1PEREncFragmentedLength(&n, %s, %s - i))\n",
                encref, lenref);
            output("return 0;\n");

            /* encode elements of the fragment */
            output("for (j = 0; j < n; i++, j++) {\n");
            if (info->Rules & eTypeRules_PointerArrayMask)
            {
                sprintf(valbuf, "(%s)[i]", valref);
            }
            else if (info->Rules & eTypeRules_LinkedListMask)
            {
                sprintf(valbuf, "f->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
            }
            else
            {
                MyAbort();
            }
            GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf,
                eEncode, encref);

            /* advance the iterator */
            if (info->Rules & eTypeRules_LinkedListMask)
            {
                output("f = f->next;\n");
            }

            /* end of inner loop */
            output("}\n");

            /* end of outer loop */
            output("}\n");

            /* add an zero-sized fragment if needed */
            output("if (n >= 0x4000) {\n");
            output("if (!ASN1PEREncFragmentedLength(&n, %s, 0))\n",
                encref);
            output("return 0;\n");
            output("}\n");
            break;

        case ePERSTIData_ObjectIdentifier:

            if (info->pPrivateDirectives->fOidArray || g_fOidArray)
            {
                /* encode object identifier value */
                output("if (!ASN1PEREncObjectIdentifier2(%s, %s))\n",
                    encref, Reference(valref));
            }
            else
            {
                /* encode object identifier value */
                output("if (!ASN1PEREncObjectIdentifier(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_External:

            /* encode external value */
            output("if (!ASN1PEREncExternal(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_EmbeddedPdv:

            /* encode embedded pdv value */
            if (sinfo->Identification) {
                output("if (!ASN1PEREncEmbeddedPdvOpt(%s, %s))\n",
                    encref, Reference(valref));
            } else {
                output("if (!ASN1PEREncEmbeddedPdv(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_MultibyteString:

            /* encode multibyte string value */
            output("if (!ASN1PEREncMultibyteString(%s, %s))\n",
                encref, valref);
            output("return 0;\n");
            break;

        case ePERSTIData_UnrestrictedString:

            /* encode character string value */
            if (sinfo->Identification) {
                output("if (!ASN1PEREncCharacterStringOpt(%s, %s))\n",
                    encref, Reference(valref));
            } else {
                output("if (!ASN1PEREncCharacterString(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_String:
        case ePERSTIData_ZeroString:

            /* encode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncFragmented%sString(%s, %s, %s, %u))\n",
                p, encref, lenref, valref, sinfo->NBits);
            output("return 0;\n");
            break;

        case ePERSTIData_TableString:
        case ePERSTIData_ZeroTableString:

            /* encode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            output("if (!ASN1PEREncFragmentedTable%sString(%s, %s, %s, %u, %s))\n",
                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
            output("return 0;\n");
            break;

        case ePERSTIData_Open:

            /* encode open type value */
            output("if (!ASN1PEREncOpenType(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;
        }
        break;

    case ePERSTILength_SmallLength:
        /* small length */

        switch (sinfo->Data) {
        case ePERSTIData_Extension:
            /* encode extension bits with normally small length */
            output("if (!ASN1PEREncNormallySmallBits(%s, %u, %s))\n",
                encref, sinfo->NBits, valref);
            output("return 0;\n");
            break;
        }
    }

    switch (sinfo->Data) {
    case ePERSTIData_RZBBitString:

        /* encode additional zero bits for remove zero bits bit string */
        /* of short length */
        if (sinfo->LLowerVal) {
            output("if (%s < %u) {\n", lenref, sinfo->LLowerVal);
            output("if (!ASN1PEREncZero(%s, %u - %s))\n",
                encref, sinfo->LLowerVal, lenref);
            output("return 0;\n");
            output("}\n");
        }
    }

    /* free calculated intx_t value */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (!info->NOctets) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    output("ASN1intx_free(&newval);\n");
                }
            }
            break;
        }
        break;
    }
}

/* generate decoding statements for a simple value */
void
GenPERDecSimpleType(AssignmentList_t ass, PERTypeInfo_t *info, char *valref, char *encref)
{
    uint32_t i;
    char *oldvalref;
    char valbuf[256], lenbuf[256];
    char *lenref;
    PERTypeInfo_t inf;

    inf = *info;

    /* examine type for special handling */
    switch (inf.Root.Data) {
    case ePERSTIData_BitString:
    case ePERSTIData_RZBBitString:

        if (inf.Root.cbFixedSizeBitString)
        {
            sprintf(lenbuf, "%u", inf.Root.LUpperVal);
            sprintf(valbuf, "%s", valref);
            lenref = lenbuf;
            valref = valbuf;
            break;
        }

        // lonchanc: intentionally fall through

    case ePERSTIData_OctetString:

        if (g_fCaseBasedOptimizer)
        {
            if (inf.Root.Data == ePERSTIData_OctetString && inf.Type == eExtension_Unextended)
            {
                switch (inf.Root.Length)
                {
                case ePERSTILength_NoLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal == inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // fixed size constraint, eg. OCTET STRING (SIZE (8))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PERDecOctetString_FixedSizeEx(%s, %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        else
                        {
                            output("if (!ASN1PERDecOctetString_FixedSize(%s, (ASN1octetstring2_t *) %s, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_Length:
                    break;
                case ePERSTILength_BitLength:
                    if (inf.Root.LConstraint == ePERSTIConstraint_Constrained &&
                        inf.Root.LLowerVal < inf.Root.LUpperVal &&
                        inf.Root.LUpperVal < 64 * 1024)
                    {
                        // variable size constraint, eg. OCTET STRING (SIZE (4..16))
                        if (inf.pPrivateDirectives->fLenPtr)
                        {
                            output("if (!ASN1PERDecOctetString_VarSizeEx(%s, %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        else
                        {
                            output("if (!ASN1PERDecOctetString_VarSize(%s, (ASN1octetstring2_t *) %s, %u, %u, %u))\n",
                                encref, Reference(valref), inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                        }
                        output("return 0;\n");
                        return;
                    }
                    break;
                case ePERSTILength_SmallLength:
                    break;
                case ePERSTILength_InfiniteLength: // no size constraint
                    /* get octet string as fragmented */
                    if (valref)
                    {
                        output("if (!ASN1PERDecOctetString_NoSize(%s, %s))\n",
                            encref, Reference(valref));
                        output("return 0;\n");
                        return;
                    }
                    break;
               } // switch
           } // if
        }

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_UTF8String:

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_String:
    case ePERSTIData_TableString:

        /* length and value of bit string/octet string/string value */
        sprintf(lenbuf, "(%s).length", valref);
        sprintf(valbuf, "(%s).value", valref);
        lenref = lenbuf;
        valref = valbuf;
        break;

    case ePERSTIData_SequenceOf:
    case ePERSTIData_SetOf:

        if (inf.Rules & eTypeRules_PointerArrayMask)
        {
            /* length and value of sequence of/set of value with */
            /* length-pointer representation */
            if (inf.Rules & eTypeRules_PointerToElement)
            {
                sprintf(lenbuf, "(%s)->count", valref);
                sprintf(valbuf, "(%s)->%s", valref, GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            else
            {
                sprintf(lenbuf, "(%s)->count", Reference(valref));
                sprintf(valbuf, "(%s)->%s", Reference(valref), GetPrivateValueName(inf.pPrivateDirectives, "value"));
            }
            lenref = lenbuf;
            valref = valbuf;
        }
        else
        if (inf.Rules & eTypeRules_LinkedListMask)
        {
            if (g_fCaseBasedOptimizer)
            {
                if (PerOptCase_IsTargetSeqOf(&inf))
                {
                    // generate the iterator
                    char szElmFn[128];
                    char szElmFnDecl[256];
                    sprintf(szElmFn, "ASN1Dec_%s_ElmFn", inf.Identifier);
                    sprintf(szElmFnDecl, "int ASN1CALL %s(ASN1decoding_t %s, P%s val)",
                        szElmFn, encref, inf.Identifier);

                    setoutfile(g_finc);
                    output("extern %s;\n", szElmFnDecl);
                    setoutfile(g_fout);

                    if ((inf.Root.LLowerVal == 0 && inf.Root.LUpperVal == 0) ||
                        (inf.Root.LUpperVal >= 64 * 1024)
                       )
                    {
                        output("return ASN1PERDecSeqOf_NoSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_decfn) %s, sizeof(*%s));\n",
                            encref, Reference(valref), szElmFn, valref);
                    }
                    else
                    {
                        if (inf.Root.LLowerVal == inf.Root.LUpperVal)
                            MyAbort();
                        output("return ASN1PERDecSeqOf_VarSize(%s, (ASN1iterator_t **) %s, (ASN1iterator_decfn) %s, sizeof(*%s), %u, %u, %u);\n",
                            encref, Reference(valref), szElmFn, valref,
                            inf.Root.LLowerVal, inf.Root.LUpperVal, inf.Root.LNBits);
                    }
                    output("}\n\n"); // end of iterator body

                    // generate the element function
                    output("static %s\n", szElmFnDecl);
                    output("{\n");
                    sprintf(valbuf, "val->%s", GetPrivateValueName(inf.pPrivateDirectives, "value"));
                    GenPERFuncSimpleType(ass, &inf.Root.SubType->PERTypeInfo, valbuf,
                            eDecode, encref);
                    // end of element body
                    return;
                }
            }

            /* use a loop for sequence of/set of value with */
            /* list representation */
            outputvar("P%s *f;\n", inf.Identifier);
            lenref = NULL;

        } else {
            MyAbort();
        }
        break;

    case ePERSTIData_Extension:

        /* length of extension */
        if (inf.Root.Length == ePERSTILength_SmallLength)
            lenref = "e";
            else
            lenref = NULL;
        break;

    case ePERSTIData_Boolean:

        if (g_fCaseBasedOptimizer)
        {
            if (PerOptCase_IsBoolean(&inf.Root))
            {
                lenref = NULL;
                break;
            }
        }

        /* boolean value */
        inf.Root.Data = ePERSTIData_Unsigned;
        lenref = NULL;
        break;

    default:

        /* other values have no additional length */
        lenref = NULL;
        break;
    }

    /* check for extended values */
    if (inf.Type > eExtension_Unextended) {
        outputvar("ASN1uint32_t x;\n");
        if (g_fCaseBasedOptimizer)
        {
            output("if (!ASN1PERDecExtensionBit(%s, &x))\n", encref);
        }
        else
        {
            output("if (!ASN1PERDecBit(%s, &x))\n", encref);
        }
        output("return 0;\n");
        output("if (!x) {\n");
    }

    /* additional variable for enumeraton value mapping */
    oldvalref = valref;
    if (inf.EnumerationValues && valref) {
        outputvar("ASN1uint32_t u;\n");
        valref = "u";
        inf.NOctets = 4;
    }

    /* decode unextended value (of extension root) */
    GenPERDecGenericUnextended(ass, &inf, &inf.Root, valref, lenref, encref);

    /* map enumeration values if type is extendable */
    if (inf.EnumerationValues && oldvalref &&
        inf.Type == eExtension_Extendable) {
        output("switch (u) {\n");
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", i);
            output("%s = %u;\n", oldvalref, intx2uint32(inf.EnumerationValues[i]));
            output("break;\n");
        }
        output("}\n");
    }

    /* type is extendable? */
    if (inf.Type > eExtension_Unextended) {
        output("} else {\n");
        if (inf.Type == eExtension_Extendable)
            valref = lenref = NULL;

        /* decode extended value (of extension addition) */
        GenPERDecGenericUnextended(ass, &inf, &inf.Additional, valref, lenref, encref);
        output("}\n");
    }

    /* map enumeration values if type is unextended/extended */
    if (inf.EnumerationValues && oldvalref &&
        inf.Type != eExtension_Extendable) {
        output("switch (u) {\n");
        for (i = 0; inf.EnumerationValues[i]; i++) {
            output("case %u:\n", i);
            output("%s = %u;\n", oldvalref, intx2uint32(inf.EnumerationValues[i]));
            output("break;\n");
        }
        output("}\n");
    }
}

/* generate decoding statements for a simple value (after some special */
/* handling has been done, esp. the evaluation of the extension) */
void GenPERDecGenericUnextended(
    AssignmentList_t ass,
    PERTypeInfo_t *info,
    PERSimpleTypeInfo_t *sinfo,
    char *valref,
    char *lenref,
    char *encref)
{
    char valbuf[256];
    char lenbuf[256];
    char lbbuf[256];
    char *p;
    char *oldvalref;
    intx_t ix;

    /* check for empty field */
    if (sinfo->NBits == 0) {
        switch (sinfo->Data) {
        case ePERSTIData_Null:
            return;
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
            if (valref && (sinfo->Constraint == ePERSTIConstraint_Semiconstrained || sinfo->Constraint == ePERSTIConstraint_Constrained)) {
                if (info->NOctets == 0) {
                    sprintf(lbbuf, "%s_lb", info->Identifier);
                    outputvarintx(lbbuf, &sinfo->LowerVal);
                    output("ASN1intx_dup(%s, %s);\n", Reference(valref), lbbuf);
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("%s = %d;\n", valref, intx2int32(&sinfo->LowerVal));
                } else {
                    output("%s = %u;\n", valref, intx2uint32(&sinfo->LowerVal));
                }
            }
            return;
        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:
        case ePERSTIData_OctetString:
        case ePERSTIData_UTF8String:
        case ePERSTIData_SequenceOf:
        case ePERSTIData_SetOf:
        case ePERSTIData_String:
        case ePERSTIData_TableString:
        case ePERSTIData_ZeroString:
        case ePERSTIData_ZeroTableString:
            if (lenref)
                output("%s = 0;\n", lenref);
            return;
        case ePERSTIData_Extension:
            if (sinfo->Length == ePERSTILength_SmallLength)
                break;
            return;
        default:
            MyAbort();
        }
    }

    /* check for decoding of non-negative-binary-integer */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        if (sinfo->Data == ePERSTIData_Integer)
            sinfo->Data = ePERSTIData_Unsigned;
        break;
    }

    /* use newval for dec of semiconstraint/constraint intx_t with lb != 0 */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (valref) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    if (info->NOctets == 0) {
                        outputvar("ASN1intx_t newval;\n");
                        oldvalref = valref;
                        valref = "newval";
                    }
                }
            }
            break;
        }
        break;
    }

    /* general rules */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned && sinfo->Length == ePERSTILength_BitLength &&
        !(sinfo->LNBits & 7))
        sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* octet alignment will be given my length */
    if (sinfo->Length == ePERSTILength_InfiniteLength &&
        (sinfo->Data == ePERSTIData_Integer && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_Unsigned && info->NOctets == 0 ||
        sinfo->Data == ePERSTIData_BitString ||
        sinfo->Data == ePERSTIData_RZBBitString ||
        sinfo->Data == ePERSTIData_Extension ||
        sinfo->Data == ePERSTIData_OctetString ||
        sinfo->Data == ePERSTIData_UTF8String ||
        sinfo->Data == ePERSTIData_SequenceOf ||
        sinfo->Data == ePERSTIData_SetOf ||
        sinfo->Data == ePERSTIData_String ||
        sinfo->Data == ePERSTIData_TableString ||
        sinfo->Data == ePERSTIData_ZeroString ||
        sinfo->Data == ePERSTIData_ZeroTableString) ||
        sinfo->Data == ePERSTIData_ObjectIdentifier ||
        sinfo->Data == ePERSTIData_Real ||
        sinfo->Data == ePERSTIData_GeneralizedTime ||
        sinfo->Data == ePERSTIData_UTCTime ||
        sinfo->Data == ePERSTIData_External ||
        sinfo->Data == ePERSTIData_EmbeddedPdv ||
        sinfo->Data == ePERSTIData_MultibyteString ||
        sinfo->Data == ePERSTIData_UnrestrictedString ||
        sinfo->Data == ePERSTIData_Open)
        sinfo->LAlignment = sinfo->Alignment = ePERSTIAlignment_BitAligned;
                                /* alignment will be done by encoding fn */
    if (sinfo->Length == ePERSTILength_NoLength ||
        sinfo->Length == ePERSTILength_SmallLength)
        sinfo->LAlignment = ePERSTIAlignment_BitAligned;
                                    /* no alignment of no length */

    if (g_fCaseBasedOptimizer)
    {
        // lonchanc: special handling for macro operations
        if (PerOptCase_IsSignedInteger(sinfo))
        {
            output("if (!ASN1PERDecInteger(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsUnsignedInteger(sinfo))
        {
            output("if (!ASN1PERDecUnsignedInteger(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsUnsignedShort(sinfo))
        {
            output("if (!ASN1PERDecUnsignedShort(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            goto FinalTouch;
        }
        if (PerOptCase_IsBoolean(sinfo))
        {
            output("if (!ASN1PERDecBoolean(%s, %s))\n", encref, Reference(valref));
            output("return 0;\n");
            return;
        }
    }

    /* initial settings for length enconding: */
    /* add lower bound of length to length */
    if (!lenref) {
        if (sinfo->Length == ePERSTILength_NoLength &&
            sinfo->Data != ePERSTIData_Extension) {
            sprintf(lenbuf, "%u", sinfo->LLowerVal);
            lenref = lenbuf;
        } else if (sinfo->Data != ePERSTIData_ObjectIdentifier &&
            sinfo->Data != ePERSTIData_External &&
            sinfo->Data != ePERSTIData_EmbeddedPdv &&
            sinfo->Data != ePERSTIData_MultibyteString &&
            sinfo->Data != ePERSTIData_UnrestrictedString &&
            sinfo->Data != ePERSTIData_Extension &&
            (sinfo->Length != ePERSTILength_InfiniteLength ||
            (sinfo->Data != ePERSTIData_SetOf &&
            sinfo->Data != ePERSTIData_SequenceOf) ||
            !IsStructuredType(GetType(ass, sinfo->SubType))) &&
            ((sinfo->Data != ePERSTIData_SetOf &&
            sinfo->Data != ePERSTIData_SequenceOf) || valref) &&
            (sinfo->Length != ePERSTILength_InfiniteLength ||
            info->NOctets != 0 ||
            (sinfo->Data != ePERSTIData_Integer &&
            sinfo->Data != ePERSTIData_Unsigned)) &&
            ((sinfo->Data != ePERSTIData_ZeroString &&
            sinfo->Data != ePERSTIData_ZeroTableString) ||
            sinfo->Length != ePERSTILength_InfiniteLength) &&
            (sinfo->Data != ePERSTIData_BitString &&
            sinfo->Data != ePERSTIData_UTF8String &&
            sinfo->Data != ePERSTIData_OctetString)) {
            outputvar("ASN1uint32_t l;\n");
            lenref = "l";
        }
    } else if (sinfo->Length == ePERSTILength_NoLength) {
        if ((sinfo->Data == ePERSTIData_BitString ||
             sinfo->Data == ePERSTIData_RZBBitString) &&
             sinfo->cbFixedSizeBitString)
        {
            // lonchanc: doing nothing here because lenref is a constant number
        }
        else
        {
            output("%s = %u;\n", lenref, sinfo->LLowerVal);
        }
    }

    /* length encoding */
    if (sinfo->LAlignment == ePERSTIAlignment_OctetAligned) {
        output("ASN1PERDecAlignment(%s);\n", encref);
    }
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:
        break;

    case ePERSTILength_BitLength:

        /* get length */
        output("if (!ASN1PERDecU32Val(%s, %u, %s))\n",
            encref, sinfo->LNBits, Reference(lenref));
        output("return 0;\n");

        /* add lower bound of length */
        if (sinfo->LLowerVal)
            output("%s += %u;\n", lenref, sinfo->LLowerVal);

        /*
        if (sinfo->LConstraint == ePERSTIConstraint_Constrained) {
            output("if (%s > %u)\n", lenref, sinfo->LUpperVal);
            output("return ASN1DecError(%s, ASN1_ERR_CORRUPT);\n", encref);
        }
        */
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* get length of integer value */
            if (info->NOctets != 0) {
                output("if (!ASN1PERDecFragmentedLength(%s, %s))\n",
                    encref, Reference(lenref));
                output("return 0;\n");
                if (sinfo->LLowerVal)
                    output("%s += %u;\n", lenref, sinfo->LLowerVal);
                /*
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained) {
                    output("if (%s > %u)\n", lenref, sinfo->LUpperVal);
                    output("return ASN1DecError(%s, ASN1_ERR_CORRUPT);\n",
                        encref);
                }
                */
            }
            break;
        }
        break;
    }

    /* value decoding */
    switch (sinfo->Length) {
    case ePERSTILength_NoLength:

        /* decode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PERDecAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:

            /* decode the value as bit field */
            if (valref) {
                if (!info->NOctets) {
                    output("if (!ASN1PERDecSXVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecS%dVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Unsigned:

            /* decode the value as bit field */
            if (valref) {
                if (!info->NOctets) {
                    output("if (!ASN1PERDecUXVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %u, %s))\n",
                        info->NOctets * 8, encref, sinfo->NBits, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_NormallySmall:

            /* decode the value as normally small number */
            if (valref) {
                if (!info->NOctets) {
                    MyAbort();
                } else {
                    output("if (!ASN1PERDecN%dVal(%s, %s))\n",
                        info->NOctets * 8, encref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipNormallySmall(%s))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* decode bit string in a bit field */
            if (valref) {
                if (sinfo->cbFixedSizeBitString)
                {
                    output("if (!ASN1PERDecExtension(%s, %s, %s))\n",
                        encref, lenref, Reference(valref));
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* decode octet string in a bit field */
            if (valref) {
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained &&
                    (! info->pPrivateDirectives->fLenPtr))
                {
                    output("if (!ASN1PERDecExtension(%s, %s * 8, %s))\n",
                        encref, lenref, valref);
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* decode octet string in a bit field */
            if (valref) {
                output("if (!ASN1PERDecUTF8String(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_Extension:

            /* decode extension bits in a bit field */
            if (valref) {
                output("if (!ASN1PERDecExtension(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_SetOf:

            /* same as BitLength encoding */
            goto SetOfEncoding;

        case ePERSTIData_SequenceOf:

            /* same as BitLength encoding */
            goto SequenceOfEncoding;

        case ePERSTIData_String:

            /* same as BitLength encoding */
            goto StringEncoding;

        case ePERSTIData_ZeroString:

            /* same as BitLength encoding */
            goto ZeroStringEncoding;

        case ePERSTIData_TableString:

            /* same as BitLength encoding */
            goto TableStringEncoding;

        case ePERSTIData_ZeroTableString:

            /* same as BitLength encoding */
            goto ZeroTableStringEncoding;

        case ePERSTIData_Reference:

            /* call encoding function of referenced type */
            if (valref) {
                output("if (!ASN1Dec_%s(%s, %s))\n",
                    Identifier2C(sinfo->SubIdentifier),
                    encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1Dec_%s(%s, NULL))\n",
                    Identifier2C(sinfo->SubIdentifier),
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Real:

            /* decode real value */
            if (valref) {
                if (info->NOctets)
                    output("if (!ASN1PERDecDouble(%s, %s))\n",
                        encref, Reference(valref));
                else
                    output("if (!ASN1PERDecReal(%s, %s))\n",
                        encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_GeneralizedTime:

            /* decode generalized time value */
            if (valref) {
                output("if (!ASN1PERDecGeneralizedTime(%s, %s, %d))\n",
                    encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %d))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTCTime:

            /* decode utc time value */
            if (valref) {
                output("if (!ASN1PERDecUTCTime(%s, %s, %d))\n",
                    encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %d))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;
        }
        break;

    case ePERSTILength_BitLength:

        /* decode alignment of the value */
        if (sinfo->Alignment == ePERSTIAlignment_OctetAligned) {
            output("ASN1PERDecAlignment(%s);\n", encref);
        }

        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* decode the value as bit field */
            if (valref) {
                if (info->NOctets == 0 && sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecSXVal(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else if (info->NOctets == 0 && sinfo->Data == ePERSTIData_Unsigned) {
                    output("if (!ASN1PERDecUXVal(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecS%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* decode the value as bit field */
            if (valref) {
                output("if (!ASN1PERDecBits(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* decode the value as bit field */
            if (valref) {
                if (sinfo->LConstraint == ePERSTIConstraint_Constrained &&
                    (! info->pPrivateDirectives->fLenPtr))
                {
                    output("if (!ASN1PERDecExtension(%s, %s * 8, %s))\n",
                        encref, lenref, valref);
                }
                else
                {
                    output("if (!ASN1PERDecBits(%s, %s * 8, %s))\n",
                        encref, lenref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                    encref, lenref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* decode the value as bit field */
            if (valref) {
                output("if (!ASN1PERDecUTF8String(%s, %s, %s))\n",
                    encref, lenref, Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_SetOf:
        SetOfEncoding:
            /*FALLTHROUGH*/
        case ePERSTIData_SequenceOf:
        SequenceOfEncoding:

            /* skip null sequence of/set of */
            if (sinfo->SubType->Flags & eTypeFlags_Null)
                break;

            outputvar("ASN1uint32_t i;\n");
            if (!valref || (info->Rules & eTypeRules_PointerArrayMask))
            {
                // lonchanc: no need to allocate memory for eTypeRules_FixedArray
                /* allocate memory for elements */
                if (valref && (info->Rules & eTypeRules_LengthPointer))
                {
                    output("if (!%s) {\n", lenref);
                    output("%s = NULL;\n", valref);
                    output("} else {\n");
                    output("if (!(%s = (%s *)ASN1DecAlloc(%s, %s * sizeof(%s))))\n",
                        valref, sinfo->SubIdentifier, encref,
                        lenref, Dereference(valref));
                    output("return 0;\n");
                }

                /* decode elements */
                output("for (i = 0; i < %s; i++) {\n", lenref);
                if (valref) {
                    sprintf(valbuf, "(%s)[i]", valref);
                    GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eDecode, encref);
                } else {
                    GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, NULL, eDecode, encref);
                }

                /* loop end */
                output("}\n");
                if (valref && (info->Rules & eTypeRules_LengthPointer))
                    output("}\n"); // closing bracket for else
            }
            else if (info->Rules & eTypeRules_SinglyLinkedList)
            {
                char szPrivateValueName[64];
                sprintf(&szPrivateValueName[0], "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                /* allocate and decode elements */
                outputvar("P%s *f;\n", info->Identifier);
                output("f = %s;\n", Reference(valref));
                output("for (i = 0; i < %s; i++) {\n", lenref);
                output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                    info->Identifier, encref);
                output("return 0;\n");
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, &szPrivateValueName[0],
                    eDecode, encref);
                output("f = &(*f)->next;\n");
                output("}\n");
                output("*f = NULL;\n");
            }
            else
            if (info->Rules & eTypeRules_DoublyLinkedList)
            {
                char szPrivateValueName[64];
                sprintf(&szPrivateValueName[0], "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                /* allocate and decode elements */
                outputvar("P%s *f;\n", info->Identifier);
                outputvar("%s b;\n", info->Identifier);
                output("f = %s;\n", Reference(valref));
                output("b = NULL;\n");
                output("for (i = 0; i < %s; i++) {\n", lenref);
                output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                    info->Identifier, encref);
                output("return 0;\n");
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, &szPrivateValueName[0],
                    eDecode, encref);
                output("f->prev = b;\n");
                output("b = *f;\n");
                output("f = &b->next;\n");
                output("}\n");
                output("*f = NULL;\n");
            }
            break;

        case ePERSTIData_String:
        StringEncoding:

            /* decode string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDec%sStringNoAlloc(%s, %s, %s, %u))\n",
                        p, encref, lenref, valref, sinfo->NBits);
                }
                else
                {
                    output("if (!ASN1PERDec%sString(%s, %s, %s, %u))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits);
                }
#else
                output("if (!ASN1PERDec%sString(%s, %s, %s, %u))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits);
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u))\n",
                    encref, lenref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroString:
        ZeroStringEncoding:

            /* decode zero-terminated string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDecZero%sStringNoAlloc(%s, %s, %s, %u))\n",
                        p, encref, lenref, valref, sinfo->NBits);
                }
                else
                {
                    output("if (!ASN1PERDecZero%sString(%s, %s, %s, %u))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits);
                }
#else
                output("if (!ASN1PERDecZero%sString(%s, %s, %s, %u))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits);
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u))\n",
                    encref, lenref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_TableString:
        TableStringEncoding:

            /* decode table string value */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                    output("if (!ASN1PERDecTable%sStringNoAlloc(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
                else
                {
                    output("if (!ASN1PERDecTable%sString(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
#else
                output("if (!ASN1PERDecTable%sString(%s, %s, %s, %u, %s))\n",
                    p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
#endif
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u, %s))\n",
                    encref, lenref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroTableString:
        ZeroTableStringEncoding:

                /* decode zero-terminated table string value */
                if (info->NOctets == 1) {
                p = "Char";
                } else if (info->NOctets == 2) {
                p = "Char16";
                } else if (info->NOctets == 4) {
                p = "Char32";
                } else
                MyAbort();
                if (valref) {
#ifdef ENABLE_CHAR_STR_SIZE
                if (info->NOctets == 1 &&
                        info->Root.LConstraint == ePERSTIConstraint_Constrained)
                {
                        output("if (!ASN1PERDecZeroTable%sStringNoAlloc(%s, %s, %s, %u, %s))\n",
                                p, encref, lenref, valref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
                else
                {
                        output("if (!ASN1PERDecZeroTable%sString(%s, %s, %s, %u, %s))\n",
                                p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                }
#else
                output("if (!ASN1PERDecZeroTable%sString(%s, %s, %s, %u, %s))\n",
                        p, encref, lenref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
#endif
                output("return 0;\n");
                } else {
                output("if (!ASN1PERDecSkipBits(%s, %s * %u, %s))\n",
                        encref, lenref, sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
                }
            break;
        }
        break;

    case ePERSTILength_InfiniteLength:

        /* infinite length case */
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:

            /* get integer value as fragmented */
            if (valref) {
                if (info->NOctets == 0) {
                    if (sinfo->Data == ePERSTIData_Integer) {
                        output("if (!ASN1PERDecFragmentedIntx(%s, %s))\n",
                            encref, Reference(valref));
                    } else {
                        output("if (!ASN1PERDecFragmentedUIntx(%s, %s))\n",
                            encref, Reference(valref));
                    }
                    output("return 0;\n");
                } else if (sinfo->Data == ePERSTIData_Integer) {
                    output("if (!ASN1PERDecS%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecU%dVal(%s, %s * 8, %s))\n",
                        info->NOctets * 8, encref, lenref, Reference(valref));
                    output("return 0;\n");
                }
            } else {
                if (info->NOctets != 0) {
                    output("if (!ASN1PERDecSkipBits(%s, %s * 8))\n",
                        encref, lenref);
                    output("return 0;\n");
                } else {
                    output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                        encref);
                    output("return 0;\n");
                }
            }
            break;

        case ePERSTIData_Extension:

            /* get extension bits as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmentedExtension(%s, %u, %s))\n",
                    encref, sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 1))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_BitString:
        case ePERSTIData_RZBBitString:

            /* get bit string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmented(%s, %s, %s, 1))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 1))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_OctetString:

            /* get octet string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecFragmented(%s, %s, %s, 8))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_UTF8String:

            /* get octet string as fragmented */
            if (valref) {
                output("if (!ASN1PERDecUTF8StringEx(%s, %s, %s))\n",
                    encref, Reference(lenref), Reference(valref));
                output("return 0;\n");
            } else {
                MyAbort();
            }
            break;

        case ePERSTIData_SetOf:
        case ePERSTIData_SequenceOf:

            /* we need some counters and iterators */
            outputvar("ASN1uint32_t i;\n");
            outputvar("ASN1uint32_t n;\n");
            if (valref)
            {
                if (info->Rules & eTypeRules_LengthPointer)
                {
                    output("%s = 0;\n", lenref);
                    output("%s = NULL;\n", valref);
                }
                else
                if (info->Rules & eTypeRules_FixedArray)
                {
                    output("%s = 0;\n", lenref);
                }
                else
                if (info->Rules & eTypeRules_SinglyLinkedList)
                {
                    outputvar("P%s *f;\n", info->Identifier);
                    output("f = %s;\n", Reference(valref));
                }
                else
                if (info->Rules & eTypeRules_DoublyLinkedList)
                {
                    outputvar("P%s *f;\n", info->Identifier);
                    outputvar("%s b;\n", info->Identifier);
                    output("f = %s;\n", Reference(valref));
                    output("b = NULL;\n");
                }
            }

            /* get all elements of the sequence of/set of */
            output("do {\n");

            /* get length of a fragment */
            output("if (!ASN1PERDecFragmentedLength(%s, &n))\n",
                encref);
            output("return 0;\n");

            if (valref)
            {
                if (info->Rules & eTypeRules_LengthPointer)
                {
                    // lonchanc: no need to allocate memory for eTypeRules_FixedArray
                    /* resize memory for the element */
                    output("if (!(%s = (%s *)ASN1DecRealloc(%s, %s, (%s + n) * sizeof(%s))))\n",
                        valref, GetTypeName(ass, sinfo->SubType), encref,
                        valref, lenref, Dereference(valref));
                    output("return 0;\n");
                }
            }

            /* get the elements of the fragment */
            output("for (i = 0; i < n; i++) {\n");
            if (valref) {
                if (info->Rules & eTypeRules_PointerArrayMask)
                {
                    sprintf(valbuf, "(%s)[%s]", valref, lenref);
                }
                else
                if (info->Rules & eTypeRules_LinkedListMask)
                {
                    output("if (!(*f = (P%s)ASN1DecAlloc(%s, sizeof(**f))))\n",
                        info->Identifier, encref);
                    output("return 0;\n");
                    sprintf(valbuf, "(*f)->%s", GetPrivateValueName(info->pPrivateDirectives, "value"));
                }
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, valbuf, eDecode, encref);
                if (info->Rules & eTypeRules_SinglyLinkedList)
                {
                    output("f = &(*f)->next;\n");
                }
                else
                if (info->Rules & eTypeRules_DoublyLinkedList)
                {
                    output("(*f)->prev = b;\n");
                    output("b = *f;\n");
                    output("f = &b->next;\n");
                }
            } else {
                GenPERFuncSimpleType(ass, &sinfo->SubType->PERTypeInfo, NULL, eDecode, encref);
            }
            if ((info->Rules & (eTypeRules_LengthPointer | eTypeRules_FixedArray)) && lenref)
                output("(%s)++;\n", lenref);

            /* end of inner loop */
            output("}\n");

            /* end of outer loop */
            output("} while (n >= 0x4000);\n");

            /* terminate list */
            if (valref && (info->Rules & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)))
                output("*f = NULL;\n");
            break;

        case ePERSTIData_ObjectIdentifier:

            /* decode object identifier value */
            if (valref) {
                if (info->pPrivateDirectives->fOidArray || g_fOidArray)
                {
                    output("if (!ASN1PERDecObjectIdentifier2(%s, %s))\n",
                        encref, Reference(valref));
                }
                else
                {
                    output("if (!ASN1PERDecObjectIdentifier(%s, %s))\n",
                        encref, Reference(valref));
                }
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_External:

            /* decode external value */
            output("if (!ASN1PERDecExternal(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_EmbeddedPdv:

            /* decode embedded pdv value */
            if (sinfo->Identification) {
                if (!strcmp(sinfo->Identification->Identifier, "fixed")) {
                    output("if (!ASN1PERDecEmbeddedPdvOpt(%s, %s, NULL, NULL))\n",
                        encref, Reference(valref));
                } else {
                    output("if (!ASN1PERDecEmbeddedPdvOpt(%s, %s, &%s_identification_syntaxes_abstract, &%s_identification_syntaxes_transfer))\n",
                        encref, Reference(valref),
                        info->Identifier, info->Identifier);
                }
            } else {
                output("if (!ASN1PERDecEmbeddedPdv(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_MultibyteString:

            /* decode multibyte string value */
            output("if (!ASN1PERDecMultibyteString(%s, %s))\n",
                encref, Reference(valref));
            output("return 0;\n");
            break;

        case ePERSTIData_UnrestrictedString:

            /* decode character string value */
            if (sinfo->Identification) {
                if (!strcmp(sinfo->Identification->Identifier, "fixed")) {
                    output("if (!ASN1PERDecCharacterStringOpt(%s, %s, NULL, NULL))\n",
                        encref, Reference(valref));
                } else {
                    output("if (!ASN1PERDecCharacterStringOpt(%s, %s, &%s_identification_syntaxes_abstract, &%s_identification_syntaxes_transfer))\n",
                        encref, Reference(valref),
                        info->Identifier, info->Identifier);
                }
            } else {
                output("if (!ASN1PERDecCharacterString(%s, %s))\n",
                    encref, Reference(valref));
            }
            output("return 0;\n");
            break;

        case ePERSTIData_String:

            /* decode string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmented%sString(%s, %s, %s, %u))\n",
                    p, encref, Reference(lenref), Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroString:

            /* decode zero-terminated string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedZero%sString(%s, %s, %u))\n",
                    p, encref, Reference(valref), sinfo->NBits);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_TableString:

            /* decode table string value as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedTable%sString(%s, %s, %s, %u, %s))\n",
                    p, encref, Reference(lenref), Reference(valref), sinfo->NBits,
                    Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_ZeroTableString:

            /* decode zero-terminated table-string as fragmented */
            if (info->NOctets == 1) {
                p = "Char";
            } else if (info->NOctets == 2) {
                p = "Char16";
            } else if (info->NOctets == 4) {
                p = "Char32";
            } else
                MyAbort();
            if (valref) {
                output("if (!ASN1PERDecFragmentedZeroTable%sString(%s, %s, %u, %s))\n",
                    p, encref, Reference(valref), sinfo->NBits, Reference(sinfo->TableIdentifier));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, %u))\n",
                    encref, sinfo->NBits);
                output("return 0;\n");
            }
            break;

        case ePERSTIData_Open:

            /* decode open type value */
            if (valref) {
                output("if (!ASN1PERDecOpenType(%s, %s))\n",
                    encref, Reference(valref));
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipFragmented(%s, 8))\n",
                    encref);
                output("return 0;\n");
            }
            break;
        }
        break;

    case ePERSTILength_SmallLength:

        switch (sinfo->Data) {
        case ePERSTIData_Extension:

            /* decode extension bits with normally small length */
            if (valref) {
                output("if (!ASN1PERDecNormallySmallExtension(%s, %s, %u, %s))\n",
                    encref, Reference(lenref), sinfo->NBits, valref);
                output("return 0;\n");
            } else {
                output("if (!ASN1PERDecSkipNormallySmallExtension(%s, %s))\n",
                    encref, Reference(lenref));
                output("return 0;\n");
            }
            break;
        }
    }

FinalTouch:

    /* additional calculations for value decoding: */
    /* add lower bound of constraint/semiconstraint value */
    switch (sinfo->Constraint) {
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Constrained:
        switch (sinfo->Data) {
        case ePERSTIData_Integer:
        case ePERSTIData_Unsigned:
        case ePERSTIData_NormallySmall:
            if (valref) {
                if (intx_cmp(&sinfo->LowerVal, &intx_0) != 0) {
                    if (info->NOctets != 0) {
                        if (intx_cmp(&sinfo->LowerVal, &intx_0) > 0) {
                            output("%s += %u;\n",
                                valref, intx2uint32(&sinfo->LowerVal));
                        } else {
                            intx_neg(&ix, &sinfo->LowerVal);
                            // LONCHANC: to workaround a compiler bug in vc++.
                            // output("%s += -%u;\n",
                            output("%s += 0 - %u;\n",
                                valref, intx2uint32(&ix));
                        }
                    } else {
                        sprintf(lbbuf, "%s_lb", info->Identifier);
                        outputvarintx(lbbuf, &sinfo->LowerVal);
                        output("ASN1intx_add(%s, %s, &%s);\n",
                            Reference(oldvalref), Reference(valref), lbbuf);
                        output("ASN1intx_free(%s);\n",
                            Reference(valref));
                    }
                }
            }
            break;
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\intx.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: we seem to have a significant amount of memory leak
// while dealing with real number and unlimited integers.
// we definitely want to re-visit all the following routines carefully
// in the future.
// moreover, we need to make sure all the memory allocation and free
// are either using encoding and decoding memory manager or kernel one.
// need to make sure we do not mix them together.

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* builtin intx values */
ASN1octet_t ASN1intx_0_[] = { 0 };
ASN1intx_t ASN1intx_0 = { 1, ASN1intx_0_ };
ASN1octet_t ASN1intx_1_[] = { 1 };
ASN1intx_t ASN1intx_1 = { 1, ASN1intx_1_ };
ASN1octet_t ASN1intx_2_[] = { 2 };
ASN1intx_t ASN1intx_2 = { 1, ASN1intx_2_ };
ASN1octet_t ASN1intx_16_[] = { 16 };
ASN1intx_t ASN1intx_16 = { 1, ASN1intx_16_ };
ASN1octet_t ASN1intx_256_[] = { 1, 0 };
ASN1intx_t ASN1intx_256 = { 2, ASN1intx_256_ };
ASN1octet_t ASN1intx_64K_[] = { 1, 0, 0 };
ASN1intx_t ASN1intx_64K = { 3, ASN1intx_64K_ };
ASN1octet_t ASN1intx_1G_[] = { 64, 0, 0, 0 };
ASN1intx_t ASN1intx_1G = { 4, ASN1intx_1G_ };

/* add two intx values */
void
ASN1intx_add(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* clear carry bit */
    c = 0;

    /* add octet by octet */
    for (i = l - 1; i >= 0; i--) {
        w = (i >= o1 ? arg1->value[i - o1] : s1) + (i >= o2 ? arg2->value[i - o2] : s2) + c;
        v[i] = (ASN1octet_t)w;
        c = w > 0xff;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* substract two intx values */
void
ASN1intx_sub(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* clear borrow bit */
    c = 0;

    /* substract octet by octet */
    for (i = l - 1; i >= 0; i--) {
        w = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2) - c;
        v[i] = (ASN1octet_t)w;
        c = w < 0;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

// lonchanc: do we forget to free dst->value???
// in case that dst and arg1 are identical. for instance, 
// ASN1BEREncReal() calls ASN1intx_sub(&exponent, &exponent, &help);
    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* add one octet to an intx */
void
ASN1intx_addoctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* add octet by octet */
    c = arg2;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] + c;
        v[i + 1] = (ASN1octet_t)w;
        c = (w > 0xff);
    }
    v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff + c) : (ASN1octet_t)c;

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* substract one octet to an intx */
void
ASN1intx_suboctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* substract octet by octet */
    c = arg2;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] - c;
        v[i + 1] = (ASN1octet_t)w;
        c = (w < 0);
    }
    v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff - c) : (ASN1octet_t)c;

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* multiply intx by an octet */
void
ASN1intx_muloctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int c;
    int i;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* multiply octet by octet */
    c = 0;
    for (i = l - 2; i >= 0; i--) {
        w = arg1->value[i] * arg2 + c;
        v[i + 1] = (ASN1octet_t)w;
        c = w >> 8;
    }
    v[0] = (ASN1octet_t)(arg1->value[0] > 0x7f ? 0xff * arg2 + c : c);

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    dst->length = l - i;
    dst->value = (ASN1octet_t *)malloc(l - i);
    memcpy(dst->value, v + i, l - i);
    free(v);
}

/* increment an intx */
void
ASN1intx_inc(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* copy value */
    memcpy(v + 1, val->value, l - 1);
    free(val->value);
    v[0] = v[1] > 0x7f ? 0xff : 0x00;

    /* increment value */
    for (i = l - 1; i >= 0; i--) {
        if (++v[i])
            break;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    val->length = l - i;
    val->value = (ASN1octet_t *)malloc(l - i);
    memcpy(val->value, v + i, l - i);
    free(v);
}

/* decrement an intx */
void
ASN1intx_dec(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)malloc(l);

    /* copy value */
    memcpy(v + 1, val->value, l - 1);
    free(val->value);
    v[0] = v[1] > 0x7f ? 0xff : 0x00;

    /* decrement value */
    for (i = l - 1; i >= 0; i--) {
        if (v[i]--)
            break;
    }

    /* octets which may shall dropped */
    w = v[0] > 0x7f ? 0xff : 0x00;

    /* count octets that shall be dropped */
    for (i = 0; i < l - 1; i++) {
        if (v[i] != w)
            break;
    }
    if ((v[i] ^ w) & 0x80)
        i--;

    /* allocate and copy result */
    val->length = l - i;
    val->value = (ASN1octet_t *)malloc(l - i);
    memcpy(val->value, v + i, l - i);
    free(v);
}

/* negate an intx value */
void
ASN1intx_neg(ASN1intx_t *dst, ASN1intx_t *arg)
{
    ASN1uint32_t i;

    /* duplicate value */
    ASN1intx_dup(dst, arg);

    /* ones complement */
    for (i = 0; i < dst->length; i++)
        dst->value[i] = ~dst->value[i];
    
    /* and increment */
    ASN1intx_inc(dst);
}

/* returns floor(log2(arg - 1)) */
ASN1uint32_t
ASN1intx_log2(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;
    ASN1uint32_t n;

    ASN1intx_dup(&v, arg);
    ASN1intx_dec(&v);
    if (v.value[0] > 0x7f) {
        ASN1intx_free(&v);
        return 0;
    }
    for (i = 0; i < v.length; i++) {
        if (v.value[i])
            break;
    }
    if (i >= v.length) {
        n = 0;
    } else if (v.value[i] > 0x7f) {
        n = 8 * (v.length - i - 1) + 8;
    } else if (v.value[i] > 0x3f) {
        n = 8 * (v.length - i - 1) + 7;
    } else if (v.value[i] > 0x1f) {
        n = 8 * (v.length - i - 1) + 6;
    } else if (v.value[i] > 0x0f) {
        n = 8 * (v.length - i - 1) + 5;
    } else if (v.value[i] > 0x07) {
        n = 8 * (v.length - i - 1) + 4;
    } else if (v.value[i] > 0x03) {
        n = 8 * (v.length - i - 1) + 3;
    } else if (v.value[i] > 0x01) {
        n = 8 * (v.length - i - 1) + 2;
    } else {
        n = 8 * (v.length - i - 1) + 1;
    }
    ASN1intx_free(&v);
    return n;
}

/* returns floor(log2(arg - 1)) */
ASN1uint32_t
ASN1uint32_log2(ASN1uint32_t arg)
{
    ASN1uint32_t i;

    arg--;
    for (i = 32; i != 0; i--) {
        if (arg & (1 << (i - 1)))
            break;
    }
    return i;
}

/* returns floor(log256(arg - 1)) */
ASN1uint32_t
ASN1intx_log256(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;

    ASN1intx_dup(&v, arg);
    ASN1intx_dec(&v);
    if (v.value[0] > 0x7f) {
        ASN1intx_free(&v);
        return 0;
    }
    for (i = 0; i < v.length; i++) {
        if (v.value[i])
            break;
    }
    ASN1intx_free(&v);
    return v.length - i;
}

/* returns floor(log256(arg - 1)) */
ASN1uint32_t
ASN1uint32_log256(ASN1uint32_t arg)
{
    if (arg > 0x10000) {
        if (arg > 0x1000000)
            return 4;
        return 3;
    }
    if (arg > 0x100)
        return 2;
    if (arg > 1)
        return 1;
    return 0;
}

/* compare two intx values; return 0 iff equal */
ASN1int32_t
ASN1intx_cmp(ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    int s1, s2;
    int o1, o2;
    int l;
    int i;
    int d;

    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;
    if (s1 != s2)
        return s1 == 0xff ? -1 : 1;
    l = arg1->length > arg2->length ? arg1->length : arg2->length;
    o1 = l - arg1->length;
    o2 = l - arg2->length;
    for (i = 0; i < l; i++) {
        d = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2);
        if (d)
            return d;
    }
    return 0;
}

/* create an intx value from an uint32 value */
void
ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = 0;
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && !*v && v[1] <= 0x7f) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)malloc(n);
    memcpy(dst->value, v, n);
}

/* create an intx value from an int32 value */
void
ASN1intx_setint32(ASN1intx_t *dst, ASN1int32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = (ASN1octet_t)(val < 0 ? 0xff : 0x00);
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && ((!*v && v[1] <= 0x7f) || (*v == 0xff && v[1] > 0x7f))) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)malloc(n);
    memcpy(dst->value, v, n);
}

/* copy constructor */
void
ASN1intx_dup(ASN1intx_t *dst, ASN1intx_t *val)
{
    dst->length = val->length;
    dst->value = (ASN1octet_t *)malloc(val->length);
    memcpy(dst->value, val->value, val->length);
}

/* free an intx value */
void
ASN1intx_free(ASN1intx_t *val)
{
    free(val->value);
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a uint64 value */
ASN1uint64_t
ASN1intx2uint64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint64_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    case 4:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32));
    case 6:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40));
    case 7:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48));
    default:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif

/* check if intx value is a uint64 value */
int
ASN1intxisuint64(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 8;
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a int64 value */
ASN1int64_t
ASN1intx2int64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int64_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int64_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xffffffffff000000LL : 0));
    case 4:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 5] > 0x7f ?
            0xffffff0000000000LL : 0));
    case 6:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 6] > 0x7f ?
            0xffff000000000000LL : 0));
    case 7:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 7] > 0x7f ?
            0xff00000000000000LL : 0));
    default:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif

/* check if intx value is an int64 value */
int
ASN1intxisint64(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 8;
}

/* convert intx value to uint32 value */
ASN1uint32_t
ASN1intx2uint32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint32_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    default:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an uint32 value */
int
ASN1intxisuint32(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 4;
}

/* convert intx value to int32 value */
ASN1int32_t
ASN1intx2int32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int32_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int32_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xff000000 : 0));
    default:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an int32 value */
int
ASN1intxisint32(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 4;
}

/* convert intx value to uint16 value */
ASN1uint16_t
ASN1intx2uint16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1uint16_t)val->value[val->length - 1];
    return (ASN1uint16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}

/* check if intx value is an uint16 value */
int
ASN1intxisuint16(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 2;
}

/* convert intx value to int16 value */
ASN1int16_t
ASN1intx2int16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1int16_t)(ASN1int8_t)val->value[val->length - 1];
    return (ASN1int16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}

/* check if intx value is an int16 value */
int
ASN1intxisint16(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 2;
}

/* convert intx value to uint8 value */
ASN1uint8_t
ASN1intx2uint8(ASN1intx_t *val)
{
    return (ASN1uint8_t)val->value[val->length - 1];
}

/* check if intx value is an uint8 value */
int
ASN1intxisuint8(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 1;
}

/* convert intx value to int8 value */
ASN1int8_t
ASN1intx2int8(ASN1intx_t *val)
{
    return (ASN1int8_t)val->value[val->length - 1];
}

/* check if intx value is an int8 value */
int
ASN1intxisint8(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 1;
}

/* count octets for a signed encoding of an intx value */
ASN1uint32_t
ASN1intx_octets(ASN1intx_t *val)
{
    ASN1uint32_t i;
    ASN1uint32_t s;

    s = val->value[0] > 0x7f ? 0xff : 0x00;
    for (i = 0; i < val->length; i++) {
        if (val->value[i] != s)
            break;
    }
    if (i && ((val->value[i] ^ s) & 0x80))
        i--;
    return val->length - i;
}

/* count octets for unsigned encoding of an unsigned intx value */
ASN1uint32_t
ASN1intx_uoctets(ASN1intx_t *val)
{
    ASN1uint32_t i;

    for (i = 0; i < val->length; i++) {
        if (val->value[i])
            break;
    }
    return val->length - i;
}

/* count octets for signed encoding of an uint32 value */
ASN1uint32_t
ASN1uint32_octets(ASN1uint32_t val)
{
    if (val >= 0x8000) {
        if (val >= 0x800000) {
            if (val >= 0x80000000)
                return 5;
            return 4;
        }
        return 3;
    }
    if (val >= 0x80)
        return 2;
    return 1;
}

/* count octets for unsigned encoding of an uint32 value */
ASN1uint32_t
ASN1uint32_uoctets(ASN1uint32_t val)
{
    if (val >= 0x10000) {
        if (val >= 0x1000000)
            return 4;
        return 3;
    }
    if (val >= 0x100)
        return 2;
    return 1;
}

/* count octets for signed encoding of an int32 value */
ASN1uint32_t
ASN1int32_octets(ASN1int32_t val)
{
    if (val >= 0) {
        if (val >= 0x8000) {
            if (val >= 0x800000)
                return 4;
            return 3;
        }
        if (val >= 0x80)
            return 2;
        return 1;
    }
    if (val < -0x8000) {
        if (val < -0x800000)
            return 4;
        return 3;
    }
    if (val < -0x80)
        return 2;
    return 1;
}

/* convert an intx value into a double */
double
ASN1intx2double(ASN1intx_t *val)
{
    double ret;
    ASN1uint32_t i;

    if (val->value[0] > 0x7f)
        ret = (double)(val->value[0] - 0x100);
    else
        ret = (double)val->value[0];
    for (i = 1; i < val->length; i++) {
        ret = ret * 256.0 + (double)val->value[i];
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\objid.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* --- NamedObjIdValue --- */

/* constructor of NamedObjIdValue_t */
NamedObjIdValue_t *NewNamedObjIdValue(NamedObjIdValue_e type)
{
    NamedObjIdValue_t *ret;

    ret = (NamedObjIdValue_t *)malloc(sizeof(NamedObjIdValue_t));
    ret->Type = type;
    ret->Next = NULL;
    ret->Name = NULL;
    ret->Number = 0xffffffff;
    return ret;
}

/* copy constructor of NamedObjIdValue_t */
NamedObjIdValue_t *DupNamedObjIdValue(NamedObjIdValue_t *src)
{
    NamedObjIdValue_t *ret;

    if (!src)
	return NULL;
    ret = (NamedObjIdValue_t *)malloc(sizeof(NamedObjIdValue_t));
    *ret = *src;
    return ret;
}

/* --- AssignedObjIds --- */

/* constructor of AssignedObjId_t */
AssignedObjId_t *NewAssignedObjId()
{
    AssignedObjId_t *ret;

    ret = (AssignedObjId_t *)malloc(sizeof(AssignedObjId_t));
    ret->Next = NULL;
    ret->Child = NULL;
    ret->Names = NULL;
    ret->Number = 0;
    return ret;
}

/* copy constructor of AssignedObjId_t */
AssignedObjId_t *DupAssignedObjId(AssignedObjId_t *src)
{
    AssignedObjId_t *ret;

    if (!src)
	return NULL;
    ret = (AssignedObjId_t *)malloc(sizeof(AssignedObjId_t));
    *ret = *src;
    return ret;
}

/* find an AssignedObjId_t by number in a list of AssignedObjId_t's */
static AssignedObjId_t *FindAssignedObjIdByNumber(AssignedObjId_t *aoi, objectnumber_t number)
{
    for (; aoi; aoi = aoi->Next) {
    	if (aoi->Number == number)
	    return aoi;
    }
    return NULL;
}

/* find an AssignedObjId_t by name in a list of AssignedObjId_t's */
static AssignedObjId_t *FindAssignedObjIdByName(AssignedObjId_t *aoi, char *name)
{
    String_t *names;

    for (; aoi; aoi = aoi->Next) {
	for (names = aoi->Names; names; names = names->Next) {
	    if (!strcmp(names->String, name))
		return aoi;
	}
    }
    return NULL;
}

/* convert a NamedObjIdValue into an object identifier value */
/* search for one NamedObjIdValue in AssignedObjIds; */
/* returns -1 for bad NamedObjIdValue (names defined to different values), */
/* returns 0 for unknown NamedObjIdValue (will probably be resolved in */
/* the next pass), */
/* returns 1 for success; */
/* on success: */
/* number contains the objectnumber, */
/* aoi contains a duplicate of the AssignedObjIds for the found */
/* NamedObjIdValue */
static int GetObjectIdentifierNumber(AssignedObjId_t **aoi, NamedObjIdValue_t *val, objectnumber_t *number)
{
    AssignedObjId_t *a, *a2;

    switch (val->Type) {
    case eNamedObjIdValue_NameForm:

	/* name form: search the assigned objid by name and return 0 if not */
	/* found */
	a2 = FindAssignedObjIdByName(*aoi, val->Name);
	if (!a2)
	    return 0;
	
	/* otherwise create a duplicate */
	a = DupAssignedObjId(a2);
	a->Next = *aoi;
	*aoi = a;
	break;

    case eNamedObjIdValue_NumberForm:

	/* number form: search the assigned objid by number and create */
	/* a new one/a duplicate */
	a2 = FindAssignedObjIdByNumber(*aoi, val->Number);
	if (!a2) {
	    a = NewAssignedObjId();
	    a->Number = val->Number;
	    a->Next = *aoi;
	    *aoi = a;
	} else {
	    a = DupAssignedObjId(a2);
	    a->Next = *aoi;
	    *aoi = a;
	}
	break;

    case eNamedObjIdValue_NameAndNumberForm:

	/* name and number form: search the assigned objid by name and by */
	/* number */
	a = FindAssignedObjIdByName(*aoi, val->Name);
	a2 = FindAssignedObjIdByNumber(*aoi, val->Number);

	/* successful but different results are errorneous */
	if (a && a != a2)
	    return -1;

	if (!a && !a2) {

	    /* found none, then create it */
	    a = NewAssignedObjId();
	    a->Number = val->Number;
	    a->Names = NewString();
	    a->Names->String = val->Name;
	    a->Next = *aoi;
	    *aoi = a;

	} else if (!a) {

	    /* found only by number, then duplicate it and add the name */
	    a = DupAssignedObjId(a2);
	    a->Names = NewString();
	    a->Names->String = val->Name;
	    a->Names->Next = a2->Names;
	    a->Next = *aoi;
	    *aoi = a;

	} else {

	    /* found only by name, then duplicate it */
	    a = DupAssignedObjId(a2);
	    a->Next = *aoi;
	    *aoi = a;
	}
	break;
    }
    *number = a->Number;
    return 1;
}

/*
 * create a value out of NamedObjIdValues
 * returns -1 for bad NamedObjIdValue (names defined to different values),
 * returns 0 for unknown NamedObjIdValue (will probably be resolved next pass),
 * returns 1 for success;
 */
int GetAssignedObjectIdentifier(AssignedObjId_t **aoi, Value_t *parent, NamedObjIdValueList_t named, Value_t **val)
{
    Value_t *v;
    int parentl;
    int l;
    NamedObjIdValue_t *n;
    objectnumber_t *on;

    /* get length of object identifier */
    parentl = (parent ? parent->U.ObjectIdentifier.Value.length : 0);
    for (l = parentl, n = named; n; n = n->Next)
    {
        Value_t *pValue;
        pValue = (n->Type == eNamedObjIdValue_NameForm) ?
                 GetDefinedOIDValue(n->Name) : NULL;
        if (pValue)
        {
            ASSERT(pValue->Type->Type == eType_ObjectIdentifier);
            l += pValue->U.ObjectIdentifier.Value.length;
        }
        else
        {
            l++;
        }
    }

    /* create the object identifier value */
    v = NewValue(NULL, Builtin_Type_ObjectIdentifier);
    v->U.ObjectIdentifier.Value.length = l;
    v->U.ObjectIdentifier.Value.value = on = 
	(objectnumber_t *)malloc(l * sizeof(objectnumber_t));

    /* get the numbers of the parent object identifier and walk in the object */
    /* identifier tree */
    n = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
    for (l = 0; l < parentl; l++) {
	n->Number = parent->U.ObjectIdentifier.Value.value[l];
	switch (GetObjectIdentifierNumber(aoi, n, on + l)) {
	case -1:
	    return -1;
	case 0:
	    return 0;
	default:
	    aoi = &(*aoi)->Child;
	    break;
	}
    }

    /* get the numers from the namedobjidvaluelist */
    for (n = named; n; n = n->Next)
    {
        Value_t *pValue;
        pValue = (n->Type == eNamedObjIdValue_NameForm) ?
                 GetDefinedOIDValue(n->Name) : NULL;
        if (pValue)
        {
            memcpy(on + l, pValue->U.ObjectIdentifier.Value.value,
                 pValue->U.ObjectIdentifier.Value.length * sizeof(objectnumber_t));
            l += pValue->U.ObjectIdentifier.Value.length;
        }
        else
        {
	        switch (GetObjectIdentifierNumber(aoi, n, on + l))
            {
	        case -1:
	            return -1;
	        case 0:
	            return 0;
	        default:
	            aoi = &(*aoi)->Child;
	            break;
	        }
            l++;
        }
    }

    *val = v;
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\libasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __ASN1C_LIB_ASN1_H__
#define __ASN1C_LIB_ASN1_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

// THE FOLLOWING IS FROM MS_CORE.H

/*
 * This file contains operating system specific defines:
 *
 * Dynamic link library support:
 * Define DllExport as declspec for exported functions and
 * DllImport as declspec for imported functions.
 *
 * Floating point encoding support:
 * For encoding floating point values either
 * - finite()+isinf()+copysign()+frexp() or
 * - finite()+fpclass()+FP_PINF+FP_NINF+frexp()
 * is needed. Define HAS_ISINF for the former case or HAS_FPCLASS for
 * the latter case.
 * Define HAS_IEEEFP_H for inclusion of <ieeefp.h> or HAS_FLOAT_H for
 * inclusion of <float.h> if required.
 *
 * Integer type support
 * [u]int{8,16,32}_t must specify an integral (unsigned iff u-prefixed)
 * type of the specified size (in bits).
 */

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}


extern ASN1_PUBLIC ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
// extern ASN1_PUBLIC ASN1stringtable_t ASN1NumericStringTable;
extern ASN1_PUBLIC void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_inc(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_dec(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern ASN1_PUBLIC void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint64(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint64(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint32(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint32(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint16(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint16(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisuint8(ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1_PUBLIC ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1_PUBLIC ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern ASN1_PUBLIC double ASN1API ASN1intx2double(ASN1intx_t *);
extern ASN1_PUBLIC double ASN1API ASN1real2double(ASN1real_t *);
extern ASN1_PUBLIC double ASN1API ASN1double_minf();
extern ASN1_PUBLIC double ASN1API ASN1double_pinf();
extern ASN1_PUBLIC int ASN1API ASN1double_isminf(double);
extern ASN1_PUBLIC int ASN1API ASN1double_ispinf(double);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern ASN1_PUBLIC int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Memory Free APIs ------ */

extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);

/* ------ Comparison APIs ------ */

extern ASN1_PUBLIC long ASN1API ASN1double_cmp(double, double);
extern ASN1_PUBLIC long ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern ASN1_PUBLIC long ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern ASN1_PUBLIC long ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC long ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern ASN1_PUBLIC long ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern ASN1_PUBLIC long ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));



#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    



#ifdef __cplusplus
}
#endif

#endif // __ASN1C_LIB_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\optcase.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_OPT_CASE_H_
#define _ASN1C_OPT_CASE_H_

int PerOptCase_IsSignedInteger(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsUnsignedInteger(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsSignedShort(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsUnsignedShort(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsBoolean(PERSimpleTypeInfo_t *sinfo);
int PerOptCase_IsTargetSeqOf(PERTypeInfo_t *info);

int BerOptCase_IsBoolean(BERTypeInfo_t *info);

#endif // _ASN1C_OPT_CASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\parser.c ===
#include "precomp.h" 
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "defs.h"
#include "builtin.h"
#include "hackdir.h"

extern int pass;


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "parser.h"

int llcpos;
int *llstk;
unsigned llstksize;
unsigned llcstp = 1;
LLTERM *lltokens;
int llntokens;
char llerrormsg[256];
LLPOS llerrorpos;
int llepos;
LLSTYPE lllval;

int llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout);
void llfailed(LLPOS *pos, char *fmt, ...);
void llresizestk();
#define LLCHECKSTK do{if (llcstp + 1 >= llstksize) llresizestk();}while(/*CONSTCOND*/0)
#define LLFAILED(_err) do{llfailed _err; goto failed;}while(/*CONSTCOND*/0)
#define LLCUTOFF do{unsigned i; for (i = llstp; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)
#define LLCUTTHIS do{if (llstk[llstp] > 0) llstk[llstp] = -llstk[llstp];}while(/*CONSTCOND*/0)
#define LLCUTALL do{unsigned i; for (i = 0; i < llcstp; i++) if (llstk[i] > 0) llstk[i] = -llstk[i];}while(/*CONSTCOND*/0)

#if LLDEBUG > 0
int lldebug;
int last_linenr;
char *last_file = "";
#define LLDEBUG_ENTER(_ident) lldebug_enter(_ident)
#define LLDEBUG_LEAVE(_ident,_succ) lldebug_leave(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt) lldebug_alternative(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num) lldebug_iteration(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos) lldebug_token(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos) lldebug_anytoken(_pos)
#define LLDEBUG_BACKTRACKING(_ident) lldebug_backtracking(_ident)
void lldebug_init();
void lldebug_enter(char *ident);
void lldebug_leave(char *ident, int succ);
void lldebug_alternative(char *ident, int alt);
void lldebug_token(int expected, unsigned pos);
void lldebug_anytoken(unsigned pos);
void lldebug_backtracking(char *ident);
void llprinttoken(LLTERM *token, char *identifier, FILE *f);
#else
#define LLDEBUG_ENTER(_ident)
#define LLDEBUG_LEAVE(_ident,_succ)
#define LLDEBUG_ALTERNATIVE(_ident,_alt)
#define LLDEBUG_ITERATION(_ident,_num)
#define LLDEBUG_TOKEN(_exp,_pos)
#define LLDEBUG_ANYTOKEN(_pos)
#define LLDEBUG_BACKTRACKING(_ident)
#endif

int ll_Main(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Main");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_ModuleDefinition(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!ll_ModuleDefinition_ESeq(&llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
}}
LLDEBUG_LEAVE("Main", 1);
return 1;
failed1: LLDEBUG_LEAVE("Main", 0);
return 0;
}

int ll_ModuleDefinition_ESeq(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleDefinition_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ModuleDefinition_ESeq", 1);
{LLSTATE llstate_1;
if (!ll_ModuleDefinition(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ModuleDefinition_ESeq(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ModuleDefinition_ESeq", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ModuleDefinition_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ModuleDefinition_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleDefinition_ESeq", 0);
return 0;
}

int ll_ModuleDefinition(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleDefinition");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_ModuleIdentifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEFINITIONS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XTagType llatt_3;
if (!ll_TagDefault(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XExtensionType llatt_4;
if (!ll_ExtensionDefault(&llatt_4, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
{if (!AssignModuleIdentifier(&llstate_5.Assignments, llatt_1))
		LLFAILED((&llstate_1.pos, "Module `%s' twice defined", llatt_1->Identifier));
	    llstate_5.MainModule = llatt_1;
	    llstate_5.Module = llatt_1;
	    llstate_5.TagDefault = llatt_3;
	    llstate_5.ExtensionDefault = llatt_4;
	    g_eDefTagType = llatt_3;
	
{LLSTATE llstate_6;
if (!llterm(T_BEGIN, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed1;
{LLSTATE llstate_7;
if (!ll_ModuleBody(&llstate_6, &llstate_7)) goto failed1;
{LLSTATE llstate_8;
if (!llterm(T_END, (LLSTYPE *)0, &llstate_7, &llstate_8)) goto failed1;
*llout = llstate_8;
{LLCUTALL;
	
}}}}}}}}}}
LLDEBUG_LEAVE("ModuleDefinition", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleDefinition", 0);
return 0;
}

int ll_ModuleIdentifier(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_DefinitiveIdentifier(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewModuleIdentifier();
		(*llret)->Identifier = llatt_1->Identifier;
		(*llret)->ObjectIdentifier = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ModuleIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleIdentifier", 0);
return 0;
}

int ll_DefinitiveIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveIdentifier", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_DefinitiveObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{switch (GetAssignedObjectIdentifier(
		&(*llout).AssignedObjIds, NULL, llatt_2, &(*llret))) {
	    case -1:
		LLFAILED((&llstate_2.pos, "Different numbers for equally named object identifier components"));
		/*NOTREACHED*/
	    case 0:
		(*llret) = NULL;
		break;
	    case 1:
		break;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveIdentifier", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveIdentifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveIdentifier", 0);
return 0;
}

int ll_DefinitiveObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveObjIdComponentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponentList", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_DefinitiveObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = DupNamedObjIdValue(llatt_1);
	    (*llret)->Next = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponentList", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveObjIdComponentList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveObjIdComponentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveObjIdComponentList", 0);
return 0;
}

int ll_DefinitiveObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveObjIdComponent");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinitiveObjIdComponent", 3);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_DefinitiveNameAndNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinitiveObjIdComponent");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinitiveObjIdComponent", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveObjIdComponent", 0);
return 0;
}

int ll_DefinitiveNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
	    (*llret)->Number = intx2uint32(&llatt_1);
	
}}
LLDEBUG_LEAVE("DefinitiveNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveNumberForm", 0);
return 0;
}

int ll_DefinitiveNameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinitiveNameAndNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNumber llatt_3;
if (!llterm(T_number, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XNumber;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameAndNumberForm);
	    (*llret)->Name = llatt_1;
	    (*llret)->Number = intx2uint32(&llatt_3);
	
}}}}}
LLDEBUG_LEAVE("DefinitiveNameAndNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinitiveNameAndNumberForm", 0);
return 0;
}

int ll_TagDefault(XTagType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TagDefault");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TagDefault", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Explicit;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TagDefault", 2);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Implicit;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TagDefault", 3);
{LLSTATE llstate_1;
if (!llterm(T_AUTOMATIC, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eTagType_Automatic;
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("TagDefault", 4);
*llout = llstate_0;
{(*llret) = eTagType_Explicit;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TagDefault");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TagDefault", 1);
return 1;
failed1: LLDEBUG_LEAVE("TagDefault", 0);
return 0;
}

int ll_ExtensionDefault(XExtensionType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtensionDefault");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtensionDefault", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXTENSIBILITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_IMPLIED, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = eExtensionType_Automatic;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtensionDefault", 2);
*llout = llstate_0;
{(*llret) = eExtensionType_None;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtensionDefault");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtensionDefault", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtensionDefault", 0);
return 0;
}

int ll_ModuleBody(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ModuleBody");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ModuleBody", 1);
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_Exports(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_Imports(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{llstate_2.Imported = llatt_2;
	
{LLSTATE llstate_3;
if (!ll_AssignmentList(&llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{String_t *s;
	    StringModule_t *sm;
	    Assignment_t *a, **aa, *oldass;
	    UndefinedSymbol_t *u;
	    if (llatt_2 != IMPORT_ALL) {
		for (sm = llatt_2; sm; sm = sm->Next) {
		    if (!FindExportedAssignment((*llout).Assignments,
			eAssignment_Undefined, sm->String, sm->Module)) {
			if (FindAssignment((*llout).Assignments,
			    eAssignment_Undefined, sm->String,
			    sm->Module)) {
			    u = NewUndefinedSymbol(
				eUndefinedSymbol_SymbolNotExported,
				eAssignment_Undefined);
			} else {
			    u = NewUndefinedSymbol(
				eUndefinedSymbol_SymbolNotDefined,
				eAssignment_Undefined);
			}
			u->U.Symbol.Identifier = sm->String;
			u->U.Symbol.Module = sm->Module;
			u->Next = (*llout).Undefined;
			(*llout).Undefined = u;
			continue;
		    }
		    if (!FindAssignmentInCurrentPass((*llout).Assignments,
			sm->String, (*llout).Module)) {
			a = NewAssignment(eAssignment_Reference);
			a->Identifier = sm->String;
			a->Module = (*llout).Module;
			a->U.Reference.Identifier = sm->String;
			a->U.Reference.Module = sm->Module;
			a->Next = (*llout).Assignments;
			(*llout).Assignments = a;
		    }
		}
	    }
	    if (llatt_1 != EXPORT_ALL) {
		for (s = llatt_1; s; s = s->Next) {
		    if (!FindAssignment((*llout).Assignments, eAssignment_Undefined,
			s->String, (*llout).Module))
			LLFAILED((&llstate_1.pos, "Exported symbol `%s' is undefined",
			    s->String));
		}
	    }
	    oldass = (*llout).Assignments;
	    for (a = (*llout).Assignments, aa = &(*llout).Assignments; a;
		a = a->Next, aa = &(*aa)->Next) {
		if (a->Type == eAssignment_NextPass)
		    break;
		*aa = DupAssignment(a);
		if (!FindAssignmentInCurrentPass(a->Next, 
		    a->Identifier, a->Module) &&
		    FindAssignmentInCurrentPass(oldass,
		    a->Identifier, a->Module) == a &&
		    !CmpModuleIdentifier(oldass, a->Module, (*llout).Module) &&
		    (llatt_1 == EXPORT_ALL || FindString(llatt_1, a->Identifier)))
		    (*aa)->Flags |= eAssignmentFlags_Exported;
	    }
	    *aa = a;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ModuleBody", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ModuleBody");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ModuleBody", 1);
return 1;
failed1: LLDEBUG_LEAVE("ModuleBody", 0);
return 0;
}

int ll_Exports(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exports");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Exports", 1);
{LLSTATE llstate_1;
if (!llterm(T_EXPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_SymbolsExported(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{String_t *s, *t;
	    for (s = llatt_2; s && s->Next; s = s->Next) {
		for (t = s->Next; t; t = t->Next) {
		    if (!strcmp(s->String, t->String))
			LLFAILED((&llstate_2.pos, "Symbol `%s' has been exported twice",
			    s->String));
		}
	    }
	    (*llret) = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Exports", 2);
*llout = llstate_0;
{(*llret) = EXPORT_ALL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Exports");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Exports", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exports", 0);
return 0;
}

int ll_SymbolsExported(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsExported");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolsExported", 1);
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_SymbolList(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolsExported", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolsExported");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolsExported", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsExported", 0);
return 0;
}

int ll_Imports(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Imports");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Imports", 1);
{LLSTATE llstate_1;
if (!llterm(T_IMPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_SymbolsImported(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(';', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Imports", 2);
*llout = llstate_0;
{(*llret) = IMPORT_ALL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Imports");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Imports", 1);
return 1;
failed1: LLDEBUG_LEAVE("Imports", 0);
return 0;
}

int ll_SymbolsImported(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsImported");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XStringModules llatt_1;
if (!ll_SymbolsFromModule_ESeq(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("SymbolsImported", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsImported", 0);
return 0;
}

int ll_SymbolsFromModule_ESeq(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsFromModule_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolsFromModule_ESeq", 1);
{LLSTATE llstate_1;XStringModules llatt_1;
if (!ll_SymbolsFromModule(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XStringModules llatt_2;
if (!ll_SymbolsFromModule_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{StringModule_t *s, **ss;
	    for (s = llatt_1, ss = &(*llret); s; s = s->Next) {
		*ss = DupStringModule(s);
		ss = &(*ss)->Next;
	    }
	    *ss = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolsFromModule_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolsFromModule_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolsFromModule_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsFromModule_ESeq", 0);
return 0;
}

int ll_SymbolsFromModule(XStringModules *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolsFromModule");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XStrings llatt_1;
if (!ll_SymbolList(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XModuleIdentifier llatt_3;
if (!ll_GlobalModuleReference(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{String_t *s, *t;
	    StringModule_t **ss;
	    for (s = llatt_1; s && s->Next; s = s->Next) {
		for (t = s->Next; t; t = t->Next) {
		    if (!strcmp(s->String, t->String))
			LLFAILED((&llstate_2.pos, "Symbol `%s' has been imported twice",
			    s->String));
		}
	    }
	    for (s = llatt_1, ss = &(*llret); s; s = s->Next) {
		*ss = NewStringModule();
		(*ss)->String = s->String;
		(*ss)->Module = llatt_3;
		ss = &(*ss)->Next;
	    }
	    *ss = NULL;
	
}}}}
LLDEBUG_LEAVE("SymbolsFromModule", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolsFromModule", 0);
return 0;
}

int ll_GlobalModuleReference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GlobalModuleReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_AssignedIdentifier(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewModuleIdentifier();
	    (*llret)->Identifier = llatt_1->Identifier;
	    (*llret)->ObjectIdentifier = llatt_2;
	
}}}
LLDEBUG_LEAVE("GlobalModuleReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("GlobalModuleReference", 0);
return 0;
}

int ll_AssignedIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AssignedIdentifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectIdentifierValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("AssignedIdentifier", 3);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AssignedIdentifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AssignedIdentifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("AssignedIdentifier", 0);
return 0;
}

int ll_SymbolList(XStrings *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SymbolList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SymbolList", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Symbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_SymbolList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SymbolList", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Symbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SymbolList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SymbolList", 1);
return 1;
failed1: LLDEBUG_LEAVE("SymbolList", 0);
return 0;
}

int ll_Symbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Symbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Symbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Reference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Symbol", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedReference(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Symbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Symbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("Symbol", 0);
return 0;
}

int ll_Reference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Reference");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Reference", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Reference", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Reference");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Reference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Reference", 0);
return 0;
}

int ll_AssignmentList(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AssignmentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!ll_Assignment(&llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!ll_Assignment_ESeq(&llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
}}
LLDEBUG_LEAVE("AssignmentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AssignmentList", 0);
return 0;
}

int ll_Assignment_ESeq(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Assignment_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Assignment_ESeq", 1);
{LLSTATE llstate_1;
if (!ll_Assignment(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_Assignment_ESeq(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Assignment_ESeq", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Assignment_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Assignment_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("Assignment_ESeq", 0);
return 0;
}

int ll_Assignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Assignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Assignment", 1);
{LLSTATE llstate_1;
if (!ll_TypeAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Assignment", 2);
{LLSTATE llstate_1;
if (!ll_ValueAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Assignment", 3);
{LLSTATE llstate_1;
if (!ll_ValueSetTypeAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Assignment", 4);
{LLSTATE llstate_1;
if (!ll_ObjectClassAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("Assignment", 5);
{LLSTATE llstate_1;
if (!ll_ObjectAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("Assignment", 6);
{LLSTATE llstate_1;
if (!ll_ObjectSetAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("Assignment", 7);
{LLSTATE llstate_1;
if (!ll_ParameterizedAssignment(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("Assignment", 8);
{LLSTATE llstate_1;
if (!ll_MacroDefinition(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{LLCUTALL;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Assignment");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Assignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("Assignment", 0);
return 0;
}

int ll_typereference(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("typereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Type);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Type)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a typereference", llatt_1));
	    (*llret) = NewType(eType_Reference);
	    if (ref && ref->U.Type.Type)
	    {
	    	int fPublic = ref->U.Type.Type->PrivateDirectives.fPublic;
	    	ref->U.Type.Type->PrivateDirectives.fPublic = 0;
	    	PropagateReferenceTypePrivateDirectives((*llret), &(ref->U.Type.Type->PrivateDirectives));
	    	ref->U.Type.Type->PrivateDirectives.fPublic = fPublic;
	    }
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("typereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("typereference", 0);
return 0;
}

int ll_Externaltypereference(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externaltypereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Type, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Type, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Type);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Type);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Type)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a typereference", llatt_1));
	    (*llret) = NewType(eType_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externaltypereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externaltypereference", 0);
return 0;
}

int ll_valuereference(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Value);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Value)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a valuereference", llatt_1));
	    (*llret) = NewValue(NULL, NULL);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("valuereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuereference", 0);
return 0;
}

int ll_Externalvaluereference(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externalvaluereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!llterm(T_lcsymbol, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XString;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Value, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Value, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Value);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Value);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Value)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not a valuereference", llatt_1));
	    (*llret) = NewValue(NULL, NULL);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externalvaluereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externalvaluereference", 0);
return 0;
}

int ll_objectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectclassreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_ObjectClass);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectClass)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectclassreference", llatt_1));
	    (*llret) = NewObjectClass(eObjectClass_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectclassreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectclassreference", 0);
return 0;
}

int ll_ExternalObjectClassReference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectClassReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ocsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_ObjectClass, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_ObjectClass, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_ObjectClass);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_ObjectClass);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectClass)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectclassreference", llatt_1));
	    (*llret) = NewObjectClass(eObjectClass_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectClassReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectClassReference", 0);
return 0;
}

int ll_objectreference(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Object);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Object)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectreference", llatt_1));
	    (*llret) = NewObject(eObject_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectreference", 0);
return 0;
}

int ll_ExternalObjectReference(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!llterm(T_lcsymbol, &lllval, &llstate_2, &llstate_3)) goto failed1;
llatt_3 = lllval._XString;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Object, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Object, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Object);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Object);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Object)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectreference", llatt_1));
	    (*llret) = NewObject(eObject_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectReference", 0);
return 0;
}

int ll_objectsetreference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectsetreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_ObjectSet);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectSet)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectsetreference", llatt_1));
	    (*llret) = NewObjectSet(eObjectSet_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("objectsetreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectsetreference", 0);
return 0;
}

int ll_ExternalObjectSetReference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalObjectSetReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_ObjectSet, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_ObjectSet, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_ObjectSet);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_ObjectSet);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_ObjectSet)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an objectsetreference", llatt_1));
	    (*llret) = NewObjectSet(eObjectSet_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("ExternalObjectSetReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalObjectSetReference", 0);
return 0;
}

int ll_macroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("macroreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    ref = FindAssignment((*llout).Assignments,
		eAssignment_Undefined, llatt_1, (*llout).Module);
	    if (!ref) {
		u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
		    eAssignment_Macro);
		u->U.Symbol.Module = (*llout).Module;
		u->U.Symbol.Identifier = llatt_1;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Macro)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an macroreference", llatt_1));
	    (*llret) = NewMacro(eMacro_Reference);
	    (*llret)->U.Reference.Identifier = llatt_1;
	    (*llret)->U.Reference.Module = (*llout).Module;
	
}}
LLDEBUG_LEAVE("macroreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("macroreference", 0);
return 0;
}

int ll_Externalmacroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Externalmacroreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XModuleIdentifier llatt_1;
if (!ll_modulereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XString llatt_3;
if (!ll_ucsymbol(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Assignment_t *ref;
	    UndefinedSymbol_t *u;
	    if ((*llout).Imported != IMPORT_ALL &&
		!FindStringModule((*llout).Assignments, (*llout).Imported, llatt_3, llatt_1))
		LLFAILED((&llstate_1.pos, "Symbol `%s.%s' has not been imported",
		    llatt_1->Identifier, llatt_3));
	    ref = FindExportedAssignment((*llout).Assignments,
		eAssignment_Macro, llatt_3, llatt_1);
	    if (!ref) {
		if (FindAssignment((*llout).Assignments,
		    eAssignment_Macro, llatt_3, llatt_1)) {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotExported,
			eAssignment_Macro);
		} else {
		    u = NewUndefinedSymbol(eUndefinedSymbol_SymbolNotDefined,
			eAssignment_Macro);
		}
		u->U.Symbol.Module = llatt_1;
		u->U.Symbol.Identifier = llatt_3;
		u->Next = (*llout).Undefined;
		(*llout).Undefined = u;
	    } else if (GetAssignmentType((*llout).Assignments, ref) !=
		eAssignment_Macro)
		LLFAILED((&llstate_1.pos, "Symbol `%s' is not an macroreference", llatt_1));
	    (*llret) = NewMacro(eMacro_Reference);
	    (*llret)->U.Reference.Identifier = llatt_3;
	    (*llret)->U.Reference.Module = llatt_1;
	
}}}}
LLDEBUG_LEAVE("Externalmacroreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Externalmacroreference", 0);
return 0;
}

int ll_localtypereference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("localtypereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("localtypereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("localtypereference", 0);
return 0;
}

int ll_localvaluereference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("localvaluereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("localvaluereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("localvaluereference", 0);
return 0;
}

int ll_productionreference(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("productionreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("productionreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("productionreference", 0);
return 0;
}

int ll_modulereference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("modulereference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewModuleIdentifier();
	    (*llret)->Identifier = llatt_1;
	
}}
LLDEBUG_LEAVE("modulereference", 1);
return 1;
failed1: LLDEBUG_LEAVE("modulereference", 0);
return 0;
}

int ll_typefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("typefieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Type);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_Type)
		LLFAILED((&llstate_1.pos, "%s is not a typefieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("typefieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("typefieldreference", 0);
return 0;
}

int ll_valuefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuefieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_amplcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Value);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_1.pos, "%s is not a valuefieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("valuefieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuefieldreference", 0);
return 0;
}

int ll_valuesetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("valuesetfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_ValueSet);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_1.pos, "%s is not a valuesetfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("valuesetfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("valuesetfieldreference", 0);
return 0;
}

int ll_objectfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_amplcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_Object);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_Object)
		LLFAILED((&llstate_1.pos, "%s is not a objectfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("objectfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectfieldreference", 0);
return 0;
}

int ll_objectsetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("objectsetfieldreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_ampucsymbol, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString;
*llout = llstate_1;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    ObjectClass_t *oc;
	    UndefinedSymbol_t *u;
	    oc = GetObjectClass((*llout).Assignments, llarg_oc);
	    fs = oc ? FindFieldSpec(oc->U.ObjectClass.FieldSpec, llatt_1) : NULL;
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe == eFieldSpec_Undefined) {
		if (llarg_oc) {
		    u = NewUndefinedField(eUndefinedSymbol_FieldNotDefined,
			llarg_oc, eSetting_ObjectSet);
		    u->U.Field.Module = (*llout).Module;
		    u->U.Field.Identifier = llatt_1;
		    u->Next = (*llout).Undefined;
		    (*llout).Undefined = u;
		}
	    } else if (fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_1.pos, "%s is not a objectsetfieldreference", llatt_1));
	    (*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("objectsetfieldreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("objectsetfieldreference", 0);
return 0;
}

int ll_word(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("word");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("word", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ucsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("word", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ABSENT";
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("word", 3);
{LLSTATE llstate_1;
if (!llterm(T_ABSTRACT_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ABSTRACT-SYNTAX";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("word", 4);
{LLSTATE llstate_1;
if (!llterm(T_ALL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ALL";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("word", 5);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ANY";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("word", 6);
{LLSTATE llstate_1;
if (!llterm(T_APPLICATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "APPLICATION";
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("word", 7);
{LLSTATE llstate_1;
if (!llterm(T_AUTOMATIC, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "AUTOMATIC";
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("word", 8);
{LLSTATE llstate_1;
if (!llterm(T_BEGIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BEGIN";
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("word", 9);
{LLSTATE llstate_1;
if (!llterm(T_BMPString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BMPString";
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("word", 10);
{LLSTATE llstate_1;
if (!llterm(T_BY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "BY";
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("word", 11);
{LLSTATE llstate_1;
if (!llterm(T_CLASS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "CLASS";
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("word", 12);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "COMPONENT";
	
break;
}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("word", 13);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "COMPONENTS";
	
break;
}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("word", 14);
{LLSTATE llstate_1;
if (!llterm(T_CONSTRAINED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "CONSTRAINED";
	
break;
}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("word", 15);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFAULT";
	
break;
}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("word", 16);
{LLSTATE llstate_1;
if (!llterm(T_DEFINED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFINED";
	
break;
}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("word", 17);
{LLSTATE llstate_1;
if (!llterm(T_DEFINITIONS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "DEFINITIONS";
	
break;
}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("word", 18);
{LLSTATE llstate_1;
if (!llterm(T_empty, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "empty";
	
break;
}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("word", 19);
{LLSTATE llstate_1;
if (!llterm(T_EXCEPT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXCEPT";
	
break;
}}
case 20: case -20:
LLDEBUG_ALTERNATIVE("word", 20);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXPLICIT";
	
break;
}}
case 21: case -21:
LLDEBUG_ALTERNATIVE("word", 21);
{LLSTATE llstate_1;
if (!llterm(T_EXPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXPORTS";
	
break;
}}
case 22: case -22:
LLDEBUG_ALTERNATIVE("word", 22);
{LLSTATE llstate_1;
if (!llterm(T_EXTENSIBILITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "EXTENSIBILITY";
	
break;
}}
case 23: case -23:
LLDEBUG_ALTERNATIVE("word", 23);
{LLSTATE llstate_1;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "FROM";
	
break;
}}
case 24: case -24:
LLDEBUG_ALTERNATIVE("word", 24);
{LLSTATE llstate_1;
if (!llterm(T_GeneralizedTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GeneralizedTime";
	
break;
}}
case 25: case -25:
LLDEBUG_ALTERNATIVE("word", 25);
{LLSTATE llstate_1;
if (!llterm(T_GeneralString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GeneralString";
	
break;
}}
case 26: case -26:
LLDEBUG_ALTERNATIVE("word", 26);
{LLSTATE llstate_1;
if (!llterm(T_GraphicString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "GraphicString";
	
break;
}}
case 27: case -27:
LLDEBUG_ALTERNATIVE("word", 27);
{LLSTATE llstate_1;
if (!llterm(T_IA5String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IA5String";
	
break;
}}
case 28: case -28:
LLDEBUG_ALTERNATIVE("word", 28);
{LLSTATE llstate_1;
if (!llterm(T_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IDENTIFIER";
	
break;
}}
case 29: case -29:
LLDEBUG_ALTERNATIVE("word", 29);
{LLSTATE llstate_1;
if (!llterm(T_identifier, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "identifier";
	
break;
}}
case 30: case -30:
LLDEBUG_ALTERNATIVE("word", 30);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPLICIT";
	
break;
}}
case 31: case -31:
LLDEBUG_ALTERNATIVE("word", 31);
{LLSTATE llstate_1;
if (!llterm(T_IMPLIED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPLIED";
	
break;
}}
case 32: case -32:
LLDEBUG_ALTERNATIVE("word", 32);
{LLSTATE llstate_1;
if (!llterm(T_IMPORTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "IMPORTS";
	
break;
}}
case 33: case -33:
LLDEBUG_ALTERNATIVE("word", 33);
{LLSTATE llstate_1;
if (!llterm(T_INCLUDES, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "INCLUDES";
	
break;
}}
case 34: case -34:
LLDEBUG_ALTERNATIVE("word", 34);
{LLSTATE llstate_1;
if (!llterm(T_ISO646String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ISO646String";
	
break;
}}
case 35: case -35:
LLDEBUG_ALTERNATIVE("word", 35);
{LLSTATE llstate_1;
if (!llterm(T_MACRO, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MACRO";
	
break;
}}
case 36: case -36:
LLDEBUG_ALTERNATIVE("word", 36);
{LLSTATE llstate_1;
if (!llterm(T_MAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MAX";
	
break;
}}
case 37: case -37:
LLDEBUG_ALTERNATIVE("word", 37);
{LLSTATE llstate_1;
if (!llterm(T_MIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MIN";
	
break;
}}
case 38: case -38:
LLDEBUG_ALTERNATIVE("word", 38);
{LLSTATE llstate_1;
if (!llterm(T_NOTATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NOTATION";
	
break;
}}
case 39: case -39:
LLDEBUG_ALTERNATIVE("word", 39);
{LLSTATE llstate_1;
if (!llterm(T_Number, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "number";
	
break;
}}
case 40: case -40:
LLDEBUG_ALTERNATIVE("word", 40);
{LLSTATE llstate_1;
if (!llterm(T_NumericString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NumericString";
	
break;
}}
case 41: case -41:
LLDEBUG_ALTERNATIVE("word", 41);
{LLSTATE llstate_1;
if (!llterm(T_ObjectDescriptor, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "ObjectDescriptor";
	
break;
}}
case 42: case -42:
LLDEBUG_ALTERNATIVE("word", 42);
{LLSTATE llstate_1;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "OF";
	
break;
}}
case 43: case -43:
LLDEBUG_ALTERNATIVE("word", 43);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "OPTIONAL";
	
break;
}}
case 44: case -44:
LLDEBUG_ALTERNATIVE("word", 44);
{LLSTATE llstate_1;
if (!llterm(T_PDV, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PDV";
	
break;
}}
case 45: case -45:
LLDEBUG_ALTERNATIVE("word", 45);
{LLSTATE llstate_1;
if (!llterm(T_PRESENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PRESENT";
	
break;
}}
case 46: case -46:
LLDEBUG_ALTERNATIVE("word", 46);
{LLSTATE llstate_1;
if (!llterm(T_PrintableString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PrintableString";
	
break;
}}
case 47: case -47:
LLDEBUG_ALTERNATIVE("word", 47);
{LLSTATE llstate_1;
if (!llterm(T_PRIVATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "PRIVATE";
	
break;
}}
case 48: case -48:
LLDEBUG_ALTERNATIVE("word", 48);
{LLSTATE llstate_1;
if (!llterm(T_SIZE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "SIZE";
	
break;
}}
case 49: case -49:
LLDEBUG_ALTERNATIVE("word", 49);
{LLSTATE llstate_1;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "STRING";
	
break;
}}
case 50: case -50:
LLDEBUG_ALTERNATIVE("word", 50);
{LLSTATE llstate_1;
if (!llterm(T_string, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "string";
	
break;
}}
case 51: case -51:
LLDEBUG_ALTERNATIVE("word", 51);
{LLSTATE llstate_1;
if (!llterm(T_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "SYNTAX";
	
break;
}}
case 52: case -52:
LLDEBUG_ALTERNATIVE("word", 52);
{LLSTATE llstate_1;
if (!llterm(T_T61String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "T61String";
	
break;
}}
case 53: case -53:
LLDEBUG_ALTERNATIVE("word", 53);
{LLSTATE llstate_1;
if (!llterm(T_TAGS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TAGS";
	
break;
}}
case 54: case -54:
LLDEBUG_ALTERNATIVE("word", 54);
{LLSTATE llstate_1;
if (!llterm(T_TeletexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TeletexString";
	
break;
}}
case 55: case -55:
LLDEBUG_ALTERNATIVE("word", 55);
{LLSTATE llstate_1;
if (!llterm(T_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE";
	
break;
}}
case 56: case -56:
LLDEBUG_ALTERNATIVE("word", 56);
{LLSTATE llstate_1;
if (!llterm(T_type, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "type";
	
break;
}}
case 57: case -57:
LLDEBUG_ALTERNATIVE("word", 57);
{LLSTATE llstate_1;
if (!llterm(T_TYPE_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE-IDENTIFIER";
	
break;
}}
case 58: case -58:
LLDEBUG_ALTERNATIVE("word", 58);
{LLSTATE llstate_1;
if (!llterm(T_UNIQUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UNIQUE";
	
break;
}}
case 59: case -59:
LLDEBUG_ALTERNATIVE("word", 59);
{LLSTATE llstate_1;
if (!llterm(T_UNIVERSAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UNIVERSAL";
	
break;
}}
case 60: case -60:
LLDEBUG_ALTERNATIVE("word", 60);
{LLSTATE llstate_1;
if (!llterm(T_UniversalString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UniversalString";
	
break;
}}
case 61: case -61:
LLDEBUG_ALTERNATIVE("word", 61);
{LLSTATE llstate_1;
if (!llterm(T_UTCTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UTCTime";
	
break;
}}
case 62: case -62:
LLDEBUG_ALTERNATIVE("word", 62);
{LLSTATE llstate_1;
if (!llterm(T_UTF8String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "UTF8String";
	
break;
}}
case 63: case -63:
LLDEBUG_ALTERNATIVE("word", 63);
{LLSTATE llstate_1;
if (!llterm(T_VALUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VALUE";
	
break;
}}
case 64: case -64:
LLDEBUG_ALTERNATIVE("word", 64);
{LLSTATE llstate_1;
if (!llterm(T_value, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "value";
	
break;
}}
case 65: case -65:
LLDEBUG_ALTERNATIVE("word", 65);
{LLSTATE llstate_1;
if (!llterm(T_VideotexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VideotexString";
	
break;
}}
case 66: case -66:
LLDEBUG_ALTERNATIVE("word", 66);
{LLSTATE llstate_1;
if (!llterm(T_VisibleString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VisibleString";
	
break;
}}
case 67: case -67:
LLDEBUG_ALTERNATIVE("word", 67);
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "WITH";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("word");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("word", 1);
return 1;
failed1: LLDEBUG_LEAVE("word", 0);
return 0;
}

int ll_identifier(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("identifier");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("identifier", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_lcsymbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("identifier", 2);
{LLSTATE llstate_1;
if (!llterm(T_empty, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "empty";
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("identifier", 3);
{LLSTATE llstate_1;
if (!llterm(T_identifier, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "identifier";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("identifier", 4);
{LLSTATE llstate_1;
if (!llterm(T_Number, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "number";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("identifier", 5);
{LLSTATE llstate_1;
if (!llterm(T_string, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "string";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("identifier", 6);
{LLSTATE llstate_1;
if (!llterm(T_type, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "type";
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("identifier", 7);
{LLSTATE llstate_1;
if (!llterm(T_value, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "value";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("identifier");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("identifier", 1);
return 1;
failed1: LLDEBUG_LEAVE("identifier", 0);
return 0;
}

int ll_ucsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ucsymbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ucsymbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_ocsymbol(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ucsymbol", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_uppercase_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ucsymbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ucsymbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("ucsymbol", 0);
return 0;
}

int ll_ocsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ocsymbol");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ocsymbol", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_only_uppercase_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ocsymbol", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_only_uppercase_digits_symbol, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ocsymbol", 3);
{LLSTATE llstate_1;
if (!llterm(T_MACRO, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "MACRO";
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ocsymbol", 4);
{LLSTATE llstate_1;
if (!llterm(T_NOTATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "NOTATION";
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("ocsymbol", 5);
{LLSTATE llstate_1;
if (!llterm(T_TYPE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "TYPE";
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("ocsymbol", 6);
{LLSTATE llstate_1;
if (!llterm(T_VALUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = "VALUE";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ocsymbol");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ocsymbol", 1);
return 1;
failed1: LLDEBUG_LEAVE("ocsymbol", 0);
return 0;
}

int ll_astring(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("astring");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed1;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{uint32_t i, len;
	    len = str32len(llatt_1);
	    (*llret) = (char *)malloc(len + 1);
	    for (i = 0; i <= len; i++)
		(*llret)[i] = (char)(llatt_1[i]);
	
}}
LLDEBUG_LEAVE("astring", 1);
return 1;
failed1: LLDEBUG_LEAVE("astring", 0);
return 0;
}

int ll_DefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Externaltypereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedType", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedType(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("DefinedType", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedValueSetType(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedType", 0);
return 0;
}

int ll_TypeAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XPrivateDirectives llatt_4;
if (!ll_PrivateDirectives(&llatt_4, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{PropagatePrivateDirectives(llatt_3, llatt_4);
	    if (!AssignType(&(*llout).Assignments, llatt_1, llatt_3))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
		((*llout).Assignments)->eDefTagType = g_eDefTagType;
	
}}}}}
LLDEBUG_LEAVE("TypeAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeAssignment", 0);
return 0;
}

int ll_ValueSetTypeAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetTypeAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_typereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XValueSet llatt_4;
if (!ll_ValueSet(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{Type_t *type;
	    type = GetTypeOfValueSet((*llout).Assignments, llatt_4);
	    if (!AssignType(&(*llout).Assignments, llatt_1, type))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}}
LLDEBUG_LEAVE("ValueSetTypeAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetTypeAssignment", 0);
return 0;
}

int ll_ValueSet(XValueSet *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, NULL, 0)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewValueSet();
	    (*llret)->Elements = llatt_2;
	    (*llret)->Type = llarg_type;
	
}}}}
LLDEBUG_LEAVE("ValueSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSet", 0);
return 0;
}

int ll_Type(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Type");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirectiveESeq(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_UndirectivedType(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XDirectives llatt_3;
if (!ll_LocalTypeDirectiveESeq(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Directive_t **dd, *d;
	    if (llatt_1 || llatt_3) {
		(*llret) = DupType(llatt_2);
		dd = &(*llret)->Directives;
		for (d = llatt_1; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_3; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = llatt_2->Directives;
	    } else {
		(*llret) = llatt_2;
	    }
	
}}}}
LLDEBUG_LEAVE("Type", 1);
return 1;
failed1: LLDEBUG_LEAVE("Type", 0);
return 0;
}

int ll_UndirectivedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UndirectivedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UndirectivedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UntaggedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UndirectivedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TaggedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UndirectivedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UndirectivedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UndirectivedType", 0);
return 0;
}

int ll_UntaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UntaggedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UntaggedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ConstrainableType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UntaggedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SequenceOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("UntaggedType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SetOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("UntaggedType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TypeWithConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UntaggedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UntaggedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UntaggedType", 0);
return 0;
}

int ll_ConstrainableType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ConstrainableType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ConstrainableType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BuiltinType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint_ESeq(&llatt_4, &llstate_3, &llstate_4, llatt_1)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalTypeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
*llout = llstate_6;
{Directive_t *d, **dd;
	    if (llatt_2 || llatt_4 || llatt_5) {
		(*llret) = DupType(llatt_1);
		IntersectConstraints(&(*llret)->Constraints,
		    llatt_1->Constraints, llatt_4);
		dd = &(*llret)->Directives;
		for (d = llatt_2; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_5; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = NULL;
	    } else {
		(*llret) = (llatt_3 || llatt_6) ? DupType(llatt_1) : llatt_1;
	    }
	    PropagatePrivateDirectives((*llret), llatt_3);
	    PropagatePrivateDirectives((*llret), llatt_6);
	
break;
}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ConstrainableType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ReferencedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint_ESeq(&llatt_4, &llstate_3, &llstate_4, llatt_1)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalTypeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
*llout = llstate_6;
{Directive_t *d, **dd;
	    if (llatt_2 || llatt_4 || llatt_5) {
		(*llret) = DupType(llatt_1);
		IntersectConstraints(&(*llret)->Constraints,
		    llatt_1->Constraints, llatt_4);
		dd = &(*llret)->Directives;
		for (d = llatt_2; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		for (d = llatt_5; d; d = d->Next) {
		    *dd = DupDirective(d);
		    dd = &(*dd)->Next;
		}
		*dd = NULL;
	    } else {
		(*llret) = (llatt_3 || llatt_6) ? DupType(llatt_1) : llatt_1;
	    }
	    PropagatePrivateDirectives((*llret), llatt_3);
	    PropagatePrivateDirectives((*llret), llatt_6);
	
break;
}}}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ConstrainableType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ConstrainableType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ConstrainableType", 0);
return 0;
}

int ll_Constraint_ESeq(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Constraint_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Constraint_ESeq", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed2;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		IntersectConstraints(&(*llret), llatt_1, llatt_2);
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Constraint_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Constraint_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Constraint_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("Constraint_ESeq", 0);
return 0;
}

int ll_BuiltinType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BuiltinType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BuiltinType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BitStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BuiltinType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_BooleanType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BuiltinType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_CharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BuiltinType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ChoiceType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("BuiltinType", 5);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_EmbeddedPDVType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("BuiltinType", 6);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_EnumeratedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("BuiltinType", 7);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ExternalType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("BuiltinType", 8);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_InstanceOfType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("BuiltinType", 9);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_IntegerType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("BuiltinType", 10);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_NullType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("BuiltinType", 11);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ObjectClassFieldType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("BuiltinType", 12);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_ObjectIdentifierType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("BuiltinType", 13);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_OctetStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("BuiltinType", 14);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UTF8StringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("BuiltinType", 15);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_RealType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("BuiltinType", 16);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SequenceType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("BuiltinType", 17);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SetType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("BuiltinType", 18);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_AnyType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("BuiltinType", 19);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_MacroDefinedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BuiltinType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BuiltinType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BuiltinType", 0);
return 0;
}

int ll_ReferencedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_DefinedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UsefulType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ReferencedType", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_SelectionType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ReferencedType", 4);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_TypeFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("ReferencedType", 5);
{LLSTATE llstate_1;XValueSet llatt_1;
if (!ll_ValueSetFromObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = GetTypeOfValueSet((*llout).Assignments, llatt_1);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedType", 0);
return 0;
}

int ll_NamedType(XNamedType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedType", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewNamedType(llatt_2->PrivateDirectives.pszFieldName ? llatt_2->PrivateDirectives.pszFieldName : llatt_1, llatt_2);
	    llatt_2->PrivateDirectives.pszFieldName = NULL;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedType", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Type_t *type;
	    type = NewType(eType_Selection);
	    type->U.Selection.Type = llatt_3;
	    type->U.Selection.Identifier = llatt_1;
	    (*llret) = NewNamedType(llatt_3->PrivateDirectives.pszFieldName ? llatt_3->PrivateDirectives.pszFieldName : llatt_1, type);
	    llatt_3->PrivateDirectives.pszFieldName = NULL;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedType", 0);
return 0;
}

int ll_BooleanType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BooleanType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_BOOLEAN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Boolean;
	
}}
LLDEBUG_LEAVE("BooleanType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BooleanType", 0);
return 0;
}

int ll_IntegerType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntegerType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntegerType", 1);
{LLSTATE llstate_1;
if (!llterm(T_INTEGER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedNumberList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{NamedNumber_t *n, *m;
	    for (n = llatt_3; n && n->Next; n = n->Next) {
		for (m = n->Next; m; m = m->Next) {
		    if (n->Type == eNamedNumber_Normal &&
			m->Type == eNamedNumber_Normal) {
			if (!strcmp(n->U.Normal.Identifier,
			    m->U.Normal.Identifier))
			    LLFAILED((&llstate_3.pos,
				"identifier `%s' has been assigned twice",
				n->U.Normal.Identifier));
			if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			    GetValue((*llout).Assignments, m->U.Normal.Value) &&
			    GetTypeType((*llout).Assignments,
			    GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			    == eType_Integer &&
			    GetTypeType((*llout).Assignments,
			    GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			    == eType_Integer &&
			    !intx_cmp(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value,
			    &GetValue((*llout).Assignments,
			    m->U.Normal.Value)->U.Integer.Value))
			    LLFAILED((&llstate_3.pos,
				"value `%d' has been assigned twice",
				intx2int32(&GetValue((*llout).Assignments,
				n->U.Normal.Value)->U.Integer.Value)));
		    }
		}
	    }
	    (*llret) = NewType(eType_Integer);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Integer.NamedNumbers = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntegerType", 2);
{LLSTATE llstate_1;
if (!llterm(T_INTEGER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewType(eType_Integer);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntegerType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntegerType", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntegerType", 0);
return 0;
}

int ll_NamedNumberList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedNumberList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedNumberList", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedNumberList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedNumberList", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedNumberList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedNumberList", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedNumberList", 0);
return 0;
}

int ll_NamedNumber(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedNumber", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_SignedNumber(&llatt_3, &llstate_2, &llstate_3, Builtin_Type_Integer)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedNumber", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_DefinedValue(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_3);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Undefined &&
		    GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
		    LLFAILED((&llstate_3.pos, "Bad type of value"));
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		    intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		    LLFAILED((&llstate_3.pos, "Bad value"));
	    }
	    (*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedNumber", 0);
return 0;
}

int ll_EnumeratedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumeratedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_ENUMERATED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_Enumerations(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{NamedNumber_t **nn, *n, *m;
	    intx_t *ix;
	    uint32_t num = 0;
	    (*llret) = NewType(eType_Enumerated);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    for (n = llatt_3; n; n = n->Next)
		if (n->Type == eNamedNumber_Normal)
		    KeepEnumNames(n->U.Normal.Identifier); // global conflict check
	    for (n = llatt_3; n && n->Next; n = n->Next) {
		if (n->Type != eNamedNumber_Normal)
		    continue;
		for (m = n->Next; m; m = m->Next) {
		    if (m->Type != eNamedNumber_Normal)
			continue;
		    if (!strcmp(n->U.Normal.Identifier,
			m->U.Normal.Identifier))
			LLFAILED((&llstate_3.pos,
			    "identifier `%s' has been assigned twice",
			    n->U.Normal.Identifier));
		    if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			GetValue((*llout).Assignments, m->U.Normal.Value) &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			== eType_Integer &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			== eType_Integer &&
			!intx_cmp(&GetValue((*llout).Assignments,
			n->U.Normal.Value)->U.Integer.Value,
			&GetValue((*llout).Assignments,
			m->U.Normal.Value)->U.Integer.Value))
			LLFAILED((&llstate_3.pos,
			    "value `%d' has been assigned twice",
			    intx2int32(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value)));
		}
	    }
	    nn = &(*llret)->U.Enumerated.NamedNumbers;
	    for (n = llatt_3; n; n = n->Next) {
		*nn = DupNamedNumber(n);
		switch (n->Type) {
		case eNamedNumber_Normal:
		    if (n->U.Normal.Value)
			break;
		    for (;; num++) {
			for (m = llatt_3; m; m = m->Next) {
			    switch (m->Type) {
			    case eNamedNumber_Normal:
				if (!m->U.Normal.Value)
				    continue;
				ix = &GetValue((*llout).Assignments,
				    m->U.Normal.Value)->U.Integer.Value;
				if (!intxisuint32(ix) ||
				    intx2uint32(ix) != num)
				    continue;
				break;
			    default:
				continue;
			    }
			    break;
			}
			if (!m)
			    break;
		    }
		    (*nn)->U.Normal.Value = NewValue(NULL,
			Builtin_Type_Integer);
		    intx_setuint32(
			&(*nn)->U.Normal.Value->U.Integer.Value,
		    	num++);
		    break;
		case eNamedNumber_ExtensionMarker:
		    break;
		}
		nn = &(*nn)->Next;
	    }
	    *nn = NULL;
	
}}}}}
LLDEBUG_LEAVE("EnumeratedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumeratedType", 0);
return 0;
}

int ll_Enumerations(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Enumerations");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_Enumeration(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedNumbers llatt_2;
if (!ll_EnumerationExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{NamedNumber_t **nn, *n;
	    nn = &(*llret);
	    for (n = llatt_1; n; n = n->Next) {
		*nn = DupNamedNumber(n);
		nn = &(*nn)->Next;
	    }
	    *nn = llatt_2;
	
}}}
LLDEBUG_LEAVE("Enumerations", 1);
return 1;
failed1: LLDEBUG_LEAVE("Enumerations", 0);
return 0;
}

int ll_EnumerationExtension(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumerationExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XNamedNumbers llatt_4;
if (!ll_Enumeration(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_ExtensionMarker);
	    (*llret)->Next = llatt_4;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 2);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewNamedNumber(eNamedNumber_ExtensionMarker);
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("EnumerationExtension", 3);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("EnumerationExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("EnumerationExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumerationExtension", 0);
return 0;
}

int ll_Enumeration(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Enumeration");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Enumeration", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_EnumerationItem(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_Enumeration(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Enumeration", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_EnumerationItem(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Enumeration");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Enumeration", 1);
return 1;
failed1: LLDEBUG_LEAVE("Enumeration", 0);
return 0;
}

int ll_EnumerationItem(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumerationItem");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("EnumerationItem", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("EnumerationItem", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedNumber(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("EnumerationItem");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("EnumerationItem", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumerationItem", 0);
return 0;
}

int ll_RealType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RealType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_REAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Real;
	
}}
LLDEBUG_LEAVE("RealType", 1);
return 1;
failed1: LLDEBUG_LEAVE("RealType", 0);
return 0;
}

int ll_BitStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BitStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BitStringType", 1);
{LLSTATE llstate_1;
if (!llterm(T_BIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('{', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XNamedNumbers llatt_4;
if (!ll_NamedBitList(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed2;
*llout = llstate_5;
{NamedNumber_t *n, *m;
	    (*llret) = NewType(eType_BitString);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.BitString.NamedNumbers = llatt_4;
	    for (n = llatt_4; n; n = n->Next)
	        KeepEnumNames(n->U.Normal.Identifier); // global conflict check
	    for (n = llatt_4; n && n->Next; n = n->Next) {
		for (m = n->Next; m; m = m->Next) {
		    if (!strcmp(n->U.Normal.Identifier,
			m->U.Normal.Identifier))
			LLFAILED((&llstate_4.pos,
			    "identifier `%s' has been assigned twice",
			    n->U.Normal.Identifier));
		    if (GetValue((*llout).Assignments, n->U.Normal.Value) &&
			GetValue((*llout).Assignments, m->U.Normal.Value) &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, n->U.Normal.Value)->Type)
			== eType_Integer &&
			GetTypeType((*llout).Assignments,
			GetValue((*llout).Assignments, m->U.Normal.Value)->Type)
			== eType_Integer &&
			!intx_cmp(&GetValue((*llout).Assignments,
			n->U.Normal.Value)->U.Integer.Value,
			&GetValue((*llout).Assignments,
			m->U.Normal.Value)->U.Integer.Value))
			LLFAILED((&llstate_4.pos,
			    "value `%u' has been assigned twice",
			    intx2uint32(&GetValue((*llout).Assignments,
			    n->U.Normal.Value)->U.Integer.Value)));
		}
	    }
	
break;
}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BitStringType", 2);
{LLSTATE llstate_1;
if (!llterm(T_BIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewType(eType_BitString);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BitStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BitStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("BitStringType", 0);
return 0;
}

int ll_NamedBitList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedBitList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedBitList", 1);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedBit(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedNumbers llatt_3;
if (!ll_NamedBitList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = DupNamedNumber(llatt_1);
	    (*llret)->Next = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedBitList", 2);
{LLSTATE llstate_1;XNamedNumbers llatt_1;
if (!ll_NamedBit(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedBitList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedBitList", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedBitList", 0);
return 0;
}

int ll_NamedBit(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedBit");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NamedBit", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNumber llatt_3;
if (!llterm(T_number, &lllval, &llstate_2, &llstate_3)) goto failed2;
llatt_3 = lllval._XNumber;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = NewValue(NULL, Builtin_Type_Integer);
	    (*llret)->U.Normal.Value->U.Integer.Value = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NamedBit", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_DefinedValue(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_3);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) != eType_Undefined &&
		    GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
		    LLFAILED((&llstate_3.pos, "Bad type of value"));
		if (GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		    intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		    LLFAILED((&llstate_3.pos, "Bad value"));
	    }
	    (*llret) = NewNamedNumber(eNamedNumber_Normal);
	    (*llret)->U.Normal.Identifier = llatt_1;
	    (*llret)->U.Normal.Value = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NamedBit");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NamedBit", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedBit", 0);
return 0;
}

int ll_OctetStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OctetStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_OCTET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_OctetString;
	
}}}
LLDEBUG_LEAVE("OctetStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("OctetStringType", 0);
return 0;
}

int ll_UTF8StringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UTF8StringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_UTF8String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_UTF8String;
	
}}
LLDEBUG_LEAVE("UTF8StringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UTF8StringType", 0);
return 0;
}

int ll_NullType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NullType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_NULL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_Null;
	
}}
LLDEBUG_LEAVE("NullType", 1);
return 1;
failed1: LLDEBUG_LEAVE("NullType", 0);
return 0;
}

int ll_SequenceType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceType", 1);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Component_t *c, *d; int fExtended = 0;
	    for (c = llatt_3; c; c = c->Next)
		if (c->Type == eComponent_Optional || c->Type == eComponent_Default || fExtended)
		    KeepOptNames(c->U.NOD.NamedType->Identifier); // global conflict check
		else
		if (c->Type == eComponent_ExtensionMarker)
		    fExtended = 1;
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Sequence);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Sequence.Components = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceType", 2);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewType(eType_Sequence);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceType", 0);
return 0;
}

int ll_ExtensionAndException(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtensionAndException");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtensionAndException", 1);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ExceptionSpec(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_ExtensionMarker);
	    /*(*llret)->U.ExtensionMarker.ExceptionSpec = llatt_2;*/
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtensionAndException", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewComponent(eComponent_ExtensionMarker);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtensionAndException");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtensionAndException", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtensionAndException", 0);
return 0;
}

int ll_ExtendedComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtendedComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExtendedComponentTypeList", 1);
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ComponentTypeList(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypeListExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExtendedComponentTypeList", 2);
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ExtensionAndException(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExtendedComponentTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExtendedComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtendedComponentTypeList", 0);
return 0;
}

int ll_ComponentTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypeListExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentTypeListExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ExtensionAndException(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_AdditionalComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t **cc, *c;
	    if (llatt_3) {
		cc = &(*llret);
		for (c = llatt_2; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_3;
	    } else {
		(*llret) = llatt_2;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentTypeListExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentTypeListExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentTypeListExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypeListExtension", 0);
return 0;
}

int ll_AdditionalComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalComponentTypeList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalComponentTypeList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalComponentTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalComponentTypeList", 0);
return 0;
}

int ll_ComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_ComponentType(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalComponentTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupComponent(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ComponentTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypeList", 0);
return 0;
}

int ll_ComponentType(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentType", 1);
{LLSTATE llstate_1;XNamedType llatt_1;
if (!ll_NamedType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ComponentTypePostfix(&llatt_2, &llstate_1, &llstate_2, llatt_1->Type)) goto failed2;
*llout = llstate_2;
{(*llret) = DupComponent(llatt_2);
	    (*llret)->U.NOD.NamedType = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentType", 2);
{LLSTATE llstate_1;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewComponent(eComponent_ComponentsOf);
	    (*llret)->U.ComponentsOf.Type = llatt_3;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentType", 0);
return 0;
}

int ll_ComponentTypePostfix(XComponents *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentTypePostfix");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewComponent(eComponent_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_Default);
	    (*llret)->U.Default.Value = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ComponentTypePostfix", 3);
*llout = llstate_0;
{(*llret) = NewComponent(eComponent_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentTypePostfix");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentTypePostfix", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentTypePostfix", 0);
return 0;
}

int ll_SequenceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XType llatt_5;
if (!ll_Type(&llatt_5, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.SequenceOf.Type = llatt_5;
	    (*llret)->U.SequenceOf.Directives = llatt_2;
	    if (llatt_3)
	    {
	        PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
}}}}}}
LLDEBUG_LEAVE("SequenceOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceOfType", 0);
return 0;
}

int ll_SetType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetType", 1);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedComponentTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Component_t *c, *d;
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Set);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Set.Components = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetType", 2);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewType(eType_Set);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetType", 0);
return 0;
}

int ll_SetOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XType llatt_5;
if (!ll_Type(&llatt_5, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.SetOf.Type = llatt_5;
	    (*llret)->U.SetOf.Directives = llatt_2;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
}}}}}}
LLDEBUG_LEAVE("SetOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetOfType", 0);
return 0;
}

int ll_ChoiceType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ChoiceType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CHOICE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_ExtendedAlternativeTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{Component_t *c, *d;
	    for (c = llatt_3; c; c = c->Next)
		if (c->Type == eComponent_Normal ||
		    c->Type == eComponent_Optional ||
		    c->Type == eComponent_Default)
		    KeepChoiceNames(c->U.NOD.NamedType->Identifier); // global conflict check
	    for (c = llatt_3; c && c->Next; c = c->Next) {
		if (c->Type != eComponent_Normal &&
		    c->Type != eComponent_Optional &&
		    c->Type != eComponent_Default)
		    continue;
		for (d = c->Next; d; d = d->Next) {
		    if (d->Type != eComponent_Normal &&
			d->Type != eComponent_Optional &&
			d->Type != eComponent_Default)
			continue;
		    if (!strcmp(c->U.NOD.NamedType->Identifier,
			d->U.NOD.NamedType->Identifier))
			LLFAILED((&llstate_3.pos, "Component `%s' has been used twice",
			    c->U.NOD.NamedType->Identifier));
		}
	    }
	    (*llret) = NewType(eType_Choice);
	    (*llret)->TagDefault = (*llout).TagDefault;
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->U.Choice.Components = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("ChoiceType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ChoiceType", 0);
return 0;
}

int ll_ExtendedAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExtendedAlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XComponents llatt_1;
if (!ll_AlternativeTypeList(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AlternativeTypeListExtension(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{Component_t **cc, *c;
	    if (llatt_2) {
		cc = &(*llret);
		for (c = llatt_1; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ExtendedAlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExtendedAlternativeTypeList", 0);
return 0;
}

int ll_AlternativeTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AlternativeTypeListExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AlternativeTypeListExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_ExtensionAndException(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XComponents llatt_3;
if (!ll_AdditionalAlternativeTypeList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t **cc, *c;
	    if (llatt_3) {
		cc = &(*llret);
		for (c = llatt_2; c; c = c->Next) {
		    *cc = DupComponent(c);
		    cc = &(*cc)->Next;
		}
		*cc = llatt_3;
	    } else {
		(*llret) = llatt_2;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AlternativeTypeListExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AlternativeTypeListExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AlternativeTypeListExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("AlternativeTypeListExtension", 0);
return 0;
}

int ll_AdditionalAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalAlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalAlternativeTypeList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AlternativeTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalAlternativeTypeList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalAlternativeTypeList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalAlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalAlternativeTypeList", 0);
return 0;
}

int ll_AlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AlternativeTypeList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedType llatt_1;
if (!ll_NamedType(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XComponents llatt_2;
if (!ll_AdditionalAlternativeTypeList(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewComponent(eComponent_Normal);
	    (*llret)->U.Normal.NamedType = llatt_1;
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("AlternativeTypeList", 1);
return 1;
failed1: LLDEBUG_LEAVE("AlternativeTypeList", 0);
return 0;
}

int ll_AnyType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AnyType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AnyType", 1);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_Open;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AnyType", 2);
{LLSTATE llstate_1;
if (!llterm(T_ANY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_DEFINED, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(T_BY, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XString llatt_4;
if (!ll_identifier(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{(*llret) = Builtin_Type_Open;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AnyType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AnyType", 1);
return 1;
failed1: LLDEBUG_LEAVE("AnyType", 0);
return 0;
}

int ll_SelectionType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SelectionType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewType(eType_Selection);
	    (*llret)->U.Selection.Identifier = llatt_1;
	    (*llret)->U.Selection.Type = llatt_3;
	
}}}}
LLDEBUG_LEAVE("SelectionType", 1);
return 1;
failed1: LLDEBUG_LEAVE("SelectionType", 0);
return 0;
}

int ll_TaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TaggedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XTags llatt_1;
if (!ll_Tag(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XTagType llatt_2;
if (!ll_TagType(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XType llatt_3;
if (!ll_Type(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Tag_t *t;
	    Type_e eType = GetTypeType((*llout).Assignments, llatt_3);
	    if (eType == eType_Choice || eType == eType_Open)
	    {
	    	if (llatt_2 == eTagType_Unknown &&
	    	    ((*llout).TagDefault == eTagType_Implicit || (*llout).TagDefault == eTagType_Automatic))
	    	{
	    	    llatt_2 = eTagType_Explicit;
	    	}
	    	else
	    	if (llatt_2 == eTagType_Implicit)
	    	{
		    for (t = llatt_3->Tags; t; t = t->Next) {
		        if (t->Type == eTagType_Explicit)
			    break;
		    }
		    if (!t)
		        LLFAILED((&llstate_3.pos, "Bad tag type for choice/open type"));
	        }
	    }
	    (*llret) = DupType(llatt_3);
	    (*llret)->Tags = DupTag(llatt_1);
	    (*llret)->Tags->Type = llatt_2;
	    (*llret)->Tags->Next = llatt_3->Tags;
	
}}}}
LLDEBUG_LEAVE("TaggedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("TaggedType", 0);
return 0;
}

int ll_TagType(XTagType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TagType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TagType", 1);
*llout = llstate_0;
{(*llret) = eTagType_Unknown;
	
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TagType", 2);
{LLSTATE llstate_1;
if (!llterm(T_IMPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagType_Implicit;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TagType", 3);
{LLSTATE llstate_1;
if (!llterm(T_EXPLICIT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagType_Explicit;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TagType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TagType", 1);
return 1;
failed1: LLDEBUG_LEAVE("TagType", 0);
return 0;
}

int ll_Tag(XTags *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Tag");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XTagClass llatt_2;
if (!ll_Class(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_ClassNumber(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(']', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = NewTag(eTagType_Unknown);
	    (*llret)->Class = llatt_2;
	    (*llret)->Tag = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("Tag", 1);
return 1;
failed1: LLDEBUG_LEAVE("Tag", 0);
return 0;
}

int ll_ClassNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ClassNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ClassNumber", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{if (intx_cmp(&llatt_1, &intx_1G) >= 0)
		LLFAILED((&llstate_1.pos, "Bad tag value"));
	    (*llret) = NewValue(NULL, Builtin_Type_Integer);
	    (*llret)->U.Integer.Value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ClassNumber", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_1);
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Undefined)
		LLFAILED((&llstate_1.pos, "Bad type of tag value"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		(intx_cmp(&v->U.Integer.Value, &intx_0) < 0 ||
		intx_cmp(&v->U.Integer.Value, &intx_1G) >= 0))
		LLFAILED((&llstate_1.pos, "Bad tag value"));
	    (*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ClassNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ClassNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("ClassNumber", 0);
return 0;
}

int ll_Class(XTagClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Class");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Class", 1);
{LLSTATE llstate_1;
if (!llterm(T_UNIVERSAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Universal;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Class", 2);
{LLSTATE llstate_1;
if (!llterm(T_APPLICATION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Application;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Class", 3);
{LLSTATE llstate_1;
if (!llterm(T_PRIVATE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = eTagClass_Private;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Class", 4);
*llout = llstate_0;
{(*llret) = eTagClass_Unknown;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Class");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Class", 1);
return 1;
failed1: LLDEBUG_LEAVE("Class", 0);
return 0;
}

int ll_ObjectIdentifierType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectIdentifierType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_OBJECT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_IDENTIFIER, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_ObjectIdentifier;
	
}}}
LLDEBUG_LEAVE("ObjectIdentifierType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectIdentifierType", 0);
return 0;
}

int ll_EmbeddedPDVType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EmbeddedPDVType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EMBEDDED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_PDV, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_EmbeddedPdv;
	
}}}
LLDEBUG_LEAVE("EmbeddedPDVType", 1);
return 1;
failed1: LLDEBUG_LEAVE("EmbeddedPDVType", 0);
return 0;
}

int ll_ExternalType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EXTERNAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = Builtin_Type_External;
	
}}
LLDEBUG_LEAVE("ExternalType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalType", 0);
return 0;
}

int ll_CharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharacterStringType", 1);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_RestrictedCharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharacterStringType", 2);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_UnrestrictedCharacterStringType(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharacterStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringType", 0);
return 0;
}

int ll_RestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RestrictedCharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 1);
{LLSTATE llstate_1;
if (!llterm(T_BMPString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_BMPString;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 2);
{LLSTATE llstate_1;
if (!llterm(T_GeneralString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GeneralString;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 3);
{LLSTATE llstate_1;
if (!llterm(T_GraphicString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GraphicString;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 4);
{LLSTATE llstate_1;
if (!llterm(T_IA5String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_IA5String;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 5);
{LLSTATE llstate_1;
if (!llterm(T_ISO646String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_ISO646String;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 6);
{LLSTATE llstate_1;
if (!llterm(T_NumericString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_NumericString;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 7);
{LLSTATE llstate_1;
if (!llterm(T_PrintableString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_PrintableString;
	
break;
}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 8);
{LLSTATE llstate_1;
if (!llterm(T_TeletexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_TeletexString;
	
break;
}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 9);
{LLSTATE llstate_1;
if (!llterm(T_T61String, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_T61String;
	
break;
}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 10);
{LLSTATE llstate_1;
if (!llterm(T_UniversalString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_UniversalString;
	
break;
}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 11);
{LLSTATE llstate_1;
if (!llterm(T_VideotexString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_VideotexString;
	
break;
}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringType", 12);
{LLSTATE llstate_1;
if (!llterm(T_VisibleString, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_VisibleString;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RestrictedCharacterStringType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RestrictedCharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("RestrictedCharacterStringType", 0);
return 0;
}

int ll_UnrestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnrestrictedCharacterStringType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CHARACTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_STRING, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = Builtin_Type_CharacterString;
	
}}}
LLDEBUG_LEAVE("UnrestrictedCharacterStringType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnrestrictedCharacterStringType", 0);
return 0;
}

int ll_UsefulType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UsefulType");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UsefulType", 1);
{LLSTATE llstate_1;
if (!llterm(T_GeneralizedTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_GeneralizedTime;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UsefulType", 2);
{LLSTATE llstate_1;
if (!llterm(T_UTCTime, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_UTCTime;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("UsefulType", 3);
{LLSTATE llstate_1;
if (!llterm(T_ObjectDescriptor, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_Type_ObjectDescriptor;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UsefulType");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UsefulType", 1);
return 1;
failed1: LLDEBUG_LEAVE("UsefulType", 0);
return 0;
}

int ll_TypeWithConstraint(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeWithConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 1);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint(&llatt_4, &llstate_3, &llstate_4, NULL, 0)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;XType llatt_7;
if (!ll_Type(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
*llout = llstate_7;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = llatt_4;
	    (*llret)->U.SetOf.Type = llatt_7;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    dd = &(*llret)->U.SetOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 2);
{LLSTATE llstate_1;
if (!llterm(T_SET, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XSubtypeElement llatt_4;
if (!ll_SizeConstraint(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;XType llatt_8;
if (!ll_Type(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
*llout = llstate_8;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SetOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = NewConstraint();
	    (*llret)->Constraints->Type = eExtension_Unextended;
	    (*llret)->Constraints->Root = NewElementSetSpec(
		eElementSetSpec_SubtypeElement);
	    (*llret)->Constraints->Root->U.SubtypeElement.SubtypeElement = llatt_4;
	    (*llret)->U.SetOf.Type = llatt_8;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if (llatt_6)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_6);
	    }
	    dd = &(*llret)->U.SetOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 3);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XConstraints llatt_4;
if (!ll_Constraint(&llatt_4, &llstate_3, &llstate_4, NULL, 0)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;XType llatt_7;
if (!ll_Type(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
*llout = llstate_7;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = llatt_4;
	    (*llret)->U.SequenceOf.Type = llatt_7;
	    if (llatt_3)
	    {
		PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    dd = &(*llret)->U.SequenceOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("TypeWithConstraint", 4);
{LLSTATE llstate_1;
if (!llterm(T_SEQUENCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XPrivateDirectives llatt_3;
if (!ll_PrivateDirectives(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;XSubtypeElement llatt_4;
if (!ll_SizeConstraint(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;XDirectives llatt_5;
if (!ll_LocalSizeDirectiveESeq(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;XPrivateDirectives llatt_6;
if (!ll_PrivateDirectives(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;XType llatt_8;
if (!ll_Type(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
*llout = llstate_8;
{Directive_t **dd, *d;
	    (*llret) = NewType(eType_SequenceOf);
	    (*llret)->ExtensionDefault = (*llout).ExtensionDefault;
	    (*llret)->Constraints = NewConstraint();
	    (*llret)->Constraints->Type = eExtension_Unextended;
	    (*llret)->Constraints->Root = NewElementSetSpec(
		eElementSetSpec_SubtypeElement);
	    (*llret)->Constraints->Root->U.SubtypeElement.SubtypeElement = llatt_4;
	    (*llret)->U.SequenceOf.Type = llatt_8;
	    if (llatt_3)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_3);
	    }
	    if (llatt_6)
	    {
	    	PropagatePrivateDirectives((*llret), llatt_6);
	    }
	    dd = &(*llret)->U.SequenceOf.Directives;
	    for (d = llatt_2; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    for (d = llatt_5; d; d = d->Next) {
		*dd = DupDirective(d);
		dd = &(*dd)->Next;
	    }
	    *dd = NULL;
	    if ((*llret)->PrivateDirectives.pszTypeName &&
		strncmp("PSetOf", (*llret)->PrivateDirectives.pszTypeName, 6) == 0)
	    {
		(*llret)->PrivateDirectives.pszTypeName++;
	    }
	
break;
}}}}}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeWithConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeWithConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeWithConstraint", 0);
return 0;
}

int ll_DefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Externalvaluereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_valuereference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedValue", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedValue(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedValue", 0);
return 0;
}

int ll_ValueAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_valuereference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XValue llatt_4;
if (!ll_Value(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{if (!AssignValue(&(*llout).Assignments, llatt_1, llatt_4))
		LLFAILED((&llstate_1.pos, "Value `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}}
LLDEBUG_LEAVE("ValueAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueAssignment", 0);
return 0;
}

int ll_Value(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Value");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Value", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BuiltinValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Value", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ReferencedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Value", 3);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectClassFieldValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Value");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Value", 1);
return 1;
failed1: LLDEBUG_LEAVE("Value", 0);
return 0;
}

int ll_BuiltinValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BuiltinValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BuiltinValue", 1);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_BitString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BitStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BuiltinValue", 2);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Boolean)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BooleanValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BuiltinValue", 3);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BuiltinValue", 4);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Choice)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ChoiceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("BuiltinValue", 5);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_EmbeddedPdv)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_EmbeddedPDVValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("BuiltinValue", 6);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Enumerated)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_EnumeratedValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("BuiltinValue", 7);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_External)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ExternalValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 8: case -8:
LLDEBUG_ALTERNATIVE("BuiltinValue", 8);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_InstanceOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_InstanceOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 9: case -9:
LLDEBUG_ALTERNATIVE("BuiltinValue", 9);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Integer)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IntegerValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 10: case -10:
LLDEBUG_ALTERNATIVE("BuiltinValue", 10);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Null)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_NullValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 11: case -11:
LLDEBUG_ALTERNATIVE("BuiltinValue", 11);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_ObjectIdentifier)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectIdentifierValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
		if (llatt_1->Type != NULL)
		{
			PropagatePrivateDirectives(llatt_1->Type, &(llarg_type->PrivateDirectives));
		}
	
break;
}}}
case 12: case -12:
LLDEBUG_ALTERNATIVE("BuiltinValue", 12);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_OctetString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_OctetStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 13: case -13:
LLDEBUG_ALTERNATIVE("BuiltinValue", 13);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Real)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 14: case -14:
LLDEBUG_ALTERNATIVE("BuiltinValue", 14);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) !=
		eType_GeneralizedTime)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_GeneralizedTimeValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 15: case -15:
LLDEBUG_ALTERNATIVE("BuiltinValue", 15);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_UTCTime)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_UTCTimeValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 16: case -16:
LLDEBUG_ALTERNATIVE("BuiltinValue", 16);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_ObjectDescriptor)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ObjectDescriptorValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 17: case -17:
LLDEBUG_ALTERNATIVE("BuiltinValue", 17);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Sequence)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 18: case -18:
LLDEBUG_ALTERNATIVE("BuiltinValue", 18);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SequenceOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 19: case -19:
LLDEBUG_ALTERNATIVE("BuiltinValue", 19);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Set)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SetValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 20: case -20:
LLDEBUG_ALTERNATIVE("BuiltinValue", 20);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SetOf)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SetOfValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 21: case -21:
LLDEBUG_ALTERNATIVE("BuiltinValue", 21);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Open)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_AnyValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 22: case -22:
LLDEBUG_ALTERNATIVE("BuiltinValue", 22);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Macro)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_MacroDefinedValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BuiltinValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BuiltinValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BuiltinValue", 0);
return 0;
}

int ll_ReferencedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ValueFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedValue", 0);
return 0;
}

int ll_NamedValue(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{Component_t *component;
	    Type_t *type;
	    component = FindComponent((*llin).Assignments, llarg_components, llatt_1);
	    if (component)
		type = component->U.NOD.NamedType->Type;
	    else
		type = NULL;
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, type)) goto failed1;
*llout = llstate_2;
{(*llret) = NewNamedValue(llatt_1, llatt_2);
	
}}}}
LLDEBUG_LEAVE("NamedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedValue", 0);
return 0;
}

int ll_BooleanValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BooleanValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BooleanValue", 1);
{LLSTATE llstate_1;
if (!llterm(T_TRUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Boolean.Value = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BooleanValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_FALSE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Boolean.Value = 0;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BooleanValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BooleanValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BooleanValue", 0);
return 0;
}

int ll_SignedNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SignedNumber");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SignedNumber", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Integer.Value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SignedNumber", 2);
{LLSTATE llstate_1;
if (!llterm('-', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XNumber;
*llout = llstate_2;
{if (!intx_cmp(&llatt_2, &intx_0))
		LLFAILED((&llstate_2.pos, "Bad negative value"));
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    intx_neg(&(*llret)->U.Integer.Value, &llatt_2);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SignedNumber");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SignedNumber", 1);
return 1;
failed1: LLDEBUG_LEAVE("SignedNumber", 0);
return 0;
}

int ll_IntegerValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntegerValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntegerValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SignedNumber(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntegerValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.Integer.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Undefined integer value"));
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		intx_dup(&(*llret)->U.Integer.Value,
		    &n->U.Normal.Value->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntegerValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntegerValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntegerValue", 0);
return 0;
}

int ll_EnumeratedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EnumeratedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.Enumerated.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Undefined enumeration value"));
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.Enumerated.Value =
		    intx2uint32(&n->U.Normal.Value->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
}}
LLDEBUG_LEAVE("EnumeratedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("EnumeratedValue", 0);
return 0;
}

int ll_RealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RealValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_NumericRealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RealValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SpecialRealValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("RealValue", 0);
return 0;
}

int ll_NumericRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NumericRealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NumericRealValue", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{if (intx_cmp(&llatt_1, &intx_0))
		LLFAILED((&llstate_1.pos, "Bad real value"));
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NumericRealValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{NamedValue_t *mant, *expo, *base;
	    mant = FindNamedValue(llatt_1->U.Sequence.NamedValues, "mantissa");
	    expo = FindNamedValue(llatt_1->U.Sequence.NamedValues, "exponent");
	    base = FindNamedValue(llatt_1->U.Sequence.NamedValues, "base");
	    if (!mant || !expo || !base) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		intx_dup(&(*llret)->U.Real.Value.mantissa,
		    &mant->Value->U.Integer.Value);
		intx_dup(&(*llret)->U.Real.Value.exponent,
		    &expo->Value->U.Integer.Value);
		(*llret)->U.Real.Value.base =
		    intx2uint32(&base->Value->U.Integer.Value);
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NumericRealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NumericRealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NumericRealValue", 0);
return 0;
}

int ll_SpecialRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SpecialRealValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SpecialRealValue", 1);
{LLSTATE llstate_1;
if (!llterm(T_PLUS_INFINITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Real.Value.type = eReal_PlusInfinity;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SpecialRealValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MINUS_INFINITY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Real.Value.type = eReal_MinusInfinity;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SpecialRealValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SpecialRealValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SpecialRealValue", 0);
return 0;
}

int ll_BitStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("BitStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("BitStringValue", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_bstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_BitString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.BitString.Value.length = len;
		(*llret)->U.BitString.Value.value =
		    (octet_t *)malloc((len + 7) / 8);
		memset((*llret)->U.BitString.Value.value, 0, (len + 7) / 8);
		for (i = 0; i < len; i++) {
		    if (llatt_1[i] == '1')
			ASN1BITSET((*llret)->U.BitString.Value.value, i);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("BitStringValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_hstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len, c;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_BitString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.BitString.Value.length = len * 4;
		(*llret)->U.BitString.Value.value =
		    (octet_t *)malloc((len + 1) / 2);
		memset((*llret)->U.BitString.Value.value, 0, (len + 1) / 2);
		for (i = 0; i < len; i++) {
		    c = isdigit(llatt_1[i]) ? llatt_1[i] - '0' : llatt_1[i] - 'A' + 10;
		    (*llret)->U.BitString.Value.value[i / 2] |=
			(i & 1) ? c : (c << 4);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("BitStringValue", 3);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_IdentifierList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("BitStringValue", 4);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("BitStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("BitStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("BitStringValue", 0);
return 0;
}

int ll_IdentifierList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IdentifierList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IdentifierList_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Identifier_EList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
*llout = llstate_2;
{uint32_t bit, len;
	    bitstring_t *src, *dst;
	    if (llatt_1 && llatt_2) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		src = &llatt_2->U.BitString.Value;
		len = bit + 1;
		if (len < src->length)
		    len = src->length;
		(*llret) = DupValue(llatt_2);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memcpy(dst->value, src->value, (src->length + 7) / 8);
		memset(dst->value + (src->length + 7) / 8, 0,
		    (len + 7) / 8 - (src->length + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else if (llatt_1) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		len = bit + 1;
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memset(dst->value, 0, (len + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else {
		(*llret) = NULL;
	    }
	
}}}
LLDEBUG_LEAVE("IdentifierList", 1);
return 1;
failed1: LLDEBUG_LEAVE("IdentifierList", 0);
return 0;
}

int ll_Identifier_EList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Identifier_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Identifier_EList", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_IdentifierList_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Identifier_EList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{uint32_t bit, len;
	    bitstring_t *src, *dst;
	    if (llatt_1 && llatt_2) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		src = &llatt_2->U.BitString.Value;
		len = bit + 1;
		if (len < src->length)
		    len = src->length;
		(*llret) = DupValue(llatt_2);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memcpy(dst->value, src->value, (src->length + 7) / 8);
		memset(dst->value + (src->length + 7) / 8, 0,
		    (len + 7) / 8 - (src->length + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else if (llatt_1) {
		bit = intx2uint32(&llatt_1->U.Integer.Value);
		len = bit + 1;
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		dst = &(*llret)->U.BitString.Value;
		dst->length = len;
		dst->value = (octet_t *)malloc((len + 7) / 8);
		memset(dst->value, 0, (len + 7) / 8);
		ASN1BITSET(dst->value, bit);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Identifier_EList", 2);
*llout = llstate_0;
{if (llarg_type) {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Identifier_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Identifier_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("Identifier_EList", 0);
return 0;
}

int ll_IdentifierList_Elem(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IdentifierList_Elem");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{Value_t *v;
	    NamedNumber_t *n;
	    Type_t *type;
	    type = GetType((*llout).Assignments, llarg_type);
	    if (type) {
		n = FindNamedNumber(type->U.BitString.NamedNumbers, llatt_1);
		if (!n)
		    LLFAILED((&llstate_1.pos, "Bad bit string value"));
		v = GetValue((*llout).Assignments, n->U.Normal.Value);
		if (v) {
		    if (GetTypeType((*llout).Assignments, v->Type) != eType_Integer)
			MyAbort();
		    (*llret) = v;
		} else {
		    (*llret) = NULL;
		}
	    } else {
		(*llret) = NULL;
	    }
	
}}
LLDEBUG_LEAVE("IdentifierList_Elem", 1);
return 1;
failed1: LLDEBUG_LEAVE("IdentifierList_Elem", 0);
return 0;
}

int ll_OctetStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OctetStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("OctetStringValue", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_bstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int len, i;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_OctetString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.OctetString.Value.length = (len + 7) / 8;
		(*llret)->U.OctetString.Value.value =
		    (octet_t *)malloc((len + 7) / 8);
		memset((*llret)->U.OctetString.Value.value, 0, (len + 7) / 8);
		for (i = 0; i < len; i++) {
		    if (llatt_1[i] == '1')
			ASN1BITSET((*llret)->U.OctetString.Value.value, i);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("OctetStringValue", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!llterm(T_hstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString;
*llout = llstate_1;
{int i, len, c;
	    if (GetTypeType((*llout).Assignments, llarg_type) == eType_OctetString) {
		len = strlen(llatt_1);
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.OctetString.Value.length = (len + 1) / 2;
		(*llret)->U.OctetString.Value.value =
		    (octet_t *)malloc((len + 1) / 2);
		memset((*llret)->U.OctetString.Value.value, 0, (len + 1) / 2);
		for (i = 0; i < len; i++) {
		    c = isdigit(llatt_1[i]) ?  llatt_1[i] - '0' : llatt_1[i] - 'A' + 10;
		    (*llret)->U.OctetString.Value.value[i / 2] |=
			(i & 1) ? c : (c << 4);
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("OctetStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("OctetStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("OctetStringValue", 0);
return 0;
}

int ll_NullValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NullValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_NULL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
}}
LLDEBUG_LEAVE("NullValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("NullValue", 0);
return 0;
}

int ll_GeneralizedTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GeneralizedTimeValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    if (!String2GeneralizedTime(&(*llret)->U.GeneralizedTime.Value,
		&llatt_1->U.RestrictedString.Value))
		LLFAILED((&llstate_1.pos, "Bad time value"));
	
}}
LLDEBUG_LEAVE("GeneralizedTimeValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("GeneralizedTimeValue", 0);
return 0;
}

int ll_UTCTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UTCTimeValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    if (!String2UTCTime(&(*llret)->U.UTCTime.Value,
		&llatt_1->U.RestrictedString.Value))
		LLFAILED((&llstate_1.pos, "Bad time value"));
	
}}
LLDEBUG_LEAVE("UTCTimeValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UTCTimeValue", 0);
return 0;
}

int ll_ObjectDescriptorValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectDescriptorValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("ObjectDescriptorValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectDescriptorValue", 0);
return 0;
}

int ll_SequenceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Component_t *components;
	    Type_t *type;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    components = type ? type->U.SSC.Components : NULL;
	
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, components)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t *c;
	    NamedValue_t *v;
	    if (type) {
		for (c = components, v = llatt_2; c; c = c->Next) {
		    switch (c->Type) {
		    case eComponent_Normal:
			if (!v)
			    LLFAILED((&llstate_2.pos,
				"Value for component `%s' is missing",
				c->U.NOD.NamedType->Identifier));
			if (strcmp(v->Identifier,
			    c->U.NOD.NamedType->Identifier))
			    LLFAILED((&llstate_2.pos, "Value for component `%s' expected",
				c->U.NOD.NamedType->Identifier));
			v = v->Next;
			break;
		    case eComponent_Optional:
		    case eComponent_Default:
			if (v && !strcmp(v->Identifier,
			    c->U.NOD.NamedType->Identifier))
			    v = v->Next;
			break;
		    }
		}
		if (v)
		    LLFAILED((&llstate_2.pos, "Component `%s' is unexpected",
			v->Identifier));
	    }
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SSC.NamedValues = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceValue", 0);
return 0;
}

int ll_ComponentValueList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentValueList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedValues llatt_1;
if (!ll_NamedValue(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed1;
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueCList(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupNamedValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("ComponentValueList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentValueList", 0);
return 0;
}

int ll_ComponentValueCList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentValueCList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ComponentValueCList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ComponentValueCList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ComponentValueCList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ComponentValueCList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentValueCList", 0);
return 0;
}

int ll_SequenceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SequenceOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SequenceOfValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Type_t *type, *subtype;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    subtype = (type ? type->U.SS.Type : NULL);
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, subtype)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SequenceOf.Values = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SequenceOfValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SequenceOfValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SequenceOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SequenceOfValue", 0);
return 0;
}

int ll_ValueList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueCList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
*llout = llstate_2;
{(*llret) = DupValue(llatt_1);
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("ValueList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueList", 0);
return 0;
}

int ll_ValueCList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueCList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueCList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueCList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueCList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueCList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueCList", 0);
return 0;
}

int ll_SetValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Component_t *components;
	    Type_t *type;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    components = type ? type->U.SSC.Components : NULL;
	
{LLSTATE llstate_2;XNamedValues llatt_2;
if (!ll_ComponentValueList(&llatt_2, &llstate_1, &llstate_2, components)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{Component_t *c;
	    NamedValue_t *v;
	    if (type) {
		for (c = components; c; c = c->Next) {
		    switch (c->Type) {
		    case eComponent_Normal:
			v = FindNamedValue(llatt_2, c->U.NOD.NamedType->Identifier);
			if (!v)
			    LLFAILED((&llstate_2.pos,
				"Value for component `%s' is missing",
				c->U.NOD.NamedType->Identifier));
			break;
		    }
		}
		for (v = llatt_2; v; v = v->Next) {
		    if (!FindComponent((*llout).Assignments, components,
			v->Identifier) ||
			FindNamedValue(v->Next, v->Identifier))
			LLFAILED((&llstate_2.pos, "Component `%s' is unexpected",
			    v->Identifier));
		}
	    }
	    (*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.Set.NamedValues = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetValue", 0);
return 0;
}

int ll_SetOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SetOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SetOfValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{Type_t *type, *subtype;
	    type = GetType(llstate_1.Assignments, llarg_type);
	    subtype = (type ? type->U.SS.Type : NULL);
	
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_ValueList(&llatt_2, &llstate_1, &llstate_2, subtype)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SetOf.Values = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SetOfValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('}', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SetOfValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SetOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SetOfValue", 0);
return 0;
}

int ll_ChoiceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ChoiceValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Component_t *component;
	    Type_t *type, *subtype;
	    type = GetType(llstate_2.Assignments, llarg_type);
	    if (type) {
		component = FindComponent(llstate_2.Assignments,
		    type->U.Choice.Components, llatt_1);
		if (!component)
		    LLFAILED((&llstate_1.pos, "Bad alternative `%s'", llatt_1));
		subtype = component->U.NOD.NamedType->Type;
	    } else {
		subtype = NULL;
	    }
	
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, subtype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.SSC.NamedValues = NewNamedValue(llatt_1, llatt_3);
	
}}}}}
LLDEBUG_LEAVE("ChoiceValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ChoiceValue", 0);
return 0;
}

int ll_ObjectIdentifierValue(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectIdentifierValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectIdentifierValue", 1);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponentList(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{switch (GetAssignedObjectIdentifier(
		&(*llout).AssignedObjIds, NULL, llatt_2, &(*llret))) {
	    case -1:
		LLFAILED((&llstate_2.pos, "Different numbers for equally named object identifier components"));
		/*NOTREACHED*/
	    case 0:
		if (pass <= 2)
		    (*llret) = NULL;
		else
		    LLFAILED((&llstate_2.pos, "Unknown object identifier component"));
		break;
	    case 1:
		break;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectIdentifierValue", 2);
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_DefinedValue(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedObjIdValue llatt_3;
if (!ll_ObjIdComponentList(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed2;
*llout = llstate_4;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_2);
	    if (v) {
		if (GetTypeType((*llout).Assignments, v->Type) !=
		    eType_ObjectIdentifier &&
		    GetTypeType((*llout).Assignments, v->Type) !=
		    eType_Undefined)
		    LLFAILED((&llstate_2.pos, "Bad type of value in object identifier"));
		if (GetTypeType((*llout).Assignments, v->Type) ==
		    eType_ObjectIdentifier) {
		    switch (GetAssignedObjectIdentifier(
			&(*llout).AssignedObjIds, v, llatt_3, &(*llret))) {
		    case -1:
			LLFAILED((&llstate_3.pos, "Different numbers for equally named object identifier components"));
			/*NOTREACHED*/
		    case 0:
			if (pass <= 2)
			    (*llret) = NULL;
			else
			    LLFAILED((&llstate_2.pos, "Unknown object identifier component"));
			break;
		    case 1:
			break;
		    }
		}
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectIdentifierValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectIdentifierValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectIdentifierValue", 0);
return 0;
}

int ll_ObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponentList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_ObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponent_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_1) {
		(*llret) = DupNamedObjIdValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = NULL;
	    }
	
}}}
LLDEBUG_LEAVE("ObjIdComponentList", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponentList", 0);
return 0;
}

int ll_ObjIdComponent_ESeq(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponent_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjIdComponent_ESeq", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_ObjIdComponent(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XNamedObjIdValue llatt_2;
if (!ll_ObjIdComponent_ESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_1) {
		(*llret) = DupNamedObjIdValue(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjIdComponent_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjIdComponent_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjIdComponent_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponent_ESeq", 0);
return 0;
}

int ll_ObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjIdComponent");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 1);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 2);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjIdComponent", 3);
{LLSTATE llstate_1;XNamedObjIdValue llatt_1;
if (!ll_NameAndNumberForm(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjIdComponent");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjIdComponent", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjIdComponent", 0);
return 0;
}

int ll_NameForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NameForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameForm);
	    (*llret)->Name = llatt_1;
	
}}
LLDEBUG_LEAVE("NameForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NameForm", 0);
return 0;
}

int ll_NumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("NumberForm", 1);
{LLSTATE llstate_1;XNumber llatt_1;
if (!llterm(T_number, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XNumber;
*llout = llstate_1;
{(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
	    (*llret)->Number = intx2uint32(&llatt_1);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("NumberForm", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{Value_t *v;
	    v = GetValue((*llout).Assignments, llatt_1);
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Integer &&
		GetTypeType((*llout).Assignments, v->Type) != eType_Undefined)
		LLFAILED((&llstate_1.pos, "Bad type in object identifier"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer &&
		intx_cmp(&v->U.Integer.Value, &intx_0) < 0)
		LLFAILED((&llstate_1.pos, "Bad value in object identifier"));
	    if (v &&
		GetTypeType((*llout).Assignments, v->Type) == eType_Integer) {
		(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NumberForm);
		(*llret)->Number = intx2uint32(&v->U.Integer.Value);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("NumberForm");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("NumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NumberForm", 0);
return 0;
}

int ll_NameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NameAndNumberForm");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('(', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XNamedObjIdValue llatt_3;
if (!ll_NumberForm(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{if (llatt_3) {
		(*llret) = NewNamedObjIdValue(eNamedObjIdValue_NameAndNumberForm);
		(*llret)->Name = llatt_1;
		(*llret)->Number = llatt_3->Number;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("NameAndNumberForm", 1);
return 1;
failed1: LLDEBUG_LEAVE("NameAndNumberForm", 0);
return 0;
}

int ll_EmbeddedPDVValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("EmbeddedPDVValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("EmbeddedPDVValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("EmbeddedPDVValue", 0);
return 0;
}

int ll_ExternalValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExternalValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("ExternalValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExternalValue", 0);
return 0;
}

int ll_CharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharacterStringValue", 1);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined && !IsRestrictedString(type))
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_RestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharacterStringValue", 2);
{if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad type of value"));
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_UnrestrictedCharacterStringValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharacterStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringValue", 0);
return 0;
}

int ll_RestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RestrictedCharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 1);
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = str32len(llatt_1);
	    (*llret)->U.RestrictedString.Value.value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharacterStringList(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 3);
{LLSTATE llstate_1;XQuadruple llatt_1;
if (!ll_Quadruple(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = 1;
	    (*llret)->U.RestrictedString.Value.value =
		(char32_t *)malloc(sizeof(char32_t));
	    (*llret)->U.RestrictedString.Value.value[0] =
		256 * (256 * (256 * llatt_1.Group + llatt_1.Plane) + llatt_1.Row) + llatt_1.Cell;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("RestrictedCharacterStringValue", 4);
{LLSTATE llstate_1;XTuple llatt_1;
if (!ll_Tuple(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = 1;
	    (*llret)->U.RestrictedString.Value.value =
		(char32_t *)malloc(sizeof(char32_t));
	    *(*llret)->U.RestrictedString.Value.value =
		llatt_1.Column * 16 + llatt_1.Row;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RestrictedCharacterStringValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RestrictedCharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("RestrictedCharacterStringValue", 0);
return 0;
}

int ll_UnrestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnrestrictedCharacterStringValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("UnrestrictedCharacterStringValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnrestrictedCharacterStringValue", 0);
return 0;
}

int ll_CharacterStringList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharacterStringList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_CharSyms(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("CharacterStringList", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharacterStringList", 0);
return 0;
}

int ll_CharSyms(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharSyms");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharSyms", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharDefn(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharSyms", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_CharDefn(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_CharSyms(&llatt_3, &llstate_2, &llstate_3, llarg_type)) goto failed2;
*llout = llstate_3;
{if (!llatt_1 || !llatt_3) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewValue((*llout).Assignments, llarg_type);
		(*llret)->U.RestrictedString.Value.length =
		    llatt_1->U.RestrictedString.Value.length +
		    llatt_3->U.RestrictedString.Value.length;
		(*llret)->U.RestrictedString.Value.value =
		    (char32_t *)malloc(
		    (*llret)->U.RestrictedString.Value.length *
		    sizeof(char32_t));
		memcpy((*llret)->U.RestrictedString.Value.value,
		    llatt_1->U.RestrictedString.Value.value,
		    llatt_1->U.RestrictedString.Value.length *
		    sizeof(char32_t));
		memcpy((*llret)->U.RestrictedString.Value.value +
		    llatt_1->U.RestrictedString.Value.length,
		    llatt_3->U.RestrictedString.Value.value,
		    llatt_3->U.RestrictedString.Value.length *
		    sizeof(char32_t));
	    }
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharSyms");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharSyms", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharSyms", 0);
return 0;
}

int ll_CharDefn(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("CharDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("CharDefn", 1);
{LLSTATE llstate_1;XString32 llatt_1;
if (!llterm(T_cstring, &lllval, &llstate_0, &llstate_1)) goto failed2;
llatt_1 = lllval._XString32;
*llout = llstate_1;
{(*llret) = NewValue((*llout).Assignments, llarg_type);
	    (*llret)->U.RestrictedString.Value.length = str32len(llatt_1);
	    (*llret)->U.RestrictedString.Value.value = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("CharDefn", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("CharDefn");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("CharDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("CharDefn", 0);
return 0;
}

int ll_Quadruple(XQuadruple *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Quadruple");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed1;
llatt_2 = lllval._XNumber;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNumber llatt_4;
if (!llterm(T_number, &lllval, &llstate_3, &llstate_4)) goto failed1;
llatt_4 = lllval._XNumber;
{LLSTATE llstate_5;
if (!llterm(',', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
{LLSTATE llstate_6;XNumber llatt_6;
if (!llterm(T_number, &lllval, &llstate_5, &llstate_6)) goto failed1;
llatt_6 = lllval._XNumber;
{LLSTATE llstate_7;
if (!llterm(',', (LLSTYPE *)0, &llstate_6, &llstate_7)) goto failed1;
{LLSTATE llstate_8;XNumber llatt_8;
if (!llterm(T_number, &lllval, &llstate_7, &llstate_8)) goto failed1;
llatt_8 = lllval._XNumber;
{LLSTATE llstate_9;
if (!llterm('}', (LLSTYPE *)0, &llstate_8, &llstate_9)) goto failed1;
*llout = llstate_9;
{(*llret).Group = intx2uint32(&llatt_2);
	    (*llret).Plane = intx2uint32(&llatt_4);
	    (*llret).Row = intx2uint32(&llatt_6);
	    (*llret).Cell = intx2uint32(&llatt_8);
	
}}}}}}}}}}
LLDEBUG_LEAVE("Quadruple", 1);
return 1;
failed1: LLDEBUG_LEAVE("Quadruple", 0);
return 0;
}

int ll_Tuple(XTuple *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Tuple");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNumber llatt_2;
if (!llterm(T_number, &lllval, &llstate_1, &llstate_2)) goto failed1;
llatt_2 = lllval._XNumber;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNumber llatt_4;
if (!llterm(T_number, &lllval, &llstate_3, &llstate_4)) goto failed1;
llatt_4 = lllval._XNumber;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret).Column = intx2uint32(&llatt_2);
	    (*llret).Row = intx2uint32(&llatt_4);
	
}}}}}}
LLDEBUG_LEAVE("Tuple", 1);
return 1;
failed1: LLDEBUG_LEAVE("Tuple", 0);
return 0;
}

int ll_AnyValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AnyValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_3;
	
}}}}
LLDEBUG_LEAVE("AnyValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("AnyValue", 0);
return 0;
}

int ll_Constraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Constraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_ConstraintSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed1;
{LLSTATE llstate_3;
if (!ll_ExceptionSpec(&llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;
if (!llterm(')', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
*llout = llstate_4;
{(*llret) = llatt_2; /*XXX ExceptionSpec */
	
}}}}}
LLDEBUG_LEAVE("Constraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("Constraint", 0);
return 0;
}

int ll_ConstraintSpec(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ConstraintSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ConstraintSpec", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_SubtypeConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ConstraintSpec", 2);
{LLSTATE llstate_1;
if (!ll_GeneralConstraint(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NULL; /*XXX*/
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ConstraintSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ConstraintSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ConstraintSpec", 0);
return 0;
}

int ll_SubtypeConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SubtypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_ElementSetSpecs(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("SubtypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SubtypeConstraint", 0);
return 0;
}

int ll_ExceptionSpec(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExceptionSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExceptionSpec", 1);
{LLSTATE llstate_1;
if (!llterm('!', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!ll_ExceptionIdentification(&llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExceptionSpec", 2);
*llout = llstate_0;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExceptionSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExceptionSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExceptionSpec", 0);
return 0;
}

int ll_ExceptionIdentification(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ExceptionIdentification");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SignedNumber(&llatt_1, &llstate_0, &llstate_1, Builtin_Type_Integer)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_DefinedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ExceptionIdentification", 3);
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed2;
*llout = llstate_3;
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ExceptionIdentification");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ExceptionIdentification", 1);
return 1;
failed1: LLDEBUG_LEAVE("ExceptionIdentification", 0);
return 0;
}

int ll_ElementSetSpecs(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpecs");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpecs", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_ElementSetSpec(&llatt_1, &llstate_0, &llstate_1, llarg_type, NULL, llarg_permalpha)) goto failed2;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_ElementSetSpecExtension(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupConstraint(llatt_2);
	    } else {
		(*llret) = NewConstraint();
	    }
	    (*llret)->Root = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpecs", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_AdditionalElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = NewConstraint();
	    (*llret)->Type = llatt_2 ? eExtension_Extended : eExtension_Extendable;
	    (*llret)->Additional = llatt_2;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpecs");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpecs", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpecs", 0);
return 0;
}

int ll_ElementSetSpecExtension(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpecExtension");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpecExtension", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XElementSetSpec llatt_3;
if (!ll_AdditionalElementSetSpec(&llatt_3, &llstate_2, &llstate_3, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_3;
{(*llret) = NewConstraint();
	    (*llret)->Type = llatt_3 ? eExtension_Extended : eExtension_Extendable;
	    (*llret)->Additional = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpecExtension", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpecExtension");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpecExtension", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpecExtension", 0);
return 0;
}

int ll_AdditionalElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("AdditionalElementSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("AdditionalElementSetSpec", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, NULL, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("AdditionalElementSetSpec", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("AdditionalElementSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("AdditionalElementSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("AdditionalElementSetSpec", 0);
return 0;
}

int ll_ElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ElementSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ElementSetSpec", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Unions(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ElementSetSpec", 2);
{LLSTATE llstate_1;
if (!llterm(T_ALL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Exclusions(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = NewElementSetSpec(eElementSetSpec_AllExcept);
	    (*llret)->U.AllExcept.Elements = llatt_2;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ElementSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ElementSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ElementSetSpec", 0);
return 0;
}

int ll_Unions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Unions");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Intersections(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_UnionList(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Union);
		(*llret)->U.Union.Elements1 = llatt_1;
		(*llret)->U.Union.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("Unions", 1);
return 1;
failed1: LLDEBUG_LEAVE("Unions", 0);
return 0;
}

int ll_UnionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnionList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UnionList", 1);
{LLSTATE llstate_1;
if (!ll_UnionMark(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Unions(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UnionList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UnionList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UnionList", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnionList", 0);
return 0;
}

int ll_Intersections(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Intersections");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_IntersectionElements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_IntersectionList(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Intersection);
		(*llret)->U.Intersection.Elements1 = llatt_1;
		(*llret)->U.Intersection.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("Intersections", 1);
return 1;
failed1: LLDEBUG_LEAVE("Intersections", 0);
return 0;
}

int ll_IntersectionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntersectionList", 1);
{LLSTATE llstate_1;
if (!ll_IntersectionMark(&llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Intersections(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntersectionList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntersectionList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntersectionList", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionList", 0);
return 0;
}

int ll_IntersectionElements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Elements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Exclusions_Opt(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = NewElementSetSpec(eElementSetSpec_Exclusion);
		(*llret)->U.Exclusion.Elements1 = llatt_1;
		(*llret)->U.Exclusion.Elements2 = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("IntersectionElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionElements", 0);
return 0;
}

int ll_Exclusions_Opt(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exclusions_Opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Exclusions_Opt", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_Exclusions(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Exclusions_Opt", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Exclusions_Opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Exclusions_Opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exclusions_Opt", 0);
return 0;
}

int ll_Exclusions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Exclusions");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_EXCEPT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_Elements(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	
}}}
LLDEBUG_LEAVE("Exclusions", 1);
return 1;
failed1: LLDEBUG_LEAVE("Exclusions", 0);
return 0;
}

int ll_UnionMark(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UnionMark");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UnionMark", 1);
{LLSTATE llstate_1;
if (!llterm('|', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UnionMark", 2);
{LLSTATE llstate_1;
if (!llterm(T_UNION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UnionMark");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UnionMark", 1);
return 1;
failed1: LLDEBUG_LEAVE("UnionMark", 0);
return 0;
}

int ll_IntersectionMark(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("IntersectionMark");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("IntersectionMark", 1);
{LLSTATE llstate_1;
if (!llterm('^', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
case 2: case -2:
LLDEBUG_ALTERNATIVE("IntersectionMark", 2);
{LLSTATE llstate_1;
if (!llterm(T_INTERSECTION, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("IntersectionMark");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("IntersectionMark", 1);
return 1;
failed1: LLDEBUG_LEAVE("IntersectionMark", 0);
return 0;
}

int ll_Elements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Elements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Elements", 1);
{if (llarg_objectclass)
		LLFAILED((&llstate_0.pos, "Bad object set"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SubtypeElements(&llatt_1, &llstate_0, &llstate_1, llarg_type, llarg_permalpha)) goto failed2;
*llout = llstate_1;
{(*llret) = NewElementSetSpec(eElementSetSpec_SubtypeElement);
	    (*llret)->U.SubtypeElement.SubtypeElement = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Elements", 2);
{if (llarg_type)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XObjectSetElement llatt_1;
if (!ll_ObjectSetElements(&llatt_1, &llstate_0, &llstate_1, llarg_objectclass)) goto failed2;
*llout = llstate_1;
{(*llret) = NewElementSetSpec(eElementSetSpec_ObjectSetElement);
	    (*llret)->U.ObjectSetElement.ObjectSetElement = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Elements", 3);
{LLSTATE llstate_1;
if (!llterm('(', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XElementSetSpec llatt_2;
if (!ll_ElementSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_type, llarg_objectclass, llarg_permalpha)) goto failed2;
{LLSTATE llstate_3;
if (!llterm(')', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_2;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Elements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Elements", 1);
return 1;
failed1: LLDEBUG_LEAVE("Elements", 0);
return 0;
}

int ll_SubtypeElements(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SubtypeElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("SubtypeElements", 1);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type == eType_Open)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SingleValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("SubtypeElements", 2);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type == eType_EmbeddedPdv ||
		type == eType_External ||
		type == eType_Open ||
		type == eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_ContainedSubtype(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("SubtypeElements", 3);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (llarg_permalpha ?
		(type != eType_Undefined &&
		type != eType_BMPString &&
		type != eType_IA5String &&
		type != eType_NumericString &&
		type != eType_PrintableString &&
		type != eType_VisibleString &&
		type != eType_UniversalString) :
		(type != eType_Undefined &&
		type != eType_Integer &&
		type != eType_Real))
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_ValueRange(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("SubtypeElements", 4);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		!IsRestrictedString(type) ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_PermittedAlphabet(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("SubtypeElements", 5);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_BitString &&
		type != eType_OctetString &&
		type != eType_UTF8String &&
		type != eType_SequenceOf &&
		type != eType_SetOf &&
		type != eType_CharacterString &&
		!IsRestrictedString(type) ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_SizeConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("SubtypeElements", 6);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_Open ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_TypeConstraint(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("SubtypeElements", 7);
{Type_e type;
	    type = GetTypeType((*llin).Assignments, llarg_type);
	    if (type != eType_Undefined &&
		type != eType_Choice &&
		type != eType_EmbeddedPdv &&
		type != eType_External &&
		type != eType_InstanceOf &&
		type != eType_Real &&
		type != eType_Sequence &&
		type != eType_SequenceOf &&
		type != eType_Set &&
		type != eType_SetOf &&
		type != eType_CharacterString ||
		llarg_permalpha)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_InnerTypeConstraints(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("SubtypeElements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("SubtypeElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("SubtypeElements", 0);
return 0;
}

int ll_SingleValue(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SingleValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_SingleValue);
	    (*llret)->U.SingleValue.Value = llatt_1;
	
}}
LLDEBUG_LEAVE("SingleValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("SingleValue", 0);
return 0;
}

int ll_ContainedSubtype(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ContainedSubtype");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XBoolean llatt_1;
if (!ll_Includes(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (GetTypeType((*llout).Assignments, llatt_2) == eType_Null && !llatt_1)
		LLFAILED((&llstate_1.pos, "Bad constraint"));
	    if (GetTypeType((*llout).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llout).Assignments, llatt_2) != eType_Undefined &&
		GetTypeType((*llout).Assignments, llarg_type) !=
		GetTypeType((*llout).Assignments, llatt_2) &&
		GetTypeType((*llout).Assignments, llarg_type) != eType_Open &&
		GetTypeType((*llout).Assignments, llatt_2) != eType_Open &&
		(!IsRestrictedString(GetTypeType((*llout).Assignments, llarg_type)) ||
		!IsRestrictedString(GetTypeType((*llout).Assignments, llatt_2))))
		LLFAILED((&llstate_2.pos, "Bad type of contained-subtype-constraint"));
	    (*llret) = NewSubtypeElement(eSubtypeElement_ContainedSubtype);
	    (*llret)->U.ContainedSubtype.Type = llatt_2;
	
}}}
LLDEBUG_LEAVE("ContainedSubtype", 1);
return 1;
failed1: LLDEBUG_LEAVE("ContainedSubtype", 0);
return 0;
}

int ll_Includes(XBoolean *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Includes");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Includes", 1);
{LLSTATE llstate_1;
if (!llterm(T_INCLUDES, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Includes", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Includes");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Includes", 1);
return 1;
failed1: LLDEBUG_LEAVE("Includes", 0);
return 0;
}

int ll_ValueRange(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueRange");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndpoint(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XEndPoint llatt_3;
if (!ll_UpperEndpoint(&llatt_3, &llstate_2, &llstate_3, llarg_type)) goto failed1;
*llout = llstate_3;
{if (!llarg_type) {
		(*llret) = NULL;
	    } else {
		(*llret) = NewSubtypeElement(eSubtypeElement_ValueRange);
		(*llret)->U.ValueRange.Lower = llatt_1;
		(*llret)->U.ValueRange.Upper = llatt_3;
	    }
	
}}}}
LLDEBUG_LEAVE("ValueRange", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueRange", 0);
return 0;
}

int ll_LowerEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LowerEndpoint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LowerEndpoint", 1);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('<', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_1;
	    (*llret).Flags |= eEndPoint_Open;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LowerEndpoint", 2);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_LowerEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LowerEndpoint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LowerEndpoint", 1);
return 1;
failed1: LLDEBUG_LEAVE("LowerEndpoint", 0);
return 0;
}

int ll_UpperEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UpperEndpoint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UpperEndpoint", 1);
{LLSTATE llstate_1;
if (!llterm('<', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XEndPoint llatt_2;
if (!ll_UpperEndValue(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = llatt_2;
	    (*llret).Flags |= eEndPoint_Open;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UpperEndpoint", 2);
{LLSTATE llstate_1;XEndPoint llatt_1;
if (!ll_UpperEndValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UpperEndpoint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UpperEndpoint", 1);
return 1;
failed1: LLDEBUG_LEAVE("UpperEndpoint", 0);
return 0;
}

int ll_LowerEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LowerEndValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LowerEndValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret).Value = llatt_1;
	    (*llret).Flags = 0;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LowerEndValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MIN, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret).Value = NULL;
	    (*llret).Flags = eEndPoint_Min;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LowerEndValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LowerEndValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("LowerEndValue", 0);
return 0;
}

int ll_UpperEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UpperEndValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UpperEndValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret).Value = llatt_1;
	    (*llret).Flags = 0;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UpperEndValue", 2);
{LLSTATE llstate_1;
if (!llterm(T_MAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret).Value = NULL;
	    (*llret).Flags = eEndPoint_Max;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UpperEndValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UpperEndValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("UpperEndValue", 0);
return 0;
}

int ll_SizeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SizeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_SIZE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint(&llatt_2, &llstate_1, &llstate_2, Builtin_Type_PositiveInteger, 0)) goto failed1;
*llout = llstate_2;
{(*llret) = NewSubtypeElement(eSubtypeElement_Size);
	    (*llret)->U.Size.Constraints = llatt_2;
	
}}}
LLDEBUG_LEAVE("SizeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SizeConstraint", 0);
return 0;
}

int ll_TypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_Type);
	    (*llret)->U.Type.Type = llatt_1;
	
}}
LLDEBUG_LEAVE("TypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeConstraint", 0);
return 0;
}

int ll_PermittedAlphabet(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PermittedAlphabet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_FROM, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XConstraints llatt_2;
if (!ll_Constraint(&llatt_2, &llstate_1, &llstate_2, llarg_type, 1)) goto failed1;
*llout = llstate_2;
{(*llret) = NewSubtypeElement(eSubtypeElement_PermittedAlphabet);
	    (*llret)->U.PermittedAlphabet.Constraints = llatt_2;
	
}}}
LLDEBUG_LEAVE("PermittedAlphabet", 1);
return 1;
failed1: LLDEBUG_LEAVE("PermittedAlphabet", 0);
return 0;
}

int ll_InnerTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InnerTypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("InnerTypeConstraints", 1);
{Type_t *subtype;
	    if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SequenceOf &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_SetOf)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	    if (GetTypeType((*llin).Assignments, llarg_type) == eType_Undefined)
		subtype = NULL;
	    else
		subtype = GetType((*llin).Assignments, llarg_type)->U.SS.Type;
	
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_COMPONENT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSubtypeElement llatt_3;
if (!ll_SingleTypeConstraint(&llatt_3, &llstate_2, &llstate_3, subtype)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("InnerTypeConstraints", 2);
{Component_t *components;
	    if (GetTypeType((*llin).Assignments, llarg_type) != eType_Undefined &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Sequence &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Set &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Choice &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_Real &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_External &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_EmbeddedPdv &&
		GetTypeType((*llin).Assignments, llarg_type) != eType_CharacterString)
		LLFAILED((&llstate_0.pos, "Bad constraint"));
	    if (GetTypeType((*llin).Assignments, llarg_type) == eType_Undefined)
	    	components = NULL;
	    else
		components = GetType((*llin).Assignments, llarg_type)->U.SSC.Components;
	
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_COMPONENTS, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSubtypeElement llatt_3;
if (!ll_MultipleTypeConstraints(&llatt_3, &llstate_2, &llstate_3, components)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("InnerTypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("InnerTypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("InnerTypeConstraints", 0);
return 0;
}

int ll_SingleTypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SingleTypeConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed1;
*llout = llstate_1;
{(*llret) = NewSubtypeElement(eSubtypeElement_SingleType);
	    (*llret)->U.SingleType.Constraints = llatt_1;
	
}}
LLDEBUG_LEAVE("SingleTypeConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("SingleTypeConstraint", 0);
return 0;
}

int ll_MultipleTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MultipleTypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("MultipleTypeConstraints", 1);
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_FullSpecification(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("MultipleTypeConstraints", 2);
{LLSTATE llstate_1;XSubtypeElement llatt_1;
if (!ll_PartialSpecification(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("MultipleTypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("MultipleTypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("MultipleTypeConstraints", 0);
return 0;
}

int ll_FullSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FullSpecification");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XNamedConstraints llatt_2;
if (!ll_TypeConstraints(&llatt_2, &llstate_1, &llstate_2, llarg_components)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewSubtypeElement(eSubtypeElement_FullSpecification);
	    (*llret)->U.FullSpecification.NamedConstraints = llatt_2;
	
}}}}
LLDEBUG_LEAVE("FullSpecification", 1);
return 1;
failed1: LLDEBUG_LEAVE("FullSpecification", 0);
return 0;
}

int ll_PartialSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PartialSpecification");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(',', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XNamedConstraints llatt_4;
if (!ll_TypeConstraints(&llatt_4, &llstate_3, &llstate_4, llarg_components)) goto failed1;
{LLSTATE llstate_5;
if (!llterm('}', (LLSTYPE *)0, &llstate_4, &llstate_5)) goto failed1;
*llout = llstate_5;
{(*llret) = NewSubtypeElement(eSubtypeElement_PartialSpecification);
	    (*llret)->U.PartialSpecification.NamedConstraints = llatt_4;
	
}}}}}}
LLDEBUG_LEAVE("PartialSpecification", 1);
return 1;
failed1: LLDEBUG_LEAVE("PartialSpecification", 0);
return 0;
}

int ll_TypeConstraints(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeConstraints");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeConstraints", 1);
{LLSTATE llstate_1;XNamedConstraints llatt_1;
if (!ll_NamedConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeConstraints", 2);
{LLSTATE llstate_1;XNamedConstraints llatt_1;
if (!ll_NamedConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_components)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(',', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XNamedConstraints llatt_3;
if (!ll_TypeConstraints(&llatt_3, &llstate_2, &llstate_3, llarg_components)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeConstraints");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeConstraints", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeConstraints", 0);
return 0;
}

int ll_NamedConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("NamedConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_identifier(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{Component_t *component;
	    Type_t *type;
	    component = FindComponent(llstate_1.Assignments, llarg_components, llatt_1);
	    type = component ? component->U.NOD.NamedType->Type : NULL;
	
{LLSTATE llstate_2;XNamedConstraints llatt_2;
if (!ll_ComponentConstraint(&llatt_2, &llstate_1, &llstate_2, type)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	    (*llret)->Identifier = llatt_1;
	
}}}}
LLDEBUG_LEAVE("NamedConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("NamedConstraint", 0);
return 0;
}

int ll_ComponentConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ComponentConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_ValueConstraint(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
{LLSTATE llstate_2;XPresence llatt_2;
if (!ll_PresenceConstraint(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewNamedConstraint();
	    (*llret)->Constraint = llatt_1;
	    (*llret)->Presence = llatt_2;
	
}}}
LLDEBUG_LEAVE("ComponentConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("ComponentConstraint", 0);
return 0;
}

int ll_ValueConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueConstraint", 1);
{LLSTATE llstate_1;XConstraints llatt_1;
if (!ll_Constraint(&llatt_1, &llstate_0, &llstate_1, llarg_type, 0)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueConstraint", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueConstraint", 0);
return 0;
}

int ll_PresenceConstraint(XPresence *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PresenceConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 1);
{LLSTATE llstate_1;
if (!llterm(T_PRESENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Present;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSENT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Absent;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 3);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ePresence_Optional;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("PresenceConstraint", 4);
*llout = llstate_0;
{(*llret) = ePresence_Normal;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PresenceConstraint");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PresenceConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("PresenceConstraint", 0);
return 0;
}

int ll_GeneralConstraint(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("GeneralConstraint");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CON_XXX1, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("GeneralConstraint", 1);
return 1;
failed1: LLDEBUG_LEAVE("GeneralConstraint", 0);
return 0;
}

int ll_LocalTypeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirectiveSeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("LocalTypeDirectiveSeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirectiveSeq", 0);
return 0;
}

int ll_LocalTypeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirectiveESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalTypeDirectiveESeq", 1);
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalTypeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalTypeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalTypeDirectiveESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalTypeDirectiveESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalTypeDirectiveESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirectiveESeq", 0);
return 0;
}

int ll_LocalTypeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalTypeDirective");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 1);
{LLSTATE llstate_1;
if (!llterm(T_ZERO_TERMINATED, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_ZeroTerminated);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 2);
{LLSTATE llstate_1;
if (!llterm(T_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_Pointer);
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("LocalTypeDirective", 3);
{LLSTATE llstate_1;
if (!llterm(T_NO_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_NoPointer);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalTypeDirective");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalTypeDirective", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalTypeDirective", 0);
return 0;
}

int ll_LocalSizeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirectiveSeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalSizeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
}}}
LLDEBUG_LEAVE("LocalSizeDirectiveSeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirectiveSeq", 0);
return 0;
}

int ll_LocalSizeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirectiveESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalSizeDirectiveESeq", 1);
{LLSTATE llstate_1;XDirectives llatt_1;
if (!ll_LocalSizeDirective(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XDirectives llatt_2;
if (!ll_LocalSizeDirectiveESeq(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{if (llatt_2) {
		(*llret) = DupDirective(llatt_1);
		(*llret)->Next = llatt_2;
	    } else {
		(*llret) = llatt_1;
	    }
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalSizeDirectiveESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalSizeDirectiveESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalSizeDirectiveESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirectiveESeq", 0);
return 0;
}

int ll_LocalSizeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("LocalSizeDirective");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 1);
{LLSTATE llstate_1;
if (!llterm(T_FIXED_ARRAY, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_FixedArray);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 2);
{LLSTATE llstate_1;
if (!llterm(T_DOUBLY_LINKED_LIST, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_DoublyLinkedList);
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 3);
{LLSTATE llstate_1;
if (!llterm(T_SINGLY_LINKED_LIST, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_SinglyLinkedList);
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("LocalSizeDirective", 4);
{LLSTATE llstate_1;
if (!llterm(T_LENGTH_POINTER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewDirective(eDirective_LengthPointer);
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("LocalSizeDirective");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("LocalSizeDirective", 1);
return 1;
failed1: LLDEBUG_LEAVE("LocalSizeDirective", 0);
return 0;
}

int ll_PrivateDir_Type(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Type");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Type", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_TypeName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Type", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Type");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Type", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Type", 0);
return 0;
}

int ll_PrivateDir_Field(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Field");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Field", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_FieldName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Field", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Field");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Field", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Field", 0);
return 0;
}

int ll_PrivateDir_Value(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Value");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Value", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_ValueName, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XString llatt_2;
if (!llterm(T_lcsymbol, &lllval, &llstate_1, &llstate_2)) goto failed2;
llatt_2 = lllval._XString;
*llout = llstate_2;
{(*llret) = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Value", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Value");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Value", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Value", 0);
return 0;
}

int ll_PrivateDir_Public(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Public");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Public", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Public, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Public", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Public");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Public", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Public", 0);
return 0;
}

int ll_PrivateDir_Intx(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Intx");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Intx", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Intx, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Intx", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Intx");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Intx", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Intx", 0);
return 0;
}

int ll_PrivateDir_LenPtr(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_LenPtr");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_LenPtr", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_LenPtr, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_LenPtr", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_LenPtr");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_LenPtr", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_LenPtr", 0);
return 0;
}

int ll_PrivateDir_Pointer(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Pointer");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Pointer", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Pointer, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Pointer", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Pointer");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Pointer", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Pointer", 0);
return 0;
}

int ll_PrivateDir_Array(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_Array");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_Array", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_Array, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_Array", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_Array");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_Array", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_Array", 0);
return 0;
}

int ll_PrivateDir_NoCode(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_NoCode");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_NoCode", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_NoCode, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_NoCode", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_NoCode");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_NoCode", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_NoCode", 0);
return 0;
}

int ll_PrivateDir_NoMemCopy(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_NoMemCopy");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_NoMemCopy", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_NoMemCopy, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_NoMemCopy", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_NoMemCopy");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_NoMemCopy", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_NoMemCopy", 0);
return 0;
}

int ll_PrivateDir_OidPacked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_OidPacked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_OidPacked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_OidPacked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_OidPacked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_OidPacked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_OidPacked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_OidPacked", 0);
return 0;
}

int ll_PrivateDir_OidArray(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_OidArray");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_OidArray", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_OidArray, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_OidArray", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_OidArray");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_OidArray", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_OidArray", 0);
return 0;
}

int ll_PrivateDir_SLinked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_SLinked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_SLinked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_SLinked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_SLinked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_SLinked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_SLinked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_SLinked", 0);
return 0;
}

int ll_PrivateDir_DLinked(int *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDir_DLinked");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDir_DLinked", 1);
{LLSTATE llstate_1;
if (!llterm(T_PrivateDir_DLinked, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDir_DLinked", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDir_DLinked");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDir_DLinked", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDir_DLinked", 0);
return 0;
}

int ll_PrivateDirectives(XPrivateDirectives *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrivateDirectives");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrivateDirectives", 1);
{LLSTATE llstate_1;int llatt_1;
if (!ll_PrivateDir_Intx(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;int llatt_2;
if (!ll_PrivateDir_LenPtr(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;int llatt_3;
if (!ll_PrivateDir_Pointer(&llatt_3, &llstate_2, &llstate_3)) goto failed2;
{LLSTATE llstate_4;int llatt_4;
if (!ll_PrivateDir_Array(&llatt_4, &llstate_3, &llstate_4)) goto failed2;
{LLSTATE llstate_5;int llatt_5;
if (!ll_PrivateDir_NoCode(&llatt_5, &llstate_4, &llstate_5)) goto failed2;
{LLSTATE llstate_6;int llatt_6;
if (!ll_PrivateDir_NoMemCopy(&llatt_6, &llstate_5, &llstate_6)) goto failed2;
{LLSTATE llstate_7;int llatt_7;
if (!ll_PrivateDir_Public(&llatt_7, &llstate_6, &llstate_7)) goto failed2;
{LLSTATE llstate_8;int llatt_8;
if (!ll_PrivateDir_OidPacked(&llatt_8, &llstate_7, &llstate_8)) goto failed2;
{LLSTATE llstate_9;int llatt_9;
if (!ll_PrivateDir_OidArray(&llatt_9, &llstate_8, &llstate_9)) goto failed2;
{LLSTATE llstate_10;XString llatt_10;
if (!ll_PrivateDir_Type(&llatt_10, &llstate_9, &llstate_10)) goto failed2;
{LLSTATE llstate_11;XString llatt_11;
if (!ll_PrivateDir_Field(&llatt_11, &llstate_10, &llstate_11)) goto failed2;
{LLSTATE llstate_12;XString llatt_12;
if (!ll_PrivateDir_Value(&llatt_12, &llstate_11, &llstate_12)) goto failed2;
{LLSTATE llstate_13;int llatt_13;
if (!ll_PrivateDir_SLinked(&llatt_13, &llstate_12, &llstate_13)) goto failed2;
{LLSTATE llstate_14;int llatt_14;
if (!ll_PrivateDir_DLinked(&llatt_14, &llstate_13, &llstate_14)) goto failed2;
*llout = llstate_14;
{(*llret) = (PrivateDirectives_t *) malloc(sizeof(PrivateDirectives_t));
	    if ((*llret))
	    {
	    	memset((*llret), 0, sizeof(PrivateDirectives_t));
		(*llret)->fIntx = llatt_1;
		(*llret)->fLenPtr = llatt_2;
		(*llret)->fPointer = llatt_3;
   		(*llret)->fArray = llatt_4;
		(*llret)->fNoCode = llatt_5;
		(*llret)->fNoMemCopy = llatt_6;
		(*llret)->fPublic = llatt_7;
		(*llret)->fOidPacked = llatt_8;
		(*llret)->fOidArray = llatt_9 | g_fOidArray;
   		(*llret)->pszTypeName = llatt_10;
   		(*llret)->pszFieldName = llatt_11;
   		(*llret)->pszValueName = llatt_12;
   		(*llret)->fSLinked = llatt_13;
   		(*llret)->fDLinked = llatt_14;
	    }
	
break;
}}}}}}}}}}}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrivateDirectives", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrivateDirectives");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrivateDirectives", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrivateDirectives", 0);
return 0;
}

int ll_DefinedObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 1);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_ExternalObjectClassReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 2);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_objectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedObjectClass", 3);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_Usefulobjectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObjectClass");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObjectClass", 0);
return 0;
}

int ll_DefinedObject(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObject", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ExternalObjectReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObject", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_objectreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObject");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObject", 0);
return 0;
}

int ll_DefinedObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedObjectSet", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ExternalObjectSetReference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedObjectSet", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_objectsetreference(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedObjectSet");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedObjectSet", 0);
return 0;
}

int ll_Usefulobjectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Usefulobjectclassreference");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Usefulobjectclassreference", 1);
{LLSTATE llstate_1;
if (!llterm(T_TYPE_IDENTIFIER, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_ObjectClass_TypeIdentifier;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Usefulobjectclassreference", 2);
{LLSTATE llstate_1;
if (!llterm(T_ABSTRACT_SYNTAX, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = Builtin_ObjectClass_AbstractSyntax;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Usefulobjectclassreference");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Usefulobjectclassreference", 1);
return 1;
failed1: LLDEBUG_LEAVE("Usefulobjectclassreference", 0);
return 0;
}

int ll_ObjectClassAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_objectclassreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XObjectClass llatt_3;
if (!ll_ObjectClass(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{if (!AssignObjectClass(&(*llout).Assignments, llatt_1, llatt_3))
		LLFAILED((&llstate_1.pos, "Type `%s' twice defined",
		    llatt_1->U.Reference.Identifier));
	
}}}}
LLDEBUG_LEAVE("ObjectClassAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassAssignment", 0);
return 0;
}

int ll_ObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectClass", 1);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_DefinedObjectClass(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectClass", 2);
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_ObjectClassDefn(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectClass", 3);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectClass(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectClass");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClass", 0);
return 0;
}

int ll_ObjectClassDefn(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_CLASS, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('{', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XFieldSpecs llatt_3;
if (!ll_FieldSpec_List(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed1;
{LLSTATE llstate_4;
if (!llterm('}', (LLSTYPE *)0, &llstate_3, &llstate_4)) goto failed1;
{LLSTATE llstate_5;XSyntaxSpecs llatt_5;
if (!ll_WithSyntaxSpec_opt(&llatt_5, &llstate_4, &llstate_5, llarg_oc)) goto failed1;
*llout = llstate_5;
{ObjectClass_t *oc;
	    oc = NewObjectClass(eObjectClass_ObjectClass);
	    oc->U.ObjectClass.FieldSpec = llatt_3;
	    oc->U.ObjectClass.SyntaxSpec = llatt_5;
	    (*llret) = oc;
	
}}}}}}
LLDEBUG_LEAVE("ObjectClassDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassDefn", 0);
return 0;
}

int ll_FieldSpec_List(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec_List");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XFieldSpecs llatt_2;
if (!ll_FieldSpec_EList(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
*llout = llstate_2;
{if (llatt_1) {
		if (llatt_2) {
		    (*llret) = DupFieldSpec(llatt_1);
		    (*llret)->Next = llatt_2;
		} else {
		    (*llret) = llatt_1;
		}
	    } else {
		(*llret) = llatt_2;
	    }
	
}}}
LLDEBUG_LEAVE("FieldSpec_List", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec_List", 0);
return 0;
}

int ll_FieldSpec_EList(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSpec_EList", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XFieldSpecs llatt_2;
if (!ll_FieldSpec(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
{LLSTATE llstate_3;XFieldSpecs llatt_3;
if (!ll_FieldSpec_EList(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed2;
*llout = llstate_3;
{if (llatt_2) {
		if (llatt_3) {
		    (*llret) = DupFieldSpec(llatt_2);
		    (*llret)->Next = llatt_3;
		} else {
		    (*llret) = llatt_2;
		}
	    } else {
		(*llret) = llatt_3;
	    }
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSpec_EList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSpec_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSpec_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec_EList", 0);
return 0;
}

int ll_WithSyntaxSpec_opt(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("WithSyntaxSpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("WithSyntaxSpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_WITH, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm(T_SYNTAX, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{LLSTATE llstate_3;XSyntaxSpecs llatt_3;
if (!ll_SyntaxList(&llatt_3, &llstate_2, &llstate_3, llarg_oc)) goto failed2;
*llout = llstate_3;
{(*llret) = llatt_3;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("WithSyntaxSpec_opt", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("WithSyntaxSpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("WithSyntaxSpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("WithSyntaxSpec_opt", 0);
return 0;
}

int ll_FieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSpec", 1);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_TypeFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSpec", 2);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FixedTypeValueFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("FieldSpec", 3);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_VariableTypeValueFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("FieldSpec", 4);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_FixedTypeValueSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("FieldSpec", 5);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_VariableTypeValueSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 6: case -6:
LLDEBUG_ALTERNATIVE("FieldSpec", 6);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_ObjectFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 7: case -7:
LLDEBUG_ALTERNATIVE("FieldSpec", 7);
{LLSTATE llstate_1;XFieldSpecs llatt_1;
if (!ll_ObjectSetFieldSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSpec", 0);
return 0;
}

int ll_TypeFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_typefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XOptionality llatt_2;
if (!ll_TypeOptionalitySpec_opt(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
*llout = llstate_2;
{(*llret) = NewFieldSpec(eFieldSpec_Type);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.Type.Optionality = llatt_2;
	
}}}
LLDEBUG_LEAVE("TypeFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeFieldSpec", 0);
return 0;
}

int ll_TypeOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Type);
	    (*llret)->U.Type = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("TypeOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TypeOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TypeOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeOptionalitySpec_opt", 0);
return 0;
}

int ll_FixedTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeValueFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XBoolean llatt_3;
if (!ll_UNIQUE_opt(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XOptionality llatt_4;
if (!ll_ValueOptionalitySpec_opt(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{if (GetType((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_FixedTypeValue);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.FixedTypeValue.Type = llatt_2;
		(*llret)->U.FixedTypeValue.Unique = llatt_3;
		(*llret)->U.FixedTypeValue.Optionality = llatt_4;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("FixedTypeValueFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeValueFieldSpec", 0);
return 0;
}

int ll_UNIQUE_opt(XBoolean *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("UNIQUE_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("UNIQUE_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_UNIQUE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = 1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("UNIQUE_opt", 2);
*llout = llstate_0;
{(*llret) = 0;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("UNIQUE_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("UNIQUE_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("UNIQUE_opt", 0);
return 0;
}

int ll_ValueOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValue llatt_2;
if (!ll_Value(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Value);
	    (*llret)->U.Value = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ValueOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueOptionalitySpec_opt", 0);
return 0;
}

int ll_VariableTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("VariableTypeValueFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_FieldName(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{Type_t *deftype;
	    FieldSpec_t *fs, *deffs;
	    fs = GetFieldSpecFromObjectClass(llstate_2.Assignments, llarg_oc, llatt_2);
	    deffs = GetFieldSpec(llstate_2.Assignments, fs);
	    if (deffs &&
		deffs->Type == eFieldSpec_Type &&
		deffs->U.Type.Optionality->Type == eOptionality_Default_Type)
		deftype = deffs->U.Type.Optionality->U.Type;
	    else
		deftype = NULL;
	
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, deftype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewFieldSpec(eFieldSpec_VariableTypeValue);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.VariableTypeValue.Fields = llatt_2;
	    (*llret)->U.VariableTypeValue.Optionality = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("VariableTypeValueFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("VariableTypeValueFieldSpec", 0);
return 0;
}

int ll_FixedTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeValueSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XType llatt_2;
if (!ll_Type(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetType((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_FixedTypeValueSet);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.FixedTypeValueSet.Type = llatt_2;
		(*llret)->U.FixedTypeValueSet.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("FixedTypeValueSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeValueSetFieldSpec", 0);
return 0;
}

int ll_ValueSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XValueSet llatt_2;
if (!ll_ValueSet(&llatt_2, &llstate_1, &llstate_2, llarg_type)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_ValueSet);
	    (*llret)->U.ValueSet = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ValueSetOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueSetOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueSetOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetOptionalitySpec_opt", 0);
return 0;
}

int ll_VariableTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("VariableTypeValueSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XStrings llatt_2;
if (!ll_FieldName(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{Type_t *deftype;
	    FieldSpec_t *fs, *deffs;
	    fs = GetFieldSpecFromObjectClass(llstate_2.Assignments, llarg_oc, llatt_2);
	    deffs = GetFieldSpec(llstate_2.Assignments, fs);
	    if (deffs &&
		deffs->Type == eFieldSpec_Type &&
		deffs->U.Type.Optionality->Type == eOptionality_Default_Type)
		deftype = deffs->U.Type.Optionality->U.Type;
	    else
		deftype = NULL;
	
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ValueSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, deftype)) goto failed1;
*llout = llstate_3;
{(*llret) = NewFieldSpec(eFieldSpec_VariableTypeValueSet);
	    (*llret)->Identifier = llatt_1;
	    (*llret)->U.VariableTypeValueSet.Fields = llatt_2;
	    (*llret)->U.VariableTypeValueSet.Optionality = llatt_3;
	
}}}}}
LLDEBUG_LEAVE("VariableTypeValueSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("VariableTypeValueSetFieldSpec", 0);
return 0;
}

int ll_ObjectFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ObjectOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetObjectClass((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_Object);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.Object.ObjectClass = llatt_2;
		(*llret)->U.Object.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectFieldSpec", 0);
return 0;
}

int ll_ObjectOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XObject llatt_2;
if (!ll_Object(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_Object);
	    (*llret)->U.Object = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectOptionalitySpec_opt", 0);
return 0;
}

int ll_ObjectSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetFieldSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XOptionality llatt_3;
if (!ll_ObjectSetOptionalitySpec_opt(&llatt_3, &llstate_2, &llstate_3, llatt_2)) goto failed1;
*llout = llstate_3;
{if (GetObjectClass((*llout).Assignments, llatt_2)) {
		(*llret) = NewFieldSpec(eFieldSpec_ObjectSet);
		(*llret)->Identifier = llatt_1;
		(*llret)->U.ObjectSet.ObjectClass = llatt_2;
		(*llret)->U.ObjectSet.Optionality = llatt_3;
	    } else {
		(*llret) = NULL;
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectSetFieldSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetFieldSpec", 0);
return 0;
}

int ll_ObjectSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetOptionalitySpec_opt");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 1);
{LLSTATE llstate_1;
if (!llterm(T_OPTIONAL, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewOptionality(eOptionality_Optional);
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 2);
{LLSTATE llstate_1;
if (!llterm(T_DEFAULT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XObjectSet llatt_2;
if (!ll_ObjectSet(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = NewOptionality(eOptionality_Default_ObjectSet);
	    (*llret)->U.ObjectSet = llatt_2;
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectSetOptionalitySpec_opt", 3);
*llout = llstate_0;
{(*llret) = NewOptionality(eOptionality_Normal);
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetOptionalitySpec_opt");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetOptionalitySpec_opt", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetOptionalitySpec_opt", 0);
return 0;
}

int ll_PrimitiveFieldName(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("PrimitiveFieldName");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_typefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuefieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 3);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_valuesetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 4);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("PrimitiveFieldName", 5);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("PrimitiveFieldName");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("PrimitiveFieldName", 1);
return 1;
failed1: LLDEBUG_LEAVE("PrimitiveFieldName", 0);
return 0;
}

int ll_FieldName(XStrings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldName");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldName", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{FieldSpec_t *fs;
	    ObjectClass_t *oc;
	    fs = GetObjectClassField(llstate_2.Assignments, llarg_oc, llatt_1);
	    if (fs)
		oc = fs->U.Object.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldName", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_objectsetfieldreference(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{FieldSpec_t *fs;
	    ObjectClass_t *oc;
	    fs = GetObjectClassField(llstate_2.Assignments, llarg_oc, llatt_1);
	    if (fs)
		oc = fs->U.ObjectSet.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	    (*llret)->Next = llatt_3;
	
break;
}}}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("FieldName", 3);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewString();
	    (*llret)->String = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldName");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldName", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldName", 0);
return 0;
}

int ll_SyntaxList(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("SyntaxList");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_Seq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("SyntaxList", 1);
return 1;
failed1: LLDEBUG_LEAVE("SyntaxList", 0);
return 0;
}

int ll_TokenOrGroupSpec_Seq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec_Seq");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_TokenOrGroupSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
*llout = llstate_2;
{(*llret) = DupSyntaxSpec(llatt_1);
	    (*llret)->Next = llatt_2;
	
}}}
LLDEBUG_LEAVE("TokenOrGroupSpec_Seq", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec_Seq", 0);
return 0;
}

int ll_TokenOrGroupSpec_ESeq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec_ESeq", 1);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_TokenOrGroupSpec(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed2;
*llout = llstate_2;
{(*llret) = DupSyntaxSpec(llatt_1);
	    (*llret)->Next = llatt_2;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec_ESeq", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TokenOrGroupSpec_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TokenOrGroupSpec_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec_ESeq", 0);
return 0;
}

int ll_TokenOrGroupSpec(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TokenOrGroupSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec", 1);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_RequiredToken(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("TokenOrGroupSpec", 2);
{LLSTATE llstate_1;XSyntaxSpecs llatt_1;
if (!ll_OptionalGroup(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("TokenOrGroupSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("TokenOrGroupSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("TokenOrGroupSpec", 0);
return 0;
}

int ll_OptionalGroup(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OptionalGroup");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('[', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSyntaxSpecs llatt_2;
if (!ll_TokenOrGroupSpec_Seq(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(']', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Optional);
	    (*llret)->U.Optional.SyntaxSpec = llatt_2;
	
}}}}
LLDEBUG_LEAVE("OptionalGroup", 1);
return 1;
failed1: LLDEBUG_LEAVE("OptionalGroup", 0);
return 0;
}

int ll_RequiredToken(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("RequiredToken");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("RequiredToken", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Literal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Literal);
	    (*llret)->U.Literal.Literal = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("RequiredToken", 2);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSyntaxSpec(eSyntaxSpec_Field);
	    (*llret)->U.Field.Field = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("RequiredToken");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("RequiredToken", 1);
return 1;
failed1: LLDEBUG_LEAVE("RequiredToken", 0);
return 0;
}

int ll_Literal(XString *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Literal");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Literal", 1);
{LLSTATE llstate_1;XString llatt_1;
if (!ll_word(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Literal", 2);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = ",";
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Literal");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Literal", 1);
return 1;
failed1: LLDEBUG_LEAVE("Literal", 0);
return 0;
}

int ll_ObjectAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_objectreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XObject llatt_4;
if (!ll_Object(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{AssignObject(&(*llout).Assignments, llatt_1, llatt_4);
	
}}}}}
LLDEBUG_LEAVE("ObjectAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectAssignment", 0);
return 0;
}

int ll_Object(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Object");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Object", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ObjectDefn(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Object", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ObjectFromObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Object", 3);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Object", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedObject(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Object");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Object", 1);
return 1;
failed1: LLDEBUG_LEAVE("Object", 0);
return 0;
}

int ll_ObjectDefn(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectDefn");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectDefn", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefaultSyntax(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectDefn", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedSyntax(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectDefn");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectDefn", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectDefn", 0);
return 0;
}

int ll_DefaultSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefaultSyntax");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting_EList(&llatt_2, &llstate_1, &llstate_2, llarg_oc, NULL)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewObject(eObject_Object);
	    (*llret)->U.Object.ObjectClass = llarg_oc;
	    (*llret)->U.Object.Settings = llatt_2;
	
}}}}
LLDEBUG_LEAVE("DefaultSyntax", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefaultSyntax", 0);
return 0;
}

int ll_FieldSetting_EList(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting_EList");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSetting_EList", 1);
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_FieldSetting(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_1, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting_EListC(&llatt_2, &llstate_1, &llstate_2, llarg_oc, se)) goto failed2;
*llout = llstate_2;
{for (s = llatt_1, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_2;
	
break;
}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSetting_EList", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSetting_EList");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSetting_EList", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting_EList", 0);
return 0;
}

int ll_FieldSetting_EListC(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting_EListC");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FieldSetting_EListC", 1);
{LLSTATE llstate_1;
if (!llterm(',', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_FieldSetting(&llatt_2, &llstate_1, &llstate_2, llarg_oc, llarg_se)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_2, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_3;XSettings llatt_3;
if (!ll_FieldSetting_EListC(&llatt_3, &llstate_2, &llstate_3, llarg_oc, se)) goto failed2;
*llout = llstate_3;
{for (s = llatt_2, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_3;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FieldSetting_EListC", 2);
*llout = llstate_0;
{(*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FieldSetting_EListC");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FieldSetting_EListC", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting_EListC", 0);
return 0;
}

int ll_FieldSetting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FieldSetting");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XString llatt_1;
if (!ll_PrimitiveFieldName(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_Setting(&llatt_2, &llstate_1, &llstate_2, llarg_oc, llarg_se, llatt_1)) goto failed1;
*llout = llstate_2;
{(*llret) = llatt_2;
	
}}}
LLDEBUG_LEAVE("FieldSetting", 1);
return 1;
failed1: LLDEBUG_LEAVE("FieldSetting", 0);
return 0;
}

int ll_DefinedSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntax");

llstate_0 = *llin;
#undef failed
#define failed failed1
{ObjectClass_t *oc;
	    SyntaxSpec_t *sy;
	    oc = GetObjectClass((*llin).Assignments, llarg_oc);
	    if (oc && !oc->U.ObjectClass.SyntaxSpec)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    sy = oc ? oc->U.ObjectClass.SyntaxSpec : UndefSyntaxSpecs;
	
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc, NULL, sy)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = NewObject(eObject_Object);
	    (*llret)->U.Object.ObjectClass = llarg_oc;
	    (*llret)->U.Object.Settings = llatt_2;
	
}}}}}
LLDEBUG_LEAVE("DefinedSyntax", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntax", 0);
return 0;
}

int ll_DefinedSyntaxToken_ESeq(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken_ESeq");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_ESeq", 1);
{if (!llarg_sy)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy)) goto failed2;
{Setting_t *s, **ss, *se;
	    for (s = llatt_1, ss = &se; s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llarg_se;
	
{LLSTATE llstate_2;XSettings llatt_2;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_2, &llstate_1, &llstate_2, llarg_oc, se, DEFINED(llarg_sy) ? llarg_sy->Next : llarg_sy)) goto failed2;
*llout = llstate_2;
{for (s = llatt_1, ss = &(*llret); s; s = s->Next, ss = &(*ss)->Next)
		*ss = DupSetting(s);
	    *ss = llatt_2;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_ESeq", 2);
*llout = llstate_0;
{if (DEFINED(llarg_sy))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    (*llret) = NULL;
	
break;
}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken_ESeq");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken_ESeq", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken_ESeq", 0);
return 0;
}

int ll_DefinedSyntaxToken(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 1);
{if (!DEFINED(llarg_sy) || llarg_sy->Type != eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken_ESeq(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy->U.Optional.SyntaxSpec)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 2);
*llout = llstate_0;
{if (!DEFINED(llarg_sy) || llarg_sy->Type != eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{(*llret) = NULL;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken", 3);
{if (DEFINED(llarg_sy) && llarg_sy->Type == eSyntaxSpec_Optional)
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_DefinedSyntaxToken_Elem(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, llarg_sy)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken", 0);
return 0;
}

int ll_DefinedSyntaxToken_Elem(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("DefinedSyntaxToken_Elem");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_Elem", 1);
{if (!llarg_sy || (DEFINED(llarg_sy) && llarg_sy->Type != eSyntaxSpec_Literal))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XString llatt_1;
if (!ll_Literal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{if (DEFINED(llarg_sy) && strcmp(llarg_sy->U.Literal.Literal, llatt_1))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	    (*llret) = NULL;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("DefinedSyntaxToken_Elem", 2);
{if (!llarg_sy || (DEFINED(llarg_sy) && llarg_sy->Type != eSyntaxSpec_Field))
		LLFAILED((&llstate_0.pos, "Bad settings"));
	
{LLSTATE llstate_1;XSettings llatt_1;
if (!ll_Setting(&llatt_1, &llstate_0, &llstate_1, llarg_oc, llarg_se, DEFINED(llarg_sy) ? llarg_sy->U.Field.Field : NULL)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("DefinedSyntaxToken_Elem");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("DefinedSyntaxToken_Elem", 1);
return 1;
failed1: LLDEBUG_LEAVE("DefinedSyntaxToken_Elem", 0);
return 0;
}

int ll_Setting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XString llarg_f)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("Setting");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("Setting", 1);
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Type)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_Type);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.Type.Type = llatt_1;
	
break;
}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("Setting", 2);
{Type_t *type;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    Setting_t *se;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_FixedTypeValue) {
		type = fs->U.FixedTypeValue.Type;
	    } else if (fe == eFieldSpec_VariableTypeValue) {
		se = GetSettingFromSettings((*llin).Assignments, llarg_se,
		    fs->U.VariableTypeValue.Fields);
		if (GetSettingType(se) != eSetting_Type &&
		    GetSettingType(se) != eSetting_Undefined)
		    MyAbort();
		if (GetSettingType(se) == eSetting_Type)
		    type = se->U.Type.Type;
		else
		    type = NULL;
	    } else {
		type = NULL;
	    }
	
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_Value(&llatt_1, &llstate_0, &llstate_1, type)) goto failed2;
*llout = llstate_1;
{if (type) {
		(*llret) = NewSetting(eSetting_Value);
		(*llret)->Identifier = llarg_f;
		(*llret)->U.Value.Value = llatt_1;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("Setting", 3);
{Type_t *type;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    Setting_t *se;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_FixedTypeValueSet) {
		type = fs->U.FixedTypeValueSet.Type;
	    } else if (fe == eFieldSpec_VariableTypeValueSet) {
		se = GetSettingFromSettings((*llin).Assignments, llarg_se,
		    fs->U.VariableTypeValueSet.Fields);
		if (GetSettingType(se) != eSetting_Type &&
		    GetSettingType(se) != eSetting_Undefined)
		    MyAbort();
		if (GetSettingType(se) == eSetting_Type)
		    type = se->U.Type.Type;
		else
		    type = NULL;
	    } else {
		type = NULL;
	    }
	
{LLSTATE llstate_1;XValueSet llatt_1;
if (!ll_ValueSet(&llatt_1, &llstate_0, &llstate_1, type)) goto failed2;
*llout = llstate_1;
{if (type) {
		(*llret) = NewSetting(eSetting_ValueSet);
		(*llret)->Identifier = llarg_f;
		(*llret)->U.ValueSet.ValueSet = llatt_1;
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("Setting", 4);
{ObjectClass_t *oc;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_Object)
		oc = fs->U.Object.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_Object(&llatt_1, &llstate_0, &llstate_1, oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_Object);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.Object.Object = llatt_1;
	
break;
}}}
case 5: case -5:
LLDEBUG_ALTERNATIVE("Setting", 5);
{ObjectClass_t *oc;
	    FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetObjectClassField((*llin).Assignments, llarg_oc, llarg_f);
	    fe = GetFieldSpecType((*llin).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_0.pos, "Bad setting"));
	    if (fe == eFieldSpec_ObjectSet)
		oc = fs->U.ObjectSet.ObjectClass;
	    else
		oc = NULL;
	
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ObjectSet(&llatt_1, &llstate_0, &llstate_1, oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewSetting(eSetting_ObjectSet);
	    (*llret)->Identifier = llarg_f;
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("Setting");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("Setting", 1);
return 1;
failed1: LLDEBUG_LEAVE("Setting", 0);
return 0;
}

int ll_ObjectSetAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_objectsetreference(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectClass llatt_2;
if (!ll_DefinedObjectClass(&llatt_2, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;
if (!llterm(T_DEF, (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
{LLSTATE llstate_4;XObjectSet llatt_4;
if (!ll_ObjectSet(&llatt_4, &llstate_3, &llstate_4, llatt_2)) goto failed1;
*llout = llstate_4;
{AssignObjectSet(&(*llout).Assignments, llatt_1, llatt_4);
	
}}}}}
LLDEBUG_LEAVE("ObjectSetAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetAssignment", 0);
return 0;
}

int ll_ObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm('{', (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;XObjectSet llatt_2;
if (!ll_ObjectSetSpec(&llatt_2, &llstate_1, &llstate_2, llarg_oc)) goto failed1;
{LLSTATE llstate_3;
if (!llterm('}', (LLSTYPE *)0, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_2;
	
}}}}
LLDEBUG_LEAVE("ObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSet", 0);
return 0;
}

int ll_ObjectSetSpec(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetSpec");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetSpec", 1);
{LLSTATE llstate_1;XElementSetSpec llatt_1;
if (!ll_ElementSetSpec(&llatt_1, &llstate_0, &llstate_1, NULL, llarg_oc, 0)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSet(eObjectSet_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectClass = llarg_oc;
	    (*llret)->U.ObjectSet.Elements = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetSpec", 2);
{LLSTATE llstate_1;
if (!llterm(T_TDOT, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSet(eObjectSet_ExtensionMarker);
	    (*llret)->U.ExtensionMarker.ObjectClass = llarg_oc;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetSpec");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetSpec", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetSpec", 0);
return 0;
}

int ll_ObjectSetElements(XObjectSetElement *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetElements");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ObjectSetFromObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 2);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_Object(&llatt_1, &llstate_0, &llstate_1, llarg_oc)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_Object);
	    (*llret)->U.Object.Object = llatt_1;
	
break;
}}
case 3: case -3:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 3);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_DefinedObjectSet(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = NewObjectSetElement(eObjectSetElement_ObjectSet);
	    (*llret)->U.ObjectSet.ObjectSet = llatt_1;
	
break;
}}
case 4: case -4:
LLDEBUG_ALTERNATIVE("ObjectSetElements", 4);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectSet(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetElements");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetElements", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetElements", 0);
return 0;
}

int ll_ObjectClassFieldType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassFieldType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObjectClass llatt_1;
if (!ll_DefinedObjectClass(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, llatt_1, llatt_3);
	    if (!fs) {
		(*llret) = NewType(eType_Undefined);
	    } else {
		switch (fs->Type) {
		case eFieldSpec_Type:
		case eFieldSpec_VariableTypeValue:
		case eFieldSpec_VariableTypeValueSet:
		    (*llret) = NewType(eType_Open);
		    break;
		case eFieldSpec_FixedTypeValue:
		    (*llret) = fs->U.FixedTypeValue.Type;
		    break;
		case eFieldSpec_FixedTypeValueSet:
		    (*llret) = fs->U.FixedTypeValueSet.Type;
		    break;
		case eFieldSpec_Object:
		    LLFAILED((&llstate_1.pos, "Object field not permitted"));
		    /*NOTREACHED*/
		case eFieldSpec_ObjectSet:
		    LLFAILED((&llstate_1.pos, "ObjectSet field not permitted"));
		    /*NOTREACHED*/
		default:
		    MyAbort();
		}
	    }
	
}}}}
LLDEBUG_LEAVE("ObjectClassFieldType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassFieldType", 0);
return 0;
}

int ll_ObjectClassFieldValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectClassFieldValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectClassFieldValue", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_OpenTypeFieldVal(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectClassFieldValue", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_FixedTypeFieldVal(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectClassFieldValue");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectClassFieldValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectClassFieldValue", 0);
return 0;
}

int ll_OpenTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("OpenTypeFieldVal");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XType llatt_1;
if (!ll_Type(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(':', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XValue llatt_3;
if (!ll_Value(&llatt_3, &llstate_2, &llstate_3, llatt_1)) goto failed1;
*llout = llstate_3;
{(*llret) = llatt_3;
	
}}}}
LLDEBUG_LEAVE("OpenTypeFieldVal", 1);
return 1;
failed1: LLDEBUG_LEAVE("OpenTypeFieldVal", 0);
return 0;
}

int ll_FixedTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("FixedTypeFieldVal");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("FixedTypeFieldVal", 1);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_BuiltinValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("FixedTypeFieldVal", 2);
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_ReferencedValue(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("FixedTypeFieldVal");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("FixedTypeFieldVal", 1);
return 1;
failed1: LLDEBUG_LEAVE("FixedTypeFieldVal", 0);
return 0;
}

int ll_ValueFromObject(XValue *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_VariableTypeValue)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueFromObject((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
}}}}}
LLDEBUG_LEAVE("ValueFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueFromObject", 0);
return 0;
}

int ll_ValueSetFromObjects(XValueSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ValueSetFromObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ValueSetFromObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValueSet &&
		fe != eFieldSpec_VariableTypeValueSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueSetFromObject((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ValueSetFromObjects", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ReferencedObjectSets(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{ObjectSet_t *os;
	    ObjectClass_t *oc;
	    os = GetObjectSet(llstate_2.Assignments, llatt_1);
	    oc = os && os->Type == eObjectSet_ObjectSet ?
	    	os->U.ObjectSet.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_FixedTypeValue &&
		fe != eFieldSpec_FixedTypeValueSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined) {
		(*llret) = GetValueSetFromObjectSet((*llout).Assignments, llatt_1, llatt_3);
	    } else {
		(*llret) = NULL;
	    }
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ValueSetFromObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ValueSetFromObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ValueSetFromObjects", 0);
return 0;
}

int ll_TypeFromObject(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("TypeFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Type)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetTypeFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
}}}}}
LLDEBUG_LEAVE("TypeFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("TypeFromObject", 0);
return 0;
}

int ll_ObjectFromObject(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectFromObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed1;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
}}}}}
LLDEBUG_LEAVE("ObjectFromObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectFromObject", 0);
return 0;
}

int ll_ObjectSetFromObjects(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ObjectSetFromObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ObjectSetFromObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_ReferencedObjects(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{Object_t *o;
	    ObjectClass_t *oc;
	    o = GetObject(llstate_2.Assignments, llatt_1);
	    oc = o ? o->U.Object.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectSetFromObject((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
break;
}}}}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ObjectSetFromObjects", 2);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_ReferencedObjectSets(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
{LLSTATE llstate_2;
if (!llterm('.', (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed2;
{ObjectSet_t *os;
	    ObjectClass_t *oc;
	    os = GetObjectSet(llstate_2.Assignments, llatt_1);
	    oc = os ? os->U.OE.ObjectClass : NULL;
	
{LLSTATE llstate_3;XStrings llatt_3;
if (!ll_FieldName(&llatt_3, &llstate_2, &llstate_3, oc)) goto failed2;
*llout = llstate_3;
{FieldSpec_t *fs;
	    FieldSpecs_e fe;
	    fs = GetFieldSpecFromObjectClass((*llout).Assignments, oc, llatt_3);
	    fe = GetFieldSpecType((*llout).Assignments, fs);
	    if (fe != eFieldSpec_Undefined &&
		fe != eFieldSpec_Object &&
		fe != eFieldSpec_ObjectSet)
		LLFAILED((&llstate_2.pos, "Bad field type"));
	    if (fe != eFieldSpec_Undefined)
		(*llret) = GetObjectSetFromObjectSet((*llout).Assignments, llatt_1, llatt_3);
	    else
		(*llret) = NULL;
	
break;
}}}}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ObjectSetFromObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ObjectSetFromObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ObjectSetFromObjects", 0);
return 0;
}

int ll_ReferencedObjects(XObject *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedObjects");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedObjects", 1);
{LLSTATE llstate_1;XObject llatt_1;
if (!ll_DefinedObject(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedObjects", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedObject(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedObjects");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedObjects", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedObjects", 0);
return 0;
}

int ll_ReferencedObjectSets(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ReferencedObjectSets");

llstate_0 = *llin;
#undef failed
#define failed failed1
#undef failed
#define failed failed2
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
LLDEBUG_ALTERNATIVE("ReferencedObjectSets", 1);
{LLSTATE llstate_1;XObjectSet llatt_1;
if (!ll_DefinedObjectSet(&llatt_1, &llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{(*llret) = llatt_1;
	
break;
}}
case 2: case -2:
LLDEBUG_ALTERNATIVE("ReferencedObjectSets", 2);
{LLSTATE llstate_1;
if (!ll_ParameterizedObjectSet(&llstate_0, &llstate_1)) goto failed2;
*llout = llstate_1;
{MyAbort();
	
break;
}}
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("ReferencedObjectSets");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("ReferencedObjectSets", 1);
return 1;
failed1: LLDEBUG_LEAVE("ReferencedObjectSets", 0);
return 0;
}

int ll_InstanceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InstanceOfType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_INSTANCE, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
{LLSTATE llstate_2;
if (!llterm(T_OF, (LLSTYPE *)0, &llstate_1, &llstate_2)) goto failed1;
{LLSTATE llstate_3;XObjectClass llatt_3;
if (!ll_DefinedObjectClass(&llatt_3, &llstate_2, &llstate_3)) goto failed1;
*llout = llstate_3;
{Component_t *co1, *co2;
	    Type_t *ty;
	    (*llret) = NewType(eType_InstanceOf);
	    (*llret)->U.Sequence.Components = co1 = NewComponent(eComponent_Normal);
	    co1->Next = co2 = NewComponent(eComponent_Normal);
	    ty = NewType(eType_FieldReference);
	    ty->U.FieldReference.Identifier = "&id";
	    ty->U.FieldReference.ObjectClass = llatt_3;
	    co1->U.Normal.NamedType = NewNamedType("type-id", ty);
	    ty = NewType(eType_FieldReference);
	    ty->Tags = NewTag(eTagType_Explicit);
	    ty->Tags->Tag = Builtin_Value_Integer_0;
	    ty->U.FieldReference.Identifier = "&Type";
	    ty->U.FieldReference.ObjectClass = llatt_3;
	    co2->U.Normal.NamedType = NewNamedType("value", ty);
	
}}}}
LLDEBUG_LEAVE("InstanceOfType", 1);
return 1;
failed1: LLDEBUG_LEAVE("InstanceOfType", 0);
return 0;
}

int ll_InstanceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("InstanceOfValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;XValue llatt_1;
if (!ll_SequenceValue(&llatt_1, &llstate_0, &llstate_1, llarg_type)) goto failed1;
*llout = llstate_1;
{(*llret) = llatt_1;
	
}}
LLDEBUG_LEAVE("InstanceOfValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("InstanceOfValue", 0);
return 0;
}

int ll_MacroDefinition(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinition");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX1, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinition", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinition", 0);
return 0;
}

int ll_MacroDefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX2, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinedType", 0);
return 0;
}

int ll_MacroDefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("MacroDefinedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX3, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("MacroDefinedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("MacroDefinedValue", 0);
return 0;
}

int ll_ParameterizedValueSetType(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedValueSetType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX4, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedValueSetType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedValueSetType", 0);
return 0;
}

int ll_ParameterizedReference(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedReference");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX5, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedReference", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedReference", 0);
return 0;
}

int ll_ParameterizedType(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedType");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX7, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedType", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedType", 0);
return 0;
}

int ll_ParameterizedValue(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedValue");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX9, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedValue", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedValue", 0);
return 0;
}

int ll_ParameterizedAssignment(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedAssignment");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX16, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedAssignment", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedAssignment", 0);
return 0;
}

int ll_ParameterizedObjectClass(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObjectClass");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX17, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObjectClass", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObjectClass", 0);
return 0;
}

int ll_ParameterizedObject(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObject");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX2, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObject", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObject", 0);
return 0;
}

int ll_ParameterizedObjectSet(LLSTATE *llin, LLSTATE *llout)
{
unsigned llstp = llcstp;
LLSTATE llstate_0;
LLDEBUG_ENTER("ParameterizedObjectSet");

llstate_0 = *llin;
#undef failed
#define failed failed1
{LLSTATE llstate_1;
if (!llterm(T_DUM_XXX12, (LLSTYPE *)0, &llstate_0, &llstate_1)) goto failed1;
*llout = llstate_1;
{MyAbort(); 
}}
LLDEBUG_LEAVE("ParameterizedObjectSet", 1);
return 1;
failed1: LLDEBUG_LEAVE("ParameterizedObjectSet", 0);
return 0;
}


int
llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout)
{
unsigned i;
LLDEBUG_ENTER("llparser");
lltokens = tokens; llntokens = ntokens;
for (i = 0; i < llstksize; i++) llstk[i] = 1;
llcstp = 1; llcpos = 0; llepos = 0; *llerrormsg = 0;
#if LLDEBUG > 0
last_linenr = 0; last_file = "";
#endif
{unsigned llpos1 = llcpos, llstp1 = llcstp;
LLCHECKSTK;
for (;;) {
switch (llstk[llcstp++]) {
case 1: case -1:
if (!ll_Main(llin, llout)) goto failed2;
if (llcpos != llntokens) goto failed2;
break;
default:
llstk[--llcstp] = 1;
goto failed1;
failed2:
LLDEBUG_BACKTRACKING("llparser");
if (llstk[--llcstp] < 0) llstk[llcstp] = 0; else llstk[llcstp]++;
llcpos = llpos1; llcstp = llstp1;
continue;
} break;
}}
LLDEBUG_LEAVE("llparser", 1);
return 1;
failed1:
LLDEBUG_LEAVE("llparser", 0);
return 0;
}

int
llterm(int token, LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_TOKEN(token, llcpos);
	if (llcpos < llntokens && lltokens[llcpos].token == token) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}

int
llanyterm(LLSTYPE *lval, LLSTATE *llin, LLSTATE *llout)
{
#if LLDEBUG > 0
	if (lldebug > 0 && (lltokens[llcpos].pos.line > last_linenr || strcmp(lltokens[llcpos].pos.file, last_file))) {
	fprintf(stderr, "File \"%s\", Line %5d                    \r",
		lltokens[llcpos].pos.file, lltokens[llcpos].pos.line);
	last_linenr = lltokens[llcpos].pos.line / 10 * 10 + 9;
	last_file = lltokens[llcpos].pos.file;
	}
#endif
	if (llstk[llcstp] != 1 && llstk[llcstp] != -1) {
		LLDEBUG_BACKTRACKING("llanyterm");
		llstk[llcstp] = 1;
		return 0;
	}
	LLDEBUG_ANYTOKEN(llcpos);
	if (llcpos < llntokens) {
		if (lval)
			*lval = lltokens[llcpos].lval;
		*llout = *llin;
		llout->pos = lltokens[llcpos].pos;
		llcpos++;
		LLCHECKSTK;
		llcstp++;
		return 1;
	}
	llfailed(&lltokens[llcpos].pos, NULL);
	llstk[llcstp] = 1;
	return 0;
}
void
llscanner(LLTERM **tokens, unsigned *ntokens)
{
	unsigned i = 0;
#if LLDEBUG > 0
	int line = -1;
#endif

	*ntokens = 1024;
	*tokens = (LLTERM *)malloc(*ntokens * sizeof(LLTERM));
	while (llgettoken(&(*tokens)[i].token, &(*tokens)[i].lval, &(*tokens)[i].pos)) {
#if LLDEBUG > 0
		if (lldebug > 0 && (*tokens)[i].pos.line > line) {
			line = (*tokens)[i].pos.line / 10 * 10 + 9;
			fprintf(stderr, "File \"%s\", Line %5d                    \r",
				(*tokens)[i].pos.file, (*tokens)[i].pos.line);
		}
#endif
		if (++i >= *ntokens) {
			*ntokens *= 2;
			*tokens = (LLTERM *)realloc(*tokens, *ntokens * sizeof(LLTERM));
		}
	}
	(*tokens)[i].token = 0;
	*ntokens = i;
#if LLDEBUG > 0
	lldebug_init();
#endif
	llresizestk();
}

void
llfailed(LLPOS *pos, char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	if (llcpos > llepos || llcpos == llepos && !*llerrormsg) {
		llepos = llcpos;
		if (fmt)
			vsprintf(llerrormsg, fmt, args);
		else
			*llerrormsg = 0;
		llerrorpos = *pos;
	}
	va_end(args);
}

void
llprinterror(FILE *f)
{
#if LLDEBUG > 0
	fputs("                                \r", stderr);
#endif
	if (*llerrormsg)
		llerror(f, &llerrorpos, llerrormsg);
	else
		llerror(f, &llerrorpos, "Syntax error");
}

void
llerror(FILE *f, LLPOS *pos, char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	llverror(f, pos, fmt, args);
	va_end(args);
}

void
llresizestk()
{
	unsigned i;

	if (llcstp + 1 >= llstksize) {
		i = llstksize;
		if (!llstksize)
			llstk = (int *)malloc((llstksize = 4096) * sizeof(int));
		else
			llstk = (int *)realloc(llstk, (llstksize *= 2) * sizeof(int));
		for (; i < llstksize; i++)
			llstk[i] = 1;
	}
}

#if LLDEBUG > 0
int lldepth;
char *lltokentab[] = {
"EOF","#1","#2","#3","#4","#5","#6","#7"
,"#8","#9","#10","#11","#12","#13","#14","#15"
,"#16","#17","#18","#19","#20","#21","#22","#23"
,"#24","#25","#26","#27","#28","#29","#30","#31"
,"' '","'!'","'\"'","'#'","'$'","'%'","'&'","'''"
,"'('","')'","'*'","'+'","','","'-'","'.'","'/'"
,"'0'","'1'","'2'","'3'","'4'","'5'","'6'","'7'"
,"'8'","'9'","':'","';'","'<'","'='","'>'","'?'"
,"'@'","'A'","'B'","'C'","'D'","'E'","'F'","'G'"
,"'H'","'I'","'J'","'K'","'L'","'M'","'N'","'O'"
,"'P'","'Q'","'R'","'S'","'T'","'U'","'V'","'W'"
,"'X'","'Y'","'Z'","'['","'\\'","']'","'^'","'_'"
,"'`'","'a'","'b'","'c'","'d'","'e'","'f'","'g'"
,"'h'","'i'","'j'","'k'","'l'","'m'","'n'","'o'"
,"'p'","'q'","'r'","'s'","'t'","'u'","'v'","'w'"
,"'x'","'y'","'z'","'{'","'|'","'}'","'~'","#127"
,"#128","#129","#130","#131","#132","#133","#134","#135"
,"#136","#137","#138","#139","#140","#141","#142","#143"
,"#144","#145","#146","#147","#148","#149","#150","#151"
,"#152","#153","#154","#155","#156","#157","#158","#159"
,"#160","#161","#162","#163","#164","#165","#166","#167"
,"#168","#169","#170","#171","#172","#173","#174","#175"
,"#176","#177","#178","#179","#180","#181","#182","#183"
,"#184","#185","#186","#187","#188","#189","#190","#191"
,"#192","#193","#194","#195","#196","#197","#198","#199"
,"#200","#201","#202","#203","#204","#205","#206","#207"
,"#208","#209","#210","#211","#212","#213","#214","#215"
,"#216","#217","#218","#219","#220","#221","#222","#223"
,"#224","#225","#226","#227","#228","#229","#230","#231"
,"#232","#233","#234","#235","#236","#237","#238","#239"
,"#240","#241","#242","#243","#244","#245","#246","#247"
,"#248","#249","#250","#251","#252","#253","#254","#255"
,"#256","\"::=\"","\"..\"","\"...\"","\"TYPE-IDENTIFIER\"","\"ABSTRACT-SYNTAX\"","\"--$zero-terminated--\"","\"--$pointer--\""
,"\"--$no-pointer--\"","\"--$fixed-array--\"","\"--$singly-linked-list--\"","\"--$doubly-linked-list--\"","\"--$length-pointer--\"","\"number\"","number","bstring"
,"hstring","cstring","only_uppercase_symbol","only_uppercase_digits_symbol","uppercase_symbol","lcsymbol","ampucsymbol","amplcsymbol"
,"CON_XXX1","CON_XXX2","OBJ_XXX1","OBJ_XXX2","OBJ_XXX3","OBJ_XXX4","OBJ_XXX5","OBJ_XXX6"
,"OBJ_XXX7","DUM_XXX1","DUM_XXX2","DUM_XXX3","DUM_XXX4","DUM_XXX5","DUM_XXX6","DUM_XXX7"
,"DUM_XXX8","DUM_XXX9","DUM_XXX10","DUM_XXX11","DUM_XXX12","DUM_XXX13","DUM_XXX14","DUM_XXX15"
,"DUM_XXX16","DUM_XXX17","DUM_XXX18","DUM_XXX19","DUM_XXX20","\"DEFINITIONS\"","\"BEGIN\"","\"END\""
,"\"EXPLICIT\"","\"TAGS\"","\"IMPLICIT\"","\"AUTOMATIC\"","\"EXTENSIBILITY\"","\"IMPLIED\"","\"EXPORTS\"","\"IMPORTS\""
,"\"FROM\"","\"ABSENT\"","\"ALL\"","\"ANY\"","\"APPLICATION\"","\"BMPString\"","\"BY\"","\"CLASS\""
,"\"COMPONENT\"","\"COMPONENTS\"","\"CONSTRAINED\"","\"DEFAULT\"","\"DEFINED\"","\"empty\"","\"EXCEPT\"","\"GeneralizedTime\""
,"\"GeneralString\"","\"GraphicString\"","\"IA5String\"","\"IDENTIFIER\"","\"identifier\"","\"INCLUDES\"","\"ISO646String\"","\"MACRO\""
,"\"MAX\"","\"MIN\"","\"NOTATION\"","\"NumericString\"","\"ObjectDescriptor\"","\"OF\"","\"OPTIONAL\"","\"PDV\""
,"\"PRESENT\"","\"PrintableString\"","\"PRIVATE\"","\"SIZE\"","\"STRING\"","\"string\"","\"SYNTAX\"","\"T61String\""
,"\"TeletexString\"","\"TYPE\"","\"type\"","\"UNIQUE\"","\"UNIVERSAL\"","\"UniversalString\"","\"UTCTime\"","\"UTF8String\""
,"\"VALUE\"","\"value\"","\"VideotexString\"","\"VisibleString\"","\"WITH\"","\"BOOLEAN\"","\"INTEGER\"","\"ENUMERATED\""
,"\"REAL\"","\"BIT\"","\"OCTET\"","\"NULL\"","\"SEQUENCE\"","\"SET\"","\"CHOICE\"","\"OBJECT\""
,"\"EMBEDDED\"","\"EXTERNAL\"","\"CHARACTER\"","\"TRUE\"","\"FALSE\"","\"PLUS_INFINITY\"","\"MINUS_INFINITY\"","\"UNION\""
,"\"INTERSECTION\"","\"PrivateDir_TypeName\"","\"PrivateDir_FieldName\"","\"PrivateDir_ValueName\"","\"PrivateDir_Public\"","\"PrivateDir_Intx\"","\"PrivateDir_LenPtr\"","\"PrivateDir_Pointer\""
,"\"PrivateDir_Array\"","\"PrivateDir_NoCode\"","\"PrivateDir_NoMemCopy\"","\"PrivateDir_OidPacked\"","\"PrivateDir_OidArray\"","\"PrivateDir_SLinked\"","\"PrivateDir_DLinked\"","\"INSTANCE\""
};

void
lldebug_init()
{
	char *p;
	p = getenv("LLDEBUG");
	if (p)
		lldebug = atoi(p);
}

void
lldebug_enter(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("/--- trying rule %s\n", ident);
	lldepth++;
}

void
lldebug_leave(char *ident, int succ)
{
	int i;

	if (lldebug < 2)
		return;
	lldepth--;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (succ)
		printf("\\--- succeeded to apply rule %s\n", ident);
	else
		printf("\\--- failed to apply rule %s\n", ident);
}

void
lldebug_alternative(char *ident, int alt)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying alternative %d for rule %s\n", alt, ident);
}

lldebug_iteration(char *ident, int num)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth - 1; i++)
		fputs("| ", stdout);
	printf(">--- trying iteration %d for rule %s\n", num, ident);
}

void
lldebug_token(int expected, unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	if (pos < llntokens && expected == lltokens[pos].token)
		printf("   found token ");
	else
		printf("   expected token %s, found token ", lltokentab[expected]);
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_anytoken(unsigned pos)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   found token ");
	if (pos >= llntokens)
		printf("<EOF>");
	else
		llprinttoken(lltokens + pos, lltokentab[lltokens[pos].token], stdout);
	putchar('\n');
}

void
lldebug_backtracking(char *ident)
{
	int i;

	if (lldebug < 2)
		return;
	for (i = 0; i < lldepth; i++)
		fputs("| ", stdout);
	printf("   backtracking rule %s\n", ident);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\parser.h ===
#ifndef _ASN1_PARSER_ 
#define _ASN1_PARSER_ 
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */

typedef char *XString;
typedef char32_t *XString32;
typedef intx_t XNumber;
typedef ASN1bool_t XBoolean;
typedef Type_t *XType;
typedef TagType_e XTagType;
typedef TagClass_e XTagClass;
typedef Tag_t *XTags;
typedef ExtensionType_e XExtensionType;
typedef NamedType_t *XNamedType;
typedef ComponentList_t XComponents;
typedef Constraint_t *XConstraints;
typedef ElementSetSpec_t *XElementSetSpec;
typedef SubtypeElement_t *XSubtypeElement;
typedef ObjectSetElement_t *XObjectSetElement;
typedef DirectiveList_t XDirectives;
typedef NamedConstraintList_t XNamedConstraints;
typedef Presence_e XPresence;
typedef NamedNumberList_t XNamedNumbers;
typedef Value_t *XValue;
typedef ValueSet_t *XValueSet;
typedef EndPoint_t XEndPoint;
typedef Tuple_t XTuple;
typedef Quadruple_t XQuadruple;
typedef NamedValueList_t XNamedValues;
typedef ModuleIdentifier_t *XModuleIdentifier;
typedef NamedObjIdValueList_t XNamedObjIdValue;
typedef ObjectClass_t *XObjectClass;
typedef ObjectSet_t *XObjectSet;
typedef Object_t *XObject;
typedef SyntaxSpecList_t XSyntaxSpecs;
typedef FieldSpecList_t XFieldSpecs;
typedef Optionality_t *XOptionality;
typedef SettingList_t XSettings;
typedef StringList_t XStrings;
typedef StringModuleList_t XStringModules;
typedef Macro_t *XMacro;
typedef MacroProduction_t *XMacroProduction;
typedef NamedMacroProductionList_t XMacroProductions;
typedef MacroLocalAssignmentList_t XMacroLocalAssignments;
typedef PrivateDirectives_t *XPrivateDirectives;
typedef struct LLPOS {
	int line;
	int column;
	char *file;
} LLPOS;
typedef struct LLSTATE {
	LLPOS pos;
	AssignmentList_t Assignments;
	AssignedObjIdList_t AssignedObjIds;
	UndefinedSymbolList_t Undefined;
	UndefinedSymbolList_t BadlyDefined;
	ModuleIdentifier_t *Module;
	ModuleIdentifier_t *MainModule;
	StringModuleList_t Imported;
	TagType_e TagDefault;
	ExtensionType_e ExtensionDefault;
} LLSTATE;
int ll_Main(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleDefinition_ESeq(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleDefinition(LLSTATE *llin, LLSTATE *llout);
int ll_ModuleIdentifier(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinitiveNameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TagDefault(XTagType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtensionDefault(XExtensionType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ModuleBody(LLSTATE *llin, LLSTATE *llout);
int ll_Exports(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsExported(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Imports(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsImported(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsFromModule_ESeq(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolsFromModule(XStringModules *llret, LLSTATE *llin, LLSTATE *llout);
int ll_GlobalModuleReference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AssignedIdentifier(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SymbolList(XStrings *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Symbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Reference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AssignmentList(LLSTATE *llin, LLSTATE *llout);
int ll_Assignment_ESeq(LLSTATE *llin, LLSTATE *llout);
int ll_Assignment(LLSTATE *llin, LLSTATE *llout);
int ll_typereference(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externaltypereference(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_valuereference(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externalvaluereference(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectClassReference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectreference(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectReference(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_objectsetreference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalObjectSetReference(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_macroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Externalmacroreference(XMacro *llret, LLSTATE *llin, LLSTATE *llout);
int ll_localtypereference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_localvaluereference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_productionreference(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_modulereference(XModuleIdentifier *llret, LLSTATE *llin, LLSTATE *llout);
int ll_typefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_valuefieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_valuesetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_objectfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_objectsetfieldreference(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_word(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_identifier(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ucsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ocsymbol(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_astring(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ValueSetTypeAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ValueSet(XValueSet *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Type(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UndirectivedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UntaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ConstrainableType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Constraint_ESeq(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BuiltinType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedType(XNamedType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_BooleanType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_IntegerType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedNumberList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedNumber(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumeratedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Enumerations(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumerationExtension(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Enumeration(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EnumerationItem(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_RealType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_BitStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedBitList(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedBit(XNamedNumbers *llret, LLSTATE *llin, LLSTATE *llout);
int ll_OctetStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UTF8StringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NullType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SequenceType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtensionAndException(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtendedComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AdditionalComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentType(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ComponentTypePostfix(XComponents *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SequenceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SetType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SetOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ChoiceType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExtendedAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AlternativeTypeListExtension(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AdditionalAlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AlternativeTypeList(XComponents *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AnyType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_SelectionType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TaggedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TagType(XTagType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Tag(XTags *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ClassNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Class(XTagClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectIdentifierType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EmbeddedPDVType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ExternalType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_CharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_RestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UnrestrictedCharacterStringType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_UsefulType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeWithConstraint(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_Value(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BuiltinValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ReferencedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NamedValue(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_BooleanValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SignedNumber(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IntegerValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_EnumeratedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_RealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_NumericRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SpecialRealValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_BitStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IdentifierList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Identifier_EList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_IdentifierList_Elem(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_OctetStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_NullValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_GeneralizedTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UTCTimeValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ObjectDescriptorValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SequenceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ComponentValueList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_ComponentValueCList(XNamedValues *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_SequenceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueCList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SetValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SetOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ChoiceValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ObjectIdentifierValue(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponentList(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponent_ESeq(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjIdComponent(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NameForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_NameAndNumberForm(XNamedObjIdValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_EmbeddedPDVValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ExternalValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_RestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UnrestrictedCharacterStringValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharacterStringList(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharSyms(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_CharDefn(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Quadruple(XQuadruple *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Tuple(XTuple *llret, LLSTATE *llin, LLSTATE *llout);
int ll_AnyValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Constraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ConstraintSpec(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_SubtypeConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ExceptionSpec(LLSTATE *llin, LLSTATE *llout);
int ll_ExceptionIdentification(LLSTATE *llin, LLSTATE *llout);
int ll_ElementSetSpecs(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ElementSetSpecExtension(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_AdditionalElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_ElementSetSpec(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Unions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_UnionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Intersections(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_IntersectionList(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_IntersectionElements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Exclusions_Opt(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_Exclusions(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_UnionMark(LLSTATE *llin, LLSTATE *llout);
int ll_IntersectionMark(LLSTATE *llin, LLSTATE *llout);
int ll_Elements(XElementSetSpec *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XObjectClass llarg_objectclass, XBoolean llarg_permalpha);
int ll_SubtypeElements(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type, XBoolean llarg_permalpha);
int ll_SingleValue(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ContainedSubtype(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_Includes(XBoolean *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueRange(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_LowerEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UpperEndpoint(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_LowerEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_UpperEndValue(XEndPoint *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SizeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PermittedAlphabet(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_InnerTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_SingleTypeConstraint(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_MultipleTypeConstraints(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_FullSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_PartialSpecification(XSubtypeElement *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_TypeConstraints(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_NamedConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XComponents llarg_components);
int ll_ComponentConstraint(XNamedConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueConstraint(XConstraints *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_PresenceConstraint(XPresence *llret, LLSTATE *llin, LLSTATE *llout);
int ll_GeneralConstraint(LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalTypeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirectiveSeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirectiveESeq(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_LocalSizeDirective(XDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Type(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Field(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Value(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Public(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Intx(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_LenPtr(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Pointer(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_Array(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_NoCode(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_NoMemCopy(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_OidPacked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_OidArray(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_SLinked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDir_DLinked(int *llret, LLSTATE *llin, LLSTATE *llout);
int ll_PrivateDirectives(XPrivateDirectives *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObject(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_DefinedObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_Usefulobjectclassreference(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClassAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClass(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectClassDefn(XObjectClass *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec_List(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec_EList(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_WithSyntaxSpec_opt(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TypeFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TypeOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout);
int ll_FixedTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_UNIQUE_opt(XBoolean *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_VariableTypeValueFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FixedTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ValueSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_VariableTypeValueSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetFieldSpec(XFieldSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetOptionalitySpec_opt(XOptionality *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_PrimitiveFieldName(XString *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldName(XStrings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_SyntaxList(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec_Seq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec_ESeq(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_TokenOrGroupSpec(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_OptionalGroup(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_RequiredToken(XSyntaxSpecs *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_Literal(XString *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_Object(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectDefn(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_DefaultSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_FieldSetting_EList(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_FieldSetting_EListC(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_FieldSetting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se);
int ll_DefinedSyntax(XObject *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_DefinedSyntaxToken_ESeq(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_DefinedSyntaxToken(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_DefinedSyntaxToken_Elem(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XSyntaxSpecs llarg_sy);
int ll_Setting(XSettings *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc, XSettings llarg_se, XString llarg_f);
int ll_ObjectSetAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ObjectSet(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetSpec(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectSetElements(XObjectSetElement *llret, LLSTATE *llin, LLSTATE *llout, XObjectClass llarg_oc);
int ll_ObjectClassFieldType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectClassFieldValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_OpenTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_FixedTypeFieldVal(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ValueFromObject(XValue *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ValueSetFromObjects(XValueSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_TypeFromObject(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectFromObject(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ObjectSetFromObjects(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedObjects(XObject *llret, LLSTATE *llin, LLSTATE *llout);
int ll_ReferencedObjectSets(XObjectSet *llret, LLSTATE *llin, LLSTATE *llout);
int ll_InstanceOfType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_InstanceOfValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_MacroDefinition(LLSTATE *llin, LLSTATE *llout);
int ll_MacroDefinedType(XType *llret, LLSTATE *llin, LLSTATE *llout);
int ll_MacroDefinedValue(XValue *llret, LLSTATE *llin, LLSTATE *llout, XType llarg_type);
int ll_ParameterizedValueSetType(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedReference(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedType(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedValue(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedAssignment(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObjectClass(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObject(LLSTATE *llin, LLSTATE *llout);
int ll_ParameterizedObjectSet(LLSTATE *llin, LLSTATE *llout);
typedef union LLSTYPE{
	XNumber _XNumber;
	XString _XString;
	XString32 _XString32;
	XModuleIdentifier _XModuleIdentifier;
	XValue _XValue;
	XNamedObjIdValue _XNamedObjIdValue;
	XTagType _XTagType;
	XExtensionType _XExtensionType;
	XStrings _XStrings;
	XStringModules _XStringModules;
	XType _XType;
	XObjectClass _XObjectClass;
	XObject _XObject;
	XObjectSet _XObjectSet;
	XMacro _XMacro;
	XValueSet _XValueSet;
	XConstraints _XConstraints;
	XNamedType _XNamedType;
	XNamedNumbers _XNamedNumbers;
	XComponents _XComponents;
	XTags _XTags;
	XTagClass _XTagClass;
	XNamedValues _XNamedValues;
	XQuadruple _XQuadruple;
	XTuple _XTuple;
	XBoolean _XBoolean;
	XElementSetSpec _XElementSetSpec;
	XSubtypeElement _XSubtypeElement;
	XEndPoint _XEndPoint;
	XNamedConstraints _XNamedConstraints;
	XPresence _XPresence;
	XDirectives _XDirectives;
	int _int;
	XPrivateDirectives _XPrivateDirectives;
	XFieldSpecs _XFieldSpecs;
	XSyntaxSpecs _XSyntaxSpecs;
	XOptionality _XOptionality;
	XSettings _XSettings;
	XObjectSetElement _XObjectSetElement;
} LLSTYPE;
typedef struct LLTERM {
	int token;
	LLSTYPE lval;
	LLPOS pos;
} LLTERM;
void llscanner(LLTERM **tokens, unsigned *ntokens);
int llparser(LLTERM *tokens, unsigned ntokens, LLSTATE *llin, LLSTATE *llout);
void llprinterror(FILE *f);
void llverror(FILE *f, LLPOS *pos, char *fmt, va_list args);
void llerror(FILE *f, LLPOS *pos, char *fmt, ...);
int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos);
#if LLDEBUG > 0
void lldebug_init();
#endif
#define T_DEF 257
#define T_DDOT 258
#define T_TDOT 259
#define T_TYPE_IDENTIFIER 260
#define T_ABSTRACT_SYNTAX 261
#define T_ZERO_TERMINATED 262
#define T_POINTER 263
#define T_NO_POINTER 264
#define T_FIXED_ARRAY 265
#define T_SINGLY_LINKED_LIST 266
#define T_DOUBLY_LINKED_LIST 267
#define T_LENGTH_POINTER 268
#define T_Number 269
#define T_number 270
#define T_bstring 271
#define T_hstring 272
#define T_cstring 273
#define T_only_uppercase_symbol 274
#define T_only_uppercase_digits_symbol 275
#define T_uppercase_symbol 276
#define T_lcsymbol 277
#define T_ampucsymbol 278
#define T_amplcsymbol 279
#define T_CON_XXX1 280
#define T_CON_XXX2 281
#define T_OBJ_XXX1 282
#define T_OBJ_XXX2 283
#define T_OBJ_XXX3 284
#define T_OBJ_XXX4 285
#define T_OBJ_XXX5 286
#define T_OBJ_XXX6 287
#define T_OBJ_XXX7 288
#define T_DUM_XXX1 289
#define T_DUM_XXX2 290
#define T_DUM_XXX3 291
#define T_DUM_XXX4 292
#define T_DUM_XXX5 293
#define T_DUM_XXX6 294
#define T_DUM_XXX7 295
#define T_DUM_XXX8 296
#define T_DUM_XXX9 297
#define T_DUM_XXX10 298
#define T_DUM_XXX11 299
#define T_DUM_XXX12 300
#define T_DUM_XXX13 301
#define T_DUM_XXX14 302
#define T_DUM_XXX15 303
#define T_DUM_XXX16 304
#define T_DUM_XXX17 305
#define T_DUM_XXX18 306
#define T_DUM_XXX19 307
#define T_DUM_XXX20 308
#define T_DEFINITIONS 309
#define T_BEGIN 310
#define T_END 311
#define T_EXPLICIT 312
#define T_TAGS 313
#define T_IMPLICIT 314
#define T_AUTOMATIC 315
#define T_EXTENSIBILITY 316
#define T_IMPLIED 317
#define T_EXPORTS 318
#define T_IMPORTS 319
#define T_FROM 320
#define T_ABSENT 321
#define T_ALL 322
#define T_ANY 323
#define T_APPLICATION 324
#define T_BMPString 325
#define T_BY 326
#define T_CLASS 327
#define T_COMPONENT 328
#define T_COMPONENTS 329
#define T_CONSTRAINED 330
#define T_DEFAULT 331
#define T_DEFINED 332
#define T_empty 333
#define T_EXCEPT 334
#define T_GeneralizedTime 335
#define T_GeneralString 336
#define T_GraphicString 337
#define T_IA5String 338
#define T_IDENTIFIER 339
#define T_identifier 340
#define T_INCLUDES 341
#define T_ISO646String 342
#define T_MACRO 343
#define T_MAX 344
#define T_MIN 345
#define T_NOTATION 346
#define T_NumericString 347
#define T_ObjectDescriptor 348
#define T_OF 349
#define T_OPTIONAL 350
#define T_PDV 351
#define T_PRESENT 352
#define T_PrintableString 353
#define T_PRIVATE 354
#define T_SIZE 355
#define T_STRING 356
#define T_string 357
#define T_SYNTAX 358
#define T_T61String 359
#define T_TeletexString 360
#define T_TYPE 361
#define T_type 362
#define T_UNIQUE 363
#define T_UNIVERSAL 364
#define T_UniversalString 365
#define T_UTCTime 366
#define T_UTF8String 367
#define T_VALUE 368
#define T_value 369
#define T_VideotexString 370
#define T_VisibleString 371
#define T_WITH 372
#define T_BOOLEAN 373
#define T_INTEGER 374
#define T_ENUMERATED 375
#define T_REAL 376
#define T_BIT 377
#define T_OCTET 378
#define T_NULL 379
#define T_SEQUENCE 380
#define T_SET 381
#define T_CHOICE 382
#define T_OBJECT 383
#define T_EMBEDDED 384
#define T_EXTERNAL 385
#define T_CHARACTER 386
#define T_TRUE 387
#define T_FALSE 388
#define T_PLUS_INFINITY 389
#define T_MINUS_INFINITY 390
#define T_UNION 391
#define T_INTERSECTION 392
#define T_PrivateDir_TypeName 393
#define T_PrivateDir_FieldName 394
#define T_PrivateDir_ValueName 395
#define T_PrivateDir_Public 396
#define T_PrivateDir_Intx 397
#define T_PrivateDir_LenPtr 398
#define T_PrivateDir_Pointer 399
#define T_PrivateDir_Array 400
#define T_PrivateDir_NoCode 401
#define T_PrivateDir_NoMemCopy 402
#define T_PrivateDir_OidPacked 403
#define T_PrivateDir_OidArray 404
#define T_PrivateDir_SLinked 405
#define T_PrivateDir_DLinked 406
#define T_INSTANCE 407
#endif // _ASN1_PARSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\list.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* get length of a singly linked list */
size_t SLlength(void *head, size_t offset)
{
    size_t nelem = 0;

    while (head) {
	/*LINTED*/
    	head = *(void **)((char *)head + offset);
	nelem++;
    }
    return nelem;
}

/* search for an element in a singly linked list */
int SLcontains(void *head, size_t offset, void *elem)
{
    while (head) {
	if (head == elem)
	    return 1;
	/*LINTED pointer cast may result in improper alignment*/
	head = *(void **)((char *)head + offset);
    }
    return 0;
}

/* copy elements of a singly linked list into an array */
void SLtoA(void *head, size_t offset, size_t elemsize, void **base, size_t *nelem)
{
    void *p;

    *nelem = SLlength(head, offset);
    if (!*nelem) {
    	*base = NULL;
	return;
    }
    p = *base = malloc(*nelem * elemsize);
    /*LINTED*/
    for (; head; head = *(void **)((char *)head + offset)) {
    	memcpy(p, head, elemsize);
	p = (void *)((char *)p + elemsize);
    }
}

/* copy pointers to elements of a singly linked list into an array */
void SLtoAP(void *head, size_t offset, void ***base, size_t *nelem)
{
    void **p;

    *nelem = SLlength(head, offset);
    if (!*nelem) {
    	*base = NULL;
	return;
    }
    p = *base = (void **)malloc(*nelem * sizeof(void *));
    /*LINTED*/
    for (; head; head = *(void **)((char *)head + offset)) {
    	*p++ = head;
    }
}

/* copy elements of an array into a singly linked list */
void AtoSL(void *base, size_t offset, size_t nelem, size_t elemsize, void **head)
{
    while (nelem--) {
    	*head = malloc(elemsize);
	memcpy(*head, base, elemsize);
	base = (void *)((char *)base + elemsize);
	/*LINTED*/
	head = (void **)((char *)*head + offset);
    }
    *head = NULL;
}

/* user defined compare function of qsortSL */
static int (*qsortSL_CmpFnCb)(const void *, const void *, void *);
static void *qsortSL_Context;

/* compare function of qsortSL */
static int __cdecl qsortSL_CmpFn(const void *p1, const void *p2)
{
    return qsortSL_CmpFnCb(*(void **)p1, *(void **)p2, qsortSL_Context);
}

/* sort a singly linked list */
void qsortSL(void **head, size_t offset, int (*cmpfn)(const void *, const void *, void *), void *context)
{
    void **base, **p;
    size_t nelem;

    SLtoAP(*head, offset, &base, &nelem);
    qsortSL_CmpFnCb = cmpfn;
    qsortSL_Context = context;
    qsort(base, nelem, sizeof(void *), qsortSL_CmpFn);
    p = base;
    while (nelem--) {
    	*head = *p++;
	/*LINTED*/
	head = (void **)((char *)*head + offset);
    }
    *head = NULL;
    free(base);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\per.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

void ExaminePERType(AssignmentList_t ass, Type_t *type, char *ideref);
static int __cdecl CmpIntxP(const void *v1, const void *v2);
void ExaminePERType_Boolean(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Integer(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Enumerated(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Real(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_BitString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_OctetString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UTF8String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Null(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_External(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_BMPString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GeneralString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GraphicString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_IA5String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ISO646String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_NumericString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_PrintableString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_TeletexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_T61String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UniversalString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_VideotexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_VisibleString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_RestrictedString(AssignmentList_t ass, Type_t *type, intx_t *up, intx_t *nchars, char *tabref, uint32_t enbits, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_UTCTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Open(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_SequenceSet(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Choice(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);
void ExaminePERType_Reference(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info);

/* examine all types and extract informations needed for PER encoding */
void
ExaminePER(AssignmentList_t ass)
{
    Assignment_t *a;

    for (a = ass; a; a = a->Next) {
	switch (a->Type) {
	case eAssignment_Type:
	    ExaminePERType(ass, a->U.Type.Type, GetName(a));
	    break;
	default:
	    break;
	}
    }
}

/* extract some type informations needed for PER encoding */
void
ExaminePERType(AssignmentList_t ass, Type_t *type, char *ideref)
{
    PERConstraints_t *per;
    PERTypeInfo_t *info;
    uint32_t lrange, lrangelog2;

    per = &type->PERConstraints;
    info = &type->PERTypeInfo;
    info->pPrivateDirectives = &type->PrivateDirectives;

    /* get the type to be examined */
    if (type->Type == eType_Reference && !IsStructuredType(GetType(ass, type)))
	type = GetType(ass, type);

    /* initialize the PER informations */
    info->Type = eExtension_Unextended;
    info->Identifier = ideref;
    info->Rules = type->Rules;
    info->Flags = type->Flags;
    info->EnumerationValues = NULL;
    info->NOctets = 0;
    info->Root.TableIdentifier = NULL;
    info->Root.Table = NULL;
    info->Root.SubIdentifier = NULL;
    info->Root.SubType = NULL;
    info->Root.Data = ePERSTIData_Null;
    info->Root.Identification = NULL;
    info->Root.Constraint = ePERSTIConstraint_Unconstrained;
    intx_setuint32(&info->Root.LowerVal, 0);
    intx_setuint32(&info->Root.UpperVal, 0);
    info->Root.NBits = 1;
    info->Root.Alignment = ePERSTIAlignment_OctetAligned;
    info->Root.Length = ePERSTILength_NoLength;
    info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
    info->Root.LLowerVal = info->Root.LUpperVal = 0;
    info->Root.LNBits = 1;
    info->Root.LAlignment = ePERSTIAlignment_OctetAligned;
    info->Additional = info->Root;
    info->Additional.NBits = 8;
    info->Additional.Length = ePERSTILength_InfiniteLength;
    info->Additional.LNBits = 1;
    info->Additional.LAlignment = ePERSTIAlignment_OctetAligned;

    /* PER informations are type specific ... */
    switch (type->Type) {
    case eType_Boolean:
	ExaminePERType_Boolean(ass, type, per, info);
	break;
    case eType_Integer:
	ExaminePERType_Integer(ass, type, per, info);
	break;
    case eType_Enumerated:
	ExaminePERType_Enumerated(ass, type, per, info);
	break;
    case eType_Real:
	ExaminePERType_Real(ass, type, per, info);
	break;
    case eType_BitString:
	ExaminePERType_BitString(ass, type, per, info);
	break;
    case eType_OctetString:
	ExaminePERType_OctetString(ass, type, per, info);
	break;
    case eType_UTF8String:
	ExaminePERType_UTF8String(ass, type, per, info);
	break;
    case eType_Null:
	ExaminePERType_Null(ass, type, per, info);
	break;
    case eType_EmbeddedPdv:
	ExaminePERType_EmbeddedPdv(ass, type, per, info);
	break;
    case eType_External:
	ExaminePERType_External(ass, type, per, info);
	break;
    case eType_ObjectIdentifier:
	ExaminePERType_ObjectIdentifier(ass, type, per, info);
	break;
    case eType_BMPString:
	ExaminePERType_BMPString(ass, type, per, info);
	break;
    case eType_GeneralString:
	ExaminePERType_GeneralString(ass, type, per, info);
	break;
    case eType_GraphicString:
	ExaminePERType_GraphicString(ass, type, per, info);
	break;
    case eType_IA5String:
	ExaminePERType_IA5String(ass, type, per, info);
	break;
    case eType_ISO646String:
	ExaminePERType_ISO646String(ass, type, per, info);
	break;
    case eType_NumericString:
	ExaminePERType_NumericString(ass, type, per, info);
	break;
    case eType_PrintableString:
	ExaminePERType_PrintableString(ass, type, per, info);
	break;
    case eType_TeletexString:
	ExaminePERType_TeletexString(ass, type, per, info);
	break;
    case eType_T61String:
	ExaminePERType_T61String(ass, type, per, info);
	break;
    case eType_UniversalString:
	ExaminePERType_UniversalString(ass, type, per, info);
	break;
    case eType_VideotexString:
	ExaminePERType_VideotexString(ass, type, per, info);
	break;
    case eType_VisibleString:
	ExaminePERType_VisibleString(ass, type, per, info);
	break;
    case eType_CharacterString:
	ExaminePERType_UnrestrictedString(ass, type, per, info);
	break;
    case eType_GeneralizedTime:
	ExaminePERType_GeneralizedTime(ass, type, per, info);
	break;
    case eType_UTCTime:
	ExaminePERType_UTCTime(ass, type, per, info);
	break;
    case eType_ObjectDescriptor:
	ExaminePERType_ObjectDescriptor(ass, type, per, info);
	break;
    case eType_Open:
	ExaminePERType_Open(ass, type, per, info);
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_InstanceOf:
	ExaminePERType_SequenceSet(ass, type, per, info);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	ExaminePERType_SequenceSetOf(ass, type, per, info);
	break;
    case eType_Choice:
	ExaminePERType_Choice(ass, type, per, info);
	break;
    case eType_RestrictedString:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Selection:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Undefined:
	MyAbort(); /* may never happen */
	/*NOTREACHED*/
    case eType_Reference:
	ExaminePERType_Reference(ass, type, per, info);
	break;
    }

    /* get real Length, LNBits and LAlignment */
    if (info->Root.Length == ePERSTILength_Length) {
	switch (info->Root.LConstraint) {
	case ePERSTIConstraint_Constrained:
	    lrange = info->Root.LUpperVal - info->Root.LLowerVal + 1;
	    lrangelog2 = uint32_log2(lrange);
	    if (info->Root.LUpperVal < 0x10000) {
		if (lrange < 0x100) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LAlignment = ePERSTIAlignment_BitAligned;
		    info->Root.LNBits = lrangelog2;
		} else if (lrange == 0x100) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LNBits = 8;
		} else if (lrange <= 0x10000) {
		    info->Root.Length = ePERSTILength_BitLength;
		    info->Root.LNBits = 16;
		} else {
		    info->Root.Length = ePERSTILength_InfiniteLength;
		    info->Root.LLowerVal = 0;
		}
	    } else {
		info->Root.Length = ePERSTILength_InfiniteLength;
		info->Root.LLowerVal = 0;
	    }
	    break;
	case ePERSTIConstraint_Semiconstrained:
	    info->Root.Length = ePERSTILength_InfiniteLength;
	    info->Root.LLowerVal = 0;
	    break;
	}
    } else if (info->Root.Length == ePERSTILength_NoLength) {
	info->Root.LAlignment = ePERSTIAlignment_BitAligned;
    }
}

/*
 * Description of the fields of PERTypeInfo_t:
 *   info.
 *	Identifier	complete name of the type
 *	Rules		encoding directive rules
 *	Flags		encoding flags
 *	EnumerationValues values of enumeration type
 *	NOctets		size of string characters/integer type
 *	Type		unextended/extendable/extended
 *	Root		information for the extension root
 *	Additional	information for the extensions
 *   info.{Root,Additional}.
 *	Data		data type of value
 *	TableIdentifier	name of stringtable to use
 *	Table		stringtable to use
 *	SubIdentifier	complete name of the subtype
 *	SubType		the subtype itself
 *	Identification	identification of EMBEDDED PDV/CHARACTER STRING
 *	NBits		number of bits to use
 *	Constraint	constraint of type values
 *	LowerVal	lower bound of values (if constrained)
 *	UpperVal	upper bound of values (if constrained)
 *	Alignment	alignment to be used for value encoding
 *	Length		type of length encoding
 *	LConstraint	constraint of length
 *	LLowerVal	lower bound of length
 *	LUpperVal	upper bound of length
 *	LAlignment	alignment to be used for length encoding
 *
 * NOTES:
 *	The encoding is mostly controlled by following arguments:
 *	- Data, the type: one of:
 *	  ePERSTIData_Null, ePERSTIData_Boolean,
 *	  ePERSTIData_Integer, ePERSTIData_Unsigned,
 *	  ePERSTIData_Real, ePERSTIData_BitString, ePERSTIData_RZBBitString,
 *	  ePERSTIData_OctetString, ePERSTIData_SequenceOf, ePERSTIData_SetOf,
 *	  ePERSTIData_ObjectIdentifier, ePERSTIData_NormallySmall,
 *	  ePERSTIData_String, ePERSTIData_TableString, ePERSTIData_ZeroString,
 *	  ePERSTIData_ZeroTableString, ePERSTIData_Reference,
 *	  ePERSTIData_Extension, ePERSTIData_External,
 *	  ePERSTIData_EmbeddedPdv, ePERSTIData_UnrestrictedString
 *	- NBits, the item size for encoding
 *	- Length, the length encoding: one of:
 *	  ePERSTILength_NoLength, ePERSTILength_SmallLength,
 *	  ePERSTILength_Length
 *	  (internally eLength will be replaced by one of:
 *	  ePERSTILength_BitLength, ePERSTILength_InfiniteLength,
 *	  depending on the constraints)
 *
 *	Additional arguments:
 *	- Alignment, the value alignment: one of:
 *	  ePERSTIAlignment_BitAligned, ePERSTIAlignment_OctetAligned
 *	- LAlignment, the length alignment: one of:
 *	  ePERSTIAlignment_BitAligned, ePERSTIAlignment_OctetAligned
 *	- Constraint, the value constraint: one of:
 *	  ePERSTIConstraint_Unconstrained, ePERSTIConstraint_Semiconstrained,
 *	  ePERSTIConstraint_Upperconstrained, ePERSTIConstraint_Constrained
 *	- LConstraint, the length constraint: one of:
 *	  ePERSTIConstraint_Semiconstrained, ePERSTIConstraint_Constrained
 *
 *	Following arguments contain variable/function names in the generated
 *	code:
 *	- Identifier, the name of the current type
 *	- SubIdentifier, the name of the subtype
 *	- TableIdentifier, the name of the stringtable
 *
 *	Following values require additional arguments:
 *	- Constraint == ePERSTIConstraint_Semiconstrained ||
 *	  Constraint == ePERSTIConstraint_Constrained:
 *	  -> LowerVal, the lower bound of the value
 *	- Constraint == ePERSTIConstraint_Upperconstrained ||
 *	  Constraint == ePERSTIConstraint_Constrained:
 *	  -> UpperVal, the upper bound of the value
 *	- Length == ePERSTILength_Length:
 *	  -> LLowerVal, the lower bound of the length
 *	- Length == ePERSTILength_Length &&
 *	  LConstraint == ePERSTIConstraint_Constrained:
 *	  -> LUpperVal, the upper bound of the length
 *	- Data == ePERSTIData_TableString ||
 *        Data == ePERSTIData_ZeroTableString:
 *	  -> TableIdentifier, the name of the string table
 *	  -> Table, the string table
 *	- Data == ePERSTIData_Reference:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	- Data == ePERSTIData_*String:
 *	  -> NOctets, the size of the string characters
 *	- Data == ePERSTIData_Integer || Data == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean:
 *	  -> NOctets, the size of the integer type
 *	- Data == ePERSTIData_SequenceOf || Data == ePERSTIData_SetOf:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 *
 *	Following values have optional arguments:
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned:
 *	  -> EnumerationValues, the mapping for enumeration values
 *
 *	Following combinations are allowed:
 *	
 *	Data/NBits/Length		Description
 *	-----------------------------------------------------------------------
 *	Null/0/NoLength			NULL type
 *
 *	Boolean/1/NoLength		boolean value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 *	Real/8/Length			REAL value
 *
 *	*BitString/0/NoLength		BIT STRING of fixed length 0
 *
 *	*BitString/1/NoLength		BIT STRING of fixed length < 64K
 *
 *	*BitString/1/Length		BIT STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of bits
 *
 *					"RZB" in e*BitString means, bit
 *					strings with removed leading zero bits
 *
 *	OctetString/0/NoLength		OCTET STRING of fixed length 0
 *
 *	OctetString/8/NoLength		OCTET STRING of fixed length < 64K,
 *
 *	OctetString/8/Length		OCTET STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of octets
 *
 *	Extension/n/NoLength		bit field representing presence or
 *					absence of <64K OPTIONAL/DEFAULT
 *					components in SEQUENCEs/SETs, encoded
 *					in n bits
 *
 *	Extension/n/Length		bit field representing presence or
 *					absence of >=64K OPTIONAL/DEFAULT
 *					components in SEQUENCEs/SETs, encoded
 *					in n bits
 *
 *	Extension/n/SmallLength		bit field representing presence or
 *					absence of components in the extension
 *					of SEQUENCEs/SETs, encoded in n bits
 *
 *	ObjectIdentifier/8/Length	OBJECT IDENTIFIER value
 *
 *	*String/0/NoLength		String of fixed length 0
 *
 *	*String/n/NoLength		String of fixed length < 64K,
 *					encoded in n bits
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings,
 *					"Table" means renumbering of the
 *					characters.
 *
 *	MultibyteString/8/Length	not known-multiplier character strings
 *
 *	SequenceOf/0/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/0/NoLength		of zero length
 *
 *	SequenceOf/1/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/NoLength		of fixed length <64K
 *
 *	SequenceOf/1/Length		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/Length			of var. length or length >= 64K or
 *					semiconstrained length
 *
 *	External/8/NoLength		EXTERNAL
 *
 *	EmbeddedPdv/8/Length		EMBEDDED PDV
 *
 *	UnrestrictedString/8/Length	CHARACTER STRING
 *
 *	GeneralizedTime/n/NoLength	GeneralizedTime, encoded in units of
 *					n bits
 *
 *	UTCTime/n/NoLength		UTCTime, encoded in units of n bits
 *
 *	Reference/1/NoLength		Reference to a structured subtype
 *
 *	Open/8/Length			Open type
 */

/* for sorting of intx_t's */
static int
__cdecl CmpIntxP(const void *v1, const void *v2)
{
    intx_t *n1 = *(intx_t **)v1;
    intx_t *n2 = *(intx_t **)v2;
    return intx_cmp(n1, n2);
}

/*
 * BOOLEAN:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Boolean/1/NoLength		boolean value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Boolean(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Boolean;
    info->NOctets = GetOctets(GetBooleanType());
    info->Root.Alignment = ePERSTIAlignment_BitAligned;
}

/*
 * INTEGER:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Integer(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    int32_t sign;
    intx_t range;
    uint32_t rangelog2;
    uint32_t rangelog256;

    /* calculate LowerVal, UpperVal and range of extension root */
    /* set Constraint according to presence of LowerVal/UpperVal */
    if (per->Value.Type == eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Min;
	upper.Flags = eEndPoint_Max;
    } else {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Value.Root, &lower, &upper);
	if (lower.Flags & eEndPoint_Max)
	    lower.Flags = eEndPoint_Min;
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
    }
    if (!(lower.Flags & eEndPoint_Min)) {
	intx_dup(&info->Root.LowerVal,
	    &GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.Constraint = ePERSTIConstraint_Semiconstrained;
    }
    if (!(upper.Flags & eEndPoint_Max)) {
	intx_dup(&info->Root.UpperVal,
	    &GetValue(ass, upper.Value)->U.Integer.Value);
	info->Root.Constraint = ePERSTIConstraint_Upperconstrained;
    }
    if (!(lower.Flags & eEndPoint_Min) && !(upper.Flags & eEndPoint_Max)) {
	intx_sub(&range, &info->Root.UpperVal, &info->Root.LowerVal);
	intx_inc(&range);
	rangelog2 = intx_log2(&range);
	rangelog256 = intx_log256(&range);
	info->Root.Constraint = ePERSTIConstraint_Constrained;
    }

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetIntegerType(ass, type, &sign));
    info->Root.Data = sign > 0 ? ePERSTIData_Unsigned : ePERSTIData_Integer;

    /* calculate Length, NBits, Alignment, LConstraint, LLowerVal and */
    /* LUpperVal */
    switch (info->Root.Constraint) {
    case ePERSTIConstraint_Unconstrained:
    case ePERSTIConstraint_Semiconstrained:
    case ePERSTIConstraint_Upperconstrained:
	info->Root.Length = ePERSTILength_Length;
	info->Root.NBits = 8;
	info->Root.LLowerVal = 1;
	break;
    case ePERSTIConstraint_Constrained:
	if (intx_cmp(&range, &intx_1) == 0) {
	    info->Root.NBits = 0;
	} else if (intx_cmp(&range, &intx_256) < 0 || Alignment == eAlignment_Unaligned) {
	    info->Root.NBits = rangelog2;
	    info->Root.Alignment = ePERSTIAlignment_BitAligned;
	} else if (intx_cmp(&range, &intx_256) == 0) {
	    info->Root.NBits = 8;
	} else if (intx_cmp(&range, &intx_64K) <= 0) {
	    info->Root.NBits = 16;
	} else {
	    info->Root.NBits = 8;
	    info->Root.Length = ePERSTILength_Length;
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	    info->Root.LLowerVal = 1;
	    info->Root.LUpperVal = rangelog256;
	}
    }

    /* check for extensions */
    info->Type = per->Value.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;
    info->Additional.Data = info->Root.Data;
}

/*
 * ENUMERATED:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Integer/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Integer/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Integer/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					int{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 */
void
ExaminePERType_Enumerated(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t nroot, nindex, i;
    NamedNumber_t *n;
    int32_t sign;
    uint32_t rangelog2;
    intx_t range;

    /* count number of enumeration values in extension root and extension */
    /* set extension type of extensions are present/possible */
    nroot = nindex = 0;
    for (n = type->U.Enumerated.NamedNumbers; n; n = n->Next) {
	switch (n->Type) {
	case eNamedNumber_Normal:
	    nindex++;
	    switch (info->Type) {
	    case eExtension_Unextended:
		nroot = nindex;
		break;
	    case eExtension_Extendable:
		info->Type = eExtension_Extended;
		break;
	    }
	    break;
	case eNamedNumber_ExtensionMarker:
	    info->Type = eExtension_Extendable;
	    break;
	}
    }

    /* allocate table for enumeration values and copy the values into */
    info->EnumerationValues =
	(intx_t **)malloc((nindex + 1) * sizeof(intx_t *));
    nindex = 0;
    for (n = type->U.Enumerated.NamedNumbers; n; n = n->Next) {
	switch (n->Type) {
	case eNamedNumber_Normal:
	    info->EnumerationValues[nindex++] =
		&GetValue(ass, n->U.Normal.Value)->U.Integer.Value;
	    break;
	case eNamedNumber_ExtensionMarker:
	    break;
	}
    }
    info->EnumerationValues[nindex] = 0;

    /* sort values of extension root according to their value */
    qsort(info->EnumerationValues, nroot,
	sizeof(*info->EnumerationValues), CmpIntxP);

    /* check the need for an index translation */
    for (i = 0; info->EnumerationValues[i]; i++) {
	if (intx2uint32(info->EnumerationValues[i]) != i)
	    break;
    }
    if (!info->EnumerationValues[i])
	info->EnumerationValues = NULL;

    /* calculate NOctets and Data depending on the used C-Type */
    info->NOctets = GetOctets(GetEnumeratedType(ass, type, &sign));
    info->Root.Data = sign > 0 ? ePERSTIData_Unsigned : ePERSTIData_Integer;

    /* enumeration is always constrained to value from 0 to nroot-1 */
    info->Root.Constraint = ePERSTIConstraint_Constrained;
    intx_setuint32(&info->Root.LowerVal, 0);
    intx_setuint32(&info->Root.UpperVal, nroot - 1);
    intx_setuint32(&range, nroot);
    rangelog2 = intx_log2(&range);

    /* calculate NBits and Alignment */
    if (nroot <= 1) {
	info->Root.NBits = 0;
    } else if (nroot < 256) {
	info->Root.Alignment = ePERSTIAlignment_BitAligned;
	info->Root.NBits = rangelog2;
    } else if (nroot == 256) {
	info->Root.NBits = 8;
    } else if (nroot < 65536) {
	info->Root.NBits = 16;
    } else {
	MyAbort();
    }

    /* values of extension will always be encoded as normally small numbers */
    /* with lowerbound = nroot */
    info->Additional.Data = ePERSTIData_NormallySmall;
    info->Additional.NBits = 1;
    info->Additional.Alignment = ePERSTIAlignment_BitAligned;
    info->Additional.Length = ePERSTILength_NoLength;
    info->Additional.Constraint = ePERSTIConstraint_Semiconstrained;
    intx_setuint32(&info->Additional.LowerVal, nroot);
}

/*
 * REAL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Real/8/Length			REAL value
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Real(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Real;
    info->Root.NBits = 8;
    info->NOctets = GetOctets(GetRealType(type));
}

/*
 * BIT STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*BitString/0/NoLength		BIT STRING of fixed length 0
 *
 *	*BitString/1/NoLength		BIT STRING of fixed length < 64K,
 *					encoded in n bits
 *
 *	*BitString/1/Length		BIT STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of bits
 *
 *					"RZB" in e*BitString means, bit
 *					strings with removed leading zero bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_BitString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    info->Root.cbFixedSizeBitString = 0; // clear it up first
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 1;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 32)
		{
		    info->Root.cbFixedSizeBitString = (info->Root.LUpperVal + 7) / 8;
        }
		if (info->Root.LUpperVal <= 16) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 1;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to RZBBitString/BitString */
    if (type->U.BitString.NamedNumbers)
	info->Root.Data = ePERSTIData_RZBBitString;
    else
	info->Root.Data = ePERSTIData_BitString;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
    info->Additional.NBits = 1;
}

/*
 * OCTET STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	OctetString/0/NoLength		OCTET STRING of fixed length 0
 *
 *	OctetString/8/NoLength		OCTET STRING of fixed length < 64K,
 *
 *	OctetString/8/Length		OCTET STRING of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of octets
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_OctetString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 8;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 2) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 8;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to OctetString */
    info->Root.Data = ePERSTIData_OctetString;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
}

void
ExaminePERType_UTF8String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	info->Root.LConstraint = ePERSTIConstraint_Semiconstrained;
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Alignment and Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    info->Root.NBits = 8;
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal <= 2) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.NBits = 8;
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set Data to OctetString */
    info->Root.Data = ePERSTIData_UTF8String;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
}

/*
 * NULL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Null/0/NoLength			NULL type
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Null(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = 0;
    info->Root.Data = ePERSTIData_Null;
}

/*
 * EMBEDDED PDV:
 *
 * Data/NBits/Length used for encoding:
 *
 *	EmbeddedPdv/8/Length		EMBEDDED PDV
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExaminePERType_EmbeddedPdv(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Identification = GetFixedIdentification(ass, type->Constraints);
    info->Root.Data = ePERSTIData_EmbeddedPdv;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * EXTERNAL:
 *
 * Data/NBits/Length used for encoding:
 *
 *	External/8/Length		EXTERNAL
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_External(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_External;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * OBJECT IDENTIFIER:
 *
 * Data/NBits/Length used for encoding:
 *
 *	ObjectIdentifier/8/Length	OBJECT IDENTIFIER value
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_ObjectIdentifier(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_ObjectIdentifier;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * *String:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*String/0/NoLength		String of fixed length 0
 *
 *	*String/n/NoLength		String of fixed length < 64K,
 *					encoded in n bits
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings,
 *					"Table" means renumbering of the
 *					characters.
 *
 *	MultibyteString/8/Length	not known-multiplier character strings
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_TableString || dat == ePERSTIData_ZeroTableString:
 *	  -> TableIdentifier, the name of the string table
 *	  -> Table, the string table
 *	- Data == ePERSTIData_*String:
 *	  -> NOctets, the size of the string characters
 */

void
ExaminePERType_BMPString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0xffff);
    intx_setuint32(&nchars, 0x10000);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, 16, per, info);
}

void
ExaminePERType_GeneralString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Root.NBits = 8;
    info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Root.Length = ePERSTILength_Length;
}

void
ExaminePERType_GraphicString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t zero;

    GetStringType(ass, type, &info->NOctets, &zero);
    info->Root.NBits = 8;
    info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Root.Length = ePERSTILength_Length;
}

void
ExaminePERType_IA5String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7f);
    intx_setuint32(&nchars, 0x80);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_ISO646String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7e);
    intx_setuint32(&nchars, 0x5f);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_NumericString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x39);
    intx_setuint32(&nchars, 0xb);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	"ASN1NumericStringTable", 4, per, info);
}

void
ExaminePERType_PrintableString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7a);
    intx_setuint32(&nchars, 0x4a);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_TeletexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_T61String(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_UniversalString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0xffffffff);
    intx_setuint32(&nchars, 0xffffffff);
    intx_inc(&nchars);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, 32, per, info);
}

void
ExaminePERType_VideotexString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_MultibyteString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
    info->NOctets = 1;
}

void
ExaminePERType_VisibleString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    intx_t up, nchars;

    intx_setuint32(&up, 0x7e);
    intx_setuint32(&nchars, 0x5f);
    ExaminePERType_RestrictedString(ass, type, &up, &nchars,
	NULL, Alignment == eAlignment_Aligned ? 8 : 7, per, info);
}

void
ExaminePERType_RestrictedString(AssignmentList_t ass, Type_t *type, intx_t *up, intx_t *nchars, char *tabref, uint32_t enbits, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    uint32_t zero, rangelog2;
    intx_t ix, range;
    char tabbuf[256];

    /* calculate NOctets depending on the used C-Type */
    GetStringType(ass, type, &info->NOctets, &zero);

    /* calculate LConstraint, LLowerVal and LUpperVal if size constraint is */
    /* given */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	if (lower.Flags & eEndPoint_Max) {
	    lower.Flags = 0;
	    lower.Value = Builtin_Value_Integer_0;
	}
	info->Root.LLowerVal =
	    intx2uint32(&GetValue(ass, lower.Value)->U.Integer.Value);
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal =
		intx2uint32(&GetValue(ass, upper.Value)->U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* get string table if permitted alphabet constraint is present */
    /* update extension type if needed */
    if (per->PermittedAlphabet.Type != eExtension_Unconstrained) {
	info->Root.Table = per->PermittedAlphabet.Root;
	if (per->PermittedAlphabet.Type > info->Type)
	    info->Type = per->PermittedAlphabet.Type;
	if (CountValues(ass, info->Root.Table, &ix)) {
	    nchars = &ix;
	    sprintf(tabbuf, "%s_StringTable", info->Identifier);
	    tabref = tabbuf;
	} else {
	    MyAbort(); /*XXX*/
	}
    }

    /* get bits needed for one character */
    info->Root.NBits = intx_log2(nchars);
    if (Alignment == eAlignment_Aligned) {
	if (info->Root.NBits > 16)
	    info->Root.NBits = 32;
	else if (info->Root.NBits > 8)
	    info->Root.NBits = 16;
	else if (info->Root.NBits > 4)
	    info->Root.NBits = 8;
	else if (info->Root.NBits > 2)
	    info->Root.NBits = 4;
    }

    /* set data type */
    info->Root.Data = tabref ?
	(zero ? ePERSTIData_ZeroTableString : ePERSTIData_TableString) :
	(zero ? ePERSTIData_ZeroString : ePERSTIData_String);

    /* check if stringtable is really needed for encoding or extension check */
    intx_dup(&range, up);
    intx_inc(&range);
    rangelog2 = intx_log2(&range);
    if (rangelog2 <= info->Root.NBits) {
	info->Root.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
	if (per->PermittedAlphabet.Type < eExtension_Extended)
	    tabref = NULL;
    }
    info->Root.TableIdentifier = tabref ? strdup(tabref) : NULL;

    /* calculate Length and Alignment */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    if (info->Root.LLowerVal == info->Root.LUpperVal) {
		if (info->Root.LUpperVal * info->Root.NBits <= 16) {
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		} else if (info->Root.LUpperVal >= 0x10000) {
		    info->Root.Length = ePERSTILength_Length;
		}
	    } else {
		if (info->Root.LUpperVal * info->Root.NBits <= 16)
		    info->Root.Alignment = ePERSTIAlignment_BitAligned;
		info->Root.Length = ePERSTILength_Length;
	    }
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* set extension informations */
    info->Additional.Data = zero ? ePERSTIData_ZeroString : ePERSTIData_String;
    info->Additional.NBits = enbits;
}

/*
 * CHARACTER STRING:
 *
 * Data/NBits/Length used for encoding:
 *
 *	UnrestrictedString/8/Length	CHARACTER STRING
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_EmbeddedPdv ||
 *	  Data == ePERSTIData_UnrestrictedString
 *	  -> Identification, the identification of the type if the type
 *	     is constraint to fixed identification or syntaxes identification
 *	     with single value
 */
void
ExaminePERType_UnrestrictedString(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Identification = GetFixedIdentification(ass, type->Constraints);
    info->Root.Data = ePERSTIData_UnrestrictedString;
    info->Root.NBits = 8;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * GeneralizedTime:
 *
 * Data/NBits/Length used for encoding:
 *
 *	GeneralizedTime/n/NoLength	GeneralizedTime, encoded in units of
 *					n bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_GeneralizedTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = (Alignment == eAlignment_Aligned) ? 8 : 7;
    info->Root.Data = ePERSTIData_GeneralizedTime;
}

/*
 * UTCTime:
 *
 * Data/NBits/Length used for encoding:
 *
 *	UTCTime/n/NoLength		UTCTime, encoded in units of
 *					n bits
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_UTCTime(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.NBits = (Alignment == eAlignment_Aligned) ? 8 : 7;
    info->Root.Data = ePERSTIData_UTCTime;
}

/*
 * ObjectDescriptor:
 *
 * Data/NBits/Length used for encoding:
 *
 *	*String/n/Length		String of var. length or
 *					length >= 64K or semiconstrained
 *					length, encoded in units of n bits
 *
 *					"Zero" in *String means
 *					zero-terminated strings
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_ObjectDescriptor(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Root.NBits = 8;
    info->Root.Data = ePERSTIData_ZeroString;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * OpenType:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Open/8/Length			Open type
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_Open(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->NOctets = 1;
    info->Root.NBits = 8;
    info->Root.Data = ePERSTIData_Open;
    info->Root.Length = ePERSTILength_Length;
}

/*
 * SEQUENCE/SET:
 *
 * Data/NBits/Length used for encoding:
 *
 *	none
 *
 * Additional arguments:
 *
 *	none
 */
void
ExaminePERType_SequenceSet(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    /* examine types of components */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	case eComponent_Optional:
	case eComponent_Default:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExaminePERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * SEQUENCE OF/SET OF:
 *
 * Data/NBits/Length used for encoding:
 *
 *	SequenceOf/0/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/0/NoLength		of zero length
 *
 *	SequenceOf/1/NoLength		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/NoLength		of fixed length <64K
 *
 *	SequenceOf/1/Length		SEQUENCE OF subtype or SET OF subtype
 *	SetOf/1/Length			of var. length or length >= 64K or
 *					semiconstrained length
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_SequenceOf || dat == ePERSTIData_SetOf:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 *	  -> Rule, the encoding directive rules
 */
void
ExaminePERType_SequenceSetOf(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    EndPoint_t lower, upper;
    char idebuf[256];

    /* calculate LConstraint, LLowerVal and LUpperVal */
    if (per->Size.Type != eExtension_Unconstrained) {
	lower.Flags = eEndPoint_Max;
	upper.Flags = eEndPoint_Min;
	GetMinMax(ass, per->Size.Root, &lower, &upper);
	if (upper.Flags & eEndPoint_Min)
	    upper.Flags = eEndPoint_Max;
	info->Root.LLowerVal = intx2uint32(&GetValue(ass, lower.Value)->
	    U.Integer.Value);
	if (!(upper.Flags & eEndPoint_Max)) {
	    info->Root.LUpperVal = intx2uint32(&GetValue(ass, upper.Value)->
		U.Integer.Value);
	    info->Root.LConstraint = ePERSTIConstraint_Constrained;
	}
    }

    /* calculate NBits, Length */
    switch (info->Root.LConstraint) {
    case ePERSTIConstraint_Constrained:
	if (info->Root.LUpperVal == 0) {
	    info->Root.NBits = 0;
	} else {
	    if (info->Root.LLowerVal != info->Root.LUpperVal)
		info->Root.Length = ePERSTILength_Length;
	}
	break;
    case ePERSTIConstraint_Semiconstrained:
	info->Root.Length = ePERSTILength_Length;
	break;
    }

    /* set data type and Alignment */
    info->Root.Data = (type->Type == eType_SequenceOf ?
	ePERSTIData_SequenceOf : ePERSTIData_SetOf);
    info->Root.Alignment = ePERSTIAlignment_BitAligned;

    /* set SubType, SubIdentifier */
    info->Root.SubType = type->U.SS.Type;
    info->Root.SubIdentifier = GetTypeName(ass, info->Root.SubType);

    /* get extension type */
    info->Type = per->Size.Type;
    if (info->Type == eExtension_Unconstrained)
	info->Type = eExtension_Unextended;

    /* set extension informations */
    info->Additional.Data = info->Root.Data;
    info->Additional.NBits = 1;
    info->Additional.SubType = info->Root.SubType;
    info->Additional.SubIdentifier = info->Root.SubIdentifier;

    /* examine subtype */
    sprintf(idebuf, "%s_%s", info->Identifier,
	type->Type == eType_SequenceOf ? "Sequence" : "Set");
    ExaminePERType(ass, type->U.SS.Type, strdup(idebuf));
}

/*
 * CHOICE:
 *
 * Data/NBits/Length used for encoding of the choice selector:
 *
 *	Unsigned/0/NoLength		constrained whole number of fixed
 *					value, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *
 *	Unsigned/n/NoLength		constrained whole number of fixed
 *					length < 64K, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in n bits
 *
 *	Unsigned/8/Length		constrained whole number of var.
 *					length or length >= 64K or
 *					semiconstrained or unconstrained
 *					whole number, stored in an
 *					uint{8,16,32}_t/intx_t
 *					(noctets == 1/2/4/0)
 *					encoded in units of octets
 *
 *	NormallySmall/1/NoLength	normally small non-negative
 *					whole number, stored in an
 *					uint{8,16,32}_t
 *					(noctets == 1/2/4)
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Integer || dat == ePERSTIData_Unsigned ||
 *	  Data == ePERSTIData_Boolean
 *	  -> NOctets, the size of the integer type
 *
 */
void
ExaminePERType_Choice(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    uint32_t nroot, rangelog2;
    intx_t range;
    Component_t *comp;
    NamedType_t *namedType;
    char idebuf[256];

    if (type->Flags & eTypeFlags_ExtensionMarker) {
	info->Type = type->U.Choice.Extensions ?
	    eExtension_Extended : eExtension_Extendable;
    }
    nroot = type->U.Choice.Alternatives;
    info->NOctets = GetOctets(GetChoiceType(type));
    info->Root.Constraint = ePERSTIConstraint_Constrained;
    intx_setuint32(&info->Root.UpperVal, nroot - 1);
    intx_setuint32(&range, nroot);
    rangelog2 = intx_log2(&range);
    if (nroot <= 1) {
	info->Root.NBits = 0;
    } else if (nroot < 256) {
	info->Root.Alignment = ePERSTIAlignment_BitAligned;
	info->Root.NBits = rangelog2;
    } else if (nroot == 256) {
	info->Root.NBits = 8;
    } else if (nroot < 65536) {
	info->Root.NBits = 16;
    } else {
	MyAbort();
    }
    info->Root.Data = ePERSTIData_Unsigned;
    info->Additional.Data = ePERSTIData_NormallySmall;
    info->Additional.NBits = 1;
    info->Additional.Alignment = ePERSTIAlignment_BitAligned;
    info->Additional.Length = ePERSTILength_NoLength;
    info->Additional.Constraint = ePERSTIConstraint_Semiconstrained;
    intx_setuint32(&info->Additional.LowerVal, nroot);

    /* examine types of alternatives */
    for (comp = type->U.SSC.Components; comp; comp = comp->Next) {
	switch (comp->Type) {
	case eComponent_Normal:
	    namedType = comp->U.NOD.NamedType;
	    sprintf(idebuf, "%s_%s", info->Identifier, namedType->Identifier);
	    ExaminePERType(ass, namedType->Type, strdup(idebuf));
	    break;
	}
    }
}

/*
 * Reference:
 *
 * Data/NBits/Length used for encoding:
 *
 *	Reference/1/NoLength		Reference to a structured subtype
 *
 * Additional arguments:
 *
 *	- Data == ePERSTIData_Reference:
 *	  -> SubIdentifier, the name of the subtype
 *	  -> SubType, the subtype itself
 */
void
ExaminePERType_Reference(AssignmentList_t ass, Type_t *type, PERConstraints_t *per, PERTypeInfo_t *info)
{
    info->Root.Data = ePERSTIData_Reference;
    info->Root.Alignment = ePERSTIAlignment_BitAligned;
    info->Root.SubIdentifier = GetName(FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier, type->U.Reference.Module));
    info->Root.SubType = GetAssignment(ass, FindAssignment(ass, eAssignment_Type, type->U.Reference.Identifier, type->U.Reference.Module))->U.Type.Type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\optcase.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

static int _IsNotBounded(PERSimpleTypeInfo_t *sinfo);
static int _IsUnsignedShortRange(PERSimpleTypeInfo_t *sinfo);
static int _IsExtendedShortRange(PERSimpleTypeInfo_t *sinfo);


int PerOptCase_IsSignedInteger(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Integer &&
            sinfo->Constraint == ePERSTIConstraint_Unconstrained &&
            sinfo->Length     == ePERSTILength_InfiniteLength &&
            sinfo->NBits      == 8 &&   // default
            sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsUnsignedInteger(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Unsigned &&
            sinfo->Constraint == ePERSTIConstraint_Semiconstrained &&
            sinfo->Length     == ePERSTILength_InfiniteLength &&
            sinfo->NBits      == 8 &&  // default
            sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsUnsignedShort(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Unsigned &&
            sinfo->Constraint == ePERSTIConstraint_Constrained &&
            sinfo->Length     == ePERSTILength_NoLength &&
            sinfo->NBits      == 16 &&
            sinfo->Alignment &&
            _IsUnsignedShortRange(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsBoolean(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->Data       == ePERSTIData_Boolean &&
            sinfo->Constraint == ePERSTIConstraint_Unconstrained &&
            sinfo->Length     == ePERSTILength_NoLength &&
            sinfo->NBits      == 1 &&
            ! sinfo->Alignment &&
            _IsNotBounded(sinfo) &&
            sinfo->LConstraint== ePERSTIConstraint_Semiconstrained &&
            sinfo->LLowerVal  == 0 &&
            sinfo->LUpperVal  == 0);
}

int PerOptCase_IsTargetSeqOf(PERTypeInfo_t *info)
{
    return (
            // we only deal with singly linked-list case
            (info->Rules & eTypeRules_SinglyLinkedList)
            &&
            // check for size of sequence of/set of
            ((info->Root.LLowerVal == 0 && info->Root.LUpperVal == 0) ||
             (info->Root.LLowerVal < info->Root.LUpperVal)
            )
            &&
            // we do not deal with null body case
            (! (info->Root.SubType->Flags & eTypeFlags_Null))
            &&
            // we do not deal with recursive sequence of/set of
            (info->Root.SubType->PERTypeInfo.Root.Data != ePERSTIData_SequenceOf)
            &&
            (info->Root.SubType->PERTypeInfo.Root.Data != ePERSTIData_SetOf)
            &&
            // we only deal with sequence of or non-canonical set of.
            ((info->Root.Data == ePERSTIData_SequenceOf) ||
             (info->Root.Data == ePERSTIData_SetOf && g_eSubEncodingRule != eSubEncoding_Canonical))
           );
}


// UTILITIES

static int _IsNotBounded(PERSimpleTypeInfo_t *sinfo)
{
    return (sinfo->LowerVal.length      == 1 &&
            sinfo->LowerVal.value[0]    == 0 &&
            sinfo->UpperVal.length      == 1 &&
            sinfo->UpperVal.value[0]    == 0);
}

static int _IsUnsignedShortRange(PERSimpleTypeInfo_t *sinfo)
{
    return ((sinfo->UpperVal.length < 3 ) ||
            (sinfo->UpperVal.length == 3 && sinfo->UpperVal.value[0] == 0 &&
             ! _IsExtendedShortRange(sinfo)));
}


static int _IsExtendedShortRange(PERSimpleTypeInfo_t *sinfo)
{
    // if the lower bound is negative and the upper bound greater than 0x7FFF
    // then it is an extended short.
    return ((sinfo->LowerVal.length >= 1) &&
            (sinfo->LowerVal.value[0] & 0x80) && // lower bound is negative
            (sinfo->UpperVal.length == 3) &&
            (sinfo->UpperVal.value[0] == 0) &&  // upper bound is positive
            (*((ASN1uint16_t *) &(sinfo->UpperVal.value[1])) > 0x7FFF)); // upper bound greater than 0x7FFF

}



int BerOptCase_IsBoolean(BERTypeInfo_t *info)
{
    return (eBERSTIData_Boolean == info->Data && 1 == info->NOctets);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\precomp.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stddef.h>
#include <ctype.h>
#include <memory.h>

#define ASN1C

#include <windows.h>

// resolve conflicts
#ifdef GetObject
#undef GetObject
#endif

#include "libasn1.h"

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef _DEBUG
__inline void MyDebugBreak(void) { DebugBreak(); }
#define ASSERT(x)   if (!(x)) MyDebugBreak();
#else
#define ASSERT(x)   
#endif // _DEBUG


typedef ASN1uint8_t     uint8_t;
typedef ASN1uint16_t    uint16_t;
typedef ASN1uint32_t    uint32_t;
typedef ASN1int8_t      int8_t;
typedef ASN1int16_t     int16_t;
typedef ASN1int32_t     int32_t;
typedef ASN1octet_t octet_t;
typedef ASN1intx_t intx_t;
typedef ASN1real_e real_e;
typedef ASN1real_t real_t;
typedef ASN1octetstring_t octetstring_t;
typedef ASN1bitstring_t bitstring_t;
typedef ASN1char_t char_t;
typedef ASN1charstring_t charstring_t;
typedef ASN1ztcharstring_t ztcharstring_t;
typedef ASN1char16_t char16_t;
typedef ASN1char16string_t char16string_t;
typedef ASN1ztchar16string_t ztchar16string_t;
typedef ASN1char32_t char32_t;
typedef ASN1char32string_t char32string_t;
typedef ASN1ztchar32string_t ztchar32string_t;
typedef ASN1uint32_t objectnumber_t;
typedef ASN1objectidentifier_t objectidentifier_t;
typedef ASN1stringtableentry_t stringtableentry_t;
typedef ASN1stringtable_t stringtable_t;
typedef ASN1objectdescriptor_t objectdescriptor_t;
typedef ASN1generalizedtime_t generalizedtime_t;
typedef ASN1utctime_t utctime_t;
typedef ASN1external_t external_t;
#define intx_0 ASN1intx_0
#define intx_1 ASN1intx_1
#define intx_2 ASN1intx_2
#define intx_16 ASN1intx_16
#define intx_256 ASN1intx_256
#define intx_64K ASN1intx_64K
#define intx_1G ASN1intx_1G
#define NumericStringTable ASN1NumericStringTable;
#define intx_add ASN1intx_add
#define intx_addoctet ASN1intx_addoctet
#define intx_sub ASN1intx_sub
#define intx_suboctet ASN1intx_suboctet
#define intx_muloctet ASN1intx_muloctet
#define intx_inc ASN1intx_inc
#define intx_dec ASN1intx_dec
#define intx_neg ASN1intx_neg
#define intx_log2 ASN1intx_log2
#define intx_log256 ASN1intx_log256
#define intx_cmp ASN1intx_cmp
#define intx_dup ASN1intx_dup
#define intx_free ASN1intx_free
#define intx_setuint32 ASN1intx_setuint32
#define intx_setint32 ASN1intx_setint32
#define intx2uint64 ASN1intx2uint64
#define intx2int64 ASN1intx2int64
#define intx2uint32 ASN1intx2uint32
#define intx2int32 ASN1intx2int32
#define intx2uint16 ASN1intx2uint16
#define intx2int16 ASN1intx2int16
#define intx2uint8 ASN1intx2uint8
#define intx2int8 ASN1intx2int8
#define intxisuint64 ASN1intxisuint64
#define intxisint64 ASN1intxisint64
#define intxisuint32 ASN1intxisuint32
#define intxisint32 ASN1intxisint32
#define intxisuint16 ASN1intxisuint16
#define intxisint16 ASN1intxisint16
#define intxisuint8 ASN1intxisuint8
#define intxisint8 ASN1intxisint8
#define intx_octets ASN1intx_octets
#define intx_uoctets ASN1intx_uoctets
#define uint32_log2 ASN1uint32_log2
#define uint32_log256 ASN1uint32_log256
#define uint32_octets ASN1uint32_octets
#define uint32_uoctets ASN1uint32_uoctets
#define int32_octets ASN1int32_octets
#define intx2double ASN1intx2double
#define real2double ASN1real2double
#define intx2double ASN1intx2double
#define real2double ASN1real2double
#define double_minf ASN1double_minf
#define double_pinf ASN1double_pinf
#define double_isminf ASN1double_isminf
#define double_ispinf ASN1double_ispinf
#define generalizedtime2string ASN1generalizedtime2string
#define utctime2string ASN1utctime2string
#define string2generalizedtime ASN1string2generalizedtime
#define string2utctime ASN1string2utctime
#define real_free ASN1real_free
#define bitstring_free ASN1bitstring_free
#define octetstring_free ASN1octetstring_free
#define objectidentifier_free ASN1objectidentifier_free
#define charstring_free ASN1charstring_free
#define char16string_free ASN1char16string_free
#define char32string_free ASN1char32string_free
#define ztcharstring_free ASN1ztcharstring_free
#define ztchar16string_free ASN1ztchar16string_free
#define ztchar32string_free ASN1ztchar32string_free
#define external_free ASN1external_free
#define embeddedpdv_free ASN1embeddedpdv_free
#define characterstring_free ASN1characterstring_free
#define open_free ASN1open_free
#define bitstring_cmp ASN1bitstring_cmp
#define octetstring_cmp ASN1octetstring_cmp
#define objectidentifier_cmp ASN1objectidentifier_cmp
#define charstring_cmp ASN1charstring_cmp
#define char16string_cmp ASN1char16string_cmp
#define char32string_cmp ASN1char32string_cmp
#define ztcharstring_cmp ASN1ztcharstring_cmp
#define ztchar16string_cmp ASN1ztchar16string_cmp
#define ztchar32string_cmp ASN1ztchar32string_cmp
#define double_cmp double
#define real_cmp ASN1real_cmp
#define external_cmp ASN1external_cmp
#define embeddedpdv_cmp ASN1embeddedpdv_cmp
#define characterstring_cmp ASN1characterstring_cmp
#define open_cmp ASN1open_cmp
#define generalizedtime_cmp ASN1generalizedtime_cmp
#define utctime_cmp ASN1utctime_cmp
#define sequenceoflengthpointer_cmp
#define sequenceofsinglylinkedlist_cmp
#define sequenceofdoublylinkedlist_cmp
#define setoflengthpointer_cmp
#define setofsinglylinkedlist_cmp
#define setofdoublylinkedlist_cmp
#define is32space ASN1is32space
#define str32len ASN1str32len
#define is16space ASN1is16space
#define str16len ASN1str16len
#define bitcpy ASN1bitcpy
#define bitclr ASN1bitclr
#define bitset ASN1bitset
#define bitput ASN1bitput
#define octetput ASN1octetput


#include "defs.h"
#include "scanner.h"
#include "parser.h"
#include "builtin.h"
#include "write.h"
#include "error.h"
#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\scanner.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#include <unistd.h>

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

#include "hackdir.h"

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *      yyless( 5 );
 *  else
 *      do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        *yy_cp = yy_hold_char; \
        yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
        YY_DO_BEFORE_ACTION; /* set up yytext again */ \
        } \
    while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
    {
    FILE *yy_input_file;

    char *yy_ch_buf;        /* input buffer */
    char *yy_buf_pos;       /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    yy_size_t yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
    };

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;      /* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;     /* whether we need to initialize */
static int yy_start = 0;    /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_is_interactive = is_interactive; \
    }

#define yy_set_bol(at_bol) \
    { \
    if ( ! yy_current_buffer ) \
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
    yy_current_buffer->yy_at_bol = at_bol; \
    }

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
    yytext_ptr = yy_bp; \
    yyleng = (int) (yy_cp - yy_bp); \
    yy_hold_char = *yy_cp; \
    *yy_cp = '\0'; \
    yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 126
#define YY_END_OF_BUFFER 127
static yyconst short int yy_accept[722] =
    {   0,
        0,    0,    0,    0,  127,  125,  123,  123,  124,   89,
       96,  125,  125,   89,   89,   93,   93,   89,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,  100,  100,  100,
      100,  100,  100,  100,  121,  120,  105,  126,  121,  121,
      121,  121,  117,  121,  121,  123,  102,  101,    0,    0,
        0,  122,   92,   93,    0,    0,   98,   97,   97,   97,
       97,   97,   97,   99,   97,   97,   97,   97,   11,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   99,   99,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   99,

       97,   97,   58,   97,   99,   97,   97,   97,   99,   97,
       97,   97,   97,   97,   98,   97,   97,   97,   99,   97,
       97,   99,   97,   99,   97,    0,  100,  100,  100,  100,
      100,  100,  100,  121,  120,  104,  121,  121,  107,  121,
      121,  113,  121,  119,  121,  121,  121,  121,  115,    0,
      102,    0,  101,   94,   95,    0,  103,   91,   90,    0,
       97,    3,    4,   97,   97,    0,   97,    8,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   23,   97,   97,
       97,   97,   97,   97,   99,   99,   98,   97,   97,   97,
       97,   97,   97,   97,   48,   49,   97,   97,   99,   97,

       97,   97,   99,   60,   97,   97,   97,   99,   97,   97,
       67,   97,   97,   97,   98,   97,   97,   97,   99,   97,
       97,   97,   99,   97,   99,   99,   97,  100,  100,  100,
      100,  100,  100,  111,  121,  121,  121,    0,  121,  121,
      109,  121,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   31,   99,   99,   98,   97,   97,   97,
       97,   97,   97,   98,   97,   97,   97,   52,   99,   97,
       97,   97,   99,   97,   97,   97,   99,   65,   97,   68,
       97,   97,   98,   73,   75,   76,   99,   97,   97,   97,

       97,   98,   99,   97,   99,   99,   88,  100,  100,  100,
      100,   77,  100,  121,  121,  121,    0,  121,  121,  121,
       97,   97,   97,   97,    7,   99,   97,   97,   97,   14,
       97,   97,   97,   97,   97,   97,   97,   97,   97,   97,
       97,   30,   99,   99,   99,   97,   97,   97,   97,   97,
       97,   97,   98,   47,   97,   97,   99,   97,   57,   97,
       99,    0,   97,   97,   99,   97,   97,   97,   99,    0,
       99,   78,   97,   97,   99,   98,   99,   84,   99,   99,
       22,  100,  100,  100,   85,  121,  121,  121,    0,  121,
      121,    0,    1,   97,   97,   97,   99,   97,   97,   13,

       97,   97,   97,   97,   97,   97,   97,   25,   97,   97,
       97,   97,   99,   99,   99,   97,   97,   97,   97,   97,
       97,   97,   97,   98,    0,   97,   99,   55,   97,   99,
       97,   97,   97,   99,   97,   69,   71,   99,   97,   99,
       79,   97,   99,   99,   99,   99,   99,  100,   53,   70,
      121,    0,  121,    0,  121,  121,    0,   97,   97,   97,
       99,   10,   97,   97,   97,   18,   19,   97,   97,   97,
       97,   27,   97,   97,   99,   99,   99,   97,   97,   40,
       41,   97,   97,   44,   97,   98,   97,   97,   99,   97,
       99,   97,   62,   64,   99,   97,   99,   97,   99,   97,

       82,   99,   99,   99,   99,  100,    0,    0,    0,    0,
      116,    0,    0,   97,   97,   97,   99,   97,   97,   97,
       97,   21,   97,   26,   97,   29,   99,   99,   99,   99,
       97,   39,   42,   43,   97,   99,   97,   51,   99,   59,
       99,   97,   99,   66,   99,   97,   99,   97,   99,   99,
       99,   99,  100,    0,    0,    0,    0,    0,    0,    0,
       97,    6,    9,   12,   15,   97,   97,   97,   97,   99,
       99,   99,   35,   97,   97,   99,   97,   99,   99,   97,
       99,   72,   97,   99,   80,   99,   99,   99,   99,  100,
        0,    0,    0,    0,    0,    0,   97,   97,   16,   97,

       97,   24,   97,   99,   99,   99,   37,   97,   99,   97,
       99,   99,   97,   99,   97,   99,   83,   99,   99,   99,
       38,    0,    0,    0,  118,    0,    0,   97,    5,   17,
       20,   97,   99,   99,   99,   97,   99,   97,   99,   99,
       97,   99,   97,   99,   99,   99,   99,    0,  106,    0,
        0,    0,   97,   97,   99,   99,   99,   45,   46,   97,
       99,   99,   97,   99,   97,   99,   99,   99,   99,    0,
        0,    0,    0,   97,   28,   33,   99,   34,   97,   54,
       99,   61,   99,   97,   74,   99,   99,   87,    0,    0,
        0,    0,   97,   99,   50,   99,   99,   97,   99,   86,

        0,  112,    0,    0,    2,   32,   99,   63,   36,   81,
        0,    0,  114,   56,    0,    0,    0,    0,  110,  108,
        0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    4,    1,    1,    1,    1,
        1,    2,    5,    6,    1,    7,    1,    8,    9,   10,
       11,    1,    1,   12,   13,   14,    1,   15,   16,   17,
       17,   18,   19,   20,   17,   21,   17,   22,   23,   24,
       25,   26,    1,   27,   28,   29,   30,   31,   32,   33,
       34,   35,   36,   37,   38,   39,   40,   41,   42,   43,
       44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
       54,    1,   55,   56,    1,    1,   57,   58,   59,   60,

       61,   62,   63,   64,   65,   66,   67,   68,   69,   70,
       71,   72,   73,   74,   75,   76,   77,   78,   73,   79,
       80,   81,   82,   83,   84,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst int yy_meta[85] =
    {   0,
        1,    2,    2,    1,    1,    1,    1,    1,    2,    1,
        1,    1,    3,    1,    4,    4,    4,    4,    4,    4,
        4,    1,    1,    1,    1,    1,    1,    4,    4,    4,
        4,    4,    4,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    1,    1,    1,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    1,    1,    1
    } ;

static yyconst short int yy_base[729] =
    {   0,
        0,    0,   83,   97, 1486, 3743,   85,   87, 3743, 3743,
     3743,  151,   89, 1471, 1469, 3743,   96, 1449,  220,   89,
      273,  281,  294,  310,  311,  113,  334,  328,  349,  365,
      371,  386,  392,  418,  421,  444,  445, 1457,   80,   84,
       89,   94,   88,   81,    0,  121,    0, 1456,   35,   62,
       63,   68, 1397,   82,   87,  171, 1454, 1451,  302,   91,
     1445, 1446, 1437,  479, 1424,  472,  508,  475,  483,  533,
      534,  549,  555, 1434,  566,  572,  583,  594,  600,  616,
      622,  633,  646,  649,  662,  670,  673,  686,  164,  149,
      701,  704,  712,  727,  738,  753,  759,  770,  781,  234,

      794,  797,  810,  818,  109,  821,  834,  842,   95,  858,
      864,  875,  881,  892, 1429,  898,  909,  915,  262,  926,
      942,  261,  939,  306,  950, 1431, 1430,  133,  318,  263,
      232,  296,  315,    0,  334, 3743, 1372, 1362,    0, 1353,
     1360,    0, 1415,    0, 1357, 1351, 1347, 1339,    0, 1398,
     1396, 1392, 1391, 3743, 3743, 1363, 3743, 3743, 3743,    0,
      963,  974,  980,  991, 1002, 1383, 1013, 1019, 1030, 1036,
     1051, 1052, 1068, 1069, 1084, 1090, 1105, 1106, 1121, 1127,
     1138, 1144, 1155, 1166,  328,  312, 1348, 1179, 1182, 1190,
     1203, 1216, 1227, 1224, 1242, 1245, 1248, 1263,  335, 1266,

     1281, 1287,  348, 1298, 1304, 1315, 1326,  331, 1337, 1343,
     1354, 1360, 1371, 1377, 1344, 1388, 1394, 1409,  380, 1417,
     1433, 1434,  229, 1449,  390,  334, 1450,  373,  347,  374,
      357,  392,  330,    0, 1330, 1326, 1318, 1307, 1307, 1310,
        0, 1300, 1465, 1466, 1481, 1487, 1502, 1503, 1520, 1519,
     1535, 1541, 1552, 1563, 1574, 1580, 1595, 1598, 1606, 1619,
     1627, 1635, 1650, 1656,  429,  407, 1294, 1667, 1680, 1688,
     1691, 1709, 1706, 1350, 1717, 1732, 1738, 1753,  443, 1754,
     1769, 1780,  417, 1786, 1801, 1807,  430, 1818, 1824, 1835,
     1841, 1857, 1288, 1858, 1873, 1879,  452, 1890, 1896, 1911,

     1912, 1316,  441, 1932,  439,  424, 1933,  163,  454,  464,
      435, 1347,  506, 1291, 1297, 1277, 1280, 1273, 1280, 1329,
     1949, 1965, 1971, 1987, 1988,  494, 2004, 2010, 2025, 2026,
     2041, 2042, 2057, 2063, 2078, 2079, 2094, 2109, 2115, 2126,
     2132, 2147,  398,  462,  495, 2148, 2168, 2165, 2186, 2185,
     2203, 2202, 1320, 2218, 2224, 2235,  467, 2241, 2252, 2258,
      551, 2269, 2275, 2286,  476, 2297, 2303, 2314,  558, 2320,
      522, 2331, 2337, 2348,  465, 1262,  566, 2359,  552,  553,
     1323,  591,  572,  567, 1321, 1252, 1318, 1261, 1256, 1258,
     1238, 1241, 2365, 2380, 2383, 2386,  595, 2401, 2407, 2418,

     2424, 2440, 2446, 2461, 2467, 2484, 2483, 2499, 2500, 2515,
     2516, 2537,  557,  593,  603, 2538, 2553, 2559, 2570, 2576,
     2591, 2597, 2612, 1269, 2618, 2629,  621, 2635, 2651,  586,
     2652, 2667, 2680,  580, 2688, 2691, 2704,  641, 2715,  574,
     2712, 2728,  605,  597,  656,  634,  671,  636, 1299, 1295,
     1290, 1244, 1287, 1229, 1223, 1281, 1221, 2736, 2739, 2752,
      654, 2760, 2773, 2781, 2789, 2797, 2805, 2813, 2826, 2829,
     2842, 2853, 2859, 2870,  673,  691,  669, 2876, 2887, 2898,
     2904, 2915, 2921, 2936, 2937, 1204, 2952, 2953,  713, 2968,
      710, 2969, 2984, 2985,  694, 3002,  695, 3008,  741, 3024,

     1266,  670,  733,  735,  745,  750, 1210, 1199, 1190, 1185,
        0, 1192, 1184, 3025, 3040, 3041,  709, 3056, 3064, 3067,
     3080, 3088, 3101, 3109, 3117, 3125,  751,  765,  756,  771,
     3138, 3146, 3149, 3162, 3170,  780, 3173, 3186,  772, 3194,
      737, 3202,  782, 3210,  792, 3218,  776, 3226,  806,  748,
      784,  808,  795, 1189, 1178, 1178, 1182, 1176, 1171, 3234,
     3242, 3250, 1226, 3258, 3266, 3279, 3287, 3290, 3303,  793,
      828,  875, 1224, 3311, 3319,  763, 3332,  879,  866, 3335,
      867, 1223, 3343,  885, 3356,  882,  896,  923,  887,  902,
     1165, 1177, 1163, 1152, 1147, 1151, 3359, 3367, 3380, 3383,

     3391, 3404, 3412,  878,  812,  921, 3415, 3428,  881, 3436,
      947,  934, 3444,  951, 3452,  953, 1202,  957,  964,  960,
     1200, 1145, 1130, 1134, 3743, 1135, 1130, 3460, 3468, 3476,
     3484, 3492,  981,  855,  983, 3505,  992, 3513,  987,  971,
     3516,  994, 3529, 1013, 1011,  975, 1016, 1132, 3743, 1115,
     1128, 1131, 3537, 3540, 1001, 1022, 1003, 3557, 1169, 3560,
     1057, 1033, 3573, 1024, 3581, 1059, 1050, 1034, 1061, 1114,
     1111, 1098, 1079, 3598, 3599, 1139, 1088, 1130, 3614, 1129,
     1089, 3615, 1069, 3632,  988, 1093, 1108,  917,  906,  843,
      883,  742, 3631, 1090, 3647, 1128, 1115, 3648, 1127,  683,

      609, 3743,  523,  529, 3663,  477, 1123,  445, 3669,  423,
      262,  181, 3743,  231,  132,   96,   60,   58, 3743, 3743,
     3743, 3717, 3721, 3723, 3728, 3731, 3734, 3737
    } ;

static yyconst short int yy_def[729] =
    {   0,
      721,    1,  722,  722,  721,  721,  721,  721,  721,  721,
      721,  721,  723,  721,  721,  721,  721,  721,  721,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,  724,  724,  724,
      724,  724,  724,  724,  725,  725,  725,  721,  725,  725,
      725,  725,  725,  725,  725,  721,  726,  727,  723,  721,
      723,  721,  721,  721,  721,   19,   19,   19,   19,   19,
       19,   19,   19,  728,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,  728,  728,
       19,   19,   19,   19,   19,   19,   19,   19,   19,  728,

       19,   19,   19,   19,  728,   19,   19,   19,  728,   19,
       19,   19,   19,   19,   67,   19,   19,   19,  728,   19,
       19,  728,   19,  728,   19,  724,  724,  724,  724,  724,
      724,  724,  724,  725,  725,  721,  725,  725,  725,  725,
      725,  725,  725,  725,  725,  725,  725,  725,  725,  726,
      726,  727,  727,  721,  721,  721,  721,  721,  721,   67,
       19,   19,   19,   19,   19,  728,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,   67,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,  728,   19,

       19,   19,  728,   19,   19,   19,   19,  728,   19,   19,
       19,   19,   19,   19,   67,   19,   19,   19,  728,   19,
       19,   19,  728,   19,  728,  728,   19,  724,  724,  724,
      724,  724,  724,  725,  725,  725,  725,  721,  725,  725,
      725,  725,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,   67,   19,   19,   19,
       19,   19,   19,   67,   19,   19,   19,   19,  728,   19,
       19,   19,  728,   19,   19,   19,  728,   19,   19,   19,
       19,   19,   67,   19,   19,   19,  728,   19,   19,   19,

       19,   67,  728,   19,  728,  728,   19,  724,  724,  724,
      724,  724,  724,  725,  725,  725,  721,  725,  725,  725,
       19,   19,   19,   19,   19,  728,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,  728,  728,  728,   19,   19,   19,   19,   19,
       19,   19,   67,   19,   19,   19,  728,   19,   19,   19,
      728,   19,   19,   19,  728,   19,   19,   19,  728,   19,
      728,   19,   19,   19,  728,   67,  728,   19,  728,  728,
      724,  724,  724,  724,  724,  725,  725,  725,  721,  725,
      725,  721,   19,   19,   19,   19,  728,   19,   19,   19,

       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,  728,  728,  728,   19,   19,   19,   19,   19,
       19,   19,   19,   67,   19,   19,  728,   19,   19,  728,
       19,   19,   19,  728,   19,   19,   19,  728,   19,  728,
       19,   19,  728,  728,  728,  728,  728,  724,  724,  724,
      725,  721,  725,  721,  725,  725,  721,   19,   19,   19,
      728,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,  728,  728,  728,   19,   19,   19,
       19,   19,   19,   19,   19,   67,   19,   19,  728,   19,
      728,   19,   19,   19,  728,   19,  728,   19,  728,   19,

      728,  728,  728,  728,  728,  724,  721,  721,  721,  721,
      725,  721,  721,   19,   19,   19,  728,   19,   19,   19,
       19,   19,   19,   19,   19,   19,  728,  728,  728,  728,
       19,   19,   19,   19,   19,  728,   19,   19,  728,   19,
      728,   19,  728,   19,  728,   19,  728,   19,  728,  728,
      728,  728,  724,  721,  721,  721,  721,  721,  721,   19,
       19,   19,  728,   19,   19,   19,   19,   19,   19,  728,
      728,  728,  728,   19,   19,  728,   19,  728,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  724,
      721,  721,  721,  721,  721,  721,   19,   19,   19,   19,

       19,   19,   19,  728,  728,  728,   19,   19,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  728,
      724,  721,  721,  721,  721,  721,  721,   19,   19,   19,
       19,   19,  728,  728,  728,   19,  728,   19,  728,  728,
       19,  728,   19,  728,  728,  728,  728,  721,  721,  721,
      721,  721,   19,   19,  728,  728,  728,   19,  728,   19,
      728,  728,   19,  728,   19,  728,  728,  728,  728,  721,
      721,  721,  721,   19,   19,  728,  728,  728,   19,  728,
      728,   19,  728,   19,  728,  728,  728,  728,  721,  721,
      721,  721,   19,  728,   19,  728,  728,   19,  728,  728,

      721,  721,  721,  721,   19,  728,  728,  728,   19,  728,
      721,  721,  721,  728,  721,  721,  721,  721,  721,  721,
        0,  721,  721,  721,  721,  721,  721,  721
    } ;

static yyconst short int yy_nxt[3828] =
    {   0,
        6,    7,    8,    9,   10,   11,    6,   12,   13,   10,
       10,   10,   14,   15,   16,   17,   17,   17,   17,   17,
       17,   18,   10,   10,    6,   10,   10,   19,   20,   21,
       22,   23,   24,   25,   26,   27,   26,   26,   26,   28,
       29,   30,   31,   26,   32,   33,   34,   35,   36,   37,
       26,   26,   26,   10,   10,   10,   38,   38,   38,   38,
       39,   38,   38,   38,   40,   38,   38,   38,   38,   41,
       38,   38,   38,   38,   42,   43,   38,   44,   38,   38,
       38,   10,   10,   10,   46,   47,   56,   56,   56,   56,
       59,   59,  126,  126,   46,   48,  126,   60,   46,   47,

      126,  126,  137,   59,   59,  138,  126,  166,   46,   48,
       64,   64,   64,   64,   64,   64,   64,   68,  139,  154,
       75,  166,  135,  141,   76,  155,  140,   68,   77,   68,
       78,   68,  135,  720,  142,  719,   68,  133,  143,  144,
       79,   68,   49,  129,   50,  126,  146,  148,  128,  147,
       51,   68,   52,   68,   53,   68,   49,   54,   50,  208,
       68,  166,  149,   55,   51,  130,   52,  132,   53,  131,
      718,   54,   56,   56,  203,  126,  166,   55,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,

       57,   57,   57,   57,  228,  186,  717,   58,   58,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   58,   66,  185,   67,   67,   67,   67,   67,   67,
       67,  166,  381,  166,  126,  716,  166,   68,   69,   68,
       68,   68,   68,   68,   68,   68,   68,   68,   70,   68,
       71,   68,   72,   68,   68,   68,   68,   73,   68,   68,
       68,   68,   68,  166,  166,  126,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,

       74,   68,  199,   59,   59,  231,  303,   80,  126,   68,
       60,   81,   83,   68,   82,   68,   59,   59,  166,   68,
       68,   68,   68,   68,  166,  223,  715,  126,   68,  219,
      126,  230,   68,   84,   85,  135,   68,   87,   68,   68,
      166,   68,  126,  166,   86,  135,  166,  166,   68,   68,
       68,   68,   68,   68,   88,   96,   68,   68,   68,  126,
      166,   91,   68,   97,   92,  225,   68,  232,   68,  126,
       68,   89,   68,   93,   94,   68,   68,   68,  229,   95,
      226,   68,  233,  266,   90,  126,  126,   68,  265,   68,
       98,   68,  166,  101,  102,  279,   99,  103,  306,   68,

      287,  106,  166,   68,  126,   68,  313,  104,  283,  107,
      166,   68,   68,   68,   68,  108,  309,  110,   68,  166,
       68,  311,  105,  111,   68,  100,   68,  112,   68,  166,
       68,  310,   68,   68,   68,  166,  166,  115,  113,   68,
      297,  166,  166,  114,  109,  116,   68,  126,  308,   68,
      305,  166,  312,  166,  413,  166,   68,  166,   68,   68,
       68,  120,  117,   68,  166,   68,  126,  121,   68,  118,
      344,  123,   68,   68,  166,  361,  126,  166,  119,  166,
      125,  380,   68,   68,   68,   68,   68,   68,  166,  166,
      122,   68,   68,   64,   64,   64,   64,   64,   64,   64,

       68,  377,  343,   68,  384,  365,  166,  166,  124,  379,
       68,   68,   68,   68,   68,   68,  357,   68,  126,   68,
      160,   68,   68,   68,  383,   68,  414,  371,  161,  382,
       68,  427,  434,  443,  166,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   68,   68,  166,  166,  166,  385,  397,  415,  166,
      166,  162,   68,   68,   68,   68,   68,   68,  166,  126,
       68,   68,  440,   68,  126,  163,  166,   68,  713,   68,
      712,  164,  166,   68,   68,   68,   68,   68,  166,  167,

       68,  165,   68,  126,   68,  166,   68,  166,   68,  166,
       68,   68,   68,   68,   68,  166,  491,  166,  168,   68,
      447,   68,   68,   68,  475,  169,  430,  446,   68,  450,
       68,  438,   68,  166,   68,  170,   68,  495,   68,  445,
       68,   68,   68,  171,   68,  449,  166,   68,  126,  173,
       68,  476,  499,  166,   68,  448,   68,  172,   68,  461,
       68,   68,   68,   68,   68,  501,  166,  477,  166,   68,
      502,   68,  174,  175,   68,   68,  711,  177,  176,  489,
       68,  166,  166,  166,   68,  166,   68,   68,   68,   68,
       68,   68,  178,   68,  504,  166,   68,  506,   68,  180,

       68,   68,   68,  166,   68,  497,  166,  166,   68,  179,
       68,  183,  181,   68,   68,   68,  182,   68,  527,  187,
       68,  166,  166,  517,   68,  166,   68,  184,   68,   68,
      503,  505,   68,   68,  549,  188,  529,  528,  530,   68,
       68,   68,   68,   68,   68,  166,   68,  166,   68,  166,
       68,   68,   68,  166,  189,   68,  190,  166,  539,   68,
      166,  543,  126,  166,  545,   68,   68,   68,  166,   68,
      541,  563,  191,  192,   68,  166,   68,  166,   68,  193,
       68,   68,  194,  166,  166,   68,  547,   68,  166,  550,
      552,   68,  166,   68,  166,   68,  166,   68,   68,  196,

       68,   68,  704,  195,  166,  166,   68,  126,   68,   68,
       68,  579,   68,  551,  553,  587,  197,   68,  166,  198,
      166,   68,   68,   68,  166,   68,  570,  609,   68,  588,
      200,  572,   68,  573,   68,   68,   68,   68,   68,   68,
      166,   68,  581,  201,   68,  571,   68,  578,   68,   68,
       68,  584,   68,  576,  582,  590,   68,   68,   68,   68,
       68,   68,   68,   68,  202,   68,  604,  166,   68,  204,
       68,  634,   68,  206,   68,  586,   68,  207,  166,  166,
       68,  205,   68,  589,   68,  209,   68,  166,  605,   68,
      166,  166,   68,  166,  166,  703,   68,  166,   68,  166,

       68,  656,   68,   68,   68,   68,   68,  210,  166,   68,
      211,   68,  614,   68,  126,   68,  702,   68,  701,   68,
       68,   68,   68,   68,  612,  213,   68,  212,   68,  166,
       68,  216,  214,  166,   68,  166,   68,   68,   68,   68,
       68,  618,  633,   68,  617,   68,  166,   68,  606,   68,
      637,   68,  611,   68,   68,   68,  217,  218,  616,  166,
      620,  220,   68,  166,   68,  166,   68,   68,   68,  166,
       68,  221,  166,   68,  222,  621,  166,  224,   68,   68,
       68,   68,   68,  166,   68,  635,   68,  166,   68,   68,
       68,   68,   68,  166,  243,  166,  227,   68,  619,  166,

      166,   68,   68,   68,  166,   68,  166,  640,   68,  244,
       68,  639,   68,  166,   68,  166,   68,  644,   68,   68,
       68,   68,   68,  166,  647,  166,  642,   68,  166,  245,
       68,   68,  645,   68,  166,  662,  166,  646,   68,  668,
       68,   68,   68,  246,   68,  166,  166,   68,  247,   68,
      655,   68,  657,   68,  659,   68,  661,   68,   68,   68,
       68,   68,  166,  676,   68,  678,   68,  664,   68,  166,
       68,  166,   68,  166,  249,  248,   68,   68,   68,   68,
       68,  166,  666,   68,  667,  669,  677,  251,  683,   68,
       68,   68,   68,   68,   68,  250,   68,   68,   68,   68,

      166,  166,  166,  687,  681,  166,   68,   68,   68,   68,
       68,  253,   68,  252,  686,   68,   68,  255,   68,  680,
      166,  685,   68,  688,   68,  256,   68,  166,   68,  254,
       68,   68,   68,   68,   68,  166,  257,   68,  697,  166,
      166,  166,  166,   68,   68,   68,   68,   68,   68,   68,
      706,  166,   68,   68,  692,   68,  694,  691,  259,   68,
      258,   68,  699,   68,  696,   68,   68,   68,   68,   68,
      700,  690,   68,  689,   68,  262,  260,  708,   68,  261,
       68,  166,   68,   68,   68,   68,   68,  673,  672,  710,
      671,   68,  670,   68,   68,   68,  714,   68,  707,  652,

      263,  651,   68,  650,   68,  264,   68,   68,   68,  649,
       68,  648,  126,   68,  166,  627,  626,   68,   68,  268,
      269,   68,   68,  270,   68,  625,   68,  624,  271,   68,
       68,   68,   68,  623,  622,  166,  166,   68,  166,  596,
      595,   68,  594,   68,   68,   68,  274,  273,  593,  272,
       68,  592,   68,  591,   68,   68,   68,  559,   68,  558,
      557,  556,   68,   68,   68,   68,   68,   68,  275,   68,
       68,   68,  555,   68,   68,  277,   68,  554,  166,  536,
       68,  513,   68,   68,   68,   68,   68,   68,   68,   68,
       68,   68,  276,  512,   68,   68,  511,  280,  510,  509,

      508,  278,  507,   68,   68,   68,   68,  126,   68,   68,
       68,  126,  281,   68,  486,   68,  457,  456,  455,   68,
      454,   68,  282,   68,  453,   68,   68,   68,   68,   68,
      452,  451,   68,  126,   68,  126,   68,  444,   68,  424,
       68,  392,   68,   68,   68,   68,   68,  391,  390,  284,
      389,   68,  388,   68,   68,   68,  387,   68,  386,  126,
      285,  376,   68,  369,   68,   68,   68,  353,   68,  345,
      320,   68,  319,   68,  286,  288,  318,   68,  317,   68,
      316,   68,   68,   68,   68,   68,  315,  314,   68,  293,
      289,  290,   68,  267,   68,  166,   68,  155,   68,   68,

       68,   68,   68,  152,  152,   68,  291,   68,  150,   68,
      150,   68,  242,   68,  241,   68,   68,   68,   68,   68,
      240,  239,   68,  292,   68,  295,   68,  238,   68,  237,
       68,  236,   68,  294,   68,   68,   68,   68,  235,  234,
      296,   68,  126,  126,  215,   68,  166,   68,  159,   68,
      158,   68,  157,  156,  302,   68,   68,   68,  298,   68,
      299,   68,   68,  152,   68,  300,  150,  145,  136,  126,
       65,   68,   68,   68,   68,   68,   68,   68,   68,  301,
       68,   68,   63,   62,  307,  721,  721,   68,   68,   68,
       68,   68,   68,   68,   68,  721,  304,   68,  721,  721,

      721,  721,  721,   68,   68,  321,   68,   68,   68,   68,
      322,  721,   68,   68,  721,   68,  323,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  324,   68,   68,   68,
       68,   68,  721,  721,   68,  721,  721,  721,  721,  721,
       68,   68,  325,   68,   68,   68,  328,   68,   68,   68,
       68,  327,  721,  721,  721,  721,  721,   68,   68,   68,
       68,   68,   68,   68,  329,  721,   68,   68,  721,   68,
      721,  721,  721,   68,  721,   68,  721,   68,  326,   68,
       68,   68,   68,   68,  721,  721,  330,  721,   68,  721,
       68,   68,   68,  331,   68,  721,  721,  721,  721,   68,

      721,   68,   68,   68,  721,   68,  721,  721,   68,  332,
       68,  721,   68,  721,   68,  721,   68,  721,   68,  721,
      334,  333,   68,   68,  721,  335,   68,   68,  721,  336,
      721,  721,  721,   68,   68,   68,   68,   68,   68,  721,
       68,  721,   68,  721,   68,   68,   68,   68,  337,  721,
      721,  721,  721,   68,  338,   68,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,   68,   68,  721,   68,
      721,  339,  721,   68,   68,  340,  721,   68,   68,  341,
      721,  342,   68,  721,   68,  721,  721,  721,   68,  721,
       68,  721,   68,  721,   68,   68,   68,   68,   68,  721,

      721,  721,  721,   68,  721,   68,  721,   68,   68,   68,
      721,  721,  721,  346,   68,  347,   68,  721,   68,   68,
       68,  721,   68,  721,  721,  721,   68,   68,   68,   68,
       68,   68,  348,   68,   68,   68,  350,   68,  349,  351,
      721,  721,  721,  721,   68,   68,   68,   68,   68,   68,
      352,   68,  721,   68,  721,   68,   68,   68,  354,   68,
       68,  721,  721,  721,   68,  721,   68,  721,  721,  721,
       68,  721,   68,  721,   68,  721,   68,  355,   68,   68,
       68,   68,   68,  358,  356,   68,  721,  721,  721,  721,
      721,   68,   68,   68,   68,   68,   68,   68,  362,  721,

       68,   68,  721,  721,  721,  721,  721,   68,   68,   68,
      721,   68,  721,  721,   68,  359,   68,  721,   68,  721,
       68,  360,   68,  721,   68,  721,   68,   68,   68,   68,
      721,  721,  363,   68,  364,   68,  721,  721,  721,   68,
      721,   68,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,   68,  721,   68,  366,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
      721,  367,   68,   68,  368,   68,   68,  721,   68,  721,
      721,  370,  721,  721,  721,   68,   68,   68,   68,   68,

       68,   68,  721,  721,   68,   68,  721,   68,  721,  721,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
       68,   68,  721,  721,   68,  721,   68,  721,   68,  721,
      372,  721,   68,  721,   68,  721,   68,   68,   68,   68,
       68,  721,  374,  373,  721,  721,  721,  721,  721,   68,
       68,   68,   68,   68,   68,  721,  721,  721,   68,   68,
       68,   68,  721,  378,  721,  721,  721,  721,  721,  721,
       68,   68,   68,   68,   68,   68,  375,   68,  721,   68,
       68,  721,  721,  721,  721,  721,  721,   68,  721,   68,
      721,   68,  394,   68,  721,  393,   68,  721,  721,   68,

      395,  721,  721,   68,  721,   68,  721,   68,  721,   68,
      721,   68,   68,   68,  396,   68,   68,  721,   68,  721,
      721,  721,  721,  721,  721,   68,   68,   68,   68,   68,
       68,  398,   68,  721,   68,   68,  721,  721,   68,  399,
      721,  721,   68,  721,   68,  721,   68,  721,   68,  721,
       68,   68,   68,   68,   68,  721,  400,   68,  721,  721,
      721,  721,  721,   68,   68,   68,   68,   68,   68,   68,
       68,  721,   68,   68,  721,  721,  721,  721,  721,   68,
       68,  401,   68,   68,   68,   68,  402,  721,   68,   68,
      721,   68,  721,  721,  404,  403,  721,   68,  405,   68,

      721,   68,  721,   68,   68,   68,   68,   68,  406,  721,
       68,  721,  721,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,  407,  721,   68,   68,  721,  721,  721,
      721,  721,   68,  721,   68,  721,   68,   68,  409,  721,
      408,   68,  721,   68,  721,  721,  721,   68,  721,   68,
      721,   68,  721,   68,   68,   68,   68,   68,  721,  721,
       68,  410,   68,  721,   68,  721,   68,  721,   68,  721,
       68,  411,  412,   68,   68,   68,   68,  721,  721,   68,
      721,  721,  721,  416,  721,   68,   68,   68,   68,   68,
       68,  721,  721,   68,   68,   68,   68,  417,  721,  418,

      721,  721,  721,   68,  721,   68,   68,   68,   68,  721,
       68,  419,   68,   68,   68,   68,  420,  721,  721,  721,
      721,  721,  721,   68,   68,  421,   68,   68,   68,  721,
       68,   68,   68,   68,  422,  721,  425,  721,  721,  721,
       68,   68,   68,   68,   68,   68,   68,  423,  721,   68,
       68,  721,   68,  721,  721,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      426,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,   68,   68,  721,  721,   68,  428,   68,  721,
       68,  721,   68,  721,   68,  721,   68,   68,  429,   68,

       68,  721,  721,   68,  431,   68,  721,   68,  721,   68,
      721,   68,  721,   68,   68,  432,   68,   68,  721,  721,
      721,  721,   68,  721,   68,   68,   68,  721,   68,  721,
      721,   68,  433,   68,  721,   68,  436,  435,  721,   68,
      721,   68,   68,   68,   68,   68,  721,  721,   68,  721,
       68,  721,   68,  721,   68,  439,   68,  721,   68,   68,
       68,   68,   68,  721,  437,   68,  721,   68,  441,   68,
      721,   68,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,  721,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  442,   68,  721,   68,  721,   68,  721,   68,

      721,   68,  721,   68,  721,   68,   68,   68,   68,  458,
      459,   68,   68,  721,   68,  721,  721,  721,   68,  721,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       68,  721,  460,   68,  721,   68,  721,  721,  721,   68,
      721,  462,  721,   68,  721,   68,   68,   68,   68,   68,
      721,  721,   68,  463,   68,  464,   68,  721,   68,  721,
       68,  721,   68,  721,   68,   68,   68,  465,   68,  721,
      721,   68,  721,  721,   68,  721,  721,  721,   68,  721,
       68,  721,   68,  721,   68,  721,   68,   68,   68,   68,
      721,  467,  466,   68,  721,   68,  721,  721,  721,   68,

      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
      470,   68,   68,  468,   68,  469,  721,  721,  721,  721,
      721,   68,   68,   68,   68,   68,   68,   68,   68,  721,
       68,   68,  721,  721,  721,  471,  721,   68,   68,   68,
       68,   68,   68,   68,   68,  721,   68,   68,  721,  721,
      721,  473,  721,   68,   68,   68,   68,   68,   68,  721,
      472,  721,   68,   68,  474,   68,   68,  721,  721,  721,
      478,  721,  721,  721,  721,   68,   68,   68,   68,   68,
       68,   68,  721,  721,   68,   68,  721,   68,  479,  480,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,

       68,   68,  721,  721,   68,  721,   68,  482,   68,  721,
       68,  721,   68,  721,   68,  481,   68,   68,   68,   68,
      483,  721,  721,   68,  721,   68,  721,  721,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
       68,  484,  721,  485,   68,  721,   68,  721,  721,  721,
       68,  721,   68,  487,   68,  721,   68,   68,   68,   68,
       68,  721,  721,   68,  721,   68,  721,   68,  721,   68,
      488,   68,  721,   68,  721,   68,   68,   68,  490,   68,
       68,  721,   68,  721,  721,  721,  721,  721,  721,   68,
       68,   68,  492,   68,   68,   68,  721,  721,   68,   68,

      721,  721,  721,  721,  721,   68,  721,   68,   68,   68,
      721,  494,  721,  493,   68,  721,   68,  496,   68,   68,
       68,  721,   68,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,   68,  721,   68,  721,  721,   68,  721,
       68,  721,   68,   68,   68,  498,   68,  721,  721,  721,
       68,   68,   68,   68,   68,   68,   68,   68,  721,   68,
      721,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  721,  500,   68,   68,   68,   68,   68,   68,
       68,   68,  514,   68,  721,  515,   68,  516,   68,  721,
       68,  721,   68,  721,   68,  721,  721,  721,   68,   68,

       68,   68,   68,  721,  518,  721,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,  519,  721,   68,  520,   68,  721,   68,   68,   68,
      721,   68,  721,   68,  721,   68,   68,   68,  721,   68,
      721,   68,  721,   68,   68,   68,  721,   68,  521,  721,
      721,   68,   68,   68,   68,   68,  522,   68,  721,  721,
       68,  721,  721,  721,   68,  721,   68,   68,   68,   68,
       68,   68,  721,   68,  721,  523,   68,  721,  721,  721,
       68,   68,   68,  721,   68,  721,  721,  525,  524,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,

       68,   68,  721,  721,   68,  721,   68,  721,  526,  721,
       68,  531,   68,  721,   68,   68,   68,   68,   68,  721,
      721,  721,  721,   68,  721,   68,   68,   68,  721,   68,
      721,  721,   68,  532,   68,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,   68,   68,  721,  721,   68,
      721,   68,  534,   68,  721,   68,  721,   68,  721,   68,
      533,   68,   68,   68,   68,   68,  535,  721,   68,  721,
      721,  721,  721,  721,   68,   68,   68,   68,   68,   68,
       68,   68,  721,   68,   68,  721,  721,  721,  721,  721,
       68,   68,  537,  538,   68,   68,   68,   68,  721,   68,

       68,  542,  721,  721,  721,  721,  540,   68,   68,   68,
       68,   68,   68,   68,  721,   68,   68,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,  721,  721,
       68,   68,   68,  544,  721,  721,   68,  560,  721,  546,
       68,  721,   68,  721,   68,  721,   68,  721,   68,   68,
       68,  548,   68,   68,  721,   68,  721,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,   68,   68,
      562,   68,   68,  721,  721,  561,  721,  721,   68,   68,
       68,   68,   68,   68,   68,  721,  721,   68,   68,  721,
      721,  721,   68,  721,   68,   68,   68,  721,   68,  721,

      564,  721,   68,   68,   68,   68,   68,  566,   68,   68,
      565,   68,  721,  721,   68,  721,   68,  721,   68,  721,
       68,  567,   68,  721,  721,  721,   68,   68,   68,   68,
       68,  721,  568,  721,  721,   68,  721,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  721,   68,   68,   68,
      721,   68,  569,   68,  721,   68,   68,   68,  721,   68,
      721,  721,  721,   68,   68,   68,   68,   68,  721,  574,
      721,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,  721,  721,   68,   68,   68,   68,   68,   68,
       68,   68,  721,   68,  721,  721,   68,  721,   68,  721,

       68,   68,   68,  721,   68,  577,  721,  721,   68,   68,
       68,   68,   68,   68,   68,   68,  575,   68,  721,  721,
       68,  721,   68,  721,   68,  721,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  580,   68,  721,
       68,   68,   68,  721,   68,  721,   68,  721,   68,   68,
       68,  721,   68,  721,   68,  721,   68,   68,  583,  721,
       68,  721,   68,  721,  585,   68,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  721,   68,  597,
       68,   68,   68,  598,   68,  721,   68,  721,   68,   68,
       68,  721,   68,  721,   68,  721,   68,   68,   68,  721,

       68,  721,  721,  721,   68,   68,   68,   68,   68,  721,
      600,  599,  721,   68,  721,   68,  721,   68,   68,   68,
      602,   68,  721,  721,  721,   68,   68,  601,   68,   68,
       68,   68,   68,  721,   68,  721,  721,   68,  721,   68,
      721,  603,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,  721,   68,  608,  607,  721,   68,   68,   68,
       68,   68,  721,   68,  721,  721,   68,  610,  721,  721,
       68,   68,   68,   68,   68,  613,  721,   68,  721,   68,
      721,   68,   68,   68,   68,   68,  721,   68,  721,  615,
       68,  721,  721,  721,   68,   68,   68,   68,   68,   68,

      721,   68,  721,   68,  721,   68,   68,  629,   68,   68,
      628,   68,  721,  630,   68,  721,  721,  721,   68,   68,
       68,   68,   68,   68,  721,   68,  721,   68,  721,   68,
       68,   68,   68,   68,  721,  721,  631,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  632,  721,  721,
       68,   68,   68,   68,   68,   68,   68,   68,  721,   68,
      721,  721,   68,  721,   68,  721,   68,  721,   68,  636,
       68,  721,   68,  721,   68,   68,  638,  721,   68,  641,
       68,  721,   68,   68,   68,  721,   68,  643,   68,  721,
       68,   68,   68,  721,   68,  721,   68,  721,   68,   68,

      653,  721,   68,  721,   68,  721,   68,   68,   68,  721,
       68,  721,   68,  721,   68,   68,   68,  721,   68,  721,
       68,  721,   68,   68,   68,  721,   68,  721,  721,  721,
       68,   68,   68,   68,   68,  721,  721,  721,  654,   68,
      721,   68,  721,   68,   68,  658,  721,   68,  660,  721,
      721,   68,   68,   68,   68,   68,   68,   68,   68,  721,
       68,  665,  663,   68,  721,   68,  721,   68,   68,   68,
      721,   68,  721,  721,  721,   68,   68,   68,   68,   68,
       68,  721,   68,  674,   68,   68,  721,   68,   68,  721,
      721,  675,  721,  721,  721,   68,  721,   68,   68,   68,

       68,   68,   68,  721,   68,  721,  679,   68,  721,   68,
      721,   68,  721,   68,  721,   68,  684,  721,  721,   68,
       68,   68,  721,   68,  682,  693,   68,   68,   68,  721,
      721,  721,  721,  721,  721,  721,   68,   68,   68,   68,
       68,   68,   68,   68,  721,   68,   68,  721,  721,  721,
      721,  721,   68,   68,   68,   68,   68,   68,  721,   68,
       68,   68,   68,  698,  721,  695,  721,  721,  721,   68,
       68,   68,   68,   68,   68,   68,   68,  721,   68,   68,
      721,  705,  721,  721,  721,   68,   68,   68,   68,   68,
       68,   68,  709,  721,   68,   68,  721,   68,  721,  721,

      721,   68,  721,   68,  721,   68,  721,   68,  721,   68,
       68,   68,  721,  721,  721,  721,   68,   45,   45,   45,
       45,   45,   61,  721,   61,  127,  127,  127,  134,  134,
      721,  134,  134,  151,  151,  151,  153,  153,  153,   74,
       74,   74,    5,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,

      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721
    } ;

static yyconst short int yy_chk[3828] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    3,    3,    7,    7,    8,    8,
       13,   13,   39,   44,    3,    3,   40,   13,    4,    4,

       43,   41,   49,   13,   13,   49,   42,  109,    4,    4,
       17,   17,   17,   17,   17,   17,   17,   20,   50,   60,
       20,  105,   46,   51,   20,   60,   50,   20,   20,   20,
       20,   20,   46,  718,   51,  717,   20,   44,   52,   52,
       20,   26,    3,   40,    3,  128,   54,   55,   39,   54,
        3,   26,    3,   26,    3,   26,    4,    3,    4,  109,
       26,   90,   55,    3,    4,   41,    4,   43,    4,   42,
      716,    4,   56,   56,  105,  308,   89,    4,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,

       12,   12,   12,   12,  128,   90,  715,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   19,   89,   19,   19,   19,   19,   19,   19,
       19,  223,  308,  714,  131,  712,  100,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,  122,  119,  130,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,

       19,   21,  100,   59,   59,  131,  223,   21,  132,   22,
       59,   21,   22,   21,   21,   21,   59,   59,  124,   22,
       21,   22,   23,   22,  186,  122,  711,  133,   22,  119,
      129,  130,   23,   23,   23,  135,   23,   24,   24,   25,
      185,   23,  233,  208,   23,  135,  226,  199,   24,   25,
       24,   25,   24,   25,   24,   28,   28,   24,   25,  229,
      203,   27,   27,   28,   27,  124,   28,  132,   28,  231,
       28,   25,   27,   27,   27,   28,   27,   29,  129,   27,
      124,   27,  133,  186,   25,  228,  230,   29,  185,   29,
       29,   29,  219,   30,   30,  199,   29,   30,  226,   31,

      208,   31,  225,   30,  232,   30,  233,   30,  203,   31,
      343,   31,   30,   31,   32,   31,  229,   32,   31,  266,
       33,  231,   30,   33,   32,   29,   32,   33,   32,  283,
       33,  230,   33,   32,   33,  710,  306,   34,   33,   33,
      219,  265,  287,   33,   31,   34,   34,  311,  228,   35,
      225,  305,  232,  303,  343,  279,   34,  708,   34,   35,
       34,   35,   34,   35,  297,   34,  309,   35,   35,   34,
      266,   36,   36,   37,  344,  283,  310,  375,   34,  357,
       37,  306,   36,   37,   36,   37,   36,   37,  365,  706,
       35,   36,   37,   64,   64,   64,   64,   64,   64,   64,

       66,  303,  265,   68,  311,  287,  326,  345,   36,  305,
       66,   69,   66,   68,   66,   68,  279,   68,  313,   66,
       67,   69,   68,   69,  310,   69,  344,  297,   69,  309,
       69,  357,  365,  375,  371,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   67,
       67,   70,   71,  361,  379,  380,  313,  326,  345,  413,
      369,   70,   71,   70,   71,   70,   71,   72,  377,  384,
       70,   71,  371,   73,  383,   71,  440,   72,  704,   72,
      703,   72,  434,   73,   75,   73,   72,   73,  430,   75,

       76,   73,   73,  382,   75,  414,   75,  397,   75,  444,
       76,   77,   76,   75,   76,  415,  430,  443,   76,   76,
      380,   77,   78,   77,  413,   77,  361,  379,   79,  384,
       77,  369,   78,  427,   78,   78,   78,  434,   79,  377,
       79,   78,   79,   80,   80,  383,  446,   79,  448,   81,
       81,  414,  440,  438,   80,  382,   80,   80,   80,  397,
       81,   82,   81,   80,   81,  443,  461,  415,  445,   81,
      444,   82,   82,   82,   83,   82,  701,   84,   83,  427,
       82,  477,  502,  447,   83,  475,   83,   84,   83,   84,
       85,   84,   85,   83,  446,  700,   84,  448,   86,   86,

       85,   87,   85,  476,   85,  438,  495,  497,   86,   85,
       86,   87,   86,   87,   88,   87,   86,   86,  475,   91,
       87,  517,  491,  461,   88,  489,   88,   88,   88,   91,
      445,  447,   92,   88,  502,   92,  476,  475,  477,   91,
       93,   91,   92,   91,   92,  503,   92,  504,   91,  541,
       93,   92,   93,  499,   93,   94,   94,  505,  489,   93,
      550,  495,  506,  527,  497,   94,   95,   94,  529,   94,
      491,  517,   94,   94,   94,  576,   95,  528,   95,   95,
       95,   96,   96,  530,  539,   95,  499,   97,  547,  503,
      505,   96,  536,   96,  543,   96,  551,   97,   98,   97,

       96,   97,  692,   96,  545,  570,   97,  553,   98,   99,
       98,  541,   98,  504,  506,  550,   98,   98,  549,   99,
      552,   99,  101,   99,  605,  102,  527,  576,   99,  551,
      101,  529,  101,  530,  101,  102,  101,  102,  103,  102,
      571,  101,  543,  102,  102,  528,  104,  539,  103,  106,
      103,  547,  103,  536,  545,  553,  104,  103,  104,  106,
      104,  106,  107,  106,  104,  104,  570,  634,  106,  106,
      108,  605,  107,  108,  107,  549,  107,  108,  579,  581,
      108,  107,  108,  552,  108,  110,  110,  572,  571,  108,
      604,  578,  111,  609,  586,  691,  110,  584,  110,  589,

      110,  634,  111,  112,  111,  110,  111,  111,  587,  113,
      111,  111,  581,  112,  590,  112,  690,  112,  689,  113,
      114,  113,  112,  113,  579,  113,  116,  112,  113,  688,
      114,  116,  114,  606,  114,  588,  116,  117,  116,  114,
      116,  587,  604,  118,  586,  116,  612,  117,  572,  117,
      609,  117,  578,  118,  120,  118,  117,  118,  584,  611,
      589,  120,  118,  614,  120,  616,  120,  123,  120,  618,
      121,  121,  620,  120,  121,  590,  619,  123,  125,  123,
      121,  123,  121,  640,  121,  606,  123,  646,  125,  121,
      125,  161,  125,  633,  161,  635,  125,  125,  588,  639,

      685,  161,  162,  161,  637,  161,  642,  612,  163,  161,
      161,  611,  162,  655,  162,  657,  162,  616,  163,  164,
      163,  162,  163,  645,  620,  644,  614,  163,  647,  164,
      165,  164,  618,  164,  656,  640,  664,  619,  164,  646,
      165,  167,  165,  165,  165,  662,  668,  168,  167,  165,
      633,  167,  635,  167,  637,  167,  639,  168,  169,  168,
      167,  168,  667,  655,  170,  657,  168,  642,  169,  661,
      169,  666,  169,  669,  170,  169,  170,  169,  170,  171,
      172,  683,  644,  170,  645,  647,  656,  172,  664,  171,
      172,  171,  172,  171,  172,  171,  173,  174,  171,  172,

      677,  681,  694,  668,  662,  686,  173,  174,  173,  174,
      173,  174,  175,  173,  667,  173,  174,  176,  176,  661,
      687,  666,  175,  669,  175,  176,  175,  697,  176,  175,
      176,  175,  176,  177,  178,  707,  177,  176,  683,  699,
      696,  680,  678,  177,  178,  177,  178,  177,  178,  179,
      694,  676,  177,  178,  673,  180,  677,  672,  180,  179,
      179,  179,  686,  179,  681,  180,  181,  180,  179,  180,
      687,  671,  182,  670,  180,  182,  181,  697,  181,  181,
      181,  659,  182,  183,  182,  181,  182,  652,  651,  699,
      650,  182,  648,  183,  184,  183,  707,  183,  696,  627,

      183,  626,  183,  624,  184,  184,  184,  188,  184,  623,
      189,  622,  621,  184,  617,  596,  595,  188,  190,  188,
      189,  188,  189,  189,  189,  594,  188,  593,  190,  189,
      190,  191,  190,  592,  591,  582,  573,  190,  563,  559,
      558,  191,  557,  191,  192,  191,  193,  192,  556,  191,
      191,  555,  194,  554,  192,  193,  192,  513,  192,  512,
      510,  509,  194,  192,  194,  193,  194,  193,  194,  193,
      195,  194,  508,  196,  193,  197,  197,  507,  501,  486,
      195,  457,  195,  196,  195,  196,  197,  196,  197,  195,
      197,  198,  196,  456,  200,  197,  455,  200,  454,  453,

      452,  198,  451,  198,  200,  198,  200,  450,  200,  201,
      198,  449,  201,  200,  424,  202,  392,  391,  390,  201,
      389,  201,  202,  201,  388,  202,  204,  202,  201,  202,
      387,  386,  205,  385,  202,  381,  204,  376,  204,  353,
      204,  320,  205,  206,  205,  204,  205,  319,  318,  205,
      317,  205,  316,  206,  207,  206,  315,  206,  314,  312,
      206,  302,  206,  293,  207,  209,  207,  274,  207,  267,
      242,  210,  240,  207,  207,  209,  239,  209,  238,  209,
      237,  210,  211,  210,  209,  210,  236,  235,  212,  215,
      210,  212,  211,  187,  211,  166,  211,  156,  212,  213,

      212,  211,  212,  153,  152,  214,  213,  212,  151,  213,
      150,  213,  148,  213,  147,  214,  216,  214,  213,  214,
      146,  145,  217,  214,  214,  217,  216,  143,  216,  141,
      216,  140,  217,  216,  217,  216,  217,  218,  138,  137,
      218,  217,  127,  126,  115,  220,   74,  218,   65,  218,
       63,  218,   62,   61,  222,  220,  218,  220,  220,  220,
      220,  221,  222,   58,  220,  220,   57,   53,   48,   38,
       18,  221,  222,  221,  222,  221,  222,  224,  227,  221,
      221,  222,   15,   14,  227,    5,    0,  224,  227,  224,
      227,  224,  227,  243,  244,    0,  224,  227,    0,    0,

        0,    0,    0,  243,  244,  243,  244,  243,  244,  245,
      244,    0,  243,  244,    0,  246,  245,    0,    0,  245,
        0,  245,    0,  245,    0,  246,  246,  246,  245,  246,
      247,  248,    0,    0,  246,    0,    0,    0,    0,    0,
      247,  248,  247,  248,  247,  248,  250,  250,  249,  247,
      248,  249,    0,    0,    0,    0,    0,  250,  249,  250,
      249,  250,  249,  251,  251,    0,  250,  249,    0,  252,
        0,    0,    0,  251,    0,  251,    0,  251,  248,  252,
      253,  252,  251,  252,    0,    0,  252,    0,  252,    0,
      253,  254,  253,  253,  253,    0,    0,    0,    0,  253,

        0,  254,  255,  254,    0,  254,    0,    0,  256,  254,
      254,    0,  255,    0,  255,    0,  255,    0,  256,    0,
      256,  255,  256,  257,    0,  257,  258,  256,    0,  258,
        0,    0,    0,  257,  259,  257,  258,  257,  258,    0,
      258,    0,  257,    0,  259,  258,  259,  260,  259,    0,
        0,    0,    0,  259,  260,  261,    0,  260,    0,  260,
        0,  260,    0,  262,    0,  261,  260,  261,    0,  261,
        0,  261,    0,  262,  261,  262,    0,  262,  263,  262,
        0,  263,  262,    0,  264,    0,    0,    0,  263,    0,
      263,    0,  263,    0,  264,  268,  264,  263,  264,    0,

        0,    0,    0,  264,    0,  268,    0,  268,  269,  268,
        0,    0,    0,  268,  268,  269,  270,    0,  269,  271,
      269,    0,  269,    0,    0,    0,  270,  269,  270,  271,
      270,  271,  270,  271,  273,  270,  272,  272,  271,  273,
        0,    0,    0,    0,  273,  275,  273,  272,  273,  272,
      273,  272,    0,  273,    0,  275,  272,  275,  275,  275,
      276,    0,    0,    0,  275,    0,  277,    0,    0,    0,
      276,    0,  276,    0,  276,    0,  277,  276,  277,  276,
      277,  278,  280,  280,  277,  277,    0,    0,    0,    0,
        0,  278,  280,  278,  280,  278,  280,  281,  284,    0,

      278,  280,    0,    0,    0,    0,    0,  281,  282,  281,
        0,  281,    0,    0,  284,  281,  281,    0,  282,    0,
      282,  282,  282,    0,  284,    0,  284,  282,  284,  285,
        0,    0,  285,  284,  286,  286,    0,    0,    0,  285,
        0,  285,    0,  285,    0,  286,  288,  286,  285,  286,
        0,    0,  289,    0,  286,  289,  288,    0,  288,    0,
      288,    0,  289,  290,  289,  288,  289,    0,    0,  291,
        0,  289,    0,  290,    0,  290,    0,  290,    0,  291,
        0,  291,  290,  291,  292,  292,  294,    0,  291,    0,
        0,  296,    0,    0,    0,  292,  294,  292,  294,  292,

      294,  295,    0,    0,  292,  294,    0,  296,    0,    0,
        0,  295,    0,  295,    0,  295,    0,  296,  298,  296,
      295,  296,    0,    0,  299,    0,  296,    0,  298,    0,
      298,    0,  298,    0,  299,    0,  299,  298,  299,  300,
      301,    0,  300,  299,    0,    0,    0,    0,    0,  300,
      301,  300,  301,  300,  301,    0,    0,    0,  300,  301,
      304,  307,    0,  304,    0,    0,    0,    0,    0,    0,
      304,  307,  304,  307,  304,  307,  301,  321,    0,  304,
      307,    0,    0,    0,    0,    0,    0,  321,    0,  321,
        0,  321,  322,  322,    0,  321,  321,    0,    0,  323,

      323,    0,    0,  322,    0,  322,    0,  322,    0,  323,
        0,  323,  322,  323,  324,  324,  325,    0,  323,    0,
        0,    0,    0,    0,    0,  324,  325,  324,  325,  324,
      325,  327,  327,    0,  324,  325,    0,    0,  328,  328,
        0,    0,  327,    0,  327,    0,  327,    0,  328,    0,
      328,  327,  328,  329,  330,    0,  329,  328,    0,    0,
        0,    0,    0,  329,  330,  329,  330,  329,  330,  331,
      332,    0,  329,  330,    0,    0,    0,    0,    0,  331,
      332,  331,  332,  331,  332,  333,  332,    0,  331,  332,
        0,  334,    0,    0,  334,  333,    0,  333,  334,  333,

        0,  334,    0,  334,  333,  334,  335,  336,  335,    0,
      334,    0,    0,    0,    0,    0,  335,  336,  335,  336,
      335,  336,  337,  336,    0,  335,  336,    0,    0,    0,
        0,    0,  337,    0,  337,    0,  337,  338,  338,    0,
      337,  337,    0,  339,    0,    0,    0,  338,    0,  338,
        0,  338,    0,  339,  340,  339,  338,  339,    0,    0,
      341,  339,  339,    0,  340,    0,  340,    0,  340,    0,
      341,  340,  341,  340,  341,  342,  346,    0,    0,  341,
        0,    0,    0,  346,    0,  342,  346,  342,  346,  342,
      346,    0,    0,  348,  342,  346,  347,  347,    0,  347,

        0,    0,    0,  348,    0,  348,  347,  348,  347,    0,
      347,  348,  348,  350,  349,  347,  349,    0,    0,    0,
        0,    0,    0,  350,  349,  350,  349,  350,  349,    0,
      352,  351,  350,  349,  351,    0,  355,    0,    0,    0,
      352,  351,  352,  351,  352,  351,  354,  352,    0,  352,
      351,    0,  355,    0,    0,    0,  354,    0,  354,    0,
      354,    0,  355,  356,  355,  354,  355,    0,    0,  358,
      356,  355,    0,  356,    0,  356,    0,  356,    0,  358,
      359,  358,  356,  358,    0,    0,  360,  358,  358,    0,
      359,    0,  359,    0,  359,    0,  360,  362,  360,  359,

      360,    0,    0,  363,  362,  360,    0,  362,    0,  362,
        0,  362,    0,  363,  364,  363,  362,  363,    0,    0,
        0,    0,  363,    0,  364,  366,  364,    0,  364,    0,
        0,  367,  364,  364,    0,  366,  367,  366,    0,  366,
        0,  367,  368,  367,  366,  367,    0,    0,  370,    0,
      367,    0,  368,    0,  368,  370,  368,    0,  370,  372,
      370,  368,  370,    0,  368,  373,    0,  370,  373,  372,
        0,  372,    0,  372,    0,  373,  374,  373,  372,  373,
        0,    0,    0,    0,  373,    0,  374,  378,  374,    0,
      374,    0,  374,  393,    0,  374,    0,  378,    0,  378,

        0,  378,    0,  393,    0,  393,  378,  393,  394,  394,
      395,  395,  393,    0,  396,    0,    0,    0,  394,    0,
      394,  395,  394,  395,  396,  395,  396,  394,  396,  398,
      395,    0,  396,  396,    0,  399,    0,    0,    0,  398,
        0,  398,    0,  398,    0,  399,  400,  399,  398,  399,
        0,    0,  401,  399,  399,  401,  400,    0,  400,    0,
      400,    0,  401,    0,  401,  400,  401,  402,  402,    0,
        0,  401,    0,    0,  403,    0,    0,    0,  402,    0,
      402,    0,  402,    0,  403,    0,  403,  402,  403,  404,
        0,  404,  403,  403,    0,  405,    0,    0,    0,  404,

        0,  404,    0,  404,    0,  405,    0,  405,  404,  405,
      407,  407,  406,  405,  405,  406,    0,    0,    0,    0,
        0,  407,  406,  407,  406,  407,  406,  408,  409,    0,
      407,  406,    0,    0,    0,  409,    0,  408,  409,  408,
      409,  408,  409,  410,  411,    0,  408,  409,    0,    0,
        0,  411,    0,  410,  411,  410,  411,  410,  411,    0,
      410,    0,  410,  411,  412,  412,  416,    0,    0,    0,
      416,    0,    0,    0,    0,  412,  416,  412,  416,  412,
      416,  417,    0,    0,  412,  416,    0,  418,  417,  418,
        0,  417,    0,  417,    0,  417,    0,  418,  419,  418,

      417,  418,    0,    0,  420,    0,  418,  420,  419,    0,
      419,    0,  419,    0,  420,  419,  420,  419,  420,  421,
      421,    0,    0,  420,    0,  422,    0,    0,    0,  421,
        0,  421,    0,  421,    0,  422,    0,  422,  421,  422,
      423,  422,    0,  423,  422,    0,  425,    0,    0,    0,
      423,    0,  423,  425,  423,    0,  425,  426,  425,  423,
      425,    0,    0,  428,    0,  425,    0,  426,    0,  426,
      426,  426,    0,  428,    0,  428,  426,  428,  429,  429,
      431,    0,  428,    0,    0,    0,    0,    0,    0,  429,
      431,  429,  431,  429,  431,  432,    0,    0,  429,  431,

        0,    0,    0,    0,    0,  432,    0,  432,  433,  432,
        0,  433,    0,  432,  432,    0,  435,  435,  433,  436,
      433,    0,  433,    0,    0,    0,  435,  433,  435,  436,
      435,  436,  437,  436,    0,  435,    0,    0,  436,    0,
      441,    0,  437,  439,  437,  439,  437,    0,    0,    0,
      441,  437,  441,  439,  441,  439,  442,  439,    0,  441,
        0,    0,  439,    0,  458,    0,  442,  459,  442,    0,
      442,    0,    0,  442,  458,  442,  458,  459,  458,  459,
      460,  459,  458,  458,    0,  459,  459,  460,  462,    0,
      460,    0,  460,    0,  460,    0,    0,    0,  462,  460,

      462,  463,  462,    0,  463,    0,    0,  462,    0,  464,
        0,  463,    0,  463,    0,  463,    0,  465,    0,  464,
      463,  464,    0,  464,  465,  466,    0,  465,  464,  465,
        0,  465,    0,  467,    0,  466,  465,  466,    0,  466,
        0,  468,    0,  467,  466,  467,    0,  467,  468,    0,
        0,  468,  467,  468,  469,  468,  469,  470,    0,    0,
      468,    0,    0,    0,  469,    0,  469,  470,  469,  470,
      471,  470,    0,  469,    0,  470,  470,    0,    0,    0,
      471,  472,  471,    0,  471,    0,    0,  473,  471,  471,
        0,  472,    0,  472,    0,  472,    0,  473,  474,  473,

      472,  473,    0,    0,  478,    0,  473,    0,  474,    0,
      474,  478,  474,    0,  478,  479,  478,  474,  478,    0,
        0,    0,    0,  478,    0,  479,  480,  479,    0,  479,
        0,    0,  481,  479,  479,    0,  480,    0,  480,    0,
      480,    0,  481,  482,  481,  480,  481,    0,    0,  483,
        0,  481,  483,  482,    0,  482,    0,  482,    0,  483,
      482,  483,  482,  483,  484,  485,  485,    0,  483,    0,
        0,    0,    0,    0,  484,  485,  484,  485,  484,  485,
      487,  488,    0,  484,  485,    0,    0,    0,    0,    0,
      487,  488,  487,  488,  487,  488,  490,  492,    0,  487,

      488,  492,    0,    0,    0,    0,  490,  492,  490,  492,
      490,  492,  493,  494,    0,  490,  492,    0,    0,    0,
        0,    0,  493,  494,  493,  494,  493,  494,    0,    0,
      496,  493,  494,  496,    0,    0,  498,  514,    0,  498,
      496,    0,  496,    0,  496,    0,  498,    0,  498,  496,
      498,  500,  500,  514,    0,  498,    0,    0,    0,    0,
        0,    0,  500,  514,  500,  514,  500,  514,  515,  516,
      516,  500,  514,    0,    0,  515,    0,    0,  515,  516,
      515,  516,  515,  516,  518,    0,    0,  515,  516,    0,
        0,    0,  519,    0,  518,  520,  518,    0,  518,    0,

      518,    0,  519,  518,  519,  520,  519,  520,  521,  520,
      519,  519,    0,    0,  520,    0,  522,    0,  521,    0,
      521,  521,  521,    0,    0,    0,  522,  521,  522,  523,
      522,    0,  523,    0,    0,  522,    0,  524,    0,  523,
        0,  523,    0,  523,    0,  525,    0,  524,  523,  524,
        0,  524,  525,  526,    0,  525,  524,  525,    0,  525,
        0,    0,    0,  526,  525,  526,  531,  526,    0,  531,
        0,    0,  526,    0,  532,    0,  531,  533,  531,    0,
      531,    0,    0,    0,  532,  531,  532,  533,  532,  533,
      534,  533,    0,  532,    0,    0,  533,    0,  535,    0,

      534,  537,  534,    0,  534,  537,    0,    0,  535,  534,
      535,  537,  535,  537,  538,  537,  535,  535,    0,    0,
      537,    0,  540,    0,  538,    0,  538,    0,  538,    0,
      542,    0,  540,  538,  540,    0,  540,  542,  544,    0,
      542,  540,  542,    0,  542,    0,  546,    0,  544,  542,
      544,    0,  544,    0,  548,    0,  546,  544,  546,    0,
      546,    0,  560,    0,  548,  546,  548,    0,  548,    0,
      561,    0,  560,  548,  560,    0,  560,    0,  562,  560,
      561,  560,  561,  561,  561,    0,  564,    0,  562,  561,
      562,    0,  562,    0,  565,    0,  564,  562,  564,    0,

      564,    0,    0,    0,  565,  564,  565,  566,  565,    0,
      566,  565,    0,  565,    0,  567,    0,  566,  568,  566,
      568,  566,    0,    0,    0,  567,  566,  567,  568,  567,
      568,  569,  568,    0,  567,    0,    0,  568,    0,  574,
        0,  569,    0,  569,    0,  569,    0,  575,    0,  574,
      569,  574,    0,  574,  575,  574,    0,  575,  574,  575,
      577,  575,    0,  580,    0,    0,  575,  577,    0,    0,
      577,  583,  577,  580,  577,  580,    0,  580,    0,  577,
        0,  583,  580,  583,  585,  583,    0,  597,    0,  583,
      583,    0,    0,    0,  585,  598,  585,  597,  585,  597,

        0,  597,    0,  585,    0,  598,  597,  598,  599,  598,
      597,  600,    0,  600,  598,    0,    0,    0,  599,  601,
      599,  600,  599,  600,    0,  600,    0,  599,    0,  601,
      600,  601,  602,  601,    0,    0,  601,    0,  601,    0,
      603,    0,  602,  607,  602,    0,  602,  603,    0,    0,
      603,  602,  603,  607,  603,  607,  608,  607,    0,  603,
        0,    0,  607,    0,  610,    0,  608,    0,  608,  608,
      608,    0,  613,    0,  610,  608,  610,    0,  610,  613,
      615,    0,  613,  610,  613,    0,  613,  615,  628,    0,
      615,  613,  615,    0,  615,    0,  629,    0,  628,  615,

      628,    0,  628,    0,  630,    0,  629,  628,  629,    0,
      629,    0,  631,    0,  630,  629,  630,    0,  630,    0,
      632,    0,  631,  630,  631,    0,  631,    0,    0,    0,
      632,  631,  632,  636,  632,    0,    0,    0,  632,  632,
        0,  638,    0,  636,  641,  636,    0,  636,  638,    0,
        0,  638,  636,  638,  641,  638,  641,  643,  641,    0,
      638,  643,  641,  641,    0,  653,    0,  643,  654,  643,
        0,  643,    0,    0,    0,  653,  643,  653,  654,  653,
      654,    0,  654,  653,  653,  658,    0,  654,  660,    0,
        0,  654,    0,    0,    0,  658,    0,  658,  660,  658,

      660,  663,  660,    0,  658,    0,  660,  660,    0,  665,
        0,  663,    0,  663,    0,  663,  665,    0,    0,  665,
      663,  665,    0,  665,  663,  674,  674,  675,  665,    0,
        0,    0,    0,    0,    0,    0,  674,  675,  674,  675,
      674,  675,  679,  682,    0,  674,  675,    0,    0,    0,
        0,    0,  679,  682,  679,  682,  679,  682,    0,  693,
      684,  679,  682,  684,    0,  679,    0,    0,    0,  693,
      684,  693,  684,  693,  684,  695,  698,    0,  693,  684,
        0,  693,    0,    0,    0,  695,  698,  695,  698,  695,
      698,  705,  698,    0,  695,  698,    0,  709,    0,    0,

        0,  705,    0,  705,    0,  705,    0,  709,    0,  709,
      705,  709,    0,    0,    0,    0,  709,  722,  722,  722,
      722,  722,  723,    0,  723,  724,  724,  724,  725,  725,
        0,  725,  725,  726,  726,  726,  727,  727,  727,  728,
      728,  728,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,

      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
char *yytext;
#define INITIAL 0
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "defs.h"
#include "parser.h"
#include "error.h"

#define T_NOTOKEN       9999

static LLPOS current_pos;
static LLPOS last_pos;

#undef YY_INPUT
#define YY_INPUT(buf,result,max_size) {\
if (!filelen) { result = YY_NULL;\
} else { while (currentfilepos >= allfilestarts[currentfile+1]) currentfile++;\
buf[0] = *currentfilepos++; filelen--;\
last_pos = current_pos;\
if (buf[0] == '\n') { current_pos.line++; current_pos.column = 1; }\
else { current_pos.column++; }\
current_pos.file = allfilenames[currentfile];\
result = 1;\
}}

LLSTYPE yylval;
char *file = NULL;
int filelen = 0;
char *currentfilepos = NULL;
char **allfilenames;
char **allfilestarts;
int currentfile;
#define DIRECTIVE 1


/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
    if ( yy_current_buffer->yy_is_interactive ) \
        { \
        int c = '*', n; \
        for ( n = 0; n < max_size && \
                 (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
            buf[n] = (char) c; \
        if ( c == '\n' ) \
            buf[n++] = (char) c; \
        if ( c == EOF && ferror( yyin ) ) \
            YY_FATAL_ERROR( "input in flex scanner failed" ); \
        result = n; \
        } \
    else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
          && ferror( yyin ) ) \
        YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
    YY_USER_ACTION

YY_DECL
    {
    register yy_state_type yy_current_state;
    register char *yy_cp, *yy_bp;
    register int yy_act;


    if ( yy_init )
        {
        yy_init = 0;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif

        if ( ! yy_start )
            yy_start = 1;   /* first start state */

        if ( ! yyin )
            yyin = stdin;

        if ( ! yyout )
            yyout = stdout;

        if ( ! yy_current_buffer )
            yy_current_buffer =
                yy_create_buffer( yyin, YY_BUF_SIZE );

        yy_load_buffer_state();
        }

    while ( 1 )     /* loops until end-of-file is reached */
        {
        yy_cp = yy_c_buf_p;

        /* Support of yytext. */
        *yy_cp = yy_hold_char;

        /* yy_bp points to the position in yy_ch_buf of the start of
         * the current run.
         */
        yy_bp = yy_cp;

        yy_current_state = yy_start;
yy_match:
        do
            {
            register YY_CHAR yy_c = (YY_CHAR)yy_ec[YY_SC_TO_UI(*yy_cp)];
            if ( yy_accept[yy_current_state] )
                {
                yy_last_accepting_state = yy_current_state;
                yy_last_accepting_cpos = yy_cp;
                }
            while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 722 )
                    yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
                }
            yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
            ++yy_cp;
            }
        while ( yy_base[yy_current_state] != 3743 );

yy_find_action:
        yy_act = yy_accept[yy_current_state];
        if ( yy_act == 0 )
            { /* have to back up */
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            yy_act = yy_accept[yy_current_state];
            }

        YY_DO_BEFORE_ACTION;


do_action:  /* This label is used only to access EOF actions. */


        switch ( yy_act )
    { /* beginning of action switch */
            case 0: /* must back up */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;
            yy_cp = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

case 1:
YY_RULE_SETUP
return T_ABSENT;
    YY_BREAK
case 2:
YY_RULE_SETUP
return T_ABSTRACT_SYNTAX;
    YY_BREAK
case 3:
YY_RULE_SETUP
return T_ALL;
    YY_BREAK
case 4:
YY_RULE_SETUP
return T_ANY;
    YY_BREAK
case 5:
YY_RULE_SETUP
return T_APPLICATION;
    YY_BREAK
case 6:
YY_RULE_SETUP
return T_AUTOMATIC;
    YY_BREAK
case 7:
YY_RULE_SETUP
return T_BEGIN;
    YY_BREAK
case 8:
YY_RULE_SETUP
return T_BIT;
    YY_BREAK
case 9:
YY_RULE_SETUP
return T_BMPString;
    YY_BREAK
case 10:
YY_RULE_SETUP
return T_BOOLEAN;
    YY_BREAK
case 11:
YY_RULE_SETUP
return T_BY;
    YY_BREAK
case 12:
YY_RULE_SETUP
return T_CHARACTER;
    YY_BREAK
case 13:
YY_RULE_SETUP
return T_CHOICE;
    YY_BREAK
case 14:
YY_RULE_SETUP
return T_CLASS;
    YY_BREAK
case 15:
YY_RULE_SETUP
return T_COMPONENT;
    YY_BREAK
case 16:
YY_RULE_SETUP
return T_COMPONENTS;
    YY_BREAK
case 17:
YY_RULE_SETUP
return T_CONSTRAINED;
    YY_BREAK
case 18:
YY_RULE_SETUP
return T_DEFAULT;
    YY_BREAK
case 19:
YY_RULE_SETUP
return T_DEFINED;
    YY_BREAK
case 20:
YY_RULE_SETUP
return T_DEFINITIONS;
    YY_BREAK
case 21:
YY_RULE_SETUP
return T_EMBEDDED;
    YY_BREAK
case 22:
YY_RULE_SETUP
return T_empty;
    YY_BREAK
case 23:
YY_RULE_SETUP
return T_END;
    YY_BREAK
case 24:
YY_RULE_SETUP
return T_ENUMERATED;
    YY_BREAK
case 25:
YY_RULE_SETUP
return T_EXCEPT;
    YY_BREAK
case 26:
YY_RULE_SETUP
return T_EXPLICIT;
    YY_BREAK
case 27:
YY_RULE_SETUP
return T_EXPORTS;
    YY_BREAK
case 28:
YY_RULE_SETUP
return T_EXTENSIBILITY;
    YY_BREAK
case 29:
YY_RULE_SETUP
return T_EXTERNAL;
    YY_BREAK
case 30:
YY_RULE_SETUP
return T_FALSE;
    YY_BREAK
case 31:
YY_RULE_SETUP
return T_FROM;
    YY_BREAK
case 32:
YY_RULE_SETUP
return T_GeneralizedTime;
    YY_BREAK
case 33:
YY_RULE_SETUP
return T_GeneralString;
    YY_BREAK
case 34:
YY_RULE_SETUP
return T_GraphicString;
    YY_BREAK
case 35:
YY_RULE_SETUP
return T_IA5String;
    YY_BREAK
case 36:
YY_RULE_SETUP
return T_TYPE_IDENTIFIER;
    YY_BREAK
case 37:
YY_RULE_SETUP
return T_IDENTIFIER;
    YY_BREAK
case 38:
YY_RULE_SETUP
return T_identifier;
    YY_BREAK
case 39:
YY_RULE_SETUP
return T_IMPLICIT;
    YY_BREAK
case 40:
YY_RULE_SETUP
return T_IMPLIED;
    YY_BREAK
case 41:
YY_RULE_SETUP
return T_IMPORTS;
    YY_BREAK
case 42:
YY_RULE_SETUP
return T_INCLUDES;
    YY_BREAK
case 43:
YY_RULE_SETUP
return T_INSTANCE;
    YY_BREAK
case 44:
YY_RULE_SETUP
return T_INTEGER;
    YY_BREAK
case 45:
YY_RULE_SETUP
return T_INTERSECTION;
    YY_BREAK
case 46:
YY_RULE_SETUP
return T_ISO646String;
    YY_BREAK
case 47:
YY_RULE_SETUP
return T_MACRO;
    YY_BREAK
case 48:
YY_RULE_SETUP
return T_MAX;
    YY_BREAK
case 49:
YY_RULE_SETUP
return T_MIN;
    YY_BREAK
case 50:
YY_RULE_SETUP
return T_MINUS_INFINITY;
    YY_BREAK
case 51:
YY_RULE_SETUP
return T_NOTATION;
    YY_BREAK
case 52:
YY_RULE_SETUP
return T_NULL;
    YY_BREAK
case 53:
YY_RULE_SETUP
return T_Number;
    YY_BREAK
case 54:
YY_RULE_SETUP
return T_NumericString;
    YY_BREAK
case 55:
YY_RULE_SETUP
return T_OBJECT;
    YY_BREAK
case 56:
YY_RULE_SETUP
return T_ObjectDescriptor;
    YY_BREAK
case 57:
YY_RULE_SETUP
return T_OCTET;
    YY_BREAK
case 58:
YY_RULE_SETUP
return T_OF;
    YY_BREAK
case 59:
YY_RULE_SETUP
return T_OPTIONAL;
    YY_BREAK
case 60:
YY_RULE_SETUP
return T_PDV;
    YY_BREAK
case 61:
YY_RULE_SETUP
return T_PLUS_INFINITY;
    YY_BREAK
case 62:
YY_RULE_SETUP
return T_PRESENT;
    YY_BREAK
case 63:
YY_RULE_SETUP
return T_PrintableString;
    YY_BREAK
case 64:
YY_RULE_SETUP
return T_PRIVATE;
    YY_BREAK
case 65:
YY_RULE_SETUP
return T_REAL;
    YY_BREAK
case 66:
YY_RULE_SETUP
return T_SEQUENCE;
    YY_BREAK
case 67:
YY_RULE_SETUP
return T_SET;
    YY_BREAK
case 68:
YY_RULE_SETUP
return T_SIZE;
    YY_BREAK
case 69:
YY_RULE_SETUP
return T_STRING;
    YY_BREAK
case 70:
YY_RULE_SETUP
return T_string;
    YY_BREAK
case 71:
YY_RULE_SETUP
return T_SYNTAX;
    YY_BREAK
case 72:
YY_RULE_SETUP
return T_T61String;
    YY_BREAK
case 73:
YY_RULE_SETUP
return T_TAGS;
    YY_BREAK
case 74:
YY_RULE_SETUP
return T_TeletexString;
    YY_BREAK
case 75:
YY_RULE_SETUP
return T_TRUE;
    YY_BREAK
case 76:
YY_RULE_SETUP
return T_TYPE;
    YY_BREAK
case 77:
YY_RULE_SETUP
return T_type;
    YY_BREAK
case 78:
YY_RULE_SETUP
return T_UNION;
    YY_BREAK
case 79:
YY_RULE_SETUP
return T_UNIQUE;
    YY_BREAK
case 80:
YY_RULE_SETUP
return T_UNIVERSAL;
    YY_BREAK
case 81:
YY_RULE_SETUP
return T_UniversalString;
    YY_BREAK
case 82:
YY_RULE_SETUP
return T_UTCTime;
    YY_BREAK
case 83:
YY_RULE_SETUP
return T_UTF8String;
    YY_BREAK
case 84:
YY_RULE_SETUP
return T_VALUE;
    YY_BREAK
case 85:
YY_RULE_SETUP
return T_value;
    YY_BREAK
case 86:
YY_RULE_SETUP
return T_VideotexString;
    YY_BREAK
case 87:
YY_RULE_SETUP
return T_VisibleString;
    YY_BREAK
case 88:
YY_RULE_SETUP
return T_WITH;
    YY_BREAK
case 89:
YY_RULE_SETUP
return *yytext;
    YY_BREAK
case 90:
YY_RULE_SETUP
return T_DEF;
    YY_BREAK
case 91:
YY_RULE_SETUP
return T_TDOT;
    YY_BREAK
case 92:
YY_RULE_SETUP
return T_DDOT;
    YY_BREAK
case 93:
YY_RULE_SETUP
{   int i;
                    intx_t h;
                    intx_setuint32(&yylval._XNumber, 0);
                    for (i = 0; i < yyleng; i++) {
                        intx_muloctet(&h, &yylval._XNumber,
                        10);
                        intx_addoctet(&yylval._XNumber, &h,
                        (octet_t)(yytext[i] - '0'));
                    }
                    return T_number;
                }
    YY_BREAK
case 94:
YY_RULE_SETUP
{   char *p, *q;
                    q = yylval._XString =
                        (char *)malloc(yyleng - 2);
                    for (p = yytext + 1; *p != '\''; p++)
                        if (*p == '0' || *p == '1')
                            *q++ = *p;
                    *q = 0;
                    return T_bstring;
                }
    YY_BREAK
case 95:
YY_RULE_SETUP
{   char *p, *q;
                    q = yylval._XString =
                        (char *)malloc(yyleng - 2);
                    for (p = yytext + 1; *p != '\''; p++)
                        if (isxdigit(*p))
                            *q++ = *p;
                    *q = 0;
                    return T_hstring;
                }
    YY_BREAK
case 96:
YY_RULE_SETUP
{   int s, l = 0, c;
                    LLPOS start_pos;
                    yylval._XString32 =
                        (char32_t *)malloc(
                        (s = 32) * sizeof(char32_t));
                    start_pos = last_pos;
                    for (;;) {
                        c = input();
                        if (!c || c == EOF) {
                        error(E_unterminated_string,
                            &start_pos);
                        /*NOTREACHED*/
                        }
                        if (c == '\n') {
                        while (l > 0 && is32space(
                            yylval._XString32[l - 1]))
                            l--;
                        while (c = input()) {
                            if (!isspace(c))
                            break;
                        }
                        }
                        if (c == '\"') {
                        c = input();
                        if (c != '\"') {
                            unput(c);
                            yylval._XString32[l] = 0;
                            return T_cstring;
                        }
                        }
                        if (l + 1 >= s) {
                        yylval._XString32 = (char32_t *)
                            realloc(yylval._XString32,
                            (s *= 2) *
                            sizeof(char32_t));
                        }
                        yylval._XString32[l++] = c;
                    }
                }
    YY_BREAK
case 97:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_only_uppercase_symbol;
                }
    YY_BREAK
case 98:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_only_uppercase_digits_symbol;
                }
    YY_BREAK
case 99:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_uppercase_symbol;
                }
    YY_BREAK
case 100:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_lcsymbol;
                }
    YY_BREAK
case 101:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_amplcsymbol;
                }
    YY_BREAK
case 102:
YY_RULE_SETUP
{
                    yylval._XString =
                        (char *)malloc(yyleng + 1);
                    strcpy(yylval._XString, yytext);
                    return T_ampucsymbol;
                }
    YY_BREAK
case 103:
YY_RULE_SETUP
{   BEGIN DIRECTIVE;
                }
    YY_BREAK
case 104:
YY_RULE_SETUP
{   BEGIN INITIAL;
                }
    YY_BREAK
case 105:
YY_RULE_SETUP
{   BEGIN INITIAL;
                }
    YY_BREAK
case 106:
case 107:
YY_RULE_SETUP
{   return T_FIXED_ARRAY;
                }
    YY_BREAK
case 108:
case 109:
YY_RULE_SETUP
{   return T_SINGLY_LINKED_LIST;
                }
    YY_BREAK
case 110:
case 111:
YY_RULE_SETUP
{   return T_DOUBLY_LINKED_LIST;
                }
    YY_BREAK
case 112:
case 113:
YY_RULE_SETUP
{   return T_LENGTH_POINTER;
                }
    YY_BREAK
case 114:
case 115:
YY_RULE_SETUP
{   return T_ZERO_TERMINATED;
                }
    YY_BREAK
case 116:
case 117:
YY_RULE_SETUP
{   return T_POINTER;
                }
    YY_BREAK
case 118:
case 119:
YY_RULE_SETUP
{   return T_NO_POINTER;
                }
    YY_BREAK
case 120:
YY_RULE_SETUP
{   /* ignore */
                }
    YY_BREAK
case 121:
YY_RULE_SETUP
{   fprintf(stderr,
                        "Bad directive %s (ignored)\n",
                        yytext);
                }
    YY_BREAK
case 122:
YY_RULE_SETUP
{   int c;
                    for (;;) {
                        c = input();
                        if (c == 0 || c == EOF)
                            break;
                        if (c == '\n')
                            break;
#ifdef MS_DIRECTIVE
                        if (c == g_chDirectiveBegin)
                        {
                            c = input();
                            GetPrivateDirective(&c);
                        }
#endif // MS_DIRECTIVE
                        if (c != '-')
                            continue;
                        c = input();
                        if (c == 0 || c == EOF)
                            break;
                        if (c == '\n')
                            break;
                        if (c != '-')
                            continue;
                        break;
                    }
                    return T_NOTOKEN;
                }
    YY_BREAK
case 123:
YY_RULE_SETUP
return T_NOTOKEN;
    YY_BREAK
case 124:
YY_RULE_SETUP
return EOF;
    YY_BREAK
case 125:
YY_RULE_SETUP
{   error(E_bad_character, &last_pos);
                }
    YY_BREAK
case 126:
YY_RULE_SETUP
ECHO;
    YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(DIRECTIVE):
    yyterminate();

    case YY_END_OF_BUFFER:
        {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = yy_hold_char;

        if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
            {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between yy_current_buffer and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            yy_n_chars = yy_current_buffer->yy_n_chars;
            yy_current_buffer->yy_input_file = yyin;
            yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
            }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            { /* This was really a NUL. */
            yy_state_type yy_next_state;

            yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans( yy_current_state );

            yy_bp = yytext_ptr + YY_MORE_ADJ;

            if ( yy_next_state )
                {
                /* Consume the NUL. */
                yy_cp = ++yy_c_buf_p;
                yy_current_state = yy_next_state;
                goto yy_match;
                }

            else
                {
                yy_cp = yy_c_buf_p;
                goto yy_find_action;
                }
            }

        else switch ( yy_get_next_buffer() )
            {
            case EOB_ACT_END_OF_FILE:
                {
                yy_did_buffer_switch_on_eof = 0;

                if ( yywrap() )
                    {
                    /* Note: because we've taken care in
                     * yy_get_next_buffer() to have set up
                     * yytext, we can now set up
                     * yy_c_buf_p so that if some total
                     * hoser (like flex itself) wants to
                     * call the scanner after we return the
                     * YY_NULL, it'll still work - another
                     * YY_NULL will get returned.
                     */
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

                    yy_act = YY_STATE_EOF(YY_START);
                    goto do_action;
                    }

                else
                    {
                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
                    }
                break;
                }

            case EOB_ACT_CONTINUE_SCAN:
                yy_c_buf_p =
                    yytext_ptr + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_match;

            case EOB_ACT_LAST_MATCH:
                yy_c_buf_p =
                &yy_current_buffer->yy_ch_buf[yy_n_chars];

                yy_current_state = yy_get_previous_state();

                yy_cp = yy_c_buf_p;
                yy_bp = yytext_ptr + YY_MORE_ADJ;
                goto yy_find_action;
            }
        break;
        }

    default:
        YY_FATAL_ERROR(
            "fatal flex scanner internal error--no action found" );
    } /* end of action switch */
        } /* end of scanning one token */
    } /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
    {
    register char *dest = yy_current_buffer->yy_ch_buf;
    register char *source = yytext_ptr;
    register int number_to_move, i;
    int ret_val;

    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
        YY_FATAL_ERROR(
        "fatal flex scanner internal error--end of buffer missed" );

    if ( yy_current_buffer->yy_fill_buffer == 0 )
        { /* Don't try to fill the buffer, so this is an EOF. */
        if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
            {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
            }

        else
            {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
            }
        }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

    for ( i = 0; i < number_to_move; ++i )
        *(dest++) = *(source++);

    if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        yy_n_chars = 0;

    else
        {
        int num_to_read =
            yy_current_buffer->yy_buf_size - number_to_move - 1;

        while ( num_to_read <= 0 )
            { /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
            YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = yy_current_buffer;

            int yy_c_buf_p_offset =
                (int) (yy_c_buf_p - b->yy_ch_buf);

            if ( b->yy_is_our_buffer )
                {
                int new_size = b->yy_buf_size * 2;

                if ( new_size <= 0 )
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char *)
                    /* Include room in for 2 EOB chars. */
                    yy_flex_realloc( (void *) b->yy_ch_buf,
                             b->yy_buf_size + 2 );
                }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = 0;

            if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR(
                "fatal error - scanner input buffer overflow" );

            yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = yy_current_buffer->yy_buf_size -
                        number_to_move - 1;
#endif
            }

        if ( num_to_read > YY_READ_BUF_SIZE )
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
            yy_n_chars, num_to_read );
        }

    if ( yy_n_chars == 0 )
        {
        if ( number_to_move == YY_MORE_ADJ )
            {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart( yyin );
            }

        else
            {
            ret_val = EOB_ACT_LAST_MATCH;
            yy_current_buffer->yy_buffer_status =
                YY_BUFFER_EOF_PENDING;
            }
        }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    yy_n_chars += number_to_move;
    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

    yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

    return ret_val;
    }


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
    {
    register yy_state_type yy_current_state;
    register char *yy_cp;

    yy_current_state = yy_start;

    for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
        {
        register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if ( yy_accept[yy_current_state] )
            {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos = yy_cp;
            }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
            {
            yy_current_state = (int) yy_def[yy_current_state];
            if ( yy_current_state >= 722 )
                yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
            }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        }

    return yy_current_state;
    }


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
    {
    register int yy_is_jam;
    register char *yy_cp = yy_c_buf_p;

    register YY_CHAR yy_c = 1;
    if ( yy_accept[yy_current_state] )
        {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
        }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 722 )
            yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
        }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    yy_is_jam = (yy_current_state == 721);

    return yy_is_jam ? 0 : yy_current_state;
    }


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
    {
    register char *yy_cp = yy_c_buf_p;

    /* undo effects of setting up yytext */
    *yy_cp = yy_hold_char;

    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
        { /* need to shift things up to make room */
        /* +2 for EOB chars. */
        register int number_to_move = yy_n_chars + 2;
        register char *dest = &yy_current_buffer->yy_ch_buf[
                    yy_current_buffer->yy_buf_size + 2];
        register char *source =
                &yy_current_buffer->yy_ch_buf[number_to_move];

        while ( source > yy_current_buffer->yy_ch_buf )
            *--dest = *--source;

        yy_cp += (int) (dest - source);
        yy_bp += (int) (dest - source);
        yy_n_chars = yy_current_buffer->yy_buf_size;

        if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
            YY_FATAL_ERROR( "flex scanner push-back overflow" );
        }

    *--yy_cp = (char) c;


    yytext_ptr = yy_bp;
    yy_hold_char = *yy_cp;
    yy_c_buf_p = yy_cp;
    }
#endif  /* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
    {
    int c;

    *yy_c_buf_p = yy_hold_char;

    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
        {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            /* This was really a NUL. */
            *yy_c_buf_p = '\0';

        else
            { /* need more input */
            yytext_ptr = yy_c_buf_p;
            ++yy_c_buf_p;

            switch ( yy_get_next_buffer() )
                {
                case EOB_ACT_END_OF_FILE:
                    {
                    if ( yywrap() )
                        {
                        yy_c_buf_p =
                        yytext_ptr + YY_MORE_ADJ;
                        return EOF;
                        }

                    if ( ! yy_did_buffer_switch_on_eof )
                        YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();
#else
                    return input();
#endif
                    }

                case EOB_ACT_CONTINUE_SCAN:
                    yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
                    break;

                case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
                    YY_FATAL_ERROR(
                    "unexpected last match in yyinput()" );
#else
                    YY_FATAL_ERROR(
                    "unexpected last match in input()" );
#endif
                }
            }
        }

    c = *(unsigned char *) yy_c_buf_p;  /* cast for 8-bit char's */
    *yy_c_buf_p = '\0'; /* preserve yytext */
    yy_hold_char = *++yy_c_buf_p;


    return c;
    }


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
    {
    if ( ! yy_current_buffer )
        yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

    yy_init_buffer( yy_current_buffer, input_file );
    yy_load_buffer_state();
    }


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
    {
    if ( yy_current_buffer == new_buffer )
        return;

    if ( yy_current_buffer )
        {
        /* Flush out information for old buffer. */
        *yy_c_buf_p = yy_hold_char;
        yy_current_buffer->yy_buf_pos = yy_c_buf_p;
        yy_current_buffer->yy_n_chars = yy_n_chars;
        }

    yy_current_buffer = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    yy_did_buffer_switch_on_eof = 1;
    }


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
    {
    yy_n_chars = yy_current_buffer->yy_n_chars;
    yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
    yyin = yy_current_buffer->yy_input_file;
    yy_hold_char = *yy_c_buf_p;
    }


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
    {
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
    if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

    b->yy_is_our_buffer = 1;

    yy_init_buffer( b, file );

    return b;
    }


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
    {
    if ( ! b )
        return;

    if ( b == yy_current_buffer )
        yy_current_buffer = (YY_BUFFER_STATE) 0;

    if ( b->yy_is_our_buffer )
        yy_flex_free( (void *) b->yy_ch_buf );

    yy_flex_free( (void *) b );
    }


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int __cdecl isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


    {
    yy_flush_buffer( b );

    b->yy_input_file = file;
    b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
    b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
    b->yy_is_interactive = 0;
#else
    b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
    }


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

    {
    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if ( b == yy_current_buffer )
        yy_load_buffer_state();
    }


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
    {
    YY_BUFFER_STATE b;

    if ( size < 2 ||
         base[size-2] != YY_END_OF_BUFFER_CHAR ||
         base[size-1] != YY_END_OF_BUFFER_CHAR )
        /* They forgot to leave room for the EOB's. */
        return 0;

    b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
    if ( ! b )
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

    b->yy_buf_size = size - 2;  /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = 0;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer( b );

    return b;
    }
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
    {
    int len;
    for ( len = 0; yy_str[len]; ++len )
        ;

    return yy_scan_bytes( yy_str, len );
    }
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
    {
    YY_BUFFER_STATE b;
    char *buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = len + 2;
    buf = (char *) yy_flex_alloc( n );
    if ( ! buf )
        YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

    for ( i = 0; i < len; ++i )
        buf[i] = bytes[i];

    buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer( buf, n );
    if ( ! b )
        YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
    }
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
    {
    if ( yy_start_stack_ptr >= yy_start_stack_depth )
        {
        yy_size_t new_size;

        yy_start_stack_depth += YY_START_STACK_INCR;
        new_size = yy_start_stack_depth * sizeof( int );

        if ( ! yy_start_stack )
            yy_start_stack = (int *) yy_flex_alloc( new_size );

        else
            yy_start_stack = (int *) yy_flex_realloc(
                    (void *) yy_start_stack, new_size );

        if ( ! yy_start_stack )
            YY_FATAL_ERROR(
            "out of memory expanding start-condition stack" );
        }

    yy_start_stack[yy_start_stack_ptr++] = YY_START;

    BEGIN(new_state);
    }
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
    {
    if ( --yy_start_stack_ptr < 0 )
        YY_FATAL_ERROR( "start-condition stack underflow" );

    BEGIN(yy_start_stack[yy_start_stack_ptr]);
    }
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
    {
    return yy_start_stack[yy_start_stack_ptr - 1];
    }
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
    {
    (void) fprintf( stderr, "%s\n", msg );
    MyExit( YY_EXIT_FAILURE );
    }



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
    do \
        { \
        /* Undo effects of setting up yytext. */ \
        yytext[yyleng] = yy_hold_char; \
        yy_c_buf_p = yytext + n - YY_MORE_ADJ; \
        yy_hold_char = *yy_c_buf_p; \
        *yy_c_buf_p = '\0'; \
        yyleng = n; \
        } \
    while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
    {
    register int i;
    for ( i = 0; i < n; ++i )
        s1[i] = s2[i];
    }
#endif

#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
    {
    return (void *) malloc( size );
    }

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
    {
    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return (void *) realloc( (char *) ptr, size );
    }

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
    {
    free( ptr );
    }

#if YY_MAIN
int main()
    {
    yylex();
    return 0;
    }
#endif


int llgettoken(int *token, LLSTYPE *lval, LLPOS *pos)
{
    for (;;) {
#ifdef MS_DIRECTIVE
// Ordering of hack directives
//      PrivateDir_Huge PrivateDir_Unbounded PrivateDir_Array PrivateDir_NoCopy PrivateDir_PDU
//      PrivateDir_ObjectIdEncoded PrivateDir_ObjectIdFixedSize
//      PrivateDir_Type PrivateDir_Field PrivateDir_Value PrivateDir_Linked

    if (g_fPrivateDir_Intx)
    {
        g_fPrivateDir_Intx = 0;
        yylval._XString = "PrivateDir_Intx";
        *lval = yylval;
        *token = T_PrivateDir_Intx;
        return 1;
    }
    if (g_fPrivateDir_LenPtr)
    {
        g_fPrivateDir_LenPtr = 0;
        yylval._XString = "PrivateDir_LenPtr";
        *lval = yylval;
        *token = T_PrivateDir_LenPtr;
        return 1;
    }
    if (g_fPrivateDir_Pointer)
    {
        g_fPrivateDir_Pointer = 0;
        yylval._XString = "PrivateDir_Pointer";
        *lval = yylval;
        *token = T_PrivateDir_Pointer;
        return 1;
    }
    if (g_fPrivateDir_Array)
    {
        g_fPrivateDir_Array = 0;
        yylval._XString = "PrivateDir_Array";
        *lval = yylval;
        *token = T_PrivateDir_Array;
        return 1;
    }
    if (g_fPrivateDir_NoCode)
    {
        g_fPrivateDir_NoCode = 0;
        yylval._XString = "PrivateDir_NoCode";
        *lval = yylval;
        *token = T_PrivateDir_NoCode;
        return 1;
    }
    if (g_fPrivateDir_NoMemCopy)
    {
        g_fPrivateDir_NoMemCopy = 0;
        yylval._XString = "PrivateDir_NoMemCopy";
        *lval = yylval;
        *token = T_PrivateDir_NoMemCopy;
        return 1;
    }
    if (g_fPrivateDir_Public)
    {
        g_fPrivateDir_Public = 0;
        yylval._XString = "PrivateDir_Public";
        *lval = yylval;
        *token = T_PrivateDir_Public;
        return 1;
    }
    if (g_fPrivateDir_OidPacked)
    {
        g_fPrivateDir_OidPacked = 0;
        yylval._XString = "PrivateDir_OidPacked";
        *lval = yylval;
        *token = T_PrivateDir_OidPacked;
        return 1;
    }
    if (g_fPrivateDir_OidArray)
    {
        g_fPrivateDir_OidArray = 0;
        yylval._XString = "PrivateDir_OidArray";
        *lval = yylval;
        *token = T_PrivateDir_OidArray;
        return 1;
    }
    if (g_szPrivateDirectedTypeName[0])
    {
        if (g_fPrivateDir_TypeNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedTypeName[0]);
            g_szPrivateDirectedTypeName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_TypeNameToken = 1;
            yylval._XString = "PrivateDir_TypeName";
            *lval = yylval;
            *token = T_PrivateDir_TypeName;
        }
        return 1;
    }
    if (g_szPrivateDirectedFieldName[0])
    {
        if (g_fPrivateDir_FieldNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedFieldName[0]);
            g_szPrivateDirectedFieldName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_FieldNameToken = 1;
            yylval._XString = "PrivateDir_FieldName";
            *lval = yylval;
            *token = T_PrivateDir_FieldName;
        }
        return 1;
    }
    if (g_szPrivateDirectedValueName[0])
    {
        if (g_fPrivateDir_ValueNameToken)
        {
            yylval._XString = strdup(&g_szPrivateDirectedValueName[0]);
            g_szPrivateDirectedValueName[0] = '\0';
            *lval = yylval;
            *token = T_lcsymbol;
        }
        else
        {
            g_fPrivateDir_ValueNameToken = 1;
            yylval._XString = "PrivateDir_ValueName";
            *lval = yylval;
            *token = T_PrivateDir_ValueName;
        }
        return 1;
    }
    if (g_fPrivateDir_SLinked)
    {
        g_fPrivateDir_SLinked = 0;
        yylval._XString = "PrivateDir_SLinked";
        *lval = yylval;
        *token = T_PrivateDir_SLinked;
        return 1;
    }
    if (g_fPrivateDir_DLinked)
    {
        g_fPrivateDir_DLinked = 0;
        yylval._XString = "PrivateDir_DLinked";
        *lval = yylval;
        *token = T_PrivateDir_DLinked;
        return 1;
    }
#endif // MS_DIRECTIVE
    if (yy_hold_char == YY_END_OF_BUFFER_CHAR) {
        *pos = current_pos;
    } else {
        *pos = last_pos;
    }
    *token = yylex();
    if (*token == 0 || *token == EOF)
        return 0;
    if (*token == T_NOTOKEN)
        continue;
    *lval = yylval;
    return 1;
    }
}

void readfiles(char **filenames)
{
    FILE *fin;
    long len;
    int i, nfiles, j;

    for (nfiles = 0; filenames[nfiles]; nfiles++) {}
    allfilenames = filenames;
    allfilestarts = (char **)malloc((nfiles + 1) * sizeof(char *));
    filelen = 0;
    for (i = 0; i < nfiles; i++) {
    fin = fopen(filenames[i], "r");
    if (!fin) {
        perror(filenames[i]);
        MyExit(1);
    }
    fseek(fin, 0, SEEK_END);
    filelen += ftell(fin);
    fclose(fin);
    }
    currentfilepos = file = (char *)malloc(filelen);
    for (i = 0; i < nfiles; i++) {
    fin = fopen(filenames[i], "r");
    if (!fin) {
        perror(filenames[i]);
        MyExit(1);
    }
    fseek(fin, 0, SEEK_END);
    len = ftell(fin);
    fseek(fin, 0, SEEK_SET);
    allfilestarts[i] = currentfilepos;
    len = fread(currentfilepos, 1, len, fin);
    currentfilepos += len;
    fclose(fin);
    }
    filelen = currentfilepos - file;
    allfilestarts[i] = currentfilepos;

    // set up the first file's info
    currentfilepos = file;
    current_pos.line = 1;
    current_pos.column = 1;
    current_pos.file = filenames[0];
    last_pos = current_pos;

    // mask out all the directives prior to the body
    for (i = 0; i < nfiles; i++)
    {
        char *psz = allfilestarts[i];
        while (isspace(*psz))
            psz++;
        while ('-' == *psz && '-' == *(psz+1))
        {
            psz += 2;
            // mask out directives if needed
            if (g_chDirectiveBegin == *psz)
                *psz++ = ' ';
            SetDirective(psz);
            // locate the closing '--'
            while ('\n' != *psz)
            {
                if ('-' == *psz && '-' == *(psz+1))
                {
                    psz++;
                    break;
                }
                psz++;
            }
            psz++; // skip over '\n' or the second '-'
            // skip over white spaces
            while (isspace(*psz))
                psz++;
        }

        // associate ghost files with ghost modules
        for (j = 0; j < g_cGhostFiles; j++)
        {
            if (! strcmp(g_aGhostFiles[j].pszFileName, filenames[i]))
            {
                int ch_idx;
                char szModuleName[128];
                // get the module identifier
                while (! isalpha(*psz))
                    psz++;
                for (ch_idx = 0; isalnum(*psz) || *psz == '-'; )
                {
                    szModuleName[ch_idx++] = *psz++;
                }
                szModuleName[ch_idx] = '\0'; // null terminator
                ASSERT(! g_aGhostFiles[j].pszModuleName);
                g_aGhostFiles[j].pszModuleName = strdup(szModuleName);
            }
        }
    }
}

void
llprinttoken(LLTERM *term, char *identifier, FILE *f)
{
    char32_t *p;

    switch (term->token) {
    case T_number:
    fprintf(f, "%s(%u)", identifier, intx2uint32(&term->lval._XNumber));
    break;
    case T_bstring:
    case T_hstring:
    case T_only_uppercase_symbol:
    case T_only_uppercase_digits_symbol:
    case T_uppercase_symbol:
    case T_lcsymbol:
    case T_ampucsymbol:
    case T_amplcsymbol:
    fprintf(f, "%s(%s)", identifier, term->lval._XString);
    break;
    case T_cstring:
    fprintf(f, "%s(", identifier);
    for (p = term->lval._XString32; *p; p++)
        putc(*p, f);
    putc(')', f);
    break;
    default:
    fprintf(f, "%s", identifier);
    }
}


#ifdef MS_DIRECTIVE
int PrivateDirectives_Input ( void )
{
    return input();
}
#endif // MS_DIRECTIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\scanner.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_SCANNER_H_
#define _ASN1C_SCANNER_H_

void readfiles(char **filenames);
extern char *file;

#endif // _ASN1C_SCANNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\percons.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "util.h"
#include "error.h"

static void GetAllPERFromConstraints(AssignmentList_t ass,
    Constraint_t *constraints,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void GetAllPERFromElementSetSpecs(AssignmentList_t ass,
    ElementSetSpec_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void GetAllPERFromSubtypeElements(AssignmentList_t ass,
    SubtypeElement_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermittedAlphabet,
    ValueConstraintList_t *permittedAlphabetConstraints,
    ValueConstraintList_t *epermittedAlphabetConstraints,
    int inPermAlpha);
static void IntersectValueConstraints(AssignmentList_t ass,
    ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void UniteValueConstraints(ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void ExcludeValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2);
static void NegateValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val);
static void IntersectPERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void UnitePERConstraints(Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void NegatePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1);
static void ExcludePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2);
static void ReduceValueConstraints(AssignmentList_t ass, ValueConstraintList_t *valueConstraints);
#if 0
ValueConstraint_t *EmptyValueConstraint();
ValueConstraint_t *EmptySizeConstraint();
ValueConstraint_t *EmptyPermittedAlphabetConstraint();
#endif
static NamedValue_t *GetFixedIdentificationFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);
static NamedValue_t *GetFixedAbstractAndTransfer(AssignmentList_t ass, Constraint_t *constraints);
static NamedValue_t *GetFixedAbstractAndTransferFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);
static NamedValue_t *GetFixedSyntaxes(AssignmentList_t ass, Constraint_t *constraints);
static NamedValue_t *GetFixedSyntaxesFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements);

/* extract per-visible constraints from a type constraint */
void
GetPERConstraints(AssignmentList_t ass, Constraint_t *constraints, PERConstraints_t *per)
{
    GetAllPERFromConstraints(ass,
	constraints,
	&per->Value.Type,
	&per->Value.Root,
	&per->Value.Additional,
	&per->Size.Type,
	&per->Size.Root,
	&per->Size.Additional,
	&per->PermittedAlphabet.Type,
	&per->PermittedAlphabet.Root,
	&per->PermittedAlphabet.Additional,
	0);
    if (per->Value.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->Value.Root);
    if (per->Value.Type == eExtension_Extended)
	ReduceValueConstraints(ass, &per->Value.Additional);
    if (per->Size.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->Size.Root);
    if (per->Size.Type == eExtension_Extended)
	ReduceValueConstraints(ass, &per->Size.Additional);
    if (per->PermittedAlphabet.Type > eExtension_Unconstrained)
	ReduceValueConstraints(ass, &per->PermittedAlphabet.Root);

    /* permitted alphabet extensions are not PER-visible */
    if (per->PermittedAlphabet.Type > eExtension_Unextended)
	per->PermittedAlphabet.Type = eExtension_Unextended;

    /* we do not support complex value sets for the size */
    if (per->Size.Type == eExtension_Extended && per->Size.Root->Next)
	error(E_constraint_too_complex, NULL);
}

/* extract per-visible constraints from a type constraint */
static void
GetAllPERFromConstraints(AssignmentList_t ass,
    Constraint_t *constraints,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    ValueConstraint_t *vc, *sc, *pc;

    /* initialize */
    if (evalue)
	*evalue = eExtension_Unconstrained;
    if (valueConstraints)
	*valueConstraints = NULL;
    if (evalueConstraints)
	*evalueConstraints = NULL;
    if (esize)
	*esize = eExtension_Unconstrained;
    if (sizeConstraints)
	*sizeConstraints = NULL;
    if (esizeConstraints)
	*esizeConstraints = NULL;
    if (epermAlpha)
	*epermAlpha = eExtension_Unconstrained;
    if (permAlphaConstraints)
	*permAlphaConstraints = NULL;
    if (epermAlphaConstraints)
	*epermAlphaConstraints = NULL;
    vc = sc = pc = NULL;

    /* examine constraint */
    if (constraints) {
	switch (constraints->Type) {
	case eExtension_Unextended:

	    /* get constraints of the extension root */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);
	    break;

	case eExtension_Extendable:

	    /* get constraints of the extension root */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);

	    /* mark as extendable */
	    if (valueConstraints && *valueConstraints &&
		*evalue < eExtension_Extendable)
		*evalue = eExtension_Extendable;
	    if (sizeConstraints && *sizeConstraints &&
		*esize < eExtension_Extendable)
		*esize = eExtension_Extendable;
	    if (permAlphaConstraints && *permAlphaConstraints &&
		*epermAlpha < eExtension_Extendable)
		*epermAlpha = eExtension_Extendable;
	    break;

	case eExtension_Extended:

	    /* get constraints of the extension root and of the extension */
	    /* addition and mark them as extended */
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Root,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);
	    GetAllPERFromElementSetSpecs(ass,
		constraints->Additional,
		NULL, &vc, NULL,
		NULL, &sc, NULL,
		NULL, &pc, NULL,
		inPermAlpha);

	    /* extension additions given twice? */
	    if ((vc && evalueConstraints && *evalueConstraints) ||
		(sc && esizeConstraints && *esizeConstraints) ||
		(pc && epermAlphaConstraints && *epermAlphaConstraints))
		error(E_constraint_too_complex, NULL);

	    /* mark as extended */
	    if (vc) {
		*evalueConstraints = vc;
		*evalue = eExtension_Extended;
	    }
	    if (sc) {
		*esizeConstraints = sc;
		*esize = eExtension_Extended;
	    }
	    if (pc) {
		*epermAlphaConstraints = pc;
		*epermAlpha = eExtension_Extended;
	    }
	    break;

	default:
	    MyAbort();
	}
    }
}

/* get per-visible constraints from an element set spec */
static void
GetAllPERFromElementSetSpecs(AssignmentList_t ass,
    ElementSetSpec_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    ValueConstraint_t *vc1, *vc2, *evc1, *evc2;
    ValueConstraint_t *sc1, *sc2, *esc1, *esc2;
    ValueConstraint_t *pc1, *pc2, *epc1, *epc2;
    Extension_e ev1, ev2, es1, es2, ep1, ep2;

    /* initialize */
    ev1 = ev2 = es1 = es2 = ep1 = ep2 = eExtension_Unconstrained;
    vc1 = vc2 = evc1 = evc2 = NULL;
    sc1 = sc2 = esc1 = esc2 = NULL;
    pc1 = pc2 = epc1 = epc2 = NULL;

    /* examine element set spec */
    switch (element->Type) {
    case eElementSetSpec_Intersection:

	/* intersection: get the constraints of the sub-element set specs */
	/* and intersect them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Intersection.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Intersection.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	IntersectPERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	IntersectPERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	IntersectPERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_Union:

	/* union: get the constraints of the sub-element set specs */
	/* and unite them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Union.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Union.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	UnitePERConstraints(evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	UnitePERConstraints(esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	UnitePERConstraints(epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_AllExcept:

	/* all-except: get the constraints of the sub-element set specs */
	/* and negate them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.AllExcept.Elements,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	NegatePERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1);
	NegatePERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1);
	NegatePERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1);
	break;

    case eElementSetSpec_Exclusion:

	/* exclusion: get the constraints of the sub-element set specs */
	/* and substract them */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Exclusion.Elements1,
	    &ev1, &vc1, &evc1,
	    &es1, &sc1, &esc1,
	    &ep1, &pc1, &epc1,
	    inPermAlpha);
	GetAllPERFromElementSetSpecs(ass,
	    element->U.Exclusion.Elements2,
	    &ev2, &vc2, &evc2,
	    &es2, &sc2, &esc2,
	    &ep2, &pc2, &epc2,
	    inPermAlpha);
	ExcludePERConstraints(ass, evalue,
	    valueConstraints, evalueConstraints,
	    ev1, vc1, evc1, ev2, vc2, evc2);
	ExcludePERConstraints(ass, esize,
	    sizeConstraints, esizeConstraints,
	    es1, sc1, esc1, es2, sc2, esc2);
	ExcludePERConstraints(ass, epermAlpha,
	    permAlphaConstraints, epermAlphaConstraints,
	    ep1, pc1, epc1, ep2, pc2, epc2);
	break;

    case eElementSetSpec_SubtypeElement:

	/* subtype element: get the constraints of the subtype element */
	GetAllPERFromSubtypeElements(ass,
	    element->U.SubtypeElement.SubtypeElement,
	    evalue, valueConstraints, evalueConstraints,
	    esize, sizeConstraints, esizeConstraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    inPermAlpha);
	break;

    default:
	MyAbort();
	/*NOTREACHED*/
    }
}

/* get per-visible constraints from a subtype element */
static void
GetAllPERFromSubtypeElements(AssignmentList_t ass,
    SubtypeElement_t *element,
    Extension_e *evalue,
    ValueConstraintList_t *valueConstraints,
    ValueConstraintList_t *evalueConstraints,
    Extension_e *esize,
    ValueConstraintList_t *sizeConstraints,
    ValueConstraintList_t *esizeConstraints,
    Extension_e *epermAlpha,
    ValueConstraintList_t *permAlphaConstraints,
    ValueConstraintList_t *epermAlphaConstraints,
    int inPermAlpha)
{
    unsigned i;
    Value_t *v;
    ValueConstraint_t **p;
    ValueConstraint_t *vc, *evc;
    ValueConstraint_t *sc, *esc;
    Extension_e ev, es;

    /* examine the subtype element */
    switch (element->Type) {
    case eSubtypeElement_ValueRange:

	/* value range: create a value constraint containing the bounds */
	if (evalue)
	    *evalue = eExtension_Unextended;
	if (!valueConstraints)
	    error(E_constraint_too_complex, NULL);
	*valueConstraints = NewValueConstraint();
	(*valueConstraints)->Lower = element->U.ValueRange.Lower;
	(*valueConstraints)->Upper = element->U.ValueRange.Upper;
	break;

    case eSubtypeElement_SingleValue:

	/* single value: create a value constraint containing the element */
	if (evalue)
	    *evalue = eExtension_Unextended;
	if (!valueConstraints)
	    error(E_constraint_too_complex, NULL);
	v = GetValue(ass, element->U.SingleValue.Value);
	switch (GetTypeType(ass, v->Type)) {
	case eType_Integer:
	    *valueConstraints = NewValueConstraint();
	    (*valueConstraints)->Lower.Flags =
		(*valueConstraints)->Upper.Flags = 0;
	    (*valueConstraints)->Lower.Value =
		(*valueConstraints)->Upper.Value = v;
	    break;
	case eType_NumericString:
	case eType_PrintableString:
	case eType_TeletexString:
	case eType_T61String:
	case eType_VideotexString:
	case eType_IA5String:
	case eType_GraphicString:
	case eType_VisibleString:
	case eType_ISO646String:
	case eType_GeneralString:
	case eType_UniversalString:
	case eType_BMPString:
	case eType_RestrictedString:
	    if (inPermAlpha) {

		/* single value of a string is used for permitted alphabet */
		/* the characters of the string shall be interpreted as a */
		/* union of the characters */
		p = valueConstraints;
		for (i = 0; i < v->U.RestrictedString.Value.length; i++) {
		    *p = NewValueConstraint();
		    (*p)->Lower.Flags = (*p)->Upper.Flags = 0;
		    (*p)->Lower.Value = (*p)->Upper.Value =
			NewValue(ass, GetType(ass, v->Type));
		    (*p)->Lower.Value->U.RestrictedString.Value.length = 1;
		    (*p)->Lower.Value->U.RestrictedString.Value.value =
			(char32_t *)malloc(sizeof(char32_t));
		    (*p)->Lower.Value->U.RestrictedString.Value.value[0] =
			v->U.RestrictedString.Value.value[i];
		    p = &(*p)->Next;
		}
		*p = 0;
	    }
	    break;
	default:
	    /* value element of other types may be ignored for per */
	    break;
	}
	break;

    case eSubtypeElement_Size:

	/* size: get the size constraint */
	if (!sizeConstraints || inPermAlpha)
	    error(E_constraint_too_complex, NULL);
	GetAllPERFromConstraints(ass,
	    element->U.Size.Constraints,
	    esize, sizeConstraints, esizeConstraints,
	    NULL, NULL, NULL,
	    NULL, NULL, NULL,
	    inPermAlpha);
	break;

    case eSubtypeElement_PermittedAlphabet:

	/* permitted alphabet: get the permitted alphabet constraint */
	if (!permAlphaConstraints || inPermAlpha)
	    error(E_constraint_too_complex, NULL);
	GetAllPERFromConstraints(ass,
	    element->U.PermittedAlphabet.Constraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    NULL, NULL, NULL,
	    NULL, NULL, NULL,
	    1);
	break;

    case eSubtypeElement_ContainedSubtype:

	/* contained subtype: */
	if (inPermAlpha) {

	    /* get the permitted alphabet of the referenced type */
	    GetAllPERFromConstraints(ass, GetType(ass,
		element->U.ContainedSubtype.Type)->Constraints,
		&ev, &vc, &evc,
		&es, &sc, &esc,
		evalue, valueConstraints, evalueConstraints,
		inPermAlpha);

	    /* drop extensions for contained subtype constraints */
	    if (evalue && *evalue > eExtension_Unextended) {
		*evalue = eExtension_Unextended;
		if (evalueConstraints)
		    *evalueConstraints = NULL;
	    }

	} else {

	    /* get the constraints of the referenced type */
	    GetAllPERFromConstraints(ass, GetType(ass,
		element->U.ContainedSubtype.Type)->Constraints,
		evalue, valueConstraints, evalueConstraints,
		esize, sizeConstraints, esizeConstraints,
		epermAlpha, permAlphaConstraints, epermAlphaConstraints,
		inPermAlpha);

	    /* drop extensions for contained subtype constraints */
	    if (evalue && *evalue > eExtension_Unextended) {
		*evalue = eExtension_Unextended;
		if (evalueConstraints)
		    *evalueConstraints = NULL;
	    }
	    if (esize && *esize > eExtension_Unextended) {
		*esize = eExtension_Unextended;
		if (esizeConstraints)
		    *esizeConstraints = NULL;
	    }
	    if (epermAlpha && *epermAlpha > eExtension_Unextended) {
		*epermAlpha = eExtension_Unextended;
		if (epermAlphaConstraints)
		    *epermAlphaConstraints = NULL;
	    }
	}
	break;

    case eSubtypeElement_Type:
    case eSubtypeElement_SingleType:
    case eSubtypeElement_FullSpecification:
    case eSubtypeElement_PartialSpecification:

	/* not PER-visible constraints */
	break;

    case eSubtypeElement_ElementSetSpec:

	/* get the constraints of the element set spec */
	GetAllPERFromElementSetSpecs(ass,
	    element->U.ElementSetSpec.ElementSetSpec,
	    evalue, valueConstraints, evalueConstraints,
	    esize, sizeConstraints, esizeConstraints,
	    epermAlpha, permAlphaConstraints, epermAlphaConstraints,
	    inPermAlpha);
	break;

    default:
	MyAbort();
    }
}

/* intersect two value constraints */
static void
IntersectValueConstraints(AssignmentList_t ass,
    ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    ValueConstraint_t *v1, *v2;
    EndPoint_t lo, up;

    /*XXX may be optimized for better results */

    /* unite intersection of each pair of value ranges */
    for (v1 = val1; v1; v1 = v1->Next) {
	for (v2 = val2; v2; v2 = v2->Next) {

	    /* get bigger lower bound */
	    if (CmpLowerEndPoint(ass, &v1->Lower, &v2->Lower) >= 0)
		lo = v1->Lower;
	    else
		lo = v2->Lower;

	    /* get smaller upper bound */
	    if (CmpUpperEndPoint(ass, &v1->Upper, &v2->Upper) <= 0)
		up = v1->Upper;
	    else
		up = v2->Upper;

	    /* add intersection if it is not empty */
	    if ((lo.Flags & eEndPoint_Min) ||
		(up.Flags & eEndPoint_Max) ||
		CmpLowerUpperEndPoint(ass, &lo, &up) <= 0) {
		*result = NewValueConstraint();
		(*result)->Lower = lo;
		(*result)->Upper = up;
		result = &(*result)->Next;
	    }
	}
    }
    *result = NULL;
}

/* unite two value constraints */
static void
UniteValueConstraints(ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    /*XXX may be optimized for better results */
    for (; val1; val1 = val1->Next) {
	*result = NewValueConstraint();
	(*result)->Lower = val1->Lower;
	(*result)->Upper = val1->Upper;
	result = &(*result)->Next;
    }
    for (; val2; val2 = val2->Next) {
	*result = NewValueConstraint();
	(*result)->Lower = val2->Lower;
	(*result)->Upper = val2->Upper;
	result = &(*result)->Next;
    }
    *result = NULL;
}

/* negate a value constraint */
static void
NegateValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val)
{
    ValueConstraint_t *vc, *lvc, *uvc;
    EndPoint_t *lower, *upper;

    *result = NewValueConstraint();
    (*result)->Lower.Flags = eEndPoint_Min;
    (*result)->Upper.Flags = eEndPoint_Max;
    for (; val; val = val->Next) {
	lower = &val->Lower;
	upper = &val->Upper;
	if (!(upper->Flags & eEndPoint_Max)) {
	    uvc = NewValueConstraint();
	    uvc->Lower.Flags = (upper->Flags & eEndPoint_Open) ^ eEndPoint_Open;
	    uvc->Lower.Value = upper->Value;
	    uvc->Upper.Flags = eEndPoint_Max;
	} else {
	    uvc = NULL;
	}
	if (!(lower->Flags & eEndPoint_Min)) {
	    lvc = NewValueConstraint();
	    lvc->Lower.Flags = eEndPoint_Min;
	    lvc->Upper.Flags = (lower->Flags & eEndPoint_Open) ^ eEndPoint_Open;
	    lvc->Upper.Value = lower->Value;
	} else {
	    lvc = NULL;
	}
	if (!lvc && !uvc) {
	    *result = NULL;
	    return;
	}
	if (lvc) {
	    vc = lvc;
	    if (uvc)
		vc->Next = uvc;
	} else {
	    vc = uvc;
	}
	IntersectValueConstraints(ass, result, *result, vc);
    }
}

/* substract two value constraints */
static void
ExcludeValueConstraints(AssignmentList_t ass, ValueConstraintList_t *result,
    ValueConstraintList_t val1, ValueConstraintList_t val2)
{
    ValueConstraint_t *notval2;

    NegateValueConstraints(ass, &notval2, val2);
    IntersectValueConstraints(ass, result, val1, notval2);
}

/* intersect two constraints */
static void
IntersectPERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 < type2 ? type1 : type2;
	if (result)
	    IntersectValueConstraints(ass, result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    IntersectValueConstraints(ass, eresult, eval1, eval2);
    }
}

/* unite two constraints */
static void
UnitePERConstraints(Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 > type2 ? type1 : type2;
	if (result)
	    UniteValueConstraints(result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    UniteValueConstraints(eresult,
		eval1 ? eval1 : val1, eval2 ? eval2 : val2);
    }
}

/* negate a constraint */
static void
NegatePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1)
{
    if (rtype)
	*rtype = type1;
    if (result)
	NegateValueConstraints(ass, result, val1);
    if (rtype && *rtype == eExtension_Extended && eresult)
	NegateValueConstraints(ass, eresult, eval1);
}

/* substract two constraints */
static void
ExcludePERConstraints(AssignmentList_t ass,
    Extension_e *rtype,
    ValueConstraintList_t *result, ValueConstraintList_t *eresult,
    Extension_e type1,
    ValueConstraintList_t val1, ValueConstraintList_t eval1,
    Extension_e type2,
    ValueConstraintList_t val2, ValueConstraintList_t eval2)
{
    if (type1 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type2;
	if (result)
	    *result = val2;
	if (eresult)
	    *eresult = eval2;
    } else if (type2 == eExtension_Unconstrained) {
	if (rtype)
	    *rtype = type1;
	if (result)
	    *result = val1;
	if (eresult)
	    *eresult = eval1;
    } else {
	if (rtype)
	    *rtype = type1 < type2 ? type1 : type2;
	if (result)
	    ExcludeValueConstraints(ass, result, val1, val2);
	if (rtype && *rtype == eExtension_Extended && eresult)
	    ExcludeValueConstraints(ass, eresult, eval1, eval2);
    }
}

/* compare two value constraints */
static int
CmpValueConstraints(const void *v1, const void *v2, void *ctx)
{
    ValueConstraint_t *vc1 = (ValueConstraint_t *)v1;
    ValueConstraint_t *vc2 = (ValueConstraint_t *)v2;
    Assignment_t *ass = (Assignment_t *)ctx;
    int r;

    r = CmpLowerEndPoint(ass, &vc1->Lower, &vc2->Lower);
    if (r)
	return r;
    return CmpUpperEndPoint(ass, &vc1->Upper, &vc2->Upper);
}

/* reduce a value constraint by concatenation of value ranges (if possible) */
void
ReduceValueConstraints(AssignmentList_t ass, ValueConstraintList_t *valueConstraints)
{
    ValueConstraint_t *p;
    EndPoint_t lower, upper, lower2, upper2;
    int flg;

    if (!*valueConstraints)
	return;
    qsortSL((void **)valueConstraints, offsetof(ValueConstraint_t, Next),
    	CmpValueConstraints, ass);
    flg = 0;
    for (p = *valueConstraints; p; p = p->Next) {
    	if (flg) {
	    lower2 = p->Lower;
	    upper2 = p->Upper;
	    if (CheckEndPointsJoin(ass, &upper, &lower2)) {
		upper = upper2;
		continue;
	    }
	    *valueConstraints = NewValueConstraint();
	    /*LINTED*/
	    (*valueConstraints)->Lower = lower;
	    (*valueConstraints)->Upper = upper;
	    valueConstraints = &(*valueConstraints)->Next;
	}
	lower = p->Lower;
	upper = p->Upper;
	flg = 1;
    }
    *valueConstraints = NewValueConstraint();
    (*valueConstraints)->Lower = lower;
    (*valueConstraints)->Upper = upper;
    (*valueConstraints)->Next = NULL;
}

/* count the values of a value constraint */
int
CountValues(AssignmentList_t ass, ValueConstraintList_t v, intx_t *n) {
    intx_t ix;

    intx_setuint32(n, 0);
    for (; v; v = v->Next) {
	if ((v->Lower.Flags & eEndPoint_Min) ||
	    (v->Upper.Flags & eEndPoint_Max))
	    return 0;
	if (!SubstractValues(ass, &ix, v->Lower.Value, v->Upper.Value))
	    return 0;
	intx_add(n, n, &ix);
	intx_inc(n);
    }
    return 1;
}


/* check if the value constraint of a value is empty */
int
HasNoValueConstraint(ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if ((p1->Flags & eEndPoint_Min) &&
	    (p2->Flags & eEndPoint_Max)) {
	    return 1;
	}
    }
    return 0;
}

/* check if the value constraint of a size is empty */
int
HasNoSizeConstraint(AssignmentList_t ass, ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if (!(p1->Flags & eEndPoint_Min) &&
	    !intx_cmp(&GetValue(ass, p1->Value)->U.Integer.Value,
	    &intx_0) && (p2->Flags & eEndPoint_Max)) {
	    return 1;
	}
    }
    return 0;
}

/* check if the value constraint of a permitted alphabet is empty */
int
HasNoPermittedAlphabetConstraint(AssignmentList_t ass, ValueConstraintList_t v)
{
    EndPoint_t *p1, *p2;

    if (!v)
	return 1;
    if (!v->Next) {
	p1 = &v->Lower;
	p2 = &v->Upper;
	if (!(p1->Flags & eEndPoint_Min) &&
	    GetValue(ass, p1->Value)->U.RestrictedString.Value.length == 1 &&
	    GetValue(ass, p1->Value)->U.RestrictedString.Value.value[0] == 0 &&
	    !(p2->Flags & eEndPoint_Max) &&
	    GetValue(ass, p2->Value)->U.RestrictedString.Value.length == 1 &&
	    GetValue(ass, p2->Value)->U.RestrictedString.Value.value[0]
	    == 0xffffffff) {
	    return 1;
	}
    }
    return 0;
}

/* get the fixed identification */
/* this is needed for embedded pdv/character string types who are encoded */
/* in an "optimized" manner if the identification is fixed */
NamedValue_t *
GetFixedIdentification(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedIdentificationFromElementSetSpec(ass, constraints->Root);
}

/* get the fixed identification from an element set spec */
static NamedValue_t *
GetFixedIdentificationFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    NamedConstraint_t *named;
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedIdentificationFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_FullSpecification:
	case eSubtypeElement_PartialSpecification:
	    for (named = se->U.FP.NamedConstraints; named;
		named = named->Next) {
		if (!strcmp(named->Identifier, "identification"))
		    return GetFixedSyntaxes(ass, named->Constraint);
	    }
	    break;
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}

/* get the fixed syntaxes from a constraint */
static NamedValue_t *
GetFixedSyntaxes(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedSyntaxesFromElementSetSpec(ass, constraints->Root);
}

/* get the fixed syntaxes from an element set spec */
static NamedValue_t *
GetFixedSyntaxesFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    int present, absent, bit;
    Constraint_t *presentconstraints[6];
    NamedConstraint_t *named;
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Intersection.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Intersection.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedSyntaxesFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_FullSpecification:
	case eSubtypeElement_PartialSpecification:
	    present = absent = 0;
	    for (named = se->U.FP.NamedConstraints; named;
		named = named->Next) {
		if (!strcmp(named->Identifier, "syntaxes")) {
		    bit = 0;
		} else if (!strcmp(named->Identifier, "syntax")) {
		    bit = 1;
		} else if (!strcmp(named->Identifier,
		    "presentation-context-id")) {
		    bit = 2;
		} else if (!strcmp(named->Identifier, "context-negotiation")) {
		    bit = 3;
		} else if (!strcmp(named->Identifier, "transfer-syntax")) {
		    bit = 4;
		} else if (!strcmp(named->Identifier, "fixed")) {
		    bit = 5;
		}
		switch (named->Presence) {
		case ePresence_Normal:
		    if (se->Type == eSubtypeElement_PartialSpecification)
			break;
		    /*FALLTHROUGH*/
		case ePresence_Present:
		    present |= (1 << bit);
		    presentconstraints[bit] = named->Constraint;
		    break;
		case ePresence_Absent:
		    absent |= (1 << bit);
		    break;
		case ePresence_Optional:
		    break;
		}
	    }
	    if (se->Type == eSubtypeElement_FullSpecification)
		absent |= (0x3f & ~present);
	    if (present == 0x20 && absent == 0x1f)
		return NewNamedValue("fixed", Builtin_Value_Null);
	    if (present == 0x01 && absent == 0x3e)
		return GetFixedAbstractAndTransfer(ass, presentconstraints[0]);
	    return NULL;
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}

/* get the fixed abstract and transfer from a constraint */
static NamedValue_t *
GetFixedAbstractAndTransfer(AssignmentList_t ass, Constraint_t *constraints)
{
    if (!constraints)
	return NULL;
    return GetFixedAbstractAndTransferFromElementSetSpec(ass,
	constraints->Root);
}

/* get the fixed abstract and transfer from an element set spec */
static NamedValue_t *
GetFixedAbstractAndTransferFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elements)
{
    NamedValue_t *nv1, *nv2;
    SubtypeElement_t *se;

    if (!elements)
	return NULL;
    switch (elements->Type) {
    case eElementSetSpec_AllExcept:
	return NULL;
    case eElementSetSpec_Union:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Union.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Union.Elements2);
	return nv1 && nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_Intersection:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Intersection.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Intersection.Elements2);
	return nv1 ? nv1 : nv2; /*XXX conflicts ignored */
    case eElementSetSpec_Exclusion:
	nv1 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements1);
	nv2 = GetFixedAbstractAndTransferFromElementSetSpec(ass,
	    elements->U.Exclusion.Elements2);
	return nv1 && !nv2 ? nv1 : NULL; /*XXX conflicts ignored */
    case eElementSetSpec_SubtypeElement:
	se = elements->U.SubtypeElement.SubtypeElement;
	switch (se->Type) {
	case eSubtypeElement_SingleValue:
	    return NewNamedValue("syntaxes", se->U.SingleValue.Value);
	}
	return NULL;
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\undefine.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* print all undefined/unexported symbols and terminate */
void
UndefinedError(AssignmentList_t ass, UndefinedSymbolList_t undef, UndefinedSymbol_t *bad)
{
    UndefinedSymbol_t *u;
    char *type;
    int undefined = 0, unexported = 0;
    char *identifier;

    /* count undefined and unexported symbols */
    for (u = undef; u; u = u->Next) {
	switch (u->Type) {
	case eUndefinedSymbol_SymbolNotDefined:
	case eUndefinedSymbol_SymbolNotExported:
	    if (FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    break;
	case eUndefinedSymbol_FieldNotDefined:
	case eUndefinedSymbol_FieldNotExported:
	    if (FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    break;
	}
	switch (u->Type) {
	case eUndefinedSymbol_SymbolNotDefined:
	case eUndefinedSymbol_FieldNotDefined:
	    undefined = 1;
	    break;
	case eUndefinedSymbol_SymbolNotExported:
	case eUndefinedSymbol_FieldNotExported:
	    unexported = 1;
	    break;
	}
    }

    /* print the undefined symbols */
    if (undefined) {
	fprintf(stderr, "Following symbols are undefined:\n");
	for (u = undef; u; u = u->Next) {
	    if (u->Type == eUndefinedSymbol_SymbolNotExported ||
	        u->Type == eUndefinedSymbol_FieldNotExported)
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined &&
		FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_FieldNotDefined &&
		FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined) {
		switch (u->U.Symbol.ReferenceType) {
		case eAssignment_Type:
		    type = "type";
		    break;
		case eAssignment_Value:
		    type = "value";
		    break;
		case eAssignment_ObjectClass:
		    type = "object class";
		    break;
		case eAssignment_Object:
		    type = "object";
		    break;
		case eAssignment_ObjectSet:
		    type = "object set";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		case eAssignment_Undefined:
		    if (isupper(*u->U.Symbol.Identifier))
			type = "type?";
		    else if (islower(*u->U.Symbol.Identifier))
			type = "value?";
		    else
			type = "?";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Symbol.Identifier ?
		    u->U.Symbol.Identifier : "<unnamed>";
		if (u->U.Symbol.Module) {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Symbol.Module->Identifier, identifier, type);
		} else {
		    fprintf(stderr, "%s (%s)\n", identifier, type);
		}
	    } else {
		switch (u->U.Field.ReferenceFieldType) {
		case eSetting_Type:
		    type = "type field";
		    break;
		case eSetting_Value:
		    type = "value field";
		    break;
		case eSetting_ValueSet:
		    type = "value set field";
		    break;
		case eSetting_Object:
		    type = "object field";
		    break;
		case eSetting_ObjectSet:
		    type = "object set field";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Field.Identifier ?
		    u->U.Field.Identifier : "<unnamed>";
		if (u->U.Field.Module) {
		    fprintf(stderr, "%s.%s.%s (%s)\n",
			u->U.Field.Module->Identifier,
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		} else {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		}
	    }
	}
    }

    /* print the unexported symbols */
    if (unexported) {
	fprintf(stderr, "Following symbols have not been exported:\n");
	for (u = undef; u; u = u->Next) {
	    if (u->Type == eUndefinedSymbol_SymbolNotDefined ||
	        u->Type == eUndefinedSymbol_FieldNotDefined)
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotExported &&
		FindUndefinedSymbol(ass, bad, u->U.Symbol.ReferenceType,
		u->U.Symbol.Identifier, u->U.Symbol.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_FieldNotExported &&
		FindUndefinedField(ass, bad, u->U.Field.ReferenceFieldType,
		u->U.Field.ObjectClass, u->U.Field.Identifier,
		u->U.Field.Module))
		continue;
	    if (u->Type == eUndefinedSymbol_SymbolNotExported) {
		switch (u->U.Symbol.ReferenceType) {
		case eAssignment_Type:
		    type = "type";
		    break;
		case eAssignment_Value:
		    type = "value";
		    break;
		case eAssignment_ObjectClass:
		    type = "object class";
		    break;
		case eAssignment_Object:
		    type = "object";
		    break;
		case eAssignment_ObjectSet:
		    type = "object set";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		case eAssignment_Undefined:
		    if (isupper(*u->U.Symbol.Identifier))
			type = "type?";
		    else if (islower(*u->U.Symbol.Identifier))
			type = "value?";
		    else
			type = "?";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Symbol.Identifier ?
		    u->U.Symbol.Identifier : "<unnamed>";
		if (u->U.Symbol.Module) {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Symbol.Module->Identifier, identifier, type);
		} else {
		    fprintf(stderr, "%s (%s)\n", identifier, type);
		}
	    } else {
		switch (u->U.Field.ReferenceFieldType) {
		case eSetting_Type:
		    type = "type field";
		    break;
		case eSetting_Value:
		    type = "value field";
		    break;
		case eSetting_ValueSet:
		    type = "value set field";
		    break;
		case eSetting_Object:
		    type = "object field";
		    break;
		case eSetting_ObjectSet:
		    type = "object set field";
		    break;
		case eAssignment_Macro:
		    type = "macro";
		    break;
		default:
		    MyAbort();
		    /*NOTREACHED*/
		}
		identifier = u->U.Field.Identifier ?
		    u->U.Field.Identifier : "<unnamed>";
		if (u->U.Field.Module) {
		    fprintf(stderr, "%s.%s.%s (%s)\n",
			u->U.Field.Module->Identifier,
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		} else {
		    fprintf(stderr, "%s.%s (%s)\n",
			u->U.Field.ObjectClass->U.Reference.Identifier,
			identifier, type);
		}
	    }
	}
    }
    MyExit(1);
}

/* compare two undefined symbol entries */
/* return 0 if equal */
int CmpUndefinedSymbol(AssignmentList_t ass, UndefinedSymbol_t *u1, UndefinedSymbol_t *u2) {
    if (u1->Type != u2->Type)
	return 1;
    switch (u1->Type) {
    case eUndefinedSymbol_SymbolNotExported:
    case eUndefinedSymbol_SymbolNotDefined:
        return strcmp(u1->U.Symbol.Identifier, u2->U.Symbol.Identifier) ||
	    u1->U.Symbol.Module && !u2->U.Symbol.Module ||
	    !u1->U.Symbol.Module && u2->U.Symbol.Module ||
	    u1->U.Symbol.Module && u2->U.Symbol.Module &&
	    CmpModuleIdentifier(ass, u1->U.Symbol.Module, u2->U.Symbol.Module);
    case eUndefinedSymbol_FieldNotExported:
    case eUndefinedSymbol_FieldNotDefined:
        return strcmp(u1->U.Field.Identifier, u2->U.Field.Identifier) ||
	    strcmp(u1->U.Field.ObjectClass->U.Reference.Identifier,
	    u2->U.Field.ObjectClass->U.Reference.Identifier) ||
	    CmpModuleIdentifier(ass,
	    u1->U.Field.ObjectClass->U.Reference.Module,
	    u2->U.Field.ObjectClass->U.Reference.Module) ||
	    u1->U.Field.Module && !u2->U.Field.Module ||
	    !u1->U.Field.Module && u2->U.Field.Module ||
	    u1->U.Field.Module && u2->U.Field.Module &&
	    CmpModuleIdentifier(ass, u1->U.Field.Module, u2->U.Field.Module);
    default:
	MyAbort();
	/*NOTREACHED*/
    }
    return 1; // not equal
}

/* compare two lists of undefined symbols */
int CmpUndefinedSymbolList(AssignmentList_t ass, UndefinedSymbolList_t u1, UndefinedSymbolList_t u2) {
    for (; u1 && u2; u1 = u1->Next, u2 = u2->Next) {
	if (CmpUndefinedSymbol(ass, u1, u2))
	    return 1;
    }
    return u1 || u2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\types.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: when we call any routine in this file, we must use kernel memory,
// otheriwse, the client app should free the buffer in its entirety
// rather than free the structure piece by piece.

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    union {
        double val;
        ASN1octet_t octets[1];
    } mix;
    memcpy(mix.octets, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return mix.val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    union {
        double val;
        ASN1octet_t octets[1];
    } mix;
    memcpy(mix.octets, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return mix.val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* convert a real value into a double */
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                ASN1intx_dup(&exp, &val->exponent);
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}

/* free a real value */
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    // lonchanc: we allocate the entire object identifer as a chunk.
    // as a result, we free it only once as a chunk.
    if (*val)
        free(*val);
}

/* free a string value */
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a 32 bit string value */
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val->length)
        free(val->value);
}

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    free(val);
}

/* free a zero-terminated 16 bit string value */
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    free(val);
}

/* free a zero-terminated 32 bit string value */
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    free(val);
}

/* free an external value */
void ASN1external_free(ASN1external_t *val)
{
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1external_identification_presentation_context_id_o:
        break;
    case ASN1external_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    }
    ASN1ztcharstring_free(val->data_value_descriptor);
    switch (val->data_value.o) {
    case ASN1external_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1external_data_value_encoded_o:
        ASN1bitstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free an embedded pdv value */
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    switch (val->identification.o) {
    case ASN1embeddedpdv_identification_syntaxes_o:
        ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
        ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
        break;
    case ASN1embeddedpdv_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1embeddedpdv_identification_presentation_context_id_o:
        break;
    case ASN1embeddedpdv_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    case ASN1embeddedpdv_identification_transfer_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
        break;
    case ASN1embeddedpdv_identification_fixed_o:
        break;
    }
    switch (val->data_value.o) {
    case ASN1embeddedpdv_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        ASN1bitstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free a character string value */
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    switch (val->identification.o) {
    case ASN1characterstring_identification_syntaxes_o:
        ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
        ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
        break;
    case ASN1characterstring_identification_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.syntax);
        break;
    case ASN1characterstring_identification_presentation_context_id_o:
        break;
    case ASN1characterstring_identification_context_negotiation_o:
        ASN1objectidentifier_free(
            &val->identification.u.context_negotiation.transfer_syntax);
        break;
    case ASN1characterstring_identification_transfer_syntax_o:
        ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
        break;
    case ASN1characterstring_identification_fixed_o:
        break;
    }
    switch (val->data_value.o) {
    case ASN1characterstring_data_value_notation_o:
        ASN1open_free(&val->data_value.u.notation);
        break;
    case ASN1characterstring_data_value_encoded_o:
        ASN1octetstring_free(&val->data_value.u.encoded);
        break;
    }
}

/* free an open type value */
void ASN1open_free(ASN1open_t *val)
{
    if (val->length)
        free(val->encoded);
}

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    sprintf(dst, "%04d%02d%02d%02d%02d%02d",
        val->year, val->month, val->day,
        val->hour, val->minute, val->second);
    if (val->millisecond) {
        if (!(val->millisecond % 100))
            sprintf(dst + 14, ".%01d", val->millisecond / 100);
        else if (!(val->millisecond % 10))
            sprintf(dst + 14, ".%02d", val->millisecond / 10);
        else
            sprintf(dst + 14, ".%03d", val->millisecond);
    }
    if (val->universal)
        strcpy(dst + strlen(dst), "Z");
    else if (val->diff > 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "+%04d",
                100 * (val->diff / 60) + (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "+%02d",
                val->diff / 60);
        }
    } else if (val->diff < 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "-%04d",
                -100 * (val->diff / 60) - (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "-%02d",
                -val->diff / 60);
        }
    }
    return 1;
}

/* convert a utc time value into a string */
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    sprintf(dst, "%02d%02d%02d%02d%02d",
        val->year, val->month, val->day,
        val->hour, val->minute);
    if (val->second)
        sprintf(dst + 10, "%02d", val->second);
    if (val->universal)
        strcpy(dst + strlen(dst), "Z");
    else if (val->diff > 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "+%04d",
                100 * (val->diff / 60) + (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "+%02d",
                val->diff / 60);
        }
    } else if (val->diff < 0) {
        if (val->diff % 60) {
            sprintf(dst + strlen(dst), "-%04d",
                -100 * (val->diff / 60) - (val->diff % 60));
        } else {
            sprintf(dst + strlen(dst), "-%02d",
                -val->diff / 60);
        }
    }
    return 1;
}

/* scan the fraction of a number */
static double scanfrac(char *p, char **e)
{
    double ret = 0.0, d = 1.0;

    while (isdigit(*p)) {
        d /= 10.0;
        ret += (*p++ - '0') * d;
    }
    *e = p;
    return ret;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    int year, month, day, hour, minute, second, millisecond, diff, universal;
    char *p;
    double f;

    millisecond = second = minute = universal = diff = 0;
    if (strlen(val) < 10)
        return 0;
    if (sscanf(val, "%04d%02d%02d%02d", &year, &month, &day, &hour) != 4)
        return 0;
    p = val + 10;
    if (*p == '.' || *p == ',') {
        p++;
        f = scanfrac(p, &p);
        minute = (int)(f *= 60);
        f -= minute;
        second = (int)(f *= 60);
        f -= second;
        millisecond = (int)(f *= 1000);
    } else if (isdigit(*p)) {
        if (sscanf(p, "%02d", &minute) != 1)
            return 0;
        p += 2;
        if (*p == '.' || *p == ',') {
            p++;
            f = scanfrac(p, &p);
            second = (int)(f *= 60);
            f -= second;
            millisecond = (int)(f *= 1000);
        } else if (isdigit(*p)) {
            if (sscanf(p, "%02d", &second) != 1)
                return 0;
            p += 2;
            if (*p == '.' || *p == ',') {
                p++;
                f = scanfrac(p, &p);
                millisecond = (int)(f *= 1000);
            }
        }
    }
    if (*p == 'Z') {
        universal = 1;
        p++;
    } else if (*p == '+') {
        f = scanfrac(p + 1, &p);
        diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
    } else if (*p == '-') {
        f = scanfrac(p + 1, &p);
        diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
    }
    if (*p)
        return 0;
    dst->year = (ASN1uint16_t)year;
    dst->month = (ASN1uint8_t)month;
    dst->day = (ASN1uint8_t)day;
    dst->hour = (ASN1uint8_t)hour;
    dst->minute = (ASN1uint8_t)minute;
    dst->second = (ASN1uint8_t)second;
    dst->millisecond = (ASN1uint16_t)millisecond;
    dst->universal = (ASN1bool_t)universal;
    dst->diff = (ASN1uint16_t)diff;
    return 1;
}

/* convert a string into a utc time value */
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    int year, month, day, hour, minute, second, diff, universal;
    char *p;
    double f;

    second = universal = diff = 0;
    if (strlen(val) < 10)
        return 0;

    if (sscanf(val, "%02d%02d%02d%02d%02d",
        &year, &month, &day, &hour, &minute) != 5)
        return 0;
    p = val + 10;
    if (isdigit(*p)) {
        if (sscanf(p, "%02d", &second) != 1)
            return 0;
        p += 2;
    }
    if (*p == 'Z') {
        universal = 1;
        p++;
    } else if (*p == '+') {
        f = scanfrac(p + 1, &p);
        diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
    } else if (*p == '-') {
        f = scanfrac(p + 1, &p);
        diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
    }
    if (*p)
        return 0;
    dst->year = (ASN1uint8_t)year;
    dst->month = (ASN1uint8_t)month;
    dst->day = (ASN1uint8_t)day;
    dst->hour = (ASN1uint8_t)hour;
    dst->minute = (ASN1uint8_t)minute;
    dst->second = (ASN1uint8_t)second;
    dst->universal = (ASN1bool_t)universal;
    dst->diff = (ASN1uint16_t)diff;
    return 1;
}


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while ((! dst) || (! src))
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) malloc(cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\util.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_UTIL_H_
#define _ASN1C_UTIL_H_

size_t SLlength(void *head, size_t offset);
int SLcontains(void *head, size_t offset, void *elem);
void SLtoA(void *head, size_t offset, size_t elemsize, void **base, size_t *nelem);
void SLtoAP(void *head, size_t offset, void ***base, size_t *nelem);
void AtoSL(void *base, size_t offset, size_t nelem, size_t elemsize, void **head);
void qsortSL(void **head, size_t offset, int (*cmpfn)(const void *, const void *, void *), void *context);

void MyAbort(void);
void MyExit(int val);

#endif /* _ASN1C_UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\write.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1C_WRITE_H_
#define _ASN1C_WRITE_H_

void setoutfile(FILE *);
/*PRINTFLIKE1*/
void output(const char *fmt, ...);
/*PRINTFLIKE1*/
void outputni(const char *fmt, ...);
void outputreal(const char *fmt, real_t *real);
void outputoctets(const char *name, uint32_t length, octet_t *val);
void outputuint32s(const char *name, uint32_t length, uint32_t *val);
void outputvalue0(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value);
void outputvalue1(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value);
void outputvalue2(AssignmentList_t ass, char *ideref, Value_t *value);
void outputvalue3(AssignmentList_t ass, char *ideref, char *valref, Value_t *value);
/*PRINTFLIKE1*/
void outputvar(const char *fmt, ...);
void outputvarintx(const char *fmt, intx_t *intx);
void outputvarreal(const char *fmt, real_t *real);
void outputvaroctets(const char *name, uint32_t length, octet_t *val);

#endif // _ASN1C_WRITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\yywrap.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

int yywrap()
{
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\util.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

extern int g_fLongNameForImported;

/* get the type by resolving references */
Type_t *
GetType(AssignmentList_t ass, Type_t *type)
{
    if (!type)
        return NULL;
    if (IsReferenceType(type))
        return GetType(ass, GetReferencedType(ass, type));
    return type;
}

/* get the type's type by resolving references */
Type_e
GetTypeType(AssignmentList_t ass, Type_t *type)
{
    type = GetType(ass, type);
    return type ? type->Type : eType_Undefined;
}

/* get the type rules */
TypeRules_e
GetTypeRules(AssignmentList_t ass, Type_t *type)
{
    if (!IsReferenceType(type))
        return type->Rules;
    return type->Rules | GetTypeRules(ass, GetReferencedType(ass, type));
}

/* get the value by resolving references */
Value_t *
GetValue(AssignmentList_t ass, Value_t *value)
{
    Assignment_t *a;

    if (!value)
        return NULL;
    if (!value->Type) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_Value,
            value->U.Reference.Identifier, value->U.Reference.Module));
        if (!a)
            return NULL;
        return GetValue(ass, a->U.Value.Value);
    }
    return value;
}

/* get the object class by resolving references */
ObjectClass_t *
GetObjectClass(AssignmentList_t ass, ObjectClass_t *oc)
{
    Assignment_t *a;
    FieldSpec_t *fs;
    ObjectClass_t *oc2;

    if (!oc)
        return NULL;
    switch (oc->Type) {
    case eObjectClass_Reference:
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_ObjectClass,
            oc->U.Reference.Identifier, oc->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObjectClass(ass, a->U.ObjectClass.ObjectClass);
    case eObjectClass_FieldReference:
        oc2 = GetObjectClass(ass, oc->U.FieldReference.ObjectClass);
        if (!oc2)
            return NULL;
        fs = GetFieldSpec(ass, FindFieldSpec(oc2->U.ObjectClass.FieldSpec,
            oc->U.FieldReference.Identifier));
        if (!fs)
            return NULL;
        if (fs->Type == eFieldSpec_Object)
            return GetObjectClass(ass, fs->U.Object.ObjectClass);
        else if (fs->Type == eFieldSpec_ObjectSet)
            return GetObjectClass(ass, fs->U.ObjectSet.ObjectClass);
        else
            return NULL;
    }
    return oc;
}

/* get the object by resolving references */
Object_t *
GetObject(AssignmentList_t ass, Object_t *o)
{
    Assignment_t *a;

    if (!o)
        return NULL;
    if (o->Type == eObject_Reference) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_Object,
            o->U.Reference.Identifier, o->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObject(ass, a->U.Object.Object);
    }
    return o;
}

/* get the object set by resolving references */
ObjectSet_t *
GetObjectSet(AssignmentList_t ass, ObjectSet_t *os)
{
    Assignment_t *a;

    if (!os)
        return NULL;
    if (os->Type == eObjectSet_Reference) {
        a = GetAssignment(ass, FindAssignment(ass, eAssignment_ObjectSet,
            os->U.Reference.Identifier, os->U.Reference.Module));
        if (!a)
            return NULL;
        return GetObjectSet(ass, a->U.ObjectSet.ObjectSet);
    }
    return os;
}

/* get the field spec */
FieldSpec_t *
GetFieldSpec(AssignmentList_t ass, FieldSpec_t *fs)
{
    return fs;
}

/* get the field spec type */
FieldSpecs_e
GetFieldSpecType(AssignmentList_t ass, FieldSpec_t *fs)
{
    return fs ? fs->Type : eFieldSpec_Undefined;
}

/* convert an identifier into C syntax */
char *
Identifier2C(char *identifier)
{
    char buffer[256];
    char *p = buffer;

    while (*identifier) {
        if (isalnum(*identifier))
            *p++ = *identifier;
        else
            *p++ = '_';
        identifier++;
    }
    *p = 0;
    return strdup(buffer);
}

/* convert an identifier into C syntax */
char *
PIdentifier2C(char *identifier)
{
    char buffer[256];
    char *p = buffer;

    *p++ = 'P';
    while (*identifier) {
        if (isalnum(*identifier))
            *p++ = *identifier;
        else
            *p++ = '_';
        identifier++;
    }
    *p = 0;
    return strdup(buffer);
}

/* get the integer type and the sign of an integer with the given bounds */
static char *
GetIType(intx_t *lb, intx_t *ub, int32_t *sign)
{
    enum {
        eint8 = 1,
        euint8 = 2,
        eint16 = 4,
        euint16 = 8,
        eint32 = 16,
        euint32 = 32,
        eint64 = 64,
        euint64 = 128,
        eintx = 256,
        euintx = 512
    } type;
    
    type = (eint8 | euint8 | eint16 | euint16 | eint32 | euint32 | eintx | euintx);
    if (Has64Bits)
        type |= eint64 | euint64;
    if (!intxisuint8(lb) || !intxisuint8(ub))
        type &= ~euint8;
    if (!intxisuint16(lb) || !intxisuint16(ub))
        type &= ~euint16;
    if (!intxisuint32(lb) || !intxisuint32(ub))
        type &= ~euint32;
    if (!intxisuint64(lb) || !intxisuint64(ub))
        type &= ~euint64;
    if (!intxisint8(lb) || !intxisint8(ub))
        type &= ~eint8;
    if (!intxisint16(lb) || !intxisint16(ub))
        type &= ~eint16;
    if (!intxisint32(lb) || !intxisint32(ub))
        type &= ~eint32;
    if (!intxisint64(lb) || !intxisint64(ub))
        type &= ~eint64;
    if (lb->value[0] >= 0x7f || ub->value[0] >= 0x7f)
        type &= ~euintx;
    if (type & euint8) {
        *sign = 1;
        return "ASN1uint16_t"; // lonchanc: for av; original is "ASN1uint8_t";
    }
    if (type & eint8) {
        *sign = -1;
        return "ASN1int8_t";
    }
    if (type & euint16) {
        *sign = 1;
        return "ASN1uint16_t";
    }
    if (type & eint16) {
        *sign = -1;
        return "ASN1int16_t";
    }
    if (type & euint32) {
        *sign = 1;
        return "ASN1uint32_t";
    }
    if (type & eint32) {
        *sign = -1;
        return "ASN1int32_t";
    }
    if (type & euint64) {
        *sign = 1;
        return "ASN1uint64_t";
    }
    if (type & eint64) {
        *sign = -1;
        return "ASN1int64_t";
    }
    if (type & euintx) {
        *sign = 1;
        return "ASN1intx_t";
    }
    if (type & eintx) {
        *sign = -1;
        return "ASN1intx_t";
    }
    MyAbort();
    /*NOTREACHED*/
    return NULL;
}

/* adjust the lower and upper bound according to the value constraints in */
/* the constraints list */
void GetMinMax(AssignmentList_t ass, ValueConstraintList_t constraints,
    EndPoint_t *lower, EndPoint_t *upper)
{
    ValueConstraint_t *vc;
    EndPoint_t lo, up;

    for (vc = constraints; vc; vc = vc->Next) {
        lo = vc->Lower;
        up = vc->Upper;
        if (CmpLowerEndPoint(ass, lower, &lo) > 0)
            *lower = lo;
        if (CmpUpperEndPoint(ass, upper, &up) < 0)
            *upper = up;
    }
}

/* get the integer type and the sign of an integer with the given bounds */
char *GetIntType(AssignmentList_t ass, EndPoint_t *lower, EndPoint_t *upper, int32_t *sign)
{
    char *inttype;

    if (!(lower->Flags & eEndPoint_Min) &&
        !(upper->Flags & eEndPoint_Max)) {
        inttype = GetIType(&GetValue(ass, lower->Value)->U.Integer.Value,
            &GetValue(ass, upper->Value)->U.Integer.Value, sign);
    } else {
        if (!(lower->Flags & eEndPoint_Min) &&
            intx_cmp(&GetValue(ass, lower->Value)->U.Integer.Value, &intx_0) >= 0) {
            inttype = UIntegerRestriction;
            *sign = 1;
        } else {
            inttype = IntegerRestriction;
            *sign = -1;
        }
        if (!strncmp(inttype, "ASN1uint", 8))
            *sign = 1;
        else if (!strncmp(inttype, "ASN1int", 7))
            *sign = -1;
    }
    return inttype;
}

/* get the integer type and the sign of an integer type */
char *GetIntegerType(AssignmentList_t ass, Type_t *type, int32_t *sign)
{
    EndPoint_t lower, upper;

    if (type->PrivateDirectives.fIntx)
    {
        return "ASN1intx_t";
    }

    lower.Flags = eEndPoint_Max;
    upper.Flags = eEndPoint_Min;
    GetMinMax(ass, type->PERConstraints.Value.Root, &lower, &upper);
    if (type->PERConstraints.Value.Type == eExtension_Extended)
        GetMinMax(ass, type->PERConstraints.Value.Additional,
            &lower, &upper);
    if (lower.Flags & eEndPoint_Max)
        lower.Flags = eEndPoint_Min;
    if (upper.Flags & eEndPoint_Min)
        upper.Flags = eEndPoint_Max;
    return GetIntType(ass, &lower, &upper, sign);
}

/* get the real type */
/*ARGSUSED*/
char *GetRealType(Type_t *type)
{
    return RealRestriction;
}

/* get the boolean type */
char *GetBooleanType()
{
    return "ASN1bool_t";
}

/* get the enumerated type */
char *GetEnumeratedType(AssignmentList_t ass, Type_t *type, int32_t *sign)
{
#if 1 // added by Microsoft
    return "ASN1enum_t";
#else
    EndPoint_t lower, upper, ep;
    NamedNumber_t *namedNumbers;

    lower.Flags = eEndPoint_Max;
    upper.Flags = eEndPoint_Min;
    ep.Flags = 0;
    for (namedNumbers = type->U.Enumerated.NamedNumbers; namedNumbers;
        namedNumbers = namedNumbers->Next) {
        switch (namedNumbers->Type) {
        case eNamedNumber_Normal:
            ep.Value = namedNumbers->U.Normal.Value;
            if (CmpLowerEndPoint(ass, &lower, &ep) > 0)
                lower = ep;
            if (CmpUpperEndPoint(ass, &upper, &ep) < 0)
                upper = ep;
            break;
        case eNamedNumber_ExtensionMarker:
            break;
        }
    }
    if (lower.Flags & eEndPoint_Max)
        lower.Flags = eEndPoint_Min;
    if (upper.Flags & eEndPoint_Min)
        upper.Flags = eEndPoint_Max;
    return GetIntType(ass, &lower, &upper, sign);
#endif
}

/* get the type of an choice selector */
char *GetChoiceType(Type_t *type)
{
#if 1 // added by Microsoft
    return "ASN1choice_t";
#else
    uint32_t nchoice;
    Component_t *components;

    nchoice = 0;
    for (components = type->U.Choice.Components; components;
        components = components->Next) {
        switch (components->Type) {
        case eComponent_Normal:
            nchoice++;
            break;
        case eComponent_ExtensionMarker:
            nchoice++; /* one reserved value for unknown extensions */
            break;
        default:
            MyAbort();
        }
    }
    if (nchoice < 0x100)
        return "ASN1uint8_t";
    if (nchoice < 0x10000)
        return "ASN1uint16_t";
    return "ASN1uint32_t";
#endif
}

/* get the type of a string */
char *GetStringType(AssignmentList_t ass, Type_t *type, int32_t *noctets, uint32_t *zero)
{
    EndPoint_t lower, upper;
    uint32_t up;

    type = GetType(ass, type);
    *zero = type->PrivateDirectives.fLenPtr ? 0 : 1; // null terminator

    /* get the upper bound and zero flag of the type */
    switch (type->Type) {
    case eType_NumericString:
        up = 0x39;
        break;
    case eType_PrintableString:
        up = 0x7a;
        break;
    case eType_ISO646String:
    case eType_VisibleString:
        up = 0x7e;
        break;
    case eType_IA5String:
        up = 0x7f;
        // *zero = 0;
        break;
    case eType_UTF8String:
        up = 0xffff;
        break;
    case eType_BMPString:
        up = 0xffff;
        *zero = 0; // must be unbounded
        break;
    case eType_UniversalString:
        up = 0xffffffff;
        *zero = 0; // must be unbounded
        break;
    case eType_GeneralString:
    case eType_GraphicString:
        up = 0xff;
        break;
    case eType_TeletexString:
        up = 0xff;
        break;
    case eType_T61String:
        up = 0xff;
        break;
    case eType_VideotexString:
        up = 0xff;
        break;
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    lower.Flags = eEndPoint_Max;
    upper.Flags = 0;
    upper.Value = NewValue(NULL, NewType(eType_RestrictedString));
    upper.Value->U.RestrictedString.Value.length = 1;
    upper.Value->U.RestrictedString.Value.value = &up;

    /* apply permitted alphabet constraints */
    if (type->PERConstraints.PermittedAlphabet.Type !=
        eExtension_Unconstrained) {
        GetMinMax(ass, type->PERConstraints.PermittedAlphabet.Root,
            &lower, &upper);
        if (type->PERConstraints.PermittedAlphabet.Type == eExtension_Extended)
            GetMinMax(ass, type->PERConstraints.PermittedAlphabet.Additional,
                &lower, &upper);
    }

    /* set zero flag if the resulting type rejects the 0-character */
    if (!(lower.Flags & eEndPoint_Max) &&
        *GetValue(ass, lower.Value)->U.RestrictedString.Value.value > 0)
        *zero = 1;

    /* get the number of octets needed for a character */
    *noctets = uint32_uoctets(
        *GetValue(ass, upper.Value)->U.RestrictedString.Value.value);

    /* if the type is marked as zero-terminated or length/value, use the */
    /* appropriate type */
    if (GetTypeRules(ass, type) & eTypeRules_ZeroTerminated)
        *zero = 1;
    else if (GetTypeRules(ass, type) & (eTypeRules_LengthPointer|eTypeRules_FixedArray))
        *zero = 0;

    /* return the correct type */
    if (*zero) {
        if (*noctets == 1)
        {
#ifdef ENABLE_CHAR_STR_SIZE
        if (g_eEncodingRule == eEncoding_Packed &&
            type->PERTypeInfo.Root.LConstraint == ePERSTIConstraint_Constrained)
        {
            return "ASN1char_t";
        }
        else
        {
                return "ASN1ztcharstring_t";
        }
#else
            return "ASN1ztcharstring_t";
#endif
        }
        if (*noctets == 2)
            return "ASN1ztchar16string_t";
        *noctets = 4;
        return "ASN1ztchar32string_t";
    } else {
        if (*noctets == 1)
            return "ASN1charstring_t";
        if (*noctets == 2)
            return "ASN1char16string_t";
        *noctets = 4;
        return "ASN1char32string_t";
    }
}

/* check if a type is a restricted string type */
int IsRestrictedString(Type_e type)
{
    return
        type == eType_NumericString ||
        type == eType_PrintableString ||
        type == eType_TeletexString ||
        type == eType_T61String ||
        type == eType_VideotexString ||
        type == eType_IA5String ||
        type == eType_GraphicString ||
        type == eType_VisibleString ||
        type == eType_ISO646String ||
        type == eType_GeneralString ||
        type == eType_UniversalString ||
        type == eType_BMPString ||
        type == eType_RestrictedString;
}

/* create a reference to a value */
char *Reference(char *p)
{
    char *q;

    if (*p == '*')
        return p + 1;
    q = (char *)malloc(strlen(p) + 2);
    *q = '&';
    strcpy(q + 1, p);
    return q;
}

/* create a dereference to a value */
char *Dereference(char *p)
{
    char *q;

    if (*p == '&')
        return p + 1;
    q = (char *)malloc(strlen(p) + 2);
    *q = '*';
    strcpy(q + 1, p);
    return q;
}

/* get the name of a type */
char *GetTypeName(AssignmentList_t ass, Type_t *t)
{
    Assignment_t *a;
    int32_t noctets;
    uint32_t zero;
    int32_t sign;
    char buf[256];
    char *p;

    switch (t->Type) {
    case eType_Boolean:
        return GetBooleanType();
    case eType_Integer:
        return GetIntegerType(ass, t, &sign);
    case eType_BitString:
        return "ASN1bitstring_t";
    case eType_OctetString:
        return "ASN1octetstring_t";
    case eType_UTF8String:
        return "ASN1wstring_t";
    case eType_Null:
        MyAbort();
        /*NOTREACHED*/
    case eType_ObjectIdentifier:
        if (t->PrivateDirectives.fOidPacked)
        {
            return "ASN1encodedOID_t";
        }
        return t->PrivateDirectives.fOidArray ? "ASN1objectidentifier2_t" : "ASN1objectidentifier_t";
    case eType_Real:
        return GetRealType(t);
    case eType_Enumerated:
        return GetEnumeratedType(ass, t, &sign);
    case eType_EmbeddedPdv:
        return "ASN1embeddedpdv_t";
    case eType_Sequence:
    case eType_SequenceOf:
    case eType_Set:
    case eType_SetOf:
    case eType_Choice:
    case eType_InstanceOf:
        MyAbort();
        /*NOTREACHED*/
    case eType_NumericString:
    case eType_PrintableString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GraphicString:
    case eType_GeneralString:
    case eType_IA5String:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
        return GetStringType(ass, t, &noctets, &zero);
    case eType_UTCTime:
        return "ASN1utctime_t";
    case eType_GeneralizedTime:
        return "ASN1generalizedtime_t";
    case eType_ObjectDescriptor:
        return "ASN1objectdescriptor_t";
    case eType_External:
        return "ASN1external_t";
    case eType_CharacterString:
        return "ASN1characterstring_t";
        /*NOTREACHED*/
    case eType_Selection:
        MyAbort();
        /*NOTREACHED*/
    case eType_Reference:
        a = FindAssignment(ass, eAssignment_Type,
            t->U.Reference.Identifier, t->U.Reference.Module);
        return GetName(a);
    case eType_FieldReference:
        p = GetObjectClassName(ass, t->U.FieldReference.ObjectClass);
        sprintf(buf, "%s_%s", p, t->U.FieldReference.Identifier);
        return Identifier2C(buf);
    case eType_RestrictedString:
        MyAbort();
        /*NOTREACHED*/
    case eType_Open:
        return "ASN1open_t";
    case eType_Undefined:
        MyAbort();
        /*NOTREACHED*/
    }
	/*NOTREACHED*/
	return NULL;
}

/* get the name of a type */
char *PGetTypeName(AssignmentList_t ass, Type_t *t)
{
    Assignment_t *a;

    if (t->Type == eType_Reference)
    {
        a = FindAssignment(ass, eAssignment_Type,
                t->U.Reference.Identifier, t->U.Reference.Module);
        return IsPSetOfType(ass, a) ? PGetName(ass, a) : GetName(a);
    }
    return GetTypeName(ass, t);
}

/* get the name of a value */
char *GetValueName(AssignmentList_t ass, Value_t *value)
{
    Assignment_t *a;

    if (value->Type)
        MyAbort();
    a = FindAssignment(ass, eAssignment_Value,
        value->U.Reference.Identifier, value->U.Reference.Module);
    return GetName(a);
}

/* get the name of an object class */
char *GetObjectClassName(AssignmentList_t ass, ObjectClass_t *oc)
{
    Assignment_t *a;

    switch (oc->Type) {
    case eObjectClass_Reference:
        a = FindAssignment(ass, eAssignment_ObjectClass,
            oc->U.Reference.Identifier, oc->U.Reference.Module);
        return GetName(a);
    default:
        MyAbort();
        /*NOTREACHED*/
    }
    return NULL;
}

/* check if a type is of structured type */
int IsStructuredType(Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_SequenceOf:
    case eType_Set:
    case eType_SetOf:
    case eType_Choice:
    case eType_InstanceOf:
        return 1;
    default:
        return 0;
    }
}

/* check if a type is of sequence type */
int IsSequenceType(Type_t *type)
{
    switch (type->Type) {
    case eType_Sequence:
    case eType_Set:
    case eType_Choice:
    case eType_Real:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
        return 1;
    default:
        return 0;
    }
}

/* check if a type is a reference type */
int IsReferenceType(Type_t *type)
{
    switch (type->Type) {
    case eType_Reference:
    case eType_FieldReference:
        return 1;
    default:
        return 0;
    }
}

/* get the tag of a type */
Tag_t *GetTag(AssignmentList_t ass, Type_t *type)
{
    Type_t *type2;
    for (;;) {
        if (type->Tags || !IsReferenceType(type))
            return type->Tags;
        type2 = GetReferencedType(ass, type);
        /*XXX self-referencing types will idle forever */
        if (type == type2)
        {
            ASSERT(0);
            return NULL;
        }
        type = type2;
    }
    /*NOTREACHED*/
}

/* get the number of octets of a C type */
int32_t GetOctets(char *inttype)
{
    if (!strcmp(inttype, "ASN1uint8_t"))
        return sizeof(ASN1uint8_t);
    if (!strcmp(inttype, "ASN1uint16_t"))
        return sizeof(ASN1uint16_t);
    if (!strcmp(inttype, "ASN1uint32_t"))
        return sizeof(ASN1uint32_t);
    if (!strcmp(inttype, "ASN1uint64_t"))
        return 8;
    if (!strcmp(inttype, "ASN1int8_t"))
        return sizeof(ASN1int8_t);
    if (!strcmp(inttype, "ASN1int16_t"))
        return sizeof(ASN1int16_t);
    if (!strcmp(inttype, "ASN1int32_t"))
        return sizeof(ASN1int32_t);
    if (!strcmp(inttype, "ASN1int64_t"))
        return 8;
    if (!strcmp(inttype, "ASN1intx_t"))
        return 0;
    if (!strcmp(inttype, "ASN1bool_t"))
        return sizeof(ASN1bool_t);
    if (!strcmp(inttype, "ASN1char_t"))
        return sizeof(ASN1char_t);
    if (!strcmp(inttype, "ASN1char16_t"))
        return sizeof(ASN1char16_t);
    if (!strcmp(inttype, "ASN1char32_t"))
        return sizeof(ASN1char32_t);
    if (!strcmp(inttype, "double"))
        return 8;
    if (!strcmp(inttype, "ASN1real_t"))
        return 0;
    // added by Microsoft
    if (!strcmp(inttype, "ASN1enum_t"))
        return sizeof(ASN1enum_t);
    if (!strcmp(inttype, "ASN1choice_t"))
        return sizeof(ASN1choice_t);
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* compare two values; return 0 if equal */
int CmpValue(AssignmentList_t ass, Value_t *v1, Value_t *v2)
{
    uint32_t i;
    int32_t d;
    Type_e t1, t2;

    v1 = GetValue(ass, v1);
    v2 = GetValue(ass, v2);
    t1 = GetTypeType(ass, v1->Type);
    t2 = GetTypeType(ass, v2->Type);
    if (t1 == eType_Integer && t2 == eType_Integer) {
        return intx_cmp(&v1->U.Integer.Value, &v2->U.Integer.Value);
    }
    if (t1 == eType_ObjectIdentifier && t2 == eType_ObjectIdentifier) {
        d = v1->U.ObjectIdentifier.Value.length -
            v2->U.ObjectIdentifier.Value.length;
        if (d)
            return d;
        for (i = 0; i < v1->U.ObjectIdentifier.Value.length; i++) {
            d = v1->U.ObjectIdentifier.Value.value[i] -
                v2->U.ObjectIdentifier.Value.value[i];
            if (d)
                return d;
        }
        return 0;
    }
    if (IsRestrictedString(t1) && IsRestrictedString(t2)) {
        if (v1->U.RestrictedString.Value.length != 1 ||
            v2->U.RestrictedString.Value.length != 1)
            MyAbort();
        if (*v1->U.RestrictedString.Value.value <
            *v2->U.RestrictedString.Value.value)
            return -1;
        if (*v1->U.RestrictedString.Value.value >
            *v2->U.RestrictedString.Value.value)
            return 1;
        return 0;
    }
    MyAbort();
    /*NOTREACHED*/
    return 1; // not equal
}

/* substract two values (integer/character) */
int SubstractValues(AssignmentList_t ass, intx_t *diff, Value_t *v1, Value_t *v2)
{
    v1 = GetValue(ass, v1);
    v2 = GetValue(ass, v2);
    switch (GetTypeType(ass, v1->Type)) {
    case eType_Integer:
            intx_sub(diff, &v1->U.Integer.Value, &v2->U.Integer.Value);
        return 1;
    default:
            if (IsRestrictedString(GetTypeType(ass, v1->Type))) {
            if (v1->U.RestrictedString.Value.length != 1 ||
                v2->U.RestrictedString.Value.length != 1)
                return 0;
            intx_setuint32(diff, v2->U.RestrictedString.Value.value[0] -
                v1->U.RestrictedString.Value.value[0]);
            return 1;
        }
        break;
    }
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* get the lower endpoint; adjust endpoint if the endpoint is "open" */
/* (means "not including the value") */
EndPoint_t *GetLowerEndPoint(AssignmentList_t ass, EndPoint_t *e)
{
    EndPoint_t *newe;
    Type_t *type;

    if ((e->Flags & eEndPoint_Min) || !(e->Flags & eEndPoint_Open))
        return e;
    type = GetType(ass, GetValue(ass, e->Value)->Type);
    switch (type->Type) {
    case eType_Integer:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        intx_add(&newe->Value->U.Integer.Value, &e->Value->U.Integer.Value,
            &intx_1);
        return newe;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        newe->Value->U.RestrictedString.Value.length = 1;
        newe->Value->U.RestrictedString.Value.value =
            (char32_t *)malloc(sizeof(char32_t));
        *newe->Value->U.RestrictedString.Value.value =
            *e->Value->U.RestrictedString.Value.value + 1;
        return newe;
    default:
        return e;
    }
}

/* get the upper endpoint; adjust endpoint if the endpoint is "open" */
/* (means "not including the value") */
EndPoint_t *GetUpperEndPoint(AssignmentList_t ass, EndPoint_t *e)
{
    EndPoint_t *newe;
    Type_t *type;

    if ((e->Flags & eEndPoint_Max) || !(e->Flags & eEndPoint_Open))
        return e;
    type = GetType(ass, GetValue(ass, e->Value)->Type);
    switch (type->Type) {
    case eType_Integer:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        intx_sub(&newe->Value->U.Integer.Value, &e->Value->U.Integer.Value,
            &intx_1);
        return newe;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        newe = NewEndPoint();
        newe->Value = NewValue(ass, type);
        newe->Value->U.RestrictedString.Value.length = 1;
        newe->Value->U.RestrictedString.Value.value =
            (char32_t *)malloc(sizeof(char32_t));
        *newe->Value->U.RestrictedString.Value.value =
            *e->Value->U.RestrictedString.Value.value - 1;
        return newe;
    default:
        return e;
    }
}

/* compare two lower endpoints */
int CmpLowerEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetLowerEndPoint(ass, e1);
    e2 = GetLowerEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if (e1->Flags & eEndPoint_Open) {
            if (e2->Flags & eEndPoint_Open)
                return 0;
            else
                return 1;
        } else {
            if (e2->Flags & eEndPoint_Open)
                return -1;
            else
                return 0;
        }
    }
}

/* compare two upper endpoints */
int CmpUpperEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetUpperEndPoint(ass, e1);
    e2 = GetUpperEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if (e1->Flags & eEndPoint_Open) {
            if (e2->Flags & eEndPoint_Open)
                return 0;
            else
                return -1;
        } else {
            if (e2->Flags & eEndPoint_Open)
                return 1;
            else
                return 0;
        }
    }
}

/* compare a lower and an upper endpoints */
int CmpLowerUpperEndPoint(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    int ret;

    e1 = GetLowerEndPoint(ass, e1);
    e2 = GetUpperEndPoint(ass, e2);
    if (e1->Flags & eEndPoint_Min) {
            if (e2->Flags & eEndPoint_Min)
            return 0;
        return -1;
    } else if (e2->Flags & eEndPoint_Min) {
            return 1;
    } else if (e1->Flags & eEndPoint_Max) {
            if (e2->Flags & eEndPoint_Max)
            return 0;
        return 1;
    } else if (e2->Flags & eEndPoint_Max) {
            return -1;
    } else {
        ret = CmpValue(ass, e1->Value, e2->Value);
        if (ret != 0)
            return ret;
        if ((e1->Flags & eEndPoint_Open) || (e2->Flags & eEndPoint_Open))
            return 1;
        else
            return 0;
    }
}

/* check whether two EndPoint_t's join together */
int CheckEndPointsJoin(AssignmentList_t ass, EndPoint_t *e1, EndPoint_t *e2)
{
    intx_t ix;
    Value_t *v1, *v2;

    /* check if endpoints overlap */
    if (CmpLowerUpperEndPoint(ass, e2, e1) <= 0)
        return 1;

    e1 = GetUpperEndPoint(ass, e1);
    e2 = GetLowerEndPoint(ass, e2);
    v1 = GetValue(ass, e1->Value);
    v2 = GetValue(ass, e2->Value);
    switch (GetTypeType(ass, v1->Type)) {
    case eType_Integer:
        /* check for subsequent integers */
            intx_dup(&ix, &v1->U.Integer.Value);
        intx_inc(&ix);
        return intx_cmp(&ix, &v2->U.Integer.Value) >= 0;
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_VideotexString:
    case eType_IA5String:
    case eType_GraphicString:
    case eType_VisibleString:
    case eType_ISO646String:
    case eType_GeneralString:
    case eType_UniversalString:
    case eType_BMPString:
    case eType_RestrictedString:
        /* reject multiple characters */
            if (v1->U.RestrictedString.Value.length != 1 ||
                v2->U.RestrictedString.Value.length != 1)
            MyAbort();

        /* beware of wrap around */
        if (v1->U.RestrictedString.Value.value[0] == 0xffffffff &&
            v2->U.RestrictedString.Value.value[0] == 0)
            return 0;

        /* check for subsequent characters */
        return v2->U.RestrictedString.Value.value[0] -
            v1->U.RestrictedString.Value.value[0] == 1;
    }
    MyAbort();
    /*NOTREACHED*/
    return 0;
}

/* compare two module identifiers; return 0 if equal */
int CmpModuleIdentifier(AssignmentList_t ass, ModuleIdentifier_t *mod1, ModuleIdentifier_t *mod2)
{
    if (mod1->ObjectIdentifier && mod2->ObjectIdentifier)
        return CmpValue(ass, mod1->ObjectIdentifier, mod2->ObjectIdentifier);
    if (mod1->Identifier && mod2->Identifier)
        return strcmp(mod1->Identifier, mod2->Identifier);
    return 0;
}

/* get the name of an assignment */
char *GetNameEx(AssignmentList_t ass, AssignmentList_t a, int fPSetOf)
{
    char *p;
    char *ide;
    char *mod;

    if (a->Type == eAssignment_Type &&
        a->U.Type.Type && a->U.Type.Type->PrivateDirectives.pszTypeName)
    {
        if (fPSetOf && IsPSetOfType(ass, a))
        {
            ide = PIdentifier2C(a->U.Type.Type->PrivateDirectives.pszTypeName);
        }
        else
        {
            ide = Identifier2C(a->U.Type.Type->PrivateDirectives.pszTypeName);
        }
    }
    else
    {
        if (fPSetOf && IsPSetOfType(ass, a))
        {
            ide = PIdentifier2C(a->Identifier);
        }
        else
        {
            ide = Identifier2C(a->Identifier);
        }
    }

// LONCHANC: disable the following code per MikeV.
    if (g_fLongNameForImported)
    {
        if (!(a->Flags & eAssignmentFlags_LongName))
            return ide;
        mod = Identifier2C(a->Module->Identifier);
        p = (char *)malloc(strlen(mod) + strlen(ide) + 2);
        sprintf(p, "%s_%s", mod, ide);
        return p;
    }
    else
    {
        return ide;
    }
}

/* get the name of an assignment */
char *GetName(AssignmentList_t a)
{
    return GetNameEx(NULL, a, 0);
}
char *PGetName(AssignmentList_t ass, AssignmentList_t a)
{
    return GetNameEx(ass, a, 1);
}

/* convert a 32 bit string into a generalized time */
int String2GeneralizedTime(generalizedtime_t *time, char32string_t *string)
{
    char str[64];
    unsigned i;

    if (string->length > 63 || string->length < 10)
        return 0;
    for (i = 0; i < string->length; i++)
        str[i] = (char)string->value[i];
    str[i] = 0;
    return string2generalizedtime(time, str);
}

/* convert a 32 bit string into an utc time */
int String2UTCTime(utctime_t *time, char32string_t *string)
{
    char str[64];
    unsigned i;

    if (string->length > 63 || string->length < 10)
        return 0;
    for (i = 0; i < string->length; i++)
        str[i] = (char)string->value[i];
    str[i] = 0;
    return string2utctime(time, str);
}

/* build an intersection of two constraints */
void IntersectConstraints(Constraint_t **ret, Constraint_t *c1, Constraint_t *c2)
{
    ElementSetSpec_t *e;

    if (!c2) {
        *ret = c1;
        return;
    }
    if (!c1) {
        *ret = c2;
        return;
    }
    *ret = NewConstraint();
    if (!c1->Root) {
        (*ret)->Root = c2->Root;
    } else if (!c2->Root) {
        (*ret)->Root = c1->Root;
    } else {
        (*ret)->Root = e = NewElementSetSpec(eElementSetSpec_Intersection);
        e->U.Intersection.Elements1 = c1->Root;
        e->U.Intersection.Elements2 = c2->Root;
    }
    if (c1->Type > c2->Type)
        (*ret)->Type = c1->Type;
    else
        (*ret)->Type = c2->Type;
    if ((*ret)->Type == eExtension_Extended) {
        if (c1->Type != eExtension_Extended || !c1->Additional) {
            (*ret)->Additional = c2->Additional;
        } else if (c2->Type != eExtension_Extended || !c2->Additional) {
            (*ret)->Additional = c1->Additional;
        } else {
            (*ret)->Additional = e =
                NewElementSetSpec(eElementSetSpec_Intersection);
            e->U.Intersection.Elements1 = c1->Additional;
            e->U.Intersection.Elements2 = c2->Additional;
        }
    }
}

/* find a field spec by name of an object class */
FieldSpec_t *GetObjectClassField(AssignmentList_t ass, ObjectClass_t *oc, char *field)
{
    oc = GetObjectClass(ass, oc);
    if (!oc)
        return NULL;
    return GetFieldSpec(ass, FindFieldSpec(oc->U.ObjectClass.FieldSpec, field));
}

/* find a field spec by name list of an object class */
FieldSpec_t *GetFieldSpecFromObjectClass(AssignmentList_t ass, ObjectClass_t *oc, StringList_t sl)
{
    FieldSpec_t *fs;

    for (; sl; sl = sl->Next) {
        fs = GetObjectClassField(ass, oc, sl->String);
        if (!fs)
            return NULL;
        if (!sl->Next)
            return fs;
        if (fs->Type == eFieldSpec_Object)
            oc = fs->U.Object.ObjectClass;
        else if (fs->Type == eFieldSpec_ObjectSet)
            oc = fs->U.ObjectSet.ObjectClass;
        else
            return NULL;
    }
    return NULL;
}

/* get the default setting of a field spec */
static Setting_t *GetDefaultSetting(FieldSpec_t *fs)
{
    Setting_t *ret = NULL;
    Optionality_t *op;

    switch (fs->Type) {
    case eFieldSpec_Type:
        op = fs->U.Type.Optionality;
        if (op && op->Type == eOptionality_Default_Type) {
            ret = NewSetting(eSetting_Type);
            ret->Identifier = fs->Identifier;
            ret->U.Type.Type = op->U.Type;
        }
        break;
    case eFieldSpec_FixedTypeValue:
        op = fs->U.FixedTypeValue.Optionality;
        if (op && op->Type == eOptionality_Default_Value) {
            ret = NewSetting(eSetting_Value);
            ret->Identifier = fs->Identifier;
            ret->U.Value.Value = op->U.Value;
        }
        break;
    case eFieldSpec_VariableTypeValue:
        op = fs->U.VariableTypeValue.Optionality;
        if (op && op->Type == eOptionality_Default_Value) {
            ret = NewSetting(eSetting_Value);
            ret->Identifier = fs->Identifier;
            ret->U.Value.Value = op->U.Value;
        }
        break;
    case eFieldSpec_FixedTypeValueSet:
        op = fs->U.FixedTypeValueSet.Optionality;
        if (op && op->Type == eOptionality_Default_ValueSet) {
            ret = NewSetting(eSetting_ValueSet);
            ret->Identifier = fs->Identifier;
            ret->U.ValueSet.ValueSet = op->U.ValueSet;
        }
        break;
    case eFieldSpec_VariableTypeValueSet:
        op = fs->U.VariableTypeValueSet.Optionality;
        if (op && op->Type == eOptionality_Default_ValueSet) {
            ret = NewSetting(eSetting_ValueSet);
            ret->Identifier = fs->Identifier;
            ret->U.ValueSet.ValueSet = op->U.ValueSet;
        }
        break;
    case eFieldSpec_Object:
        op = fs->U.Object.Optionality;
        if (op && op->Type == eOptionality_Default_Object) {
            ret = NewSetting(eSetting_Object);
            ret->Identifier = fs->Identifier;
            ret->U.Object.Object = op->U.Object;
        }
        break;
    case eFieldSpec_ObjectSet:
        op = fs->U.Object.Optionality;
        if (op && op->Type == eOptionality_Default_ObjectSet) {
            ret = NewSetting(eSetting_ObjectSet);
            ret->Identifier = fs->Identifier;
            ret->U.ObjectSet.ObjectSet = op->U.ObjectSet;
        }
        break;
    default:
        return NULL;
    }
    return ret;
}

Setting_t *GetSettingFromSettings(AssignmentList_t ass, SettingList_t se, StringList_t sl)
{
    Object_t *o;

    for (; sl; sl = sl->Next) {
        for (; se; se = se->Next) {
            if (!strcmp(se->Identifier, sl->String))
                break;
        }
        if (!se)
            return NULL;
        if (!sl->Next)
            return se;
        if (se->Type != eSetting_Object)
            return NULL;
        o = GetObject(ass, se->U.Object.Object);
        if (!o)
            return NULL;
        se = o->U.Object.Settings;
    }
    return NULL;
}

Setting_t *GetSettingFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    FieldSpec_t *fs;
    Setting_t *se;
    ObjectClass_t *oc;

    for (; sl; sl = sl->Next) {
        o = GetObject(ass, o);
        if (!o)
            return NULL;
        oc = GetObjectClass(ass, o->U.Object.ObjectClass);
        if (!oc)
            return NULL;
        fs = GetFieldSpec(ass,
            FindFieldSpec(oc->U.ObjectClass.FieldSpec, sl->String));
        if (!fs)
            return NULL;
        se = FindSetting(o->U.Object.Settings, sl->String);
        if (!se) {
            se = GetDefaultSetting(fs);
            if (!se)
                return NULL;
        }
        if (!sl->Next)
            return se;
        if (fs->Type == eFieldSpec_Object && se->Type == eSetting_Object) {
            o = se->U.Object.Object;
        } else {
            return NULL;
        }
    }
    return NULL;
}

ObjectClass_t *GetObjectClassFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems)
{
    ObjectSetElement_t *ose;
    Object_t *o;
    ObjectSet_t *os;

    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        return GetObjectClassFromElementSetSpec(ass,
            elems->U.AllExcept.Elements);
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        return GetObjectClassFromElementSetSpec(ass,
            elems->U.UIE.Elements1);
    case eElementSetSpec_SubtypeElement:
        MyAbort();
        /*NOTREACHED*/
    case eElementSetSpec_ObjectSetElement:
        ose = elems->U.ObjectSetElement.ObjectSetElement;
        switch (ose->Type) {
        case eObjectSetElement_Object:
            o = ose->U.Object.Object;
            o = GetObject(ass, o);
            if (!o)
                return NULL;
            return o->U.Object.ObjectClass;
        case eObjectSetElement_ObjectSet:
            os = ose->U.ObjectSet.ObjectSet;
            os = GetObjectSet(ass, os);
            if (!os)
                return NULL;
            return os->U.ObjectSet.ObjectClass;
        case eObjectSetElement_ElementSetSpec:
            return GetObjectClassFromElementSetSpec(ass,
                ose->U.ElementSetSpec.ElementSetSpec);
        } 
        /*NOTREACHED*/
    }
    /*NOTREACHED*/
	return NULL;
}

#if 0
Type_t *GetTypeFromElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems)
{
    Type_t *ret;
    SubtypeElement_t *sub;
    Value_t *value;

    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        return GetTypeFromElementSetSpec(ass,
            elems->U.AllExcept.Elements);
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        ret = GetTypeFromElementSetSpec(ass, elems->U.UIE.Elements1);
        if (ret)
            return ret;
        return GetTypeFromElementSetSpec(ass, elems->U.UIE.Elements2);
    case eElementSetSpec_SubtypeElement:
        sub = elems->U.SubtypeElement.SubtypeElement;
        switch (sub->Type) {
        case eSubtypeElement_Size:
        case eSubtypeElement_PermittedAlphabet:
        case eSubtypeElement_SingleType:
        case eSubtypeElement_FullSpecification:
        case eSubtypeElement_PartialSpecification:
            return NULL;
        case eSubtypeElement_Type:
            return Builtin_Type_Open;
        case eSubtypeElement_ContainedSubtype:
            return sub->U.ContainedSubtype.Type;
        case eSubtypeElement_SingleValue:
            value = GetValue(ass, sub->U.SingleValue.Value);
            return value->Type;
        case eSubtypeElement_ValueRange:
            if (!(sub->U.ValueRange.Lower.Flags & eEndPoint_Min)) {
                value = GetValue(ass, sub->U.ValueRange.Lower.Value);
                return value->Type;
            }
            if (!(sub->U.ValueRange.Upper.Flags & eEndPoint_Max)) {
                value = GetValue(ass, sub->U.ValueRange.Upper.Value);
                return value->Type;
            }
            return NULL;
        case eSubtypeElement_ElementSetSpec:
            return GetTypeFromElementSetSpec(ass,
                sub->U.ElementSetSpec.ElementSetSpec);
        } 
        /*NOTREACHED*/
    case eElementSetSpec_ObjectSetElement:
        MyAbort();
        /*NOTREACHED*/
    }
    /*NOTREACHED*/
}
#endif

Type_t *GetTypeOfValueSet(AssignmentList_t ass, ValueSet_t *vs)
{
    Type_t *ret;
    Constraint_t *c;

    if (!vs)
        return NULL;
    ret = DupType(vs->Type);
    c = NewConstraint();
    c->Type = eExtension_Unextended;
    c->Root = vs->Elements;
    IntersectConstraints(&ret->Constraints, vs->Type->Constraints, c);
    return ret;
}

Value_t *GetValueFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Value)
        return NULL; /* error */
    return se->U.Value.Value;
}

ValueSet_t *GetValueSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_ValueSet)
        return NULL; /* error */
    return se->U.ValueSet.ValueSet;
}

Type_t *GetTypeFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Type)
        return NULL; /* error */
    return se->U.Type.Type;
}

Object_t *GetObjectFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_Object)
        return NULL; /* error */
    return se->U.Object.Object;
}

ObjectSet_t *GetObjectSetFromObject(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    Setting_t *se;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type != eSetting_ObjectSet)
        return NULL; /* error */
    return se->U.ObjectSet.ObjectSet;
}

ElementSetSpec_t *ConvertElementSetSpecToElementSetSpec(AssignmentList_t ass, ElementSetSpec_t *elems, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl))
{
    ElementSetSpec_t *ret, *e1, *e2;
    ObjectSetElement_t *ose;

    ret = NULL;
    switch (elems->Type) {
    case eElementSetSpec_AllExcept:
        e1 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.AllExcept.Elements, sl, fn);
        if (e1) {
            ret = NewElementSetSpec(elems->Type);
            ret->U.AllExcept.Elements = e1;
        }
        break;
    case eElementSetSpec_Union:
    case eElementSetSpec_Intersection:
    case eElementSetSpec_Exclusion:
        e1 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.UIE.Elements1, sl, fn);
        e2 = ConvertElementSetSpecToElementSetSpec(
            ass, elems->U.UIE.Elements2, sl, fn);
        if (e1 && e2) {
            ret = NewElementSetSpec(elems->Type);
            ret->U.UIE.Elements1 = ConvertElementSetSpecToElementSetSpec(
                ass, elems->U.UIE.Elements1, sl, fn);
            ret->U.UIE.Elements2 = ConvertElementSetSpecToElementSetSpec(
                ass, elems->U.UIE.Elements2, sl, fn);
        } else if (e1) {
            ret = e1;
        } else if (e2) {
            if (elems->Type == eElementSetSpec_Exclusion) {
                ret = NewElementSetSpec(eElementSetSpec_AllExcept);
                ret->U.AllExcept.Elements = e2;
            } else {
                ret = e2;
            }
        }
        break;
    case eElementSetSpec_ObjectSetElement:
        ose = elems->U.ObjectSetElement.ObjectSetElement;
        switch (ose->Type) {
        case eObjectSetElement_Object:
            ret = fn(ass, ose->U.Object.Object, sl);
            break;
        case eObjectSetElement_ObjectSet:
            ret = ConvertObjectSetToElementSetSpec(ass,
                ose->U.ObjectSet.ObjectSet, sl, fn);
            break;
        case eObjectSetElement_ElementSetSpec:
            ret = ConvertElementSetSpecToElementSetSpec(ass,
                ose->U.ElementSetSpec.ElementSetSpec, sl, fn);
            break;
        }
        break;
    case eElementSetSpec_SubtypeElement:
        MyAbort();
        /*NOTREACHED*/
    }
    return ret;
}

ElementSetSpec_t *ConvertObjectSetToElementSetSpec(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl, ElementSetSpec_t *(*fn)(AssignmentList_t ass, Object_t *o, StringList_t sl))
{
    os = GetObjectSet(ass, os);
    if (!os)
        return NULL;
    return ConvertElementSetSpecToElementSetSpec(ass,
        os->U.ObjectSet.Elements, sl, fn);
}

static ElementSetSpec_t *CbGetValueSetFromObjectSet(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    ElementSetSpec_t *ret;
    Setting_t *se;
    SubtypeElement_t *sub;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type == eSetting_Value) {
        sub = NewSubtypeElement(eSubtypeElement_SingleValue);
        sub->U.SingleValue.Value = se->U.Value.Value;
        ret = NewElementSetSpec(eElementSetSpec_SubtypeElement);
        ret->U.SubtypeElement.SubtypeElement = sub;
        return ret;
    } else if (se->Type == eSetting_ValueSet) {
        return se->U.ValueSet.ValueSet->Elements;
    } else {
        return NULL; /* error */
    }
}

ValueSet_t *GetValueSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl)
{
    ElementSetSpec_t *elems;
    ValueSet_t *ret;
    ObjectClass_t *oc;
    FieldSpec_t *fs;
    Type_t *type;

    os = GetObjectSet(ass, os);
    if (!os)
        return NULL;
    oc = os->U.ObjectSet.ObjectClass;
    fs = GetFieldSpecFromObjectClass(ass, oc, sl);
    if (!fs)
        return NULL;
    if (fs->Type == eFieldSpec_FixedTypeValue)
        type = fs->U.FixedTypeValue.Type;
    else if (fs->Type == eFieldSpec_FixedTypeValueSet)
        type = fs->U.FixedTypeValueSet.Type;
    else
        return NULL;
    elems = ConvertObjectSetToElementSetSpec(ass, os, sl,
        CbGetValueSetFromObjectSet);
    if (!elems)
        return NULL;
    ret = NewValueSet();
    ret->Elements = elems;
    ret->Type = type;
    return ret;
}

static ElementSetSpec_t *CbGetObjectSetFromObjectSet(AssignmentList_t ass, Object_t *o, StringList_t sl)
{
    ElementSetSpec_t *ret;
    Setting_t *se;
    ObjectSetElement_t *sub;

    se = GetSettingFromObject(ass, o, sl);
    if (!se)
        return NULL;
    if (se->Type == eSetting_Object) {
        sub = NewObjectSetElement(eObjectSetElement_Object);
        sub->U.Object.Object = se->U.Object.Object;
        ret = NewElementSetSpec(eElementSetSpec_ObjectSetElement);
        ret->U.ObjectSetElement.ObjectSetElement = sub;
        return ret;
    } else if (se->Type == eSetting_ObjectSet) {
        return se->U.ObjectSet.ObjectSet->U.ObjectSet.Elements;
    } else {
        return NULL; /* error */
    }
}

ObjectSet_t *GetObjectSetFromObjectSet(AssignmentList_t ass, ObjectSet_t *os, StringList_t sl)
{
    ElementSetSpec_t *elems;
    ObjectSet_t *ret;

    elems = ConvertObjectSetToElementSetSpec(ass, os, sl,
        CbGetObjectSetFromObjectSet);
    if (!elems)
        return NULL;
    ret = NewObjectSet(eObjectSet_ObjectSet);
    ret->U.ObjectSet.Elements = elems;
    ret->U.ObjectSet.ObjectClass = GetObjectClassFromElementSetSpec(ass, elems);
    return ret;
}

// The following is added by Microsoft

int IsPSetOfType(AssignmentList_t ass, Assignment_t *a)
{
    Type_t *t2 = a->U.Type.Type;
#if 0
    if (t2->Type == eType_Reference)
    {
        t2 = GetType(ass, t2);
    }
#endif
    return ((eType_SequenceOf == t2->Type || eType_SetOf == t2->Type)
            &&
            (t2->Rules & (eTypeRules_LinkedListMask | eTypeRules_PointerToElement))
            // (t2->PrivateDirectives.fSLinked)
           );
}


void MyAbort(void)
{
    ASSERT(0);
    abort();
}

void MyExit(int val)
{
    ASSERT(0);
    exit(val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1c\write.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#define IDCHRSET "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"

#define INDENT 4
#define TABSIZE 8

static FILE *fout;
static int xcurrindent = 0;
static int xindentflag = 0;
static char *xbuf = 0;
static int xbufsize = 0;
static int xbuflen = 0;
static int ycurrindent = 1;
static char *ybuf = 0;
static int ybufsize = 0;
static int ybuflen = 0;

void xputc(char c);
void xputs(char *s);
void xflush();
void yputc(char c);
void yputs(char *s);
void yflush();

/* set the output file */
void
setoutfile(FILE *f)
{
    xflush();
    fout = f;
}

/* print indentation up to current indentation level */
static void
findent()
{
    int indent;

    indent = xcurrindent * INDENT;
    while (indent >= TABSIZE) {
	xputc('\t');
	indent -= TABSIZE;
    }
    while (indent-- > 0)
	xputc(' ');
}

/* print indentation up to current indentation level */
/* but expect one character to be printed already */
static void
findent1()
{
    int indent;

    indent = xcurrindent * INDENT;
    if (indent > 0 && indent < TABSIZE)
	indent--;
    while (indent >= TABSIZE) {
	xputc('\t');
	indent -= TABSIZE;
    }
    while (indent-- > 0)
	xputc(' ');
}

/* output function doing indentation automatically */
void
outputv(const char *format, va_list args)
{
    static char buf[4098];
    static int pos = 0;
    char *p, *q;
    int l;
    
    /* get the string to write */
    vsprintf(buf + pos, format, args);

    /* print it line by line */
    for (p = buf; *p; p = q) {
	q = strchr(p, '\n');
	if (!q) {
	    for (q = buf; *p;)
		*q++ = *p++;
	    *q = 0;
	    pos = q - buf;
	    return;
	}
	*q++ = 0;

	/* examine the first character for correct indentation */
	if (strchr(IDCHRSET, *p)) {
	    l = strspn(p, IDCHRSET);
	} else if (*p == '{' || *p == '}' || *p == '*' || *p == '&' ||
	    *p == '(' || *p == ')' || *p == '#') {
	    l = 1;
	} else {
	    l = 0;
	}

	if (!l) {

	    /* no indentation at all */
	    xputs(p);
	    xputc('\n');
	    continue;
	}

	if (p[0] == '#') {

	    /* preprocessor directive: indent after # */
	    xputc('#');
	    findent1();
	    xputs(p + 1);
	    xputc('\n');
	    continue;
	}

	/* closing brace? then unindent */
	if (p[0] == '}')
	    xcurrindent--;

	/* print the indentation, but labels will be less indented */
	if (p[strlen(p) - 1] == ':') {
	    xcurrindent--;
	    findent();
	    xcurrindent++;
	} else {
	    findent();
	}

	/* output the line */
	xputs(p);
	xputc('\n');

	/* back at indentation level 0? then we can flush our buffers */
	/* first the variables then the other lines */
	if (!xcurrindent) {
	    yflush();
	    xflush();
	}

	/* undo indentation of non-braced if/else/switch/for/while/do stmt */
	if (xindentflag) {
	    xcurrindent--;
	    xindentflag = 0;
	}

	/* indent after opening brace */
	if (p[strlen(p) - 1] == '{') {
	    xcurrindent++;
	    xindentflag = 0;

	/* indent one line after if/else/switch/for/while/do stmt */
	} else if (l == 2 && !memcmp(p, "if", l) ||
	    l == 4 && !memcmp(p, "else", l) ||
	    l == 6 && !memcmp(p, "switch", l) ||
	    l == 3 && !memcmp(p, "for", l) ||
	    l == 5 && !memcmp(p, "while", l) ||
	    l == 2 && !memcmp(p, "do", l)) {
	    xcurrindent++;
	    xindentflag = 1;
	}
    }

    /* empty buffer after printing */
    pos = 0;
}

/* output function doing indentation automatically */
/*PRINTFLIKE1*/
void
output(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputv(format, args);
    va_end(args);
}

/* output function without indentation */
void
outputniv(const char *format, va_list args)
{
    static char buf[512];

    vsprintf(buf, format, args);
    xputs(buf);
}

/* output function without indentation */
/*PRINTFLIKE1*/
void
outputni(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputniv(format, args);
    va_end(args);
}

/* output an intx value definition */
void
outputintx(const char *name, intx_t *val)
{
    outputoctets(name, val->length, val->value);
    output("static ASN1intx_t %s = { %d, %s_octets };\n",
	name, val->length, name);
}

/* output an real value definition */
void
outputreal(const char *name, real_t *val)
{
    char buf[256];
    switch (val->type) {
    case eReal_Normal:
	sprintf(buf, "%s_mantissa", name);
	outputoctets(buf, val->mantissa.length, val->mantissa.value);
	sprintf(buf, "%s_exponent", name);
	outputoctets(buf, val->exponent.length, val->exponent.value);
	output("ASN1real_t %s = { eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } };\n",
	    name, val->mantissa.length, name,
	    val->base, val->exponent.length, name);
	break;
    case eReal_PlusInfinity:
	output("ASN1real_t %s = { eReal_PlusInfinity };\n", name);
	break;
    case eReal_MinusInfinity:
	output("ASN1real_t %s = { eReal_MinusInfinity };\n", name);
	break;
    }
}

/* output an octet array definition */
void
outputoctets(const char *name, uint32_t length, octet_t *val)
{
    uint32_t i;
    char buf[1024];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "0x%02x", val[i]);
	p += 4;
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    *p = 0;
    output("static ASN1octet_t %s_octets[%u] = { %s };\n",
	name, length, buf);
}

/* output an uint32 array definition */
void
outputuint32s(const char *name, uint32_t length, uint32_t *val)
{
    uint32_t i;
    char buf[256];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "%u", val[i]);
	p += strlen(p);
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    *p = 0;
    output("static ASN1uint32_t %s_elems[%u] = { %s };\n",
	name, length, buf);
}

/* output forward declaration for a value */
void
outputvalue0(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value)
{
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    int32_t sign;
    char *pszStatic = "extern";

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
		ideref, value->U.Integer.Value.length);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t"))
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("%s ASN1octet_t %s_mantissa_octets[%u];\n", pszStatic,
		    ideref, value->U.Real.Value.mantissa.length);
		output("%s ASN1octet_t %s_exponent_octets[%u];\n", pszStatic,
		    ideref, value->U.Real.Value.exponent.length);
		break;
	    }
	}
	break;
    case eType_BitString:
	output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
	    ideref, (value->U.BitString.Value.length + 7) / 8);
	break;
    case eType_OctetString:
	output("%s ASN1octet_t %s_octets[%u];\n", pszStatic,
	    ideref, value->U.OctetString.Value.length);
	break;
    case eType_UTF8String:
	output("%s ASN1wchar_t %s_wchars[%u];\n", pszStatic,
	    ideref, value->U.UTF8String.Value.length);
	break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked ||
            type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            // doing nothing
        }
        else
        {
            output("%s ASN1uint32_t %s_elems[%u];\n", pszStatic,
                ideref, value->U.ObjectIdentifier.Value.length);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	switch (noctets) {
	case 1:
	    output("%s ASN1char_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 2:
	    output("%s ASN1char16_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 4:
	    output("%s ASN1char32_t %s_chars[%u];\n", pszStatic,
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	}
	break;
    case eType_ObjectDescriptor:
	output("%s ASN1char_t %s_chars[%u];\n", pszStatic,
	    ideref, value->U.ObjectDescriptor.Value.length + 1);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
        if (type->Rules & (eTypeRules_LengthPointer | eTypeRules_FixedArray))
        {
            for (i = 0, values = value->U.SS.Values; values;
            i++, values = values->Next) {}
            if (value->U.SS.Values) {
            for (i = 0, values = value->U.SS.Values; values;
                i++, values = values->Next) {
                sprintf(buf, "%s_value%d", ideref, i);
                outputvalue0(ass, buf,
                GetTypeName(ass, type->U.SS.Type), values);
            }
            output("%s %s %s_values[%u];\n", pszStatic,
                GetTypeName(ass, type->U.SS.Type),
                ideref, i);
            }
        }
        else
        if (type->Rules & (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList))
        {
            for (i = 0, values = value->U.SS.Values; values;
            i++, values = values->Next) {
            sprintf(buf, "%s_element%d", ideref, i);
            outputvalue0(ass, buf, GetTypeName(ass, type->U.SS.Type),
                values);
            output("%s %s_Element %s_value%d;\n", pszStatic,
                typeref, ideref, i);
            }
        }
        else
        {
            MyAbort();
        }
        break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue)
		    break;
		sprintf(buf, "%s_%s", ideref,
		    Identifier2C(components->U.NOD.NamedType->Identifier));
		outputvalue0(ass, buf,
		    GetTypeName(ass, components->U.NOD.NamedType->Type),
		    namedvalue->Value);
		break;
	    }
	}
	break;
    }
}

/* output definitions of value components */
void
outputvalue1(AssignmentList_t ass, char *ideref, char *typeref, Value_t *value)
{
    static uint32_t nOidPackedCount = 0;
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    int32_t sign;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    outputoctets(ideref, value->U.Integer.Value.length,
		value->U.Integer.Value.value);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t")) {
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		sprintf(buf, "%s_mantissa", ideref);
		outputoctets(buf, value->U.Real.Value.mantissa.length,
		    value->U.Real.Value.mantissa.value);
		sprintf(buf, "%s_exponent", ideref);
		outputoctets(buf, value->U.Real.Value.exponent.length,
		    value->U.Real.Value.exponent.value);
		break;
	    }
	}
	break;
    case eType_BitString:
	outputoctets(ideref, (value->U.BitString.Value.length + 7) / 8,
	    value->U.BitString.Value.value);
	break;
    case eType_OctetString:
	outputoctets(ideref, value->U.OctetString.Value.length,
	    value->U.OctetString.Value.value);
	break;
    case eType_UTF8String:
        itype = GetStringType(ass, type, &noctets, &zero);
        output("static ASN1wchar_t %s_wchars[%u] = { ",
        ideref, value->U.UTF8String.Value.length + zero);
        for (i = 0; i < value->U.UTF8String.Value.length; i++) {
            output("0x%x", value->U.UTF8String.Value.value[i]);
            if (i < value->U.UTF8String.Value.length - 1)
                output(", ");
        }
        if (zero) {
            if (value->U.UTF8String.Value.length)
                output(", 0x0");
            else
                output("0x0");
        }
        output(" };\n");
        break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked)
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i, j, cb;
            uint32_t count = 0;
            uint32_t node;
            unsigned char aLittleEndian[16];
            char buf[1024];
            char *p = buf;
            sprintf(p, "{");
            p += strlen(p);
            for (i = 0; i < length; i++)
            {
                // get node value
                node = val[i];

                // special case for the first node
                if (0 == i && length > 1)
                {
                    i++;
                    node = node * 40 + val[1];
                }

                // encode this node
                ZeroMemory(aLittleEndian, sizeof(aLittleEndian));
                for (j = 0; node != 0; j++)
                {
                    aLittleEndian[j] = (unsigned char) (node & 0x7f);
                    if (j != 0)
                    {
                        aLittleEndian[j] |= (unsigned char) 0x80;
                    }
                    node >>= 7;
                }
                cb = j ? j : 1; // at least one byte for zero value

                // print out the values
                for (j = 0; j < cb; j ++)
                {
                    count++;
                    sprintf(p, " %u,", (unsigned char) aLittleEndian[cb - j - 1]);
                    p += strlen(p);
                }
            }
            --p; // remove the last ','
            strcpy(p, " }");
            output("static ASN1octet_t s_oid%u[] = %s;\n", nOidPackedCount, buf);
            output("ASN1encodedOID_t %s = { %u, s_oid%u };\n", ideref, count, nOidPackedCount);
            nOidPackedCount++;
        }
        else
        if (type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i;
            char buf[1024];
            char *p = buf;
            sprintf(p, "{ ");
            p += strlen(p);
            for (i = 0; i < length; i++)
            {
                if (i == length - 1)
                {
                    sprintf(p, "%u }", val[i]);
                }
                else
                {
                    sprintf(p, "%u, ", val[i]);
                }
                p += strlen(p);
            }
            *p = 0;
            output("ASN1objectidentifier2_t %s = {\n%u, %s\n};\n", ideref, length, buf);
        }
        else
        {
            uint32_t length = value->U.ObjectIdentifier.Value.length;
            uint32_t *val = value->U.ObjectIdentifier.Value.value;
            uint32_t i;
            char buf[1024];
            char *p = buf;
            for (i = 0; i < length; i++)
            {
                if (i == length - 1)
                {
                    sprintf(p, "{ NULL, %u }", val[i]);
                }
                else
                {
                    sprintf(p, "{ (ASN1objectidentifier_t) &(%s_list[%u]), %u },\n", ideref, i+1, val[i]);
                }
                p += strlen(p);
            }
            *p = 0;
            output("static const struct ASN1objectidentifier_s %s_list[%u] = {\n%s\n};\n",
            ideref, length, buf);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	switch (noctets) {
	case 1:
	    output("static ASN1char_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 2:
	    output("static ASN1char16_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	case 4:
	    output("static ASN1char32_t %s_chars[%u] = { ",
		ideref, value->U.RestrictedString.Value.length + zero);
	    break;
	}
	for (i = 0; i < value->U.RestrictedString.Value.length; i++) {
	    output("0x%x", value->U.RestrictedString.Value.value[i]);
	    if (i < value->U.RestrictedString.Value.length - 1)
		output(", ");
	}
	if (zero) {
	    if (value->U.RestrictedString.Value.length)
		output(", 0x0");
	    else
		output("0x0");
	}
	output(" };\n");
	break;
    case eType_ObjectDescriptor:
	output("static ASN1char_t %s_chars[%u] = { ",
	    ideref, value->U.ObjectDescriptor.Value.length + 1);
	for (i = 0; i < value->U.ObjectDescriptor.Value.length; i++) {
	    output("0x%x, ", value->U.ObjectDescriptor.Value.value[i]);
	}
	output("0x0 };\n");
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	if (type->Rules & 
	    (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
	    if (value->U.SS.Values) {
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {
		    sprintf(buf, "%s_value%d", ideref, i);
		    outputvalue1(ass, buf,
			GetTypeName(ass, type->U.SS.Type),
			values);
		}
		output("static %s %s_values[%u] = { ",
		    GetTypeName(ass, type->U.SS.Type),
		    ideref, i);
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {
		    if (i)
			output(", ");
		    sprintf(buf, "%s_value%d", ideref, i);
		    outputvalue2(ass, buf, values);
		}
		output(" };\n");
	    }
	} else if (type->Rules &
	    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
	    for (i = 0, values = value->U.SS.Values; values;
		i++, values = values->Next) {
		sprintf(buf, "%s_element%d", ideref, i);
		outputvalue1(ass, buf, GetTypeName(ass, type->U.SS.Type),
		    values);
	    }
	    for (i = 0, values = value->U.SS.Values; values;
		i++, values = values->Next) {
		output("static %s_Element %s_value%d = { ",
		    typeref, ideref, i);
		if (values->Next)
		    output("&%s_value%d, ", ideref, i + 1);
		else
		    output("0, ");
		if (type->Rules & eTypeRules_DoublyLinkedList) {
		    if (i)
			output("&%s_value%d, ", ideref, i - 1);
		    else
			output("0, ");
		}
		sprintf(buf, "%s_element%d", ideref, i);
		outputvalue2(ass, buf, values);
		output(" };\n");
	    }
	} else {
	    MyAbort();
	}
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue)
		    break;
		sprintf(buf, "%s_%s", ideref,
		    Identifier2C(components->U.NOD.NamedType->Identifier));
		outputvalue1(ass, buf,
		    GetTypeName(ass, components->U.NOD.NamedType->Type),
		    namedvalue->Value);
		break;
	    }
	}
	break;
    case eType_Choice:
	namedvalue = value->U.Choice.NamedValues;
	components = FindComponent(ass, type->U.Choice.Components,
	    namedvalue->Identifier);
	sprintf(buf, "%s_%s", ideref,
	    Identifier2C(components->U.NOD.NamedType->Identifier));
	outputvalue1(ass, buf, GetTypeName(ass,
	    components->U.NOD.NamedType->Type),
	    namedvalue->Value);
	output("static %s %s = ",
	    GetTypeName(ass, components->U.NOD.NamedType->Type), buf);
	outputvalue2(ass, buf, namedvalue->Value);
	output(";\n");
	break;
    }
}

/* output definition of value */
void
outputvalue2(AssignmentList_t ass, char *ideref, Value_t *value)
{
    Type_t *type;
    char buf[256];
    char *itype;
    int32_t noctets;
    uint32_t zero;
    uint32_t i;
    Value_t *values;
    Component_t *components;
    NamedValue_t *namedvalue;
    char *comma;
    uint32_t ext;
    uint32_t opt;
    int32_t sign;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    value = GetValue(ass, value);
    switch (type->Type) {
    case eType_Boolean:
	output("%d", value->U.Boolean.Value);
	break;
    case eType_Integer:
	itype = GetIntegerType(ass, type, &sign);
	if (!strcmp(itype, "ASN1intx_t")) {
	    output("{ %d, %s_octets }", value->U.Integer.Value.length, ideref);
	} else if (sign > 0) {
	    output("%u", intx2uint32(&value->U.Integer.Value));
	} else {
	    output("%d", intx2int32(&value->U.Integer.Value));
	}
	break;
    case eType_Enumerated:
	output("%u", value->U.Enumerated.Value);
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (!strcmp(itype, "ASN1real_t")) {
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("{ eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } }",
		    value->U.Real.Value.mantissa.length, ideref,
		    value->U.Real.Value.base,
		    value->U.Real.Value.exponent.length, ideref);
		break;
	    case eReal_PlusInfinity:
		output("{ eReal_PlusInfinity }");
		break;
	    case eReal_MinusInfinity:
		output("{ eReal_MinusInfinity }");
		break;
	    }
	}
	else
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		output("%g", real2double(&value->U.Real.Value));
		break;
	    case eReal_PlusInfinity:
	    case eReal_MinusInfinity:
		output("0.0");
		break;
	    }
	}
	break;
    case eType_BitString:
	output("{ %u, %s_octets }",
	    value->U.BitString.Value.length, ideref);
	break;
    case eType_OctetString:
	output("{ %u, %s_octets }",
	    value->U.OctetString.Value.length, ideref);
	break;
    case eType_UTF8String:
        output("{ %u, %s_utf8chars }",
            value->U.UTF8String.Value.length, ideref);
        break;
    case eType_ObjectIdentifier:
        if (type->PrivateDirectives.fOidPacked)
        {
            // doing nothing
        }
        else
        if (type->PrivateDirectives.fOidArray || g_fOidArray)
        {
            output("(ASN1objectidentifier2_t *) &%s_list", ideref);
        }
        else
        {
            output("(ASN1objectidentifier_t) %s_list", ideref);
        }
        break;
    case eType_BMPString:
    case eType_GeneralString:
    case eType_GraphicString:
    case eType_IA5String:
    case eType_ISO646String:
    case eType_NumericString:
    case eType_PrintableString:
    case eType_TeletexString:
    case eType_T61String:
    case eType_UniversalString:
    case eType_VideotexString:
    case eType_VisibleString:
    case eType_RestrictedString:
	itype = GetStringType(ass, type, &noctets, &zero);
	if (zero) {
	    output("%s_chars", ideref);
	} else {
	    output("{ %u, %s_chars }",
		value->U.RestrictedString.Value.length, ideref);
	}
	break;
    case eType_ObjectDescriptor:
	output("%s_chars", ideref);
	break;
    case eType_GeneralizedTime:
	output("{ %d, %d, %d, %d, %d, %d, %d, %d, %d }",
	    value->U.GeneralizedTime.Value.year,
	    value->U.GeneralizedTime.Value.month,
	    value->U.GeneralizedTime.Value.day,
	    value->U.GeneralizedTime.Value.hour,
	    value->U.GeneralizedTime.Value.minute,
	    value->U.GeneralizedTime.Value.second,
	    value->U.GeneralizedTime.Value.millisecond,
	    value->U.GeneralizedTime.Value.universal,
	    value->U.GeneralizedTime.Value.diff);
	break;
    case eType_UTCTime:
	output("{ %d, %d, %d, %d, %d, %d, %d, %d }",
	    value->U.UTCTime.Value.year,
	    value->U.UTCTime.Value.month,
	    value->U.UTCTime.Value.day,
	    value->U.UTCTime.Value.hour,
	    value->U.UTCTime.Value.minute,
	    value->U.UTCTime.Value.second,
	    value->U.UTCTime.Value.universal,
	    value->U.UTCTime.Value.diff);
	break;
    case eType_SequenceOf:
    case eType_SetOf:
	if (type->Rules &
	    (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
	    if (value->U.SS.Values) {
		for (i = 0, values = value->U.SS.Values; values;
		    i++, values = values->Next) {}
		output("{ %d, %s_values }", i, ideref);
	    } else {
		output("{ 0, NULL }");
	    }
	} else if (type->Rules &
	    (eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
	    output("&%s_value0", ideref);
	} else {
	    MyAbort();
	}
	break;
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	comma = "";
	output("{ ");
	if (type->U.SSC.Optionals || type->U.SSC.Extensions) {
	    output("{ ");
	    ext = 0;
	    opt = 0;
	    i = 0;
	    comma = "";
	    for (components = type->U.SSC.Components; components;
		components = components->Next) {
		switch (components->Type) {
		case eComponent_Normal:
		    if (!ext)
			break;
		    /*FALLTHROUGH*/
		case eComponent_Optional:
		case eComponent_Default:
		    namedvalue = FindNamedValue(value->U.SSC.NamedValues,
			components->U.NOD.NamedType->Identifier);
		    if (namedvalue)
			opt |= (0x80 >> i);
		    if (++i > 7) {
			output("%s0x%02x", comma, opt);
			opt = 0;
			i = 0;
			comma = ", ";
		    }
		    break;
		case eComponent_ExtensionMarker:
		    if (i) {
			output("%s0x%02x", comma, opt);
			opt = 0;
			i = 0;
			comma = ", ";
		    }
		    ext = 1;
		    break;
		}
	    }
	    if (i)
		output("%s0x%02x", comma, opt);
	    output(" }");
	    comma = ", ";
	}
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
	    case eComponent_Optional:
	    case eComponent_Default:
		namedvalue = FindNamedValue(value->U.SSC.NamedValues,
		    components->U.NOD.NamedType->Identifier);
		if (!namedvalue) {
		    output("%s0", comma);
		} else {
		    output("%s", comma);
		    sprintf(buf, "%s_%s", ideref,
			Identifier2C(components->U.NOD.NamedType->Identifier));
		    outputvalue2(ass, buf, namedvalue->Value);
		}
		comma = ", ";
		break;
	    }
	}
	output(" }");
	break;
    case eType_Choice:
	i = ASN1_CHOICE_BASE;
	for (components = type->U.SSC.Components; components;
	    components = components->Next) {
	    switch (components->Type) {
	    case eComponent_Normal:
		if (!strcmp(value->U.SSC.NamedValues->Identifier,
		    components->U.NOD.NamedType->Identifier))
		    break;
		i++;
		continue;
	    case eComponent_ExtensionMarker:
		continue;
	    default:
		MyAbort();
	    }
	    break;
	}
	output("{ %d }", i);
    }
}

/* output assignments needed in initialization function */
void
outputvalue3(AssignmentList_t ass, char *ideref, char *valref, Value_t *value)
{
    Type_t *type;
    NamedValue_t *named;
    Value_t *values;
    int i;
    char idebuf[256];
    char valbuf[256];
    char *itype;

    value = GetValue(ass, value);
    type = GetType(ass, value->Type);
    switch (type->Type) {
    case eType_SequenceOf:
    case eType_SetOf:
	for (values = value->U.SS.Values, i = 0; values;
	    values = values->Next, i++) {
	    if (type->Rules &
	        (eTypeRules_LengthPointer | eTypeRules_FixedArray)) {
		sprintf(idebuf, "%s.value[%d]", ideref, i);
	    } else if (type->Rules &
		(eTypeRules_SinglyLinkedList | eTypeRules_DoublyLinkedList)) {
		sprintf(idebuf, "%s_value%d", ideref, i);
	    } else {
		MyAbort();
	    }
	    sprintf(valbuf, "%s_value%d", valref, i);
	    outputvalue3(ass, idebuf, valbuf, values);
	}
	break;
    case eType_Choice:
	output("%s.u.%s = %s_%s;\n",
	    ideref, Identifier2C(value->U.SSC.NamedValues->Identifier),
	    valref, Identifier2C(value->U.SSC.NamedValues->Identifier));
	/*FALLTHROUGH*/
    case eType_Sequence:
    case eType_Set:
    case eType_External:
    case eType_EmbeddedPdv:
    case eType_CharacterString:
    case eType_InstanceOf:
	for (named = value->U.SSC.NamedValues; named; named = named->Next) {
	    sprintf(idebuf, "%s.%s", ideref,
		Identifier2C(named->Identifier));
	    sprintf(valbuf, "%s_%s", valref,
		Identifier2C(named->Identifier));
	    outputvalue3(ass, idebuf, valbuf, named->Value);
	}
	break;
    case eType_Real:
	itype = GetRealType(type);
	if (strcmp(itype, "ASN1real_t"))
	{
	    switch (value->U.Real.Value.type) {
	    case eReal_Normal:
		break;
	    case eReal_PlusInfinity:
		output("%s = ASN1double_pinf();\n", ideref);
		break;
	    case eReal_MinusInfinity:
		output("%s = ASN1double_minf();\n", ideref);
		break;
	    }
	}
    }
}

/* print indentation up to current indentation level for variables */
static void
findentvar()
{
    int indent;

    indent = ycurrindent * INDENT;
    while (indent >= TABSIZE) {
	yputc('\t');
	indent -= TABSIZE;
    }
    while (indent--)
	yputc(' ');
}

/* print indentation up to current indentation level for variables */
void
outputvarv(const char *format, va_list args)
{
    static char buf[512];
    static int pos = 0;
    char *p, *q;
    int l;
    
    /* get the string to write */
    vsprintf(buf + pos, format, args);

    /* print it line by line */
    for (p = buf; *p; p = q) {
	q = strchr(p, '\n');
	if (!q) {
	    for (q = buf; *p;)
		*q++ = *p++;
	    *q = 0;
	    pos = q - buf;
	    return;
	}
	*q++ = 0;

	/* output every variable only once */
	if (ycurrindent == 1) {
	    l = 0;
	    while (l < ybuflen) {
		if (!memcmp(ybuf + l + INDENT / TABSIZE + INDENT % TABSIZE,
		    p, strlen(p)))
		    break;
		l += (strchr(ybuf + l, '\n') - (ybuf + l)) + 1;
	    }
	    if (l < ybuflen)
		continue;
	}

	/* examine the first character for correct indentation */
	if (strchr(IDCHRSET, *p)) {
	    l = strspn(p, IDCHRSET);
	} else if (*p == '{' || *p == '}') {
	    l = 1;
	} else {
	    l = 0;
	}

	if (!l) {

	    /* no indentation at all */
	    yputs(p);
	    yputc('\n');
	    continue;
	}

	/* closing brace? then unindent */
	if (p[0] == '}')
	    ycurrindent--;

	/* print indentation */
	findentvar();

	/* output the line */
	yputs(p);
	yputc('\n');

	/* indent after opening brace */
	if (p[strlen(p) - 1] == '{') {
	    ycurrindent++;
	}
    }
    pos = 0;
}

/* print indentation up to current indentation level for variables */
/*PRINTFLIKE1*/
void
outputvar(const char *format, ...)
{
    va_list args;

    va_start(args, format);
    outputvarv(format, args);
    va_end(args);
}

/* output an octet array definition for variables */
void
outputvaroctets(const char *name, uint32_t length, octet_t *val)
{
    uint32_t i;
    char buf[256];
    char *p;

    p = buf;
    for (i = 0; i < length; i++) {
	sprintf(p, "0x%02x", val[i]);
	p += 4;
	if (i < length - 1) {
	    sprintf(p, ", ");
	    p += 2;
	}
    }
    outputvar("static ASN1octet_t %s_octets[%u] = { %s };\n",
	name, length, buf);
}

/* output an intx value definition for variables */
void outputvarintx(const char *name, intx_t *val)
{
    outputvaroctets(name, val->length, val->value);
    outputvar("static ASN1intx_t %s = { %d, %s_octets };\n",
	name, val->length, name);
}

/* output an real value definition for variables */
void outputvarreal(const char *name, real_t *val)
{
    char buf[256];
    switch (val->type) {
    case eReal_Normal:
	sprintf(buf, "%s_mantissa", name);
	outputvaroctets(buf, val->mantissa.length, val->mantissa.value);
	sprintf(buf, "%s_exponent", name);
	outputvaroctets(buf, val->exponent.length, val->exponent.value);
	outputvar("ASN1real_t %s = { eReal_Normal, { %u, %s_mantissa_octets }, %u, { %u, %s_exponent_octets } };\n",
	    name, val->mantissa.length, name,
	    val->base, val->exponent.length, name);
	break;
    case eReal_PlusInfinity:
	outputvar("ASN1real_t %s = { eReal_PlusInfinity };\n", name);
	break;
    case eReal_MinusInfinity:
	outputvar("ASN1real_t %s = { eReal_MinusInfinity };\n", name);
	break;
    }
}

/* output a character of the function body */
void xputc(char c)
{
    if (xbuflen + 1 > xbufsize) {
    	xbufsize += 1024;
	if (!xbuf)
	    xbuf = (char *)malloc(xbufsize);
	else
	    xbuf = (char *)realloc(xbuf, xbufsize);
    }
    xbuf[xbuflen++] = c;
}

/* output a string of the function body */
void xputs(char *s)
{
    int sl;

    sl = strlen(s);
    if (xbuflen + sl > xbufsize) {
	while (xbuflen + sl > xbufsize)
	    xbufsize += 1024;
	if (!xbuf)
	    xbuf = (char *)malloc(xbufsize);
	else
	    xbuf = (char *)realloc(xbuf, xbufsize);
    }
    memcpy(xbuf + xbuflen, s, sl);
    xbuflen += sl;
}

/* flush the function body into the output file */
void xflush()
{
    if (xbuflen) {
	fwrite(xbuf, xbuflen, 1, fout);
#if 0
	fflush(fout);
#endif
	xbuflen = 0;
    }
}

/* output a character of the function variables */
void yputc(char c)
{
    if (ybuflen + 1 > ybufsize) {
    	ybufsize += 1024;
	if (!ybuf)
	    ybuf = (char *)malloc(ybufsize);
	else
	    ybuf = (char *)realloc(ybuf, ybufsize);
    }
    ybuf[ybuflen++] = c;
}

/* output a string of the function variables */
void yputs(char *s)
{
    int sl;

    sl = strlen(s);
    if (ybuflen + sl > ybufsize) {
	while (ybuflen + sl > ybufsize)
	    ybufsize += 1024;
	if (!ybuf)
	    ybuf = (char *)malloc(ybufsize);
	else
	    ybuf = (char *)realloc(ybuf, ybufsize);
    }
    memcpy(ybuf + ybuflen, s, sl);
    ybuflen += sl;
}

/* flush the function variables into the output file */
void yflush()
{
    if (ybuflen) {
	fwrite(ybuf, ybuflen, 1, fout);
#if 0
	fflush(fout);
#endif
	ybuflen = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\cntlist.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "cntlist.h"


CList::CList(UINT cMaxItems)
:
    m_cMaxEntries(cMaxItems)
{
    Init(1);
}


CList::CList(CList *pSrc)
:
    m_cMaxEntries(pSrc->GetCount())
{

    Init(1);

    LPVOID p;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate()))
    {
        Append(p);
    }
}


CList::CList(UINT cMaxItems, UINT cSubItems)
:
    m_cMaxEntries(cMaxItems)
{
    ASSERT(2 == cSubItems);
    Init(cSubItems);
}


BOOL CList::Init(UINT cSubItems)
{
    if (m_cMaxEntries < CLIST_DEFAULT_MAX_ITEMS)
    {
        m_cMaxEntries = CLIST_DEFAULT_MAX_ITEMS;
    }

    m_cEntries = 0;
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
    m_cSubItems = cSubItems;

    // it is kind of bad here because there is no way to return an error.
    // unfortunately it won't fault here and later.
    m_aEntries = (LPVOID *) new char[m_cMaxEntries * m_cSubItems * sizeof(LPVOID)];
    CalcKeyArray();
    return (BOOL) m_aEntries;
}


CList::~CList(void) 
{
    delete m_aEntries;
}


void CList::CalcKeyArray(void)
{
    if (1 == m_cSubItems)
    {
        m_aKeys = NULL;
    }
    else
    {
        ASSERT(2 == m_cSubItems);
        m_aKeys = (NULL != m_aEntries) ?
                        (UINT *) &m_aEntries[m_cMaxEntries] :
                        NULL;
    }
}


BOOL CList::Expand(void)
{
    if (NULL == m_aEntries)
    {
        // it is impossible.
        ASSERT(FALSE);
        return Init(m_cSubItems);
    }

    // the current array is full
    ASSERT(m_cEntries == m_cMaxEntries);

    // remember the old array to free or to restore
    LPVOID  *aOldEntries = m_aEntries;

    // we need to allocate a bigger array to hold more data.
    // the new array has twice the size of the old one
    UINT cNewMaxEntries = m_cMaxEntries << 1;
    m_aEntries = (LPVOID *) new char[cNewMaxEntries * m_cSubItems * sizeof(LPVOID)];
    if (NULL == m_aEntries)
    {
        // we failed; we have to restore the array and return
        m_aEntries = aOldEntries;
        return FALSE;
    }

    // copy the old entries into the new array, starting from the beginning
    UINT nIdx = m_cMaxEntries - m_nHeadOffset;
    ::CopyMemory(m_aEntries, &aOldEntries[m_nHeadOffset], nIdx * sizeof(LPVOID));
    ::CopyMemory(&m_aEntries[nIdx], aOldEntries, m_nHeadOffset * sizeof(LPVOID));

    // set the new max entries (required for the key array)
    m_cMaxEntries = cNewMaxEntries;

    if (m_cSubItems > 1)
    {
        ASSERT(2 == m_cSubItems);
        UINT *aOldKeys = m_aKeys;
        CalcKeyArray();
        ::CopyMemory(m_aKeys, &aOldKeys[m_nHeadOffset], nIdx * sizeof(UINT));
        ::CopyMemory(&m_aKeys[nIdx], aOldKeys, m_nHeadOffset * sizeof(UINT));
    }

    // Free the old array of entries
    delete aOldEntries;

    // Set the instance variables
    m_nHeadOffset = 0;
    m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;

    return TRUE;
}


BOOL CList::Append(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_aEntries[(m_nHeadOffset + (m_cEntries++)) % m_cMaxEntries] = pData;

    return TRUE;
}


BOOL CList::Prepend(LPVOID pData)
{
    if (NULL == m_aEntries || m_cEntries >= m_cMaxEntries)
    {
        if (! Expand())
        {
            return FALSE;
        }
    }

    ASSERT(NULL != m_aEntries);
    ASSERT(m_cEntries < m_cMaxEntries);

    m_cEntries++;
    m_nHeadOffset = (0 == m_nHeadOffset) ? m_cMaxEntries - 1 : m_nHeadOffset - 1;
    m_aEntries[m_nHeadOffset] = pData;

    return TRUE;
}


BOOL CList::Find(LPVOID pData)
{
    for (UINT i = 0; i < m_cEntries; i++)
    {
        if (pData == m_aEntries[(m_nHeadOffset + i) % m_cMaxEntries])
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL CList::Remove(LPVOID pData)
{
    UINT nIdx;
    for (UINT i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (pData == m_aEntries[nIdx])
        {
            // to remove the current, we simply move the last to here.
            UINT nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
            m_aEntries[nIdx] = m_aEntries[nIdxSrc];
            if (m_cSubItems > 1)
            {
                ASSERT(2 == m_cSubItems);
                m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            }
            m_cEntries--;
            return TRUE;
        }
    }
    return FALSE;
}


LPVOID CList::Get(void)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
    }
    return pRet;
}


LPVOID CList::Iterate(void)
{
    if (0 == m_cEntries)
    {
        return NULL;
    }

    if (m_nCurrOffset == CLIST_END_OF_ARRAY_MARK)
    {
        // start from the beginning
        m_nCurrOffset = 0;
    }
    else
    {
        if (++m_nCurrOffset >= m_cEntries)
        {
            // reset the iterator
            m_nCurrOffset = CLIST_END_OF_ARRAY_MARK;
            return NULL;
        }
    }

    return m_aEntries[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries];
}





CList2::CList2(CList2 *pSrc)
:
    CList(pSrc->GetCount(), 2)
{
    CalcKeyArray();

    LPVOID p;
    UINT n;
    pSrc->Reset();
    while (NULL != (p = pSrc->Iterate(&n)))
    {
        Append(n, p);
    }
}


BOOL CList2::Append(UINT nKey, LPVOID pData)
{
    if (! CList::Append(pData))
    {
        return FALSE;
    }

    // after CList::append(), m_cEntries has been incremented,
    // therefore, we need decrement it again.
    m_aKeys[(m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries] = nKey;
    return TRUE;
}


BOOL CList2::Prepend(UINT nKey, LPVOID pData)
{
    if (! CList::Prepend(pData))
    {
        return FALSE;
    }

    m_aKeys[m_nHeadOffset] = nKey;
    return TRUE;
}


LPVOID CList2::Find(UINT nKey)
{
    UINT nIdx;
    for (UINT i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            return m_aEntries[nIdx];
        }
    }
    return NULL;
}


LPVOID CList2::Remove(UINT nKey)
{
    UINT nIdx;
    for (UINT i = 0; i < m_cEntries; i++)
    {
        nIdx = (m_nHeadOffset + i) % m_cMaxEntries;
        if (nKey == m_aKeys[nIdx])
        {
            LPVOID pRet = m_aEntries[nIdx];

            // to remove the current, we simply move the last to here.
            UINT nIdxSrc = (m_nHeadOffset + (m_cEntries - 1)) % m_cMaxEntries;
            m_aEntries[nIdx] = m_aEntries[nIdxSrc];
            m_aKeys[nIdx] = m_aKeys[nIdxSrc];
            m_cEntries--;
            return pRet;
        }
    }
    return NULL;
}


LPVOID CList2::Get(UINT *pnKey)
{
    LPVOID pRet = NULL;

    if (m_cEntries > 0)
    {
        pRet = m_aEntries[m_nHeadOffset];
        *pnKey = m_aKeys[m_nHeadOffset];
        m_cEntries--;
        m_nHeadOffset = (m_nHeadOffset + 1) % m_cMaxEntries;
    }
    else
    {
        pRet = NULL;
        *pnKey = 0;
    }
    return pRet;
}


LPVOID CList2::Iterate(UINT *pnKey)
{
    LPVOID p = CList::Iterate();
    *pnKey = (NULL != p) ? m_aKeys[(m_nHeadOffset + m_nCurrOffset) % m_cMaxEntries] : 0;
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\cntlist.h ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#ifndef _CONTAINED_LIST_H_
#define _CONTAINED_LIST_H_


#define CLIST_DEFAULT_MAX_ITEMS   8
#define CLIST_END_OF_ARRAY_MARK   ((UINT) -1)


class CList
{
public:

    CList(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS);
    CList(CList *pSrc);

    CList(UINT cMaxItems, UINT cSubItems);

    ~CList(void);

    BOOL Append(LPVOID pData);
    BOOL Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    void CalcKeyArray(void);

protected:

    UINT       m_cEntries;
    UINT       m_cMaxEntries;
    UINT       m_nHeadOffset;
    UINT       m_nCurrOffset;
    UINT       m_cSubItems;    // 1 for CList, 2 for CList2

    LPVOID      *m_aEntries;
    UINT        *m_aKeys;       // for CList2

private:

    BOOL Expand(void);
    BOOL Init(UINT cSubItems);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) CList::Iterate(); }


class CList2 : public CList
{
public:

    CList2(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 2) { }
    CList2(CList2 *pSrc);

    BOOL Append(UINT nKey, LPVOID pData);
    BOOL Prepend(UINT nKey, LPVOID pData);

    // BOOL Remove(LPVOID pData); // inherited from CList
    LPVOID Remove(UINT nKey);

    // BOOL Find(LPVOID pData); // inherited from CList
    LPVOID Find(UINT nKey);

    // LPVOID Get(void); // inheirted from CList
    LPVOID Get(UINT *pnKey);

    // LPVOID Iterate(void); // inherited from CList
    LPVOID Iterate(UINT *pnKey);
};


#define DEFINE_CLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) CList2::Remove((UINT) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) CList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { return (_PtrItemType_) CList2::Get((UINT *) pnKey); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { return (_PtrItemType_) CList2::Iterate((UINT *) pnKey); }

#define DEFINE_CLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems) { ASSERT(sizeof(_ShortKeyType_) != sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { ASSERT(sizeof(_ShortKeyType_) != sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { ASSERT(sizeof(_ShortKeyType_) != sizeof(UINT)); ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT) nKey, (LPVOID) pData); } \
            BOOL Prepend(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_ShortKeyType_ nKey) { return (_PtrItemType_) CList2::Remove((UINT) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_ShortKeyType_ nKey) { return (_PtrItemType_) CList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ Get(_ShortKeyType_ *pnKey) { UINT n; _PtrItemType_ p = (_PtrItemType_) CList2::Get(&n); *pnKey = (_ShortKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); } \
            _PtrItemType_ Iterate(_ShortKeyType_ *pnKey) { UINT n; _PtrItemType_ p = (_PtrItemType_) CList2::Iterate(&n); *pnKey = (_ShortKeyType_) n; return p; }

// both key and item are of the same type
#define DEFINE_CLIST2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Remove((UINT) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Find((UINT) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Get((UINT *) pnKey); } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) CList::PeekHead(); } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Iterate((UINT *) pnKey); }


typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT)  1)
#define FALSE_PTR       ((LPVOID) (UINT) -1)

#endif // _CONTAINED_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\asn1\asn1cpp\asn1cpp.cpp ===
/* Copyright (C) Microsoft Corporation, 1998. All rights reserved. */

#include "precomp.h"
#include "getsym.h"
#include "macro.h"
#include "typeid.h"
#include "utils.h"


// local prototypes
BOOL ExpandFile ( LPSTR pszInputFile, LPSTR pszOutputFile, CMacroMgrList *pMacrMgrList );
BOOL CollectMacros ( CInput *,