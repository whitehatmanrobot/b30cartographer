der.
PBYTE SkipMember(PBYTE pbMapAddress)
{
    PIMAGE_ARCHIVE_MEMBER_HEADER pMemHdr;
    ULONG       ulMemSize;
    int         j;

    pMemHdr = (PIMAGE_ARCHIVE_MEMBER_HEADER)pbMapAddress;

    // Get size of the member.
    ulMemSize = 0;
    for (j = 0; j < 10; j++)
    {
        if (pMemHdr->Size[j] < '0' || pMemHdr->Size[j] > '9')
            break;
        else
            ulMemSize = ulMemSize * 10 + pMemHdr->Size[j] - '0';
    }

    // Skip past the header.
    pbMapAddress += IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR + ulMemSize;
    // Find the next even address if the current one is not even.
    if ((ULONG)pbMapAddress % 2)
        pbMapAddress++;

    return pbMapAddress;
} // void SkipMember()

// This function returns the name of the given Obj.  If the name fits in the header,
// szBuf will be filled in and returned from the function.  Else an offset into the long
// names section will be returned.
char *GetNameOfObj(PBYTE pbLongNames, PIMAGE_ARCHIVE_MEMBER_HEADER pMemHdr, char szBuf[17])
{
    if (pMemHdr->Name[0] == '/')
    {
        ULONG   ulOffset = 0;

        // Long Names section must exist if the .obj file name starts with '/'.
        _ASSERTE(pbLongNames &&
            "Corrupt archive file - .obj file name in the header starts with "
            "'/' but no long names section present in the archive file.");

        // Calculate the offset into the long names section.
        for (int j = 1; j < 16; j++)
        {
            if (pMemHdr->Name[j] < '0' || pMemHdr->Name[j] > '9')
                break;
            else
                ulOffset = ulOffset * 10 + pMemHdr->Name[j] - '0';
        }
        return (char *)(pbLongNames + ulOffset);
    }
    else
    {
        for (int j = 0; j < 16; j++)
            if ((szBuf[j] = pMemHdr->Name[j]) == '/')
                break;
        szBuf[j] = '\0';
        return szBuf;
    }
} // char *GetNameOfObj()

// DisplayArchive() function
//
// Opens the .LIB file, and displays the metadata in the specified object files.

void DisplayArchive(wchar_t* szFile, ULONG DumpFilter, wchar_t* szObjName, strPassBackFn pDisplayString)
{
    PBYTE       pbMapAddress;
    PBYTE       pbStartAddress;
    PBYTE       pbLongNameAddress;
    PIMAGE_ARCHIVE_MEMBER_HEADER pMemHdr;
    DWORD       dwFileSize;
    PVOID       pvMetaData;
    char        *szName;
    wchar_t     wzName[1024];
    char        szBuf[17];
    long        cbMetaData;
    int         i;
    HRESULT     hr;
	char		szString[1024];

    GetMapViewOfFile(szFile, &pbMapAddress, &dwFileSize);
    pbStartAddress = pbMapAddress;

    // Verify and skip archive signature.
    if (dwFileSize < IMAGE_ARCHIVE_START_SIZE ||
        strncmp((char *)pbMapAddress, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE))
    {
        MDInfo::Error("Bad file format - archive signature mis-match!");
    }
    pbMapAddress += IMAGE_ARCHIVE_START_SIZE;

    // Skip linker member 1, linker member 2.
    for (i = 0; i < 2; i++)
        pbMapAddress = SkipMember(pbMapAddress);

    // Save address of the long name member and skip it if there exists one.
    pMemHdr = (PIMAGE_ARCHIVE_MEMBER_HEADER)pbMapAddress;
    if (pMemHdr->Name[0] == '/' && pMemHdr->Name[1] == '/')
    {
        pbLongNameAddress = pbMapAddress + IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR;
        pbMapAddress = SkipMember(pbMapAddress);
    }
    else
        pbLongNameAddress = 0;

    pDisplayString ("\n");
    // Get the MetaData for each object file and display it.
    while (DWORD(pbMapAddress - pbStartAddress) < dwFileSize)
    {
        szName = GetNameOfObj(pbLongNameAddress, (PIMAGE_ARCHIVE_MEMBER_HEADER)pbMapAddress, szBuf);
        if (mbstowcs(wzName, szName, 1024) == -1)
            MDInfo::Error("Conversion from Multi-Byte to Wide-Char failed.");

        // Display metadata only for object files.
        // If szObjName is specified, display metadata only for that one object file.
        if (!_stricmp(&szName[strlen(szName) - OBJ_EXT_LEN], OBJ_EXT) && 
            (!szObjName || !_wcsicmp(szObjName, wzName)))
        {
            // Try to find the MetaData section in the current object file.
            hr = FindObjMetaData(pbMapAddress+IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR, &pvMetaData, &cbMetaData);
            if (SUCCEEDED(hr))
            {
                sprintf (szString,"MetaData for object file %s:\n", szName);
				pDisplayString(szString);
                MDInfo archiveInfo(g_pDisp,
                                (PBYTE)pvMetaData,
                                cbMetaData,
                                pDisplayString,
                                DumpFilter);
                archiveInfo.DisplayMD();
            }
            else
			{
                sprintf(szString,"MetaData not found for object file %s!\n\n", szName);
				pDisplayString(szString);
			}
        }

        // Skip past the object file.
        pbMapAddress = SkipMember(pbMapAddress);
    }

    UnmapViewOfFile(pbStartAddress);
} // void DisplayArchive()

// DisplayFile() function
//
// Opens the meta data content of a .EXE, .CLB, .CLASS, .TLB, .DLL or .LIB file, and
// calls RawDisplay()

void DisplayFile(wchar_t* szFile, BOOL isFile, ULONG DumpFilter, wchar_t* szObjName, strPassBackFn pDisplayString)
{
    HRESULT hr=S_OK;

    // Open the emit scope
    WCHAR szScope[1024];
	char szString[1024];

    if (isFile)
    {
        wcscpy(szScope, L"file:");
        wcscat(szScope, szFile);
    }
    else
        wcscpy(szScope, szFile);

    // print bar that separates different files
    pDisplayString("////////////////////////////////////////////////////////////////\n");
    wchar_t rcFname[_MAX_FNAME], rcExt[_MAX_EXT];

    _wsplitpath(szFile, 0, 0, rcFname, rcExt);
    sprintf(szString,"\nFile %S%S: \n",rcFname, rcExt);
    pDisplayString(szString);

    if (DumpFilter & MDInfo::dumpValidate)
    {
        if (!_wcsicmp(rcExt, OBJ_EXT_W) || !_wcsicmp(rcExt, LIB_EXT_W))
            g_ValModuleType = ValidatorModuleTypeObj;
        else
            g_ValModuleType = ValidatorModuleTypePE;
    }

    if (!_wcsicmp(rcExt, LIB_EXT_W))
        DisplayArchive(szFile, DumpFilter, szObjName, pDisplayString);
    else
    {
        MDInfo metaDataInfo(g_pDisp, szScope, pDisplayString, DumpFilter);
        metaDataInfo.DisplayMD();
    }
} // void DisplayFile()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\dupelim.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mscorsrt.h
//
//*****************************************************************************

#pragma once

BOOL EliminateOverlaps(WCHAR *szFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\dupelim.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mscordmp.cpp
//
//*****************************************************************************
#include "common.h"

typedef unsigned __int16 UINT16;

#include <imagehlp.h>

MINIDUMP_THREAD *rgThreads = NULL;
ULONG32 cThreads = 0;

MINIDUMP_MODULE *rgModules = NULL;
ULONG32 cModules = 0;

MINIDUMP_DIRECTORY *rgDirs = NULL;

MINIDUMP_MEMORY_DESCRIPTOR *rgMemDescs = NULL;
ULONG32 cRanges = 0;

HANDLE hFile = INVALID_HANDLE_VALUE;

inline BOOL Contains(MINIDUMP_MEMORY_DESCRIPTOR *pRange1, MINIDUMP_MEMORY_DESCRIPTOR *pRange2)
{
    return ((pRange1->StartOfMemoryRange <= pRange2->StartOfMemoryRange) &&
            (pRange1->StartOfMemoryRange + pRange1->Memory.DataSize >= pRange2->StartOfMemoryRange + pRange2->Memory.DataSize));
}

inline BOOL Overlap(MINIDUMP_MEMORY_DESCRIPTOR *pRange1, MINIDUMP_MEMORY_DESCRIPTOR *pRange2)
{
    return ((pRange1->StartOfMemoryRange + pRange1->Memory.DataSize) > pRange2->StartOfMemoryRange);
}

inline BOOL ContainedInStack(MINIDUMP_MEMORY_DESCRIPTOR *pRange)
{
    for (ULONG32 i = 0; i < cThreads; i++)
    {
        if (Contains(&rgThreads[i].Stack, pRange))
        {
            return (TRUE);
        }
    }

    return (FALSE);
}

inline BOOL ContainedInModule(MINIDUMP_MEMORY_DESCRIPTOR *pRange)
{
    for (ULONG32 i = 0; i < cModules; i++)
    {
        MINIDUMP_MEMORY_DESCRIPTOR desc;
        desc.StartOfMemoryRange = rgModules[i].BaseOfImage;
        desc.Memory.DataSize = rgModules[i].SizeOfImage;

        if (Contains(&desc, pRange))
        {
            return (TRUE);
        }
    }

    return (FALSE);
}

BOOL EliminateOverlapsInDescriptors()
{
    if (cRanges == 0)
        return (TRUE);

    ULONG32 i = 0;
    while (i < cRanges - 1)
    {
        _ASSERTE(rgMemDescs[i].StartOfMemoryRange <= rgMemDescs[i+1].StartOfMemoryRange);
        if (rgMemDescs[i].StartOfMemoryRange > rgMemDescs[i+1].StartOfMemoryRange)
            return (FALSE);

        if (rgMemDescs[i].StartOfMemoryRange == rgMemDescs[i+1].StartOfMemoryRange)
        {
            if (Contains(&rgMemDescs[i], &rgMemDescs[i+1]))
            {
                memmove((void *)&rgMemDescs[i+1],
                        (const void *)&rgMemDescs[i+2],
                        (cRanges - (i + 2)) * sizeof(MINIDUMP_MEMORY_DESCRIPTOR));

                cRanges--;
            }

            else
            {
                _ASSERTE(Contains(&rgMemDescs[i+1], &rgMemDescs[i]));

                memmove((void *)&rgMemDescs[i],
                        (const void *)&rgMemDescs[i+1],
                        (cRanges - (i + 1)) * sizeof(MINIDUMP_MEMORY_DESCRIPTOR));

                cRanges--;
            }
        }

        else if (Contains(&rgMemDescs[i], &rgMemDescs[i+1]))
        {
            ULONG32 newSize = (ULONG32) (rgMemDescs[i+1].StartOfMemoryRange - rgMemDescs[i].StartOfMemoryRange);

            rgMemDescs[i+1].Memory.Rva = rgMemDescs[i].Memory.Rva + newSize;
            rgMemDescs[i+1].Memory.DataSize = rgMemDescs[i].Memory.DataSize - newSize;
            rgMemDescs[i].Memory.DataSize = newSize;
        }

        else if (Overlap(&rgMemDescs[i], &rgMemDescs[i+1]))
        {
            ULONG32 newSize = (ULONG32) (rgMemDescs[i+1].StartOfMemoryRange - rgMemDescs[i].StartOfMemoryRange);
            rgMemDescs[i].Memory.DataSize = newSize;
        }

        else if (ContainedInStack(&rgMemDescs[i]) || ContainedInModule(&rgMemDescs[i]))
        {
            memmove((void *)&rgMemDescs[i],
                    (const void *)&rgMemDescs[i+1],
                    (cRanges - (i + 1)) * sizeof(MINIDUMP_MEMORY_DESCRIPTOR));

            cRanges--;
        }

        i++;

        /*
        if (Contains(&rgMemDescs[i], &rgMemDescs[i+1]))
        {
            memmove((void *)&rgMemDescs[i+1],
                    (const void *)&rgMemDescs[i+2],
                    (cRanges - (i + 2)) * sizeof(MINIDUMP_MEMORY_DESCRIPTOR));

            cRanges--;
        }

        else if (Contains(&rgMemDescs[i+1], &rgMemDescs[i]))
        {
            memmove((void *)&rgMemDescs[i],
                    (const void *)&rgMemDescs[i+1],
                    (cRanges - (i + 1)) * sizeof(MINIDUMP_MEMORY_DESCRIPTOR));

            cRanges--;
        }

        else if (Overlap(&rgMemDescs[i], &rgMemDescs[i+1]))
        {
            SIZE_T cbOverlap = (SIZE_T)
                ((rgMemDescs[i].StartOfMemoryRange + rgMemDescs[i].Memory.DataSize) - rgMemDescs[i+1].StartOfMemoryRange);

            rgMemDescs[i].Memory.DataSize -= cbOverlap;

            i++;
        }

        else
        {
            i++;
        }
        */
    }

    return (TRUE);
}

BOOL EliminateOverlapsHelper(WCHAR *szFile)
{
    _ASSERTE(szFile != NULL);

    if (szFile == NULL)
        return (FALSE);

    //
    // Open the file
    //

    // Try to open the file
    hFile = WszCreateFile(szFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    _ASSERTE(hFile != INVALID_HANDLE_VALUE);

    if (hFile == INVALID_HANDLE_VALUE)
        return (FALSE);

    //
    // Read in the header
    //

    MINIDUMP_HEADER header;
    DWORD cbRead;
    BOOL fRes = ReadFile(hFile, (LPVOID) &header, sizeof(header), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    //
    // Read in the stream directory
    //

    // Create the stream directory
    rgDirs = new MINIDUMP_DIRECTORY[header.NumberOfStreams];
    _ASSERTE(rgDirs);

    if (!rgDirs)
        return (FALSE);

    // Read in the stream directory
    fRes = ReadFile(hFile, (LPVOID) rgDirs, header.NumberOfStreams * sizeof(MINIDUMP_DIRECTORY), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

#ifdef _DEBUG
    // Find the MemoryListStream entry
    SIZE_T cMemStreams = 0;
    for (ULONG32 j = 0; j < header.NumberOfStreams; j++)
    {
        if (rgDirs[j].StreamType == MemoryListStream)
            cMemStreams++;
    }
    _ASSERTE(cMemStreams == 1);
#endif    

    //
    // Find the MemoryListStream and ThreadListStream entries
    //

    ULONG32 memoryListStreamIdx = (ULONG32) (-1);
    ULONG32 threadListStreamIdx = (ULONG32) (-1);
    ULONG32 moduleListStreamIdx = (ULONG32) (-1);
    for (ULONG32 i = 0; i < header.NumberOfStreams; i++)
    {
        switch (rgDirs[i].StreamType)
        {
        case MemoryListStream:
            memoryListStreamIdx = i;
            break;

        case ThreadListStream:
            threadListStreamIdx = i;
            break;

        case ModuleListStream:
            moduleListStreamIdx = i;
            break;
        }
    }

    // The streams didn't exist
    if (memoryListStreamIdx == (ULONG32) (-1) ||
        threadListStreamIdx == (ULONG32) (-1) ||
        moduleListStreamIdx == (ULONG32) (-1))
    {
        return (FALSE);
    }

    // Record the RVAs of each
    RVA memStreamRVA = rgDirs[memoryListStreamIdx].Location.Rva;
    RVA thdStreamRVA = rgDirs[threadListStreamIdx].Location.Rva;
    RVA modStreamRVA = rgDirs[moduleListStreamIdx].Location.Rva;

    //
    // Read in the thread stream information
    //

    // Go to the RVA of the thread stream
    DWORD dwRes = SetFilePointer(hFile, (LONG) thdStreamRVA, NULL, FILE_BEGIN);
    _ASSERTE(dwRes == thdStreamRVA);

    if (dwRes != thdStreamRVA)
        return (FALSE);

    // Read in the number of ranges
    fRes = ReadFile(hFile, (LPVOID) &cThreads, sizeof(ULONG32), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    // Allocate an array of memory descriptors
    rgThreads = new MINIDUMP_THREAD[cThreads];
    _ASSERTE(rgThreads != NULL);

    if (!rgThreads)
        return (FALSE);

    // Read in the thread descriptors
    fRes = ReadFile(hFile, (LPVOID) rgThreads, sizeof(MINIDUMP_THREAD) * cThreads, &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    //
    // Read in the module stream information
    //

    // Go to the RVA of the module stream
    dwRes = SetFilePointer(hFile, (LONG) modStreamRVA, NULL, FILE_BEGIN);
    _ASSERTE(dwRes == modStreamRVA);

    if (dwRes != modStreamRVA)
        return (FALSE);

    // Read in the number of ranges
    fRes = ReadFile(hFile, (LPVOID) &cModules, sizeof(ULONG32), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    // Allocate an array of memory descriptors
    rgModules = new MINIDUMP_MODULE[cModules];
    _ASSERTE(rgModules != NULL);

    if (!rgModules)
        return (FALSE);

    // Read in the thread descriptors
    fRes = ReadFile(hFile, (LPVOID) rgModules, sizeof(MINIDUMP_MODULE) * cModules, &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    //
    // Read in the memory stream data
    //

    // Go to the RVA of the memory descs
    dwRes = SetFilePointer(hFile, (LONG) memStreamRVA, NULL, FILE_BEGIN);
    _ASSERTE(dwRes == memStreamRVA);

    if (dwRes != memStreamRVA)
        return (FALSE);

    // Read in the number of ranges
    fRes = ReadFile(hFile, (LPVOID) &cRanges, sizeof(ULONG32), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    // Allocate an array of memory descriptors
    rgMemDescs = new MINIDUMP_MEMORY_DESCRIPTOR[cRanges];
    _ASSERTE(rgMemDescs != NULL);

    if (!rgMemDescs)
        return (FALSE);

    // Read in the memory descriptors
    fRes = ReadFile(hFile, (LPVOID) rgMemDescs, sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cRanges, &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    //
    // Fixup the memory stream to eliminate overlapping ranges
    //

    fRes = EliminateOverlapsInDescriptors();
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    //
    // Rewrite the total size of the memory stream entry
    //

    // Go to the RVA of the memory descs
    dwRes = SetFilePointer(
        hFile,
        (LONG) (sizeof(header) + (memoryListStreamIdx * sizeof(MINIDUMP_DIRECTORY)) +
                offsetof(MINIDUMP_DIRECTORY, Location) + offsetof(MINIDUMP_LOCATION_DESCRIPTOR, DataSize)),
        NULL, FILE_BEGIN);

    // Write out the new size
    ULONG32 cbNewMemStreamSize = sizeof(MINIDUMP_MEMORY_LIST) + sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cRanges;
    fRes = WriteFile(hFile, (LPVOID) &cbNewMemStreamSize, sizeof(ULONG32), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    //
    // Rewrite the memory descriptors for the memory list stream and the count
    //

    // Go back to the RVA of the memory stream
    dwRes = SetFilePointer(hFile, (LONG) memStreamRVA, NULL, FILE_BEGIN);
    _ASSERTE(dwRes == memStreamRVA);

    if (dwRes != memStreamRVA)
        return (FALSE);

    // Overwrite the count of memory descriptors with the new count
    DWORD cbWritten;
    fRes = WriteFile(hFile, (LPCVOID) &cRanges, sizeof(ULONG32), &cbWritten, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    // Overwrite the memory stream memory descriptors with the adjusted version
    fRes = WriteFile(hFile, (LPCVOID) rgMemDescs, sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cRanges, &cbWritten, NULL);
    _ASSERTE(fRes);

    // Clean up
    delete [] rgMemDescs;
    rgMemDescs = NULL;

    if (!fRes)
        return (FALSE);

    fRes = FlushFileBuffers(hFile);

    if (!fRes)
        return (FALSE);

    fRes = CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    if (!fRes)
        return (FALSE);

    return (TRUE);
}

BOOL EliminateOverlaps(WCHAR *szFile)
{
    BOOL fRes = EliminateOverlapsHelper(szFile);

    if (rgThreads != NULL)
    {
        delete [] rgThreads;
        rgThreads = NULL;
    }

    if (rgDirs != NULL)
    {
        delete [] rgDirs;
        rgDirs = NULL;
    }

    if (rgMemDescs != NULL)
    {
        delete [] rgMemDescs;
        rgMemDescs = NULL;
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        FlushFileBuffers(hFile);
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    return (fRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: common.h
//
//*****************************************************************************

#pragma once

#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <crtdbg.h>
#include <malloc.h>

#include <utilcode.h>
#include <winwrap.h>
#include <corver.h>
#include "__file__.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\merge.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: merge.h
//
//*****************************************************************************

#pragma once

BOOL MergeMiniDump(WCHAR *szMiniDumpFile, WCHAR *szManagedDumpFile, WCHAR *szMergedDumpFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\merge.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: merge.cpp
//
//*****************************************************************************
#include "common.h"

typedef unsigned __int16 UINT16;

#include <minidump.h>

typedef struct
{
    HANDLE                      hFile;                  // The file handle for the minidump
    MINIDUMP_HEADER             header;                 // The minidump header
    MINIDUMP_DIRECTORY         *rgStreams;              // The array of streams
    ULONG32                     idxMemoryStream;        // Index of the memory stream in rgStreams
    RVA                         memStreamRVA;
    ULONG32                     cMemDescs;              // The number of memory blocks in this stream
    MINIDUMP_MEMORY_DESCRIPTOR *rgMemDescs;             // Array of memory block descriptors
    DWORD                       cbFileSize;             // Size of the file
} MiniDumpData;

typedef struct
{
    HANDLE                      hFile;                  // Managed dump file handle
    ULONG32                     cMemDescs;              // The number of memory blocks in this stream
    MINIDUMP_MEMORY_DESCRIPTOR *rgMemDescs;             // Array of memory block descriptors
    DWORD                       cbFileSize;             // Size of the file
} ManagedDumpData;

MiniDumpData    g_mdData;
ManagedDumpData g_mgData;

BOOL ReadManagedDump(WCHAR *szManagedDumpFile)
{
    // Try to open the file
    g_mgData.hFile = WszCreateFile(szManagedDumpFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    _ASSERTE(g_mgData.hFile != INVALID_HANDLE_VALUE);

    if (g_mgData.hFile == INVALID_HANDLE_VALUE)
        return (FALSE);

    // Save the size of the file
    DWORD dwHigh;
    g_mgData.cbFileSize = GetFileSize(g_mgData.hFile, &dwHigh);
    if (dwHigh != 0)
        return (FALSE);

    if (g_mgData.cbFileSize == (DWORD) -1)
        return (FALSE);

    // Read in the number of ranges
    DWORD cbRead;
    if (!ReadFile(g_mgData.hFile, (LPVOID) &g_mgData.cMemDescs, sizeof(ULONG32), &cbRead, NULL))
        return (FALSE);

    // Allocate an array of memory descriptors
    g_mgData.rgMemDescs = new MINIDUMP_MEMORY_DESCRIPTOR[g_mgData.cMemDescs];
    _ASSERTE(g_mgData.rgMemDescs != NULL);

    if (!g_mgData.rgMemDescs)
        return (FALSE);

    // Read in the memory descriptors
    if (!ReadFile(g_mgData.hFile, (LPVOID) g_mgData.rgMemDescs,
                  sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * g_mgData.cMemDescs, &cbRead, NULL))
    {
        delete [] g_mgData.rgMemDescs;
        return (FALSE);
    }

    return (TRUE);
}

BOOL ReadMiniDump(WCHAR *szMiniDumpFile)
{
    // Try to open the file
    g_mdData.hFile = WszCreateFile(szMiniDumpFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    _ASSERTE(g_mdData.hFile != INVALID_HANDLE_VALUE);

    if (g_mdData.hFile == INVALID_HANDLE_VALUE)
        return (FALSE);

    // Save the size of the file
    DWORD dwHigh;
    g_mdData.cbFileSize = GetFileSize(g_mdData.hFile, &dwHigh);
    if (dwHigh != 0)
        return (FALSE);

    if (g_mdData.cbFileSize == (DWORD) -1)
        return (FALSE);

    // Now read in the g_mdData.header
    DWORD cbRead;
    if (!ReadFile(g_mdData.hFile, (LPVOID) &g_mdData.header, sizeof(g_mdData.header), &cbRead, NULL))
        return (FALSE);

    // Create the stream directory
    g_mdData.rgStreams = new MINIDUMP_DIRECTORY[g_mdData.header.NumberOfStreams];
    _ASSERTE(g_mdData.rgStreams);

    if (!g_mdData.rgStreams)
        return (FALSE);

    // Read in the stream directory
    if (!ReadFile(g_mdData.hFile, (LPVOID) g_mdData.rgStreams,
                  g_mdData.header.NumberOfStreams * sizeof(MINIDUMP_DIRECTORY), &cbRead, NULL))
        return (FALSE);

    // Find the MemoryListStream entry
    for (ULONG32 i = 0; i < g_mdData.header.NumberOfStreams; i++)
    {
        if (g_mdData.rgStreams[i].StreamType == MemoryListStream)
        {
            // Save the index of the memory stream entry
            g_mdData.idxMemoryStream = i;

            // Save the RVA of the memory stream
            g_mdData.memStreamRVA = g_mdData.rgStreams[g_mdData.idxMemoryStream].Location.Rva;

            break;
        }
    }
    _ASSERTE(g_mdData.header.NumberOfStreams != i);

    // There was no memory stream entry
    if (g_mdData.header.NumberOfStreams == i)
    {
        delete [] g_mdData.rgStreams;
        return (FALSE);
    }

    // Go to the RVA of the memory stream
    DWORD dwRes = SetFilePointer(g_mdData.hFile, (LONG) g_mdData.memStreamRVA, NULL, FILE_BEGIN);
    _ASSERTE(dwRes == g_mdData.memStreamRVA);

    if (dwRes != g_mdData.memStreamRVA)
        return (FALSE);

    // Read in the number of ranges
    if (!ReadFile(g_mdData.hFile, (LPVOID) &g_mdData.cMemDescs, sizeof(ULONG32), &cbRead, NULL))
        return (FALSE);

    // Allocate an array of memory descriptors
    g_mdData.rgMemDescs = new MINIDUMP_MEMORY_DESCRIPTOR[g_mdData.cMemDescs];
    _ASSERTE(g_mdData.rgMemDescs != NULL);

    if (!g_mdData.rgMemDescs)
        return (FALSE);

    // Read in the memory descriptors
    if (!ReadFile(g_mdData.hFile, (LPVOID) g_mdData.rgMemDescs,
                  sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * g_mdData.cMemDescs, &cbRead, NULL))
    {
        delete [] g_mdData.rgMemDescs;
        return (FALSE);
    }

    return (TRUE);
}

BOOL DoMerge()
{
    // Figure out the combined count of memory blocks
    ULONG32 cNewMemDescs = g_mdData.cMemDescs + g_mgData.cMemDescs;
    ULONG32 cbNewMemStreamSize = sizeof(MINIDUMP_MEMORY_LIST) + sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * cNewMemDescs;

    // Figure out the RVA of where the new directory will start
    RVA newMemStreamRVA = g_mdData.cbFileSize;

    // Enter the new info in the stream descriptor
    g_mdData.rgStreams[g_mdData.idxMemoryStream].Location.Rva = newMemStreamRVA;
    g_mdData.rgStreams[g_mdData.idxMemoryStream].Location.DataSize = cbNewMemStreamSize;

    // Go to the RVA of the stream directory
    DWORD dwRes = SetFilePointer(
        g_mdData.hFile,
        (LONG) g_mdData.header.StreamDirectoryRva + (g_mdData.idxMemoryStream * sizeof(MINIDUMP_DIRECTORY)),
        NULL, FILE_BEGIN);

    if (dwRes != g_mdData.header.StreamDirectoryRva + (g_mdData.idxMemoryStream * sizeof(MINIDUMP_DIRECTORY)))
        return (FALSE);

    // Write out the new descriptor
    DWORD cbWrite;
    if (!WriteFile(g_mdData.hFile, (LPCVOID) &g_mdData.rgStreams[g_mdData.idxMemoryStream],
                   sizeof(MINIDUMP_DIRECTORY), &cbWrite, NULL))
        return (FALSE);

    // Now write out the new memory descriptor directory
    dwRes = SetFilePointer(g_mdData.hFile, (LONG) newMemStreamRVA, NULL, FILE_BEGIN);

    if (dwRes != newMemStreamRVA)
        return (FALSE);

    if (!WriteFile(g_mdData.hFile, (LPCVOID) &cNewMemDescs, sizeof(ULONG32), &cbWrite, NULL))
        return (FALSE);

    // Write the directory from the original minidump in an unchanged format
    if (!WriteFile(g_mdData.hFile, (LPCVOID) &g_mdData.rgMemDescs, g_mdData.cMemDescs * sizeof(MINIDUMP_MEMORY_DESCRIPTOR),
                   &cbWrite, NULL))
        return (FALSE);

    //
    // Now we need to adjust the RVA's of the managed dump to be relative to the new location of the memory blocks
    //

    // This is the location at which all the memory blocks start (i.e., subtract the memory occupied by the
    // memory descriptors)
    RVA cbOldBaseRVA = sizeof(MINIDUMP_MEMORY_LIST) + g_mgData.cMemDescs * sizeof(MINIDUMP_MEMORY_DESCRIPTOR);
    RVA cbNewBaseRVA = newMemStreamRVA + sizeof(MINIDUMP_MEMORY_LIST) + cNewMemDescs * sizeof(MINIDUMP_MEMORY_DESCRIPTOR);

    for (ULONG32 i = 0; i < g_mgData.cMemDescs; i++)
        g_mgData.rgMemDescs[i].Memory.Rva = g_mgData.rgMemDescs[i].Memory.Rva - cbOldBaseRVA + cbNewBaseRVA;

    if (!WriteFile(g_mdData.hFile, (LPCVOID) &g_mgData.rgMemDescs, g_mgData.cMemDescs * sizeof(MINIDUMP_MEMORY_DESCRIPTOR),
                   &cbWrite, NULL))
        return (FALSE);

    // Now write the actual memory data on the end of the file
    // Go to the RVA of the stream directory
    dwRes = SetFilePointer(g_mdData.hFile,
                           sizeof(MINIDUMP_MEMORY_LIST) + sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * g_mgData.cMemDescs,
                           NULL, FILE_BEGIN);

    DWORD cbMemToCopy = g_mgData.cbFileSize - cbOldBaseRVA;
    BYTE    rgBuf[1024];
    while (cbMemToCopy > 0)
    {
        DWORD cbBufCopy = min(cbMemToCopy, sizeof(rgBuf));

        DWORD cbRead;
        if (!ReadFile(g_mdData.hFile, (LPVOID) &rgBuf, cbBufCopy, &cbRead, NULL))
            return (FALSE);

        if (!WriteFile(g_mdData.hFile, (LPCVOID) &rgBuf, cbBufCopy, &cbWrite, NULL))
            return (FALSE);

        cbMemToCopy -= cbBufCopy;
    }

    return (TRUE);
}

BOOL MergeMiniDump(WCHAR *szMiniDumpFile, WCHAR *szManagedDumpFile, WCHAR *szMergedDumpFile)
{
    // Zero out all the structs
    memset((void *)&g_mdData, 0, sizeof(MiniDumpData));
    memset((void *)&g_mgData, 0, sizeof(ManagedDumpData));

    _ASSERTE(szMiniDumpFile != NULL);
    _ASSERTE(szManagedDumpFile != NULL);
    _ASSERTE(szMergedDumpFile != NULL);
    if (szMiniDumpFile == NULL || szManagedDumpFile == NULL || szMergedDumpFile == NULL)
        return (FALSE);

    // Can't have any files that are the same
    if (_wcsicmp(szMiniDumpFile, szManagedDumpFile) == 0 ||
        _wcsicmp(szMiniDumpFile, szMergedDumpFile) == 0 ||
        _wcsicmp(szManagedDumpFile, szMergedDumpFile) == 0 )
    {
        return (FALSE);
    }

    // Try and copy the file to the destination file
    if (!WszCopyFile(szMiniDumpFile, szMergedDumpFile, FALSE))
        return (FALSE);

    // Read the minidump file we just copied
    if (!ReadMiniDump(szMergedDumpFile))
        return (FALSE);

    // Read information out of the managed dump file
    if (!ReadManagedDump(szManagedDumpFile))
        return (FALSE);

    // Now we can actually do the merge
    if (!DoMerge())
        return (FALSE);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\mscordmp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mscordmp.cpp
//
//*****************************************************************************
#include "common.h"

#include "shell.h"
#include "minidump.h"

extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    MiniDumpShell *sh = new MiniDumpShell();

    return (sh->Main(argc, argv));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\vs\common.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: common.cpp
//
//*****************************************************************************

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\minidump.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: minidump.h
//
//*****************************************************************************

#pragma once

#include <IPCManagerInterface.h>

#include "Shell.h"

class MiniDump
{
private:
    // Constructor
    MiniDump() {}

    // Dtor
    ~MiniDump() {}

public:
    // Perform the dump operation
    static HRESULT WriteMiniDump(DWORD dwPid, WCHAR *szFilename);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\minidump.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: minidump.cpp
//
//*****************************************************************************

#include "common.h"
#include "minidump.h"
#include "minidumppriv.h"

// This is a typedef for the entrypoint for mscor[wks|svr]
extern "C" typedef HRESULT STDAPICALLTYPE CorCreateMiniDump(DWORD dwProcessId, WCHAR *szOutFilename);
typedef CorCreateMiniDump *PCorCreateMiniDump;
#define COR_CREATE_MINI_DUMP_ENTRYPOINT "CorCreateMiniDump"

extern "C" typedef HRESULT STDAPICALLTYPE GetRealProcAddress(LPCSTR szProcName, VOID** ppFn);
typedef GetRealProcAddress *PGetRealProcAddress;
#define SHIM_GET_REAL_PROC_ADDR_ENTRYPOINT "GetRealProcAddress"

extern "C" typedef HRESULT STDAPICALLTYPE CorBindToRuntimeByPath(LPCWSTR swzFullPath, BOOL *pBindSuccessful);
typedef CorBindToRuntimeByPath *PCorBindToRuntimeByPath;
#define SHIM_BIND_RUNTIME_BY_PATH "CorBindToRuntimeByPath"

#define COR_ALTERNATE_MINIDUMP_BINARY_W L"mscormdmp.dll"

//*****************************************************************************
// Writes the minidump (static version)
//*****************************************************************************
HRESULT MiniDump::WriteMiniDump(DWORD dwPid, WCHAR *szFilename)
{
    OnUnicodeSystem();

    HRESULT hr;
    WCHAR *corPath = NULL;

    // Check error conditions
    if (*szFilename == L'\0' || dwPid == 0)
        return (E_FAIL);

    WCHAR *winDir = REGUTIL::GetConfigString(L"windir", FALSE, REGUTIL::COR_CONFIG_ENV);
    DWORD  cWinDir = wcslen(winDir);

    WCHAR *sysDir = new WCHAR[cWinDir + wcslen(L"\\system32") + 1];
    wcscpy(sysDir, winDir);

    if (RunningOnWin95())
        wcscat(sysDir, L"\\system");
    else
        wcscat(sysDir, L"\\system32");

    DWORD cSysDir = wcslen(sysDir);

    corPath = new WCHAR[cSysDir + wcslen(L"\\mscoree.dll") + 1];
    wcscpy(corPath, sysDir);
    wcscat(corPath, L"\\mscoree.dll");

    // Now try and load mscoree.dll and call the minidump entrypoint
    HMODULE hEE = WszLoadLibrary(corPath);

    delete [] winDir;
    delete [] sysDir;
    delete [] corPath;

    if (hEE == NULL)
        return(HRESULT_FROM_WIN32(GetLastError()));

    // Try to create a new IPCReader
    IPCReaderInterface *ipcReader = new IPCReaderInterface();

    // Try and open the shared memory block (for read only access)
    // Note that this will fail if the IPC block versions differ
    hr = ipcReader->OpenPrivateBlockOnPidReadOnly(dwPid);

    if (FAILED(hr))
    {
        if (hEE != NULL)
            FreeLibrary(hEE);

        delete ipcReader;
        return (hr);
    }

    // This gets the information for the minidump block
    MiniDumpBlock *pMDBlock = ipcReader->GetMiniDumpBlock();

    // This is for future use - if a file of the name mscormdmp.dll exists in the same
    // directory as the runtime, we'll look for and invoke the minidump entrypoint on
    // in instead of the one in the runtime
    {
        WCHAR wszCorMdmpName[MAX_PATH+1];
        wcscpy(wszCorMdmpName, pMDBlock->szCorPath);

        WCHAR *wszPtr = wcsrchr(wszCorMdmpName, L'\\');
        if (wszPtr != NULL)
        {
            _ASSERTE(_wcsicmp(wszPtr, L"mscorwks.dll") == 0 || _wcsicmp(wszPtr, L"mscorsvr.dll"));

            // Change mscor[wks|svr].dll to mscormdmp.dll
            wcscpy(++wszPtr, COR_ALTERNATE_MINIDUMP_BINARY_W);

            // Try to load the dll
            HMODULE hMdmp = WszLoadLibrary(wszCorMdmpName);

            if (hMdmp != NULL)
            {
                // Now get the minidump creation function entrypoint.
                FARPROC pFcn = GetProcAddress(hMdmp, COR_CREATE_MINI_DUMP_ENTRYPOINT);

                if (pFcn != NULL)
                {
                    // Call the mini dump creation function.
                    hr = ((PCorCreateMiniDump) pFcn) (dwPid, szFilename);

                    if (SUCCEEDED(hr))
                    {
                        return (hr);
                    }
                }
            }
        }
    }

    FARPROC pFcn;
    BOOL    fBindSuccess;

    // First, must bind the shim to the runtime that's loaded in the
    // process that we are trying to perform the minidump on.
    pFcn = GetProcAddress(hEE, SHIM_BIND_RUNTIME_BY_PATH);

    if (pFcn == NULL)
    {
        hr = E_FAIL;
        goto LExit;
    }

    // Call the binding entrypoint
    hr = ((PCorBindToRuntimeByPath) pFcn)(pMDBlock->szCorPath, &fBindSuccess);
    _ASSERTE(fBindSuccess && SUCCEEDED(hr));

    // This should never happen
    if (!fBindSuccess)
        hr = E_FAIL;

    if (FAILED(hr))
        goto LExit;

    // Now get the GetRealProcAddress entrypoint
    pFcn = GetProcAddress(hEE, SHIM_GET_REAL_PROC_ADDR_ENTRYPOINT);

    if (pFcn == NULL)
    {
        hr = E_FAIL;
        goto LExit;
    }

    // Get the entrypoint through the shim indirection
    hr = ((PGetRealProcAddress) pFcn) (COR_CREATE_MINI_DUMP_ENTRYPOINT, (VOID **)&pFcn);

    if (FAILED(hr))
        goto LExit;

    // Call the final function pointer that points to the real mini dump creation function.
    hr = ((PCorCreateMiniDump) pFcn) (dwPid, szFilename);

LExit:
    if (ipcReader != NULL)
    {
        ipcReader->ClosePrivateBlock();
        delete ipcReader;
    }

    // Free the library
    if (hEE != NULL)
        FreeLibrary(hEE);

    // Return whether or not the write succeeded or failed
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\sort.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mscordmp.cpp
//
//*****************************************************************************
#include "common.h"

typedef unsigned __int16 UINT16;

#include <imagehlp.h>

int __cdecl cmp(const void *elem1, const void *elem2)
{
    MINIDUMP_MEMORY_DESCRIPTOR *desc1 = (MINIDUMP_MEMORY_DESCRIPTOR *)elem1;
    MINIDUMP_MEMORY_DESCRIPTOR *desc2 = (MINIDUMP_MEMORY_DESCRIPTOR *)elem2;

    if (desc1->StartOfMemoryRange <= desc2->StartOfMemoryRange)
        return (-1);
    else
        return (1);
}

BOOL SortMiniDumpMemoryStream(WCHAR *szFile)
{
    _ASSERTE(szFile != NULL);

    if (szFile == NULL)
        return (FALSE);

    // Try to open the file
    HANDLE hFile = WszCreateFile(szFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    _ASSERTE(hFile != INVALID_HANDLE_VALUE);

    if (hFile == INVALID_HANDLE_VALUE)
        return (FALSE);

    // Now read in the header
    MINIDUMP_HEADER header;
    DWORD cbRead;
    BOOL fRes = ReadFile(hFile, (LPVOID) &header, sizeof(header), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    // Create the stream directory
    MINIDUMP_DIRECTORY *rgDirs = new MINIDUMP_DIRECTORY[header.NumberOfStreams];
    _ASSERTE(rgDirs);

    if (!rgDirs)
        return (FALSE);

    // Read in the stream directory
    fRes = ReadFile(hFile, (LPVOID) rgDirs, header.NumberOfStreams * sizeof(MINIDUMP_DIRECTORY), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
    {
        delete [] rgDirs;
        return (FALSE);
    }

#ifdef _DEBUG
    // Find the MemoryListStream entry
    SIZE_T cMemStreams = 0;
    for (ULONG32 j = 0; j < header.NumberOfStreams; j++)
    {
        if (rgDirs[j].StreamType == MemoryListStream)
            cMemStreams++;
    }
    _ASSERTE(cMemStreams == 1);
#endif    

    // Find the MemoryListStream entry
    for (ULONG32 i = 0; i < header.NumberOfStreams; i++)
    {
        if (rgDirs[i].StreamType == MemoryListStream)
            break;
    }
    _ASSERTE(header.NumberOfStreams != i);

    // There was no memory stream entry
    if (header.NumberOfStreams == i)
    {
        delete [] rgDirs;
        return (FALSE);
    }

    RVA memStreamRVA = rgDirs[i].Location.Rva;
    delete [] rgDirs;
    rgDirs = NULL;

    // Go to the RVA of the memory stream
    DWORD dwRes = SetFilePointer(hFile, (LONG) memStreamRVA, NULL, FILE_BEGIN);
    _ASSERTE(dwRes == memStreamRVA);

    if (dwRes != memStreamRVA)
        return (FALSE);

    // Read in the number of ranges
    ULONG32 numRanges;
    fRes = ReadFile(hFile, (LPVOID) &numRanges, sizeof(ULONG32), &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
        return (FALSE);

    // Allocate an array of memory descriptors
    MINIDUMP_MEMORY_DESCRIPTOR *rgMemDescs = new MINIDUMP_MEMORY_DESCRIPTOR[numRanges];
    _ASSERTE(rgMemDescs != NULL);

    if (!rgMemDescs)
        return (FALSE);

    // Read in the memory descriptors
    fRes = ReadFile(hFile, (LPVOID) rgMemDescs, sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * numRanges, &cbRead, NULL);
    _ASSERTE(fRes);

    if (!fRes)
    {
        delete [] rgMemDescs;
        return (FALSE);
    }

    // Sort the memory descriptors
    qsort((void *)rgMemDescs, (unsigned) numRanges, (unsigned) sizeof(MINIDUMP_MEMORY_DESCRIPTOR), &cmp);

    // Go back to the beginning of the memory descriptors in the file
    dwRes = SetFilePointer(hFile, (LONG) (memStreamRVA + sizeof(ULONG32)), NULL, FILE_BEGIN);
    _ASSERTE(dwRes == memStreamRVA + sizeof(ULONG32));

    if (dwRes != memStreamRVA + sizeof(ULONG32))
    {
        delete [] rgMemDescs;
        return (FALSE);
    }

    // Overwrite the memory stream memory descriptors with the sorted version
    DWORD cbWritten;
    fRes = WriteFile(hFile, (LPCVOID) rgMemDescs, sizeof(MINIDUMP_MEMORY_DESCRIPTOR) * numRanges, &cbWritten, NULL);
    _ASSERTE(fRes);

    // Clean up
    delete [] rgMemDescs;
    rgMemDescs = NULL;

    if (!fRes)
        return (FALSE);

    fRes = FlushFileBuffers(hFile);

    if (!fRes)
        return (FALSE);

    fRes = CloseHandle(hFile);

    if (!fRes)
        return (FALSE);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\shell.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: shell.h
//
//*****************************************************************************

#pragma once

#include <windows.h>
#include <stdio.h>

class MiniDumpShell
{
protected:
    FILE *m_out;
    FILE *m_err;

protected:
    void CommonWrite(FILE *out, const WCHAR *buffer, va_list args);

public:
    enum DISPLAY_FILTER
    {
        displayNoLogo       = 0x00000001,
        displayHelp         = 0x00000002,

        displayDefault      = 0x00000000
    };

    MiniDumpShell() : m_out(stdout), m_err(stderr) {}

    void Write(const WCHAR *buffer, ...);
    void Error(const WCHAR *buffer, ...);
    void WriteLogo();
    void WriteUsage();
    bool GetIntArg(const WCHAR *szString, int *pResult);
    int  Main(int argc, WCHAR *argv[]);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\shell.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: shell.cpp
//
//*****************************************************************************

#include "common.h"

#include "shell.h"
#include "minidump.h"
#include "sort.h"
#include "dupelim.h"
#include "merge.h"


#define INIT_WRITE_BUF_SIZE 4096

//*****************************************************************************
// Common routine for writing text to the console
//*****************************************************************************
void MiniDumpShell::CommonWrite(FILE *out, const WCHAR *buffer, va_list args)
{
    BOOL fNeedToDeleteDB = FALSE;
    SIZE_T curBufSizeDB = INIT_WRITE_BUF_SIZE;
    WCHAR *szBufDB = (WCHAR *)_alloca(curBufSizeDB * sizeof(WCHAR));

    int cchWrittenDB = _vsnwprintf(szBufDB, INIT_WRITE_BUF_SIZE, buffer, args);

    if (cchWrittenDB == -1)
    {
        szBufDB = NULL;

        while (cchWrittenDB == -1)
        {
            delete [] szBufDB;
            szBufDB = new WCHAR[curBufSizeDB * 4];

            // Out of memory, nothing we can do
            if (!szBufDB)
                return;

            curBufSizeDB *= 4;
            fNeedToDeleteDB = TRUE;

            cchWrittenDB = _vsnwprintf(szBufDB, INIT_WRITE_BUF_SIZE, buffer, args);
        }
    }

    // Double check that we're null-terminated
    szBufDB[curBufSizeDB - 1] = L'\0';

    // Allocate buffer
    BOOL fNeedToDeleteMB = FALSE;
    SIZE_T curBufSizeMB = INIT_WRITE_BUF_SIZE;
    CHAR *szBufMB = (CHAR *) _alloca(curBufSizeMB * sizeof(CHAR));

    // Try the write
    int cchWrittenMB = WideCharToMultiByte(CP_ACP, 0, szBufDB, -1, szBufMB, curBufSizeMB-1, NULL, NULL);

    if (cchWrittenMB == 0)
    {
        // Figure out size required
        int cchReqMB = WideCharToMultiByte(CP_ACP, 0, szBufDB, -1, NULL, 0, NULL, NULL);
        _ASSERTE(cchReqMB > 0);

        // I don't think the +1 is necessary, but I'm doing it to make sure (WideCharToMultiByte is a bit
        // shady in whether or not it writes the null after the end of the buffer)
        szBufMB = new CHAR[cchReqMB+1];

        // Out of memory, nothing we can do
        if (!szBufDB)
        {
            if (fNeedToDeleteDB)
                delete [] szBufDB;

            return;
        }

        curBufSizeMB = cchReqMB;
        fNeedToDeleteMB = TRUE;

        // Try the write
        cchWrittenMB = WideCharToMultiByte(CP_ACP, 0, szBufDB, -1, szBufMB, curBufSizeMB, NULL, NULL);
        _ASSERTE(cchWrittenMB > 0);
    }

    // Finally, write it
    fputs(szBufMB, out);

    // Clean up
    if (fNeedToDeleteDB)
        delete [] szBufDB;

    if (fNeedToDeleteMB)
        delete [] szBufMB;
}

//*****************************************************************************
// Writes a message to the console in the printf style
//*****************************************************************************
void MiniDumpShell::Write(const WCHAR *buffer, ...)
{
    va_list     args;

    va_start(args, buffer);

    CommonWrite(m_out, buffer, args);

    va_end(args);
}

//*****************************************************************************
// Writes an error message to the console in the printf style
//*****************************************************************************
void MiniDumpShell::Error(const WCHAR *buffer, ...)
{
    va_list     args;

    va_start(args, buffer);

    CommonWrite(m_err, buffer, args);

    va_end(args);
}

//*****************************************************************************
// Writes the logo to the console
//*****************************************************************************
void MiniDumpShell::WriteLogo()
{
	Write(L"\nMicrosoft (R) Common Language Runtime Minidump Utility.   Version %S\n", VER_FILEVERSION_STR);
    Write(VER_LEGALCOPYRIGHT_DOS_STR);
    Write(L"\n\n");
}

//*****************************************************************************
// Writes the argument descriptions to the console
//*****************************************************************************
void MiniDumpShell::WriteUsage()
{
    Write(L"mscordmp [options] /pid <process id> /out <output file>\n");
    Write(L"\n");
    Write(L"Options:\n");
    Write(L"    /nologo : do not display logo.\n");
#if 0
    // This isn't quite working yet, so don't display it in the help options
    Write(L"    /merge  : <minidump> <managed dump> <out file>\n");
    Write(L"              merges a native minidump file with a managed dump file.\n");
    Write(L"    /fixup  : (DEBUG ONLY) takes a minidump as argument and fixes\n");
    Write(L"              it's memory stream after a merge has taken place.\n");
    Write(L"              all other arguments are ignored.\n");
#endif
    Write(L"\n");
    Write(L"Arguments:\n");
    Write(L"    /pid  : the ID of the process on which to perfrom the minidump.\n");
    Write(L"    /out  : the full path and name of the file to write the minidump to.\n");
    Write(L"    /h /? : this help message.\n");
#ifdef _DEBUG
    Write(L"    /av   : (DEBUG ONLY) deliberately causes null dereference to show\n");
    Write(L"            that this tool can fail gracefully.\n");
#endif
    Write(L"\n");
    Write(L"This utility creates a file containing information supplemental to the\n");
    Write(L"standard minidump.  The additional information includes memory ranges\n");
    Write(L"useful in deciphering errors within the Common Language Runtime.\n");
}

//*****************************************************************************
// Parses the arguments, configures the minidump and executes it if possible
//*****************************************************************************
bool MiniDumpShell::GetIntArg(const WCHAR *szString, int *pResult)
{
    while(*szString && iswspace(*szString))
        szString++;

    *pResult = 0;

    if(szString[0] == L'0' && towlower(szString[1]) == L'x')
    {
        szString += 2;

        while(iswxdigit(*szString))
        {
            *pResult <<= 4;
            if(iswdigit(*szString))
                *pResult += *szString - L'0';
            else
                *pResult += 10 + towlower(*szString) - L'a';

            szString++;
        }

        return(true);
    }
    else if(iswdigit(*szString))
    {
        while(iswdigit(*szString))
        {
            *pResult *= 10;
            *pResult += *szString++ - L'0';
        }

        return(true);
    }
    else
        return(false);
}

//*****************************************************************************
// Parses the arguments, configures the minidump and executes it if possible
//*****************************************************************************
int MiniDumpShell::Main(int argc, WCHAR *argv[])
{
    HRESULT hr          = S_OK;
    DWORD  dwPid        = 0;
    WCHAR *szFilename   = NULL;

    __try
    {
        BOOL  fInvalidArg     = FALSE;
        ULONG ulDisplayFilter = displayDefault;

        // Look for /nologo switch
        for (int i = 1;  i < argc;  i++)
        {
            const WCHAR *szArg = argv[i];

            if (*szArg == L'-' || *szArg == L'/')
            {
                if (_wcsicmp(szArg + 1, L"nologo") == 0)
                    ulDisplayFilter |= displayNoLogo;
            }
        }

        // Print the logo unless specifically asked not to
        if (!(ulDisplayFilter & displayNoLogo))
            WriteLogo();

        // Validate incoming arguments
        for (i = 1;  i < argc && !fInvalidArg;  i++)
        {
            const WCHAR *szArg = argv[i];

            if (*szArg == L'-' || *szArg == L'/')
            {
                if (_wcsicmp(szArg + 1, L"?") == 0 || _wcsicmp(szArg + 1, L"h") == 0)
                    ulDisplayFilter |= displayHelp;

                // Argument that specifies where the minidump should be written
                else if (_wcsicmp(szArg + 1, L"out") == 0)
                {
                    // Make sure there's an argument for the /out switch
                    if (++i < argc && argv[i][0] != L'/')
                        szFilename = argv[i];

                    // No argument to the /out switch
                    else
                    {
                        Error(L"Error: must provide file name argument to /out switch.\n");
                        fInvalidArg = TRUE;
                    }
                }

                // Argument that specifies the process to perform the minidump on.
                else if (_wcsicmp(szArg + 1, L"pid") == 0)
                {
                    // Make sure there's an argument for the /pid switch
                    if (++i < argc)
                    {
                        // Get the process id argument
                        if (!GetIntArg(argv[i], (int *)&dwPid))
                        {
                            Error(L"Error: invalid process id %s.\n", argv[i]);
                            fInvalidArg = TRUE;
                        }
                    }

                    // No argument to the /p switch
                    else
                    {
                        Error(L"Error: must provide process identifier argument to /p switch.\n");
                        fInvalidArg = TRUE;
                    }
                }

#ifdef _DEBUG
                // This is a testing switch that causes an AV to show we can gracefully fail
                else if (_wcsicmp(szArg + 1, L"av") == 0)
                {
                    *((int *)NULL) = 0;
                }
#endif
#if 0
                // If they are using the fixup switch, fixup the minidump's memory stream
                else if (_wcsicmp(szArg + 1, L"fixup") == 0)
                {
                    if (++i < argc && argv[i][0] != L'/' && argv[i][0] != L'-')
                    {
                        Write(L"Fixing memory stream for minidump file: %s\n", argv[i]);
                        BOOL fRes = SortMiniDumpMemoryStream(argv[i]);

                        if (!fRes)
                        {
                            Error(L"Error: could not open or sort file: %s\n", argv[i]);
                            fInvalidArg = TRUE;
                        }

                        fRes = EliminateOverlaps(argv[i]);

                        if (!fRes)
                        {
                            Error(L"Error: could not open or fixup file: %s\n", argv[i]);
                            fInvalidArg = TRUE;
                        }

                        return (!fRes);
                    }

                    else
                    {
                        Error(L"Error: must provide filename argument to /fixup switch.\n");
                        fInvalidArg = TRUE;
                    }
                }
#endif // 0
                // Look for /nologo switch - this was already searched for earlier, so just skip it
                else if (_wcsicmp(szArg + 1, L"nologo") == 0)
                {
                }
#if 0
                else if (_wcsicmp(szArg + 1, L"merge") == 0)
                {
                    i += 3;
                    // Make sure there's an argument for the /pid switch
                    if (i < argc)
                    {
                        BOOL fRes = MergeMiniDump(argv[i-2], argv[i-1], argv[i]);

                        if (!fRes)
                        {
                            Error(L"Error: merge failed.\n", argv[i]);
                            fInvalidArg = TRUE;
                        }

                        return (!fRes);
                    }
                    else
                    {
                        // Get the process id argument
                        if (!GetIntArg(argv[i], (int *)&dwPid))
                        {
                            Error(L"Error: invalid number of arguments to /merge command.\n", argv[i]);
                            fInvalidArg = TRUE;
                        }
                    }
                }
#endif // 0

                // Unrecognized switch
                else
                {
                    Error(L"Error: unrecognized switch %s.\n", argv[i]);
                    fInvalidArg = TRUE;
                }
            }

            // Non-switch argument
            else
                fInvalidArg = TRUE;
        }

        // If '/?' switch or no arguments whatsoever provided, display help
        if ((ulDisplayFilter & displayHelp) || argc == 1)
        {
            WriteUsage();
            return (0);
        }

        // If there was a bad argument, bail
        if (fInvalidArg)
            return (1);

        Write(L"Minidump of process 0x%08x in progress.\n", dwPid);

        // Perform minidump operation
        hr = MiniDump::WriteMiniDump(dwPid, szFilename);
    }

    // This will eat any exceptions and gracefully fail
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        Write(L"Minidump succeeded.\n");
    }
    else
    {
        Error(L"Minidump failed.\n");
    }

    // Return the negation of SUCCEEDED because a 0 exit value for a process means success
    return (!SUCCEEDED(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "MSCORDMP.EXE\0"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Managed Minidump Utility.\0"
#define VER_ORIGFILENAME_STR    "mscordmp.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\sort.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mscorsrt.h
//
//*****************************************************************************

#pragma once

BOOL SortMiniDumpMemoryStream(WCHAR *szFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\vs\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: mscordmp.cpp
//
//*****************************************************************************
#include "common.h"

#include <windows.h>
#include "minidump.h"

extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    DWORD procId = 0;
    WCHAR *fileName = L"foo";
    HRESULT hr = CreateManagedMiniDump(GetCurrentProcessId(), fileName);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\vs\common.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: common.h
//
//*****************************************************************************

#pragma once

#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <crtdbg.h>
#include <malloc.h>
#include "__file__.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\vs\minidump.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: minidump.h
//
//*****************************************************************************

#pragma once

STDAPI CreateManagedMiniDump(IN DWORD dwPid, IN WCHAR *wszOutFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\vs\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "MSCORDMP.EXE\0"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Managed Minidump Utility.\0"
#define VER_ORIGFILENAME_STR    "mscordmp.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\mscordmp\vs\minidump.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: minidump.cpp
//
//*****************************************************************************

#include "common.h"
#include "minidump.h"

#define FRAMEWORK_REGISTRY_KEY          "Software\\Microsoft\\.NETFramework"
#define FRAMEWORK_REGISTRY_KEY_W        L"Software\\Microsoft\\.NETFramework"

#define DMP_NAME_W                      L"bin\\mscordmp.exe"

//*****************************************************************************
// Creates an ANSI string from any Unicode string.
//*****************************************************************************
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (long)((wcslen(widestr) + 1) * 2 * sizeof(char)); \
    LPSTR ptrname = (LPSTR) _alloca(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, ptrname, __l##ptrname-1, NULL, NULL)

#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname; \
    LPWSTR ptrname; \
    __l##ptrname = MultiByteToWideChar(CP_ACP, 0, ansistr, -1, 0, 0); \
    ptrname = (LPWSTR) alloca(__l##ptrname*sizeof(WCHAR));  \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, ptrname, __l##ptrname);

//*****************************************************************************
// Enum to track which version of the OS we are running
//*****************************************************************************
typedef enum {
    RUNNING_ON_STATUS_UNINITED = 0,
    RUNNING_ON_WIN95,
    RUNNING_ON_WINNT,
    RUNNING_ON_WINNT5
} RunningOnStatusEnum;

RunningOnStatusEnum gRunningOnStatus = RUNNING_ON_STATUS_UNINITED;

//*****************************************************************************
// One time initialization of the OS version
//*****************************************************************************
static void InitRunningOnVersionStatus ()
{
        OSVERSIONINFOA  sVer;
        sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        GetVersionExA(&sVer);

        if (sVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
            gRunningOnStatus = RUNNING_ON_WIN95;
        if (sVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            if (sVer.dwMajorVersion >= 5)
                gRunningOnStatus = RUNNING_ON_WINNT5;
            else
                gRunningOnStatus = RUNNING_ON_WINNT;
        }
}

//*****************************************************************************
// Returns TRUE if and only if you are running on Win95.
//*****************************************************************************
inline BOOL RunningOnWin95()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return (gRunningOnStatus == RUNNING_ON_WIN95) ? TRUE : FALSE;
}

//*****************************************************************************
// Returns TRUE if and only if you are running on WinNT.
//*****************************************************************************
inline BOOL RunningOnWinNT()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return ((gRunningOnStatus == RUNNING_ON_WINNT) || (gRunningOnStatus == RUNNING_ON_WINNT5)) ? TRUE : FALSE;
}

//*****************************************************************************
// Returns TRUE if and only if you are running on WinNT5.
//*****************************************************************************
inline BOOL RunningOnWinNT5()
{
    if (gRunningOnStatus == RUNNING_ON_STATUS_UNINITED)
    {
        InitRunningOnVersionStatus();
    }

    return (gRunningOnStatus == RUNNING_ON_WINNT5) ? TRUE : FALSE;
}

//*****************************************************************************
// The first portion of the header of the IPC block
//*****************************************************************************
struct IPCBlockHeader
{
    DWORD m_version;
    DWORD m_blockSize;
};

//*****************************************************************************
//
//*****************************************************************************
class MiniDump
{
protected:
    DWORD           m_pid;
    HANDLE          m_hPrivateBlock;
    IPCBlockHeader *m_ptrPrivateBlock;
    WCHAR          *m_outFilename;

public:
    // Constructor
    MiniDump() : m_pid(0), m_hPrivateBlock(NULL), m_ptrPrivateBlock(NULL),
                 m_outFilename(NULL) {}

    // Sets the process id that the minidump is supposed to be operating on
    void  SetProcessId(DWORD pid) { m_pid = pid; }

    // Gets the process id that the minidump is supposed to be operating on
    DWORD GetProcessId() { return (m_pid); }

    // Sets the minidump output filename
    WCHAR *GetFilename() { return (m_outFilename); }

    // Sets the minidump output filename
    void SetFilename(WCHAR *szFilename) { m_outFilename = szFilename; }

    // Perform the dump operation
    HRESULT WriteMiniDump();
};

// This relies on ret being of length MAX_PATH + 1
BOOL GetConfigString(LPCWSTR name, LPWSTR ret)
{
    HRESULT lResult;
    HKEY userKey = NULL;
    HKEY machineKey = NULL;
    DWORD type;
    DWORD size;
    BOOL succ = FALSE;
    ret[0] = L'\0';

    if (RunningOnWin95())
    {
        MAKE_ANSIPTR_FROMWIDE(nameA, name);

        if ((RegOpenKeyExA(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY, 0, KEY_READ, &userKey) == ERROR_SUCCESS) &&
            (RegQueryValueExA(userKey, nameA, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ && size > 1) 
        {
            LPSTR retA = (LPSTR) _alloca(size + 1);
            lResult = RegQueryValueExA(userKey, nameA, 0, 0, (LPBYTE) retA, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            MAKE_WIDEPTR_FROMANSI(retW, retA);
            wcscpy(ret, retW);
            succ = TRUE;
        }

        else if ((RegOpenKeyExA(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY, 0, KEY_READ, &machineKey) == ERROR_SUCCESS) &&
            (RegQueryValueExA(machineKey, nameA, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ && size > 1) 
        {
            LPSTR retA = (LPSTR) _alloca(size + 1);
            lResult = RegQueryValueExA(machineKey, nameA, 0, 0, (LPBYTE) retA, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            MAKE_WIDEPTR_FROMANSI(retW, retA);
            wcscpy(ret, retW);
            succ = TRUE;
        }
    }
    else
    {
        if ((RegOpenKeyExW(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &userKey) == ERROR_SUCCESS) &&
            (RegQueryValueExW(userKey, name, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ && size > 1) 
        {
            lResult = RegQueryValueExW(userKey, name, 0, 0, (LPBYTE) ret, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            succ = TRUE;
        }

        else if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &machineKey) == ERROR_SUCCESS) &&
            (RegQueryValueExW(machineKey, name, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ && size > 1) 
        {
            lResult = RegQueryValueExW(machineKey, name, 0, 0, (LPBYTE) ret, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            succ = TRUE;
        }
    }

    if (userKey)
        RegCloseKey(userKey);
    if (machineKey)
        RegCloseKey(machineKey);

    return(succ);
}

//*****************************************************************************
// Writes the minidump
//*****************************************************************************

HRESULT MiniDump::WriteMiniDump()
{
    HRESULT hr = S_OK;

    __try
    {
        // Check for immediate failure conditions
        if (m_outFilename == NULL || m_pid == 0 || m_pid == (DWORD) -1)
            return (E_FAIL);

        LPWSTR szDmpLoc = (LPWSTR) _alloca((MAX_PATH + 1) * sizeof(WCHAR));

        // Get the location of mscordmp.exe
        if (!GetConfigString(L"sdkInstallRoot", szDmpLoc))
            return (E_FAIL);

        wcscat(szDmpLoc, DMP_NAME_W);

        // Create the command line arguments
        // command line format: "path_to_mscordmp /pid 0x12345678 /out path_to_outfile\0"
        WCHAR *commandLine =
            (WCHAR *) _alloca((wcslen(szDmpLoc) + 1 + 4 + 1 + 10 + 1 + 3 + 1 + wcslen(m_outFilename) + 1) * sizeof(WCHAR));

        // A pid will have the form "0x12345678" which is 10 chars (11 including null)
        WCHAR *pid = (WCHAR *) _alloca(10 * sizeof(WCHAR) + 1);
        wsprintf(pid, L"0x%08x", m_pid);

        // Put command line arguments together
        wcscpy(commandLine, szDmpLoc);
        wcscat(commandLine, L" /pid ");
        wcscat(commandLine, pid);
        wcscat(commandLine, L" /out ");
        wcscat(commandLine, m_outFilename);

        PROCESS_INFORMATION procInfo;
        BOOL                procSucc;

        // Now try and launch the process, depending on whether we are on 9x or NT
        if (RunningOnWin95())
        {
            STARTUPINFOA         startInfo = {0};
            startInfo.cb = sizeof(STARTUPINFOA);
            MAKE_ANSIPTR_FROMWIDE(ansiDmpLoc, szDmpLoc);
            MAKE_ANSIPTR_FROMWIDE(ansiCommandLine, commandLine);

            procSucc = CreateProcessA(ansiDmpLoc, ansiCommandLine, NULL, NULL, FALSE,
                                      NORMAL_PRIORITY_CLASS, NULL, NULL, &startInfo, &procInfo);
        }
        else
        {
            STARTUPINFOW         startInfo = {0};
            startInfo.cb = sizeof(STARTUPINFOW);
            procSucc = CreateProcessW(szDmpLoc, commandLine, NULL, NULL, FALSE,
                                      NORMAL_PRIORITY_CLASS, NULL, NULL, &startInfo, &procInfo);
        }

        // Couldn't create the process!
        if (!procSucc)
            return (E_FAIL);

        // Wait for the process to finish, waiting a max of 3 seconds
        DWORD dwRes = WaitForSingleObject(procInfo.hProcess, 3000);

        // Check the result
        if (dwRes == WAIT_OBJECT_0)
        {
            DWORD dwExitCode;
            BOOL bSucc = GetExitCodeProcess(procInfo.hProcess, &dwExitCode);

            // If the process didn't complete the minidump successfully
            if (!bSucc || dwExitCode != 0)
                hr = (E_FAIL);
        }
        else if (dwRes == WAIT_TIMEOUT)
        {
            hr = E_FAIL;

            // Kill the process
            TerminateProcess(procInfo.hProcess, 1);
        }

        // Close the handles
        CloseHandle(procInfo.hProcess);
        CloseHandle(procInfo.hThread);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        // Do nothing but set the HR to a failure value
        hr = E_FAIL;
    }

    // If succeeded, always return S_OK to avoid confusion
    if (SUCCEEDED(hr))
        hr = S_OK;

    return (hr);
}

//*****************************************************************************
//
//*****************************************************************************
STDAPI CreateManagedMiniDump(IN DWORD dwPid, IN WCHAR *wszOutFile)
{
    HRESULT hr;

    __try
    {
        if (dwPid == 0 || dwPid == (DWORD) -1 || wszOutFile == NULL)
            return (E_INVALIDARG);

        MiniDump md;

        // Set the variables in the object
        md.SetProcessId(dwPid);
        md.SetFilename(wszOutFile);

        // Create the minidump
        hr = md.WriteMiniDump();
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_FAIL;
    }

    // Return the result
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ngen\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "ngen.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime native compiler\0"
#define VER_ORIGFILENAME_STR    "ngen.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ngen\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop
#include "ShimLoad.h"

ExternC PfnDliHook __pfnDliNotifyHook = ShimSafeModeDelayLoadHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\ngen\ngen.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <WinWrap.h>
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>
#include <locale.h>

#include "utilcode.h"
#include "corhlpr.cpp"
#include "corjit.h"
#include "corcompile.h"
#include "iceefilegen.h"

#include "zapper.h"
#include "nlog.h"

#include "corver.h"
#include "__file__.ver"

#include "CorZap.h"
#include "mscoree.h"
/* --------------------------------------------------------------------------- *
 * DelayLoad.cpp stuff
 * --------------------------------------------------------------------------- */

#include "ngen.h"
#include "shimload.h"
ExternC PfnDliHook __pfnDliNotifyHook = ShimSafeModeDelayLoadHook;


/* --------------------------------------------------------------------------- *
 * Options class
 * --------------------------------------------------------------------------- */

class NGenOptionsParser
{
  public:
    LPCWSTR     *m_inputs;
    SIZE_T      m_inputCount;
    SIZE_T      m_inputAlloc;

    bool        m_show;
    bool        m_delete;
    bool        m_logo;

    bool        m_debug;    
    bool        m_debugOpt;    
    bool        m_prof;    

    bool        m_silent;
    bool        m_showVersion;
    
    NGenOptionsParser();
    ~NGenOptionsParser();
    HRESULT ReadCommandLine(int argc, LPCWSTR argv[]);
    void PrintLogo();
    void PrintUsage();
    NGenOptions GetNGenOptions();
};

NGenOptionsParser::NGenOptionsParser()
  : m_inputs(NULL),
    m_inputCount(0),
    m_inputAlloc(0),
    m_show(false),
    m_delete(false),
    m_logo(true),
    m_debug(false),
    m_debugOpt(false),
    m_prof(false),
    m_showVersion(false)
{
    m_silent = false;
}

NGenOptionsParser::~NGenOptionsParser()
{
    delete [] m_inputs;
}


HRESULT NGenOptionsParser::ReadCommandLine(int argc, LPCWSTR argv[])
{
    HRESULT hr = S_OK;

    if (argc == 0)
        return S_FALSE;

    while (argc-- > 0)
    {
        const WCHAR *arg = *argv++;

        if (*arg == '-' || *arg == '/')
        {
            arg++;
            switch (tolower(*arg++))
            {
            case '?':
                return S_FALSE;

            case 'd':
                if (_wcsicmp(&arg[-1], L"debug") == 0)
                {
                    m_debug = true;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"debugopt") == 0)
                {
                    m_debugOpt = true;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"delete") == 0)
                {
                    m_delete = true;
                    continue;
                }
     
                goto option_error;

            case 'h':
                if (_wcsicmp(&arg[-1], L"help") == 0) 
                    return S_FALSE;
                goto option_error;

            case 'n':
                if (_wcsicmp(&arg[-1], L"nologo") == 0)
                {
                    m_logo = false;
                    continue;
                }
                goto option_error;

            case 'p':
                if (_wcsicmp(&arg[-1], L"prof") == 0)
                {
                    m_prof = true;
                    continue;
                }
                goto option_error;

            case 's':
                if (_wcsicmp(&arg[-1], L"show") == 0) 
                {
                    m_show = true;
                    continue;
                } 
                else
                if (_wcsicmp(&arg[-1], L"silent") == 0) 
                {
                    m_silent = true;
                    continue;
                } 
                else
                if (_wcsicmp(&arg[-1], L"showversion") == 0) 
                {
                    m_showVersion = true;
                    continue;
                } 

                goto option_error;

            default:
                goto option_error;
            }
                
            if (*arg != 0)
            {
            option_error:
                PrintLogo();
                printf("\nError: Unrecognized option %S\n", argv[-1]);
                hr = E_FAIL;
            }
        }
        else
        {
            if (m_inputCount == m_inputAlloc)
            {
                if (m_inputCount == 0)
                    m_inputAlloc = 5;
                else
                    m_inputAlloc *= 2;

                WCHAR **newInputs = new WCHAR * [m_inputAlloc];
                if (newInputs == NULL)
                    return E_OUTOFMEMORY;

                memcpy(newInputs, m_inputs, 
                       m_inputCount * sizeof(WCHAR *));

                delete [] m_inputs;                 
                m_inputs = (const WCHAR **) newInputs;
            }
            m_inputs[m_inputCount++] = arg;
        }
    }
    
    // Check parameters are valid
    char* pErrorMessage = NULL;
    
    if ((m_inputCount == 0) && !m_show && !m_delete)
    {
        pErrorMessage = "\nError: Must specify at least one assembly to compile.\n";
        hr = E_FAIL;
    }

    if ((m_inputCount == 0) && m_delete)
    {
        pErrorMessage = "\nError: Must specify at least one assembly to delete.\n";
        hr = E_FAIL;
    }

    if (m_debug && m_debugOpt)
    {
        pErrorMessage = "\nError: Cannot specify both /debug and /debugopt.\n";
        hr = E_FAIL;
    }

    if (pErrorMessage != NULL)
    {
        PrintLogo();
        printf("%s", pErrorMessage);
    }
    
    return hr;
}

void NGenOptionsParser::PrintLogo()
{
    if (m_logo && !m_silent)
    {
        printf("Microsoft (R) CLR Native Image Generator - Version " VER_FILEVERSION_STR);
        printf("\nCopyright (C) Microsoft Corporation 1998-2002. All rights reserved.");
        printf("\n");
        m_logo = false;
    }
}

void NGenOptionsParser::PrintUsage()
{
    printf("\nUsage: ngen [options] <assembly path or display name> ...\n"
           "\n"
           "    Administrative options:\n"
           "        /show           Show existing native images (show all if no args)\n"
           "        /delete         Delete an existing native image (use * to delete all)\n"
           "        /showversion    Displays the version of the runtime that would be used\n"
           "                        to generate the image (it does not actually create the\n"
           "                        image)\n"
           "\n"
           "    Developer options:\n"
           "        /debug          Generate image which can be used under a debugger\n"
           "        /debugopt       Generate image which can be used under\n"
           "                        a debugger in optimized debugging mode\n"
           "        /prof           Generate image which can be used under a profiler\n"
           "\n"
           "    Miscellaneous options:\n"
           "        /? or /help     Show this message\n"
           "        /nologo         Prevents displaying of logo\n"
           "        /silent         Prevents displaying of success messages\n"
           "\n"
           );
}

NGenOptions NGenOptionsParser::GetNGenOptions()
{
    NGenOptions ngo;
    ngo.dwSize = sizeof(NGenOptions);
    ngo.fDebug = this->m_debug;    
    ngo.fDebugOpt = this->m_debugOpt;    
    ngo.fProf = this->m_prof;    
    ngo.fSilent = this->m_silent;
    ngo.lpszExecutableFileName = NULL;
    return ngo;
}// GetNGenOptions
/* --------------------------------------------------------------------------- *
 * main routine
 * --------------------------------------------------------------------------- */

#define FAILURE_RESULT -1

int trymain(int argc, LPCWSTR argv[])
{
    HRESULT hr;

    OnUnicodeSystem();

    NGenOptionsParser opt;

    hr = opt.ReadCommandLine(argc-1, argv+1);

    opt.PrintLogo();

    if (hr != S_OK)
    {
        opt.PrintUsage();
        if (FAILED(hr))
            exit(FAILURE_RESULT);
        else
            exit(0);
    }

    //
    // Now, create zapper using these interfaces
    //

    WCHAR wszVersion[64];
    DWORD dwLen = 0;
    int result = 0;
    BOOL fFoundRuntime = FALSE;
    LPCWSTR lpszExeName = NULL;

    // Check for exes...
    // If we do have an exe, then prejit with the version of the runtime that the
    // exe will run under
    for(DWORD i=0; i< opt.m_inputCount; i++)
    {
        int nLen = wcslen(opt.m_inputs[i]);
        if (nLen > 4)
        {
            LPCWSTR pExtension = opt.m_inputs[i] + nLen - 4;
            if (!_wcsicmp(pExtension, L".exe"))
            {
                hr = GetRequestedRuntimeVersion((LPWSTR)opt.m_inputs[i], wszVersion, 63, &dwLen);
                // We were able to get a good version of the runtime
                if (SUCCEEDED(hr))
                {
                    lpszExeName = opt.m_inputs[i];
                    fFoundRuntime = TRUE;
                    wcscpy(g_wszDelayLoadVersion, wszVersion);
                    break;
                }
            }
        }
            
        
    }

    if (!fFoundRuntime)
    {
        // We don't have an EXE, so we'll just prejit with the version of the runtime
        // that corresponds to this version of ngen
        swprintf(wszVersion, L"v%d.%d.%d", COR_BUILD_YEAR, COR_BUILD_MONTH, CLR_BUILD_VERSION );
    }

    if (opt.m_showVersion)
    {
        printf("Version %S of the runtime would be used to generate this image.\n", wszVersion);
        exit(0);
    }

    // Should we check to see if this fails, or just handle the failure when we can't
    // find any of the entry points in the runtime?
    CorBindToRuntimeEx(wszVersion,NULL,STARTUP_LOADER_SETPREFERENCE|STARTUP_LOADER_SAFEMODE,IID_NULL,IID_NULL,NULL);

    // Try to grab the Zap functions out of the runtime
    PNGenCreateZapper pfnCreateZapper = NULL;
    PNGenTryEnumerateFusionCache pfnEnumerateCache = NULL;
    PNGenCompile pfnCompile = NULL;
    PNGenFreeZapper pfnFreeZapper = NULL;
        
    hr = GetRealProcAddress("NGenCreateZapper", (void**)&pfnCreateZapper);

    // If the first one succeeded, hopefully the rest will succeed too
    if (SUCCEEDED(hr))
    {
        GetRealProcAddress("NGenTryEnumerateFusionCache", (void**)&pfnEnumerateCache);
        GetRealProcAddress("NGenCompile", (void**)&pfnCompile);
        GetRealProcAddress("NGenFreeZapper", (void**)&pfnFreeZapper);
    }
    // If any of these are NULL, then we'll need to do something special...
    if (pfnCreateZapper == NULL || pfnEnumerateCache == NULL ||
        pfnCompile == NULL || pfnFreeZapper == NULL)
    {
        // Only try spinning up another version of the runtime if missing methods was our problem
        if (hr == CLR_E_SHIM_RUNTIMEEXPORT)
        {
            // If this happens, then we've bound to v1 of the runtime. If that's the
            // case, let's spin up the v1 version of ngen and go from there.

            // First, we need to find it.
            WCHAR pPath[MAX_PATH+1];
            DWORD dwLen = 0;
            hr = GetCORSystemDirectory(pPath, MAX_PATH, &dwLen);
            if (SUCCEEDED(hr))
            {
                LPWSTR commandLineArgs = NULL;

                // Figure the length of all these
                // Construct the exe name + command line
                int nLen = wcslen(pPath) + wcslen(L"ngen.exe");

                // We'll start off with a length of the number of args -1 in order
                // to count for spaces....
                //
                // like...
                // ngen a b c
                // 4 arguments, and we need to have room for 3 spaces
                nLen += argc - 1;
                // Count the length of each argument (make sure we skip the first one)
                for(int i=1; i<argc; i++)
                    nLen += wcslen(argv[i]);

                // We'll also be adding the '/nologo' option when we spin up the 
                // new version of negen.
                nLen+=wcslen(L" /nologo");
            
                commandLineArgs = new WCHAR[nLen+1];
                if (commandLineArgs == NULL)
                    hr = E_OUTOFMEMORY;
                else
                {
                    swprintf(commandLineArgs, L"%s%s /nologo", pPath, L"ngen.exe");

                    int nOffset = wcslen(commandLineArgs);

                    // Don't include the first one (the exe name)
                    for(int i=1; i<argc; i++)
                    {
                        wcscpy(commandLineArgs + nOffset, L" ");
                        nOffset++;
                        wcscpy(commandLineArgs + nOffset, argv[i]);
                        nOffset += wcslen(argv[i]);
                    }
                }
                if (commandLineArgs != NULL)
                {
                    STARTUPINFO sui;
                    PROCESS_INFORMATION pi;
                    memset(&sui, 0, sizeof(STARTUPINFO));
                    sui.cb = sizeof(STARTUPINFO);
                    BOOL res = WszCreateProcess(NULL,
                                                commandLineArgs,
                                                NULL,
                                                NULL,
                                                FALSE,
                                                0,
                                                NULL,
                                                NULL,
                                                &sui,
                                                &pi);

                    if (res == 0)
                        hr = E_FAIL;
                    else
                    {
                        // We need to wait for this process to die before we die,
                        // otherwise the console window likes to pause.
                        WaitForSingleObject(pi.hProcess, INFINITE);
                        CloseHandle(pi.hProcess);
                        CloseHandle(pi.hThread);
                    }
                
                    delete commandLineArgs;
                }
            }                         
        }
        if (FAILED(hr))
        {
            printf("Unable to launch a version of ngen to prejit this assembly.\n");
            // What should we do here? Allow it to get prejitted with the most recent
            // version of the runtime?
            result = FAILURE_RESULT;
        }
    }
    else
    {
        // Note, we need to keep the NGenOptionsParser around for some of
        // NGenOption's fields to be valid
        NGenOptions ngo = opt.GetNGenOptions();

        WCHAR   wszFullPath[MAX_PATH+1]; // Make sure this stays in the same scope as the Compile call

        // Make sure this filename is the full filename and not a partial path
        
        if (lpszExeName != NULL && *lpszExeName)
        {
            WCHAR *pszFileName = NULL;
        
            DWORD nRet = WszGetFullPathName(  lpszExeName, 
                                                                    NumItems(wszFullPath),
                                                                    wszFullPath,
                                                                    &pszFileName);

            if (nRet == 0 || nRet > NumItems(wszFullPath))                                                             
            {
                printf("Filename and path are too long.\n");
                return FAILURE_RESULT;
            }

            lpszExeName = wszFullPath;
        }

        ngo.lpszExecutableFileName = lpszExeName; 

        HANDLE hZapper = INVALID_HANDLE_VALUE;

        hr = pfnCreateZapper(&hZapper, &ngo);

        if (SUCCEEDED(hr) && hZapper != INVALID_HANDLE_VALUE && (opt.m_show || opt.m_delete))
        {
            BOOL found = FALSE;

            if (opt.m_inputCount == 0 || !wcscmp(opt.m_inputs[0], L"*"))
            {
                found = (pfnEnumerateCache(hZapper, 
                                           NULL, 
                                           opt.m_show || (!opt.m_silent && opt.m_delete), 
                                           opt.m_delete) == S_OK);
            }
            else
            {
                for (unsigned i = 0; i < opt.m_inputCount; i++)
                {
                    HRESULT hr = pfnEnumerateCache(hZapper,
                                                   opt.m_inputs[i], 
                                                   opt.m_show || (!opt.m_silent && opt.m_delete), 
                                                   opt.m_delete);
                    if (FAILED(hr))
                        printf("Error reading fusion cache for %S\n", opt.m_inputs[i]);
                    else if (hr == S_OK)
                        found = TRUE;
                }
            }

            if (!found)
            {
                printf("No matched entries in the cache.\n");
                result = FAILURE_RESULT;
            }
        }
        else 
        {
            for (unsigned i = 0; i < opt.m_inputCount; i++)
            {

                WCHAR*  pwszFileName = NULL;
                WCHAR   wszFullPath[MAX_PATH + 1];

                // Check to see if this is a file or an assembly
                DWORD attributes = WszGetFileAttributes(opt.m_inputs[i]);

                if (attributes != INVALID_FILE_ATTRIBUTES && ((attributes & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY))
                {

                    // This is an actual file.
                    DWORD nRet = WszGetFullPathName(opt.m_inputs[i], 
                                                                           NumItems(wszFullPath),
                                                                           wszFullPath,
                                                                           &pwszFileName);

                    if (nRet == 0 || nRet > NumItems(wszFullPath))                                                             
                    {
                        printf("Filename and path are too long.\n");
                        return FAILURE_RESULT;
                    }

                    pwszFileName = wszFullPath;
                }
                // This is an assembly... don't fix it up
                else
                {
                    pwszFileName = (WCHAR*)opt.m_inputs[i];
                }

            
                if (!pfnCompile(hZapper, pwszFileName))
                    result = FAILURE_RESULT;
            }
        }
    if (hZapper != INVALID_HANDLE_VALUE)
        pfnFreeZapper(hZapper);
    }
    return result;
}

int _cdecl wmain(int argc, LPCWSTR argv[])
{
    HRESULT hr;
    int result;

    __try
      {
          result = trymain(argc, argv);
      }
    __except(hr = (IsHRException(((EXCEPTION_POINTERS*)GetExceptionInformation())->ExceptionRecord) 
                   ? GetHRException(((EXCEPTION_POINTERS*)GetExceptionInformation())->ExceptionRecord)
                   : S_OK),
             EXCEPTION_EXECUTE_HANDLER)
      {
          WCHAR* buffer;

          // Get the string error from the HR
          DWORD res = FALSE;
          if (FAILED(hr))
              res = WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM 
                                     | FORMAT_MESSAGE_ALLOCATE_BUFFER
                                     | FORMAT_MESSAGE_IGNORE_INSERTS, 
                                     NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                                     (WCHAR *) &buffer, 0, NULL);

          if (res)
              wprintf(buffer);
          else
              printf("Unknown error occurred\n");

          result = hr;
      }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\callback.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "StdAfx.h"
#include "Profiler.h"
#include "ObjectGraph.h"

#define SZ_DEFAULT_LOG_FILE  L"PROFILER.OUT"

#define PREFIX "ProfTrace:  "

ProfCallback *g_Prof = NULL;

ProfCallback::ProfCallback() : m_pInfo(NULL)
{
	_ASSERTE(g_Prof == NULL);
	g_Prof = this;
}

ProfCallback::~ProfCallback()
{
	if (m_pInfo)
	{
		_ASSERTE(m_pInfo != NULL);
		RELEASE(m_pInfo);
	}
	g_Prof = NULL;

    Printf(PREFIX "Done.\n");
}

COM_METHOD ProfCallback::Initialize( 
    /* [in] */ ICorProfilerInfo *pProfilerInfo,
    /* [out] */ DWORD *pdwRequestedEvents)
{
    HRESULT hr = S_OK;

	Printf(PREFIX "Ininitialize(%08x, %08x)\n", pProfilerInfo, pdwRequestedEvents);

	m_pInfo = pProfilerInfo;
	m_pInfo->AddRef();

    // Just monitor GC events
    *pdwRequestedEvents = COR_PRF_MONITOR_GC;

    return (S_OK);
}

COM_METHOD ProfCallback::GCStarted()
{
    g_objectGraph.GCStarted();
    return S_OK;
}

COM_METHOD ProfCallback::GCFinished()
{
    g_objectGraph.GCFinished();
    return S_OK;
}

COM_METHOD ProfCallback::ObjectReferences(
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId,
    /* [in] */ ULONG cObjectRefs,
    /* [in, size_is(cObjectRefs)] */ ObjectID objectRefIds[])
{
	g_objectGraph.AddObjectRefs(objectId, classId, cObjectRefs, objectRefIds);
    return (S_OK);
}
                                              
// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\classfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ClassFactory.cpp
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#include "stdafx.h"
#include "ClassFactory.h"


/***************************************************************************************
 ********************                                               ********************
 ********************          CClassFactory Implementation         ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
 /* private */
CClassFactory::CClassFactory()
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit CClassFactory::CClassFactory" )

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
CClassFactory::CClassFactory( const COCLASS_REGISTER *pCoClass ) :
	m_refCount( 1 ),
    m_pCoClass( pCoClass )
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit CClassFactory::CClassFactory" )

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
CClassFactory::~CClassFactory()
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit CClassFactory::~CClassFactory" )

} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ULONG CClassFactory::AddRef()
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit CClassFactory::AddRef" )


  	return InterlockedIncrement( &m_refCount );

} // CClassFactory::AddRef


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
ULONG CClassFactory::Release()
{
	TRACE_NON_CALLBACK_METHOD( "Enter CClassFactory::Release" )

	long refCount;


    refCount = InterlockedDecrement( &m_refCount );
    if ( refCount == 0 )
	    delete this;


	TRACE_NON_CALLBACK_METHOD( "Exit CClassFactory::Release" )


	return refCount;

} // CClassFactory::Release


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT CClassFactory::QueryInterface( REFIID riid, void **ppInterface )
{
	TRACE_NON_CALLBACK_METHOD( "Enter CClassFactory::QueryInterface" )

    if ( riid == IID_IUnknown )
        *ppInterface = static_cast<IUnknown *>( this );

    else if ( riid == IID_IClassFactory )
        *ppInterface = static_cast<IClassFactory *>( this );

    else
    {
        *ppInterface = NULL;
		TRACE_NON_CALLBACK_METHOD( "Exit CClassFactory::QueryInterface" )


        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown *>( *ppInterface )->AddRef();
    TRACE_NON_CALLBACK_METHOD( "Exit CClassFactory::QueryInterface" )


    return S_OK;

} // CClassFactory::QueryInterface


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT CClassFactory::CreateInstance( IUnknown	*pUnkOuter,	REFIID riid, void **ppInstance )
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit CClassFactory::CreateInstance" )

	// aggregation is not supported by these objects
	if ( pUnkOuter != NULL )
		return CLASS_E_NOAGGREGATION;


	// ask the object to create an instance of itself, and check the iid.
	return (*m_pCoClass->pfnCreateObject)( riid, ppInstance );

} // CClassFactory::CreateInstance


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT CClassFactory::LockServer( BOOL fLock )
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit CClassFactory::LockServer" )


	return S_OK;

} // CClassFactory::LockServer


/***************************************************************************************
 ********************                                               ********************
 ********************            Dll Registration Helpers           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI DllRegisterServer()
{
	printf("in RegisterServer\n");
	TRACE_NON_CALLBACK_METHOD( "Enter DllRegisterServer" )

	HRESULT hr = S_OK;
	char  rcModule[_MAX_PATH];
    const COCLASS_REGISTER *pCoClass;


	DllUnregisterServer();
	GetModuleFileNameA( GetModuleInst(), rcModule, NumItems( rcModule ) );

	// for each item in the coclass list, register it
	for ( pCoClass = g_CoClasses; (SUCCEEDED( hr ) && (pCoClass->pClsid != NULL)); pCoClass++ )
	{
		// register the class with default values
       	hr = REGUTIL::RegisterCOMClass( *pCoClass->pClsid,
									    g_szCoclassDesc,
										g_szProgIDPrefix,
										g_iVersion,
										pCoClass->szProgID,
										g_szThreadingModel,
										rcModule );
	} // for


	if ( FAILED( hr ) )
		DllUnregisterServer();


   	TRACE_NON_CALLBACK_METHOD( "Exit DllRegisterServer" )


	return hr;

} // DllRegisterServer


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI DllUnregisterServer()
{
	TRACE_NON_CALLBACK_METHOD( "Enter DllUnregisterServer" )

	const COCLASS_REGISTER *pCoClass;


	// for each item in the coclass list, unregister it
	for ( pCoClass = g_CoClasses; pCoClass->pClsid != NULL; pCoClass++ )
	{
		REGUTIL::UnregisterCOMClass( *pCoClass->pClsid,
        							 g_szProgIDPrefix,
									 g_iVersion,
                                     pCoClass->szProgID );
	} // for

   	TRACE_NON_CALLBACK_METHOD( "Exit DllUnregisterServer" )


	return S_OK;

} // DllUnregisterServer


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv )
{
	TRACE_NON_CALLBACK_METHOD( "Enter DllGetClassObject" )

	CClassFactory *pClassFactory;
	const COCLASS_REGISTER *pCoClass;
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;


	// scan for the right one
	for ( pCoClass = g_CoClasses; pCoClass->pClsid != NULL; pCoClass++ )
	{
		if ( *pCoClass->pClsid == rclsid )
		{
			pClassFactory = new CClassFactory( pCoClass );
			if ( pClassFactory != NULL )
			{
				hr = pClassFactory->QueryInterface( riid, ppv );

				pClassFactory->Release();
				break;
			}
            else
            {
            	hr = E_OUTOFMEMORY;
            	break;
           	}
      	}
	} // for

    TRACE_NON_CALLBACK_METHOD( "Exit DllGetClassObject" )


	return hr;

} // DllGetClassObject


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
HINSTANCE GetModuleInst()
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit GetModuleInst" )


    return g_hInst;

} // GetModuleInst


/***************************************************************************************
 ********************                                               ********************
 ********************            DllMain Implementation             ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
	TRACE_NON_CALLBACK_METHOD( "Enter DllMain" )

	// save off the instance handle for later use
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		g_hInst = hInstance;
		g_outfile = getenv("COR_OGP_OUT");
        if (g_outfile == NULL)
            g_outfile = "objectrefs.log";
		g_out = fopen(g_outfile, "w+");


		printf("########## %s ##########\n", g_outfile);
		DisableThreadLibraryCalls( hInstance );
	}

	TRACE_NON_CALLBACK_METHOD( "Exit DllMain" )


	return TRUE;

} // DllMain


FILE* GetFileHandle()
{
	return g_out;
}

static int doLog = 0;

BOOL loggingEnabled()
{
    return doLog;
}

int printToLog(const char *fmt, ... )
{
    va_list     args;
    va_start( args, fmt );

    if (! loggingEnabled())
    {
        va_end(args);
        return 0;
    }

	int count = vfprintf(g_out, fmt, args );
    fflush(g_out);
    return count;
}

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\liveobjectlist.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "LiveObjectList.h"
#include "ProfilerCallBack.h"

int printToLog(const char *fmt, ... );

void LiveObjectList::Add(ObjectID objectID, ULONG32 size)
{
    if (! m_pProfiler->TrackLiveObjects())
        return;

#if 0
    // not sure it this is a valid thing to check for
    ListElement *elem = m_curList;
    while (elem)
    {
        // make sure the new object doesn't overlap any existing objects or something
        // is wrong.
        if (objectID >= elem->m_ObjectID && objectID < elem->m_ObjectID + elem->m_size)
            break;
        elem = elem->m_next;
    }
    if (elem)
        DebugBreak();
#endif

    ListElement *elem = new ListElement(objectID, size);
    elem->m_next = m_curList;
    m_curList = elem;
}

void LiveObjectList::GCStarted()
{
    m_origList = m_curList;
    m_curList = NULL;
}

void LiveObjectList::GCFinished()
{
    while (m_origList)
    {
        ListElement *tmp = m_origList;
        m_origList = m_origList->m_next;
        delete tmp;
    }
}

LiveObjectList::ListElement *LiveObjectList::IsInList(ObjectID objectID, ListElement *elem)
{
    while (elem && elem->m_ObjectID != objectID)
    {
        elem = elem->m_next;
    }
    if (elem && elem->m_ObjectID == objectID)
        return elem;

    return NULL;
}

ObjectID LiveObjectList::Keep(ObjectID objectID, BOOL fMayBeInterior)
{
    if (! m_pProfiler->TrackLiveObjects())
        return objectID;

    ListElement *elem = m_origList, *prev = NULL;
    while (elem)
    {
        if (elem->m_ObjectID == objectID)
            break;
        // if this could be an interior pointer, check if the object id is in the range
        // of the current object
        if (fMayBeInterior && objectID > elem->m_ObjectID && objectID < elem->m_ObjectID+elem->m_size)
            break;
        prev = elem;
        elem = elem->m_next;
    }

    if (! elem)
    {
        // if are tracking all live objects then the object must be either in the origList
        // or already moved to the curList
        if (m_pProfiler->TrackAllLiveObjects() && ! IsInList(objectID, m_curList))
            DebugBreak();
        return objectID;
    }
    
    if (! prev)
        m_origList = m_origList->m_next;
    else 
        prev->m_next = elem->m_next;

    elem->m_next = m_curList;
    m_curList = elem;
    return elem->m_ObjectID;
}

// move all objects in the given range to th new location
void LiveObjectList::Move(byte *oldAddressStart, byte *oldAddressEnd, byte *newAddressStart)
{
    if (! m_pProfiler->TrackLiveObjects())
        return;

    ListElement *elem = m_origList;

    byte *newAddressEnd = newAddressStart + (oldAddressEnd - oldAddressStart);
    // go through and mark any in the new range as stale
    while (elem)
    {
        byte *objAddr = (byte*)elem->m_ObjectID;
        if (objAddr >= newAddressStart && objAddr < newAddressEnd)
            elem->m_fStale = TRUE;
        elem = elem->m_next;
    }

    elem = m_origList;
    while (elem)
    {
        byte *objAddr = (byte*)elem->m_ObjectID;
        if (objAddr >= oldAddressStart && objAddr < oldAddressEnd)
        {		        
            ObjectID newObjectID = (ObjectID)(newAddressStart + (objAddr-oldAddressStart));

            // if this was previously marked as stale, reset it
            elem->m_fStale = FALSE;
            elem->m_ObjectID = (ObjectID)(newAddressStart + (objAddr-oldAddressStart));

            printToLog("    %8.8x to %8.8x\n", objAddr, elem->m_ObjectID);
        }
        elem = elem->m_next;
    }
}

LiveObjectList::ListElement* LiveObjectList::Remove(ObjectID objectID, ListElement *&list)
{
    if (! m_pProfiler->TrackLiveObjects())
        return NULL;

    ListElement *elem = list, *prev = NULL;

    while (elem && elem->m_ObjectID != objectID)
    {
        prev = elem;
        elem = elem->m_next;
    }
    if (! elem || elem->m_ObjectID != objectID)
    {
        return NULL;
    }

    if (prev)
        prev->m_next = elem->m_next;
    else 
        list = elem->m_next;

#if 0
    // should not still be there
    if (IsInList(objectID, list))
        DebugBreak();
#endif

    return elem;
}

void LiveObjectList::ClearStaleObjects()
{
    if (! m_pProfiler->TrackLiveObjects())
        return;

    ListElement *elem = m_origList, *prev = NULL;

    while ((elem = m_origList)->m_fStale == TRUE)
    {
        m_origList = m_origList->m_next;
        delete elem;
    }

    while (elem)
    {
        if (elem->m_fStale == TRUE) {
            prev->m_next = elem->m_next;
            delete elem;
            elem = prev->m_next;
            continue;
        }
        prev = elem;
        elem = elem->m_next;
    }
}

void LiveObjectList::DumpLiveObjects()
{
    printToLog("LiveObjects: \n");
    Dump(m_curList);
}

void LiveObjectList::DumpOldObjects()
{
    printToLog("OldObjects: \n");
    Dump(m_origList);
}

void LiveObjectList::Dump(ListElement *elem)
{
    if (! m_pProfiler->TrackLiveObjects())
        return;

    BOOL oldObjects = (elem == m_origList);

    int i = 0;
    int totSize = 0;
    while (elem)
    {
        if (oldObjects)
        	printToLog("[%4.4d]: %8.8x, size %8.8x,\n", i, elem->m_ObjectID, elem->m_size);
        else
        {
            ClassID classID;
      	    WCHAR className[512];

      	    HRESULT hr = m_pProfiler->GetProfilerInfo()->GetClassFromObject(elem->m_ObjectID, &classID);
    	    hr = m_pProfiler->GetNameFromClassID(m_pProfiler->GetProfilerInfo(), classID,className );

            totSize += elem->m_size;
    	    printToLog("[%4.4d]: %8.8x, %8.8x, %S, %8.8x", i++, elem->m_ObjectID, classID, className, elem->m_size);
            if (stringObjectClass == 0 && wcscmp(L"System.String", className) == 0)
                stringObjectClass = classID;
            if (classID != stringObjectClass)
                printToLog("\n");
            else
                printToLog(", \"%S\"\n", ((StringObject*)elem->m_ObjectID)->m_Characters);
        }
        elem = elem->m_next;
	}
    printToLog("Count %d, total size %d\n", i, totSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\liveobjectlist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef LIVEOBJECTLIST_H

#define LIVEOBJECTLIST_H

int printToLog(const char *fmt, ... );

class ProfilerCallback;

// this class maintains a list of live objects so you can track object allocations between
// specific points in the program. By setting TrackAllLiveObjects in the ProfilerCallBack, all
// object allocations will be tracked. By setting just TrackLiveObjects, only the ones from that
// point on will be tracked.
class LiveObjectList {
    struct ListElement 
    {
        ListElement(ObjectID objectID, ULONG size) : 
            m_ObjectID(objectID), m_size(size), m_fStale(FALSE), m_next(NULL) {}
        ObjectID m_ObjectID;
        ULONG m_size;
        BOOL m_fStale;
        ListElement *m_next;
    };
    // m_curList is the main live list. Allocated objects are put in here. When a GC starts, we
    // set origList to curList and move over referenced objects from origList to curList as we
    // see them. Anything that is not moved over from origList is now dead. So at the end of the
    // GC, m_curList will contain only the live objects of interest.
    ListElement *m_curList, *m_origList;
    ProfilerCallback *m_pProfiler;
    void Dump(ListElement *list);
    ListElement *Remove(ObjectID objectID, ListElement *&list);
    ListElement *Find(ObjectID objectID);
    ListElement *IsInList(ObjectID objectID, ListElement *list);
  public:
    LiveObjectList(ProfilerCallback *pProfiler) :  m_curList(NULL), m_pProfiler(pProfiler) {};
    void Add(ObjectID objectID, ULONG32 size);
    void GCStarted();
    void GCFinished();
    ObjectID Keep(ObjectID objectID, BOOL fMayBeInterior=FALSE);
    void Move(byte *oldAddressStart, byte *oldAddressEnd, byte *newAddressStart);
    void ClearStaleObjects();
    void DumpLiveObjects();
    void DumpOldObjects();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\objectgraph.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef OBJECTGRAPHNODE_H

#define OBJECTGRAPHNODE_H

#include "StdAfx.h"

class ObjectGraphNodeRef;
class ProfilerCallback;
class ObjectGraph;

class ObjectGraphNode {
    BOOL m_visited;
    BOOL m_fIsRoot;
	ObjectID m_objectId;
	ClassID m_classId;
    int m_cObjectRefs;
	ObjectGraphNode **m_objectRefsTo;        // array of pointers to objects ref'ed by this object
    ObjectGraphNodeRef *m_objectRefsFrom;    // linked list of objects that ref this object

public:
    ObjectGraphNode(ObjectID objectId);
    ~ObjectGraphNode();
    void AddRefsTo(ObjectGraph *pObjectGraph, ClassID classId, ULONG cObjectRefs, ObjectID objectRefIds[]);
    void AddRefFrom(ObjectGraphNode *objectId);
    void DumpRefTree(int indent);
    ObjectID GetObjectID()
    {
        return m_objectId;
    }
    void SetIsRoot()
    {
        m_fIsRoot = TRUE;
    }
    BOOL IsRoot()
    {
        return m_fIsRoot;
    }
};

class ObjectGraphNodeRef {
    ObjectGraphNode *m_node;
    ObjectGraphNodeRef *m_next;
public:
    ObjectGraphNodeRef(ObjectGraphNode *node) : m_node(node), m_next(NULL) {}
    ObjectGraphNode *GetNode()
    {
        return m_node;
    }
    ObjectID GetObjectID()
    {
        return m_node->GetObjectID();
    }
    ObjectGraphNodeRef* GetNext()
    {
        return m_next;
    }
    void SetNext(ObjectGraphNodeRef* next)
    {
        m_next = next;
    }
};

class ObjectGraph {
    ObjectGraphNodeRef *m_objects;  // linked list of all the objects for current GC
    int m_cObjects;

    ObjectGraphNodeRef *m_objectsPrev;  // linked list of all the objects from previous GC
    int m_cObjectsPrev;

    ObjectGraphNode *Find(ObjectID objectId, ObjectGraphNodeRef *objectList);
	ObjectGraphNode *AddObject(ObjectID objectId);
    void Clear(ObjectGraphNodeRef *nodeRef);

    ProfilerCallback *m_pProfiler;

public:
    ObjectGraph(ProfilerCallback *pProfiler) : 
        m_objects(NULL), m_cObjects(0), m_objectsPrev(NULL), m_cObjectsPrev(0), m_pProfiler(pProfiler) {}

    int ObjectCountCur()
    {
        return m_cObjects;
    }

    int ObjectCountPrev()
    {
        return m_cObjectsPrev;
    }

    void GCStarted();
    void GCFinished();
	void AddObjectRefs(ObjectID objectId, ClassID classId, ULONG cObjectRefs, ObjectID objectRefIds[]);
	void AddRootRefs( ULONG rootRefs, ObjectID rootRefIDs[]);
    ObjectGraphNode *Get(ObjectID objectId);
    void DumpRefTree(ObjectID objectId, BOOL fCurTree);
    void DumpAllRefTrees(BOOL fCurTree);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  classfactory.h
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#ifndef __CLASSFACTORY_H__
#define __CLASSFACTORY_H__


#include "RegUtil.h"
#include "ProfilerCallback.h"


//
// profiler GUID definition
//
#define PROFILER_GUID "{3353B053-7621-4d4f-9F1D-A11A703C4842}"

extern const GUID __declspec( selectany ) CLSID_PROFILER =
{ 0x3353b053, 0x7621, 0x4d4f, { 0x9f, 0x1d, 0xa1, 0x1a, 0x70, 0x3c, 0x48, 0x42 } };





//
// Helpers/Registration
//
HINSTANCE g_hInst;		  // instance handle to this piece of code
const int g_iVersion = 1; // version of coclasses.

static const LPCSTR g_szCoclassDesc    = "Microsoft Common Language Runtime Profiler";
static const LPCSTR g_szProgIDPrefix   = "COR";
static const LPCSTR g_szThreadingModel = "Both";


// create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)( REFIID riid, void **ppInterface );


/***************************************************************************************
 ********************                                               ********************
 ********************         COCLASS_REGISTER Declaration          ********************
 ********************                                               ********************
 ***************************************************************************************/
struct COCLASS_REGISTER
{
	const GUID *pClsid;				// Class ID of the coclass
    const char *szProgID;			// Prog ID of the class
   	PFN_CREATE_OBJ pfnCreateObject;	// function to create instance

}; // COCLASS_REGISTER


// this map contains the list of coclasses which are exported from this module
const COCLASS_REGISTER g_CoClasses[] =
{
	&CLSID_PROFILER,
    "ObjectGraphProfiler",
    ProfilerCallback::CreateObject,
	NULL,
    NULL,
    NULL
};


char* g_outfile;
FILE* g_out;

/***************************************************************************************
 ********************                                               ********************
 ********************          CClassFactory Declaration            ********************
 ********************                                               ********************
 ***************************************************************************************/
class CClassFactory :
	public IClassFactory
{
	private:

		CClassFactory();


	public:

    	CClassFactory( const COCLASS_REGISTER *pCoClass );
		~CClassFactory();


	public:

		//
		// IUnknown
		//
      	COM_METHOD( ULONG ) AddRef();
	    COM_METHOD( ULONG ) Release();
	    COM_METHOD( HRESULT ) QueryInterface( REFIID riid, void	**ppInterface );

		//
		// IClassFactory
		//
		COM_METHOD( HRESULT ) LockServer( BOOL fLock );
	    COM_METHOD( HRESULT ) CreateInstance( IUnknown *pUnkOuter,
	    									  REFIID riid,
	    									  void **ppInterface );


	private:

		long m_refCount;
    	const COCLASS_REGISTER *m_pCoClass;

}; // CClassFactory


//
// function prototypes
//
HINSTANCE GetModuleInst();
STDAPI DllRegisterServer();
STDAPI DllUnregisterServer();
STDAPI DllGetClassObject( REFCLSID rclsid, /* class desired */
						  REFIID riid,	   /* interface desired	*/
						  LPVOID FAR *ppv  /* return interface pointer */ );

FILE* GetFileHandle();


#endif // __CLASSFACTORY_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\objectgraph.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "ObjectGraph.h"
#include "ProfilerCallback.h"


static FILE *outputFile = NULL;
VOID FlushLog()
{
    if (outputFile)
        fflush(outputFile);
}

VOID Log(char *fmt, ...)
{
    va_list     args;
    va_start( args, fmt );

    char        buffer[1000];

    const char *outputFileName = "objectgraph.log";

    if (! outputFile)
        outputFile = fopen(outputFileName, "w");

    if (! outputFile)
        printf("***** Error: ObjectGraphProfiler couldn't open file %s\n", outputFileName);

    wvsprintfA(buffer, fmt, args );

    fprintf(outputFile, buffer);
}

BOOL MemCheck(void *ptr)
{
    _ASSERTE(ptr);

    if (! ptr)
    {
        Log("***** Error: ObjectGraphProfiler out of memory\n");
        return FALSE;
    }
    return TRUE;
}

ObjectGraphNode::ObjectGraphNode(ObjectID objectId)
    : m_visited(FALSE), m_fIsRoot(FALSE), m_objectId(objectId), m_classId(0),
      m_cObjectRefs(0), m_objectRefsTo(NULL), m_objectRefsFrom(NULL)
{
}

void ObjectGraphNode::AddRefsTo(ObjectGraph *pObjectGraph, ClassID classId, ULONG cObjectRefs, ObjectID objectRefIds[])
{
    m_classId = classId;
    m_objectRefsTo = new ObjectGraphNode*[cObjectRefs];
    if (!MemCheck(m_objectRefsTo))
        return;

    m_cObjectRefs = cObjectRefs;
    for (int i=0; i < m_cObjectRefs; i++)
    {
        ObjectGraphNode *node = pObjectGraph->Get(objectRefIds[i]);
        node->AddRefFrom(this);
        m_objectRefsTo[i] = node;
    }
}

void ObjectGraphNode::AddRefFrom(ObjectGraphNode *fromNode)
{
    ObjectGraphNodeRef *nodeRef = new ObjectGraphNodeRef(fromNode);
    MemCheck(nodeRef);

    nodeRef->SetNext(m_objectRefsFrom);
    m_objectRefsFrom = nodeRef;
}

ObjectGraphNode::~ObjectGraphNode()
{
	ObjectGraphNodeRef *nodeRef = m_objectRefsFrom;

    while (nodeRef != NULL)
    {
        ObjectGraphNodeRef *next = nodeRef->GetNext();
        delete nodeRef;
        nodeRef = next;
    }
}

void ObjectGraphNode::DumpRefTree(int indent)
{
    Log("%8.8x%s ", m_objectId, IsRoot() ? "*" : " ");

    if (! m_objectRefsFrom)
    {
        Log("\n");
        return;
    }

    if (m_visited)
    {
        Log("~ circref\n");
        return;
    }

    m_visited = TRUE;

    ObjectGraphNodeRef *nodeRef = m_objectRefsFrom;
    while (nodeRef != NULL)
    {
        nodeRef->GetNode()->DumpRefTree(indent + 1);
        nodeRef = nodeRef->GetNext();
        if (nodeRef)
        {
            for (int i=0; i < indent; i++)
                Log("          ");
        }
    }
    m_visited = FALSE;
}

void ObjectGraph::Clear(ObjectGraphNodeRef *nodeRef)
{
    while (nodeRef != NULL)
    {
        ObjectGraphNodeRef *next = nodeRef->GetNext();

        delete nodeRef->GetNode();
        delete nodeRef;
        nodeRef = next;
    }
}

ObjectGraphNode* ObjectGraph::Get(ObjectID objectId)
{
	ObjectGraphNode *node = Find(objectId, m_objects);

    if (node)
        return node;

    node = new ObjectGraphNode(objectId);
    ObjectGraphNodeRef *nodeRef = new ObjectGraphNodeRef(node);
    if (!MemCheck(node) || ! MemCheck(nodeRef))
        return NULL;

    nodeRef->SetNext(m_objects);
    m_objects = nodeRef;
    ++m_cObjects;

    return m_objects->GetNode();
}

ObjectGraphNode* ObjectGraph::Find(ObjectID objectId, ObjectGraphNodeRef *nodeRef)
{
    while (nodeRef != NULL)
    {
        if (nodeRef->GetObjectID() == objectId)
            return nodeRef->GetNode();
        nodeRef = nodeRef->GetNext();
    }
    return NULL;
}


void ObjectGraph::DumpRefTree(ObjectID objectId, BOOL fCurTree)
{
    ObjectGraphNode *node = Find(objectId, fCurTree ? m_objects : m_objectsPrev);

    if (! node)
    {
        Log("DumpRefTree: object %8.8x not found\n", objectId);
        return;
    }

    Log("%8.8x: ", node->GetObjectID());
    node->DumpRefTree(1);
    FlushLog();
}

void ObjectGraph::DumpAllRefTrees(BOOL fCurTree)
{
    ObjectGraphNodeRef *nodeRef = fCurTree ? m_objects : m_objectsPrev;
    while (nodeRef != NULL)
    {
        ObjectGraphNode *node = nodeRef->GetNode();
        Log("%8.8x, ", node->GetObjectID());
        node->DumpRefTree(1);
        nodeRef = nodeRef->GetNext();
    }
}

void ObjectGraph::AddRootRefs( ULONG rootRefs, ObjectID rootRefIDs[])
{
    if (! this->m_pProfiler->BuildObjectGraph())
        return;

  	for (ULONG i = 0; i< rootRefs; i++)
	{
        if (rootRefIDs[i] == 0)
            continue;

	    ObjectGraphNode *node = Get(rootRefIDs[i]);

        node->SetIsRoot();
    }
}

void ObjectGraph::AddObjectRefs(ObjectID objectId, ClassID classId, ULONG cObjectRefs, ObjectID objectRefIds[])
{
    if (! this->m_pProfiler->BuildObjectGraph())
        return;

	ObjectGraphNode *node = Get(objectId);

    node->AddRefsTo(this, classId, cObjectRefs, objectRefIds);
    //Log("ObjectGraph::AddObjectRefs for %8.8x\n", objectId);
}

void ObjectGraph::GCStarted()
{
    if (! this->m_pProfiler->BuildObjectGraph())
        return;

    Log("GCStarted\n");
}


void ObjectGraph::GCFinished()
{
    if (! this->m_pProfiler->BuildObjectGraph())
        return;

    Log("GCFinished for %d objects\n", m_cObjects);
    FlushLog();

    if (m_cObjects == 0)
        return;

    // transfer the current GC info to the previous info to allow us to track previous GC
    // along with the current GC in progress
    Clear(m_objectsPrev);
    m_objectsPrev = m_objects;
    m_objects = NULL;
    m_cObjectsPrev = m_cObjects;
    m_cObjects = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\profilerbase.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerTestBase.cpp
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#include "stdafx.h"
#include "ProfilerBase.h"


static
DWORD _FetchDebugEnvironment()
{
	DWORD retVal = 0;
	char debugEnvironment[MAX_LENGTH];


 	if ( GetEnvironmentVariableA( DEBUG_ENVIRONMENT, debugEnvironment, MAX_LENGTH ) > 0 )
   		retVal = (DWORD)atoi( debugEnvironment );


    return retVal;

} // _FetchDebugEnvironemnt


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void _DDebug( char *format, ... )
{
	static DWORD debugShow = _FetchDebugEnvironment();


    if ( debugShow > 1 )
    {
    	va_list args;
    	DWORD dwLength;
    	char buffer[MAX_LENGTH];


    	va_start( args, format );
    	dwLength = wvsprintfA( buffer, format, args );

    	printf( "%s\n", buffer );
   	}

} // _DDebug


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void _LaunchDebugger( const char *szMsg, const char* szFile, int iLine )
{
	static DWORD launchDebugger = _FetchDebugEnvironment();


	if ( launchDebugger >= 1 )
    {
    	char message[MAX_LENGTH];


		sprintf( message,
				 "%s\n\n"     \
                 "File: %s\n" \
                 "Line: %d\n",
				 ((szMsg == NULL) ? "FAILURE" : szMsg),
                 szFile,
                 iLine );

		switch ( MessageBoxA( NULL, message, "FAILURE", (MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION) ) )
		{
			case IDABORT:
				TerminateProcess( GetCurrentProcess(), 1 /* bad exit code */ );
				break;

			case IDRETRY:
				_DbgBreak();

			case IDIGNORE:
				break;

		} // switch
	}

} // _LaunchDebugger


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
void Failure( char *message )
{
	if ( message == NULL )
	 	message = "**** FAILURE: TURNING OFF PROFILING EVENTS ****";


	_PRF_ERROR( message );

} // failure


/***************************************************************************************
 ********************                                               ********************
 ********************            Synchronize Implementation         ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
Synchronize::Synchronize( CRITICAL_SECTION &criticalSection ) :
	m_block( criticalSection )
{
	EnterCriticalSection( &m_block );

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
Synchronize::~Synchronize()
{
	LeaveCriticalSection( &m_block );

} // dtor

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\profilerbase.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerBase.h
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#ifndef __PROFILERBASE_H__
#define __PROFILERBASE_H__

//#include "BasicHdr.h"



//
// debug dumper
//
void _DDebug( char *format, ... );


//
// launch debugger
//
void _LaunchDebugger( const char *szMsg, const char *szFile, int iLine );


//
// report failure
//
void Failure( char *message );


/***************************************************************************************
 ********************                                               ********************
 ********************            Synchronize Declaration            ********************
 ********************                                               ********************
 ***************************************************************************************/
class Synchronize
{
	public:

    	Synchronize( CRITICAL_SECTION &criticalSection );
		~Synchronize();


	private:

    	CRITICAL_SECTION &m_block;

}; // Synchronize

#endif // __PROFILERBASE_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\profilerhelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerHelper.cpp
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#include "stdafx.h"
#include "ProfilerHelper.h"


/***************************************************************************************
 ********************                                               ********************
 ********************             BaseInfo Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
BaseInfo::BaseInfo( ULONG id ) :
	m_id( id )
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit BaseInfo::BaseInfo" )

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
BaseInfo::~BaseInfo()
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit BaseInfo::~BaseInfo" )

} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
BOOL BaseInfo::Compare( ULONG key )
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit BaseInfo::Compare" )


    return (BOOL)(m_id == key);

} // BaseInfo::Compare


/***************************************************************************************
 ********************                                               ********************
 ********************          FunctionInfo Implementation          ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
FunctionInfo::FunctionInfo( FunctionID functionID ) :
    BaseInfo( functionID ),
  	m_left( 0 ),
  	m_enter( 0 ),
    m_classID( 0 ),
  	m_codeSize( 0 ),
    m_moduleID( 0 ),
	m_pStartAddress( NULL ),
    m_functionToken( mdTokenNil )
{
	TRACE_NON_CALLBACK_METHOD( "Enter FunctionInfo::FunctionInfo" )

   	wcscpy( m_functionName, L"UNKNOWN" );

    TRACE_NON_CALLBACK_METHOD( "Exit FunctionInfo::FunctionInfo" )

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public virtual */
FunctionInfo::~FunctionInfo()
{
	TRACE_NON_CALLBACK_METHOD( "Enter/Exit FunctionInfo::~FunctionInfo" )

} // dtor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */

/***************************************************************************************
 ********************                                               ********************
 ********************              PrfInfo Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
PrfInfo::PrfInfo() :
    m_pProfilerInfo( NULL )
{
    TRACE_NON_CALLBACK_METHOD( "Enter PrfInfo::PrfInfo" )

    TRACE_NON_CALLBACK_METHOD( "Exit PrfInfo::PrfInfo" )

} // ctor


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* virtual public */
PrfInfo::~PrfInfo()
{
    TRACE_NON_CALLBACK_METHOD( "Enter PrfInfo::~PrfInfo" )

    if ( m_pProfilerInfo != NULL )
    	m_pProfilerInfo->Release();


   	// clean up function table

    TRACE_NON_CALLBACK_METHOD( "Exit PrfInfo::~PrfInfo" )

} // dtor






// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\profilercallback.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerCallBack.cpp
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#include "stdafx.h"
#include "ProfilerCallback.h"
#include "ObjectGraph.h"
#include "LiveObjectList.h"

/***************************************************************************************
 ********************                                               ********************
 ********************     ProfilerCallBack Implementation           ********************
 ********************                                               ********************
 ***************************************************************************************/
ProfilerCallback *g_MyObject;

LONG ProfilerCallback::m_FunctionEnter = 0;
LONG ProfilerCallback::m_FunctionLeave = 0;

ClassID stringObjectClass = 0;

void DumpRefTreeCur(ObjectID objectId)
{
    if (g_MyObject)
        g_MyObject->GetObjectGraph()->DumpRefTree(objectId, TRUE);
}

void DumpRefTreePrev(ObjectID objectId)
{
    if (g_MyObject)
        g_MyObject->GetObjectGraph()->DumpRefTree(objectId, FALSE);
}

/***************************************************************************************
 ********************                                               ********************
 ********************   Global Functions Used by Function Hooks     ********************
 ********************                                               ********************
 ***************************************************************************************/
//
// the functions EnterStub and LeaveStub are basically wrappers
// because the __declspec(naked) definition does not allow
// the use of ProfilerCallback::Enter(functionID);
//
void __stdcall EnterStub( FunctionID functionID )
{
    ProfilerCallback::Enter( functionID );
}


void __stdcall LeaveStub( FunctionID functionID )
{
    ProfilerCallback::Leave( functionID );
}


void __declspec( naked ) EnterNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp+16]
        call EnterStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
}


void __declspec( naked ) LeaveNaked()
{
    __asm
    {
        push eax
        push ecx
        push edx
        push [esp+16]
        call LeaveStub
        pop edx
        pop ecx
        pop eax
        ret 4
    }
}

/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
ProfilerCallback::ProfilerCallback() :
    m_refCount( 0 ), m_gcNum(0), m_gcStarted(FALSE)

{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::ProfilerCallback" )

	_ASSERTE(g_MyObject == NULL);
    g_MyObject = this;
    m_dwEventMask = (DWORD) COR_PRF_MONITOR_GC | COR_PRF_MONITOR_SUSPENDS | COR_PRF_MONITOR_OBJECT_ALLOCATED;
    m_fTrackLiveObjects = FALSE;
    m_fTrackAllLiveObjects = FALSE;
    m_fBuildObjectGraph = TRUE;
    m_fDumpAllRefTrees = FALSE;
    m_pLiveObjects = new LiveObjectList(this);
    m_pObjectGraph = new ObjectGraph(this);
    if (!m_pLiveObjects || !m_pObjectGraph)
  	    printToLog("Out of memory allocating ProfilerCallback members");

#if 0
    // Read the reg key settings
    if (ERROR_SUCCESS != WszRegOpenKey(hKeyVal, (szKey) ? szKey : FRAMEWORK_REGISTRY_KEY_W, &hKey))
        return (iDefault);

    // Read the key value if found.
    iType = REG_DWORD;
    iSize = sizeof(long);
    if (ERROR_SUCCESS != WszRegQueryValueEx(hKey, szName, NULL, 
            &iType, (LPBYTE)&iValue, &iSize) || iType != REG_DWORD)
        iValue = iDefault;

    // We're done with the key now.
    RegCloseKey(hKey);
    return (iValue);
#endif
    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::ProfilerCallback" )

} // ctor


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
ProfilerCallback::~ProfilerCallback()
{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::~ProfilerCallback" )

	if (m_pProfilerInfo)
	{
		_ASSERTE(m_pProfilerInfo != NULL);
		RELEASE(m_pProfilerInfo);
	}
	g_MyObject = NULL;


    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::~ProfilerCallback" )


} // dtor


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
ULONG ProfilerCallback::AddRef()
{
    TRACE_NON_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AddRef" )


    return InterlockedIncrement( &m_refCount );

} // ProfilerCallback::AddRef


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
ULONG ProfilerCallback::Release()
{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::Release" )

    long refCount;


    refCount = InterlockedDecrement( &m_refCount );
    if ( refCount == 0 )
        delete this;


    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::Release" )


    return refCount;

} // ProfilerCallback::Release


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::QueryInterface( REFIID riid, void **ppInterface )
{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::QueryInterface" )

    if ( riid == IID_IUnknown )
        *ppInterface = static_cast<IUnknown *>( this );

    else if ( riid == IID_ICorProfilerCallback )
        *ppInterface = static_cast<ICorProfilerCallback *>( this );

    else
    {
        *ppInterface = NULL;
        TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::QueryInterface" )


        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown *>( *ppInterface )->AddRef();
    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::QueryInterface" )


    return S_OK;

} // ProfilerCallback::QueryInterface


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::Initialize( IUnknown *pProfilerInfo)
{
    TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::Initialize" )
	HRESULT hr = 0;

    if ( pProfilerInfo != NULL )
    {
    	hr = pProfilerInfo->QueryInterface(IID_ICorProfilerInfo, (void **)&m_pProfilerInfo);
    	if (FAILED(hr))
    	{
    		return (hr);
    	}
        m_pProfilerInfo->AddRef();
        DWORD dwRequestedEvents = m_dwEventMask;

        if (FAILED(m_pProfilerInfo->SetEventMask(dwRequestedEvents)))
        {
			return E_FAIL;
		}

    }
    else
        Failure( "ProfilerCallback::Initialize FAILED" );

    TRACE_CALLBACK_METHOD( "Exit ProfilerCallback::Initialize" )


    return S_OK;

} // ProfilerCallback::Initialize


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::Shutdown()
{
    TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::Shutdown" )


    TRACE_CALLBACK_METHOD( "Exit ProfilerCallback::Shutdown" )


    return S_OK;

} // ProfilerCallback::Shutdown


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCompilationFinished( FunctionID functionID,
                                                  HRESULT hrStatus,
                                                  BOOL fIsSafeToBlock )
{
    TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::JITCompilationFinished" )


    TRACE_CALLBACK_METHOD( "Exit ProfilerCallback::JITCompilationFinished" )

    return S_OK;

} // ProfilerCallback::JITCompilationFinished


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public static */
HRESULT ProfilerCallback::CreateObject( REFIID riid, void **ppInterface )
{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::CreateObject" )

    HRESULT hr = S_OK;


    if ( (riid == IID_IUnknown) || (riid == IID_ICorProfilerCallback) )
    {
        ProfilerCallback *pProfilerCallback;


        pProfilerCallback = new ProfilerCallback();
        if ( pProfilerCallback != NULL )
        {
            pProfilerCallback->AddRef();
            *ppInterface = static_cast<ICorProfilerCallback *>( pProfilerCallback );
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_NOINTERFACE;


    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::CreateObject" )


    return hr;

} // ProfilerCallback::CreateObject


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::Enter( FunctionID functionID )
{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::Enter" )

    //InterlockedIncrement( &m_FunctionEnter );

    //g_MyObject->UpdateEnterExitCounters( functionID, 1 );

    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::Enter" )

} // ProfilerCallback::Enter


/***************************************************************************************
 *  Method:
 *
 *
 *  Purpose:
 *
 *
 *  Parameters:
 *
 *
 *  Return value:
 *
 *
 *  Notes:
 *
 ***************************************************************************************/
/* public */
void ProfilerCallback::Leave( FunctionID functionID )
{
    TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::Leave" )

    //InterlockedIncrement( &m_FunctionLeave );

    //g_MyObject->UpdateEnterExitCounters( functionID, 2 );

    TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::Leave" )

} // ProfilerCallback::Leave


/***************************************************************************************
 ********************                                               ********************
 ******************** Callbacks With Default Implementation Below   ********************
 ********************                                               ********************
 ***************************************************************************************/

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainCreationStarted( AppDomainID appDomainID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AppDomainCreationStarted" )


    return S_OK;

} // ProfilerCallback::AppDomainCreationStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainCreationFinished( AppDomainID appDomainID,
													 HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AppDomainCreationFinished" )


    return S_OK;

} // ProfilerCallback::AppDomainCreationFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainShutdownStarted( AppDomainID appDomainID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AppDomainShutdownStarted" )


    return S_OK;

} // ProfilerCallback::AppDomainShutdownStarted



/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AppDomainShutdownFinished( AppDomainID appDomainID,
													 HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AppDomainShutdownFinished" )


    return S_OK;

} // ProfilerCallback::AppDomainShutdownFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyLoadStarted( AssemblyID assemblyID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AssemblyLoadStarted" )


    return S_OK;

} // ProfilerCallback::AssemblyLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyLoadFinished( AssemblyID assemblyID,
												HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AssemblyLoadFinished" )


    return S_OK;

} // ProfilerCallback::AssemblyLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyUnloadStarted( AssemblyID assemblyID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AssemblyUnloadStarted" )


    return S_OK;

} // ProfilerCallback::AssemblyUnLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::AssemblyUnloadFinished( AssemblyID assemblyID,
												  HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::AssemblyUnloadFinished" )


    return S_OK;

} // ProfilerCallback::AssemblyUnLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleLoadStarted( ModuleID moduleID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ModuleLoadStarted" )


    return S_OK;

} // ProfilerCallback::ModuleLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleLoadFinished( ModuleID moduleID,
											  HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ModuleLoadFinished" )


    return S_OK;

} // ProfilerCallback::ModuleLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleUnloadStarted( ModuleID moduleID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ModuleUnloadStarted" )


    return S_OK;

} // ProfilerCallback::ModuleUnloadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleUnloadFinished( ModuleID moduleID,
												HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ModuleUnloadFinished" )


    return S_OK;

} // ProfilerCallback::ModuleUnloadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ModuleAttachedToAssembly( ModuleID moduleID,
													AssemblyID assemblyID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ModuleAttachedToAssembly" )


    return S_OK;

} // ProfilerCallback::ModuleAttachedToAssembly


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassLoadStarted( ClassID classID )
{
	TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::ClassLoadStarted" )


    return S_OK;

} // ProfilerCallback::ClassLoadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassLoadFinished( ClassID classID,
											 HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ClassLoadFinished" )


    return S_OK;

} // ProfilerCallback::ClassLoadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassUnloadStarted( ClassID classID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ClassUnloadStarted" )


    return S_OK;

} // ProfilerCallback::ClassUnloadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ClassUnloadFinished( ClassID classID,
											   HRESULT hrStatus )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ClassUnloadFinished" )


    return S_OK;

} // ProfilerCallback::ClassUnloadFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::FunctionUnloadStarted( FunctionID functionID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::FunctionUnloadStarted" )


    return S_OK;

} // ProfilerCallback::FunctionUnloadStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCompilationStarted( FunctionID functionID,
                                                 BOOL fIsSafeToBlock )
{
	TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::JITCompilationStarted" )


    TRACE_CALLBACK_METHOD( "Exit ProfilerCallback::JITCompilationStarted" )

    return S_OK;

} // ProfilerCallback::JITCompilationStarted




/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::SetILMap( FunctionID functionID )
{
	TRACE_NON_CALLBACK_METHOD( "Enter ProfilerCallback::SetILMap" )

    HRESULT hr = S_OK;
	TRACE_NON_CALLBACK_METHOD( "Exit ProfilerCallback::SetILMap" )

    return hr;

} // ProfilerCallback::SetILMap



HRESULT ProfilerCallback::GetNameFromFunctionID( ICorProfilerInfo *pPrfInfo,
									      FunctionID functionID,
									      WCHAR functionName[] , WCHAR className[])
{
	TRACE_NON_CALLBACK_METHOD( "Enter PrfHelper::GetNameFromFunctionID" )

    HRESULT hr = E_FAIL;


    if ( pPrfInfo == NULL ) 
    {
		_PRF_ERROR( "ICorProfilerInfo Interface has NOT been Initialized" );
        return hr;
    }

    ClassID	classID;
	ModuleID moduleID;

	hr = pPrfInfo->GetFunctionInfo ( functionID,
									 &classID,
									 &moduleID,
									 NULL );
	if ( FAILED( hr ) )
    {
        _PRF_ERROR( "ICorProfilerInfo::GetTokenAndMetaDataFromFunction() FAILED" );
        return hr;
    }

    mdToken	token;
	IMetaDataImport *pMDImport = NULL;


	// try to get all the available metadata interfaces, notify upon failure
	hr = pPrfInfo->GetTokenAndMetaDataFromFunction( functionID,
			           								IID_IMetaDataImport,
													(IUnknown **)&pMDImport,
													&token );
	if ( FAILED( hr ) )
    {
		_PRF_ERROR( "IProfilerInfo::GetModuleMetaData() => IMetaDataImport FAILED" )
        return hr;
    }

	hr = pMDImport->GetMethodProps( token,
									NULL,
									functionName,
									MAX_LENGTH,
									0,
									0,
									NULL,
									NULL,
									NULL,
									NULL );
	if ( FAILED( hr ) )
    {
        _PRF_ERROR( "PrfHelper::GetNameFromClassID() FAILED" )
		pMDImport->Release ();
        return hr;
    }

    // get the name of the class
	hr = GetNameFromClassID( pPrfInfo,
							 classID,
							 className );
	if ( SUCCEEDED( hr ) )
	{
	   // fix the function fully qualified name and assign to the output paremeter
	   //swprintf( functionName, L"%s::%s",className, funName );
	}
	else
		_PRF_ERROR( "IMetaDataImport::GetTypeDefProps() FAILED" )

    pMDImport->Release ();
		

	TRACE_NON_CALLBACK_METHOD( "Exit PrfHelper::GetNameFromFunctionID" )


	return hr;

} // PrfHelper::GetNameFromFunctionID



WCHAR *elemNames[] = 
{
    L"ELEMENT_TYPE_END",  
    L"ELEMENT_TYPE_VOID",  
    L"ELEMENT_TYPE_BOOLEAN",  
    L"ELEMENT_TYPE_CHAR",  
    L"ELEMENT_TYPE_I1",  
    L"ELEMENT_TYPE_U1", 
    L"ELEMENT_TYPE_I2",  
    L"ELEMENT_TYPE_U2",  
    L"ELEMENT_TYPE_I4",  
    L"ELEMENT_TYPE_U4",  
    L"ELEMENT_TYPE_I8",  
    L"ELEMENT_TYPE_U8",  
    L"ELEMENT_TYPE_R4",  
    L"ELEMENT_TYPE_R8",  
    L"ELEMENT_TYPE_STRING",  
    L"ELEMENT_TYPE_PTR",
    L"ELEMENT_TYPE_BYREF",
    L"ELEMENT_TYPE_VALUETYPE",
    L"ELEMENT_TYPE_CLASS",
    L"<INVALID CLASS>",
    L"ELEMENT_TYPE_ARRAY",
    L"<INVALID CLASS>",
    L"ELEMENT_TYPE_TYPEDBYREF",
    L"<INVALID CLASS>",
    L"ELEMENT_TYPE_I",    
    L"ELEMENT_TYPE_U",    
    L"ELEMENT_TYPE_FNPTR",
    L"ELEMENT_TYPE_OBJECT",
    L"ELEMENT_TYPE_SZARRAY",
};

HRESULT ProfilerCallback::GetNameFromClassID( ICorProfilerInfo *pPrfInfo,
									   ClassID classID,
									   WCHAR className[] )
{
	TRACE_NON_CALLBACK_METHOD( "Enter PrfHelper::GetNameFromClassID" )

    HRESULT hr = E_FAIL;


    if ( pPrfInfo == NULL )
    {
		_PRF_ERROR( "ICorProfilerInfo Interface has NOT been Initialized" )
        return hr;
    }

    ModuleID moduleID;
	mdTypeDef classToken;


	hr = pPrfInfo->GetClassIDInfo( classID,
	        					   &moduleID,
	                               &classToken );
	if ( FAILED( hr ) )
    {
	    _PRF_ERROR( "ICorProfilerInfo::GetClassIDInfo() FAILED" );
        return hr;
    }
            
    ULONG rank;
    BOOL isArrayClass = FALSE;
    ULONG numDims = 0;

    ClassID arrayClassID = classID;
    while (classToken == 0x02000000)
	{
        ++numDims;

        ClassID baseClassID;
        CorElementType baseElemType;
        if (! (isArrayClass = SUCCEEDED(pPrfInfo->IsArrayClass(arrayClassID, &baseElemType, &baseClassID, &rank))))
        {
    		swprintf(className, L"<INVALID CLASS>");
	    	return S_OK;
        }
        if (! baseClassID)
        {
    		swprintf(className, L"%s[%d]", elemNames[baseElemType], rank);
            return S_OK;
        }
	    hr = pPrfInfo->GetClassIDInfo( baseClassID,
	        					       &moduleID,
	                                   &classToken );
	    if ( FAILED( hr ) )
        {
	        _PRF_ERROR( "ICorProfilerInfo::GetClassIDInfo() FAILED" );
            return hr;
        }
        arrayClassID = baseClassID;
    }

    IMetaDataImport *pMDImport = NULL;

	hr = pPrfInfo->GetModuleMetaData( moduleID,
		           					  (ofRead),
									  IID_IMetaDataImport,
		                              (IUnknown **)&pMDImport );
	if ( FAILED( hr ) )
	{
		_PRF_ERROR( "IProfilerInfo::GetModuleMetaData() => IMetaDataImport FAILED" );
        pMDImport->Release();
        return hr;
    }

	hr = pMDImport->GetTypeDefProps( classToken,
					                 className,
					                 MAX_LENGTH,
					                 NULL,
					                 NULL,
					                 NULL );
	if ( FAILED( hr ) )
    {
		_PRF_ERROR( "IMetaDataImport::GetTypeDefProps() FAILED" )
    }
    else if (isArrayClass)
    {
        WCHAR dimStr[50] = { L'\0' };
        for (ULONG i=1; i < numDims; i++)
            wcscat(dimStr, L"[]");

        WCHAR rankStr[75];
        swprintf(rankStr, L"%s[%d]", dimStr, rank);
        wcscat(className, rankStr);
    }

	pMDImport->Release ();

	TRACE_NON_CALLBACK_METHOD( "Exit PrfHelper::GetNameFromClassID" )

	return hr;

} // PrfHelper::GetNameFromClassID




/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCachedFunctionSearchStarted( FunctionID functionID, BOOL *pbUseCachedFunction)
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::JITCachedFunctionSearchStarted" )


    return S_OK;

} // ProfilerCallback::JITCachedFunctionSearchStarted


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITCachedFunctionSearchFinished( FunctionID functionID,
														   COR_PRF_JIT_CACHE result)
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::JITCacheFunctionSearchComplete" )


    return S_OK;

} // ProfilerCallback::JITCachedFunctionSearchFinished


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::JITFunctionPitched( FunctionID functionID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::JITFunctionPitched" )


    return S_OK;

} // ProfilerCallback::JITFunctionPitched


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ThreadCreated( ThreadID threadID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ThreadCreated" )


    return S_OK;

} // ProfilerCallback::ThreadCreated


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ThreadDestroyed( ThreadID threadID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ThreadDestroyed" )


    return S_OK;

} // ProfilerCallback::ThreadDestroyed


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ThreadAssignedToOSThread( ThreadID managedThreadID,
                                                    DWORD osThreadID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ThreadAssignedToOSThread" )


    return S_OK;

} // ProfilerCallback::ThreadAssignedToOSThread



/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientInvocationStarted()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingClientInvocationStarted" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientSendingMessage( GUID *pCookie,
    													BOOL fIsAsync )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingClientSendingMessage" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientReceivingReply(	GUID *pCookie,
	    												BOOL fIsAsync )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingClientReceivingReply" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingClientInvocationFinished()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingClientInvocationFinished" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerReceivingMessage( GUID *pCookie,
    													  BOOL fIsAsync )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingServerReceivingMessage" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerInvocationStarted()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingServerInvocationStarted" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerInvocationReturned()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingServerInvocationReturned" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RemotingServerSendingReply( GUID *pCookie,
    												  BOOL fIsAsync )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RemotingServerSendingReply" )


    return S_OK;
}


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::UnmanagedToManagedTransition( FunctionID functionID,
                                                        COR_PRF_TRANSITION_REASON reason )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::UnmanagedToManagedTransition" )


    return S_OK;

} // ProfilerCallback::UnmanagedToManagedTransition


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ManagedToUnmanagedTransition( FunctionID functionID,
                                                        COR_PRF_TRANSITION_REASON reason )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ManagedToUnmanagedTransition" )


    return S_OK;

} // ProfilerCallback::ManagedToUnmanagedTransition



/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::SecurityCheck( ThreadID threadID )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::SecurityCheck" )


    return S_OK;

} // ProfilerCallback::SecurityCheck


// Exception creation
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionThrown( ObjectID thrownObjectID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallbackBase::ExceptionThrown" )


    return S_OK;

} // ProfilerCallback::ExceptionThrown

// Search phase
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFunctionEnter( FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallbackBase::ExceptionSearchFunctionEnter" )


    return S_OK;

} // ProfilerCallback::ExceptionSearchFunctionEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFunctionLeave()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionSearchFunctionLeave" )


    return S_OK;

} // ProfilerCallback::ExceptionSearchFunctionLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFilterEnter( FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionSearchFilterEnter" )


    return S_OK;

} // ProfilerCallback::ExceptionSearchFilterEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchFilterLeave()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionSearchFilterLeave" )


    return S_OK;

} // ProfilerCallback::ExceptionSearchFilterLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionSearchCatcherFound( FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionSearchCatcherFound" )


    return S_OK;

} // ProfilerCallback::ExceptionSearchCatcherFound


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionOSHandlerEnter( FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionOSHandlerEnter" )


    return S_OK;

} // ProfilerCallback::ExceptionOSHandlerEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionOSHandlerLeave( FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionOSHandlerLeave" )


    return S_OK;

} // ProfilerCallback::ExceptionOSHandlerLeave


// Unwind phase
/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFunctionEnter(	/* [in] */ FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionUnwindFunctionEnter" )


    return S_OK;

} // ProfilerCallback::ExceptionUnwindFunctionEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFunctionLeave()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionUnwindFunctionLeave" )


    return S_OK;

} // ProfilerCallback::ExceptionUnwindFunctionLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFinallyEnter( FunctionID functionID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionUnwindFinallyEnter" )


    return S_OK;

} // ProfilerCallback::ExceptionUnwindFinallyEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionUnwindFinallyLeave()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionUnwindFinallyLeave" )


    return S_OK;

} // ProfilerCallback::ExceptionUnwindFinallyLeave


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionCatcherEnter( FunctionID functionID,
    											 ObjectID objectID )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionCatcherEnter" )


    return S_OK;

} // ProfilerCallback::ExceptionCatcherEnter


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ExceptionCatcherLeave()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionCatcherLeave" )


    return S_OK;

} // ProfilerCallback::ExceptionCatcherLeave

HRESULT ProfilerCallback::ExceptionCLRCatcherFound()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionCLRCatcherFound" );
    return S_OK;

}

HRESULT ProfilerCallback::ExceptionCLRCatcherExecute()
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ExceptionCLRCatcherExecute" );
    return S_OK;

}

/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::COMClassicWrapperCreated( ClassID wrappedClassID,
													REFGUID implementedIID,
													void *pUnknown,
													ULONG cSlots )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::COMClassicWrapperCreated" )


    return S_OK;

} // ProfilerCallback::COMClassicWrapperCreated


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::COMClassicWrapperDestroyed( ClassID wrappedClassID,
    												  REFGUID implementedIID,
													  void *pUnknown )
{
    TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::COMClassicWrapperDestroyed" )


    return S_OK;

} // ProfilerCallback::COMClassicWrapperDestroyed


HRESULT ProfilerCallback::JITInlining(FunctionID callerId, FunctionID calleeId, BOOL __RPC_FAR *pfShouldInline)
{
	   return S_OK;
}

HRESULT ProfilerCallback::RuntimeSuspendStarted(COR_PRF_SUSPEND_REASON suspendReason)
{
	if (suspendReason != COR_PRF_SUSPEND_FOR_GC)
        return S_OK;

    if (! loggingEnabled())
        return S_OK;

    m_currentThread = GetCurrentThreadId();
	printToLog("GCStarting,%d\n", ++m_gcNum);
    m_gcStarted = TRUE;
    m_pLiveObjects->GCStarted();
    m_pObjectGraph->GCStarted();

	return S_OK;
}

HRESULT ProfilerCallback::RuntimeSuspendFinished(void)
{
	return S_OK;
}

HRESULT ProfilerCallback::RuntimeSuspendAborted(void)
{
	return S_OK;
}

HRESULT ProfilerCallback::RuntimeResumeStarted(void)
{
    if (! loggingEnabled())
        return S_OK;

	if (m_gcStarted && m_currentThread == GetCurrentThreadId())
	{
		printToLog("GCEnding,%d\n", m_gcNum);
        m_pLiveObjects->GCFinished();
        m_pLiveObjects->DumpLiveObjects();
        m_pObjectGraph->GCFinished();
        if (m_fDumpAllRefTrees)
            m_pObjectGraph->DumpAllRefTrees(FALSE);
        m_gcStarted = FALSE;
	}
	return S_OK;
}

HRESULT ProfilerCallback::RuntimeResumeFinished(void)
{
	return S_OK;
}

HRESULT ProfilerCallback::RuntimeThreadSuspended(ThreadID threadid)
{
	return S_OK;
}

HRESULT ProfilerCallback::RuntimeThreadResumed(ThreadID threadid)
{
	return S_OK;
}

inline static unsigned roundUp(unsigned len, unsigned align) {
    return((len + align-1) & ~(align-1));
}

HRESULT ProfilerCallback::MovedReferences( ULONG movedObjectRefs,
                                           ObjectID oldObjectRefs[],
                                           ObjectID newObjectRefs[],
                                           ULONG objectRefSize[] )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::MovedReferences" )

    if (! loggingEnabled())
        return S_OK;

	printToLog("MovedReferences:\n", movedObjectRefs);

	for (ULONG i = 0; i < movedObjectRefs; i++)
	{
        printToLog("0x%x bytes from %8.8x...%8.8x to %8.8x...%8.8x\n",
            objectRefSize[i], oldObjectRefs[i], ((byte*)oldObjectRefs[i]) + objectRefSize[i],
            newObjectRefs[i], ((byte*)newObjectRefs[i]) + objectRefSize[i]);

        m_pLiveObjects->Move((byte *)oldObjectRefs[i], (byte *)oldObjectRefs[i]+objectRefSize[i],
                            (byte*)newObjectRefs[i]);
	}

	printToLog("\n");

    m_pLiveObjects->ClearStaleObjects();

    return S_OK;

} // ProfilerCallback::MovedReferences


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ObjectAllocated( ObjectID objectID,
                                           ClassID classID )
{
	TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::ObjectAllocated" )

    if (! loggingEnabled())
        return S_OK;

	HRESULT hr = 0;
	WCHAR className[512];
	ULONG size;

	GetNameFromClassID( m_pProfilerInfo, classID,className );
	hr = m_pProfilerInfo->GetObjectSize(objectID, &size);

	if (FAILED(hr))
	{
		printf("GetObject Size Failed\n");
		size = (ULONG)-1;

	}

	printToLog("ObjectAllocated,%8.8x,%8.8x,%S,%8.8x\n", objectID, classID, className, size);
    m_pLiveObjects->Add(objectID, size);

	TRACE_CALLBACK_METHOD( "Exit ProfilerCallback::ObjectAllocated" )

    return S_OK;

} // ProfilerCallback::ObjectAllocated


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ObjectsAllocatedByClass( ULONG classCount,
                                                   ClassID classIDs[],
                                                   ULONG objects[] )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::ObjectsAllocatedByClass" )


    return S_OK;

} // ProfilerCallback::ObjectsAllocatedByClass


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::ObjectReferences( ObjectID objectId,
                                            ClassID classId,
                                            ULONG objectRefs,
                                            ObjectID objectRefIds[] )
{
	TRACE_CALLBACK_METHOD( "Enter ProfilerCallback::ObjectReferences" )

    if (! loggingEnabled())
        return S_OK;

    m_pObjectGraph->AddObjectRefs(objectId, classId, objectRefs, objectRefIds);

	HRESULT hr = 0;
	WCHAR className[512];
	ULONG size;

	GetNameFromClassID( m_pProfilerInfo, classId,className );
	hr = m_pProfilerInfo->GetObjectSize(objectId, &size);

	if (FAILED(hr))
	{
		printf("GetObject Size Failed\n");
		size = (ULONG)-1;

	}

    m_pLiveObjects->Keep(objectId);
	printToLog("ObjectRefs,%8.8x,%8.8x,%S,%8.8x,%8.8x\n", objectId, classId, className, size, objectRefs);

    int j = 0;
	for (ULONG i = 0; i< objectRefs; i++)
	{
        m_pLiveObjects->Keep(objectRefIds[i]);
		printToLog("%8.8x,", objectRefIds[i]);
        if (j++ == 7)
        {
            printToLog("\n");
            j = 0;
        }
	}

	printToLog("\n");

	TRACE_CALLBACK_METHOD( "Exit ProfilerCallback::ObjectReferences" )
    return S_OK;

} // ProfilerCallback::ObjectReferences


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 ***************************************************************************************/
/* public */
HRESULT ProfilerCallback::RootReferences( ULONG rootRefs,
                                          ObjectID rootRefIDs[] )
{
	TRACE_CALLBACK_METHOD( "Enter/Exit ProfilerCallback::RootReferences" )

    if (! loggingEnabled())
        return S_OK;

    m_pObjectGraph->AddRootRefs(rootRefs, rootRefIDs);

    printToLog("RootRefs,%8.8x\n", rootRefs);

	for (ULONG i = 0; i< rootRefs; i++)
	{
        if (rootRefIDs[i] == 0)
            continue;

        // Keep will return the real object corresponding to an interior pointer
        // if object tracking is enabled and we've tracked that object
        ObjectID rootRef = m_pLiveObjects->Keep(rootRefIDs[i], TRUE);

        ClassID classID;
      	WCHAR className[512];
        ULONG size;

        __try
        {
      	    HRESULT hr = m_pProfilerInfo->GetClassFromObject(rootRef, &classID);
    	    hr = GetNameFromClassID(m_pProfilerInfo, classID, className);
    	    hr = m_pProfilerInfo->GetObjectSize(rootRef, &size);

            if (rootRef != rootRefIDs[i])
            	printToLog("[%4.4d] %8.8x (interior %8.8x), %8.8x, %S, %8.8x", i, rootRef, rootRefIDs[i], classID, className, size);
            else
            	printToLog("[%4.4d] %8.8x, %8.8x, %S, %8.8x", i, rootRef, classID, className, size);
            if (stringObjectClass == 0 && wcscmp(L"System.String", className) == 0)
                stringObjectClass = classID;
            if (classID != stringObjectClass)
                printToLog("\n");
            else
                printToLog(", \"%S\"\n", ((StringObject*)rootRefIDs[i])->m_Characters);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
    	    printToLog("[%4.4d], %8.8x\n", i, rootRef, classID, className, size);
        }
	}

	printToLog("\n");

	// @todo We will need to use this
    return S_OK;

} // ProfilerCallback::RootReferences
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************

#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\regutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// RegUtil.cpp
//
// This module contains a set of functions that can be used to access the
// regsitry.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegUtil.h"


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *	Set an entry in the registry of the form:
 *					HKEY_CLASSES_ROOT\szKey\szSubkey = szValue
 *	If szSubkey or szValue are NULL, omit them from the above expression.
 ***************************************************************************************/
BOOL REGUTIL::SetKeyAndValue( const char *szKey,
							  const char *szSubkey,
							  const char *szValue )
{
	HKEY hKey;	 	 		// handle to the new reg key.
	char rcKey[MAX_LENGTH]; // buffer for the full key name.


	// init the key with the base key name.
	strcpy( rcKey, szKey );

	// append the subkey name (if there is one).
	if ( szSubkey != NULL )
	{
		strcat( rcKey, "\\" );
		strcat( rcKey, szSubkey );
	}

	// create the registration key.
	if (RegCreateKeyExA( HKEY_CLASSES_ROOT,
						 rcKey,
						 0,
						 NULL,
						 REG_OPTION_NON_VOLATILE,
						 KEY_ALL_ACCESS,
						 NULL,
						 &hKey,
						 NULL ) == ERROR_SUCCESS )
	{
		// set the value (if there is one).
		if ( szValue != NULL )
		{
			RegSetValueExA( hKey,
							NULL,
							0,
							REG_SZ,
							(BYTE *) szValue,
							( strlen( szValue ) + 1 ) * sizeof( char ) );
		}

		RegCloseKey( hKey );


		return TRUE;
	}


	return FALSE;

} // REGUTIL::SetKeyAndValue


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *	Delete an entry in the registry of the form:
 *					HKEY_CLASSES_ROOT\szKey\szSubkey = szValue
 ***************************************************************************************/
BOOL REGUTIL::DeleteKey( const char *szKey,
					 	 const char *szSubkey )
{
	char rcKey[MAX_LENGTH]; // buffer for the full key name.


	// init the key with the base key name.
	strcpy( rcKey, szKey );

	// append the subkey name (if there is one).
	if ( szSubkey != NULL )
	{
		strcat( rcKey, "\\" );
		strcat( rcKey, szSubkey );
	}

	// delete the registration key.
	RegDeleteKeyA( HKEY_CLASSES_ROOT, rcKey );


	return TRUE;

} // REGUTIL::DeleteKey


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *	Open the key, create a new keyword and value pair under it.
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 *
 ***************************************************************************************/
BOOL REGUTIL::SetRegValue( const char *szKeyName,
						   const char *szKeyword,
						   const char *szValue )
{
	HKEY hKey; // handle to the new reg key.

	// create the registration key.
	if ( RegCreateKeyExA( HKEY_CLASSES_ROOT,
						  szKeyName,
						  0,
						  NULL,
						  REG_OPTION_NON_VOLATILE,
						  KEY_ALL_ACCESS,
						  NULL,
						  &hKey,
						  NULL) == ERROR_SUCCESS )
	{
		// set the value (if there is one).
		if ( szValue != NULL )
		{
			RegSetValueExA( hKey,
							szKeyword,
							0,
							REG_SZ,
							(BYTE *)szValue,
							( strlen( szValue ) + 1 ) * sizeof( char ) );
		}

		RegCloseKey( hKey );


		return TRUE;
	}


	return FALSE;

} // REGUTIL::SetRegValue


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *	Does standard registration of a CoClass with a progid.
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 *
 ***************************************************************************************/
HRESULT REGUTIL::RegisterCOMClass( REFCLSID	rclsid,
								   const char *szDesc,
								   const char *szProgIDPrefix,
								   int	iVersion,
								   const char *szClassProgID,
								   const char *szThreadingModel,
								   const char *szModule )
{
	HRESULT	hr;
	char rcCLSID[MAX_LENGTH];			// CLSID\\szID.
	char rcProgID[MAX_LENGTH];			// szProgIDPrefix.szClassProgID
	char rcIndProgID[MAX_LENGTH];		// rcProgID.iVersion
	char rcInproc[MAX_LENGTH + 2]; 		// CLSID\\InprocServer32


	// format the prog ID values.
	sprintf( rcIndProgID, "%s.%s", szProgIDPrefix, szClassProgID ) ;
	sprintf( rcProgID, "%s.%d", rcIndProgID, iVersion );

	// do the initial portion.
	hr =  RegisterClassBase( rclsid,
							 szDesc,
							 rcProgID,
							 rcIndProgID,
							 rcCLSID );
	if ( SUCCEEDED( hr ) )
	{
		// set the server path.
	    SetKeyAndValue( rcCLSID, "InprocServer32", szModule );

		// add the threading model information.
		sprintf( rcInproc, "%s\\%s", rcCLSID, "InprocServer32" );
		SetRegValue( rcInproc, "ThreadingModel", szThreadingModel );
	}


	return hr;

} // REGUTIL::RegisterCOMClass


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *	Register the basics for a in proc server.
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 *
 ***************************************************************************************/
HRESULT REGUTIL::RegisterClassBase( REFCLSID rclsid,
									const char *szDesc,
									const char *szProgID,
									const char *szIndepProgID,
									char *szOutCLSID )
{
    // create some base key strings.

	char szID[64]; 	   // the class ID to register.
	OLECHAR	szWID[64]; // helper for the class ID to register.


    StringFromGUID2( rclsid, szWID, NumItems( szWID ) );
	WideCharToMultiByte( CP_ACP,
						 0,
						 szWID,
						 -1,
						 szID,
						 sizeof( szID ),
						 NULL,
						 NULL );

    strcpy( szOutCLSID, "CLSID\\" );
    strcat( szOutCLSID, szID );

    // create ProgID keys.
    SetKeyAndValue( szProgID, NULL, szDesc );
    SetKeyAndValue( szProgID, "CLSID", szID );

    // create VersionIndependentProgID keys.
    SetKeyAndValue( szIndepProgID, NULL, szDesc );
    SetKeyAndValue( szIndepProgID, "CurVer", szProgID );
    SetKeyAndValue( szIndepProgID, "CLSID", szID );

    // create entries under CLSID.
    SetKeyAndValue( szOutCLSID, NULL, szDesc );
    SetKeyAndValue( szOutCLSID, "ProgID", szProgID );
    SetKeyAndValue( szOutCLSID, "VersionIndependentProgID", szIndepProgID );
    SetKeyAndValue( szOutCLSID, "NotInsertable", NULL );


	return S_OK;

} // REGUTIL::RegisterClassBase


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *	Unregister the basic information in the system registry for a given object
 *	class
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 *
 ***************************************************************************************/
HRESULT REGUTIL::UnregisterCOMClass( REFCLSID rclsid,
									 const char *szProgIDPrefix,
									 int iVersion,
									 const char *szClassProgID )
{
	char szID[64];		   // the class ID to unregister.
	char rcCLSID[64];	   // CLSID\\szID.
	OLECHAR	szWID[64];	   // helper for the class ID to unregister.
	char rcProgID[128];	   // szProgIDPrefix.szClassProgID
	char rcIndProgID[128]; // rcProgID.iVersion


	// format the prog ID values.
	sprintf( rcProgID, "%s.%s", szProgIDPrefix, szClassProgID );
	sprintf( rcIndProgID, "%s.%d", rcProgID, iVersion );

	UnregisterClassBase( rclsid, rcProgID, rcIndProgID, rcCLSID );
	DeleteKey( rcCLSID, "InprocServer32" );

    StringFromGUID2(rclsid, szWID, NumItems( szWID ) );
	WideCharToMultiByte( CP_ACP,
						 0,
						 szWID,
						 -1,
						 szID,
						 sizeof( szID ),
						 NULL,
						 NULL );

	DeleteKey( "CLSID", rcCLSID );


	return S_OK;

} // REGUTIL::UnregisterCOMClass


/***************************************************************************************
 *	Method:
 *
 *
 *	Purpose:
 *	Delete the basic settings for an inproc server.
 *
 *	Parameters:
 *
 *
 *	Return value:
 *
 *
 *	Notes:
 *
 *
 ***************************************************************************************/
HRESULT REGUTIL::UnregisterClassBase( REFCLSID rclsid,
									  const char *szProgID,
									  const char *szIndepProgID,
									  char *szOutCLSID )
{
	char szID[64]; 	   // the class ID to register.
	OLECHAR	szWID[64]; // helper for the class ID to register.


    StringFromGUID2( rclsid, szWID, NumItems( szWID ) );
	WideCharToMultiByte( CP_ACP,
						 0,
						 szWID,
						 -1,
						 szID,
						 sizeof( szID ),
						 NULL,
						 NULL );

	strcpy( szOutCLSID, "CLSID\\" );
	strcat( szOutCLSID, szID );

	// delete the version independant prog ID settings.
	DeleteKey( szIndepProgID, "CurVer" );
	DeleteKey( szIndepProgID, "CLSID" );
	RegDeleteKeyA( HKEY_CLASSES_ROOT, szIndepProgID );


	// delete the prog ID settings.
	DeleteKey( szProgID, "CLSID" );
	RegDeleteKeyA( HKEY_CLASSES_ROOT, szProgID );


	// delete the class ID settings.
	DeleteKey( szOutCLSID, "ProgID" );
	DeleteKey( szOutCLSID, "VersionIndependentProgID" );
	DeleteKey( szOutCLSID, "NotInsertable" );
	RegDeleteKeyA( HKEY_CLASSES_ROOT, szOutCLSID );


	return S_OK;

} // REGUTIL::UnregisterClassBase


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\profilercallback.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerCallback.h
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#ifndef __PROFILER_CALLBACK_H__
#define __PROFILER_CALLBACK_H__

#include "ProfilerBase.h"
#include "ProfilerHelper.h"

//#define _PRF_ERROR( message ) printf( "%s\n", message );

int printToLog(const char *fmt, ... );
BOOL loggingEnabled();

struct StringObject
{
    DWORD   m_Vtable;
    DWORD   m_ArrayLength;
    DWORD   m_StringLength;
    WCHAR   m_Characters[0];
};

extern ClassID stringObjectClass;

class LiveObjectList;
class ObjectGraph;

/***************************************************************************************
 ********************                                               ********************
 ********************       ProfilerCallback Declaration            ********************
 ********************                                               ********************
 ***************************************************************************************/
class ProfilerCallback :
	public ICorProfilerCallback,
	public PrfInfo
{
    public:

        ProfilerCallback();
        ~ProfilerCallback();


    public:




        //
        // IUnknown
        //
        COM_METHOD( ULONG ) AddRef();
        COM_METHOD( ULONG ) Release();
        COM_METHOD( HRESULT ) QueryInterface( REFIID riid, void **ppInterface );

        //
        // STARTUP/SHUTDOWN EVENTS
        //
		COM_METHOD( HRESULT ) Initialize(IUnknown *pProfilerInfo);
        COM_METHOD( HRESULT ) Shutdown();


		//
	 	// APPLICATION DOMAIN EVENTS
		//
	   	COM_METHOD( HRESULT ) AppDomainCreationStarted( AppDomainID appDomainID );

    	COM_METHOD( HRESULT ) AppDomainCreationFinished( AppDomainID appDomainID,
													     HRESULT hrStatus );

        COM_METHOD( HRESULT ) AppDomainShutdownStarted( AppDomainID appDomainID );

		COM_METHOD( HRESULT ) AppDomainShutdownFinished( AppDomainID appDomainID,
        												 HRESULT hrStatus );

		//
	 	// ASSEMBLY EVENTS
		//
	   	COM_METHOD( HRESULT ) AssemblyLoadStarted( AssemblyID assemblyID );

    	COM_METHOD( HRESULT ) AssemblyLoadFinished( AssemblyID assemblyID,
                                                    HRESULT hrStatus );

        COM_METHOD( HRESULT ) AssemblyUnloadStarted( AssemblyID assemblyID );

		COM_METHOD( HRESULT ) AssemblyUnloadFinished( AssemblyID assemblyID,
        											  HRESULT hrStatus );


		//
	 	// MODULE EVENTS
		//
	   	COM_METHOD( HRESULT ) ModuleLoadStarted( ModuleID moduleID );

    	COM_METHOD( HRESULT ) ModuleLoadFinished( ModuleID moduleID,
                                                  HRESULT hrStatus );

        COM_METHOD( HRESULT ) ModuleUnloadStarted( ModuleID moduleID );

		COM_METHOD( HRESULT ) ModuleUnloadFinished( ModuleID moduleID,
        											HRESULT hrStatus );

		COM_METHOD( HRESULT ) ModuleAttachedToAssembly( ModuleID moduleID,
														AssemblyID assemblyID );


        //
        // CLASS EVENTS
        //
        COM_METHOD( HRESULT ) ClassLoadStarted( ClassID classID );

        COM_METHOD( HRESULT ) ClassLoadFinished( ClassID classID,
                                                 HRESULT hrStatus );

     	COM_METHOD( HRESULT ) ClassUnloadStarted( ClassID classID );

		COM_METHOD( HRESULT ) ClassUnloadFinished( ClassID classID,
        										   HRESULT hrStatus );

		COM_METHOD( HRESULT ) FunctionUnloadStarted( FunctionID functionID );


        //
        // JIT EVENTS
        //
        COM_METHOD( HRESULT ) JITCompilationStarted( FunctionID functionID,
                                                     BOOL fIsSafeToBlock );

        COM_METHOD( HRESULT ) JITCompilationFinished( FunctionID functionID,
        											  HRESULT hrStatus,
                                                      BOOL fIsSafeToBlock );

        COM_METHOD( HRESULT ) JITCachedFunctionSearchStarted( FunctionID functionID, BOOL *pbUseCachedFunction);

		COM_METHOD( HRESULT ) JITCachedFunctionSearchFinished( FunctionID functionID,
															   COR_PRF_JIT_CACHE result);


        COM_METHOD( HRESULT ) JITFunctionPitched( FunctionID functionID );


        //
        // THREAD EVENTS
        //
        COM_METHOD( HRESULT ) ThreadCreated( ThreadID threadID );

        COM_METHOD( HRESULT ) ThreadDestroyed( ThreadID threadID );

        COM_METHOD( HRESULT ) ThreadAssignedToOSThread( ThreadID managedThreadID,
                                                        DWORD osThreadID );

       	//
        // REMOTING EVENTS
        //

        //
        // Client-side events
        //

        COM_METHOD( HRESULT ) RemotingClientInvocationStarted();

        COM_METHOD( HRESULT ) RemotingClientSendingMessage( GUID *pCookie,
															BOOL fIsAsync );

        COM_METHOD( HRESULT ) RemotingClientReceivingReply( GUID *pCookie,
															BOOL fIsAsync );

        COM_METHOD( HRESULT ) RemotingClientInvocationFinished();

        //
        // Server-side events
        //

        COM_METHOD( HRESULT ) RemotingServerReceivingMessage( GUID *pCookie,
															  BOOL fIsAsync );

        COM_METHOD( HRESULT ) RemotingServerInvocationStarted();

        COM_METHOD( HRESULT ) RemotingServerInvocationReturned();

        COM_METHOD( HRESULT ) RemotingServerSendingReply( GUID *pCookie,
														  BOOL fIsAsync );


       	//
        // CONTEXT EVENTS
        //
    	COM_METHOD( HRESULT ) UnmanagedToManagedTransition( FunctionID functionID,
                                                            COR_PRF_TRANSITION_REASON reason );

        COM_METHOD( HRESULT ) ManagedToUnmanagedTransition( FunctionID functionID,
                                                            COR_PRF_TRANSITION_REASON reason );

        COM_METHOD( HRESULT )  STDMETHODCALLTYPE COMClassicVTableCreated(
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots)
		{
			return E_NOTIMPL;
		}


        COM_METHOD( HRESULT ) STDMETHODCALLTYPE COMClassicVTableDestroyed(
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable)
		{
			return E_NOTIMPL;
		}


       	//
        // GC EVENTS
        //
        COM_METHOD( HRESULT ) MovedReferences( ULONG movedObjectRefs,
                                               ObjectID oldObjectRefs[],
                                               ObjectID newObjectRefs[],
                                               ULONG objectRefSize[] );

        COM_METHOD( HRESULT ) ObjectAllocated( ObjectID objectID,
                                               ClassID classID );

        COM_METHOD( HRESULT ) ObjectsAllocatedByClass( ULONG classCount,
                                                       ClassID classIDs[],
                                                       ULONG objects[] );

        COM_METHOD( HRESULT ) ObjectReferences( ObjectID objectID,
                                                ClassID classID,
                                                ULONG cObjectRefs,
                                                ObjectID objectRefIDs[] );

        COM_METHOD( HRESULT ) RootReferences( ULONG cRootRefs,
                                              ObjectID rootRefIDs[] );



    	//
        // SECURITY EVENTS
        //
        COM_METHOD( HRESULT ) SecurityCheck( ThreadID threadID );


      	//
        // EXCEPTION EVENTS
        //

        // Exception creation
        COM_METHOD( HRESULT ) ExceptionThrown( ObjectID thrownObjectID );

        // Search phase
        COM_METHOD( HRESULT ) ExceptionSearchFunctionEnter( FunctionID functionID );

        COM_METHOD( HRESULT ) ExceptionSearchFunctionLeave();

        COM_METHOD( HRESULT ) ExceptionSearchFilterEnter( FunctionID functionID );

        COM_METHOD( HRESULT ) ExceptionSearchFilterLeave();

        COM_METHOD( HRESULT ) ExceptionSearchCatcherFound( FunctionID functionID );

        COM_METHOD( HRESULT ) ExceptionOSHandlerEnter( FunctionID functionID );

        COM_METHOD( HRESULT ) ExceptionOSHandlerLeave( FunctionID functionID );

        // Unwind phase
        COM_METHOD( HRESULT ) ExceptionUnwindFunctionEnter( FunctionID functionID );

        COM_METHOD( HRESULT ) ExceptionUnwindFunctionLeave();

        COM_METHOD( HRESULT ) ExceptionUnwindFinallyEnter( FunctionID functionID );

        COM_METHOD( HRESULT ) ExceptionUnwindFinallyLeave();

        COM_METHOD( HRESULT ) ExceptionCatcherEnter( FunctionID functionID,
            										 ObjectID objectID );

        COM_METHOD( HRESULT ) ExceptionCatcherLeave();

        COM_METHOD( HRESULT ) ExceptionCLRCatcherFound();

        COM_METHOD( HRESULT ) ExceptionCLRCatcherExecute();

        //
		// COM CLASSIC WRAPPER
		//
        COM_METHOD( HRESULT )  COMClassicWrapperCreated( ClassID wrappedClassID,
                                                               REFGUID implementedIID,
                                                               void *pUnknown,
                                                               ULONG cSlots );

        COM_METHOD( HRESULT )  COMClassicWrapperDestroyed( ClassID wrappedClassID,
                                                                REFGUID implementedIID,
                                                                void *pUnknown );

		COM_METHOD( HRESULT )  JITInlining(FunctionID callerId, FunctionID calleeId, BOOL __RPC_FAR *pfShouldInline);
		COM_METHOD( HRESULT )  RuntimeSuspendStarted(COR_PRF_SUSPEND_REASON suspendReason);
		COM_METHOD( HRESULT )  RuntimeSuspendFinished(void);
		COM_METHOD( HRESULT )  RuntimeSuspendAborted(void);
		COM_METHOD( HRESULT )  RuntimeResumeStarted(void);
		COM_METHOD( HRESULT )  RuntimeResumeFinished(void);
		COM_METHOD( HRESULT )  RuntimeThreadSuspended(ThreadID threadid);
		COM_METHOD( HRESULT )  RuntimeThreadResumed(ThreadID threadid);
        //
        // helper
        //
        static COM_METHOD( HRESULT) CreateObject( REFIID riid, void **ppInterface );
        COM_METHOD( HRESULT)  GetNameFromFunctionID( ICorProfilerInfo *pPrfInfo, FunctionID functionID, WCHAR functionName[] , WCHAR className[]);
        COM_METHOD( HRESULT) GetNameFromClassID( ICorProfilerInfo *pPrfInfo, ClassID classID, WCHAR className[] );
		//COM_METHOD( HRESULT) InsertProbes( FunctionID functionID );
		COM_METHOD( HRESULT) SetILMap( FunctionID functionID );
		//HRESULT GetCoverageTokens(ICorProfilerInfo *pPrfInfo, FunctionID functionID);




    	// used by function hooks, they have to be static
    	static void  Enter( FunctionID functionID );
		static void  Leave( FunctionID functionID );

        ICorProfilerInfo *GetProfilerInfo() {
            return m_pProfilerInfo;
        }

        BOOL TrackLiveObjects() {
            return m_fTrackLiveObjects || m_fTrackAllLiveObjects;
        }

        BOOL TrackAllLiveObjects() {
            return m_fTrackAllLiveObjects;
        }

        BOOL BuildObjectGraph() {
            return m_fBuildObjectGraph;
        }

        ObjectGraph *GetObjectGraph() {
            return m_pObjectGraph;
        }

    private:

        long m_refCount;
        DWORD m_dwEventMask;
        DWORD m_currentThread;
        long  m_gcNum;
        BOOL m_gcStarted;

		// global counter for total number of function entries and leaves
		static LONG	m_FunctionEnter;
		static LONG	m_FunctionLeave;

        BOOL m_fTrackLiveObjects;
        BOOL m_fTrackAllLiveObjects;
        LiveObjectList *m_pLiveObjects;

        BOOL m_fBuildObjectGraph;
        BOOL m_fDumpAllRefTrees;
        ObjectGraph *m_pObjectGraph;

}; // ProfilerCallback


#endif //  __PROFILER_CALLBACK_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  BasicHdr.h
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#ifndef __BASICHDR_H__
#define __BASICHDR_H__

#define _WIN32_DCOM


/***************************************************************************************
 ********************                                               ********************
 ********************             Common Includes                   ********************
 ********************                                               ********************
 ***************************************************************************************/
#include "math.h"
#include "stdio.h"
#include "stdlib.h"
#include "stdarg.h"
#include "limits.h"
#include "malloc.h"
#include "string.h"
#include "windows.h"

#include "cor.h"
#include "corprof.h"
#include "corhlpr.h"


/***************************************************************************************
 ********************                                               ********************
 ********************              Basic Macros                     ********************
 ********************                                               ********************
 ***************************************************************************************/
//
// alias' for COM method signatures
//
#define COM_METHOD( TYPE ) TYPE STDMETHODCALLTYPE


//
// max length for arrays
//
#define MAX_LENGTH 256


//
// debug macro for DebugBreak
//
#undef _DbgBreak
#ifdef _X86_
	#define _DbgBreak() __asm { int 3 }
#else
	#define _DbgBreak() DebugBreak()
#endif // _X86_



//
// used for debugging purposes
//
#define DEBUG_ENVIRONMENT        "DBG_PRF"


//
// basic I/O macros
//
#define DEBUG_OUT( message ) _DDebug message;
#define TEXT_OUT( message ) printf( "%s", message );
#define TEXT_OUTLN( message ) printf( "%s\n", message );


//
// trace callback methods
//
#define TRACE_CALLBACK_METHOD( message ) DEBUG_OUT( ("%s", message) )


//
// trace non-callback methods
//
#define TRACE_NON_CALLBACK_METHOD( message ) DEBUG_OUT( ("%s", message) )


#define _PRF_ERROR( message ) \
{ \
	TEXT_OUTLN( message ) \
    _LaunchDebugger( message, __FILE__, __LINE__ );	\
} \


#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE(iptr);             \
        iptr->Release();            \
        iptr = NULL;                \
    }

#define VERIFY(stmt) _ASSERTE((stmt))

#else

#define RELEASE(iptr)               \
    iptr->Release();

#define VERIFY(stmt) (stmt)

#endif

#endif // __BASICHDR_H__

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\profilerhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************************
 * File:
 *  ProfilerHelper.h
 *
 * Description:
 *
 *
 *
 ***************************************************************************************/
#ifndef __PROFILERHELPER_H__
#define __PROFILERHELPER_H__

//#include "Table.hpp"
#include "ProfilerBase.h"


/***************************************************************************************
 ********************                                               ********************
 ********************             BaseInfo Declaration              ********************
 ********************                                               ********************
 ***************************************************************************************/
class BaseInfo
{
	public:

    	BaseInfo( ULONG id );
        virtual ~BaseInfo();


	public:

        BOOL Compare( ULONG key );


 	public:

    	ULONG m_id;

}; // BaseInfo


/***************************************************************************************
 ********************                                               ********************
 ********************          FunctionInfo Declaration             ********************
 ********************                                               ********************
 ***************************************************************************************/
class FunctionInfo :
	public BaseInfo
{
	public:

		FunctionInfo( FunctionID functionID );
   		virtual ~FunctionInfo();


	public:

    	void Dump();


	public:

    	LONG m_enter;
		LONG m_left;
        ULONG m_codeSize;
        ClassID m_classID;
        ModuleID m_moduleID;
        mdToken m_functionToken;
		LPCBYTE m_pStartAddress;
        WCHAR m_functionName[MAX_LENGTH];

}; // FunctionInfo



/***************************************************************************************
 ********************                                               ********************
 ********************              PrfInfo Declaration              ********************
 ********************                                               ********************
 ***************************************************************************************/
class PrfInfo
{
    public:

        PrfInfo();
        ~PrfInfo();


    protected:

        ICorProfilerInfo *m_pProfilerInfo;


  	private:

        // tables
   }; // PrfInfo


#endif // __PROFILERHELPER_H___

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\regutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// regutil.h
//
// This module contains a set of functions that can be used to access the
// regsitry.
//
//*****************************************************************************
#ifndef __REGUTIL_H__
#define __REGUTIL_H__

//#include "BasicHdr.h"

#define NumItems(s) ( sizeof(s) / sizeof(s[0]) )

static const char*	gszKey = "Software\\Microsoft\\.NETFramework";

class REGUTIL
{
	public:

	static BOOL SetKeyAndValue( const char *szKey,
	    						const char *szSubkey,
	    						const char *szValue );

	static BOOL DeleteKey( const char *szKey,
	    				   const char *szSubkey );

	static BOOL SetRegValue( const char *szKeyName,
	    					 const char *szKeyword,
	    					 const char *szValue );

	static HRESULT RegisterCOMClass( REFCLSID rclsid,
							         const char *szDesc,
							         const char *szProgIDPrefix,
							         int iVersion,
							         const char *szClassProgID,
							         const char *szThreadingModel,
							         const char *szModule );

	static HRESULT UnregisterCOMClass( REFCLSID rclsid,
								       const char *szProgIDPrefix,
								       int iVersion,
								       const char *szClassProgID );

	private:

	static HRESULT RegisterClassBase( REFCLSID rclsid,
							          const char *szDesc,
							          const char *szProgID,
							          const char *szIndepProgID,
							          char *szOutCLSID );

	static HRESULT UnregisterClassBase( REFCLSID rclsid,
								        const char *szProgID,
								        const char *szIndepProgID,
								        char *szOutCLSID );
};


#endif // __REGUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\permview\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "permview.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Permission Request Viewer\0"
#define VER_ORIGFILENAME_STR    "permview.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\objectgraphprof\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "ilcover.exe"
#define VER_FILEDESCRIPTION_STR "Common Language Runtime exe\0"
#define VER_ORIGFILENAME_STR    "ilcover.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\permview\resources.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#define PV_ASSEMBLY                 1
#define PV_ASSERT                   2
#define PV_CLASS                    3
#define PV_DEMAND                   4
#define PV_DENY                     5
#define PV_FAILED_ALLOC_METHODS     6
#define PV_FAILED_ALLOC_TYPEDEFS    7
#define PV_FAILED_CLR_STARTUP       8
#define PV_FAILED_COM_STARTUP       9
#define PV_FAILED_COUNT_FILES       10
#define PV_FAILED_COUNT_GLOBALS     11
#define PV_FAILED_COUNT_METHODS     12
#define PV_FAILED_COUNT_TYPEDEFS    13
#define PV_FAILED_CREATE            14
#define PV_FAILED_CREATE_DISP       15
#define PV_FAILED_ENUM_FILES        16
#define PV_FAILED_ENUM_GLOBALS      17
#define PV_FAILED_ENUM_METHODS      18
#define PV_FAILED_ENUM_PSETS        19
#define PV_FAILED_ENUM_TYPEDEFS     20
#define PV_FAILED_GET_FILE_PROPS    21
#define PV_FAILED_GET_METH_PROPS    22
#define PV_FAILED_GET_PSET_PROPS    23
#define PV_FAILED_GET_TYPE_PROPS    24
#define PV_FAILED_LOCATE_IMPORT     25
#define PV_FAILED_OPEN_SCOPE        26
#define PV_INHDEMAND                27
#define PV_INVALID_ACTION           28
#define PV_INVALID_OBJ              29
#define PV_LINKTIMEDEMAND           30
#define PV_METHOD                   31
#define PV_METHOD_GLOBAL            32
#define PV_MINIMAL                  33
#define PV_MISSING_FILENAME         34
#define PV_MISSING_OUTPUT_ARG       35
#define PV_NONCAS_DEMAND            36
#define PV_NONCAS_INH               37
#define PV_NONCAS_LINKDEMAND        38
#define PV_OPTIONAL                 39
#define PV_OPTIONS                  40
#define PV_OPTNAME_DECL             41
#define PV_OPTNAME_HELP             42
#define PV_OPTNAME_OUTPUT           43
#define PV_OPT_DECL                 44
#define PV_OPT_HELP                 45
#define PV_OPT_OUTPUT               46
#define PV_PERMITONLY               47
#define PV_PREJIT_DENIED            48
#define PV_PREJIT_GRANT             49
#define PV_PSET                     50
#define PV_PSET_EMPTY               51
#define PV_PSET_NONE                52
#define PV_READ_REQUESTS            53
#define PV_REFUSED                  54
#define PV_REQMIN                   55
#define PV_REQOPT                   56
#define PV_REQREFUSE                57
#define PV_REQUEST                  58
#define PV_TITLE                    59
#define PV_USAGE                    60
#define PV_TRUNCATED_OUTPUT         61
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: main.cpp
// 
// Reads and verifies PE File Format and COM+ header using the PEverf* classes
// ===========================================================================
#include "stdpch.h"
#pragma hdrstop
#include <time.h>
#include <mscoree.h>
#include "corver.h"
#include <corhost.h>
#include "utilcode.h"
#include "PEverify.h"
#include "malloc.h"
#include "ivehandler.h"
#include "ivehandler_i.c"
#include "ivalidator.h"

#define WSZ_MSCORLIB L"mscorlib.dll"
#define SZ_MSCORLIB   "mscorlib.dll"
#define LEN_MSCORLIB (sizeof(SZ_MSCORLIB) - 1)

#define PEVERIFY_IL			0x001
#define PEVERIFY_METADATA	0x002
#define PEVERIFY_IL_ANYWAY	0x004

#define MAKE_WIDE(ptrname, utf8str) \
    long __l##ptrname; \
    LPWSTR ptrname; \
    __l##ptrname = MultiByteToWideChar(CP_ACP, 0, utf8str, -1, 0, 0); \
    ptrname = (LPWSTR) _alloca(__l##ptrname*sizeof(WCHAR));  \
    MultiByteToWideChar(CP_ACP, 0, utf8str, -1, ptrname, __l##ptrname); 

#define MAKE_ANSI(ptrname, wstr) \
    long __l##ptrname; \
    LPSTR ptrname; \
    __l##ptrname = WideCharToMultiByte(CP_ACP, 0, wstr, -1, 0, 0, NULL, NULL); \
    ptrname = (LPSTR) _alloca(__l##ptrname);  \
    if (WideCharToMultiByte(CP_ACP, 0, wstr, -1, ptrname, __l##ptrname, NULL, NULL) != __l##ptrname) \
        memset( ptrname, 0, __l##ptrname );


bool g_bQuiet;
bool g_bNoCLS;
bool g_bCLSOnly;
bool g_bUniqueOnly;
bool g_bShowHres;
bool g_bClock;
unsigned g_uMaxErrors;

unsigned g_uErrorCount;
unsigned g_uWarningCount;
HRESULT	 g_HR[16384];
HRESULT	 g_HRignore[16384];
unsigned g_uIgnoreCount;

class CVEHandler :
    public IVEHandler
{
private:
    IValidator  *m_val;
public:
    CVEHandler() : m_val(0) {}
    void SetValidator(IValidator *val) { m_val = val; }

    // *** IUnknown methods ***
    STDMETHODIMP_(ULONG) AddRef(void)
    { return E_NOTIMPL; }
    STDMETHODIMP_(ULONG) Release(void)
    { return E_NOTIMPL; }
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv) 
    { return E_NOTIMPL; }

    HRESULT STDMETHODCALLTYPE VEHandler( 
        /* [in] */ HRESULT VECode,
        /* [in] */ VEContext Context,
        /* [in] */ SAFEARRAY __RPC_FAR * psa)
    {
		for(unsigned i=0; i < g_uIgnoreCount; i++)
		{
			if(g_HRignore[i] == VECode) return S_OK;
		}
		if(g_bUniqueOnly)
		{
			for(int i=0; (i < 16384) && g_HR[i]; i++)
			{
				if(g_HR[i] == VECode) return S_OK;
			}
			g_HR[i] = VECode;
		}
        ++g_uErrorCount;
		
		if(g_bQuiet) return S_OK;

        if (m_val)
        {
#define MSG_LEN 1000
            WCHAR msg[MSG_LEN + 1];

            if (SUCCEEDED(m_val->FormatEventInfo(VECode, Context, 
                    &msg[0], MSG_LEN, psa)))
            {
                wprintf(L"[IL]");
				if(g_bShowHres) wprintf(L"(0x%08X)",VECode);
                wprintf(L": Error: ");
                fflush(stdout);
                PrintfStdOut(msg);
                wprintf(L"\n");
                return g_uErrorCount >= g_uMaxErrors ? E_FAIL : S_OK;
            }
        }

        return E_FAIL;
    }

    HRESULT STDMETHODCALLTYPE SetReporterFtn( 
        /* [in] */ __int64 lFnPtr)
    {
        return E_NOTIMPL;
    }
};



//-----------------------------------------------------------------------------
// CompactMsg
// suitable for scripts
//-----------------------------------------------------------------------------
void CompactMsg(WCHAR *pwszFilename, unsigned uNumErrors)
{
    MAKE_ANSI( pszFilename, pwszFilename );

    printf(pszFilename);

    if (uNumErrors == 0)
        printf(" PASS\n");
    else
        printf(" FAIL (%d errors)\n",uNumErrors);
}

//-----------------------------------------------------------------------------
// Error/warning reporting function, replacing the standard one of IVEHandler
//-----------------------------------------------------------------------------
HRESULT MDWarning[] = {
    VLDTR_E_TR_HASTYPEDEF,
    VLDTR_E_TD_DUPGUID,
    VLDTR_E_TD_IFACEGUIDNULL,
    VLDTR_E_TD_ENUMNOVALUE,
    VLDTR_E_TD_ENUMNOLITFLDS,
    VLDTR_E_TD_EXTTYPESPEC,
    VLDTR_E_MR_DUP,
    VLDTR_E_MR_VARARGCALLINGCONV,
    VLDTR_E_MODREF_DUP,
    VLDTR_E_TD_EXTTRRES,
    VLDTR_E_MD_MULTIPLESEMANTICS,
    VLDTR_E_MD_PARAMOUTOFSEQ,
    VLDTR_E_FMD_GLOBALITEM,
    VLDTR_E_FD_FLDINIFACE,
    VLDTR_E_FMD_BADIMPLMAP,
    VLDTR_E_AS_HASHALGID,
    VLDTR_E_AS_BADLOCALE,
    VLDTR_E_AR_PROCID,
    VLDTR_E_CT_NOTYPEDEFID
};
unsigned Nmdw = sizeof(MDWarning)/sizeof(HRESULT);
bool IsMdWarning(HRESULT hr)
{
    for(unsigned i = 0; i < Nmdw; i++) if(hr == MDWarning[i]) return true;
    return false;
}

HRESULT PEVerifyReporter( // Return status.
    LPCWSTR     szMsg,                  // Error message.
	VEContext	Context,				// Error context (offset,token)
    HRESULT		hr)						// Original HRESULT
{
	for(unsigned i=0; i < g_uIgnoreCount; i++)
	{
		if(g_HRignore[i] == hr) return S_OK;
	}

	if(g_bUniqueOnly)
	{
		for(int i=0; (i < 16384) && g_HR[i]; i++)
		{
			if(g_HR[i] == hr) return S_OK;
		}
		g_HR[i] = hr;
	}
	if(wcsstr(szMsg,L"[CLS]"))
	{
		if(g_bNoCLS) return S_OK; // ignore CLS warnings
	}
	else
	{
		if(g_bCLSOnly) return S_OK; // ignore everything but CLS warnings
	}
	if(!g_bQuiet)
	{
		if(szMsg)
		{
			wprintf(L"[MD]");
			if(g_bShowHres) wprintf(L"(0x%08X)",hr);
			wprintf(L": ");
			fflush(stdout);
			PrintfStdOut(szMsg);
			// include token and offset from Context
			if(Context.Token) wprintf(L" [token:0x%08X]",Context.Token);
			if(Context.uOffset) wprintf(L" [at:0x%X]",Context.uOffset);
			wprintf(L"\n");
		}
	}
    if(IsMdWarning(hr)) g_uWarningCount++;
    else g_uErrorCount++;
	return (g_uErrorCount >= g_uMaxErrors) ? E_FAIL : S_OK;
}

#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION

typedef HRESULT (*REPORTFCTN)(LPCWSTR, VEContext, HRESULT);

class MDVEHandlerClass : public IVEHandler
{
public: 
    SIZE_T      m_refCount;
	REPORTFCTN  m_fnReport;

    MDVEHandlerClass() { m_refCount=0; m_fnReport=PEVerifyReporter; };
    virtual ~MDVEHandlerClass() { };

    //-----------------------------------------------------------
    // IUnknown support
    //-----------------------------------------------------------
    HRESULT STDMETHODCALLTYPE    QueryInterface(REFIID id, void** pInterface) 
	{
		if (id == IID_IVEHandler)
			*pInterface = (IVEHandler*)this;
		else if (id == IID_IUnknown)
			*pInterface = (IUnknown*)(IVEHandler*)this;
		else
		{
			*pInterface = NULL;
			return E_NOINTERFACE;
		}

		AddRef();
		return S_OK;
	}
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long        refCount = InterlockedDecrement((long *) &m_refCount);
        if (refCount == 0) delete this;
        return (refCount);
    }
    //-----------------------------------------------------------
    // IVEHandler support
    //-----------------------------------------------------------
	HRESULT STDMETHODCALLTYPE	SetReporterFtn(__int64 lFnPtr)
	{
		m_fnReport = lFnPtr ? reinterpret_cast<REPORTFCTN>(lFnPtr) 
							 : PEVerifyReporter;
		return S_OK;
	};

//*****************************************************************************
// The Verification Event Handler itself. Declared in VEHandler.h as virtual, may be overridden
//*****************************************************************************
	HRESULT STDMETHODCALLTYPE VEHandler(HRESULT hrRpt, VEContext Context, SAFEARRAY *psa)
	{
	// The following code is copied from Utilcode\PostError.cpp with minor additions
		WCHAR       rcBuf[1024];             // Resource string.
		WCHAR       rcMsg[1024];             // Error message.
		va_list     marker,pval;             // User text.
		HRESULT     hr;
		VARIANT		*pVar,Var;
		ULONG		nVars,i,lVar,j,l,k;
		WCHAR		*pWsz[1024], *pwsz; // is more than 1024 string arguments likely?

		// Return warnings without text.
		if (!FAILED(hrRpt))
			return (hrRpt);
		memset(pWsz,0,sizeof(pWsz));
		// Convert safearray of variants into va_list
		if(psa && (nVars = psa->rgsabound[0].cElements))
		{
			_ASSERTE(psa->fFeatures & FADF_VARIANT);
			_ASSERTE(psa->cDims == 1);
			marker = (va_list)(new char[nVars*sizeof(double)]); // double being the largest variant element
            if (marker == NULL)
                return E_FAIL;
			for(i=0,pVar=(VARIANT *)(psa->pvData),pval=marker; i < nVars; pVar++,i++)
			{
				memcpy(&Var,pVar,sizeof(VARIANT));
				switch(Var.vt)
				{
					case VT_I1:
					case VT_UI1:	lVar = 1; break;

					case VT_I2:
					case VT_UI2:	lVar = 2; break;

					case VT_R8:
					case VT_CY:
					case VT_DATE:	lVar = 8; break;

					case VT_BYREF|VT_I1:
					case VT_BYREF|VT_UI1: // it's ASCII string, convert it to UNICODE
						lVar = 4;
						l = strlen((char *)(Var.pbVal))+1;
						pwsz = new WCHAR[l];
						if (pwsz == NULL)
							return E_FAIL;
						for(j=0; j<l; j++) pwsz[j] = Var.pbVal[j];
						for(k=0; pWsz[k]; k++);
						pWsz[k] = pwsz;
						Var.piVal = (short *)pwsz;
						break;

					default:		lVar = 4; break;
				}
				memcpy(pval,&(Var.bVal),lVar);
				pval += (lVar + sizeof(int) - 1) & ~(sizeof(int) - 1); //From STDARG.H: #define _INTSIZEOF(n)
			}
		}
		else
			marker = NULL;

		// If this is one of our errors, then grab the error from the rc file.
		if (HRESULT_FACILITY(hrRpt) == FACILITY_URT)
		{
			hr = LoadStringRC(LOWORD(hrRpt), rcBuf, NumItems(rcBuf), true);
			if (hr == S_OK)
			{
				// Format the error.
				if (marker != NULL)
					_vsnwprintf(rcMsg, NumItems(rcMsg), rcBuf, marker);
				else
					_snwprintf(rcMsg, NumItems(rcMsg), rcBuf);
				rcMsg[NumItems(rcMsg) - 1] = 0;
			}
		}
		// Otherwise it isn't one of ours, so we need to see if the system can
		// find the text for it.
		else
		{
			if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
					0, hrRpt, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					rcMsg, NumItems(rcMsg), 0))
			{
				hr = S_OK;

				// System messages contain a trailing \r\n, which we don't want normally.
				int iLen = lstrlenW(rcMsg);
				if (iLen > 3 && rcMsg[iLen - 2] == '\r' && rcMsg[iLen - 1] == '\n')
					rcMsg[iLen - 2] = '\0';
			}
			else
				hr = HRESULT_FROM_WIN32(GetLastError());
		}
		if(marker) delete marker;

		// If we failed to find the message anywhere, then issue a hard coded message.
		if (FAILED(hr))
		{
			swprintf(rcMsg, L".NET Framework Internal error: 0x%08x", hrRpt);
			//DEBUG_STMT(DbgWriteEx(rcMsg));
		}

		// delete WCHAR buffers allocated above (if any)
		for(k=0; pWsz[k]; k++) delete pWsz[k];

		return (m_fnReport(rcMsg, Context,hrRpt) == S_OK ? S_OK : E_FAIL);
	};

    static HRESULT STDMETHODCALLTYPE CreateObject(REFIID id, void **object)
    { return E_NOTIMPL; }
};

#endif

#define ERRORMAX 100
//-----------------------------------------------------------------------------
// VerifyPEformat (driver function for file format verification)
// returns true if the file correctly verifies
//-----------------------------------------------------------------------------
bool VerifyPEformat(WCHAR *pwszFilename, DWORD dwFlags, bool quiet)
{
    bool retval = false;
    HRESULT hr = S_OK;
    if (FAILED(hr = CoInitialize(NULL))) {
        printf("Failed to initialize COM, error %08X\n", hr);
        return retval;
    }
	bool bILverified = false;

    MAKE_ANSI( pszFilename, pwszFilename );

	clock_t cBegin=0,cEnd=0,cMDBegin=0,cMDEnd=0,cMDVBegin=0,cMDVEnd=0,cILBegin=0,cILEnd=0,cILVBegin=0,cILVEnd=0;

	if(g_bClock) cBegin = clock();

	g_bQuiet = quiet;

	g_uErrorCount = 0;
	g_uWarningCount = 0;
    if (dwFlags & PEVERIFY_METADATA)
    { // Meta Data Validation Segment:
        IMetaDataDispenserEx *pDisp;
        IMetaDataImport *pImport;
        IMetaDataValidate *pValidate = 0;
#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
		MDVEHandlerClass	*pVEHandler = 0;
#else
        IVEHandler  *pVEHandler = 0;
#endif
        const char *szErrStr = 0;
		if(g_bClock) cMDBegin = clock();

		g_uErrorCount = 1; // just in case we don't make it to ValidateMetaData
        if(SUCCEEDED(hr = CoCreateInstance(CLSID_CorMetaDataDispenser, 
                      NULL, CLSCTX_INPROC_SERVER, 
                      IID_IMetaDataDispenserEx, (void **) &pDisp)))
        {
            if(SUCCEEDED(hr = pDisp->OpenScope(pwszFilename,0,
                        IID_IMetaDataImport, (IUnknown**)&pImport)))
            {
                if(SUCCEEDED(hr=pImport->QueryInterface(IID_IMetaDataValidate, 
                    (void**) &pValidate)))
                {
#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
					if(pVEHandler = new MDVEHandlerClass())
#else
                    if(SUCCEEDED(hr = CoCreateInstance(CLSID_VEHandlerClass,
                                                        NULL,
                                                        CLSCTX_INPROC_SERVER,
                                                        IID_IVEHandler,
                                                        (void **)&pVEHandler)))
#endif
                    {
                        pVEHandler->SetReporterFtn((__int64)PEVerifyReporter);

                        if(SUCCEEDED(hr = pValidate->ValidatorInit(
                            ValidatorModuleTypePE,  pVEHandler)))
                        {
							g_uErrorCount = 0;
							if(g_bClock) cMDVBegin = clock();
                            hr = pValidate->ValidateMetaData();
							if(g_bClock) cMDVEnd = clock();
							retval = (g_uErrorCount == 0);
                        }
                        else
                            printf("Unable to initialize the Validator:%08X\n",hr);

#ifndef EXTERNAL_VE_HANDLER_FOR_MD_VALIDATION
                    }
                    else
                        printf("Unable to create VEHandlerClass\n");
#else
                        pVEHandler->Release();
                    }
                    else
                        printf("Unable to CoCreateInstance of IVEHandler:%08X\n",hr);
#endif
                    pValidate->Release();
                }
                else
                    printf("Unable to get IMetaDataValidate:%08X\n",hr);

                pImport->Release();
            }
            else
                printf("Unable to OpenScopeOnMemory for IMetaDataImport:%08X\n", hr); 
            pDisp->Release();
        }
        else
            printf("Unable to CoCreate Meta-data Dispenser:%08X\n", hr); 
		if(g_bClock) cMDEnd = clock();
    }  // End Of Meta Data Validation Segment
    
    if (((dwFlags & PEVERIFY_IL)&&(g_uErrorCount == 0))
		||((dwFlags & PEVERIFY_IL_ANYWAY)&&(g_uMaxErrors > g_uErrorCount)))
    {
        CVEHandler  veh;
        ICorRuntimeHost *pCorHost;
        pCorHost = NULL;
	
		bILverified = true;
		if(g_bClock) cILBegin = clock();

        // Here we are going to get the hosting interface to the runtime and get 
        // it to verify the methods.
        hr =  CoCreateInstance(CLSID_CorRuntimeHost,
                NULL,CLSCTX_INPROC_SERVER,
                IID_ICorRuntimeHost,
                (void**)&pCorHost);
    
        if (FAILED(hr)) {
            printf ("Errors Instantiating .NET Framework\n");
            goto Exit;
        }
    
        hr = pCorHost->Start();
    
        if(FAILED(hr)) {
            printf("Error starting .NET Framework\n");
            goto Exit;
        }
    
#ifdef PEVERIFY_USE_CORHOST_
        LONG naryErrors[ERRORMAX];
	    DWORD errorCount;
	    
		errorCount = 0;
        ZeroMemory(naryErrors, sizeof(naryErrors));
    
        hr = pCorHost->
            VerifyAssemblyFile(pwszFilename, naryErrors, ERRORMAX, &errorCount);
        g_uErrorCount += errorCount;
#else
        IValidator  *pVal;
        HANDLE      hFile, hMapping;
        PBYTE       pFile;
        DWORD       dwFileSize, dwHigh;

        pVal        = NULL;
        pFile       = NULL;
        hMapping    = NULL;
        hFile       = INVALID_HANDLE_VALUE;
        dwFileSize  = dwHigh = 0;

        hFile = WszCreateFile(
            pwszFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_RANDOM_ACCESS,
            NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = GetLastError();
			printf("Could not open file '%s' error:0x%08X\n",pszFilename,hr);
			g_uErrorCount++;
            goto exit_val;
        }

        // Get the file size
    
        dwFileSize = ::GetFileSize(hFile, &dwHigh);
    
        if ((dwFileSize == 0xFFFFFFFF) && (hr = (GetLastError() != NO_ERROR)))
        {
			printf("Could not get size of file '%s' error:0x%08X\n",pszFilename,hr);
			g_uErrorCount++;
            goto exit_val;
        }
    
        if (dwHigh != 0)
        {
            hr = E_FAIL;
            printf("File too big !\n");
        }

        hMapping = WszCreateFileMapping(
            hFile,
            NULL,
            PAGE_READONLY,
            0,
            0,
            NULL);

        if (hMapping == NULL)
        {
            hr = GetLastError();
			printf("Could not create mapping for file '%s' error:0x%08X\n",pszFilename,hr);
			g_uErrorCount++;
            goto exit_val;
        }

        pFile = (PBYTE) MapViewOfFile(
            hMapping,
            FILE_MAP_READ,
            0,
            0,
            0);


        if (pFile == NULL)
        {
            hr = GetLastError();
			printf("Could not map the file '%s' error:0x%08X\n",pszFilename,hr);
			g_uErrorCount++;
            goto exit_val;
        }

        // CorHost requires full path.
        WCHAR wszFullPath[_MAX_PATH + 1];
        BOOL fFullName;

        fFullName = (BOOL) WszGetFullPathName(
                            pwszFilename,  _MAX_PATH,  wszFullPath,  NULL);

        wszFullPath[_MAX_PATH] = 0;

        hr = pCorHost->QueryInterface(IID_IValidator, (void **)&pVal);

        if (FAILED(hr))
		{
			printf("Could not get IValidator interface error:0x%08X\n",hr);
			g_uErrorCount++;
            goto exit_val;
		}

        // All error exits from here on will be to Exit_val:

        veh.SetValidator(pVal);
	
		if(g_bClock) cILVBegin = clock();

        hr = pVal->Validate(
            &veh, 
            NULL, 
            0, 
            g_uMaxErrors - g_uErrorCount, 
            0, 
            fFullName ? wszFullPath : pwszFilename, 
            pFile, 
            dwFileSize);

		if(g_bClock) cILVEnd = clock();

exit_val:
        if (pFile != NULL)
            UnmapViewOfFile(pFile);

        if (hMapping != NULL)
            CloseHandle(hMapping);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        if (pVal)
            pVal->Release();

#endif
Exit:
        if (pCorHost)
            pCorHost->Release();
		if(g_bClock) cILEnd = clock();
    }

    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            printf("\nVerifyPEformat: Error Opening file\n");
        }

#ifdef PEVERIFY_USE_CORHOST_
		if(errorCount == 0)
		{
			if(bILverified)
			{
				if(!quiet) printf("\nIL verification failed: 0x%08X\n",hr);
				g_uErrorCount++;
			}
		}
#endif
	}

	retval = (g_uErrorCount == 0);

	if (quiet) {
		CompactMsg(pwszFilename, g_uErrorCount);
	}
	else {

#ifdef PEVERIFY_USE_CORHOST_
		for(DWORD i = 0; i < errorCount; i++) {
			printf("Error: %x\n", naryErrors[i]);
		}

		if (errorCount > 0)
			printf("\n");
#endif
		if(retval)
			printf("All Classes and Methods in %s Verified\n",pszFilename);
		else
			printf("%d Errors Verifying %s\n",g_uErrorCount,pszFilename);
		if(g_uWarningCount) printf("(%d Warnings)\n",g_uWarningCount);
	}

    CoUninitialize();
	if(g_bClock)
	{
		cEnd = clock();
		printf("Timing: Total run     %d msec\n",((cEnd-cBegin)*1000)/CLOCKS_PER_SEC);
		if(dwFlags & PEVERIFY_METADATA)
		{
			printf("        MD Val.cycle  %d msec\n",((cMDEnd-cMDBegin)*1000)/CLOCKS_PER_SEC);
			printf("        MD Val.pure   %d msec\n",((cMDVEnd-cMDVBegin)*1000)/CLOCKS_PER_SEC);
		}
		if(bILverified)
		{
			printf("        IL Ver.cycle  %d msec\n",((cILEnd-cILBegin)*1000)/CLOCKS_PER_SEC);
			printf("        IL Ver.pure   %d msec\n",((cILVEnd-cILVBegin)*1000)/CLOCKS_PER_SEC);
		}
	}

    return retval;
}

//-----------------------------------------------------------------------------
// Usage
//-----------------------------------------------------------------------------
//#define CLS_OPTIONS_ENABLED
void Usage()
{
    printf("Usage: PEverify <image file> [Options]\n\n");
    printf("\nOptions:");
    printf("\n/IL           Verify only the PE structure and IL");
    printf("\n/MD           Verify only the PE structure and MetaData");
#ifdef CLS_OPTIONS_ENABLED
    printf("\n/CLS          Verify only the PE structure and CLS compliance");
    printf("\n/NOCLS        Verify only the PE structure and MetaData, w/o CLS compliance");
#endif
    printf("\n/UNIQUE       Disregard repeating error codes");
    printf("\n/HRESULT      Display error codes in hex format");
    printf("\n/CLOCK        Measure and report verification times");
    printf("\n/IGNORE=<hex.code>[,<hex.code>...]  Ignore specified error codes");
    printf("\n/IGNORE=@<file name>                Ignore error codes specified in <file name>");
    printf("\n/BREAK=<maxErrorCount>              Abort verification after <maxErrorCount> errors");
    printf("\n                                    (unspecified or <=0 <maxErrorCount> means 1 error)");
    printf("\n/QUIET        Display only file and Status. Do not display all errors.\n");
    printf("Note: By default, MD is verified and then if there were no errors - IL is verified.\n");
    printf("      if /MD /IL options are specified, IL is verified even if there were MD verification errors.\n");
}


static FILE* PEVerifyFOpen( const WCHAR *filename, const WCHAR *mode )
{
    if (GetVersion() < 0x80000000)
    {
        return _wfopen( filename, mode );
    }
    else
    {
        MAKE_ANSI( szFileName, filename );
        MAKE_ANSI( szMode, mode );

        return fopen( szFileName, szMode );
    }
}

//-----------------------------------------------------------------------------
// main
//-----------------------------------------------------------------------------
extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    bool    quiet = false;
    bool    logo = true;
    DWORD   dwFlags = 0;
    int     filenameIndex = -1;
	WCHAR*	pch;
	WCHAR*   mscorlib;
    bool    fCheckMscorlib = true;
    int     offset;
	bool	fInvalidOption = false;

    OnUnicodeSystem();      // Init the Wsz Wrappers.

	g_bCLSOnly = false;
#ifdef CLS_OPTIONS_ENABLED
	g_bNoCLS = false;
#else
	g_bNoCLS = true;
#endif
	g_bUniqueOnly = false;
	g_bShowHres = false;
	g_bClock = false;
	g_uMaxErrors = 0xFFFFFFFF;
	memset(g_HR,0,sizeof(g_HR));
	memset(g_HRignore,0,sizeof(g_HRignore));
	g_uIgnoreCount = 0;

    for (int i=1; i<argc; ++i)
    {
        if ((*(argv[i]) != L'/') && (*(argv[i]) != L'-'))
            filenameIndex = i;        
        else if ((_wcsicmp(argv[i], L"/?") == 0) ||
                 (_wcsicmp(argv[i], L"-?") == 0))
		{
			printf("\nMicrosoft (R) .NET Framework PE Verifier.  Version " VER_FILEVERSION_STR);
			printf("\n%S\n\n", VER_LEGALCOPYRIGHT_DOS_STR);
			Usage();
			exit(0);
		}
        else if ((_wcsicmp(argv[i], L"/QUIET") == 0) ||
                 (_wcsicmp(argv[i], L"-QUIET") == 0))
                     quiet = true;
        else if ((_wcsicmp(argv[i], L"/nologo") == 0) ||
                 (_wcsicmp(argv[i], L"-nologo") == 0))
                     logo = false;
        else if ((_wcsicmp(argv[i], L"/IL") == 0) ||
                 (_wcsicmp(argv[i], L"-IL") == 0))
                     dwFlags |= PEVERIFY_IL | PEVERIFY_IL_ANYWAY;
        else if ((_wcsicmp(argv[i], L"/MD") == 0) ||
                 (_wcsicmp(argv[i], L"-MD") == 0))
                     dwFlags |= PEVERIFY_METADATA;
#ifdef CLS_OPTIONS_ENABLED
        else if ((_wcsicmp(argv[i], L"/CLS") == 0) ||
                 (_wcsicmp(argv[i], L"-CLS") == 0))
                     g_bCLSOnly = true;
        else if ((_wcsicmp(argv[i], L"/NOCLS") == 0) ||
                 (_wcsicmp(argv[i], L"-NOCLS") == 0))
                     g_bNoCLS = true;
#endif
        else if ((_wcsicmp(argv[i], L"/UNIQUE") == 0) ||
                 (_wcsicmp(argv[i], L"-UNIQUE") == 0))
                     g_bUniqueOnly = true;
        else if ((_wcsicmp(argv[i], L"/HRESULT") == 0) ||
                 (_wcsicmp(argv[i], L"-HRESULT") == 0))
                     g_bShowHres = true;
        else if ((_wcsicmp(argv[i], L"/CLOCK") == 0) ||
                 (_wcsicmp(argv[i], L"-CLOCK") == 0))
                     g_bClock = true;
        else if ((_wcsnicmp(argv[i], L"/BREAK",6) == 0) ||
                 (_wcsnicmp(argv[i], L"-BREAK",6) == 0))
		{
            g_uMaxErrors = 1;
			pch = wcschr(argv[i],L'=');
			if(pch)
			{
				int dummy;
                swscanf( pch+1, L"%d", &dummy );
				if(dummy > 1) g_uMaxErrors=(unsigned)dummy;
			}
		}
        else if ((_wcsnicmp(argv[i], L"/IGNORE",7) == 0) ||
                 (_wcsnicmp(argv[i], L"-IGNORE",7) == 0))
		{
			pch = wcschr(argv[i],L'=');
			if(pch)
			{
				WCHAR* pch1 = pch;
				if(*(pch+1) == L'@')
				{
					if(wcslen(pch+2))
					{
						FILE* pF = PEVerifyFOpen(pch+2,L"rt");
						if(pF)
						{
							char sz[2048];
							unsigned dummy;
							while(!feof(pF))
							{
								memset(sz,0,2048);
								fgets(sz,2048,pF);
								char *spch1 = &sz[0] - 1;
								do
								{
									char* spch = spch1+1;
									spch1 = strchr(spch, ',');
									if(spch1) *spch1 = 0;
									dummy = atoi( spch );
									if(!dummy) sscanf(spch,"%x",&dummy);
									if(dummy)
									{
										g_HRignore[g_uIgnoreCount++] = dummy;
										//printf("0x%08x\n",g_HRignore[g_uIgnoreCount-1]);
									}
								} while(spch1);
							}
							fclose(pF);
						}
						else
							printf("Failed to open file '%s'\n",pch+2);
					}
					else
					{
						printf("Invalid option: %S \n\n",argv[i]);
						fInvalidOption = true;
					}
				}
				else
				{
					do
					{
						pch = pch1+1;
						pch1 = wcschr(pch, ',');
						if(pch1) *pch1 = 0;
						swscanf(pch,L"%x",&g_HRignore[g_uIgnoreCount++]);
						//printf("0x%08x\n",g_HRignore[g_uIgnoreCount-1]);
					} while(pch1);
				}
			}
		}
		else
		{
			printf("Invalid option: %S \n\n",argv[i]);
			fInvalidOption = true;
		}
    }

    if (dwFlags == 0)
        dwFlags = PEVERIFY_METADATA | PEVERIFY_IL;

	if(!(dwFlags & PEVERIFY_METADATA))
	{
		g_bCLSOnly = false;
		g_bNoCLS = false;
	}
    if (!quiet && logo)
    {
        printf("\nMicrosoft (R) .NET Framework PE Verifier  Version " VER_FILEVERSION_STR);
        printf("\n%S\n\n", VER_LEGALCOPYRIGHT_DOS_STR);
    }

    if (argc < 2 || filenameIndex < 1 || fInvalidOption)
    {
        Usage();
        exit(argc<2? 0:1);
    }

    // PEVerify cannot be used to verify some system libraries.
    // compare with ignorecase the last LEN_OF_MSCORLIB chars will be sufficient

    if ((dwFlags&PEVERIFY_IL) != 0)
    {
        offset = wcslen(argv[filenameIndex]) - LEN_MSCORLIB;
    
        if (offset >= 0)
        {
            mscorlib = argv[filenameIndex];
    
            if (offset > 0)
            {
                // check for files names that end with mscorlib.dll, 
                // but not mscorlib.dll eg. MyMscorlib.dll
                if ((mscorlib[offset - 1] != '.') &&
                    (mscorlib[offset - 1] != '\\') &&
                    (mscorlib[offset - 1] != '/'))
                    fCheckMscorlib = false;
    
                // let my.mscorlib.dll go thru.., but prevent .mscorlib.dll
                if ((mscorlib[offset - 1] == '.') && (offset != 1))
                    fCheckMscorlib = false;
    
                mscorlib += offset;
            }
    
            if (fCheckMscorlib && _wcsicmp(mscorlib, WSZ_MSCORLIB) == 0)
            {
                printf("IL Verification cannot be performed on system library %S\n", argv[filenameIndex]);
                if(dwFlags & PEVERIFY_METADATA) dwFlags = PEVERIFY_METADATA;
				else exit(1);
            }
        }
    }

    if (!VerifyPEformat(argv[filenameIndex], dwFlags, quiet))
        exit(1);

    exit(0);        // return success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\peverf32.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: PEverf32.CPP
// 
// Class PEverf32 
// ===========================================================================

#include "PEverf32.h"


// A Helper to determine if we are running on Win95
inline BOOL RunningOnWin95()
{
	OSVERSIONINFOA	sVer;
	sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionExA(&sVer);
	return (sVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}



//-----------------------------------------------------------------------------
// Class PEverify constructors and destructor
//-----------------------------------------------------------------------------
PEverf32::PEverf32()
{
    m_hFile    = NULL;
    m_hMapFile = NULL;
    m_lpMapAddress = NULL;
    m_nDOSErrors   = 0;
    m_nNTstdErrors = 0;
    m_nNTpeErrors  = 0;
}


HRESULT PEverf32::Init(char *pszFilename)
{
    return openFile(pszFilename);
}


PEverf32::~PEverf32()
{
    // We should close the files we opened ourselves
    if (m_hFile)
        this->closeFile();
}


//-----------------------------------------------------------------------------
// closeFile - closes file handles etc.
//-----------------------------------------------------------------------------
void PEverf32::closeFile()
{
    //We need to unmap the view and then closehandle
    if (m_lpMapAddress)
    {
        UnmapViewOfFile(m_lpMapAddress);
        m_lpMapAddress = NULL;
    }
    if (m_hMapFile)
    {
        CloseHandle(m_hMapFile);
        m_hMapFile = NULL;
    }
    if (m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
}


//-----------------------------------------------------------------------------
// openFile - maps pszFilename to memory
//-----------------------------------------------------------------------------
HRESULT PEverf32::openFile(char *pszFilename)
{
    // If we are on NT then the following form of file mapping works just fine.  On W95 it does not!
    m_hFile = CreateFile(pszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (m_hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());
    if(!RunningOnWin95())
    {
        m_hMapFile = CreateFileMapping(m_hFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, "PEverifyMapFile");
        if (m_hMapFile == NULL)
            return HRESULT_FROM_WIN32(GetLastError());
    
        m_lpMapAddress = MapViewOfFile(m_hMapFile, FILE_MAP_READ, 0, 0, 0);
        if (m_lpMapAddress == NULL)
            return HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        if (!LoadImageW9x())
            return E_FAIL;
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// verifyPE - verifies the DOS and PE headers
//-----------------------------------------------------------------------------
BOOL PEverf32::verifyPE()
{
    _ASSERTE(m_lpMapAddress);

    // Get the DOS and NT headers
    m_pDOSheader = (IMAGE_DOS_HEADER*) m_lpMapAddress;

    m_pNTheader  = (IMAGE_NT_HEADERS*) (m_pDOSheader->e_lfanew + (DWORD) m_lpMapAddress);
        //***************** why not this (m_lpMapAddress + 0x3c);

    // Verify DOS Header
    if (m_pDOSheader->e_magic != IMAGE_DOS_SIGNATURE)
        m_nDOSErrors |= 0x1;

    if (m_pDOSheader->e_lfanew == 0)
        m_nDOSErrors |= 0x40000;

    // Verify NT Standard Header
    if (m_pNTheader->Signature != IMAGE_NT_SIGNATURE)
        m_nNTstdErrors |= 0x1;
/*
    if (m_pNTheader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)
        m_nNTstdErrors |= 0x2;
*/
    if (m_pNTheader->FileHeader.NumberOfSections > 16)
        m_nNTstdErrors |= 0x4;

    if (m_pNTheader->FileHeader.PointerToSymbolTable != 0)
        m_nNTstdErrors |= 0x10;

    if (m_pNTheader->FileHeader.NumberOfSymbols != 0)
        m_nNTstdErrors |= 0x20;

    if (m_pNTheader->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER)
        m_nNTstdErrors |= 0x40;

    // TODO: Verify the Characteristics for IL only EXE and IL only DLL

    // Verify NT Optional (required for COM+ image) Header.  Also known as PE Header
    if (m_pNTheader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)
        m_nNTpeErrors |= 0x1;

    if (m_pNTheader->OptionalHeader.ImageBase % 64 != 0)
        m_nNTpeErrors |= 0x200;

    if (m_pNTheader->OptionalHeader.SectionAlignment < m_pNTheader->OptionalHeader.FileAlignment)
        m_nNTpeErrors |= 0x400;


    int nFileAlignment = m_pNTheader->OptionalHeader.FileAlignment;
    
    if (nFileAlignment < 512 || nFileAlignment > 65536)
        m_nNTpeErrors |= 0x800;
    else 
    {
        while (nFileAlignment > 512)
            nFileAlignment /= 2;

        if (nFileAlignment != 512)
            m_nNTpeErrors |= 0x800;
    }  // else


    if (m_pNTheader->OptionalHeader.SizeOfImage % m_pNTheader->OptionalHeader.SectionAlignment != 0)
        m_nNTpeErrors |= 0x80000;
    
    if (m_pNTheader->OptionalHeader.SizeOfHeaders % m_pNTheader->OptionalHeader.FileAlignment != 0)
        m_nNTpeErrors |= 0x100000;

    if(m_pNTheader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].Size == 0)    
        m_COMPlusErrors |= 0x1;
/*
    LPDWORD HeaderSum;
    LPDWORD CheckSum;
    PIMAGE_NT_HEADERS pNThdr;
    
    pNThdr = CheckSumMappedFile(m_lpMapAddress, m_pNTheader->OptionalHeader.SizeOfImage, HeaderSum, CheckSum);
    if (HeaderSum != CheckSum)
        m_nNTpeErrors |= 0x200000;


    if (m_pNTheader->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_WINDOWS_GUI)
        m_nNTpeErrors |= 0x400000;
*/
    

    if (m_nDOSErrors == 0 && m_nNTstdErrors == 0 && m_nNTpeErrors == 0)
        return TRUE;

    return FALSE;
}

// This is a helper that will map in the PE and close up the gap between the PE header info and the sections.

BOOL PEverf32::LoadImageW9x()
{    
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS ntHeader;
    IMAGE_SECTION_HEADER shLast;
    IMAGE_SECTION_HEADER* rgsh;
    DWORD cbRead;
    DWORD cb;
    int i;
    

  if((ReadFile(m_hFile, &dosHeader, sizeof(dosHeader), &cbRead, NULL) != 0) &&
    (cbRead == sizeof(dosHeader)) &&
    (dosHeader.e_magic == IMAGE_DOS_SIGNATURE) &&
    (dosHeader.e_lfanew != 0) &&
    (SetFilePointer(m_hFile, dosHeader.e_lfanew, NULL, FILE_BEGIN) != 0xffffffff) &&
    (ReadFile(m_hFile, &ntHeader, sizeof(ntHeader), &cbRead, NULL) != 0) &&
    (cbRead == sizeof(ntHeader)) &&
    (ntHeader.Signature == IMAGE_NT_SIGNATURE) &&
    (ntHeader.FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
    (ntHeader.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC))
  {
        if((SetFilePointer(m_hFile, dosHeader.e_lfanew + sizeof(ntHeader) +
          (ntHeader.FileHeader.NumberOfSections - 1)*sizeof(shLast), NULL, FILE_BEGIN) == 0xffffffff) ||
          (ReadFile(m_hFile, &shLast, sizeof(shLast), &cbRead, NULL) == 0) ||
          (cbRead != sizeof(shLast)))
            return FALSE;

        cb = shLast.VirtualAddress + shLast.SizeOfRawData;

        // create our swap space in the system swap file
        m_hMapFile = CreateFileMapping((HANDLE)0xffffffff, NULL, PAGE_READWRITE, 0, cb, NULL);
        if (m_hMapFile == NULL)
            return FALSE;

        /* Try to map the image at the preferred base address */
        m_lpMapAddress = (HINSTANCE) MapViewOfFileEx(m_hMapFile, FILE_MAP_WRITE, 0, 0, cb, (PVOID)ntHeader.OptionalHeader.ImageBase);
        if (m_lpMapAddress == NULL)
        {
           //That didn't work; maybe the preferred address was taken. Try to
           //map it at any address.
            m_lpMapAddress = (HINSTANCE) MapViewOfFileEx(m_hMapFile, FILE_MAP_WRITE, 0, 0, cb, (PVOID)NULL);
        }

        if (m_lpMapAddress == NULL)
            return FALSE;

        // copy in data from hFile

        cb = dosHeader.e_lfanew + sizeof(ntHeader) +
             sizeof(IMAGE_SECTION_HEADER)*ntHeader.FileHeader.NumberOfSections;

        if ((SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) == 0xffffffff) ||
           (ReadFile(m_hFile, (LPVOID)(m_lpMapAddress), cb, &cbRead, NULL) == 0) ||
           (cbRead != cb))
            return FALSE;

        rgsh = (IMAGE_SECTION_HEADER*) ((PBYTE)(m_lpMapAddress) + dosHeader.e_lfanew + sizeof(ntHeader));

        // now let's loop for each loadable sections
        for (i=0;i<ntHeader.FileHeader.NumberOfSections; i++)
        {
            DWORD loff, cbVirt, cbPhys, dwAddr;

            loff   = rgsh[i].PointerToRawData;
            cbVirt = rgsh[i].Misc.VirtualSize;
            cbPhys = min(rgsh[i].SizeOfRawData, cbVirt);
            dwAddr = (DWORD) rgsh[i].VirtualAddress + (DWORD) m_lpMapAddress;

            // read in cbPhys of the page.  The rest will be zero filled...
            if ((SetFilePointer(m_hFile, loff, NULL, FILE_BEGIN) == 0xffffffff) ||
            (ReadFile(m_hFile, (LPVOID)dwAddr, cbPhys, &cbRead, NULL) == 0) ||
            (cbRead != cbPhys))
                return FALSE;
        }

        return TRUE;
    }
    return FALSE;
}


void PEverf32::getErrors(unsigned int *naryErrors)
{
    naryErrors[0] = m_nDOSErrors;
    naryErrors[1] = m_nNTstdErrors;
    naryErrors[2] = m_nNTpeErrors;
    naryErrors[3] = m_COMPlusErrors;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\permview\permview.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//

#include <winwrap.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>
#include <cor.h>
#include <corperm.h>
#include <corver.h>
#include <__file__.ver>
#include <resources.h>


#define MAX_CLASSNAME_LENGTH    1024


// Loaded string resources.
LPWSTR g_szAssemblyString = NULL;
LPWSTR g_szClassString = NULL;
LPWSTR g_szMethodString = NULL;
LPWSTR g_szMethodGlobalString = NULL;
LPWSTR g_szRequestString = NULL;
LPWSTR g_szDemandString = NULL;
LPWSTR g_szAssertString = NULL;
LPWSTR g_szDenyString = NULL;
LPWSTR g_szPermitOnlyString = NULL;
LPWSTR g_szLinktimeDemandString = NULL;
LPWSTR g_szInhDemandString = NULL;
LPWSTR g_szReqMinString = NULL;
LPWSTR g_szReqOptString = NULL;
LPWSTR g_szReqRefuseString = NULL;
LPWSTR g_szPrejitGrantString = NULL;
LPWSTR g_szPrejitDeniedString = NULL;
LPWSTR g_szNonCasDemandString = NULL;
LPWSTR g_szNonCasLinkDemandString = NULL;
LPWSTR g_szNonCasInhString = NULL;
LPWSTR g_szMinimalString = NULL;
LPWSTR g_szOptionalString = NULL;
LPWSTR g_szRefusedString = NULL;
LPWSTR g_szOptOutputString = NULL;
LPWSTR g_szOptDeclString = NULL;
LPWSTR g_szOptHelpString = NULL;


// Various routines for formatting and writing messages to a file or console.
void Output(HANDLE hFile, LPWSTR szFormat, va_list pArgs)
{
    DWORD   dwLength;
    LPSTR   szMessage;
    DWORD   dwWritten;

    if (OnUnicodeSystem()) {
        WCHAR  szBuffer[8192];
        if (_vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), szFormat, pArgs) == -1) {
            WCHAR   szWarning[256];
            if (WszLoadString(NULL, PV_TRUNCATED_OUTPUT, szWarning, sizeof(szWarning) / sizeof(WCHAR)))
                wcscpy(&szBuffer[(sizeof(szBuffer) / sizeof(WCHAR)) - wcslen(szWarning) - 1], szWarning);
        }
        szBuffer[(sizeof(szBuffer) / sizeof(WCHAR)) - 1] = L'\0';

        dwLength = (wcslen(szBuffer) + 1) * 3;
        szMessage = (LPSTR)_alloca(dwLength);
        WszWideCharToMultiByte(GetConsoleOutputCP(), 0, szBuffer, -1, szMessage, dwLength - 1, NULL, NULL);
    } else {
        char   *szAnsiFormat;
        size_t  i;

        // Win9X has broken _vsnwprintf support. Sigh. Narrow the format string
        // and convert any %s format specifiers to %S. Ack.
        dwLength = (wcslen(szFormat) + 1) * 3;
        szAnsiFormat = (char*)_alloca(dwLength);
        WszWideCharToMultiByte(GetConsoleOutputCP(), 0, szFormat, -1, szAnsiFormat, dwLength - 1, NULL, NULL);
        for (i = 0; i < strlen(szAnsiFormat); i++)
            if (szAnsiFormat[i] == '%' && szAnsiFormat[i + 1] == 's')
                szAnsiFormat[i + 1] = 'S';

        szMessage = (LPSTR)_alloca(1024);

        _vsnprintf(szMessage, 1024, szAnsiFormat, pArgs);
        szMessage[1023] = '\0';
    }

    if (hFile == NULL)
        hFile = GetStdHandle(STD_OUTPUT_HANDLE);

    WriteFile(hFile, szMessage, strlen(szMessage), &dwWritten, NULL);
}

void Output(HANDLE hFile, LPWSTR szFormat, ...)
{
    va_list pArgs;

    va_start(pArgs, szFormat);
    Output(hFile, szFormat, pArgs);
    va_end(pArgs);
}

void Output(HANDLE hFile, DWORD dwResId, ...)
{
    va_list pArgs;
    WCHAR   szFormat[1024];

    if (WszLoadString(NULL, dwResId, szFormat, sizeof(szFormat)/sizeof(WCHAR))) {
        va_start(pArgs, dwResId);
        Output(hFile, szFormat, pArgs);
        va_end(pArgs);
    }
}


void Title()
{
    Output(NULL, PV_TITLE, VER_FILEVERSION_WSTR);
    Output(NULL, L"\r\n" VER_LEGALCOPYRIGHT_DOS_STR);
    Output(NULL, L"\r\n\r\n");
}


void Usage()
{
    Output(NULL, PV_USAGE);
    Output(NULL, PV_OPTIONS);
    Output(NULL, PV_OPT_OUTPUT);
    Output(NULL, PV_OPT_DECL);
    Output(NULL, PV_OPT_HELP);
    Output(NULL, L"\r\n\r\n");
}


// Get a string based from a resource ID. Deallocate the returned string with
// delete [].
LPWSTR GetString(DWORD dwResId)
{
    WCHAR   szString[1024];

    if (WszLoadString(NULL, dwResId, szString, sizeof(szString)/sizeof(WCHAR))) {
        LPWSTR szRet = new WCHAR[wcslen(szString) + 1];
        if (szRet != NULL)
            wcscpy(szRet, szString);
        return szRet;
    } else
        return NULL;
}


// Output a permission set to the console or a file.
HRESULT OutputPermissionSet(BYTE   *pbPSet,
                            DWORD   cbPSet,
                            HANDLE  hFile,
                            LPWSTR  szName)
{
    WCHAR      *szString;

    // Check whether a permission set has been supplied.
    if (pbPSet && cbPSet) {

        // Move output to a nul terminated buffer.
        szString = (LPWSTR)_alloca(cbPSet + sizeof(WCHAR));
        memcpy(szString, pbPSet, cbPSet);
        szString[cbPSet / sizeof(WCHAR)] = L'\0';

        // Output data.
        Output(hFile, PV_PSET, szName, szString);

    } else if (pbPSet) { 
        // Empty permission set supplied.
        Output(hFile, PV_PSET_EMPTY, szName);
    } else {
        // No permission set supplied.
        Output(hFile, PV_PSET_NONE, szName);
    }

    return S_OK;
}


// Output all declarative security tagged on to a specific metadata token (for
// an assembly, type or method).
HRESULT DumpDeclSecOnObj(HANDLE hFile, IMetaDataImport *pImport, mdToken tkObj)
{
    HRESULT                     hr;
    HCORENUM                    hEnum = 0;
    mdPermission                rPermSets[dclMaximumValue + 1];
    DWORD                       dwPermSets;
    DWORD                       i;
    DWORD                       dwAction;
    BYTE                       *pbPermSet;
    DWORD                       cbPermSet;
    WCHAR                       szPrefix[1024];
    WCHAR                       szOutput[1024];
    mdTypeDef                   tkClass;
    WCHAR                       szType[MAX_CLASSNAME_LENGTH];
    WCHAR                       szMethod[MAX_CLASSNAME_LENGTH];
    DWORD                       cchNamespace;
    DWORD                       cchType;
    DWORD                       cchMethod;

    __try {

        // Check whether the object has permission sets attached.
        if (FAILED(hr = pImport->EnumPermissionSets(&hEnum,
                                                    tkObj,
                                                    dclActionNil,
                                                    rPermSets,
                                                    dclMaximumValue + 1,
                                                    &dwPermSets))) {
            Output(NULL, PV_FAILED_ENUM_PSETS, tkObj, hr);
            return hr;
        }

        if (dwPermSets == 0)
            return S_OK;

        // Build the object (assembly, class or method) name.
        switch (TypeFromToken(tkObj)) {
        case mdtAssembly:
            wcscpy(szPrefix, g_szAssemblyString);
            break;
        case mdtTypeDef:
            if (FAILED(hr = pImport->GetTypeDefProps(tkObj,
                                                     szType,
                                                     sizeof(szType) / sizeof(WCHAR),
                                                     &cchType,
                                                     NULL,
                                                     NULL))) {
                Output(NULL, PV_FAILED_GET_TYPE_PROPS, tkObj, hr);
                return hr;
            }
            szType[cchType] = L'\0';
            Wszwsprintf(szPrefix, g_szClassString, szType);
            break;
        case mdtMethodDef:
            if (FAILED(hr = pImport->GetMethodProps(tkObj,
                                                    &tkClass,
                                                    szMethod,
                                                    sizeof(szMethod) / sizeof(WCHAR),
                                                    &cchMethod,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    NULL,
                                                    NULL))) {
                Output(NULL, PV_FAILED_GET_METH_PROPS, tkObj, hr);
                return hr;
            }
            if (IsNilToken(tkClass)) {
                cchNamespace = 0;
                cchType = 0;
            } else if (FAILED(hr = pImport->GetTypeDefProps(tkClass,
                                                            szType,
                                                            sizeof(szType) / sizeof(WCHAR),
                                                            &cchType,
                                                            NULL,
                                                            NULL))) {
                Output(NULL, PV_FAILED_GET_TYPE_PROPS, tkClass, hr);
                return hr;
            }
            szMethod[cchMethod] = L'\0';
            szType[cchType] = L'\0';
            if (cchType)
                Wszwsprintf(szPrefix, g_szMethodString, szType, szMethod);
            else
                Wszwsprintf(szPrefix, g_szMethodGlobalString, szMethod);
            break;
        default:
            Output(NULL, PV_INVALID_OBJ, tkObj);
            return E_FAIL;
        }

        for (i = 0; i < dwPermSets; i++) {

            // Get the encoded permission set.
            hr = pImport->GetPermissionSetProps(rPermSets[i],
                                                &dwAction,
                                                (void const **)&pbPermSet,
                                                &cbPermSet);
            if (FAILED(hr)) {
                Output(NULL, PV_FAILED_GET_PSET_PROPS, hr);
                return hr;
            }


            // Append the action code.
            wcscpy(szOutput, szPrefix);
            switch (dwAction) {
            case dclRequest:
                wcscat(szOutput, g_szRequestString);
                break;
            case dclDemand:
                wcscat(szOutput, g_szDemandString);
                break;
            case dclAssert:
                wcscat(szOutput, g_szAssertString);
                break;
            case dclDeny:
                wcscat(szOutput, g_szDenyString);
                break;
            case dclPermitOnly:
                wcscat(szOutput, g_szPermitOnlyString);
                break;
            case dclLinktimeCheck:
                wcscat(szOutput, g_szLinktimeDemandString);
                break;
            case dclInheritanceCheck:
                wcscat(szOutput, g_szInhDemandString);
                break;
            case dclRequestMinimum:
                wcscat(szOutput, g_szReqMinString);
                break;
            case dclRequestOptional:
                wcscat(szOutput, g_szReqOptString);
                break;
            case dclRequestRefuse:
                wcscat(szOutput, g_szReqRefuseString);
                break;
            case dclPrejitGrant:
                wcscat(szOutput, g_szPrejitGrantString);
                break;
            case dclPrejitDenied:
                wcscat(szOutput, g_szPrejitDeniedString);
                break;
            case dclNonCasDemand:
                wcscat(szOutput, g_szNonCasDemandString);
                break;
            case dclNonCasLinkDemand:
                wcscat(szOutput, g_szNonCasLinkDemandString);
                break;
            case dclNonCasInheritance:
                wcscat(szOutput, g_szNonCasInhString);
                break;
            default:
                Output(NULL, PV_INVALID_ACTION, dwAction);
                return E_FAIL;
            }

            // Display the set itself.
            if (FAILED(hr = OutputPermissionSet(pbPermSet,
                                                cbPermSet,
                                                hFile,
                                                szOutput)))
                return hr;
        }

    } __finally {

        if (hEnum)
            pImport->CloseEnum(hEnum);

    }

    return S_OK;
}


// Output all declarative security for every assembly, type or method token
// defined in a given metadata scope.
HRESULT DumpDeclSecOnScope(HANDLE hFile, IMetaDataImport *pImport)
{
    HRESULT                     hr;
    IMetaDataAssemblyImport    *pAsmImport = NULL;
    mdAssembly                  tkAssembly;
    HCORENUM                    hEnumGlobals = 0;
    HCORENUM                    hEnumTypes = 0;
    HCORENUM                    hEnumMethods = 0;
    DWORD                       i, j;
    DWORD                       dwTypes;
    DWORD                       dwMethods;
    mdTypeDef                  *tkTypes;
    mdMethodDef                *tkMethods;

    __try {

        // Get an assembly metadata scope (this will succeed even if the scope
        // in question has no assembly metadata) .
        if (FAILED(hr = pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void**)&pAsmImport))) {
            Output(NULL, PV_FAILED_LOCATE_IMPORT, hr);
            return hr;
        }

        // Dump any permission requests on the assembly if we succeed in finding
        // some assembly metadata.
        if (SUCCEEDED(pAsmImport->GetAssemblyFromScope(&tkAssembly)))
            if (FAILED(hr = DumpDeclSecOnObj(hFile, pImport, tkAssembly)))
                return hr;

        // Enumerate all the global functions.
        if (FAILED(hr = pImport->EnumMethods(&hEnumGlobals, mdTokenNil, NULL, 0, NULL))) {
            Output(NULL, PV_FAILED_ENUM_GLOBALS, hr);
            return hr;
        }

        if (FAILED(hr = pImport->CountEnum(hEnumGlobals, &dwMethods))) {
            Output(NULL, PV_FAILED_COUNT_GLOBALS, hr);
            return hr;
        }

        if (dwMethods) {
            tkMethods = new mdMethodDef[dwMethods];
            if (tkMethods == NULL) {
                Output(NULL, PV_FAILED_ALLOC_METHODS, dwMethods);
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr = pImport->EnumMethods(&hEnumGlobals, mdTokenNil,
                                                 tkMethods,
                                                 dwMethods,
                                                 NULL))) {
                Output(NULL, PV_FAILED_ENUM_GLOBALS, hr);
                return hr;
            }

            for (i = 0; i < dwMethods; i++)
                if (FAILED(hr = DumpDeclSecOnObj(hFile, pImport, tkMethods[i])))
                    return hr;

            delete [] tkMethods;
        }

        // Enumerate all the classes within the file.
        if (FAILED(hr = pImport->EnumTypeDefs(&hEnumTypes, NULL, 0, NULL))) {
            Output(NULL, PV_FAILED_ENUM_TYPEDEFS, hr);
            return hr;
        }

        if (FAILED(hr = pImport->CountEnum(hEnumTypes, &dwTypes))) {
            Output(NULL, PV_FAILED_COUNT_TYPEDEFS, hr);
            return hr;
        }

        if (dwTypes) {
            tkTypes = new mdTypeDef[dwTypes];
            if (tkTypes == NULL) {
                Output(NULL, PV_FAILED_ALLOC_TYPEDEFS, dwTypes);
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr = pImport->EnumTypeDefs(&hEnumTypes,
                                                  tkTypes,
                                                  dwTypes,
                                                  NULL))) {
                Output(NULL, PV_FAILED_ENUM_TYPEDEFS, hr);
                return hr;
            }

            for (i = 0; i < dwTypes; i++) {

                if (FAILED(hr = DumpDeclSecOnObj(hFile, pImport, tkTypes[i])))
                    return hr;

                // Enumerate all the methods on the class.
                hEnumMethods = 0;
                if (FAILED(hr = pImport->EnumMethods(&hEnumMethods, tkTypes[i], NULL, 0, NULL))) {
                    Output(NULL, PV_FAILED_ENUM_METHODS, tkTypes[i], hr);
                    return hr;
                }

                if (FAILED(hr = pImport->CountEnum(hEnumMethods, &dwMethods))) {
                    Output(NULL, PV_FAILED_COUNT_METHODS, tkTypes[i], hr);
                    return hr;
                }

                if (dwMethods) {
                    tkMethods = new mdMethodDef[dwMethods];
                    if (tkMethods == NULL) {
                        Output(NULL, PV_FAILED_ALLOC_METHODS, dwMethods);
                        return E_OUTOFMEMORY;
                    }

                    if (FAILED(hr = pImport->EnumMethods(&hEnumMethods, tkTypes[i],
                                                         tkMethods,
                                                         dwMethods,
                                                         NULL))) {
                        Output(NULL, PV_FAILED_ENUM_METHODS, tkTypes[i], hr);
                        return hr;
                    }

                    for (j = 0; j < dwMethods; j++)
                        if (FAILED(hr = DumpDeclSecOnObj(hFile, pImport, tkMethods[j])))
                            return hr;

                    delete [] tkMethods;
                }

                pImport->CloseEnum(hEnumMethods);

            }

            delete [] tkTypes;
        }

    } __finally {

        if (hEnumTypes)
            pImport->CloseEnum(hEnumTypes);

        if (hEnumGlobals)
            pImport->CloseEnum(hEnumGlobals);

        if (pAsmImport)
            pAsmImport->Release();
    }

    return S_OK;
}


// Output all declarative security for all metadata scopes encompassed by the
// given manifest file.
HRESULT DumpDeclarativeSecurity(HANDLE hFile, LPWSTR szFile)
{
    HRESULT                     hr;
    IMetaDataDispenser         *pDispenser = NULL;
    IMetaDataImport            *pImport = NULL;
    IMetaDataAssemblyImport    *pAsmImport = NULL;
    WCHAR                       szDir[MAX_PATH + 1];
    WCHAR                      *pSlash;
    DWORD                       cchDir;
    HCORENUM                    hEnum = 0;
    DWORD                       dwFiles;
    mdFile                     *pFiles = NULL;
    DWORD                       i;

    __try {

        // Calculate manifest directory.
        wcscpy(szDir, szFile);
        pSlash = wcsrchr(szDir, L'\\');
        if (pSlash)
            pSlash[1] = L'\0';
        else
            szDir[0] = L'\0';
        cchDir = wcslen(szDir);

        // Get a metadata interface dispenser.
        if (FAILED(hr = CoCreateInstance(CLSID_CorMetaDataDispenser,
                                         NULL,
                                         CLSCTX_INPROC_SERVER, 
                                         IID_IMetaDataDispenser,
                                         (void **)&pDispenser))) {
            Output(NULL, PV_FAILED_CREATE_DISP, hr);
            return hr;
        }

        // Open a scope on the input file.
        if (FAILED(hr = pDispenser->OpenScope(szFile,
                                              ofRead | ofNoTypeLib,
                                              IID_IMetaDataImport,
                                              (IUnknown **)&pImport))) {
            Output(NULL, PV_FAILED_OPEN_SCOPE, hr);
            return hr;
        }

        // Get an assembly scope as well.
        if (FAILED(hr = pImport->QueryInterface(IID_IMetaDataAssemblyImport, (void**)&pAsmImport))) {
            Output(NULL, PV_FAILED_LOCATE_IMPORT, hr);
            return hr;
        }

        // Open a module file enumerator.
        if (FAILED(hr = pAsmImport->EnumFiles(&hEnum, NULL, 0, NULL))) {
            Output(NULL, PV_FAILED_ENUM_FILES, hr);
            return hr;
        }

        // Get the count of module files.
        if (FAILED(hr = pImport->CountEnum(hEnum, &dwFiles))) {
            Output(NULL, PV_FAILED_COUNT_FILES, hr);
            return hr;
        }

        // Allocate an array large enough to record all the file tokens.
        pFiles = (mdFile*)_alloca(dwFiles * sizeof(mdFile));

        // Read all the module file tokens in one operation.
        if (FAILED(hr = pAsmImport->EnumFiles(&hEnum,
                                              pFiles,
                                              dwFiles,
                                              &dwFiles))) {
            Output(NULL, PV_FAILED_ENUM_FILES, hr);
            return hr;
        }

        // Process the manifest module.
        DumpDeclSecOnScope(hFile, pImport);

        // Iterate over each additional module.
        for (i = 0; i < dwFiles; i++) {
            WCHAR            szModuleFile[MAX_PATH + 1];
            DWORD            cchModuleFile;
            IMetaDataImport *pModuleImport = NULL;

            // Prepend the directory path to the module filename.
            wcscpy(szModuleFile, szDir);

            // Get the module filename.
            if (FAILED(hr = pAsmImport->GetFileProps(pFiles[i],
                                                     &szModuleFile[cchDir],
                                                     (sizeof(szModuleFile) - cchDir) / sizeof(WCHAR),
                                                     &cchModuleFile,
                                                     NULL,
                                                     NULL,
                                                     NULL))) {
                Output(NULL, PV_FAILED_GET_FILE_PROPS, pFiles[i], hr);
                return hr;
            }

            // Ensure the result is NUL terminated.
            szModuleFile[cchDir + cchModuleFile] = L'\0';

            // Attempt to open a metadata scope on the file.
            if (SUCCEEDED(pDispenser->OpenScope(szModuleFile,
                                                ofRead | ofNoTypeLib,
                                                IID_IMetaDataImport,
                                                (IUnknown**)&pModuleImport))) {
                // Process the module.
                DumpDeclSecOnScope(hFile, pModuleImport);
                pModuleImport->Release();
            }
        }

    } __finally {

        if (hEnum)
            pAsmImport->CloseEnum(hEnum);
        
        if (pAsmImport)
            pAsmImport->Release();

        if (pImport)
            pImport->Release();

        if (pDispenser)
            pDispenser->Release();
    }

    return S_OK;
}


extern "C" int _cdecl wmain(int argc, WCHAR *argv[])
{
    BOOL    fOutput = FALSE;
    BOOL    fDecl = FALSE;
    LPWSTR  szOutput;
    LPWSTR  szFile;
    int     iArg;
    BYTE   *pbMinimal = NULL;
    DWORD   cbMinimal = 0;
    BYTE   *pbOptional = NULL;
    DWORD   cbOptional = 0;
    BYTE   *pbRefused = NULL;
    DWORD   cbRefused = 0;
    HRESULT hr;
    HANDLE  hFile = NULL;
    BOOL    fResult = TRUE;

    // Initialize Wsz wrappers.
    OnUnicodeSystem();

    // Load up resource strings.
    if (!(g_szAssemblyString = GetString(PV_ASSEMBLY)) ||
        !(g_szClassString = GetString(PV_CLASS)) ||
        !(g_szMethodString = GetString(PV_METHOD)) ||
        !(g_szMethodGlobalString = GetString(PV_METHOD_GLOBAL)) ||
        !(g_szRequestString = GetString(PV_REQUEST)) ||
        !(g_szDemandString = GetString(PV_DEMAND)) ||
        !(g_szAssertString = GetString(PV_ASSERT)) ||
        !(g_szDenyString = GetString(PV_DENY)) ||
        !(g_szPermitOnlyString = GetString(PV_PERMITONLY)) ||
        !(g_szLinktimeDemandString = GetString(PV_LINKTIMEDEMAND)) ||
        !(g_szInhDemandString = GetString(PV_INHDEMAND)) ||
        !(g_szReqMinString = GetString(PV_REQMIN)) ||
        !(g_szReqOptString = GetString(PV_REQOPT)) ||
        !(g_szReqRefuseString = GetString(PV_REQREFUSE)) ||
        !(g_szPrejitGrantString = GetString(PV_PREJIT_GRANT)) ||
        !(g_szPrejitDeniedString = GetString(PV_PREJIT_DENIED)) ||
        !(g_szNonCasDemandString = GetString(PV_NONCAS_DEMAND)) ||
        !(g_szNonCasLinkDemandString = GetString(PV_NONCAS_LINKDEMAND)) ||
        !(g_szNonCasInhString = GetString(PV_NONCAS_INH)) ||
        !(g_szMinimalString = GetString(PV_MINIMAL)) ||
        !(g_szOptionalString = GetString(PV_OPTIONAL)) ||
        !(g_szRefusedString = GetString(PV_REFUSED)) ||
        !(g_szOptOutputString = GetString(PV_OPTNAME_OUTPUT)) ||
        !(g_szOptDeclString = GetString(PV_OPTNAME_DECL)) ||
        !(g_szOptHelpString = GetString(PV_OPTNAME_HELP))) {
        printf("Failed to load string resources\r\n");
        return 1;
    }

    Title();

    if (argc < 2) {
        Usage();
        return 1;
    }

    // Parse options.
    for (iArg = 1; iArg < argc; iArg++) {
        if (argv[iArg][0] == L'/' || argv[iArg][0] == L'-') {
            if (!_wcsicmp(g_szOptOutputString, &argv[iArg][1])) {
                fOutput = TRUE;
                iArg++;
                if (iArg >= argc) {
                    Output(NULL, PV_MISSING_OUTPUT_ARG);
                    return 1;
                }
                szOutput = argv[iArg];
            } else if (!_wcsicmp(g_szOptDeclString, &argv[iArg][1])) {
                fDecl = TRUE;
            } else if (!_wcsicmp(L"?", &argv[iArg][1]) ||
                       !_wcsicmp(g_szOptHelpString, &argv[iArg][1]) ||
                       !_wcsicmp(L"h", &argv[iArg][1])) {
                Usage();
                return 0;
            } else
                break;
        } else
            break;
    }

    if (iArg >= argc) {
        Output(NULL, PV_MISSING_FILENAME);
        return 1;
    }

    // Grab image name.
    szFile = argv[iArg];

    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        Output(NULL, PV_FAILED_COM_STARTUP, hr);
        return 1;
    }

    // Startup the EE once now to avoid starting and stopping continuosly during
    // the program.
    hr = CoInitializeEE(COINITEE_DEFAULT);
    if (FAILED(hr)) {
        Output(NULL, PV_FAILED_CLR_STARTUP, hr);
        return 1;
    }

    // Open the ouput file if specified.
    if (fOutput) {
        hFile = WszCreateFile(szOutput,
                              GENERIC_WRITE,
                              0,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            Output(NULL, PV_FAILED_CREATE, szOutput, GetLastError());
            return 1;
        }
    }

    if (fDecl) {

        // Dump declarative security for all classes/methods in the image.
        fResult = SUCCEEDED(DumpDeclarativeSecurity(hFile, szFile));

    } else {

        // Read permission request set(s) from assembly manifest.
        hr = GetPermissionRequests(szFile,
                                   &pbMinimal,
                                   &cbMinimal,
                                   &pbOptional,
                                   &cbOptional,
                                   &pbRefused,
                                   &cbRefused);
        if (FAILED(hr)) {
            Output(NULL, PV_READ_REQUESTS, hr);
            fResult = FALSE;
        } else {

            // Output minimal set.
            if (FAILED(OutputPermissionSet(pbMinimal, cbMinimal, hFile, g_szMinimalString)))
                fResult = FALSE;
            else
                // Output optional set.
                if (FAILED(OutputPermissionSet(pbOptional, cbOptional, hFile, g_szOptionalString)))
                    fResult = FALSE;
                else
                    // Output refused set.
                    if (FAILED(OutputPermissionSet(pbRefused, cbRefused, hFile, g_szRefusedString)))
                        fResult = FALSE;

        }
    }

    if (fOutput)
        CloseHandle(hFile);

    return fResult ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_APP
#define VER_INTERNALNAME_STR	"PEVERIFY.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework PE, Metadata and IL Verification Tool\0"
#define VER_ORIGFILENAME_STR    "peverify.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\peverf32.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: PEverf32.h
// 
// Class Structure for class PEverf32 (PEverf32.cpp)
// ===========================================================================
#ifndef PEVerf32_H 
#define PEVerf32_H

#include <cor.h>
#include <crtdbg.h>
#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include <windows.h>
#include <imagehlp.h>
#include "corver.h"



//=============================================================================
//                        # definitions for Errors
//=============================================================================
#define IMPROPER_DOS_SIGNATURE           0x000000001

//=============================================================================
//                            class  PEverf32
//=============================================================================
class PEverf32
{
  protected:

      unsigned int       m_nDOSErrors;
      unsigned int       m_nNTstdErrors;
      unsigned int       m_nNTpeErrors;
      unsigned int       m_COMPlusErrors;

      HANDLE             m_hFile;
      HANDLE             m_hMapFile;
      LPVOID             m_lpMapAddress;

      _IMAGE_DOS_HEADER* m_pDOSheader;
      _IMAGE_NT_HEADERS* m_pNTheader;



  public:
    PEverf32();
    ~PEverf32();

    HRESULT  Init(char *);
    HRESULT  openFile(char *);
    void     closeFile();
    BOOL     LoadImageW9x();
    BOOL     verifyPE();
    void     getErrors(unsigned int*);

//-----------------------------------------------------------------------------
// GET functions - return values from all headers
//-----------------------------------------------------------------------------
    // Base information
    inline HANDLE  getHFile()                      { return m_hFile; }
    inline LPVOID  getBaseAddress()                { return m_lpMapAddress; }

    // DOS Header
    inline WORD   gete_magic()                    { return m_pDOSheader->e_magic;    }
    inline WORD   gete_cblp()                     { return m_pDOSheader->e_cblp;     }
    inline WORD   gete_cp()                       { return m_pDOSheader->e_cp;       }
    inline WORD   gete_crlc()                     { return m_pDOSheader->e_crlc;     }
    inline WORD   gete_cparhdr()                  { return m_pDOSheader->e_cparhdr;  }
    inline WORD   gete_minalloc()                 { return m_pDOSheader->e_minalloc; }
    inline WORD   gete_maxalloc()                 { return m_pDOSheader->e_maxalloc; }
    inline WORD   gete_ss()                       { return m_pDOSheader->e_ss;       }
    inline WORD   gete_sp()                       { return m_pDOSheader->e_sp;       }
    inline WORD   gete_csum()                     { return m_pDOSheader->e_csum;     }
    inline WORD   gete_ip()                       { return m_pDOSheader->e_ip;       }
    inline WORD   gete_cs()                       { return m_pDOSheader->e_cs;       }
    inline WORD   gete_lfarlc()                   { return m_pDOSheader->e_lfarlc;   }
    inline WORD   gete_ovno()                     { return m_pDOSheader->e_ovno;     }
    inline WORD   gete_oemid()                    { return m_pDOSheader->e_oemid;    }
    inline WORD   gete_oeminfo()                  { return m_pDOSheader->e_oeminfo;  }
    inline LONG   gete_lfanew()                   { return m_pDOSheader->e_lfanew;   }

    // COFF File Header
    inline DWORD  getSignature()                  { return m_pNTheader->Signature;                       }
    inline WORD   getMachine()                    { return m_pNTheader->FileHeader.Machine;              }
    inline WORD   getNumberOfSections()           { return m_pNTheader->FileHeader.NumberOfSections;     }
    inline DWORD  getTimeDateStamp()              { return m_pNTheader->FileHeader.TimeDateStamp;        }
    inline DWORD  getPointerToSymbolTable()       { return m_pNTheader->FileHeader.PointerToSymbolTable; }
    inline DWORD  getNumberOfSymbols()            { return m_pNTheader->FileHeader.NumberOfSymbols;      }
    inline WORD   getSizeOfOptionalHeader()       { return m_pNTheader->FileHeader.SizeOfOptionalHeader; }
    inline WORD   getCharacteristics()            { return m_pNTheader->FileHeader.Characteristics;      }

    // Optional Header - Standard Fields
    inline WORD   getMagic()                      { return m_pNTheader->OptionalHeader.Magic;              }
    inline BYTE   getMajorLinkerVersion()         { return m_pNTheader->OptionalHeader.MajorLinkerVersion; }
    inline BYTE   getMinorLinkerVersion()         { return m_pNTheader->OptionalHeader.MinorLinkerVersion; }
    inline DWORD  getSizeOfCode()                 { return m_pNTheader->OptionalHeader.SizeOfCode;         }
    inline DWORD  getSizeOfInitializedData()      { return m_pNTheader->OptionalHeader.SizeOfInitializedData;  }
    inline DWORD  getSizeOfUninitializedData()    { return m_pNTheader->OptionalHeader.SizeOfUninitializedData;}
    inline DWORD  getAddressOfEntryPoint()        { return m_pNTheader->OptionalHeader.AddressOfEntryPoint;}
    inline DWORD  getBaseOfCode()                 { return m_pNTheader->OptionalHeader.BaseOfCode;         }
    inline DWORD  getBaseOfData()                 { return m_pNTheader->OptionalHeader.BaseOfData;         }

    // Optional Header - NT Specific Fields
    inline DWORD  getImageBase()                  { return m_pNTheader->OptionalHeader.ImageBase;          }
    inline DWORD  getSectionAlignment()           { return m_pNTheader->OptionalHeader.SectionAlignment;   }
    inline DWORD  getFileAlignment()              { return m_pNTheader->OptionalHeader.FileAlignment;      }
    inline WORD   getMajorOperatingSystemVersion(){ return m_pNTheader->OptionalHeader.MajorOperatingSystemVersion; }
    inline WORD   getMinorOperatingSystemVersion(){ return m_pNTheader->OptionalHeader.MinorOperatingSystemVersion; }
    inline WORD   getMajorImageVersion()          { return m_pNTheader->OptionalHeader.MajorImageVersion;  }
    inline WORD   getMinorImageVersion()          { return m_pNTheader->OptionalHeader.MinorImageVersion;  }
    inline WORD   getMajorSubsystemVersion()      { return m_pNTheader->OptionalHeader.MajorSubsystemVersion;  }
    inline WORD   getMinorSubsystemVersion()      { return m_pNTheader->OptionalHeader.MinorSubsystemVersion;  }
    inline DWORD  getWin32VersionValue()          { return m_pNTheader->OptionalHeader.Win32VersionValue;  }
    inline DWORD  getSizeOfImage()                { return m_pNTheader->OptionalHeader.SizeOfImage;        }
    inline DWORD  getSizeOfHeaders()              { return m_pNTheader->OptionalHeader.SizeOfHeaders;      }
    inline DWORD  getCheckSum()                   { return m_pNTheader->OptionalHeader.CheckSum;           }
    inline WORD   getSubsystem()                  { return m_pNTheader->OptionalHeader.Subsystem;          }
    inline WORD   getDllCharacteristics()         { return m_pNTheader->OptionalHeader.DllCharacteristics; }
    inline DWORD  getSizeOfStackReserve()         { return m_pNTheader->OptionalHeader.SizeOfStackReserve; }
    inline DWORD  getSizeOfStackCommit()          { return m_pNTheader->OptionalHeader.SizeOfStackCommit;  }
    inline DWORD  getSizeOfHeapReserve()          { return m_pNTheader->OptionalHeader.SizeOfHeapReserve;  }
    inline DWORD  getSizeOfHeapCommit()           { return m_pNTheader->OptionalHeader.SizeOfHeapCommit;   }
    inline DWORD  getLoaderFlags()                { return m_pNTheader->OptionalHeader.LoaderFlags;        }
    inline DWORD  getNumberOfRvaAndSizes()        { return m_pNTheader->OptionalHeader.NumberOfRvaAndSizes;}

    //inline DWORD  getSizeOfCOMHeader()            { return m_pNTheader; }
    inline unsigned int getDOSErrors()            { return m_nDOSErrors;   }
    inline unsigned int getNTstdErrors()          { return m_nNTstdErrors; }
    inline unsigned int getNTpeErrors()           { return m_nNTpeErrors;  }
};

#endif // PEVerf32.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\prejit\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop
#include "ShimLoad.h"

ExternC PfnDliHook __pfnDliNotifyHook = ShimDelayLoadHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\peverify.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: PEverify.h
// 
// Header file for main.cpp
// ===========================================================================

#include <stdio.h>
#include <stdlib.h>
#include <wtypes.h>
#include "__file__.ver"
//#include "cor.ver"


BOOL VerifyPEformat (char *);
void Usage();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\prejit\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "PREJIT.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM+ Install-O-JIT Compiler\0"
#define VER_ORIGFILENAME_STR    "PREJIT.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\stdpch.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\profpick\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ProfPick.rc
//
#define IDD_DIALOG_PROFPICK             101
#define IDC_COMBO_LIST_PROFILERS        1000
#define IDC_EDIT_PROGRAM                1001
#define IDC_EDIT_DIRECTORY              1002
#define IDC_BUTTON_BROWSE_DIR           1003
#define IDC_EDIT_PROGRAM_ARGS           1004
#define IDC_EDIT_PROFILER_OPTIONS       1005
#define IDC_BUTTON_BROWSE_FILE          1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\peverify\stdpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "PEverify.h"
#include "PEverf32.h"
#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\profpick\profpick.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// ProfPick.h
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Registry Keys
//-----------------------------------------------------------------------------

// COM+'s list of profilers. We can walk this list and display them all
#define REGKEY_PROFILER "software\\microsoft\\.NETFramework\\profilers"

// ProfPick's spot to persists the user settings
#define REGKEY_SETTINGS "software\\microsoft\\ProfPick"

// value under each profiler's subkey with instantiation info
#define REGKEY_ID_VALUE "ProfilerID"


//-----------------------------------------------------------------------------
// Function Prototypes
//-----------------------------------------------------------------------------

int APIENTRY WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
void MsgBoxError(DWORD dwErr);
void BrowseForProgram(HWND hWnd);
void InitDialog(HWND hDlg);

BOOL CALLBACK ProfDlg(HWND, UINT, WPARAM, LPARAM);

void SaveRegString(HKEY, LPCTSTR lpValueName, const char * pszOutput);
void ReadStringValue(HKEY hKey, LPCTSTR lpValueName, char * pszInput);

void LoadRegistryToDlg(HWND hDlg);


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

const int MAX_STRING = 512;
const int PROFILER_NONE = -1;


//-----------------------------------------------------------------------------
// CExecuteInfo holds the information for running a process and it
// has functions to communicate that info with a dialog. This is a 
// Convenience class.
//-----------------------------------------------------------------------------
class CExecuteInfo
{
public:
	CExecuteInfo();

// Read dialog and grab text fields
	void GetTextInfoFromDlg(HWND hDlg);

// Based on member text fields, create an execution process
	BOOL Execute();


	void SaveDlgToRegistry(HWND hDlg);	
protected:

// helpers
	bool GetSelectedProfiler(HWND hDlg);

// member data
	char m_szProgram[MAX_STRING];
	char m_szDirectory[MAX_STRING];
	char m_szProgramArgs[MAX_STRING];
	char m_szProfileOpts[MAX_STRING];

	int m_nRegIdx;	// index into registry for profiler
	char m_szProfileRegInfo[MAX_STRING];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\profpick\profpick.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-----------------------------------------------------------------------------
// ProfPick.cpp :
// Dialog Utility to wrap running COM+ Profilers by
// setting necessary environment variables for a child process.
//-----------------------------------------------------------------------------

#include <windows.h>
#include <commdlg.h>
#include <stdio.h>

#include "resource.h"
#include "ProfPick.h"

//-----------------------------------------------------------------------------
// Entry function, kick off the main dialog box
//-----------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
// Launch the DialogBox, let ProfDlg() do the rest
	int iRet = DialogBox(
		hInstance,  
		MAKEINTRESOURCE(IDD_DIALOG_PROFPICK),
		NULL,      
		ProfDlg
	);

// Check failure
	if (iRet == -1)
	{
		DWORD dwFail = GetLastError();
		MsgBoxError(dwFail);
	}

	

	return 0;
}


//-----------------------------------------------------------------------------
// Message box that translates GetLastError() code into text
//-----------------------------------------------------------------------------
void MsgBoxError(DWORD dwError)
{
	LPVOID lpMsgBuf;
	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		dwError,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);
	
	MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error", MB_OK | MB_ICONSTOP );

	LocalFree( lpMsgBuf );
}


//-----------------------------------------------------------------------------
// Open Common File Dlg to Browse for filename
//-----------------------------------------------------------------------------
void BrowseForProgram(HWND hWnd)
{
	char szFile[MAX_STRING] = {"\0"};
	char szFileOut[MAX_STRING] = { "\0"};

	OPENFILENAME of;
	of.lStructSize		= sizeof(OPENFILENAME);
	of.hwndOwner		= hWnd;
	of.hInstance		= NULL; // ignored
	of.lpstrFilter		= NULL;	// filter info
	of.lpstrCustomFilter= NULL;	// no custom filter info
	of.nMaxCustFilter	= 0;	// ignored;
	of.nFilterIndex		= 0;
	of.lpstrFile		= szFile;
	of.nMaxFile			= MAX_STRING;
	of.lpstrFileTitle	= szFileOut;
	of.nMaxFileTitle	= MAX_STRING;
	of.lpstrInitialDir	= NULL;	//
	of.lpstrTitle		= "Browse";
	of.Flags			= OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
	of.nFileOffset		= 0;
	of.nFileExtension	= 0;
	of.lpstrDefExt		= ".exe";
	of.lCustData		= 0;
	of.lpfnHook			= NULL;
	of.lpTemplateName	= NULL;


	BOOL fOK = ::GetOpenFileName(&of);

	if (fOK)
	{
	// Set the edit contents in program edit box
		HWND hProg = ::GetDlgItem(hWnd, IDC_EDIT_PROGRAM);
		::SendMessage(hProg, WM_SETTEXT, 0, (LPARAM) of.lpstrFile);		

	}	

	
}

//-----------------------------------------------------------------------------
// Initilize the Main popup dialog
// * Must walk registry to add profilers to combo box
// * Load registry settings
//-----------------------------------------------------------------------------
void InitDialog(HWND hDlg)
{
// Add "None" to profiler combo box
	HWND hCombo = ::GetDlgItem(hDlg, IDC_COMBO_LIST_PROFILERS);
	int iRet = ::SendMessage(hCombo, CB_ADDSTRING, 0,  (LPARAM) "(none)");
	::SendMessage(hCombo, CB_SETITEMDATA, iRet, PROFILER_NONE);
	::SendMessage(hCombo, CB_SETCURSEL, iRet, 0);

// Walk registry to add extra profilers to combo box
	HKEY hKey;
	long lOpenStatus = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_PROFILER, 0, KEY_ENUMERATE_SUB_KEYS, &hKey);

	if (lOpenStatus == ERROR_SUCCESS)
	{
		long lRet;
		int idx =0;
		char szKeyName[MAX_STRING];

		do 
		{

			DWORD dwSize = MAX_STRING;
			lRet = RegEnumKeyEx(
				hKey,
				idx,			// index of subkey to enumerate
				szKeyName,		// address of buffer for subkey name
				&dwSize,		// address for size of subkey buffer
				NULL, NULL, NULL, NULL
			);
		
		// Add profiler to combo box and attach back to registry index
			if (lRet == ERROR_SUCCESS) 
			{			
				iRet = ::SendMessage(hCombo, CB_ADDSTRING, 0,  (LPARAM) szKeyName);
				::SendMessage(hCombo, CB_SETITEMDATA, iRet, idx);
			}
			idx ++;
		} while (lRet != ERROR_NO_MORE_ITEMS);
		

		::RegCloseKey(hKey);
	}


// Set current directory
	char szDir[MAX_STRING];
	
	DWORD dwLen = GetCurrentDirectory(MAX_STRING, szDir);
	HWND hEditDir = ::GetDlgItem(hDlg, IDC_EDIT_DIRECTORY);
	int iOK = ::SendMessage(hEditDir, WM_SETTEXT, 0, (long) &szDir);

	
// Grab from registry
	LoadRegistryToDlg(hDlg);
}

//-----------------------------------------------------------------------------
// Dialog Callback function.
BOOL CALLBACK ProfDlg(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		{
			InitDialog(hDlg);
			return TRUE; 
		}
		break;

	case WM_COMMAND:
		{
			switch(LOWORD(wParam)) {
			case IDOK:
				{
				// Execute based on the settings
					CExecuteInfo exeinfo;
					exeinfo.GetTextInfoFromDlg(hDlg);
					BOOL fOk = exeinfo.Execute();
					exeinfo.SaveDlgToRegistry(hDlg);

				// Only close dialog if we execute successfully
					if (fOk) 
						EndDialog(hDlg, 1);
				}
				break;
			case IDCANCEL:
				EndDialog(hDlg, 0);
				break;

		// Browse for file to execute 
			case IDC_BUTTON_BROWSE_FILE:
				BrowseForProgram(hDlg);
				break;
			}
		}
		return TRUE;
		break;
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// CExecute info manages Dialog information
CExecuteInfo::CExecuteInfo()
{
// Set all strungs to empty
	m_szDirectory[0]		= 
	m_szProfileOpts[0]		= 
	m_szProgram[0]			= 
	m_szProfileRegInfo[0]	=
	m_szProgramArgs[0]		= '\0';

	m_nRegIdx = PROFILER_NONE;	 
}


//-----------------------------------------------------------------------------
// After everything is setup, execute 
BOOL CExecuteInfo::Execute()
{

	STARTUPINFO startInfo;
	::ZeroMemory(&startInfo, sizeof(STARTUPINFO));
	startInfo.cb = sizeof(STARTUPINFO);
	
	PROCESS_INFORMATION processInfo;

// Use SetEnvironmentVariable to set environ vars in this space. Then make
// calle inherit ProfPick's vars. When profpick quits, all changes are
// restored by os. This saves us messy string manipulation in Environ block.
	if (m_nRegIdx != PROFILER_NONE)
	{
		BOOL fSetOK;
		fSetOK = SetEnvironmentVariable("CORDBG_ENABLE", "0x20");
		fSetOK = SetEnvironmentVariable("COR_PROFILER", m_szProfileRegInfo);
		fSetOK = SetEnvironmentVariable("PROF_CONFIG", m_szProfileOpts);
	}


// Handle Directory. Save the current directory and then change to the selected
// directory. Then let CreateProcess use the current (our selected) dir.
	if (m_szDirectory[0] != '\0') 
	{
		BOOL fSetOk = SetCurrentDirectory(m_szDirectory);
		if (!fSetOk) {
			char szBuffer[MAX_STRING];
			sprintf(szBuffer, "Failed to set directory to: %s", m_szDirectory);
			MessageBox(NULL, szBuffer, "Error", MB_OK | MB_ICONSTOP);

			return FALSE;
		}
	}

// Append CmdLine = program + program args
	char szCmdLine[MAX_PATH];
	sprintf(szCmdLine, "%s %s", m_szProgram, m_szProgramArgs);

// Launch process
	BOOL fOk = CreateProcess(	
		NULL,						// pointer to name of executable module
		szCmdLine,					// pointer to command line string

		NULL,						// process security attributes
		NULL,						// thread security attributes
		FALSE,						// handle inheritance flag
		0,							// creation flags
		NULL,						// pointer to new environment block
		NULL,						// pointer to current directory name		
		&startInfo,					// pointer to STARTUPINFO
		&processInfo				// pointer to PROCESS_INFORMATION
	);

// Failure?
	if (!fOk) 
	{
		DWORD dwErr = GetLastError();
		MsgBoxError(dwErr);
		return FALSE;
	}

	return TRUE;

}

//-----------------------------------------------------------------------------
// Look at dialog edit boxes to fill out execution info
void CExecuteInfo::GetTextInfoFromDlg(HWND hDlg)
{
// Get text from edit boxes
	HWND hProg = ::GetDlgItem(hDlg, IDC_EDIT_PROGRAM);
	::SendMessage(hProg, WM_GETTEXT, MAX_STRING, (LPARAM) &m_szProgram);

	HWND hDir = ::GetDlgItem(hDlg, IDC_EDIT_DIRECTORY);
	::SendMessage(hDir, WM_GETTEXT, MAX_STRING, (LPARAM) &m_szDirectory);

	HWND hProgArgs = ::GetDlgItem(hDlg, IDC_EDIT_PROGRAM_ARGS);
	::SendMessage(hProgArgs, WM_GETTEXT, MAX_STRING, (LPARAM) &m_szProgramArgs);

	HWND hProfileOpts = ::GetDlgItem(hDlg, IDC_EDIT_PROFILER_OPTIONS);
	::SendMessage(hProfileOpts, WM_GETTEXT, MAX_STRING, (LPARAM) &m_szProfileOpts);

// Get CLSID for selected profiler from Registry & ComboBox
	GetSelectedProfiler(hDlg);

}

//-----------------------------------------------------------------------------
// Return true if we get the profiler from the registry (may be "none"), 
// else return false and set the member vars to non-profile state
// Note that we must deal with a possibly corrupted / incomplete registry
bool CExecuteInfo::GetSelectedProfiler(HWND hDlg)
{
	m_szProfileRegInfo[0] = 0;
	char szMessage[MAX_STRING];

// Get selected profiler from combo box
	HWND hCombo = ::GetDlgItem(hDlg, IDC_COMBO_LIST_PROFILERS);
	int iSel = ::SendMessage(hCombo, CB_GETCURSEL, 0, 0);
	if (iSel == CB_ERR) 
	{
		m_nRegIdx = PROFILER_NONE;
		return true;
	}
	else
	{
		m_nRegIdx = ::SendMessage(hCombo, CB_GETITEMDATA, iSel, 0);
	}

	if (m_nRegIdx == PROFILER_NONE)
		return true;


// Lookup into registry to find ID. 
	HKEY hKey;
	long lOpenStatus = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_PROFILER, 0, KEY_ENUMERATE_SUB_KEYS, &hKey);
	
	if (lOpenStatus != ERROR_SUCCESS)
	{
		m_nRegIdx = PROFILER_NONE;
		
		sprintf(szMessage, "Could not open registry key:" REGKEY_PROFILER "\nCan't load selected profiler.");
		MessageBox(hDlg, szMessage, "Error opening Registry Key", MB_ICONSTOP | MB_OK);
		return false;
	}


// Get pretty name from index
	long lRet;			
	DWORD dwSize = MAX_STRING;
	char szSubKeyName[MAX_STRING];

	lRet = RegEnumKeyEx(
		hKey,
		m_nRegIdx,				// index of subkey to enumerate
		szSubKeyName,			// address of buffer for subkey name
		&dwSize,				// address for size of subkey buffer
		NULL, NULL, NULL, NULL
	);
	
	if (lRet != ERROR_SUCCESS) 
	{
		m_nRegIdx = PROFILER_NONE;
		::RegCloseKey(hKey);
		
		sprintf(szMessage, "Could not open key for profiler: '%s'\nCan't profile.", szSubKeyName);
		MessageBox(hDlg, szMessage, "Error opening Registry Key", MB_ICONSTOP | MB_OK);
		return false;
	}

// Open key with pretty name				
	HKEY hKeySub;
	DWORD dwType;
	lOpenStatus = ::RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_QUERY_VALUE, &hKeySub);
	
	if (lRet != ERROR_SUCCESS) 
	{
		m_nRegIdx = PROFILER_NONE;
		::RegCloseKey(hKey);

		sprintf(szMessage, "Could not open key for profiler: '%s'\nCan't profile.", szSubKeyName);
		MessageBox(hDlg, szMessage, "Error opening Registry Key", MB_ICONSTOP | MB_OK);
		return false;
	}

// Get CLSID from open key
	dwSize = MAX_STRING;
	
	lRet = ::RegQueryValueEx(hKeySub, REGKEY_ID_VALUE, NULL, &dwType, (BYTE*) m_szProfileRegInfo, &dwSize);
	
	if (lRet != ERROR_SUCCESS) 
	{
		m_nRegIdx = PROFILER_NONE;
		::RegCloseKey(hKeySub);
		::RegCloseKey(hKey);

		sprintf(szMessage, "Profiler '%s' missing PROGID value.\nCan't profile.", szSubKeyName);
		MessageBox(hDlg, szMessage, "Error opening Registry Value", MB_ICONSTOP | MB_OK);
		return false;
	}
	
	::RegCloseKey(hKeySub);
	::RegCloseKey(hKey);

	return true;
}


//-----------------------------------------------------------------------------
// Helper to save registry settings
void SaveRegString(HKEY hKey, LPCTSTR lpValueName, const char * pszOutput)
{
	const long len = strlen(pszOutput);
	long lStatus = ::RegSetValueEx(hKey, lpValueName, 0, REG_SZ, (BYTE*) pszOutput, len);
}

//-----------------------------------------------------------------------------
// Persist Dialog Settings
void CExecuteInfo::SaveDlgToRegistry(HWND hDlg)
{
// Open registry key and write in the current dialog contents as values
// Lookup into registry to find ID. 
	HKEY hKey;
	DWORD dwAction;

	long lStatus = ::RegCreateKeyEx(
		HKEY_CURRENT_USER,					// handle to an open key
		REGKEY_SETTINGS,					// address of subkey name
		0,									// reserved
		"Test",								// address of class string
		REG_OPTION_NON_VOLATILE,			// special options flag
		KEY_ALL_ACCESS,						// desired security access
		NULL,								// address of key security structure
		&hKey,								// address of buffer for opened handle
		&dwAction							// address of disposition value buffer
	);
 

	if (lStatus != ERROR_SUCCESS)
	{
		return;
	}	

	
// Now that key is open, set / add values
	SaveRegString(hKey, "Program", m_szProgram);
		
	SaveRegString(hKey, "WorkingDir", m_szDirectory);

	SaveRegString(hKey, "ProgArgs", m_szProgramArgs);

	SaveRegString(hKey, "ProfOpts", m_szProfileOpts);

	
}

//-----------------------------------------------------------------------------
// Helper function for LoadRegistryToDlg()
// Read a string from the registry. If the read fails, set pszInput to empty.
void ReadStringValue(HKEY hKey, LPCTSTR lpValueName, char * pszInput)
{
	DWORD dwType, dwSize;

	dwSize = MAX_STRING;
	long lRet = ::RegQueryValueEx(hKey, lpValueName, NULL, &dwType, (BYTE*) pszInput, &dwSize);
	if ((lRet != ERROR_SUCCESS) || (dwType != REG_SZ))
	{
		pszInput[0] = 0;
		return;
	}

// Registry may not null terminate our string,so do it manually
	if (dwSize < MAX_STRING)
	{
		pszInput[dwSize] = '\0';
	}

}

//-----------------------------------------------------------------------------
// Grab settings from Registry
void LoadRegistryToDlg(HWND hDlg)
{
// Lookup into registry to find saved settings
	HKEY hKey;
	long lStatus = ::RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_SETTINGS, 0, KEY_READ, &hKey);
	
	if (lStatus != ERROR_SUCCESS)
		return;
	
// Read off keys
	char szBuffer[MAX_STRING];

	ReadStringValue(hKey, "Program",	szBuffer);
	SetDlgItemText(hDlg, IDC_EDIT_PROGRAM, szBuffer);

	ReadStringValue(hKey, "WorkingDir", szBuffer);
	SetDlgItemText(hDlg, IDC_EDIT_DIRECTORY, szBuffer);

	ReadStringValue(hKey, "ProgArgs",	szBuffer);
	SetDlgItemText(hDlg, IDC_EDIT_PROGRAM_ARGS, szBuffer);

	ReadStringValue(hKey, "ProfOpts",	szBuffer);
	SetDlgItemText(hDlg, IDC_EDIT_PROFILER_OPTIONS, szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\profpick\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "ProfPick.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft COM+ Runtime executable.\0"
#define VER_ORIGFILENAME_STR    "ProfPick.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\prejit\prejit.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <WinWrap.h>
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>

#include "utilcode.h"
#include "corhlpr.cpp"
#include "corjit.h"
#include "corcompile.h"
#include "iceefilegen.h"

#include "zapper.h"
#include "nlog.h"

#include "corver.h"
#include "__file__.ver"

#include "CorZap.h"


/* --------------------------------------------------------------------------- *
 * DelayLoad.cpp stuff
 * --------------------------------------------------------------------------- */

#include "shimload.h"
ExternC PfnDliHook __pfnDliNotifyHook = ShimDelayLoadHook;


/* --------------------------------------------------------------------------- *
 * Options class
 * --------------------------------------------------------------------------- */

class PrejitOptions : public ZapperOptions
{
  public:
    LPCWSTR     *m_inputs;
    SIZE_T      m_inputCount;
    SIZE_T      m_inputAlloc;

    bool        m_log;
    bool        m_show;
    bool        m_delete;

    PrejitOptions();
    ~PrejitOptions();
    HRESULT ReadCommandLine(int argc, LPCWSTR argv[]);
    void PrintUsage();
};

PrejitOptions::PrejitOptions()
  : ZapperOptions(), 
    m_inputs(NULL),
    m_inputCount(0),
    m_inputAlloc(0),
    m_log(false),
    m_show(false),
    m_delete(false)
{
    m_preload = true;
    m_jit = true;
    m_recurse = false;
    m_update = true;
    m_shared = false;
    m_autodebug = true;
    m_verbose = false;
    m_compilerFlags = CORJIT_FLG_RELOC | CORJIT_FLG_PREJIT; 
}

PrejitOptions::~PrejitOptions()
{
    delete [] m_inputs;
}


HRESULT PrejitOptions::ReadCommandLine(int argc, LPCWSTR argv[])
{
    HRESULT hr = S_OK;

    while (argc-- > 0)
    {
        const WCHAR *arg = *argv++;

        if (*arg == '-' || *arg == '/')
        {
            arg++;
            switch (tolower(*arg++))
            {
            case '?':
                PrintUsage();
                return S_FALSE;

            case 'l':
                m_log = true;
                m_autodebug = false;
                continue;

            case 'f':
                m_update = false;
                break;

            case 'v':
                m_verbose = true;
                break;

            case 'i':
                if (tolower(*arg++) == 'l')
                {
                    m_jit = false;
                    break;
                }
                goto option_error;

            case 's':
                if (_wcsicmp(&arg[-1], L"show") == 0) {
                    m_show = true;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"stats") == 0)
                {
                    m_stats = true;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"size") == 0)
                {
                    m_compilerFlags |= CORJIT_FLG_SIZE_OPT;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"speed") == 0)
                {
                    m_compilerFlags |= CORJIT_FLG_SPEED_OPT;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"shared") == 0)
                {
                    m_shared = true;
                    continue;
                }
                goto option_error;
                    
            case 'd':
                if (_wcsicmp(&arg[-1], L"debug") == 0)
                {
                    m_compilerFlags |= CORJIT_FLG_DEBUG_INFO|CORJIT_FLG_DEBUG_OPT;
                    m_autodebug = false;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"debugopt") == 0)
                {
                    m_compilerFlags &= ~CORJIT_FLG_DEBUG_OPT;
                    m_compilerFlags |= CORJIT_FLG_DEBUG_INFO;
                    m_autodebug = false;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"delete") == 0)
                {
                    m_delete = true;
                    continue;
                }
                goto option_error;

            case 'n':
                if (*arg == 0)
                {
                    m_preload = false;
                    continue;
                }
                if (_wcsicmp(&arg[-1], L"nodebug") == 0)
                {
                    m_compilerFlags &= ~CORJIT_FLG_DEBUG_INFO;
                    m_compilerFlags &= ~CORJIT_FLG_DEBUG_OPT;
                    m_autodebug = false;
                    continue;
                }
                goto option_error;
                
            case 'p':
                if (_wcsicmp(&arg[-1], L"prof") == 0)
                {
                    m_compilerFlags |= CORJIT_FLG_PROF_ENTERLEAVE;
                    continue;
                }
                goto option_error;

            case 'w':
                if (_wcsicmp(&arg[-1], L"ws") == 0)
                {
                    m_attribStats = true;
                    continue;
                }
                goto option_error;

            case 'z':
                if (_wcsicmp(&arg[-1], L"Zjit") == 0)
                    printf("Jit testing functionality has been moved to a separate tool.\n");
                goto option_error;

            default:
                goto option_error;
            }
                
            if (*arg != 0)
            {
            option_error:
                printf("Unrecognized option %S\n", argv[-1]);
                hr = E_FAIL;
            }
        }
        else
        {
            if (m_inputCount == m_inputAlloc)
            {
                if (m_inputCount == 0)
                    m_inputAlloc = 5;
                else
                    m_inputAlloc *= 2;

                WCHAR **newInputs = new WCHAR * [m_inputAlloc];
                if (newInputs == NULL)
                    return E_OUTOFMEMORY;

                memcpy(newInputs, m_inputs, 
                       m_inputCount * sizeof(WCHAR *));

                delete [] m_inputs;                 
                m_inputs = (const WCHAR **) newInputs;
            }
            m_inputs[m_inputCount++] = arg;
        }
    }
    
    // Check parameters are vald
    if ((m_inputCount == 0) && !m_log && !m_show && !m_delete)
        hr = E_FAIL;

    return hr;
}

void PrejitOptions::PrintUsage()
{
    printf("\nMicrosoft (R) CLR IL Install-O-JIT  Version " VER_FILEVERSION_STR);
    printf("\nUsage: prejit [options] <assembly path or display name>...\n"
           "\n"
           "        /f              force compilation even if up to date\n"
           "        /n              don't preload classes\n"
           "        /IL             don't prejit code\n"
           "\n"
           "    Automatic options:\n"
           "        /log            Automatically compile assemblies based on log\n"
           "                        (a string can specify app name, \n"
           "                        otherwise all apps are compiled)\n"
           "        /show           With /log, shows the files in the log rather than \n"
           "                        the files in the cache.\n"
           "\n"
           "    Codegen options:\n"
           "        /size           optimize for code size\n"
           "        /speed          optimize for speed\n"
           "        /shared         load as shared assembly\n"
           "\n"
           "    Debugging options:\n"
           "        /debug          Force debugging\n"  
           "        /debugopt       Force optimized debugging\n"    
           "        /nodebug        Force non-debugging\n"
           "        /prof           Generate enter/leave callbacks\n"
           "\n"
           "    Diagnostic options:\n"
           "        /v              verbose\n"
           "        /stats          print out compilation statistics at the end\n"
           "        /ws             print out working set statistics at the end\n"
           "\n"
           "    Cache options:\n"
           "        /show           Show entries in the cache\n"
           "        /delete         Delete entries in the cache\n"
           "\n"
           );
}

/* --------------------------------------------------------------------------- *
 * main routine
 * --------------------------------------------------------------------------- */

int _cdecl wmain(int argc, LPCWSTR argv[])
{
    HRESULT hr;

    OnUnicodeSystem();

    PrejitOptions opt;

    hr = opt.ReadCommandLine(argc-1, argv+1);
    if (hr != S_OK)
    {
        if (FAILED(hr))
            opt.PrintUsage();
        exit(0);
    }

    //
    // Initialize COM & the EE
    //

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    // 
    // Init unicode wrappers
    // 

    OnUnicodeSystem();

    //
    // Now, create the zapper
    //

    Zapper zapper(&opt);

    if (opt.m_log) 
    {
        if (opt.m_inputCount == 0)
            zapper.EnumerateLog(NULL, !opt.m_show && !opt.m_delete, TRUE, opt.m_delete );
        else for (unsigned i = 0; i < opt.m_inputCount; i++)
            zapper.EnumerateLog(opt.m_inputs[i], 
                                !opt.m_show && !opt.m_delete, TRUE, opt.m_delete );
    } 
    else if (opt.m_show || opt.m_delete)
    {
        BOOL found = FALSE;

        if (opt.m_inputCount == 0)
            found = (zapper.TryEnumerateFusionCache(NULL, opt.m_show, opt.m_delete) == S_OK);
        else
        {
            for (unsigned i = 0; i < opt.m_inputCount; i++)
            {
                HRESULT hr = zapper.TryEnumerateFusionCache(opt.m_inputs[i], 
                                                            opt.m_show, opt.m_delete);
                if (FAILED(hr))
                    printf("Error reading fusion cache for %S\n", opt.m_inputs[i]);
                else if (hr == S_OK)
                    found = TRUE;
            }
        }

        if (!found)
            printf("No matched entries in the cache.\n");
    }
    else 
    {
        for (unsigned i = 0; i < opt.m_inputCount; i++)
        {
            zapper.Compile(opt.m_inputs[i]);
        }
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\attrlist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef ATTRDEF
#error  Must define 'ATTRDEF' properly before including this file!
#endif

ATTRDEF(GUID       , "guid"      )
ATTRDEF(SYS_IMPORT , "sysimport" )
ATTRDEF(NATIVE_TYPE, "nativetype")
ATTRDEF(SYS_STRUCT , "sysstruct" )

#undef  ATTRDEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\attrs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _ATTRS_H_
#define _ATTRS_H_
/*****************************************************************************/

enum attrKinds
{
    #define ATTRDEF(ename, sname) ATTR_##ename,
    #include "attrlist.h"

    ATTR_COUNT
};

enum attrMasks
{
    #define ATTRDEF(ename, sname) ATTR_MASK_##ename = 1 << ATTR_##ename,
    #include "attrlist.h"
};

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\alloc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _ALLOC_H_
#define _ALLOC_H_
/*****************************************************************************/

#pragma warning(disable:4200)

/*****************************************************************************/

#define _OS_COMMIT_ALLOC    1       // depends on host OS, use "1" for Win32

/*****************************************************************************/

void    *           LowLevelAlloc(size_t sz);
void                LowLevelFree (void *blk);

/*****************************************************************************/

struct nraMarkDsc
{
    void    *       nmPage;
    BYTE    *       nmNext;
    BYTE    *       nmLast;
};

// The following s/b inside 'struct norls_allocator', moved here temporarily.

struct norls_pagdesc
{
    norls_pagdesc * nrpNextPage;
    norls_pagdesc * nrpPrevPage;
#ifndef NDEBUG
    void    *       nrpSelfPtr;
#endif
    size_t          nrpPageSize;    // # of bytes allocated
    size_t          nrpUsedSize;    // # of bytes actually used
    BYTE            nrpContents[];
};

class norls_allocator
{
public:

    bool            nraInit (Compiler comp, size_t pageSize = 0,
                                            bool   preAlloc = false);
    bool            nraStart(Compiler comp, size_t initSize,
                                            size_t pageSize = 0);

    void            nraFree ();
    void            nraDone ();

private:

    Compiler        nraComp;

    norls_pagdesc * nraPageList;
    norls_pagdesc * nraPageLast;

    bool            nraRetNull;         // OOM returns NULL (longjmp otherwise)

    BYTE    *       nraFreeNext;        // these two (when non-zero) will
    BYTE    *       nraFreeLast;        // always point into 'nraPageLast'

    size_t          nraPageSize;

    bool            nraAllocNewPageNret;
    void    *       nraAllocNewPage(size_t sz);

#ifdef  DEBUG
    void    *       nraSelf;
#endif

public:

    void    *       nraAlloc(size_t sz);

    /* The following used for mark/release operation */

    void            nraMark(nraMarkDsc *mark)
    {
        mark->nmPage = nraPageLast;
        mark->nmNext = nraFreeNext;
        mark->nmLast = nraFreeLast;
    }

private:

    void            nraToss(nraMarkDsc *mark);

public:

    void            nraRlsm(nraMarkDsc *mark)
    {
        if (nraPageLast != mark->nmPage)
        {
            nraToss(mark);
        }
        else
        {
            nraFreeNext = mark->nmNext;
            nraFreeLast = mark->nmLast;
        }
    }

    size_t          nraTotalSizeAlloc();
    size_t          nraTotalSizeUsed ();

    /* The following used to visit all of the allocated pages */

    void    *       nraPageWalkerStart();
    void    *       nraPageWalkerNext (void *page);

    void    *       nraPageGetData(void *page);
    size_t          nraPageGetSize(void *page);
};

#ifndef DEBUG

inline
void    *           norls_allocator::nraAlloc(size_t sz)
{
    void    *   block;

    block = nraFreeNext;
            nraFreeNext += sz;

    if  (nraFreeNext > nraFreeLast)
        block = nraAllocNewPage(sz);

    return  block;
}

#endif

/*****************************************************************************
 *
 *  This is a generic block allocator.
 */

class block_allocator
{
public:

    bool            baInit(Compiler comp);
    void            baDone();

private:

    Compiler        baComp;

    bool            baGetMnret;

    void    *       baGetM(size_t size);        // out of memory -> calls longjmp
    void    *       baGet0(size_t size);        // out of memory -> returns NULL

    void            baRlsM(void *block);

public:

    void    *       baAlloc      (size_t size);
    void    *       baAllocOrNull(size_t size);
    void            baFree       (void *block);
};

/*---------------------------------------------------------------------------*/
#ifndef DEBUG

/* The non-debug case: map into calls of the non-debug routines */

inline
void    *           block_allocator::baAlloc      (size_t size)
{
    return baGetM(size);
}

inline
void    *           block_allocator::baAllocOrNull(size_t size)
{
    return baGet0(size);
}

inline
void                block_allocator::baFree       (void *block)
{
    baRlsM(block);
}

#endif

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\alloc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

/*****************************************************************************/

#include "error.h"
#include "alloc.h"

/*****************************************************************************/
#ifdef  DEBUG
#define MEMALLOC_DISP   0
#else
#define MEMALLOC_DISP   0
#endif
/*****************************************************************************/
#if     COUNT_CYCLES
#define ALLOC_CYCLES    0
#else
#define ALLOC_CYCLES    0
#endif
/*****************************************************************************/

#if     MEMALLOC_DISP

static  unsigned        totSize;
static  unsigned        maxSize;

inline
void    updateMemSize(int size)
{
    totSize += size;
    if  (maxSize < totSize)
         maxSize = totSize;
}

#endif

/*****************************************************************************/

void    *           LowLevelAlloc(size_t sz)
{

#if MEMALLOC_DISP
    printf("LLalloc: alloc %04X bytes\n", sz); updateMemSize(sz);
#endif

    return  VirtualAlloc(NULL, sz, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
}

void                LowLevelFree(void *blk)
{
    if  (blk)
        VirtualFree(blk, 0, MEM_RELEASE);
}

/*****************************************************************************/
#if 0
/*****************************************************************************
 *
 *  Initialize a committing allocator. If uncommitted (win32-style) memory
 *  management is supported by our host OS, the parameters have the following
 *  meaning:
 *
 *      iniSize ... ignored
 *
 *      incSize ... how much more memory to commit each time we run
 *                  out of space (0 --> use a reasonable default)
 *
 *      maxSize ... gives the max. size we'll ever need to allocate
 *
 *  If the host OS doesn't support uncommitted memory allocation (e.g. we're
 *  on the MAC), the parameters are interpreted as follows:
 *
 *      iniSize ... initial allocation (0 --> use a reasonable default)
 *
 *      incSize ... if non-zero, indicates how much to grow the allocation
 *                  when we run out of space; if 0, allocation will double
 *                  whenever space is exhausted
 *
 *      maxSize ... ignored
 */

bool        commitAllocator::cmaInitT(Compiler comp, size_t iniSize,
                                                     size_t incSize,
                                                     size_t maxSize)
{
    cmaRetNull = true;

    /* Remember the compiler we belong to */

    cmaComp    = comp;

#if _OS_COMMIT_ALLOC

    assert(maxSize);

    maxSize +=  (OS_page_size - 1);
    maxSize &= ~(OS_page_size - 1);

    cmaMaxSize = maxSize;
    cmaIncSize = incSize ? incSize
                         : 2*OS_page_size;

    /* Grab max. logical space but don't commit anything yet */

#if ALLOC_CYCLES
    unsigned        start = GetCycleCount32();
#endif

    cmaBase =
    cmaNext =
    cmaLast = (BYTE *)VirtualAlloc(0, maxSize, MEM_RESERVE, PAGE_READWRITE);
    if  (!cmaBase)
        return true;

#if ALLOC_CYCLES
    cycleExtra += GetCycleCount32() - start;
#endif

#else

    cmaIncSize = incSize;

    /* Make sure the initial size is reasonable */

    if  (iniSize)
    {
        iniSize +=  (OS_page_size - 1);
        iniSize &= ~(OS_page_size - 1);
    }
    else
    {
        iniSize = OS_page_size;
    }

    cmaBase =
    cmaNext = (BYTE *)VirtualAlloc(0, iniSize, MEM_COMMIT , PAGE_READWRITE);
    if  (!cmaBase)
        return true;

#if MEMALLOC_DISP
    printf("cmaInit: alloc %04X bytes\n", iniSize); updateMemSize(iniSize);
#endif

    cmaLast = cmaBase + iniSize;

#endif

    return false;
}

void        commitAllocator::cmaInit(Compiler comp, size_t iniSize,
                                                    size_t incSize,
                                                    size_t maxSize)
{
    if  (cmaInitT(comp, iniSize, incSize, maxSize))
        cmaComp->cmpFatal(ERRnoMemory);

    cmaRetNull = false;
}

/*****************************************************************************
 *
 *  This function gets called by caAlloc when it runs out of space. It
 *  keeps committing more memory until we have enough room for the
 *  attempted allocation.
 */

void    *   commitAllocator::cmaMore(size_t sz)
{
    /* Undo the increment done in caGetm() */

    cmaNext -= sz;

#if _OS_COMMIT_ALLOC

    /* Keep grabbing more memory until we succeed */

    for (;;)
    {
        size_t      sizeInc;
        size_t      sizeCur = cmaLast - cmaBase;

        /* Figure out how much more memory to commit */

        sizeInc = cmaIncSize;
        if  (sizeCur + sizeInc > cmaMaxSize)
            sizeInc = cmaMaxSize - sizeCur;

        assert(sizeInc);

#if ALLOC_CYCLES
        unsigned        start = GetCycleCount32();
#endif

        /* Commit a few more memory pages */

        if  (!VirtualAlloc(cmaLast, sizeInc, MEM_COMMIT, PAGE_READWRITE))
        {
            if  (cmaRetNull)
                return 0;

            cmaComp->cmpFatal(ERRnoMemory);
        }

#ifdef DEBUG
        memset(cmaLast, 0xDD, sizeInc);
#endif

#if ALLOC_CYCLES
        cycleExtra += GetCycleCount32() - start;
#endif

#if MEMALLOC_DISP
        printf("cmaMore: alloc %04X bytes\n", sizeInc); updateMemSize(sizeInc);
#endif

        /* Bump the last available byte pointer */

        cmaLast += sizeInc;

        /* Do we have enough room now? */

        if  (cmaNext + sz <= cmaLast)
        {
            void    *   temp;

            temp = cmaNext;
                   cmaNext += sz;

            return  temp;
        }
    }

#else

    /* Figure out how much more memory to allocate */

    BYTE    *   baseNew;
    size_t      sizeNew;
#ifdef DEBUG
    size_t      sizeInc;
#endif
    size_t      sizeCur = cmaLast - cmaBase;

    sizeNew = cmaIncSize;
    if  (!sizeNew)
        sizeNew = sizeCur;
#ifdef DEBUG
    sizeInc  = sizeNew;             // remember how much more we're grabbing
#endif
    sizeNew += sizeCur;

    /* Allocate the new, larger block */

    baseNew = (BYTE *)VirtualAlloc(0, sizeNew, MEM_COMMIT, PAGE_READWRITE);
    if  (!baseNew)
        cmaComp->cmpFatal(ERRnoMemory);

#if MEMALLOC_DISP
    printf("cmaMore: alloc %04X bytes\n", sizeNew); updateMemSize(sizeNew);
#endif

    /* Copy the old block to the new one */

    memcpy(baseNew, cmaBase, sizeCur);

    /* Release the old block, it's no longer needed */

    VirtualFree(cmaBase, 0, MEM_RELEASE);

    /* Update the various pointers */

    cmaNext += baseNew - cmaBase;
    cmaBase  = baseNew;
    cmaLast  = baseNew + sizeNew;

#ifdef DEBUG
    memset(cmaNext, 0xDD, sizeInc);
#endif

    return  cmaGetm(sz);

#endif

}

void        commitAllocator::cmaDone()
{

#if _OS_COMMIT_ALLOC

    /* Decommit any extra memory we've allocated */

#if 0

    printf("Unused committed space: %u bytes\n", cmaLast - cmaNext);

    if  (cmaLast != cmaBase)
        VirtualAlloc(0, cmaLast - cmaBase, MEM_DECOMMIT, 0);

#endif

#else

    // ISSUE: is it worth shrinking the block? Not likely .....

#endif

}

void        commitAllocator::cmaFree()
{
    VirtualFree(cmaBase, 0, MEM_RELEASE);

    cmaBase =
    cmaNext =
    cmaLast = 0;
}

/*****************************************************************************/
#endif//0
/*****************************************************************************/

bool                norls_allocator::nraInit(Compiler comp, size_t pageSize,
                                                               bool   preAlloc)
{
    bool            result = false;

    /* Remember the compiler we belong to */

    nraComp      = comp;

    nraRetNull   = true;

#ifdef  DEBUG
    nraSelf      = this;
#endif

    nraPageList  = NULL;
    nraPageLast  = NULL;

    nraFreeNext  = NULL;
    nraFreeLast  = NULL;

    nraPageSize  = pageSize ? pageSize
                            : 4*OS_page_size;

    if  (preAlloc)
    {
        const   void *  temp;

        /* Make sure we don't toss a fatal error exception */

        nraAllocNewPageNret = true;

        /* Grab the initial page(s) */

        temp = nraAllocNewPage(0);

        /* Check whether we've succeeded or not */

        if  (!temp)
            result = true;
    }

    nraAllocNewPageNret = false;

    return  result;
}

bool        norls_allocator::nraStart(Compiler comp, size_t initSize,
                                                     size_t pageSize)
{
    /* Add the page descriptor overhead to the required size */

//  initSize += offsetof(norls_pagdesc, nrpContents);
    initSize += (size_t)&(((norls_pagdesc *)0)->nrpContents);

    /* Round the initial size to a OS page multiple */

    initSize +=  (OS_page_size - 1);
    initSize &= ~(OS_page_size - 1);

    /* Initialize the allocator by allocating one big page */

    if  (nraInit(comp, initSize))
        return  true;

    /* Now go back to the 'true' page size */

    nraPageSize  = pageSize ? pageSize
                            : 4*OS_page_size;

    return  false;
}

/*---------------------------------------------------------------------------*/

void    *           norls_allocator::nraAllocNewPage(size_t sz)
{
    norls_pagdesc * newPage;
    size_t          sizPage;

    /* Do we have a page that's now full? */

    if  (nraPageLast)
    {
        /* Undo the "+=" done in nraAlloc() */

        nraFreeNext -= sz;

        /* Save the actual used size of the page */

        nraPageLast->nrpUsedSize = nraFreeNext - nraPageLast->nrpContents;
    }

    /* Make sure we grab enough to satisfy the allocation request */

    sizPage = nraPageSize;

    if  (sizPage < sz + sizeof(norls_pagdesc))
    {
        /* The allocation doesn't fit in a default-sized page */

#ifdef  DEBUG
//      if  (nraPageLast) printf("NOTE: wasted %u bytes in last page\n", nraPageLast->nrpPageSize - nraPageLast->nrpUsedSize);
#endif

        sizPage = sz + sizeof(norls_pagdesc);
    }

    /* Round to the nearest multiple of OS page size */

    sizPage +=  (OS_page_size - 1);
    sizPage &= ~(OS_page_size - 1);

    /* Allocate the new page */

#if ALLOC_CYCLES
    unsigned        start = GetCycleCount32();
#endif
    newPage = (norls_pagdesc *)VirtualAlloc(NULL, sizPage, MEM_COMMIT, PAGE_READWRITE);
#if ALLOC_CYCLES
    cycleExtra += GetCycleCount32() - start;
#endif
    if  (!newPage)
    {
        if  (nraAllocNewPageNret)
            return  NULL;

        nraComp->cmpFatal(ERRnoMemory);
    }

#if MEMALLOC_DISP
    printf("nraPage: alloc %04X bytes\n", sizPage); updateMemSize(sizPage);
#endif

#ifndef NDEBUG
    newPage->nrpSelfPtr = newPage;
#endif

    /* Append the new page to the end of the list */

    newPage->nrpNextPage = NULL;
    newPage->nrpPageSize = sizPage;
    newPage->nrpPrevPage = nraPageLast;

    if  (nraPageLast)
        nraPageLast->nrpNextPage = newPage;
    else
        nraPageList              = newPage;
    nraPageLast = newPage;

    /* Set up the 'next' and 'last' pointers */

    nraFreeNext = newPage->nrpContents + sz;
    nraFreeLast = newPage->nrpPageSize + (BYTE *)newPage;

#ifdef DEBUG
    memset(newPage->nrpContents, 0xDD, nraFreeLast - newPage->nrpContents);
#endif

    assert(nraFreeNext <= nraFreeLast);

    return  newPage->nrpContents;
}

void                norls_allocator::nraDone()
{
    /* Do nothing if we have no pages at all */

    if  (!nraPageList)
        return;

    /* We'll release all but the very first page */

    for (;;)
    {
        norls_pagdesc * temp;

        /* Get the next page, and stop if there aren't any more */

        temp = nraPageList->nrpNextPage;
        if  (!temp)
            break;

        /* Remove the next page from the list */

        nraPageList->nrpNextPage = temp->nrpNextPage;

#if 0
#ifdef DEBUG

        if  (this == &stmt_cmp::scAlloc)
            printf("StmtCmp");
        else if (this == &stmtExpr::sxAlloc)
            printf("StmtExp");
        else
            printf("Unknown");

        printf(": done page at %08X\n", temp);

#endif
#endif


        VirtualFree(temp, 0, MEM_RELEASE);
    }

    /* We now have exactly one page */

    nraPageLast = nraPageList;

    assert(nraPageList->nrpPrevPage == NULL);
    assert(nraPageList->nrpNextPage == NULL);

    /* Reset the pointers, the whole page is free now */

    nraFreeNext  = nraPageList->nrpContents;
    nraFreeLast  = nraPageList->nrpPageSize + (BYTE *)nraPageList;
}

void                norls_allocator::nraFree()
{
    /* Free all of the allocated pages */

    while   (nraPageList)
    {
        norls_pagdesc * temp;

        temp = nraPageList;
               nraPageList = temp->nrpNextPage;

#if 0
#ifdef DEBUG

        if  (this == &stmt_cmp::scAlloc)
            printf("StmtCmp");
        else if (this == &stmtExpr::sxAlloc)
            printf("StmtExp");
        else
            printf("Unknown");

        printf(": free page at %08X\n", temp);

#endif
#endif


        VirtualFree(temp, 0, MEM_RELEASE);
    }
}

void                norls_allocator::nraToss(nraMarkDsc *mark)
{
    void    *       last = mark->nmPage;

    if  (!last)
    {
        if  (!nraPageList)
            return;

        nraFreeNext  = nraPageList->nrpContents;
        nraFreeLast  = nraPageList->nrpPageSize + (BYTE *)nraPageList;

        return;
    }

    /* Free up all the new pages we've added at the end of the list */

    while (nraPageLast != last)
    {
        norls_pagdesc * temp;

        /* Remove the last page from the end of the list */

        temp = nraPageLast;
               nraPageLast = temp->nrpPrevPage;

#if MEMALLOC_DISP
        printf("nraToss: free  %04X bytes\n", temp->nrpPageSize); updateMemSize(-(int)temp->nrpPageSize);
#endif

        /* The new last page has no 'next' page */

        nraPageLast->nrpNextPage = NULL;

        VirtualFree(temp, 0, MEM_RELEASE);
    }

    nraFreeNext = mark->nmNext;
    nraFreeLast = mark->nmLast;
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

void    *           norls_allocator::nraAlloc(size_t sz)
{
    void    *   block;

    assert((sz & (sizeof(int) - 1)) == 0);
    assert(nraSelf == this);

    block = nraFreeNext;
            nraFreeNext += sz;

    if  (nraFreeNext > nraFreeLast)
        block = nraAllocNewPage(sz);

    return  block;
}

/*****************************************************************************/
#endif
/*****************************************************************************/

size_t              norls_allocator::nraTotalSizeAlloc()
{
    norls_pagdesc * page;
    size_t          size = 0;

    for (page = nraPageList; page; page = page->nrpNextPage)
        size += page->nrpPageSize;

    return  size;
}

size_t              norls_allocator::nraTotalSizeUsed()
{
    norls_pagdesc * page;
    size_t          size = 0;

    if  (nraPageLast)
        nraPageLast->nrpUsedSize = nraFreeNext - nraPageLast->nrpContents;

    for (page = nraPageList; page; page = page->nrpNextPage)
        size += page->nrpUsedSize;

    return  size;
}

/*****************************************************************************/

void    *   norls_allocator::nraPageWalkerStart()
{
    /* Make sure the actual used size for the current page is recorded */

    if  (nraPageLast)
        nraPageLast->nrpUsedSize = nraFreeNext - nraPageList->nrpContents;

    /* Return the first page */

    return  nraPageList;
}

void    *   norls_allocator::nraPageWalkerNext(void *page)
{
    norls_pagdesc * temp = (norls_pagdesc *)page;

#ifndef NDEBUG
    assert(temp);
    assert(temp->nrpSelfPtr == temp);
#endif

    return  temp->nrpNextPage;
}

void    *   norls_allocator::nraPageGetData(void *page)
{
    norls_pagdesc * temp = (norls_pagdesc *)page;

#ifndef NDEBUG
    assert(temp);
    assert(temp->nrpSelfPtr == temp);
#endif

    return  temp->nrpContents;
}

size_t      norls_allocator::nraPageGetSize(void *page)
{
    norls_pagdesc * temp = (norls_pagdesc *)page;

#ifndef NDEBUG
    assert(temp);
    assert(temp->nrpSelfPtr == temp);
#endif

    return  temp->nrpUsedSize;
}

/*****************************************************************************
 *
 *  Initialize the block allocator.
 */

bool                block_allocator::baInit(Compiler comp)
{
    /* Remember the compiler pointer */

    baComp     = comp;

    /* Normally we toss out-of-memory fatal errors */

    baGetMnret = false;

    return  false;
}

/*****************************************************************************
 *
 *  Shut down the block allocator.
 */

void                block_allocator::baDone()
{
}

/*****************************************************************************/

void    *           block_allocator::baGetM(size_t sz)
{
    void    *   block;

    assert((sz & (sizeof(int) - 1)) == 0);

    block = malloc(sz);
    if  (!block && !baGetMnret)
        baComp->cmpFatal(ERRnoMemory);

#if MEMALLOC_DISP
    printf("baGetM : alloc %04X bytes\n", sz); updateMemSize(sz);
#endif

    return  block;
}

void    *   block_allocator::baGet0(size_t sz)
{
    void    *   block;

    /* Try to allocate the block but don't toss an out-of-memory error */

    baGetMnret = true;
    block = baGetM(sz);
    baGetMnret = false;

    return  block;
}

void        block_allocator::baRlsM(void *block)
{
    assert(block);          // caller should check for NULL
      free(block);
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************
 *
 *  The following are the debug versions of the general memory allocator
 *  routines. They (optionally) log information about each allocation to
 *  make it easier to track down things like memory consumption, leaks,
 *  and so on.
 *
 */

void    *           block_allocator::baAlloc      (size_t size)
{
    void    *       block;

    assert((size & (sizeof(int) - 1)) == 0);

    block = baGetM(size);

    return  block;
}

void    *           block_allocator::baAllocOrNull(size_t size)
{
    void    *       block;

    assert((size & (sizeof(int) - 1)) == 0);

    block = baGet0(size);

    if  (block == NULL)
        return  block;

//  recordBlockAlloc(this, block, tsize);

    return  block;
}

void                block_allocator::baFree       (void *block)
{
//  recordBlockFree (this, block);

    baRlsM(block);
}

/*****************************************************************************/
#endif// DEBUG
/*****************************************************************************
 *
 *  Display memory alloc stats.
 */

#if MEMALLOC_DISP

void                dispMemAllocStats()
{
    printf("Total allocated memory: %8u (0x%08X) bytes.\n", totSize, totSize);
    printf("Max.  allocated memory: %8u (0x%08X) bytes.\n", maxSize, maxSize);
}

#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\regtlb\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "REGTLB.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM+ Typelib Registration\0"
#define VER_ORIGFILENAME_STR    "regtlb.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\regtlb\regtlb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// regtlb.cpp : Defines the entry point for the console application.
//

#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "process.h"
#include "ole2.h"

void Logo()
{
    printf("Microsoft (R) .NET TypeLib Registration Tool\n");
    printf("Copyright (C) Microsoft Corp. 1998-2002. All rights reserved.\n");
    printf("\n");
} // void Logo()

void Usage()
{
	Logo();
    printf("REGTLB [-u] [-n] filename [filename...]\n");
    printf("\n");
    printf("  filname - Name of the typelib file to register.\n");
    printf("  -u	  - If specified, unregister typelibs.\n");
    printf("  -n	  - If specified, suppress copyright notice.\n");
    printf("\n");
    exit(0);
} // void Usage()

int Register(char *pName)
{
	wchar_t		szFile[_MAX_PATH];
	LPVOID		lpMsgBuf = NULL;
	DWORD		dwStatus = 0;
	ITypeLib	*pTLB=0;
	HRESULT     hr;

	MultiByteToWideChar(CP_ACP, 0, pName,-1, szFile,_MAX_PATH);
	hr = LoadTypeLibEx(szFile, REGKIND_REGISTER, &pTLB);

	if (pTLB)
		pTLB->Release();

	if (SUCCEEDED(hr))
		return 0;

	dwStatus = FormatMessageA( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			(DWORD)hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL 
		);

	if (dwStatus) 
	{
		printf("Register %ls : (0x%X) %s", szFile, hr, lpMsgBuf);
		LocalFree( lpMsgBuf );
	}
	else
		printf("Register %ls: return code 0x%X\n", szFile, hr);

    return 1;
} // int Register()

int Unregister(char *pName)
{
	wchar_t		szFile[_MAX_PATH];
	LPVOID		lpMsgBuf = NULL;
	DWORD		dwStatus = 0;
	ITypeLib	*pTLB=0;
	HRESULT     hr;
	TLIBATTR	*pAttr;
	GUID		guid;					// Values
	WORD		wMajor;					//	used 
	WORD		wMinor;					//	 to
	LCID		lcid;					//	  unregister
	SYSKIND		syskind;				//	   typelib

	MultiByteToWideChar(CP_ACP, 0, pName,-1, szFile,_MAX_PATH);
	hr = LoadTypeLibEx(szFile, REGKIND_NONE, &pTLB);

	if (pTLB)
	{
		pTLB->GetLibAttr(&pAttr);
		guid	= pAttr->guid;
		wMajor	= pAttr->wMajorVerNum;
		wMinor	= pAttr->wMinorVerNum;
		lcid	= pAttr->lcid;
		syskind = pAttr->syskind;
		pTLB->ReleaseTLibAttr(pAttr);
		pTLB->Release();

		hr = UnRegisterTypeLib(guid, wMajor, wMinor, lcid, syskind);
	}
	else
		hr = 0;

	if (SUCCEEDED(hr))
		return 0;

	dwStatus = FormatMessageA( 
			FORMAT_MESSAGE_ALLOCATE_BUFFER | 
			FORMAT_MESSAGE_FROM_SYSTEM | 
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			(DWORD)hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			(LPTSTR) &lpMsgBuf,
			0,
			NULL 
		);

	if (dwStatus) 
	{
		printf("UnRegister %ls : (0x%X) %s", szFile, hr, lpMsgBuf);
		LocalFree( lpMsgBuf );
	}
	else
		printf("UnRegister %ls: return code 0x%X\n", szFile, hr);

    return 1;
} // int Unregister()

int __cdecl main(int argc, char* argv[])
{
	int			i;						// Loop control.
	int			bUnregister=false;		// Register or Unregister?
	int			bNologo=false;			// True to suppress logo.
	int			cFailures=0;			// Count of failures.

    if (argc < 2)
        Usage();

	for (i=1; i<argc; ++i)
	{
		// Switch?
		if (argv[i][0] == '-')
		{
			switch (tolower(argv[i][1]))
			{
			case 'u':
				bUnregister = true;
				break;
			case '?':
				Usage();
			case 'n':
				bNologo=true;
			}
		}
	}

	if (!bNologo)
		Logo();

	for (i=1; i<argc; ++i)
	{
		// Filename?
		if (argv[i][0] != '-')
		{
			if (bUnregister)
			{
				if (Unregister(argv[i]))
					++cFailures;
			}
			else
			{
				if (Register(argv[i]))
					++cFailures;
			}
		}
	}

	// Give indication back to batch files.
	return (cFailures ? 1 : 0);
} // int __cdecl main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\bind.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "comp.h"
#include "genIL.h"

/*****************************************************************************/

#ifdef  DEBUG

#if     0
#define SHOW_CODE_OF_THIS_FNC   "name"          // will display code for this fn
#endif

#if     0
#define SHOW_OVRS_OF_THIS_FNC   "f"             // disp overload res for this fn
#endif

#undef  SHOW_OVRS_OF_CONVS                      // disp overload res for conversions

#endif

/*****************************************************************************
 *
 *  The low-level tree node allocator to be used during expression binding.
 */

Tree                compiler::cmpAllocExprRaw(Tree expr, treeOps oper)
{
    if  (!expr)
    {
#if MGDDATA
        expr = new Tree;
#else
        expr =    (Tree)cmpAllocCGen.nraAlloc(sizeof(*expr));
#endif

//      expr->tnColumn = 0;
        expr->tnLineNo = 0;
    }

    expr->tnOper  = oper;
    expr->tnFlags = 0;

    return  expr;
}

/*****************************************************************************
 *
 *  Return an error node.
 */

Tree                compiler::cmpCreateErrNode(unsigned errn)
{
    Tree            expr = cmpAllocExprRaw(NULL, TN_ERROR);

    if  (errn)
        cmpError(errn);

    expr->tnVtyp = TYP_UNDEF;
    expr->tnType = cmpGlobalST->stIntrinsicType(TYP_UNDEF);

    return  expr;
}

/*****************************************************************************
 *
 *  Given a type, check whether it's un unmanaged array and if so decay its
 *  type to a pointer to the array element.
 */

Tree                compiler::cmpDecayArray(Tree expr)
{
    TypDef          type = expr->tnType;

    if  (type->tdTypeKind == TYP_ARRAY && !type->tdIsManaged)
    {
        var_types       vtyp = TYP_PTR;

        /* Check for a managed address, it yields a byref */

        if  (cmpIsManagedAddr(expr))
            vtyp = TYP_REF;

        /* Create the implicit 'address of' node */

        expr = cmpCreateExprNode(NULL,
                                 TN_ADDROF,
                                 cmpGlobalST->stNewRefType(vtyp, type->tdArr.tdaElem),
                                 expr,
                                 NULL);

        expr->tnFlags |= TNF_ADR_IMPLICIT;
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Return a node that refers to the given local variable symbol.
 */

Tree                compiler::cmpCreateVarNode(Tree expr, SymDef sym)
{
    expr = cmpAllocExprRaw(expr, TN_LCL_SYM);

    expr->tnLclSym.tnLclSym = sym; sym->sdReferenced = true;

    if  (sym->sdCompileState >= CS_DECLARED)
    {
        /* Is the variable a byref argument? */

        if  (sym->sdVar.sdvMgdByRef || sym->sdVar.sdvUmgByRef)
        {
            assert(sym->sdVar.sdvArgument);

            /* Bash the type of the argument reference to ref/pointer */

            expr->tnVtyp   = sym->sdVar.sdvMgdByRef ? TYP_REF : TYP_PTR;
            expr->tnType   = cmpGlobalST->stNewRefType(expr->tnVtypGet(), sym->sdType);
            expr->tnFlags &= ~TNF_LVALUE;

            /* Create an explicit indirection */

            expr = cmpCreateExprNode(NULL, TN_IND, sym->sdType, expr, NULL);
        }
        else
        {
            expr->tnType   = sym->sdType;
            expr->tnVtyp   = expr->tnType->tdTypeKind;

            /* Is the variable a constant? */

            if  (sym->sdVar.sdvConst)
                return  cmpFetchConstVal(sym->sdVar.sdvCnsVal, expr);
        }
    }
    else
    {
        cmpError(ERRlvInvisible, sym);

        expr->tnVtyp       = TYP_UNDEF;
        expr->tnType       = cmpGlobalST->stIntrinsicType(TYP_UNDEF);
    }

    expr->tnFlags |=  TNF_LVALUE;

AGAIN:

    switch (expr->tnVtyp)
    {
    case TYP_TYPEDEF:
        expr->tnType = cmpActualType(expr->tnType);
        expr->tnVtyp = expr->tnType->tdTypeKindGet();
        goto AGAIN;

    case TYP_ARRAY:
        expr = cmpDecayCheck(expr);
        break;
    }

    return expr;
}

/*****************************************************************************
 *
 *  Return a 32-bit integer constant node.
 */

Tree                compiler::cmpCreateIconNode(Tree expr, __int32 val, var_types typ)
{
    expr = cmpAllocExprRaw(expr, TN_CNS_INT);

    assert(typ != TYP_LONG && typ != TYP_ULONG);

    expr->tnVtyp             = typ;
    expr->tnType             = cmpGlobalST->stIntrinsicType(typ);
    expr->tnIntCon.tnIconVal = val;

    return expr;
}

/*****************************************************************************
 *
 *  Return a 64-bit integer constant node.
 */

Tree                compiler::cmpCreateLconNode(Tree expr, __int64 val, var_types typ)
{
    expr = cmpAllocExprRaw(expr, TN_CNS_LNG);

    assert(typ == TYP_LONG || typ == TYP_ULONG);

    expr->tnVtyp             = typ;
    expr->tnType             = cmpGlobalST->stIntrinsicType(typ);
    expr->tnLngCon.tnLconVal = val;

    return expr;
}

/*****************************************************************************
 *
 *  Return a float constant node.
 */

Tree                compiler::cmpCreateFconNode(Tree expr, float val)
{
    expr = cmpAllocExprRaw(expr, TN_CNS_FLT);

    expr->tnVtyp             = TYP_FLOAT;
    expr->tnType             = cmpGlobalST->stIntrinsicType(TYP_FLOAT);
    expr->tnFltCon.tnFconVal = val;

    return expr;
}

/*****************************************************************************
 *
 *  Return a float constant node.
 */

Tree                compiler::cmpCreateDconNode(Tree expr, double val)
{
    expr = cmpAllocExprRaw(expr, TN_CNS_DBL);

    expr->tnVtyp             = TYP_DOUBLE;
    expr->tnType             = cmpGlobalST->stIntrinsicType(TYP_DOUBLE);
    expr->tnDblCon.tnDconVal = val;

    return expr;
}
/*****************************************************************************
 *
 *  Return a string constant node.
 */

Tree                compiler::cmpCreateSconNode(stringBuff  str,
                                                size_t      len,
                                                unsigned    wide,
                                                TypDef      type)
{
    Tree            expr;

    expr = cmpAllocExprRaw(NULL, TN_CNS_STR);

    expr->tnType             = type;
    expr->tnVtyp             = type->tdTypeKindGet();
    expr->tnStrCon.tnSconVal = str;
    expr->tnStrCon.tnSconLen = len;
    expr->tnStrCon.tnSconLCH = wide;

    return expr;
}

/*****************************************************************************
 *
 *  Allocate a generic expression tree node with the given type.
 */

Tree                compiler::cmpCreateExprNode(Tree expr, treeOps  oper,
                                                           TypDef   type)
{
    expr = cmpAllocExprRaw(expr, oper);

    expr->tnFlags    = 0;
    expr->tnVtyp     = type->tdTypeKind;
    expr->tnType     = type;

    if  (expr->tnVtyp == TYP_TYPEDEF)
    {
        expr->tnType = type = type->tdTypedef.tdtType;
        expr->tnVtyp = type->tdTypeKindGet();
    }

//  if  ((int)expr == 0x00a5033c) forceDebugBreak();

    return  expr;
}

Tree                compiler::cmpCreateExprNode(Tree expr, treeOps  oper,
                                                           TypDef   type,
                                                           Tree     op1,
                                                           Tree     op2)
{
    expr = cmpAllocExprRaw(expr, oper);

    expr->tnFlags    = 0;
    expr->tnVtyp     = type->tdTypeKind;
    expr->tnType     = type;
    expr->tnOp.tnOp1 = op1;
    expr->tnOp.tnOp2 = op2;

    if  (expr->tnVtyp == TYP_TYPEDEF)
    {
        expr->tnType = type = type->tdTypedef.tdtType;
        expr->tnVtyp = type->tdTypeKindGet();
    }

//  if  ((int)expr == 0x00a5033c) forceDebugBreak();

    return  expr;
}

/*****************************************************************************
 *
 *  Bring the two given class/array expressions to a common type if possible.
 *  Returns non-zero in case of success (in which either of the expressions
 *  may have been coerced to the proper type).
 */

bool                compiler::cmpConvergeValues(INOUT Tree REF op1,
                                                INOUT Tree REF op2)
{
    TypDef          bt1 = op1->tnType;
    TypDef          bt2 = op2->tnType;

    assert(bt1->tdTypeKind == TYP_REF ||
           bt1->tdTypeKind == TYP_PTR ||
           bt1->tdTypeKind == TYP_ARRAY);

    assert(bt2->tdTypeKind == TYP_REF ||
           bt2->tdTypeKind == TYP_PTR ||
           bt2->tdTypeKind == TYP_ARRAY);

    /* Are both operands the same? */

    if  (bt1 == bt2)
        return true;

    /* Special case: 'null' always 'bends' to the other type */

    if  (op1->tnOper == TN_NULL)
    {
        op1 = cmpCoerceExpr(op1, op2->tnType, false);
        return true;
    }

    if  (op2->tnOper == TN_NULL)
    {
        op2 = cmpCoerceExpr(op2, op1->tnType, false);
        return true;
    }

    /* Arrays require special handling */

    if  (bt1->tdTypeKind == TYP_ARRAY)
    {
        if  (cmpIsObjectVal(op2))
        {
            /* 'Object' is a base class of all arrays */

            op1 = cmpCoerceExpr(op1, op2->tnType, false);
            return true;
        }

        /* Is the other operand another array? */

        if  (bt2->tdTypeKind != TYP_ARRAY)
            return false;

        /* Get hold of the element types */

        bt1 = cmpDirectType(bt1->tdArr.tdaElem);
        bt2 = cmpDirectType(bt2->tdArr.tdaElem);

        if  (bt1 == bt2)
            return  true;

        /* Is one element type the base of the other? */

        if  (bt1->tdTypeKind != TYP_REF) return false;
        if  (bt2->tdTypeKind != TYP_REF) return false;

        goto CHK_BASE;
    }

    if  (bt2->tdTypeKind == TYP_ARRAY)
    {
        if  (cmpIsObjectVal(op1))
        {
            /* 'Object' is a base class of all arrays */

            op2 = cmpCoerceExpr(op2, op1->tnType, false);
            return true;
        }

        /* We already know that the other operand is not an array */

        return false;
    }

CHK_BASE:

    /* Is one operand a base class of the other? */

    bt1 = cmpGetRefBase(bt1);
    bt2 = cmpGetRefBase(bt2);

    if  (!bt1 || bt1->tdTypeKind != TYP_CLASS) return true;
    if  (!bt2 || bt2->tdTypeKind != TYP_CLASS) return true;

    if      (cmpIsBaseClass(bt1, bt2))
    {
        op2 = cmpCoerceExpr(op2, op1->tnType, false);
        return true;
    }
    else if (cmpIsBaseClass(bt2, bt1))
    {
        op1 = cmpCoerceExpr(op1, op2->tnType, false);
        return true;
    }

    return false;
}

/*****************************************************************************
 *
 *  Make sure access to the specified symbol is permitted right now; issues
 *  an error message and returns false if access it not allowed.
 */

bool                compiler::cmpCheckAccessNP(SymDef sym)
{
    SymDef          clsSym;
    SymDef          nspSym;

    /* Figure out the class/namespace owning the symbol */

    clsSym = sym->sdParent;
    if  (!clsSym)
        return  true;

    if  (clsSym->sdSymKind != SYM_CLASS)
    {
        nspSym = clsSym;
        clsSym = NULL;
    }
    else
    {
        nspSym = clsSym->sdParent;
        while (nspSym->sdSymKind != SYM_NAMESPACE)
            nspSym = nspSym->sdParent;
    }

    /* Check the access level of the symbol */

    switch (sym->sdAccessLevel)
    {
    case ACL_PUBLIC:
        return true;

    case ACL_DEFAULT:

        /* Is this a type that came from an external assembly ? */

        if  (sym->sdSymKind == SYM_CLASS && sym->sdClass.sdcAssemIndx)
            break;

        /* Are we within the same namespace? */

        if  (cmpCurNS == nspSym)
            return true;

        /* If the symbol is not an import, it's OK as well */

        if  (!sym->sdIsImport)
            return true;

        // Fall through ...

    case ACL_PROTECTED:

        /* Are we in a member of a derived class? */

        if  (cmpCurCls && clsSym)
        {
            SymDef          nestCls;

            for (nestCls = cmpCurCls;
                 nestCls && nestCls->sdSymKind == SYM_CLASS;
                 nestCls = nestCls->sdParent)
            {
                if  (cmpIsBaseClass(clsSym->sdType, nestCls->sdType))
                    return true;
            }
        }

        // Fall through ...

    case ACL_PRIVATE:

        /* Are we within a member of the same class? */

        if  (cmpCurCls == clsSym)
            return true;

        /* Are we nested within the same class? */

        if  (cmpCurCls)
        {
            SymDef          tmpSym = cmpCurCls;

            do
            {
                 tmpSym = tmpSym->sdParent;
                 if (tmpSym == clsSym)
                     return true;
            }
            while (tmpSym->sdSymKind == SYM_CLASS);
        }

        break;

    default:
#ifdef  DEBUG
        printf("Symbol '%s'\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
#endif
        assert(!"invalid symbol access");
    }

    /*
        Last-ditch effort: always allow access to interface members
        as well as property symbols (for those we check access on
        the accessor instead).
     */

    if  (clsSym && clsSym->sdClass.sdcFlavor == STF_INTF)
        return  true;
    if  (sym->sdSymKind == SYM_PROP)
        return  true;

//  #pragma message("WARNING: access checking disabled near line 1280!")
//  return  true;

    forceDebugBreak();
    cmpErrorQnm(ERRnoAccess, sym);
    return false;
}

/*****************************************************************************
 *
 *  The given type is an "indirect" one (i.e. a typedef or enum), convert
 *  it to the underlying type.
 */

TypDef              compiler::cmpGetActualTP(TypDef type)
{
    for (;;)
    {
        switch (type->tdTypeKind)
        {
        case TYP_TYPEDEF:
            type = type->tdTypedef.tdtType;
            if  (varTypeIsIndirect(type->tdTypeKindGet()))
                continue;
            break;

        case TYP_ENUM:
            type = type->tdEnum.tdeIntType;
            break;
        }

        return  type;
    }
}

/*****************************************************************************
 *
 *  Make sure the given expression is an lvalue.
 */

bool                compiler::cmpCheckLvalue(Tree expr, bool addr, bool noErr)
{
    if  (expr->tnFlags & TNF_LVALUE)
    {
        /* If we're taking the address of this thing ... */

        if  (addr)
        {
            /* ... then it better not be a bitfield */

            if  (expr->tnOper == TN_VAR_SYM)
            {
                SymDef          memSym = expr->tnVarSym.tnVarSym;

                assert(memSym->sdSymKind == SYM_VAR);

                if  (memSym->sdVar.sdvBitfield)
                {
                    if  (noErr)
                        return  false;

                    cmpError(ERRbfldAddr, memSym);
                }
            }
        }
    }
    else
    {
        /* Try to give a more specific message */

        switch (expr->tnOper)
        {
            SymDef          sym;

        case TN_VAR_SYM:

            sym = expr->tnVarSym.tnVarSym;
            goto CHK_CNS;

        case TN_LCL_SYM:

            sym = expr->tnLclSym.tnLclSym;

        CHK_CNS:

            if  (sym->sdVar.sdvConst || sym->sdIsSealed)
            {
                /* Special case: readonly members can be assigned in ctors */

                if  (cmpCurFncSym && cmpCurFncSym->sdFnc.sdfCtor
                                  && cmpCurFncSym->sdParent == sym->sdParent)
                {
                    /* Allow assignments to the member */

                    expr->tnFlags |= TNF_LVALUE;

                    return  true;
                }

                if  (!noErr)
                    cmpError(ERRassgCns, expr->tnVarSym.tnVarSym);

                return false;
            }

            break;
        }

        if  (!noErr)
        {
            cmpRecErrorPos(expr);

            cmpError((expr->tnOperKind() & TNK_CONST) ? ERRassgLit
                                                      : ERRnotLvalue);
        }

        return false;
    }

    return true;
}

/*****************************************************************************
 *
 *  See if the value of the given condition expression can be determined
 *  trivially at compile time. The return value is as follows:
 *
 *      -1      The condition is always 'false'
 *       0      The condition value cannot be determined at compile time
 *      +1      The condition is always 'true'
 */

int                 compiler::cmpEvalCondition(Tree cond)
{
    if  (cond->tnOper == TN_CNS_INT)
    {
        if  (cond->tnIntCon.tnIconVal)
            return +1;
        else
            return -1;
    }

    // CONSIDER: Add more tests (like a string literal is always non-zero)

    return 0;
}

/*****************************************************************************
 *
 *  Return an expression that yields the value of "this" (the caller has
 *  already checked that we're in a non-static member function).
 */

inline
Tree                compiler::cmpThisRefOK()
{
    Tree            args;

    assert(cmpThisSym);

    args = cmpCreateVarNode(NULL, cmpThisSym);
    args->tnFlags &= ~TNF_LVALUE;

    return args;
}

/*****************************************************************************
 *
 *  Return an expression that yields the value of "this". If we're not in
 *  a non-static member function, an error is issued and NULL is returned.
 */

Tree                compiler::cmpThisRef()
{
    if  (cmpThisSym)
    {
        return  cmpThisRefOK();
    }
    else
    {
        return  cmpCreateErrNode(ERRbadThis);
    }
}

/*****************************************************************************
 *
 *  Given an expression that refers to a member of the current class,
 *  prefix it with an implicit "this." reference.
 */

Tree                compiler::cmpBindThisRef(SymDef sym)
{
    /* Make sure we have a 'this' pointer */

    if  (cmpThisSym)
    {
        Tree            expr;

        /* Create a variable member reference off of 'this' */

        expr = cmpCreateExprNode(NULL, TN_VAR_SYM, sym->sdType);

        expr->tnVarSym.tnVarObj = cmpThisRef();
        expr->tnVarSym.tnVarSym = sym;

        if  (!sym->sdVar.sdvConst && !sym->sdIsSealed)
            expr->tnFlags |= TNF_LVALUE;

        return expr;
    }

    cmpErrorQnm(ERRmemWOthis, sym);
    return cmpCreateErrNode();
}

/*****************************************************************************
 *
 *  We've got an expression that references an anonymous union member. Return
 *  a fully qualified access expression that will select the proper member.
 */

Tree                compiler::cmpRefAnUnionMem(Tree expr)
{
    SymDef          sym;
    SymDef          uns;
    Tree            obj;

    assert(expr->tnOper == TN_VAR_SYM);

    sym = expr->tnVarSym.tnVarSym; assert(sym->sdSymKind == SYM_VAR);
    uns = sym->sdParent;           assert(symTab::stIsAnonUnion(uns));
    obj = expr->tnVarSym.tnVarObj; assert(obj);

    do
    {
        Tree            temp;
        SymXinfoSym     tmem = cmpFindSymInfo(uns->sdClass.sdcExtraInfo, XI_UNION_MEM);

        assert(tmem);

        /* Insert an explicit member selector */

        temp = cmpCreateExprNode(NULL, TN_VAR_SYM, uns->sdType);

        temp->tnVarSym.tnVarObj = obj;
        temp->tnVarSym.tnVarSym = tmem->xiSymInfo;

        obj = temp;
        sym = uns;
        uns = uns->sdParent;
    }
    while (symTab::stIsAnonUnion(uns));

    expr->tnVarSym.tnVarObj = obj;

    return  expr;
}

/*****************************************************************************
 *
 *  Create a reference to a data member of a class or a global variable.
 */

Tree                compiler::cmpRefMemberVar(Tree expr, SymDef sym, Tree objx)
{
    assert(sym);
    assert(sym->sdSymKind == SYM_VAR || sym->sdSymKind == SYM_PROP);

    /* Make sure we are allowed to access the variable */

    cmpCheckAccess(sym);

    /* Has the member been marked as "deprecated" ? */

    if  (sym->sdIsImport && (sym->sdIsDeprecated || (sym->sdIsMember && sym->sdParent->sdIsDeprecated)))
    {
        if  (sym->sdIsDeprecated)
        {
            if  (sym->sdSymKind == SYM_VAR)
                cmpObsoleteUse(sym, WRNdepFld);
            else
                cmpObsoleteUse(sym, WRNdepProp);
        }
        else
        {
            cmpObsoleteUse(sym->sdParent, WRNdepCls);
        }
    }

    /* Prefix with 'this' if this is a non-static member */

    if  (sym->sdIsStatic || !sym->sdIsMember)
    {
        /* Static member -- make sure this is not a forward reference */

        if  (sym->sdCompileState < CS_CNSEVALD)
        {
            if  (sym->sdSymKind == SYM_VAR)
            {
                if  (sym->sdVar.sdvInEval ||
                     sym->sdVar.sdvDeferCns)
                {
                    cmpEvalCnsSym(sym, true);
                }
                else
                    cmpDeclSym(sym);
            }
            else
                cmpDeclSym(sym);

            sym->sdCompileState = CS_CNSEVALD;
        }

        /* Create a data member reference */

        expr->tnOper            = TN_VAR_SYM;
        expr->tnType            = sym->sdType;
        expr->tnVtyp            = sym->sdType->tdTypeKind;

        expr->tnVarSym.tnVarSym = sym;
        expr->tnVarSym.tnVarObj = objx;

        /* Is this a variable or a property? */

        if  (sym->sdSymKind == SYM_VAR)
        {
            /* Is the variable a constant? */

//          if  (sym->sdName && !strcmp(sym          ->sdSpelling(), "MinValue")
//                           && !strcmp(sym->sdParent->sdSpelling(), "SByte")) forceDebugBreak();

            if  (sym->sdVar.sdvConst)
            {
                expr = cmpFetchConstVal(sym->sdVar.sdvCnsVal, expr);
            }
            else
            {
                if (!sym->sdIsSealed)
                    expr->tnFlags |= TNF_LVALUE;
            }
        }
        else
        {
            expr->tnOper   = TN_PROPERTY;
            expr->tnFlags |= TNF_LVALUE;
        }
    }
    else
    {
        SymDef          cls;

        /* Non-static member -- we'll need an object address */

        if  (objx)
        {
            /* Create a data member reference */

            expr->tnOper            = TN_VAR_SYM;
            expr->tnType            = sym->sdType;
            expr->tnVtyp            = sym->sdType->tdTypeKind;

            expr->tnVarSym.tnVarSym = sym;
            expr->tnVarSym.tnVarObj = objx;

            if  (!sym->sdIsSealed)
                expr->tnFlags |= TNF_LVALUE;
        }
        else
        {
            /* Caller didn't supply an object address, use "this" implicitly */

            if  (cmpCurCls == NULL)
            {
            NO_THIS:
                cmpErrorQnm(ERRmemWOthis, sym);
                return cmpCreateErrNode();
            }

            cls = cmpSymbolOwner(sym); assert(cls && cls->sdSymKind == SYM_CLASS);

            if  (!cmpIsBaseClass(cls->sdType, cmpCurCls->sdType))
                goto NO_THIS;

            expr = cmpBindThisRef(sym);
            if  (expr->tnOper == TN_ERROR)
                return  expr;

            assert(expr->tnOper == TN_VAR_SYM);
            objx = expr->tnVarSym.tnVarObj;
        }

        /* Is this a "normal" member or property? */

        if  (sym->sdSymKind == SYM_VAR)
        {
            /* Is this a bitfield member? */

            if  (sym->sdVar.sdvBitfield)
            {
                assert(sym->sdIsStatic == false);
                assert(objx);

                /* Change the node to a bitfield */

                expr->tnOper            = TN_BFM_SYM;

                expr->tnBitFld.tnBFinst = objx;
                expr->tnBitFld.tnBFmsym = sym;
                expr->tnBitFld.tnBFoffs = sym->sdVar.sdvOffset;
                expr->tnBitFld.tnBFlen  = sym->sdVar.sdvBfldInfo.bfWidth;
                expr->tnBitFld.tnBFpos  = sym->sdVar.sdvBfldInfo.bfOffset;
            }
        }
        else
        {
            expr->tnOper = TN_PROPERTY;
        }
    }

    /* Special case: member of anonymous union */

    if  (sym->sdSymKind == SYM_VAR && sym->sdVar.sdvAnonUnion)
    {
        assert(expr->tnVarSym.tnVarSym == sym);
        assert(expr->tnVarSym.tnVarObj != NULL);

        expr = cmpRefAnUnionMem(expr);
    }

    return  cmpDecayCheck(expr);
}

/*****************************************************************************
 *
 *  Bind a reference to a simple name.
 */

Tree                compiler::cmpBindName(Tree expr, bool isCall,
                                                     bool classOK)
{
    SymTab          ourStab = cmpGlobalST;

    Ident           name;
    name_space      nsp;
    SymDef          scp;
    SymDef          sym;

    /* Is the operand a qualified symbol name? */

    if  (expr->tnOper == TN_ANY_SYM)
    {
        sym = expr->tnSym.tnSym;
        scp = expr->tnSym.tnScp;
        goto CHKSYM;
    }

    assert(expr->tnOper == TN_NAME);

    /* Lookup the name in the current context */

    name = expr->tnName.tnNameId;

    /* Figure out what namespace to look in */

    nsp  = NS_NORM;
    if  (classOK)
        nsp = (name_space)(NS_TYPE|NS_NORM);
    if  (expr->tnFlags & TNF_NAME_TYPENS)
        nsp = NS_TYPE;

    scp = NULL;
    sym = ourStab->stLookupSym(name, nsp);

#ifdef  SETS

    /* Was the name found within an implicit scope ? */

    if  (ourStab->stImplicitScp)
    {
        SymDef          var;
        Tree            dotx;

        /* Grab the implicit scope and clear it */

        scp = ourStab->stImplicitScp;
              ourStab->stImplicitScp = NULL;

        assert(scp->sdIsImplicit && scp->sdSymKind == SYM_SCOPE);

        /* The scope better contain exactly one variable */

        var = scp->sdScope.sdScope.sdsChildList; assert(var);

#ifndef NDEBUG
        for (SymDef sibling = var->sdNextInScope; sibling; sibling = sibling->sdNextInScope)
            assert(sibling->sdSymKind == SYM_SCOPE);
#endif

        /* Create a "var.name" tree and bind it */

        dotx = cmpParser->parseCreateNode(TN_ANY_SYM);
        dotx->tnSym.tnSym = var;
        dotx->tnSym.tnScp = NULL;

        dotx = cmpParser->parseCreateOperNode(TN_DOT, dotx, expr);

        return  cmpBindDotArr(dotx, isCall, classOK);
    }

#endif

    if  (!sym)
    {
        /* Special case: "va_start" and "va_arg" */

        if  (name == cmpIdentVAbeg && isCall)
        {
            sym = cmpFNsymVAbeg;
            if  (!sym)
            {
                sym = cmpFNsymVAbeg = ourStab->stDeclareSym(name, SYM_FNC, NS_HIDE, NULL);
                sym->sdType = cmpTypeVoidFnc;
            }

            goto CHKSYM;
        }

        if  (name == cmpIdentVAget && isCall)
        {
            sym = cmpFNsymVAget;
            if  (!sym)
            {
                sym = cmpFNsymVAget = ourStab->stDeclareSym(name, SYM_FNC, NS_HIDE, NULL);
                sym->sdType = cmpTypeVoidFnc;
            }

            goto CHKSYM;
        }

        /* Declare a symbol in the current function to prevent repeated errors */

        sym = ourStab->stDeclareLcl(name,
                                    SYM_ERR,
                                    NS_NORM,
                                    cmpCurScp,
                                    &cmpAllocCGen);

        sym->sdType         = ourStab->stIntrinsicType(TYP_UNDEF);
        sym->sdCompileState = CS_DECLARED;

        cmpRecErrorPos(expr);
        cmpError(ERRundefName, expr->tnName.tnNameId);
        return cmpCreateErrNode();
    }

CHKSYM:

    /* Make sure the name looks kosher */

    switch (sym->sdSymKind)
    {
        TypDef          type;
        TypDef          base;

    case SYM_VAR:
    case SYM_PROP:

        /* Make sure a variable is acceptable here */

        if  (isCall)
        {
            /* No good - we need a function here */

            switch (sym->sdType->tdTypeKind)
            {
            case TYP_UNDEF:
                break;

            case TYP_PTR:

                /* Pointer to function is acceptable for calls */

                base = cmpActualType(sym->sdType->tdRef.tdrBase);
                if  (base->tdTypeKind == TYP_FNC)
                    goto MEM_REF;

                // Fall through ...

            default:
                cmpError(ERRnotAfunc, sym);
            }

            return cmpCreateErrNode();
        }

    MEM_REF:

        /* In case something goes wrong ... */

        cmpRecErrorPos(expr);

        /* Is this a local variable or a class member? */

        if  (sym->sdIsMember || !sym->sdVar.sdvLocal)
            expr = cmpRefMemberVar (expr, sym);
        else
            expr = cmpCreateVarNode(expr, sym);

        /* Indirect through the result if we have a fn ptr call */

        if  (isCall)
        {
            assert(sym->sdType->tdTypeKind == TYP_PTR);
            assert(base->tdTypeKind == TYP_FNC);

            expr = cmpCreateExprNode(NULL, TN_IND, base, expr, NULL);
        }

        break;

    case SYM_FNC:

        assert((int)scp != 0xDDDDDDDD);

        /* If we've found a function, it must be a global or a member of our class */

        expr = cmpCreateExprNode(expr, TN_FNC_SYM, sym->sdType);
        expr->tnFncSym.tnFncSym  = sym;
        expr->tnFncSym.tnFncArgs = NULL;
        expr->tnFncSym.tnFncObj  = NULL;
        expr->tnFncSym.tnFncScp  = scp;

        if  (sym->sdIsMember && !sym->sdIsStatic && cmpThisSym && cmpCurCls != sym->sdParent)
        {
            SymDef          fncClsSym = sym->sdParent;

            assert(cmpCurCls && cmpCurCls->sdSymKind == SYM_CLASS && cmpCurCls == cmpCurFncSym->sdParent);
            assert(fncClsSym && fncClsSym->sdSymKind == SYM_CLASS);

            /* Is the function a member of our class or its base? */

            if  (cmpIsBaseClass(cmpCurCls->sdType, fncClsSym->sdType))
                expr->tnFncSym.tnFncObj = cmpThisRefOK();
        }

        /* Make sure a function member is acceptable here */

        if  (!isCall)
        {
            /* Presumably we're passing a function pointer */

            if  (sym->sdIsMember && !sym->sdIsStatic)
            {
                expr->tnOper = TN_FNC_PTR;
            }
            else
            {
                expr = cmpCreateExprNode(NULL,
                                         TN_ADDROF,
                                         cmpGlobalST->stNewRefType(TYP_PTR, expr->tnType),
                                         expr,
                                         NULL);
            }
        }

        break;

    case SYM_ENUM:
    case SYM_CLASS:

        /* If a class/enum name isn't acceptable here, report that and bail */

        if  (!classOK)
        {
        BAD_USE:

            cmpRecErrorPos(expr);
            cmpErrorQnm(ERRbadNameUse, sym);

            return cmpCreateErrNode();
        }

        /* Make sure the class/enum type is fully defined before proceeding */

        cmpDeclSym(sym);

        expr->tnOper     = TN_CLASS;
        expr->tnType     = sym->sdType;
        expr->tnVtyp     = sym->sdType->tdTypeKind;

        expr->tnOp.tnOp1 =
        expr->tnOp.tnOp2 = NULL;

        return expr;

    case SYM_NAMESPACE:

        /* If a class/namespace name isn't acceptable here, pretend it's undefined */

        if  (!classOK)
            goto BAD_USE;

        expr->tnOper            = TN_NAMESPACE;
        expr->tnType            = cmpTypeVoid;
        expr->tnVtyp            = TYP_VOID;
        expr->tnLclSym.tnLclSym = sym;

        return expr;

    case SYM_ENUMVAL:

        type = sym->sdType;
        assert(type->tdTypeKind == TYP_ENUM);

        /* Has the enum value been marked as "deprecated" ? */

        if  (sym->sdIsImport && (sym->sdIsDeprecated || (sym->sdIsMember && sym->sdParent->sdIsDeprecated)))
        {
            if  (sym->sdIsDeprecated)
                cmpObsoleteUse(sym, WRNdepEnum);
            else
                cmpObsoleteUse(sym->sdParent, WRNdepCls);
        }

        /* Make sure we have the enum member's value */

        if  (!sym->sdIsDefined)
        {
            if  (sym->sdCompileState == CS_DECLSOON)
            {
                cmpError(ERRcircDep, sym);
                sym->sdCompileState = CS_DECLARED;
            }
            else
                cmpDeclEnum(type->tdEnum.tdeSymbol);
        }

        /* Fetch the value of the enum */

        if  (type->tdEnum.tdeIntType->tdTypeKind >= TYP_LONG)
            expr = cmpCreateLconNode(expr, *sym->sdEnumVal.sdEV.sdevLval, TYP_LONG);
        else
            expr = cmpCreateIconNode(expr,  sym->sdEnumVal.sdEV.sdevIval, TYP_INT);

        expr->tnType = sym->sdType;
        expr->tnVtyp = TYP_ENUM;
        break;

    case SYM_ERR:
        return cmpCreateErrNode();

    default:
        assert(!"unexpected symbol kind");
    }

    return expr;
}

/*****************************************************************************
 *
 *  Bind a dotted or arrowed name reference. Such a name may mean a number
 *  of things, for example:
 *
 *      instance->data_member
 *      instance->func_member(args)
 *      classname.membername
 *
 *  etc...
 */

Tree                compiler::cmpBindDotArr(Tree expr, bool isCall, bool classOK)
{
    Tree            opTree;
    Tree            nmTree;
    Tree            objPtr;
    TypDef          clsTyp;
    SymDef          clsSym;
    Ident           memNam;
    SymDef          memSym;
    Tree            args;
    name_space      nsp;

    unsigned        flags  = expr->tnFlags;
    TypDef          boxCls = NULL;

    assert(expr->tnOper == TN_DOT  ||
           expr->tnOper == TN_ARROW);

    /*
        We have to check for the special strange case of multiple dots,
        since in that case the parse tree will have the wrong order for
        binding the dots (which needs to be done left to right).
     */

    opTree = expr->tnOp.tnOp1;
    nmTree = expr->tnOp.tnOp2;
    assert(nmTree->tnOper == TN_NAME);
    memNam = nmTree->tnName.tnNameId;

//  static int x; if (++x == 0) forceDebugBreak();

    /* Figure out what namespace to look in */

    nsp  = classOK ? (name_space)(NS_TYPE|NS_NORM)
                   : NS_NORM;

    /* See if the left operand is a name or another dot */

    switch (opTree->tnOper)
    {
    case TN_DOT:
    case TN_ARROW:
        objPtr = cmpBindDotArr (opTree, false, true);
        break;

    case TN_NAME:
    case TN_ANY_SYM:
        objPtr = cmpBindNameUse(opTree, false, true);
        break;

    default:
        objPtr = cmpBindExprRec(opTree);
        break;
    }

    if  (objPtr->tnVtyp == TYP_UNDEF)
        return objPtr;

    /* Check for some special cases */

    switch (objPtr->tnOper)
    {
        SymDef          nspSym;

    case TN_CLASS:

        if  (expr->tnOper == TN_ARROW)
            cmpError(ERRbadArrowNC);

        clsTyp = objPtr->tnType;
        objPtr = NULL;

        if  (clsTyp->tdTypeKind == TYP_ENUM)
        {
            SymDef          enumSym = clsTyp->tdEnum.tdeSymbol;

            assert(enumSym && enumSym->sdSymKind == SYM_ENUM);

            if  (enumSym->sdCompileState < CS_DECLARED)
                cmpDeclEnum(enumSym, true);

            memSym = cmpGlobalST->stLookupScpSym(memNam, enumSym);

            if  (!memSym)
            {
                cmpError(ERRnotMember, enumSym, memNam);
                return cmpCreateErrNode();
            }

            expr->tnOper      = TN_ANY_SYM;
            expr->tnSym.tnSym = memSym;
            expr->tnSym.tnScp = NULL;

            return  cmpBindName(expr, false, false);
        }
        break;

    case TN_NAMESPACE:

        if  (expr->tnOper == TN_ARROW)
            cmpError(ERRbadArrowNC);

        /* We have "namespace.name" */

        nspSym = objPtr->tnLclSym.tnLclSym;

        assert(nspSym);
        assert(nspSym->sdSymKind == SYM_NAMESPACE);

        /* Is it OK to have a class/package name here? */

        if  (!classOK)
        {
            cmpErrorQnm(ERRbadNameUse, nspSym);
            return cmpCreateErrNode();
        }

        /* Look for a matching nested namespace or class */

        memSym = cmpGlobalST->stLookupNspSym(memNam, NS_NORM, nspSym);
        if  (!memSym)
        {
            cmpError(ERRundefNspm, nspSym, memNam);
            return cmpCreateErrNode();
        }

        /* Set the node to class/namespace as appropriate */

        switch (memSym->sdSymKind)
        {
        case SYM_NAMESPACE:
            objPtr->tnLclSym.tnLclSym = memSym;
            break;

        case SYM_ENUM:
        case SYM_CLASS:

        CLS_REF:

            objPtr = cmpCreateExprNode(objPtr, TN_CLASS, memSym->sdType, NULL, NULL);
            break;

        default:
            assert(!"unexpected namespace member found");
        }

        return objPtr;

    default:

        /* The first operand must be a class */

        clsTyp = objPtr->tnType;

        if  (clsTyp->tdTypeKind != TYP_REF &&
             clsTyp->tdTypeKind != TYP_PTR)
        {
            /* OK, we'll take "array.length" as well */

            if  (clsTyp->tdTypeKind != TYP_ARRAY)
            {
                TypDef          type;

                /* Remember the type we started with */

                boxCls = clsTyp;

                /* If this is a dot, we'll also allow structs */

                if  (expr->tnOper == TN_DOT && clsTyp->tdTypeKind == TYP_CLASS)
                {
                    var_types       ptrVtp;
                    TypDef          ptrTyp;

                    /* Does the class have a matching member? */

                    if  (!cmpGlobalST->stLookupClsSym(memNam, clsTyp->tdClass.tdcSymbol))
                    {
                        Tree            objx;

                        /* Is there an implicit conversion to object? */

                        objx = cmpCheckConvOper(objPtr, NULL, cmpObjectRef(), false);
                        if  (objx)
                        {
                            boxCls = NULL;
                            objPtr = objx;
                            clsTyp = cmpClassObject->sdType;
                            break;
                        }
                    }

                    /* Take the address of the operand and use "->" on it */

                    ptrVtp = clsTyp->tdIsManaged ? TYP_REF : TYP_PTR;
                    ptrTyp = cmpGlobalST->stNewRefType(ptrVtp, clsTyp);

                    /* The address of "*ptr" is "ptr", of course */

                    if  (objPtr->tnOper == TN_IND)
                    {
                        objPtr         = objPtr->tnOp.tnOp1;
                        objPtr->tnType = ptrTyp;
                        objPtr->tnVtyp = ptrVtp;
                    }
                    else
                    {
                        objPtr = cmpCreateExprNode(NULL,
                                                   TN_ADDROF,
                                                   ptrTyp,
                                                   objPtr,
                                                   NULL);
                    }

                    break;
                }

                type = cmpCheck4valType(clsTyp);

                /* Is this a struct equivalent of an intrinsic type? */

                if  (type)
                {
                    objPtr = cmpCoerceExpr(objPtr, type, false);
                    objPtr = cmpCreateExprNode(NULL,
                                               TN_ADDROF,
                                               type->tdClass.tdcRefTyp,
                                               objPtr,
                                               NULL);
                    clsTyp =
                    boxCls = type;
                }
                else
                {
                    objPtr = cmpCoerceExpr(objPtr, cmpRefTpObject, false);
                    clsTyp = cmpClassObject->sdType;
                }
                break;

            DOT_ERR:

                cmpError((expr->tnOper == TN_DOT) ? ERRbadDotOp
                                                  : ERRbadArrOp, clsTyp);
                return cmpCreateErrNode();
            }

            /* We have an array value followed by "." */

            assert(objPtr->tnVtyp == TYP_ARRAY);


            /* Simply treat the value as having the type 'System.Array' */

            clsSym         = cmpClassArray;

            objPtr->tnType = cmpArrayRef();
            objPtr->tnVtyp = TYP_REF;

            memSym = cmpGlobalST->stLookupAllCls(memNam, clsSym, NS_NORM, CS_DECLARED);
            if  (memSym)
                goto FOUND_MEM;

            cmpError(ERRnotMember, clsTyp, memNam);
            return cmpCreateErrNode();
        }

        clsTyp = clsTyp->tdRef.tdrBase;

        if  (clsTyp->tdTypeKind != TYP_CLASS)
            goto DOT_ERR;

        break;
    }

    /* Lookup the name (the second operand) in the class */

    assert(clsTyp->tdTypeKind == TYP_CLASS);
    clsSym = clsTyp->tdClass.tdcSymbol;

    memSym = cmpGlobalST->stLookupAllCls(memNam, clsSym, nsp, CS_DECLARED);

    if  (!memSym)
    {


        cmpError(ERRnotMember, clsSym, memNam);
        return cmpCreateErrNode();
    }

FOUND_MEM:

    /* Is it a data or function member (or a property) ? */

    switch (memSym->sdSymKind)
    {
    case SYM_FNC:

        args = cmpCreateExprNode(NULL, isCall ? TN_FNC_SYM
                                              : TN_FNC_PTR, memSym->sdType);

        args->tnFncSym.tnFncObj  = objPtr;
        args->tnFncSym.tnFncSym  = memSym;
        args->tnFncSym.tnFncArgs = NULL;
        args->tnFncSym.tnFncScp  = clsSym;

        if  (boxCls && memSym->sdParent->sdType != boxCls && objPtr->tnOper != TN_BOX
                                                          && objPtr->tnOper != TN_ERROR)
        {
            if  (objPtr->tnOper == TN_ADDROF)
            {
                objPtr = objPtr->tnOp.tnOp1;
            }
            else
            {
                assert(objPtr->tnOper == TN_UNBOX);
            }

            assert(clsTyp->tdTypeKind == TYP_CLASS);

            args->tnFncSym.tnFncObj = cmpCreateExprNode(NULL,
                                                        TN_BOX,
                                                        clsTyp->tdClass.tdcRefTyp,
                                                        objPtr);
        }
        break;

    case SYM_VAR:
    case SYM_PROP:

        if  (isCall)
        {
            cmpError(ERRbadArgs, memSym);
            return cmpCreateErrNode();
        }

        /* In case something goes wrong ... */

        cmpRecErrorPos(nmTree);

        /* Make sure we can access the member this way */

        args = cmpRefMemberVar(nmTree, memSym, objPtr);

        /* Is this a property reference? */

        if  (args->tnOper == TN_PROPERTY)
        {
            if  (!(flags & TNF_ASG_DEST))
                args = cmpBindProperty(args, NULL, NULL);
        }

        break;

    case SYM_CLASS:
        goto CLS_REF;

    default:
        UNIMPL(!"unexpected symbol kind");
    }

    return args;
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  Bind a slicing operator: "bag_expr .. field".
 */

Tree                compiler::cmpBindSlicer(Tree expr)
{
    Tree            opTree;
    Tree            nmTree;
    Ident           memNam;
    TypDef          memTyp;
    SymDef          memSym;
    SymDef          clsSym;

    TypDef          collTp;
    TypDef          elemTp;

    assert(expr->tnOper == TN_DOT2);

    opTree = expr->tnOp.tnOp1;
    nmTree = expr->tnOp.tnOp2;

    /* Get hold of the field name */

    assert(nmTree->tnOper == TN_NAME);
    memNam = nmTree->tnName.tnNameId;

    /* Bind the first operand and make sure it's a bag */

    opTree = cmpBindExprRec(opTree);

    if  (opTree->tnVtyp != TYP_REF)
    {
        if  (opTree->tnVtyp == TYP_UNDEF)
            return  opTree;

    BAD_COLL:

        cmpError(ERRnotCollExpr, opTree->tnType);
        return cmpCreateErrNode();
    }

    collTp = opTree->tnType;
    elemTp = cmpIsCollection(collTp->tdRef.tdrBase);
    if  (!elemTp)
        goto BAD_COLL;

    assert(elemTp->tdTypeKind == TYP_CLASS);

#ifdef DEBUG
//  printf("Object expr:\n");
//  cmpParser->parseDispTree(opTree);
//  printf("Field   name = '%s'\n", memNam->idSpelling());
//  printf("Element type = '%s'\n", cmpGlobalST->stTypeName(elemTp, NULL, NULL, NULL, false));
#endif

    /* Lookup the name (the second operand) in the class */

    assert(elemTp->tdTypeKind == TYP_CLASS);
    clsSym = elemTp->tdClass.tdcSymbol;

    memSym = cmpGlobalST->stLookupAllCls(memNam, clsSym, NS_NORM, CS_DECLARED);

    if  (!memSym)
    {
        cmpError(ERRnotMember, clsSym, memNam);
        return cmpCreateErrNode();
    }

    /* In case something goes wrong ... */

    cmpRecErrorPos(nmTree);

    /* Is it a data or function member (or a property) ? */

    switch (memSym->sdSymKind)
    {
        Tree            call;
        Tree            args;

        Tree            typx;
        Ident           mnam;
        Tree            name;

        TypDef          tmpTyp;
        SymDef          hlpSym;
        SymDef          collCls;

    case SYM_VAR:
    case SYM_PROP:

        /* Make sure we can access the member */

        cmpCheckAccess(memSym);

        /* Has the member been marked as "deprecated" ? */

        if  (memSym->sdIsImport)
        {
            if  (memSym->sdIsDeprecated)
            {
                if  (memSym->sdSymKind == SYM_VAR)
                    cmpObsoleteUse(memSym, WRNdepFld);
                else
                    cmpObsoleteUse(memSym, WRNdepProp);
            }
            else
            {
                if  (clsSym->sdIsDeprecated)
                    cmpObsoleteUse(clsSym, WRNdepCls);
            }
        }

        /* The member/property better not be static */

        if  (memSym->sdIsStatic)
            return cmpCreateErrNode(ERRsliceKind);

        /* The member must have a class type */

        memTyp = cmpActualType(memSym->sdType);

        if  (memTyp->tdTypeKind != TYP_REF || !memTyp->tdIsManaged)
        {
        BAD_SLTP:
            UNIMPL(!"sorry, for now you can't slice on a field with an intrinsic type");
        }

        /* Do we need to flatten the result? */

        tmpTyp = cmpIsCollection(memTyp->tdRef.tdrBase);

        if  (tmpTyp)
        {
            if  (tmpTyp->tdTypeKind != TYP_CLASS || !tmpTyp->tdIsManaged)
                goto BAD_SLTP;

            memTyp = tmpTyp->tdClass.tdcRefTyp;
        }

#ifdef DEBUG
//      printf("Result  type = '%s'\n", cmpGlobalST->stTypeName(memTyp, NULL, NULL, NULL, false));
#endif

        /* Get hold of the resulting type (collection of the field type) */

        assert(memTyp->tdTypeKind == TYP_REF   && memTyp->tdIsManaged);
        assert(collTp->tdTypeKind == TYP_REF   && collTp->tdIsManaged);
        collTp = collTp->tdRef.tdrBase;

        assert(collTp->tdTypeKind == TYP_CLASS);
        collCls = collTp->tdClass.tdcSymbol;

        assert(collCls->sdSymKind == SYM_CLASS && collCls->sdClass.sdcSpecific);

#ifdef DEBUG
//      printf("specfic type = '%s'\n", cmpGlobalST->stTypeName(collTp                              , NULL, NULL, NULL, false));
//      printf("generic type = '%s'\n", cmpGlobalST->stTypeName(collCls->sdClass.sdcGenClass->sdType, NULL, NULL, NULL, false));
#endif

        collCls = cmpParser->parseSpecificType(collCls->sdClass.sdcGenClass, memTyp->tdRef.tdrBase);

#ifdef DEBUG
//      printf("result  coll = '%s'\n", cmpGlobalST->stTypeName(collCls->sdType, NULL, NULL, NULL, false));
#endif

        /* Is this a property reference? */

        if  (memSym->sdSymKind == SYM_PROP)
        {
            // for now do nothing special, use the 'naked' property name
        }

        /* Create the call to the slicing helper */

        assert(cmpClassDBhelper);

        hlpSym = cmpGlobalST->stLookupClsSym(cmpIdentDBslice, cmpClassDBhelper); assert(hlpSym);

        mnam = memSym->sdName;
        typx = cmpTypeIDinst(collCls->sdType);
        name = cmpCreateSconNode(mnam->idSpelling(),
                                 mnam->idSpellLen(),
                                 0,
                                 cmpStringRef());

        args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid,   typx, NULL);
        args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid,   name, args);
        args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, opTree, args);

        call = cmpCreateExprNode(expr, TN_FNC_SYM, collCls->sdType->tdClass.tdcRefTyp);
        call->tnFncSym.tnFncSym  = hlpSym;
        call->tnFncSym.tnFncArgs = args;
        call->tnFncSym.tnFncObj  = NULL;
        call->tnFncSym.tnFncScp  = NULL;

//      cmpParser->parseDispTree(call);

        return  call;

    default:
        return cmpCreateErrNode(ERRsliceKind);
    }
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  Returns non-zero if the given expression (or expression list) contains
 *  a TYP_UNDEF entry.
 */

bool                compiler::cmpExprIsErr(Tree expr)
{
    while   (expr)
    {
        if  (expr->tnVtyp == TYP_UNDEF)
            return true;

        if  (expr->tnOper != TN_LIST)
            break;

        if  (expr->tnOp.tnOp1->tnVtyp == TYP_UNDEF)
            return true;

        expr = expr->tnOp.tnOp2;
    }

    return false;
}

/*****************************************************************************
 *
 *  Given an integer or floating-point constant, figure out the smallest
 *  type the value fits in.
 */

var_types           compiler::cmpConstSize(Tree expr, var_types vtp)
{
    if  (expr->tnFlags & TNF_BEEN_CAST)
        return  vtp;

    if  (expr->tnOper == TN_CNS_INT)
    {
        if  (vtp > TYP_NATINT)
            return vtp;

        __int32     value = expr->tnIntCon.tnIconVal;

        if  (value < 128   && value >= -128)
            return TYP_CHAR;

        if  (value < 256   && value >= 0)
            return TYP_UCHAR;

        if  (value < 32768 && value >= -32768)
            return TYP_SHORT;

        if  (value < 65536 && value >= 0)
            return TYP_SHORT;
    }

    return  vtp;
}

/*****************************************************************************
 *
 *  Given a value of type Object, unbox it to the specified type.
 */

Tree                compiler::cmpUnboxExpr(Tree expr, TypDef type)
{
    TypDef          ptrt;

    /* Special case: "Object -> struct" may be a conversion */

    if  (type->tdTypeKind == TYP_CLASS)
    {
        Tree            conv;

        /* Look for an appropriate overloaded conversion operator */

        conv = cmpCheckConvOper(expr, NULL, type, true);
        if  (conv)
            return  conv;
    }

    ptrt = cmpGlobalST->stNewRefType(TYP_PTR, type);

    expr = cmpCreateExprNode(NULL, TN_UNBOX, ptrt, expr);
    expr = cmpCreateExprNode(NULL, TN_IND  , type, expr);

    // ISSUE: Is the result of unboxing an lvalue or not?

    return  expr;
}

/*****************************************************************************
 *
 *  Make sure we didn't mess up a cast (in terms of context flavors).
 */

#ifndef NDEBUG

void                compiler::cmpChk4ctxChange(TypDef type1,
                                               TypDef type2, unsigned flags)
{
    if  (type1->tdTypeKind == TYP_REF &&
         type2->tdTypeKind == TYP_REF)
    {
        TypDef          base1 = cmpGetRefBase(type1);
        TypDef          base2 = cmpGetRefBase(type2);

        if  (base1 && base1->tdTypeKind == TYP_CLASS &&
             base2 && base2->tdTypeKind == TYP_CLASS)
        {
            if  (cmpDiffContext(base1, base2))
            {
                if  ((flags & TNF_CTX_CAST) != 0)
                    return;

                printf("Type 1 = '%s'\n", cmpGlobalST->stTypeName(type1, NULL, NULL, NULL, false));
                printf("Type 2 = '%s'\n", cmpGlobalST->stTypeName(type2, NULL, NULL, NULL, false));

                UNIMPL(!"context change slipped through!");
            }
        }
    }

    if  ((flags & TNF_CTX_CAST) == 0)
        return;

    printf("Type 1 = '%s'\n", cmpGlobalST->stTypeName(type1, NULL, NULL, NULL, false));
    printf("Type 2 = '%s'\n", cmpGlobalST->stTypeName(type2, NULL, NULL, NULL, false));

    UNIMPL(!"bogus context change marked in cast node!");
}

#endif

/*****************************************************************************
 *
 *  The following table yields the conversion cost for arithmetic conversions.
 */

const   unsigned    convCostTypeMin = TYP_BOOL;
const   unsigned    convCostTypeMax = TYP_LONGDBL;

static  signed char arithCost[][convCostTypeMax - convCostTypeMin + 1] =
{
// from       to BOOL   WCHAR  CHAR   UCHAR  SHORT  USHRT  INT    UINT   N-INT  LONG   ULONG  FLOAT  DBL    LDBL
/* BOOL    */  {   0  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  },
/* WCHAR   */  {  20  ,   0  ,  20  ,  20  ,  20  ,   1  ,   1  ,   2  ,   3  ,   4  ,   5  ,   6  ,   7  ,   8  },
/* CHAR    */  {  20  ,   1  ,   0  ,  20  ,   1  ,   2  ,   3  ,   4  ,   5  ,   6  ,   7  ,   8  ,   9  ,  10  },
/* UCHAR   */  {  20  ,   1  ,  20  ,   0  ,   1  ,   2  ,   3  ,   4  ,   5  ,   6  ,   7  ,   8  ,   9  ,  10  },
/* SHORT   */  {  20  ,  20  ,  20  ,  20  ,   2  ,  20  ,   1  ,   2  ,   3  ,   4  ,   5  ,   6  ,   7  ,   8  },
/* USHORT  */  {  20  ,   1  ,  20  ,  20  ,  20  ,   0  ,   1  ,   2  ,   3  ,   4  ,   5  ,   6  ,   7  ,   8  },
/* INT     */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,  20  ,   1  ,   2  ,   3  ,   4  ,   5  ,   6  },
/* UINT    */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,  20  ,   1  ,   2  ,   3  ,   4  ,   5  },
/* NATINT  */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,   1  ,  20  ,  20  ,  20  ,  20  },
/* LONG    */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,  20  ,  20  ,  20  ,  20  },
/* ULONG   */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,  20  ,  20  ,  20  },
/* FLOAT   */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,   1  ,   2  },
/* DOUBLE  */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  ,   1  },
/* LONGDBL */  {  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,  20  ,   0  },
};

static  int         arithConvCost(var_types src, var_types dst)
{
    assert(src >= convCostTypeMin);
    assert(src <= convCostTypeMax);
    assert(dst >= convCostTypeMin);
    assert(dst <= convCostTypeMax);

    return arithCost[src - convCostTypeMin]
                    [dst - convCostTypeMin];
}

/*****************************************************************************
 *
 *  Convert the given expression to the specified type, if possible.
 */

Tree                compiler::cmpCoerceExpr(Tree   expr,
                                            TypDef type, bool explicitCast)
{
    unsigned        kind;
    unsigned        flags  = 0;

    TypDef          srcType = expr->tnType;
    TypDef          dstType = type;

    var_types       srcVtyp;
    var_types       dstVtyp;

//  static int x; if (++x == 0) forceDebugBreak();

AGAIN:

    assert(expr->tnVtyp != TYP_TYPEDEF);

    srcVtyp = srcType->tdTypeKindGet();
    dstVtyp = dstType->tdTypeKindGet();

    /* Are the types identical? */

    if  (srcType == dstType)
    {
        /* Special bizarre case: explicit cast to floating-point */

        if  (srcVtyp == TYP_FLOAT || srcVtyp == TYP_DOUBLE)
        {
            if  (expr->tnOper != TN_CAST && !(expr->tnFlags & TNF_BEEN_CAST))
            {
                /* In MSIL, math operations actually produce "R", not float/double */

                if  (expr->tnOperKind() & (TNK_UNOP|TNK_BINOP))
                {
                    expr->tnVtyp = TYP_LONGDBL;
                    expr->tnType = cmpGlobalST->stIntrinsicType(TYP_LONGDBL);

                    goto RET_CAST;
                }
            }
        }

        /* The result of a coercion is never an lvalue */

        expr->tnFlags &= ~TNF_LVALUE;
        expr->tnFlags |=  TNF_BEEN_CAST;

        return expr;
    }

    /* Have we had errors within the expression? */

    if  (srcVtyp == TYP_UNDEF)
        return expr;

    /* Are the types identical? */

    if  (srcVtyp == dstVtyp)
    {
        if  (cmpGlobalST->stMatchTypes(srcType, dstType))
        {
            /* The result of a coercion is never an lvalue */

            expr->tnFlags &= ~TNF_LVALUE;

            return expr;
        }
    }

//  printf("Cast from '%s'\n", cmpGlobalST->stTypeName(expr->tnType, NULL, NULL, NULL, false));
//  printf("Cast  to  '%s'\n", cmpGlobalST->stTypeName(        type, NULL, NULL, NULL, false));

    /* Are both types arithmetic? */

    if  (varTypeIsArithmetic(dstVtyp) &&
         varTypeIsArithmetic(srcVtyp))
    {
        assert(srcVtyp != dstVtyp);

    ARITH:

        /* A widening cast is almost always OK (except conversions to 'wchar') */

        if  (dstVtyp > srcVtyp)
        {
            /* Are we coercing an integer constant? */

            switch (expr->tnOper)
            {
                bool            uns;

                __int32         sv;
                __uint32        uv;

            case TN_CNS_INT:

                if  (varTypeIsUnsigned(srcVtyp))
                {
                    uns = true;
                    uv  = expr->tnIntCon.tnIconVal;
                }
                else
                {
                    uns = false;
                    sv  = expr->tnIntCon.tnIconVal;
                }

                switch (dstVtyp)
                {
                case TYP_CHAR:
                case TYP_UCHAR:
                case TYP_SHORT:
                case TYP_USHORT:
                case TYP_INT:
                case TYP_NATINT:
                case TYP_NATUINT:
                    // ISSUE: What about sign and range-check?
                    break;

                case TYP_UINT:
                    if  (!uns && sv < 0)
                        cmpWarn(WRNunsConst);
                    break;

                case TYP_LONG:
                case TYP_ULONG:
                    expr->tnOper             = TN_CNS_LNG;
                    expr->tnLngCon.tnLconVal = uns ? (__int64)uv
                                                   : (__int64)sv;
                    break;

                case TYP_FLOAT:
                    expr->tnOper             = TN_CNS_FLT;
                    expr->tnFltCon.tnFconVal = uns ? (float  )uv
                                                   : (float  )sv;
                    break;

                case TYP_DOUBLE:
                case TYP_LONGDBL:
                    expr->tnOper             = TN_CNS_DBL;
                    expr->tnDblCon.tnDconVal = uns ? (double )uv
                                                   : (double )sv;
                    break;

                default:
#ifdef  DEBUG
                    cmpParser->parseDispTree(expr);
                    printf("Cast to type '%s'\n", cmpGlobalST->stTypeName(type, NULL, NULL, NULL, false));
#endif
                    UNIMPL(!"unexpected constant type");
                    break;
                }

            BASH_TYPE:

                /* Come here to bash the type of the operand */

                expr->tnFlags |=  TNF_BEEN_CAST;
                expr->tnFlags &= ~TNF_ADR_IMPLICIT;

#ifdef  DEBUG

                /* Make sure we're not bashing the wrong thing */

                if      (expr->tnVtyp == TYP_CLASS)
                {
                    assert(cmpFindStdValType(dstVtyp     ) == expr->tnType);
                }
                else if (dstVtyp == TYP_CLASS)
                {
                    assert(cmpFindStdValType(expr->tnVtyp) == dstType);
                }
                else
                {
                    switch (expr->tnOper)
                    {
                    case TN_CNS_INT:

                        assert(expr->tnVtyp != TYP_LONG &&
                               expr->tnVtyp != TYP_ULONG);
                        break;

                    case TN_NULL:
                        break;

                    case TN_IND:
                    case TN_INDEX:

                        if  (   cmpGetTypeSize(cmpActualType(dstType)) !=
                                cmpGetTypeSize(cmpActualType(srcType)))
                        {
                            printf("Type size changed:\n");

                        BAD_BASH:

                            printf("Casting from '%s'\n", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
                            printf("Casting  to  '%s'\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));
                            assert(!"bad bash");
                        }

                        if  (varTypeIsUnsigned(cmpActualVtyp(dstType)) !=
                             varTypeIsUnsigned(cmpActualVtyp(srcType)))
                        {
                            printf("Type sign changed:\n");
                            goto BAD_BASH;
                        }

                        // Fall through ...

                    default:
                        if  (explicitCast)
                            cmpChk4ctxChange(expr->tnType, type, 0);
                        break;
                    }
                }

#endif

                assert(dstType->tdTypeKindGet() == dstVtyp);

                expr->tnVtyp   = dstVtyp;
                expr->tnType   = dstType;

                return expr;
            }

            /* Only integer constants may be converted to 'wchar' */

            if  (dstVtyp != TYP_WCHAR)
            {
                int             cost;

                /* Special case: float constants converted 'in place' */

                if  (expr->tnOper == TN_CNS_FLT)
                {
                    assert(dstVtyp == TYP_DOUBLE);

                    expr->tnOper             = TN_CNS_DBL;
                    expr->tnDblCon.tnDconVal = expr->tnFltCon.tnFconVal;
                    goto BASH_TYPE;
                }

                /* Even though "TYP_INT < TYP_UINT" is true, it loses precision */

                cost = arithConvCost(srcVtyp, dstVtyp);

                if  (cost >= 0 && cost < 20)
                    goto RET_CAST;
            }
        }

        /* Special case: NULL cast to an integral type */

        if  (expr->tnOper == TN_NULL)
            goto BASH_TYPE;

        /* A narrowing cast is OK so long as it's an explicit one */

        if  (explicitCast)
            goto RET_CAST;

        /* Special case: integer constant */

        if  (expr->tnOper == TN_CNS_INT && expr->tnVtyp != TYP_ENUM)
        {
            /* Try to shrink the value to be as small as possible */

            expr->tnFlags &= ~TNF_BEEN_CAST; expr = cmpShrinkExpr(expr);

            if  (expr->tnVtyp != srcVtyp)
            {
                srcType = expr->tnType;
                goto AGAIN;
            }
        }

        /* Last chance: in non-pedantic mode let this pass with just a warning */

        if  (!cmpConfig.ccPedantic)
        {
            if  ((srcVtyp == TYP_INT || srcVtyp == TYP_UINT) &&
                 (dstVtyp == TYP_INT || dstVtyp == TYP_UINT))
            {
                goto RET_CAST;
            }

            cmpRecErrorPos(expr); cmpWarn(WRNloseBits, srcType, dstType);
            goto RET_CAST;
        }

        /* This is an illegal implicit cast */

    ERR_IMP:

        cmpRecErrorPos(expr);

        if  (expr->tnOper == TN_NULL && !(expr->tnFlags & TNF_BEEN_CAST))
            cmpError(ERRbadCastNul,         dstType);
        else
            cmpError(ERRbadCastImp, srcType, dstType);

        return cmpCreateErrNode();

    ERR_EXP:

        cmpRecErrorPos(expr);

        if  (expr->tnOper == TN_NULL && !(expr->tnFlags & TNF_BEEN_CAST))
            cmpError(ERRbadCastNul,         dstType);
        else
            cmpError(ERRbadCastExp, srcType, dstType);

        return cmpCreateErrNode();
    }

    /* Let's see what we're casting to */

    switch (dstVtyp)
    {
        TypDef          base;
        Tree            conv;

    case TYP_BOOL:

        /* Nothing can be converted to 'boolean' in pedantic mode */

        if  (explicitCast || !cmpConfig.ccPedantic)
        {
            if  (varTypeIsArithmetic(srcVtyp))
            {
                /* We're presumably materializing a boolean condition */

                if  (expr->tnOper == TN_VAR_SYM)
                {
                    SymDef          memSym = expr->tnVarSym.tnVarSym;

                    assert(memSym->sdSymKind == SYM_VAR);

                    if  (memSym->sdVar.sdvBfldInfo.bfWidth == 1 &&
                         varTypeIsUnsigned(expr->tnVtypGet()))
                    {
                        /* The value being cast to boolean is a 1-bit bitfield */

                        goto BASH_TYPE;
                    }
                }

                cmpRecErrorPos(expr); cmpWarn(WRNconvert, srcType, dstType);

                return  cmpBooleanize(expr, true);
            }

            if  (explicitCast && srcType == cmpObjectRef())
                return  cmpUnboxExpr(expr, type);
        }

        goto TRY_CONVOP;

    case TYP_WCHAR:

        /* An explicit cast is always good, in pedantic mode it's required */

        if  (explicitCast || !cmpConfig.ccPedantic)
        {
            /* Any arithmetic type will do */

            if  (varTypeIsArithmetic(srcVtyp))
                goto RET_CAST;

            if  (explicitCast && srcType == cmpObjectRef())
                return  cmpUnboxExpr(expr, type);
        }

        /* Also allow integer constant 0 and character literals */

        if  (expr->tnOper == TN_CNS_INT && (srcVtyp == TYP_CHAR || !expr->tnIntCon.tnIconVal))
        {
            goto BASH_TYPE;
        }

        goto TRY_CONVOP;

    case TYP_ENUM:

        /* We allow enum's to promote to integer types */

        if  (explicitCast)
        {
            var_types       svtp = cmpActualVtyp(srcType);
            var_types       dvtp = cmpActualVtyp(dstType);

            /* Make sure the target type isn't too small */

            if  (dvtp >= svtp || (explicitCast && varTypeIsArithmetic(srcVtyp)))
            {
                /* It's OK to just bash the type if the sign/size match */

                if  (symTab::stIntrTypeSize(dvtp) == symTab::stIntrTypeSize(svtp) &&
                          varTypeIsUnsigned(dvtp) ==      varTypeIsUnsigned(svtp))
                {
                    goto BASH_TYPE;
                }

                /* Can't just bash the expression, will have to create a cast node */

                goto RET_CAST;
            }
        }

        // Fall through ....

    case TYP_CHAR:
    case TYP_UCHAR:
    case TYP_SHORT:
    case TYP_USHORT:
    case TYP_INT:
    case TYP_UINT:
    case TYP_NATINT:
    case TYP_NATUINT:
    case TYP_LONG:
    case TYP_ULONG:

        /* It's OK to convert from enum's  */

        if  (srcVtyp == TYP_ENUM && dstVtyp != TYP_ENUM)
        {
            /* Get hold of the underlying type of the enum */

            base = srcType->tdEnum.tdeIntType;

            /* If this is an explicit case, it's definitely OK */

            if  (explicitCast)
            {
                expr->tnType = srcType = base;
                expr->tnVtyp = base->tdTypeKindGet();
                goto AGAIN;
            }

            /* Make sure the target type isn't too small */

            srcVtyp = base->tdTypeKindGet();

            if  (srcVtyp == dstVtyp)
                goto BASH_TYPE;
            else
                goto ARITH;
        }

        /* In unsafe mode it's OK to explicitly cast between integer and pointer types */

        if  (srcVtyp == TYP_PTR && explicitCast)
        {
            if  (cmpConfig.ccSafeMode)
                cmpError(ERRunsafeCast, srcType, dstType);

            if  (symTab::stIntrTypeSize(srcVtyp) == symTab::stIntrTypeSize(dstVtyp))
                goto BASH_TYPE;
            else
                goto RET_CAST;
        }

        // Fall through ....

    case TYP_FLOAT:
    case TYP_DOUBLE:
    case TYP_LONGDBL:

        /* An cast from 'wchar' is OK if non-pedantic or explicit */

        if  (srcVtyp == TYP_WCHAR)
        {
            if  (explicitCast || !cmpConfig.ccPedantic)
                goto RET_CAST;
        }

        /* 'bool' can be converted in non-pedantic mode */

        if  (srcVtyp == TYP_BOOL && !cmpConfig.ccPedantic)
        {
            if  (!explicitCast)
                cmpWarn(WRNconvert, srcType, dstType);

            goto RET_CAST;
        }

        if  (explicitCast)
        {
            /* "NULL" can be explicitly cast to an integer type */

            if  (expr->tnOper == TN_NULL && !(expr->tnFlags & TNF_BEEN_CAST))
                goto BASH_TYPE;

            /* Explicit cast from Object is unboxing */

            if  (srcType == cmpObjectRef())
                return  cmpUnboxExpr(expr, type);

            /* Allow explicit cast of unmanaged string literal to integer */

            if  (expr->tnOper == TN_CNS_STR && !(expr->tnFlags & TNF_BEEN_CAST))
            {
                if  (!(expr->tnFlags & TNF_STR_STR))
                    goto BASH_TYPE;
            }
        }

    TRY_CONVOP:

        /* Last chance: look for an overloaded operator */

        if  (srcVtyp == TYP_CLASS)
        {
            conv = cmpCheckConvOper(expr, NULL, dstType, explicitCast);
            if  (conv)
                return  conv;

            if  (srcType->tdIsIntrinsic && dstVtyp < TYP_lastIntrins)
            {
                var_types       cvtp = (var_types)srcType->tdClass.tdcIntrType;

                /* Can we convert to the corresponding intrinsic type? */

                if  (cvtp != TYP_UNDEF)
                {
                    if  (cvtp == dstVtyp)
                        goto BASH_TYPE;

                    srcType = cmpGlobalST->stIntrinsicType(cvtp);
                    expr    = cmpCoerceExpr(expr, srcType, explicitCast);
                    goto AGAIN;
                }
            }
        }

    ERR:

        if  (explicitCast)
            goto ERR_EXP;
        else
            goto ERR_IMP;

    case TYP_VOID:

        /* Anything can be converted to 'void' */

        goto RET_CAST;

    case TYP_PTR:

        if  (explicitCast)
        {
            if  (cmpConfig.ccSafeMode)
                cmpError(ERRunsafeCast, srcType, dstType);

            /* Any pointer can be converted to any other via an explicit cast */

            if  (srcVtyp == TYP_PTR)
                goto BASH_TYPE;

            /* In unsafe mode it's OK to explicitly cast between integers and pointers */

            if  (varTypeIsIntegral(srcVtyp) && !cmpConfig.ccPedantic)
            {
                if  (symTab::stIntrTypeSize(srcVtyp) == symTab::stIntrTypeSize(dstVtyp))
                    goto BASH_TYPE;
                else
                    goto RET_CAST;
            }
        }

        /* Special case - string literal passed to "char *" or "void *" */

        if  (srcVtyp == TYP_REF)
        {
            if  (cmpMakeRawString(expr, dstType))
                goto BASH_TYPE;
        }

        // Fall through ....

    case TYP_REF:

        /* Classes can be converted to classes under some circumstances */

        if  (srcVtyp == dstVtyp)
        {
            TypDef          oldBase;
            TypDef          newBase;

            oldBase = cmpGetRefBase(srcType); if  (!oldBase) return cmpCreateErrNode();
            newBase = cmpGetRefBase(dstType); if  (!newBase) return cmpCreateErrNode();

            /* Unless both are class refs, things don't look too good */

            if  (oldBase->tdTypeKind != TYP_CLASS ||
                 newBase->tdTypeKind != TYP_CLASS)
            {
                /* It's always OK to convert "any *" to "void *" */

                if  (newBase->tdTypeKind == TYP_VOID)
                    goto BASH_TYPE;

                /* Explicit casts of byrefs are allowed as well */

                if  (explicitCast)
                {
                    if  (oldBase->tdTypeKind != TYP_CLASS &&
                         newBase->tdTypeKind != TYP_CLASS)
                    {
                        goto BASH_TYPE;
                    }
                }

                goto CHKNCR;
            }

            /* "NULL" trivially converts to any reference type */

            if  (expr->tnOper == TN_NULL && !(expr->tnFlags & TNF_BEEN_CAST))
                goto BASH_TYPE;

            /* Is the target a base class of the source? */

            if  (cmpIsBaseClass(newBase, oldBase))
            {
                if  (expr->tnOper == TN_NULL)
                    goto BASH_TYPE;

                /* Check for a context change */

//              printf("Check for ctx [1]: %s", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
//              printf(              "-> %s\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));

                if  (cmpDiffContext(newBase, oldBase))
                {
                    if  (explicitCast)
                        flags |= TNF_CTX_CAST;
                    else
                        cmpWarn(WRNctxFlavor, srcType, dstType);
                }

                goto RET_CAST;
            }

            /* Is the source a base class of the target? */

            if  (cmpIsBaseClass(oldBase, newBase))
            {

            EXP_CLS:

                if  (!explicitCast)
                    goto CHKNCR;

                /* This cast will have to be checked at runtime */

                flags |= TNF_CHK_CAST;

                /* Check for a context change */

//              printf("Check for ctx [1]: %s", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
//              printf(              "-> %s\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));

                if  (cmpDiffContext(newBase, oldBase))
                    flags |= TNF_CTX_CAST;

                goto RET_CAST;
            }

            /* Is either type an interface? */

            if  (oldBase->tdClass.tdcFlavor == STF_INTF)
                goto EXP_CLS;
            if  (newBase->tdClass.tdcFlavor == STF_INTF)
                goto EXP_CLS;

            /* Is either type a generic type argument? */

            if  (oldBase->tdIsGenArg || newBase->tdIsGenArg)
            {
                // UNDONE: If the generic type has a strong-enough constraint,
                // UNDONE: the cast may not need to be checked at runtime.

                goto EXP_CLS;
            }

#ifdef  SETS

            /* Are both types instances of the same parameterized type ? */

            if  (oldBase->tdClass.tdcSymbol->sdClass.sdcSpecific &&
                 newBase->tdClass.tdcSymbol->sdClass.sdcSpecific)
            {
                SymDef          oldCls = oldBase->tdClass.tdcSymbol;
                SymDef          newCls = newBase->tdClass.tdcSymbol;

                SymDef          genCls = oldCls->sdClass.sdcGenClass;

                assert(genCls);
                assert(genCls->sdSymKind == SYM_CLASS);
                assert(genCls->sdClass.sdcGeneric);

                if  (genCls == newCls->sdClass.sdcGenClass)
                {
                    GenArgDscA      oldArg = (GenArgDscA)oldCls->sdClass.sdcArgLst;
                    GenArgDscA      newArg = (GenArgDscA)newCls->sdClass.sdcArgLst;

                    /* For now we only allow one actual type argument */

                    if  (oldArg == NULL || oldArg->gaNext != NULL)
                    {
                        UNIMPL("check instance compatibility (?)");
                    }

                    if  (newArg == NULL || newArg->gaNext != NULL)
                    {
                        UNIMPL("check instance compatibility (?)");
                    }

                    assert(oldArg->gaBound && newArg->gaBound);

                    if  (cmpGlobalST->stMatchTypes(oldArg->gaType, newArg->gaType))
                        goto BASH_TYPE;
                }
            }

#endif

            /* Are both delegates? */

            if  (oldBase->tdClass.tdcFlavor == STF_DELEGATE &&
                 newBase->tdClass.tdcFlavor == STF_DELEGATE)
            {
                /* If the referenced types are identical, we're OK */

                if  (cmpGlobalST->stMatchTypes(oldBase, newBase))
                    goto BASH_TYPE;
            }
        }

    CHKNCR:

        if  (dstVtyp == TYP_REF && srcVtyp == TYP_ARRAY)
        {
            /* An array may be converted to 'Object' */

            if  (dstType == cmpObjectRef())
                goto BASH_TYPE;

            /* An array may be converted to 'Array' or to its parents */

            expr->tnType   = srcType = cmpArrayRef();
            expr->tnVtyp   = TYP_REF;
            expr->tnFlags |= TNF_BEEN_CAST;

            if  (srcType == dstType)
                return  expr;

            goto AGAIN;
        }

        /* Special case: 'null' converts to any class ref type */

        if  (expr->tnOper == TN_NULL && !(expr->tnFlags & TNF_BEEN_CAST))
            goto BASH_TYPE;

        if  (type == cmpRefTpObject)
        {
            /* Any managed class ref converts to Object */

            if  (srcVtyp == TYP_REF)
            {
                TypDef          srcBase;

                srcBase = cmpGetRefBase(srcType);
                if  (!srcBase)
                    return cmpCreateErrNode();

                if  (srcBase->tdTypeKind == TYP_CLASS && srcBase->tdIsManaged)
                {
                    /* Check for a context change */

//                  printf("Check for ctx [1]: %s", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
//                  printf(              "-> %s\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));

                    if  (cmpDiffContext(srcBase, cmpClassObject->sdType))
                    {
                        if  (explicitCast)
                        {
                            flags |= TNF_CTX_CAST;
                            goto RET_CAST;
                        }

                        cmpWarn(WRNctxFlavor, srcType, dstType);
                    }

                    goto BASH_TYPE;
                }
            }

            /* Check for a user-defined conversion if value type */

            if  (srcVtyp == TYP_CLASS)
            {
                conv = cmpCheckConvOper(expr, NULL, dstType, explicitCast);
                if  (conv)
                    return  conv;
            }

            if  (explicitCast)
            {
                if  (srcVtyp != TYP_FNC && srcVtyp != TYP_VOID && srcVtyp != TYP_PTR)
                    return  cmpCreateExprNode(NULL, TN_BOX, type, expr);
            }
        }

        if  (expr->tnOper == TN_CNS_INT &&   srcVtyp == TYP_INT
                                        &&   dstVtyp == TYP_PTR
                                        &&   expr->tnIntCon.tnIconVal == 0
                                        && !(expr->tnFlags & TNF_BEEN_CAST))
        {
            /* In non-pedantic mode we let this through with a warning */

            if  (!cmpConfig.ccPedantic)
            {
                cmpRecErrorPos(expr);
                cmpWarn(WRNzeroPtr);
                goto BASH_TYPE;
            }
        }

        /* Look for a user-defined conversion operator if we have a struct */

        if  (srcVtyp == TYP_CLASS)
        {
            TypDef          btyp;

            conv = cmpCheckConvOper(expr, NULL, dstType, explicitCast);
            if  (conv)
                return  conv;

            /* Does the struct implement the target type? */

            btyp = cmpGetRefBase(dstType);

            if  (btyp && btyp->tdTypeKind == TYP_CLASS && cmpIsBaseClass(btyp, srcType))
            {
                /* Box the struct and cast the result */

                srcType = cmpRefTpObject;
                expr    = cmpCreateExprNode(NULL, TN_BOX, srcType, expr);

                /* The cast from object has to be explicit */

                explicitCast = true;

                goto AGAIN;
            }


        }

#if 0

        /* Look for an overloaded operator in the class */

        if  (dstVtyp == TYP_REF)
        {
            conv = cmpCheckConvOper(expr, NULL, dstType, explicitCast);
            if  (conv)
                return  conv;
        }

#endif

        /* Last chance - check for box-and-cast, the most wonderful thing ever invented */

        if  (dstVtyp == TYP_REF && srcVtyp <  TYP_lastIntrins
                                && srcVtyp != TYP_VOID)
        {
            TypDef          boxer = cmpFindStdValType(srcVtyp);

            if  (boxer)
            {
                TypDef          dstBase = cmpGetRefBase(dstType);
                
                if  (dstBase->tdTypeKind == TYP_CLASS && cmpIsBaseClass(dstBase, boxer))
                {
                    expr = cmpCreateExprNode(NULL, TN_BOX, boxer->tdClass.tdcRefTyp, expr);
                    goto RET_CAST;
                }
            }
        }

        goto ERR;

    case TYP_ARRAY:

        /* Are we converting an array to another one? */

        if  (srcVtyp == TYP_ARRAY)
        {
            TypDef          srcBase;
            TypDef          dstBase;

            /* Do we have a matching number dimensions? */

            if  (srcType->tdArr.tdaDcnt != dstType->tdArr.tdaDcnt)
                goto ERR;

            /* Check the element types of the arrays */

            srcBase = cmpDirectType(srcType->tdArr.tdaElem);
            dstBase = cmpDirectType(dstType->tdArr.tdaElem);

            /* If the element types are identical, we're OK */

            if  (cmpGlobalST->stMatchTypes(srcBase, dstBase))
                goto RET_CAST;

            /* Are these both arrays of classes? */

            if  (srcBase->tdTypeKind == TYP_REF &&
                 dstBase->tdTypeKind == TYP_REF)
            {
                /* Pretend we had classes to begin with */

                srcType = srcBase;
                dstType = dstBase;

                goto AGAIN;
            }

            /* Check if one is a subtype of the other */

            if  (symTab::stMatchArrays(srcType, dstType, true))
                goto RET_CAST;

            goto ERR;
        }

        /* 'Object' and 'Array' can sometimes be converted to an array */

        if  (srcVtyp == TYP_REF)
        {
            if  (srcType == cmpArrayRef()) ////////// && explicitCast)   disabled for now, tests break!
            {
                flags |= TNF_CHK_CAST;
                goto RET_CAST;
            }

            if  (srcType == cmpObjectRef())
            {
                /* Special case: 'null' converts to an array type */

                if  (expr->tnOper == TN_NULL)
                    goto BASH_TYPE;

                if  (explicitCast)
                {
                    flags |= TNF_CHK_CAST;
                    goto RET_CAST;
                }
            }
        }

        goto ERR;

    case TYP_UNDEF:
        return cmpCreateErrNode();

    case TYP_CLASS:

        /* Check for unboxing from Object to a struct type */

        if  (srcType == cmpObjectRef() && explicitCast)
            return  cmpUnboxExpr(expr, type);

        /* Look for a user-defined conversion operator */

        conv = cmpCheckConvOper(expr, NULL, dstType, explicitCast);
        if  (conv)
            return  conv;

        /* Check for a downcast */

        if  (srcVtyp == TYP_REF && explicitCast)
        {
            TypDef          srcBase = cmpGetRefBase(srcType);

            /* Is the source a base class of the target? */

            if  (srcBase && srcBase->tdTypeKind == TYP_CLASS
                         && cmpIsBaseClass(srcBase, dstType))
            {
                /* Simply unbox the expression */

                return  cmpUnboxExpr(expr, dstType);
            }
        }

        /* Last chance - let's confuse structs and intrinsics */

        if  (srcVtyp < TYP_lastIntrins)
        {
            var_types       cvtp = (var_types)dstType->tdClass.tdcIntrType;

            /* Can we convert to the corresponding intrinsic type? */

            if  (cvtp != TYP_UNDEF)
            {
                if  (cvtp == srcVtyp)
                    goto BASH_TYPE;
//                  goto RET_CAST;

                dstType = cmpGlobalST->stIntrinsicType(cvtp);
                expr    = cmpCoerceExpr(expr, dstType, explicitCast);
                goto AGAIN;
            }
        }

        goto ERR;

    case TYP_TYPEDEF:

        dstType = dstType->tdTypedef.tdtType;
        goto AGAIN;

    case TYP_REFANY:
        if  (expr->tnOper != TN_ADDROF || (expr->tnFlags & TNF_ADR_IMPLICIT))
            goto ERR;
        goto RET_CAST;

    default:

#ifdef  DEBUG
        printf("Casting from '%s'\n", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
        printf("Casting  to  '%s'\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));
#endif
        assert(!"unhandled target type in compiler::cmpCoerceExpr()");
    }

    /* See what we're casting from */

    switch (srcVtyp)
    {
    case TYP_BOOL:
    case TYP_VOID:

        /* 'boolean' or 'void' can never be converted to anything */

        goto ERR_EXP;

    default:
#ifdef  DEBUG
        printf("Casting from '%s'\n", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
        printf("Casting  to  '%s'\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));
#endif
        assert(!"unhandled source type in compiler::cmpCoerceExpr()");
    }

RET_CAST:

//  if  (expr->tnOper == TN_NULL)  forceDebugBreak();

    /* Don't leave any enum's around */

    if  (expr->tnVtyp == TYP_ENUM)
    {
        expr->tnType = expr->tnType->tdEnum.tdeIntType;
        expr->tnVtyp = expr->tnType->tdTypeKindGet();
    }

#ifndef NDEBUG
    if  (explicitCast) cmpChk4ctxChange(expr->tnType, type, flags);
#endif

    /* Remember whether the operand is a constant or not */

    kind = expr->tnOperKind();

    /* Create the cast expression */

    expr = cmpCreateExprNode(NULL, TN_CAST, type, expr);
    expr->tnFlags |= flags;

    /* Casts to 'bool' must be done differently */

    assert(expr->tnVtyp != TYP_BOOL || srcVtyp == TYP_CLASS && cmpFindStdValType(TYP_BOOL) == srcType);

    if  (kind & TNK_CONST)
    {
        switch (expr->tnOp.tnOp1->tnOper)
        {
        case TN_CNS_INT: expr = cmpFoldIntUnop(expr); break;
        case TN_CNS_LNG: expr = cmpFoldLngUnop(expr); break;
        case TN_CNS_FLT: expr = cmpFoldFltUnop(expr); break;
        case TN_CNS_DBL: expr = cmpFoldDblUnop(expr); break;

        case TN_NULL:
        case TN_CNS_STR: break;

        default: NO_WAY(!"unexpected const type");
        }
    }

    return  expr;
}

/*****************************************************************************
 *
 *  We have a situation where a pointer is expected and an expression was
 *  supplied that appears to have a reference type. We check to see whether
 *  the expression is a string literal, and if so we make it into a "raw"
 *  string (i.e. we change it from "String &" to "char *" or "wchar *").
 */

bool                compiler::cmpMakeRawStrLit(Tree     expr,
                                               TypDef   type, bool chkOnly)
{
    var_types       btp;

    /* We expect the caller to have checked some things already */

    assert(expr->tnVtyp     == TYP_REF);
    assert(type->tdTypeKind == TYP_PTR);

    assert(expr->tnOper == TN_CNS_STR || expr->tnOper == TN_QMARK);

    /* If the type of the expression has been set explicitly, no can do */

    if  (expr->tnFlags & (TNF_BEEN_CAST|TNF_STR_STR))
        return  false;

    /* Make sure the target type is acceptable for a string */

    btp = cmpGetRefBase(type)->tdTypeKindGet();

    switch (btp)
    {
    case TYP_CHAR:
        if  (expr->tnFlags & TNF_STR_WIDE)
            return  false;
        break;

    case TYP_WCHAR:
        if  (expr->tnFlags & TNF_STR_ASCII)
            return  false;
        break;

    case TYP_VOID:
        if  (!(expr->tnFlags & (TNF_STR_ASCII|TNF_STR_WIDE|TNF_STR_STR)))
        {
            if  (!chkOnly)
                expr->tnFlags |= TNF_STR_ASCII; // default for strlit is ANSI

//          return  false;
        }
        break;

    default:
        return  false;
    }

    /* If we have ?:, there is more checking to be done */

    if  (expr->tnOper == TN_QMARK)
    {
        Tree            col1 = expr->tnOp.tnOp2->tnOp.tnOp1;
        Tree            col2 = expr->tnOp.tnOp2->tnOp.tnOp2;

        assert(col1 && cmpIsStringVal(col1));
        assert(col2 && cmpIsStringVal(col2));

        /* Check for the obvious case of <cond ? "str1" : "str2" > */

        if  (col1->tnOper != TN_CNS_STR || (col1->tnFlags & TNF_BEEN_CAST))
        {
            if  (chkOnly)
            {
                if  (cmpConversionCost(col1, type) < 0)
                    return  false;
            }
            else
                col1 = cmpCoerceExpr(col1, type, true);
        }

        if  (col2->tnOper != TN_CNS_STR)
        {
            if  (chkOnly)
            {
                if  (cmpConversionCost(col2, type) < 0)
                    return  false;
            }
            else
                col2 = cmpCoerceExpr(col2, type, true);
        }

        /* Bash the types of each sub-operand */

        col1->tnVtyp = col2->tnVtyp = TYP_PTR;
        col1->tnType = col2->tnType = type;
    }

    /* Looks good, bash the type of the expression and return */

    if  (!chkOnly)
    {
        expr->tnVtyp = TYP_PTR;
        expr->tnType = type;
    }

    return  true;
}

/*****************************************************************************
 *
 *  Return the "cost" of converting the actual argument value 'srcExpr' to
 *  the formal argument type 'dstType' - the higher the number, the more
 *  work it is to convert, with -1 meaning the conversion is impossible.
 */

int                 compiler::cmpConversionCost(Tree    srcExpr,
                                                TypDef  dstType, bool noUserConv)
{
    TypDef          srcType = srcExpr->tnType;

    var_types       srcVtyp;
    var_types       dstVtyp;

    int             cost;

//  printf("srcType = %s\n", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
//  printf("dstType = %s\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));

AGAIN:

    srcVtyp = srcType->tdTypeKindGet();
    dstVtyp = dstType->tdTypeKindGet();

    /* Is either type a typedef? */

    if  (srcVtyp == TYP_TYPEDEF)
    {
        srcType = srcType->tdTypedef.tdtType;
        srcVtyp = srcType->tdTypeKindGet();
    }

    if  (dstVtyp == TYP_TYPEDEF)
    {
        dstType = dstType->tdTypedef.tdtType;
        dstVtyp = dstType->tdTypeKindGet();
    }

    /* Are the types identical? */

    if  (srcVtyp == dstVtyp)
    {
        if  (srcVtyp <= TYP_lastIntrins)
            return  0;

        if  (cmpGlobalST->stMatchTypes(srcType, dstType))
        {
            /* The following is rather absurd, but whatever */


            if  (srcExpr->tnOper != TN_NULL)
                return 0;
        }
    }

    /* Are both types arithmetic? */

    if  (varTypeIsArithmetic(dstVtyp) &&
         varTypeIsArithmetic(srcVtyp))
    {
        assert(srcVtyp != dstVtyp);

    ARITH:

        /* Compute the cost from the table */

        cost = arithConvCost(srcVtyp, dstVtyp);

        if  (cost >= 20 && cmpConfig.ccPedantic)
            cost = -1;

        return  cost;
    }
    else if (srcVtyp == TYP_ENUM && varTypeIsArithmetic(dstVtyp))
    {
        unsigned        cost;

        /* We're converting an enum to an arithmetic type */

        cost = arithConvCost(srcType->tdEnum.tdeIntType->tdTypeKindGet(), dstVtyp);


        return  cost + 1;
    }
    else if (srcVtyp == TYP_BOOL && !cmpConfig.ccPedantic)
    {
        /* Promoting 'bool' to an arithmetic type is not exactly a big deal */

        if  (varTypeIsArithmetic(dstVtyp))
            return  2;
    }

    /* Let's see what we're casting to */

    switch (dstVtyp)
    {
        unsigned        cost;

    case TYP_WCHAR:

        /* Special case: a character literal */

        if  (srcVtyp == TYP_CHAR && srcExpr->tnOper == TN_CNS_INT)
        {
            if  (!(srcExpr->tnFlags & TNF_BEEN_CAST))
            {
                return  0;
            }
        }

        // Fall through ....

    case TYP_BOOL:
    case TYP_CHAR:
    case TYP_UCHAR:
    case TYP_SHORT:
    case TYP_USHORT:
    case TYP_INT:
    case TYP_NATINT:
    case TYP_NATUINT:
    case TYP_UINT:
    case TYP_LONG:
    case TYP_ULONG:
    case TYP_FLOAT:
    case TYP_DOUBLE:
    case TYP_LONGDBL:

        if  (srcVtyp == TYP_WCHAR || srcVtyp == TYP_BOOL)
        {
            if  (!cmpConfig.ccPedantic)
                goto ARITH;
        }

        return -1;

    case TYP_REF:
    case TYP_PTR:

        /* Classes can be converted to classes under some circumstances */

        if  (srcVtyp == dstVtyp)
        {
            TypDef          srcBase = cmpGetRefBase(srcType);
            TypDef          dstBase = cmpGetRefBase(dstType);

            if  (!srcBase)
            {
                /* Special case: 'src' could be an undefined type */

                if  (dstType == cmpRefTpObject)
                    return 2;

                return -1;
            }

            if  (!dstBase)
                return -1;

            /* Special case: 'null' converts easily to any ref/ptr type */

            if  (srcExpr->tnOper == TN_NULL && !(srcExpr->tnFlags & TNF_BEEN_CAST))
            {
                unsigned        cost = cmpIsBaseClass(srcBase, dstBase);

#if 0
printf("srcBase = %s\n", cmpGlobalST->stTypeName(srcBase, NULL, NULL, NULL, false));
printf("dstBase = %s\n", cmpGlobalST->stTypeName(dstBase, NULL, NULL, NULL, false));
printf("cost is   %u\n", cost);
#endif

                if  (cost > 10)
                    return  1;
                else
                    return  10 - cost;
            }

            /* Is the target a base class of the source? */

            if  (srcBase->tdTypeKind == TYP_CLASS &&
                 dstBase->tdTypeKind == TYP_CLASS)
            {
                if  (srcBase == dstBase)
                    return  0;

                cost = cmpIsBaseClass(dstBase, srcBase);
                if  (cost)
                    return  cost;
            }

            /* It's not too bad to convert to "void *" */

            if  (dstBase->tdTypeKind == TYP_VOID)
                return  2;

            return  -1;
        }

        /* An array or method pointer may be converted to 'Object' */

        if  (dstType == cmpRefTpObject)
        {
            if  (srcVtyp == TYP_ARRAY)
            {
                if  (dstType == cmpArrayRef())
                    return 1;
                else
                    return  2;
            }

            if  (srcVtyp == TYP_FNC)
            {
                assert(srcExpr->tnOper == TN_FNC_PTR);

                return  2;
            }


        }

        if  (dstVtyp == TYP_PTR)
        {
            if  (srcVtyp == TYP_REF)
            {
                /* String literal passed to "char *" or "void *" is also OK */

                if  (cmpMakeRawString(srcExpr, dstType, true))
                    return  1;

                /* 'null' converts to any ptr type */

                if  (srcExpr->tnOper == TN_NULL && !(srcExpr->tnFlags & TNF_BEEN_CAST))
                    return 1;
            }

            /* Some people insist on using 0 instead of null/NULL */

            if  (srcVtyp         ==    TYP_INT &&
                 srcExpr->tnOper == TN_CNS_INT &&   srcExpr->tnIntCon.tnIconVal == 0
                                               && !(srcExpr->tnFlags & TNF_BEEN_CAST))
            {
                /* In non-pedantic mode we let this through with a warning */

                if  (!cmpConfig.ccPedantic)
                    return  2;
            }
        }

        /* An array may be converted to 'Array' */

        if  (dstType == cmpArrayRef() && srcVtyp == TYP_ARRAY)
            return  1;

        return -1;

    case TYP_ARRAY:

        /* Are we converting an array to another one? */

        if  (srcVtyp == TYP_ARRAY)
        {
            TypDef          srcBase;
            TypDef          dstBase;

            /* Check the element types of the arrays */

            srcBase = cmpDirectType(srcType->tdArr.tdaElem);
            dstBase = cmpDirectType(dstType->tdArr.tdaElem);

            /* If the element types are identical, we're OK */

            if  (cmpGlobalST->stMatchTypes(srcBase, dstBase))
                return 0;

            /* Are these both arrays of classes? */

            if  (srcBase->tdTypeKind == TYP_REF &&
                 dstBase->tdTypeKind == TYP_REF)
            {
                /* Pretend we had classes to begin with */

                srcType = srcBase;
                dstType = dstBase;

                goto AGAIN;
            }

            /* Check if one is a subtype of the other */

            if  (symTab::stMatchArrays(srcType, dstType, true))
                return  1;
        }

        /* 'null' converts to an array */

        if  (srcVtyp == TYP_REF && srcType == cmpRefTpObject)
        {
            if  (srcExpr->tnOper == TN_NULL)
                return 1;
        }

        return -1;

    case TYP_UNDEF:
        return -1;

    case TYP_CLASS:

        if  (noUserConv)
            return  -1;

        if  (cmpCheckConvOper(srcExpr, srcType, dstType, false, &cost))
            return  cost;

        return  -1;

    case TYP_ENUM:

        /* We already know the source isn't the same type */

        assert(cmpGlobalST->stMatchTypes(srcType, dstType) == false);

        /* An explicit conversion is OK if the source type is an arithmetic type */

        if  (varTypeIsIntegral(srcVtyp))
        {
            if  (srcVtyp == TYP_ENUM)
                srcVtyp = srcType->tdEnum.tdeIntType->tdTypeKindGet();

            return  20 + arithConvCost(srcVtyp, dstType->tdEnum.tdeIntType->tdTypeKindGet());
        }

        return  -1;

    case TYP_REFANY:
        if  (srcExpr->tnOper == TN_ADDROF && !(srcExpr->tnFlags & TNF_ADR_IMPLICIT))
            return  0;

        return  -1;

    default:
        assert(!"unhandled target type in compiler::cmpConversionCost()");
    }

    /* See what we're casting from */

    switch (srcVtyp)
    {
    case TYP_BOOL:

        /* 'boolean' can never be converted to anything */

        break;

    default:
        assert(!"unhandled source type in compiler::cmpConversionCost()");
    }

    return -1;
}

/*****************************************************************************
 *
 *  If the argsession is a constant, shrink it to the smallest possible type
 *  that can hold the constant value.
 */

Tree                compiler::cmpShrinkExpr(Tree expr)
{
    if  (expr->tnOper == TN_CNS_INT ||
         expr->tnOper == TN_CNS_FLT ||
         expr->tnOper == TN_CNS_DBL)
    {
        var_types       vtp = expr->tnVtypGet();

        /* Don't touch the thing if it's not an intrinsic type */

        if  (vtp > TYP_lastIntrins)
        {
#if 0
            TypDef          etp;

            /* Except for enums, of course */

            if  (vtp != TYP_ENUM)
                return  expr;

            expr->tnType = etp = expr->tnType->tdEnum.tdeIntType;
            expr->tnVtyp = vtp = etp->tdTypeKindGet();
#else
            return  expr;
#endif
        }

        /* Figure out the smallest size for the constant */

        expr->tnVtyp = cmpConstSize(expr, vtp);
        expr->tnType = cmpGlobalST->stIntrinsicType(expr->tnVtypGet());
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Find an appropriate string comparison method.
 */

SymDef              compiler::cmpFindStrCompMF(const char *name, bool retBool)
{
    ArgDscRec       args;
    TypDef          type;
    SymDef          fsym;

    cmpParser->parseArgListNew(args,
                               2,
                               false, cmpRefTpString,
                                      cmpRefTpString,
                                      NULL);

    type  = cmpGlobalST->stNewFncType(args, retBool ? cmpTypeBool
                                                    : cmpTypeInt);

    /* Find the appropriate method in class System::String */

    fsym = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString(name),
                                       cmpClassString);
    assert(fsym);

    fsym = cmpCurST->stFindOvlFnc(fsym, type);

    assert(fsym && fsym->sdIsStatic);

    return  fsym;
}

/*****************************************************************************
 *
 *  Call the specified string comparison method.
 */

Tree                compiler::cmpCallStrCompMF(Tree expr,
                                               Tree  op1,
                                               Tree  op2, SymDef fsym)
{
    assert(expr && op1 && op2);
    assert(fsym && fsym->sdIsMember && fsym->sdSymKind == SYM_FNC && fsym->sdIsStatic);

    op2 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, op2, NULL);
    op1 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, op1,  op2);

    expr->tnOper             = TN_FNC_SYM;
    expr->tnType             = fsym->sdType->tdFnc.tdfRett;
    expr->tnVtyp             = expr->tnType->tdTypeKindGet();
    expr->tnFncSym.tnFncSym  = fsym;
    expr->tnFncSym.tnFncArgs = op1;
    expr->tnFncSym.tnFncObj  = NULL;
    expr->tnFncSym.tnFncScp  = NULL;

    return  expr;
}

/*****************************************************************************
 *
 *  Given a member function and an argument list, find a matching overload.
 */

SymDef              compiler::cmpFindOvlMatch(SymDef fncSym, Tree args,
                                                             Tree thisArg)
{
    int             argCnt   = -1;

    TypDef          bestTyp;
    SymDef          bestSym  = NULL;
    SymDef          moreSym  = NULL;

    unsigned        btotCost = 99999;
    int             bestCost = 99999;

    bool            inBase   = false;

    SymDef          xtraSym  = NULL;

    /* Do we have two sets of functions to consider? */

    if  (!fncSym)
    {
        assert(args && args->tnOper == TN_LIST);

        assert(thisArg->tnOper == TN_LIST);
        assert(thisArg->tnOp.tnOp1->tnOper == TN_FNC_SYM);
        assert(thisArg->tnOp.tnOp2->tnOper == TN_FNC_SYM);

         fncSym = thisArg->tnOp.tnOp1->tnFncSym.tnFncSym;
        xtraSym = thisArg->tnOp.tnOp2->tnFncSym.tnFncSym;

        thisArg = NULL;
    }

    assert(fncSym && fncSym->sdSymKind == SYM_FNC);

#ifdef  SHOW_OVRS_OF_THIS_FNC

    SymDef          ovlFunc  = fncSym;

    if  (fncSym && !strcmp(fncSym->sdSpelling(), SHOW_OVRS_OF_THIS_FNC) || !strcmp(SHOW_OVRS_OF_THIS_FNC, "*"))
    {
        printf("\nOverloaded call [%08X]: begin\n", args);
        cmpParser->parseDispTree(args);
        printf("\n\n");
    }

#endif

AGAIN:

    for (;;)
    {
        SymDef          fncSave = fncSym;
        TypDef          baseCls;

        /* Walk the overload list, looking for the best match */

        do
        {
            TypDef          fncTyp;
            bool            extArgs;

            Tree            actuals;
            ArgDef          formals;

            int             argCost;
            int             maxCost;
            unsigned        totCost;

            unsigned        actCnt;

            /* Get hold of the type for the next overload */

            fncTyp = fncSym->sdType;

            /* Check the argument count, if it's been determined */

            if  (argCnt != fncTyp->tdFnc.tdfArgs.adCount &&
                 argCnt != -1)
            {
                /* Do we have too few or too many arguments? */

                if  (argCnt < fncTyp->tdFnc.tdfArgs.adCount)
                {
                    /* We don't have enough arguments, there better be defaults */

                    if  (!fncTyp->tdFnc.tdfArgs.adDefs)
                        goto NEXT;
                }
                else
                {
                    /* If it's a varargs function, too many args might be OK */

                    if  (!fncTyp->tdFnc.tdfArgs.adVarArgs)
                        goto NEXT;
                }
            }

#ifdef  SHOW_OVRS_OF_THIS_FNC
            if  (!strcmp(fncSym->sdSpelling(), SHOW_OVRS_OF_THIS_FNC) || !strcmp(SHOW_OVRS_OF_THIS_FNC, "*"))
                printf("\nConsider '%s':\n", cmpGlobalST->stTypeName(fncTyp, fncSym, NULL, NULL, false));
#endif

            /* Does the function have extended argument descriptors? */

            extArgs = fncTyp->tdFnc.tdfArgs.adExtRec;

            /* Walk the formal and actual arguments, computing the max. cost */

            maxCost = 0;
            totCost = 0;
            actCnt  = 0;

            actuals = args;
            formals = fncTyp->tdFnc.tdfArgs.adArgs;

            /* Is there a "this" pointer? */

            if  (fncSym->sdIsMember && thisArg && !fncSym->sdIsStatic)
            {
                TypDef          clsType = fncSym->sdParent->sdType;

                assert(clsType->tdTypeKind == TYP_CLASS);

                argCost = cmpConversionCost(thisArg, clsType->tdClass.tdcRefTyp);
                if  (argCost < 0)
                    goto NEXT;

#ifdef  SHOW_OVRS_OF_THIS_FNC
                if  (!strcmp(ovlFunc->sdSpelling(), SHOW_OVRS_OF_THIS_FNC) || !strcmp(SHOW_OVRS_OF_THIS_FNC, "*"))
                {
                    printf("'this' arg: cost = %d\n", argCost);
                    printf("    Formal: %s\n", cmpGlobalST->stTypeName(clsType->tdClass.tdcRefTyp, NULL, NULL, NULL, false));
                    printf("    Actual: %s\n", cmpGlobalST->stTypeName(thisArg->tnType           , NULL, NULL, NULL, false));
                }
#endif

                /* The "this" argument cost is our initial total/max cost */

                maxCost = argCost;
                totCost = argCost;
            }

            if  (actuals)
            {
                do
                {
                    Tree            actualx;

                    /* If there are no more formals, we have too many args */

                    if  (!formals)
                    {
                        /* If it's a varargs function, we have a match */

                        if  (fncTyp->tdFnc.tdfArgs.adVarArgs)
                            goto MATCH;
                        else
                            goto NEXT;
                    }

                    assert(actuals->tnOper == TN_LIST);

                    /* Count this argument */

                    actCnt++;

                    /* Get hold of the next actual value */

                    actualx = actuals->tnOp.tnOp1;

                    /* Is this supposed to be a byref argument? */

                    if  (extArgs)
                    {
                        /* The actual value has to be a matching lvalue */

                        assert(formals->adIsExt);

                        if  (((ArgExt)formals)->adFlags & (ARGF_MODE_OUT  |
                                                           ARGF_MODE_INOUT|
                                                           ARGF_MODE_REF))
                        {
                            /* The actual value has to be a matching lvalue */

                            if  (actualx->tnOper == TN_ADDROF)
                                actualx = actualx->tnOp.tnOp1;

                            if  (cmpCheckLvalue(actualx, true, true) &&
                                 symTab::stMatchTypes(formals->adType, actualx->tnType))
                            {
                                argCost =  0;
                            }
                            else
                                argCost = -1;

                            goto GOT_ARGC;
                        }
                    }

                    /* Compute the conversion cost for this argument */

                    argCost = cmpConversionCost(actualx, formals->adType);

                GOT_ARGC:

#ifdef  SHOW_OVRS_OF_THIS_FNC
                    if  (!strcmp(ovlFunc->sdSpelling(), SHOW_OVRS_OF_THIS_FNC) || !strcmp(SHOW_OVRS_OF_THIS_FNC, "*"))
                    {
                        printf("Argument #%2u: cost = %d\n", actCnt, argCost);
                        printf("    Formal: %s\n", cmpGlobalST->stTypeName(formals->adType, NULL, NULL, NULL, false));
                        printf("    Actual: %s\n", cmpGlobalST->stTypeName(actualx->tnType, NULL, NULL, NULL, false));
                    }
#endif

                    /* If this value can't be converted at all, give up */

                    if  (argCost < 0)
                        goto NEXT;

                    /* Keep track of the total and highest cost */

                    totCost += argCost;

                    if  (maxCost < argCost)
                         maxCost = argCost;

                    /* Move on to the next formal */

                    formals = formals->adNext;

                    /* Are there any more actuals? */

                    actuals = actuals->tnOp.tnOp2;
                }
                while (actuals);
            }

            /* Remember how many actual args we've found for next round */

            argCnt = actCnt;

            /* This is a match if there are no more formals */

            if  (formals)
            {
                /* Is there a default value? */

                if  (!fncTyp->tdFnc.tdfArgs.adDefs || !extArgs)
                    goto NEXT;

                /*
                    Note that we depend on the absence of gaps in trailing
                    argument defaults, i.e. once a default is specified all
                    the arguments that follow must also have defaults.
                 */

                assert(formals->adIsExt);

                if  (!(((ArgExt)formals)->adFlags & ARGF_DEFVAL))
                    goto NEXT;
            }

        MATCH:

#ifdef  SHOW_OVRS_OF_THIS_FNC
            if  (!strcmp(ovlFunc->sdSpelling(), SHOW_OVRS_OF_THIS_FNC) || !strcmp(SHOW_OVRS_OF_THIS_FNC, "*"))
                printf("\nMax. cost = %2u, total cost = %u\n", maxCost, totCost);
#endif

            /* Compare the max. cost to the best so far */

            if  (maxCost > bestCost)
                goto NEXT;


            /* Is this a clearly better match? */

            if  (maxCost < bestCost || totCost < btotCost)
            {
                bestCost = maxCost;
                btotCost = totCost;
                bestSym  = fncSym;
                bestTyp  = fncTyp;
                moreSym  = NULL;

                goto NEXT;
            }

            if  (totCost == btotCost)
            {
                /*
                    This function is exactly as good as the best match we've
                    found so far. In fact, it will be hidden by our best match
                    if we're in a base class. If the argument lists match, we
                    ignore this function and move on.
                 */

                if  (!inBase || !cmpGlobalST->stArgsMatch(bestTyp, fncTyp))
                    moreSym = fncSym;
            }

        NEXT:

            /* Continue with the next overload, if any */

            fncSym = fncSym->sdFnc.sdfNextOvl;
        }
        while (fncSym);

        /* Do we have base class overloads? */

        if  (!fncSave->sdFnc.sdfBaseOvl)
            break;

        /* Look for a method with the same name in the base class */

        assert(fncSave->sdParent->sdSymKind == SYM_CLASS);

        baseCls = fncSave->sdParent->sdType->tdClass.tdcBase;
        if  (!baseCls)
            break;

        assert(baseCls->tdTypeKind == TYP_CLASS);

        fncSym = cmpGlobalST->stLookupAllCls(fncSave->sdName,
                                             baseCls->tdClass.tdcSymbol,
                                             NS_NORM,
                                             CS_DECLSOON);

        if  (!fncSym || fncSym->sdSymKind != SYM_FNC)
            break;

        /* We'll have to weed out hidden methods in the base */

        inBase = true;
    }

    /* Do we have another set of functions to consider? */

    if  (xtraSym)
    {
        fncSym = xtraSym;
                 xtraSym = NULL;

        goto AGAIN;
    }

#ifdef  SHOW_OVRS_OF_THIS_FNC
    if  (!strcmp(ovlFunc->sdSpelling(), SHOW_OVRS_OF_THIS_FNC) || !strcmp(SHOW_OVRS_OF_THIS_FNC, "*"))
        printf("\nOverloaded call [%08X]: done.\n\n", args);
#endif

    /* Is the call ambiguous? */

    if  (moreSym)
    {
        /* Report an ambiguity error */

        cmpErrorQSS(ERRambigCall, bestSym, moreSym);
    }

    return  bestSym;
}

/*****************************************************************************
 *
 *  Given a function call node with a bound function member and argument list,
 *  check the arguments and return an expression that represents the result of
 *  calling the function.
 */

Tree                compiler::cmpCheckFuncCall(Tree call)
{
    SymDef          fncSym;
    TypDef          fncTyp;
    SymDef          ovlSym = NULL;
    Tree            fncLst = NULL;

    ArgDef          formal;
    Tree            actual;
    Tree            actLst;
    Tree            actNul = NULL;
    Tree            defExp;
    unsigned        argCnt;
    unsigned        argNum;
    bool            extArg;

    switch (call->tnOper)
    {
    case TN_FNC_SYM:

        /* Get the arguments from the call node */

        actual = call->tnFncSym.tnFncArgs;

    CHK_OVL:

        fncSym = call->tnFncSym.tnFncSym;
        assert(fncSym->sdSymKind == SYM_FNC);

        /* Is the method overloaded? */

        if  (fncSym->sdFnc.sdfNextOvl || fncSym->sdFnc.sdfBaseOvl)
        {
            /* Try to find a matching overload */

            ovlSym = cmpFindOvlMatch(fncSym, call->tnFncSym.tnFncArgs,
                                             call->tnFncSym.tnFncObj);

            /* Bail if no matching function was found */

            if  (!ovlSym)
            {

            ERR:

                if  (!cmpExprIsErr(call->tnFncSym.tnFncArgs))
                {
                    if  (fncSym->sdFnc.sdfCtor)
                    {
                        SymDef          parent = fncSym->sdParent;

                        if  (parent && parent->sdSymKind         == SYM_CLASS
                                    && parent->sdClass.sdcFlavor == STF_DELEGATE)
                        {
                            Tree            args = call->tnFncSym.tnFncArgs;

                            assert(call->tnOper == TN_FNC_SYM);
                            assert(args->tnOper == TN_LIST);
                            args = args->tnOp.tnOp2;
                            assert(args->tnOper == TN_LIST);
                            args = args->tnOp.tnOp1;
                            assert(args->tnOper == TN_ADDROF);
                            args = args->tnOp.tnOp1;
                            assert(args->tnOper == TN_FNC_PTR);

                            cmpErrorQSS(ERRnoDlgMatch, args->tnFncSym.tnFncSym, parent);
                        }
                        else
                        {
                            cmpErrorXtp(ERRnoCtorMatch, parent, call->tnFncSym.tnFncArgs);
                        }
                    }
                    else
                    {
                        SymDef          clsSym;

                        cmpErrorXtp(ERRnoOvlMatch, fncSym, call->tnFncSym.tnFncArgs);

                        clsSym = fncSym->sdParent; assert(clsSym);

                        if  (clsSym->sdSymKind == SYM_CLASS)
                        {
                            SymDef          baseMFN;

                            if  (clsSym->sdType->tdClass.tdcBase == NULL)
                                break;

                            clsSym  = clsSym->sdType->tdClass.tdcBase->tdClass.tdcSymbol;
                            baseMFN = cmpGlobalST->stLookupClsSym(fncSym->sdName, clsSym);

                            if  (baseMFN)
                            {
                                ovlSym = cmpFindOvlMatch(baseMFN, call->tnFncSym.tnFncArgs,
                                                                  call->tnFncSym.tnFncObj);
                                if  (ovlSym)
                                {
                                    cmpErrorQnm(ERRhideMatch, ovlSym);
                                    goto RET_ERR;
                                }
                            }
                        }
                    }
                }

            RET_ERR:

                return cmpCreateErrNode();
            }

        MFN:

            call->tnFncSym.tnFncSym = fncSym = ovlSym;
        }

        fncTyp = fncSym->sdType; assert(fncTyp->tdTypeKind == TYP_FNC);

        /* Make sure we are allowed to access the function */

        cmpCheckAccess(fncSym);

        /* Has the function been marked as "deprecated" ? */

        if  (fncSym->sdIsDeprecated || (fncSym->sdParent && fncSym->sdParent->sdIsDeprecated))
        {
            if  (fncSym->sdIsImport)
            {
                if  (fncSym->sdIsDeprecated)
                    cmpObsoleteUse(fncSym          , WRNdepCall);
                else
                    cmpObsoleteUse(fncSym->sdParent, WRNdepCls);
            }
        }

        break;

    case TN_CALL:

        assert(call->tnOp.tnOp1->tnOper == TN_IND);

#ifdef  DEBUG
        fncSym = NULL;
#endif
        fncTyp = call->tnOp.tnOp1->tnType;

        /* Get the arguments from the call node */

        actual = call->tnOp.tnOp2;
        break;

    case TN_LIST:

        /* The function list is in op1, the arguments are in op2 */

        actual = call->tnOp.tnOp2;
        fncLst = call->tnOp.tnOp1;

        if  (fncLst->tnOper == TN_LIST)
        {
            /* We have more than one set of candidate functions */

            assert(fncLst->tnOp.tnOp1->tnOper == TN_FNC_SYM);
            assert(fncLst->tnOp.tnOp2->tnOper == TN_FNC_SYM);

            /* Look for a matching overload */

            ovlSym = cmpFindOvlMatch(NULL, actual, fncLst);

            if  (!ovlSym)
                goto ERR;

            call->tnOper             = TN_FNC_SYM;
            call->tnFncSym.tnFncArgs = actual;

            goto MFN;
        }
        else
        {
            /* There is one candidate set of functions */

            call = fncLst; assert(call->tnOper == TN_FNC_SYM);

            goto CHK_OVL;
        }
        break;

    default:
        NO_WAY(!"weird call");
    }

    assert(fncTyp->tdTypeKind == TYP_FNC);

    /* Walk the argument list, checking each type as we go */

    formal = fncTyp->tdFnc.tdfArgs.adArgs;
    extArg = fncTyp->tdFnc.tdfArgs.adExtRec;
    defExp =
    actLst = NULL;
    argCnt = 0;

    for (argNum = 0; ; argNum++)
    {
        Tree            actExp;
        TypDef          formTyp;

        /* Are there any actual arguments left? */

        if  (actual == NULL)
        {
            /* No more actuals -- there better be no more formals */

            if  (formal)
            {
                /* Is there a default value? */

                if  (extArg)
                {
                    ArgExt          formExt = (ArgExt)formal;

                    assert(formal->adIsExt);

                    /* Grab a default value if it's present */

                    if  (formExt->adFlags & ARGF_DEFVAL)
                    {
#if MGDDATA
                        actExp = cmpFetchConstVal( formExt->adDefVal);
#else
                        actExp = cmpFetchConstVal(&formExt->adDefVal);
#endif
                        defExp = cmpCreateExprNode(NULL,
                                                   TN_LIST,
                                                   cmpTypeVoid,
                                                   actExp,
                                                   NULL);

                        /* Add the argument to the actual argument list */

                        if  (actLst)
                        {
                            assert(actLst->tnOper     == TN_LIST);
                            assert(actLst->tnOp.tnOp2 == NULL);

                            actLst->tnOp.tnOp2       = defExp;
                        }
                        else
                        {
                            call->tnFncSym.tnFncArgs = defExp;
                        }

                        actLst = defExp;

                        goto CHKARG;
                    }
                }

                if  (fncSym->sdFnc.sdfCtor)
                    goto ERR;

                cmpErrorQnm(ERRmisgArg, fncSym);
                return cmpCreateErrNode();
            }

            /* No more actuals or formals -- looks like we're done! */

            break;
        }

        /* Count this argument, in case we have to give an error */

        argCnt++;

        /* Get hold of the next argument value */

        assert(actual->tnOper == TN_LIST);
        actExp = actual->tnOp.tnOp1;

    CHKARG:

        /* Are there any formal parameters left? */

        if  (formal == NULL)
        {
            var_types       actVtp;

            /* Is this a varargs function? */

            if  (!fncTyp->tdFnc.tdfArgs.adVarArgs)
            {
                /* Check for "va_start" and "va_arg" */

                if  (fncSym == cmpFNsymVAbeg ||
                     fncSym == cmpFNsymVAget)
                {
                    return  cmpBindVarArgUse(call);
                }

                /* Too many actual arguments */

                if  (fncSym->sdFnc.sdfCtor)
                    goto ERR;

                cmpErrorQnm(ERRmanyArg, fncSym);
                return cmpCreateErrNode();
            }

            /* Mark the call as "varargs" */

            call->tnFlags |= TNF_CALL_VARARG;

            /* Promote the argument if small int or FP value */

            actVtp = actExp->tnVtypGet();

            if  (varTypeIsArithmetic(actVtp))
            {
                if      (actVtp == TYP_FLOAT)
                {
                    /* Promote float varargs values to double */

                    actVtp = TYP_DOUBLE;
                }
                else if (actVtp >= TYP_CHAR && actVtp < TYP_INT)
                {
                    actVtp = TYP_INT;
                }
                else
                    goto NEXT_ARG;

                formTyp = cmpGlobalST->stIntrinsicType(actVtp);

                goto CAST_ARG;
            }

            goto NEXT_ARG;
        }

        /* Get the type of the formal parameter */

        formTyp = cmpDirectType(formal->adType);

        /* Get the argument flags, if present */

        if  (extArg)
        {
            unsigned        argFlags;

            assert(formal->adIsExt);

            argFlags = ((ArgExt)formal)->adFlags;

            if  (argFlags & (ARGF_MODE_OUT|ARGF_MODE_INOUT|ARGF_MODE_REF))
            {
                Tree            argx;

                /* We must have an lvalue of the exact right type */

                if  (actExp->tnOper == TN_ADDROF)
                {
                    actExp = actExp->tnOp.tnOp1;
                }
                else
                {
                    if  (argFlags & (ARGF_MODE_INOUT|ARGF_MODE_OUT))
                        cmpWarnNqn(WRNimplOut, argNum+1, fncSym);
                }

                if  (!cmpCheckLvalue(actExp, true))
                    return cmpCreateErrNode();

                if  (!symTab::stMatchTypes(formTyp, actExp->tnType))
                    goto ARG_ERR;

                // UNDONE: Make sure the lvalue is GC/non-GC as appropriate

                argx = cmpCreateExprNode(NULL,
                                         TN_ADDROF,
                                         cmpGlobalST->stNewRefType(TYP_PTR, formTyp),
                                         actExp,
                                         NULL);

                argx->tnFlags |= TNF_ADR_OUTARG;

                /* Store the updated value in the arglist and continue */

                actual->tnOp.tnOp1 = argx;
                goto NEXT_ARG;
            }
        }

        /* If we haven't performed overload resolution ... */

        if  (!ovlSym)
        {
            /* Make sure the argument can be converted */

            if  (cmpConversionCost(actExp, formTyp) < 0)
            {
                char            temp[16];
                int             errn;
                stringBuff      nstr;

            ARG_ERR:

                /* Issue an error and give up on this argument */

                if  (formal->adName)
                {
                    nstr = formal->adName->idSpelling();
                    errn = ERRbadArgValNam;
                }
                else
                {
                    sprintf(temp, "%u", argCnt);
                    nstr = makeStrBuff(temp);
                    errn = ERRbadArgValNum;
                }

                cmpErrorSST(errn, nstr, fncSym, actExp->tnType);
                goto NEXT_ARG;
            }
        }

        /* Coerce the argument to the formal argument's type */

        if  (actExp->tnType != formTyp)
        {
            Tree            conv;

        CAST_ARG:

            conv = cmpCoerceExpr(actExp, formTyp, false);

            if  (actual)
                actual->tnOp.tnOp1 = conv;
            else
                defExp->tnOp.tnOp1 = conv;
        }

    NEXT_ARG:

        /* Move to the next formal and actual argument */

        if  (formal)
            formal = formal->adNext;

        if  (actual)
        {
            actLst = actual;
            actual = actual->tnOp.tnOp2;
        }
    }

    /* Get hold of the return type and set the type of the call */

    call->tnType = cmpDirectType(fncTyp->tdFnc.tdfRett);
    call->tnVtyp = call->tnType->tdTypeKind;

    return call;
}

/*****************************************************************************
 *
 *  Bind a call to a function.
 */

Tree                compiler::cmpBindCall(Tree expr)
{
    Tree            func;

    Tree            fncx;
    Tree            args;

    SymDef          fsym;
    TypDef          ftyp;

    bool            indir;

    SymDef          errSym = NULL;
    bool            CTcall = false;

    assert(expr->tnOper == TN_CALL);

    /* The expression being called must be an optionally dotted name */

    func = expr->tnOp.tnOp1;

    switch (func->tnOper)
    {
    case TN_NAME:
    case TN_ANY_SYM:
        fncx = cmpBindNameUse(func, true, false);
        break;

    case TN_DOT:
    case TN_ARROW:
        fncx = cmpBindDotArr(func, true, false);
        if  (fncx->tnOper == TN_ARR_LEN)
            return  fncx;
        break;

    case TN_THIS:
    case TN_BASE:

        /* Make sure we are in a constructor */

        if  (!cmpCurFncSym || !cmpCurFncSym->sdFnc.sdfCtor)
        {
            cmpError(ERRbadCall);
            return cmpCreateErrNode();
        }

        /* Figure out which class to look for the constructor in */

        ftyp = cmpCurCls->sdType;

        if  (func->tnOper == TN_BASE)
        {
            if  (ftyp->tdClass.tdcValueType && ftyp->tdIsManaged)
            {
                /* Managed structs don't really have a base class */

                ftyp = NULL;
            }
            else
                ftyp = ftyp->tdClass.tdcBase;

            /* Make sure this is actually OK */

            if  (!cmpBaseCTisOK || ftyp == NULL)
                cmpError(ERRbadBaseCall);

            /* This can only be done once, of course */

            cmpBaseCTisOK = false;

            /* We should have noticed that "baseclass()" is called */

            assert(cmpBaseCTcall == false);
        }

        /* Get the constructor symbol from the class */

        fsym = cmpFindCtor(ftyp, false);
        if  (!fsym)
        {
            /* Must have had some nasty errors earlier */

            assert(cmpErrorCount);
            return cmpCreateErrNode();
        }

        /* Create the member function call node */

        fncx = cmpCreateExprNode(NULL, TN_FNC_SYM, fsym->sdType);

        fncx->tnFncSym.tnFncObj = cmpThisRef();
        fncx->tnFncSym.tnFncSym = fsym;
        fncx->tnFncSym.tnFncScp  = NULL;

        break;

    case TN_ERROR:
        return  func;

    default:
        return cmpCreateErrNode(ERRbadCall);
    }

    /* If we got an error binding the function, bail */

    if  (fncx->tnVtyp == TYP_UNDEF)
        return fncx;

    /* At this point we expect to have a function */

    if  (fncx->tnVtyp != TYP_FNC)
        return cmpCreateErrNode(ERRbadCall);

    ftyp = fncx->tnType;
    assert(ftyp->tdTypeKind == TYP_FNC);

    /* Bind the argument list */

    args = NULL;

    if  (expr->tnOp.tnOp2)
    {
        args = expr->tnOp.tnOp2; assert(args->tnOper == TN_LIST);

        /* Special case: the second operand of va_arg() must be a type */

        if  (fncx->tnOper == TN_FNC_SYM && fncx->tnFncSym.tnFncSym == cmpFNsymVAget)
        {
            /* Bind both arguments (allow the second one to be a type) */

            args->tnOp.tnOp1 = cmpBindExprRec(args->tnOp.tnOp1);

            if  (args->tnOp.tnOp2)
            {
                Tree            arg2 = args->tnOp.tnOp2->tnOp.tnOp1;

                /* All error checking is done elsewhere, just check for type */

                if  (arg2->tnOper == TN_TYPE)
                {
                    arg2->tnType = cmpActualType(arg2->tnType);
                    arg2->tnVtyp = arg2->tnType->tdTypeKindGet();
                }
                else
                {
                    args->tnOp.tnOp2->tnOp.tnOp1 = cmpBindExprRec(arg2);
                }
            }
        }
        else
        {
            args = cmpBindExprRec(args);

            if  (args->tnVtyp == TYP_UNDEF)
                return args;
        }
    }

    /* Is this a direct or indirect function call ? */

    if  (fncx->tnOper == TN_FNC_SYM)
    {
        /* Direct call to a function symbol */

        fsym  = fncx->tnFncSym.tnFncSym; assert(fsym->sdSymKind == SYM_FNC);
        indir = false;

        /* Store the arguments in the call node */

        fncx->tnFncSym.tnFncArgs = args;
    }
    else
    {
        /* Must be an indirect call through a function pointer */

        assert(fncx->tnOper == TN_IND);

        fsym  = NULL;
        indir = true;
        fncx  = cmpCreateExprNode(NULL, TN_CALL, cmpTypeInt, fncx, args);
    }

#if 0
    printf("Func:\n");
    cmpParser->parseDispTree(fncx);
    printf("Args:\n");
    cmpParser->parseDispTree(args);
    printf("\n");
#endif

    /* In case something goes wrong ... */

    cmpRecErrorPos(expr);

    /* Check the call (performing overload resolution of necessary) */

    fncx = cmpCheckFuncCall(fncx);
    if  (fncx->tnVtyp == TYP_UNDEF)
        return  fncx;

    /* Typedefs should be folded by now */

    assert(fncx->tnVtyp != TYP_TYPEDEF);

    /* Was this a direct or indirect call? */

    if  (indir)
        return  fncx;

    if  (fncx->tnOper != TN_FNC_SYM)
    {
        assert(fncx->tnOper == TN_VARARG_BEG ||
               fncx->tnOper == TN_VARARG_GET);

        return  fncx;
    }

    /* Get the function symbol the call resolved to */

    fsym = fncx->tnFncSym.tnFncSym;

    /*
        If the function is private or it's a method of a final
        class, the call to it won't need to be virtual.
     */

    if  (fsym->sdIsMember)
    {
        if  (fsym->sdAccessLevel == ACL_PRIVATE)
            fncx->tnFlags |= TNF_CALL_NVIRT;
        if  (fsym->sdParent->sdIsSealed)
            fncx->tnFlags |= TNF_CALL_NVIRT;
    }

    /* Did we have an object or just a class name reference? */

    if  (fncx->tnFncSym.tnFncObj)
    {
        Tree            objExpr = fncx->tnFncSym.tnFncObj;

        /* Special case: "base.func()" is *not* virtual */

        if  ((objExpr->tnOper == TN_LCL_SYM   ) &&
             (objExpr->tnFlags & TNF_LCL_BASE))
        {
            fncx->tnFlags |= TNF_CALL_NVIRT;
        }
    }
    else
    {
        SymDef          memSym = fncx->tnFncSym.tnFncSym;

        /* Are we calling a member function ? */

        if  (memSym->sdIsMember)
        {
            /* The called member must belong to our class or be static */

            if  (!memSym->sdIsStatic)
            {
                SymDef          memCls;

                /* Figure out the scope the member came from */

                memCls = fncx->tnFncSym.tnFncScp;
                if  (!memCls)
                    memCls = memSym->sdParent;

                /* Does the member belong to a base? */

                if  (cmpCurCls  &&
                     cmpThisSym && cmpIsBaseClass(memCls->sdType, cmpCurCls->sdType))
                {
                    /* Stick an implicit "this->" in front of the reference */

                    fncx->tnFncSym.tnFncObj = cmpThisRefOK();
                }
                else
                {
                    SymDef          parent;

                    // The following is a truly outrageous. I'm proud of it, though.

                    parent = memSym->sdParent;
                             memSym->sdParent = memCls;
                    cmpErrorQnm(ERRmemWOthis, memSym);
                             memSym->sdParent = parent;

                    return cmpCreateErrNode();
                }
            }
        }
        else
        {
            /* Check for a few "well-known" functions */

            if  ((hashTab::getIdentFlags(memSym->sdName) & IDF_PREDEF) &&
                 memSym->sdIsDefined == false &&
                 memSym->sdParent == cmpGlobalNS)
            {
                if      (memSym->sdName == cmpIdentDbgBreak)
                {
                    assert(args == NULL);

                    fncx = cmpCreateExprNode(fncx, TN_DBGBRK, cmpTypeVoid);

                    memSym->sdIsImplicit = true;
                }
                else if (memSym->sdName == cmpIdentXcptCode)
                {
                    Ident           getxName;
                    SymDef          getxSym;
                    SymDef          getxCls;

                    assert(args == NULL);

                    memSym->sdIsImplicit = true;

                    /* This is only allowed within a filter expression */

                    if  (!cmpFilterObj)
                    {
                        cmpError(ERRnotFlx, memSym);
                        return cmpCreateErrNode();
                    }

                    /* Find the "System::Runtime::InteropServices::Marshal" class */

                    getxCls = cmpMarshalCls;
                    if  (!getxCls)
                    {
                        // System::Runtime::InteropServices::Marshal

                        getxCls = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("Marshal"),
                                                              NS_NORM,
                                                              cmpInteropGet());

                        if  (!getxCls || getxCls->sdSymKind != SYM_CLASS)
                            cmpGenFatal(ERRbltinTp, "System::Runtime::InteropServices::Marshal");

                        cmpMarshalCls = getxCls;
                    }

                    /* Find "GetExceptionCode()" and create the call */

                    getxName = cmpGlobalHT->hashString("GetExceptionCode");
                    getxSym  = cmpGlobalST->stLookupClsSym(getxName, getxCls);

                    assert(getxSym && getxSym->sdIsStatic
                                   && getxSym->sdFnc.sdfNextOvl == NULL);

                    fncx->tnOper             = TN_FNC_SYM;
                    fncx->tnFncSym.tnFncSym  = getxSym;
                    fncx->tnFncSym.tnFncArgs = NULL;
                    fncx->tnFncSym.tnFncObj  = NULL;
                    fncx->tnFncSym.tnFncScp  = NULL;
                }
                else if (memSym->sdName == cmpIdentXcptInfo)
                {
                    UNIMPL("sorry, can't use _exception_info for now");
                }
            }
        }
    }

    return fncx;
}

/*****************************************************************************
 *
 *  Bind an assignment.
 */

Tree                compiler::cmpBindAssignment(Tree          dstx,
                                                Tree          srcx,
                                                Tree          expr,
                                                treeOps       oper)
{
    TypDef          dstType;
    var_types       dstVtyp;

    /* Mark the target of the assignment */

    dstx->tnFlags |= TNF_ASG_DEST;

    /* In case the coercion or lvalue check fail ... */

    cmpRecErrorPos(expr);

    /* Usually the result has the same type as the target */

    dstType = dstx->tnType;
    dstVtyp = dstType->tdTypeKindGet();

    /* Check for an assignment to an indexed property */

    if  (dstVtyp == TYP_FNC && dstx->tnOper == TN_PROPERTY)
    {
        Tree            dest = dstx->tnVarSym.tnVarObj;

        assert(dest && dest->tnOper == TN_LIST);
        assert(oper == TN_ASG && "sorry, things like += are not allowed with properties for now");

        dstx->tnVarSym.tnVarObj = dest->tnOp.tnOp1;

        return  cmpBindProperty(dstx, dest->tnOp.tnOp2, srcx);
    }

    /* Check for an overloaded operator */

    if  (dstVtyp == TYP_CLASS || dstVtyp == TYP_REF && oper != TN_ASG)
    {
        Tree            ovlx;

        expr->tnOp.tnOp1 = dstx;
        expr->tnOp.tnOp2 = srcx;

        ovlx = cmpCheckOvlOper(expr);
        if  (ovlx)
            return  ovlx;
    }

    /* Make sure the target is an lvalue */

    if  (!cmpCheckLvalue(dstx, false, true) && dstx->tnOper != TN_PROPERTY)
    {
        cmpCheckLvalue(dstx, false);
        return cmpCreateErrNode();
    }

    /* In general, we need to coerce the value to the target type */

    switch (oper)
    {
    default:

        srcx = cmpCastOfExpr(srcx, dstx->tnType, false);
        break;

    case TN_ASG_ADD:
    case TN_ASG_SUB:

        /* Special case: "ptr += int" or "ptr -= int' */

        if  (dstx->tnVtyp == TYP_PTR)
        {
            if  (cmpConfig.ccTgt64bit)
            {
                if  (srcx->tnVtyp < TYP_NATINT || srcx->tnVtyp > TYP_ULONG)
                    srcx = cmpCoerceExpr(srcx, cmpTypeNatInt, false);
            }
            else
            {
                if  (srcx->tnVtyp < TYP_INT || srcx->tnVtyp >= TYP_LONG)
                    srcx = cmpCoerceExpr(srcx, cmpTypeInt, false);
            }

            /* Scale the index value if necessary */

            srcx = cmpScaleIndex(srcx, dstType, TN_MUL);

            goto DONE;
        }

        srcx = cmpCastOfExpr(srcx, dstx->tnType, false);
        break;

    case TN_ASG_LSH:
    case TN_ASG_RSH:
    case TN_ASG_RSZ:

        /* Special case: if the second operand is 'long', make it 'int' */

        if  (dstx->tnVtyp == TYP_LONG)
        {
            srcx = cmpCoerceExpr(srcx, cmpTypeInt, false);
            break;
        }

        srcx = cmpCastOfExpr(srcx, dstx->tnType, false);
        break;
    }

    assert(srcx);

    /* Is this an assignment operator? */

    switch (oper)
    {
    case TN_ASG:
        break;

    case TN_ASG_ADD:
    case TN_ASG_SUB:
    case TN_ASG_MUL:
    case TN_ASG_DIV:
    case TN_ASG_MOD:

        /* The operands must be arithmetic */

        if  (varTypeIsArithmetic(dstVtyp))
            break;

        /* Wide characters are also OK in non-pedantic mode */

        if  (dstVtyp == TYP_WCHAR && !cmpConfig.ccPedantic)
            break;

        goto OP_ERR;

    case TN_ASG_AND:

        /* Strings are acceptable for "&=" */

        if  (cmpIsStringVal(dstx) && cmpIsStringVal(srcx))
            break;

    case TN_ASG_XOR:
    case TN_ASG_OR:

        /* The operands must be an integral type  */

        if  (varTypeIsIntegral(dstVtyp))
        {
            /* For enums and bools, the types better be identical */

            if  (varTypeIsArithmetic(srcx->tnVtypGet()) && varTypeIsArithmetic(dstVtyp))
                break;

            if  (symTab::stMatchTypes(srcx->tnType, dstType))
                break;
        }

        goto OP_ERR;

    case TN_ASG_LSH:
    case TN_ASG_RSH:
    case TN_ASG_RSZ:

        /* The operands must be integer */

        if  (varTypeIsIntegral(dstVtyp))
        {
            /* But not bool or enum! */

            if  (dstVtyp != TYP_BOOL && dstVtyp != TYP_ENUM)
                break;
        }

        goto OP_ERR;

    default:
        assert(!"unexpected assignment operator");
    }

    /* Is this an assignment operator? */

    if  (oper != TN_ASG)
    {
        /* The result will be promoted to 'int' if it's any smaller */

        if  (dstType->tdTypeKind < TYP_INT)
            dstType = cmpTypeInt;
    }

DONE:

    if  (dstx->tnOper == TN_PROPERTY)
        return  cmpBindProperty(dstx, NULL, srcx);

    /* Return an assignment node */

    return  cmpCreateExprNode(expr, oper, dstType, dstx, srcx);

OP_ERR:

    if  (srcx->tnVtyp != TYP_UNDEF && dstx->tnVtyp != TYP_UNDEF)
    {
        cmpError(ERRoperType2,
                 cmpGlobalHT->tokenToIdent(treeOp2token(oper)),
                 dstx->tnType,
                 srcx->tnType);
    }

    return cmpCreateErrNode();
}

/*****************************************************************************
 *
 *  If the given expression is of a suitable type, make it into the boolean
 *  result, i.e. compare it against 0.
 */

Tree                compiler::cmpBooleanize(Tree expr, bool sense)
{
    if  (varTypeIsSclOrFP(expr->tnVtypGet()))
    {
        Tree            zero;

        if  (expr->tnOperKind() & TNK_CONST)
        {
            switch (expr->tnOper)
            {
            case TN_CNS_INT:

                expr->tnIntCon.tnIconVal = (!expr->tnIntCon.tnIconVal) ^ sense;
                expr->tnVtyp             = TYP_BOOL;
                expr->tnType             = cmpTypeBool;

                return  expr;

            // ISSUE: fold long/float/double conditions as well, right?
            }
        }

        switch (expr->tnVtyp)
        {
        case TYP_LONG:
        case TYP_ULONG:
            zero = cmpCreateLconNode(NULL, 0, TYP_LONG);
            break;

        case TYP_FLOAT:
            zero = cmpCreateFconNode(NULL, 0);
            break;

        case TYP_DOUBLE:
            zero = cmpCreateDconNode(NULL, 0);
            break;

        case TYP_REF:
        case TYP_PTR:
            zero = cmpCreateExprNode(NULL, TN_NULL, expr->tnType);
            break;

        default:
            zero = cmpCreateIconNode(NULL, 0, TYP_INT);
            break;
        }

        zero->tnType = expr->tnType;
        zero->tnVtyp = expr->tnVtypGet();

        expr = cmpCreateExprNode(NULL, sense ? TN_NE : TN_EQ,
                                       cmpTypeBool,
                                       expr,
                                       zero);
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Bind the given tree and make sure it's a suitable condition expression.
 */

Tree                compiler::cmpBindCondition(Tree expr)
{
    expr = cmpBindExprRec(expr);

    /* In non-pedantic mode we allow any arithemtic type as a condition */

    if  (expr->tnVtyp != TYP_BOOL && !cmpConfig.ccPedantic)
    {
        switch (expr->tnOper)
        {
        case TN_EQ:
        case TN_NE:
        case TN_LT:
        case TN_LE:
        case TN_GE:
        case TN_GT:

            assert(expr->tnVtyp <= TYP_UINT);

            expr->tnType = cmpTypeBool;
            expr->tnVtyp = TYP_BOOL;

            break;

        default:
            expr = cmpBooleanize(expr, true);
            break;
        }
    }

    /* Make sure the result is 'boolean' */

    return  cmpCoerceExpr(expr, cmpTypeBool, false);
}

/*****************************************************************************
 *
 *  Multiply the expression by the size of the type pointed to by the given
 *  pointer type. The 'oper' argument should be TN_MUL or TN_DIV depending
 *  on whether the index is to be multiplied or divided.
 */

Tree                compiler::cmpScaleIndex(Tree expr, TypDef type, treeOps oper)
{
    size_t          size;

    assert(type->tdTypeKind == TYP_PTR || (type->tdTypeKind == TYP_REF && !type->tdIsManaged));
    assert(oper == TN_MUL || oper == TN_DIV);

    size = cmpGetTypeSize(cmpActualType(type->tdRef.tdrBase));

    if      (size == 0)
    {
        cmpError(ERRbadPtrUse, type);
    }
    else if (size > 1)
    {
        if  (expr->tnOper == TN_CNS_INT)
        {
            expr->tnIntCon.tnIconVal *= size;
        }
        else
        {
            Tree        cnsx;

            cnsx = cmpConfig.ccTgt64bit ? cmpCreateLconNode(NULL, size, TYP_ULONG)
                                        : cmpCreateIconNode(NULL, size, TYP_UINT);

            expr = cmpCreateExprNode(NULL, oper, expr->tnType, expr,
                                                               cnsx);
        }
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Return true if the given expresion refers to a managed object.
 */

bool                compiler::cmpIsManagedAddr(Tree expr)
{
    switch (expr->tnOper)
    {
    case TN_LCL_SYM:
        return  false;

    case TN_INDEX:
        expr = expr->tnOp.tnOp1;
        if  (expr->tnVtyp != TYP_ARRAY)
            return  false;
        break;

    case TN_VAR_SYM:
        return  expr->tnVarSym.tnVarSym->sdIsManaged;

    case TN_IND:
        return  false;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
        printf("WARNING: unexpected value in cmpIsManagedAddr()\n");
#endif
        return  false;
    }

    return  expr->tnType->tdIsManaged;
}

/*****************************************************************************
 *
 *  Bind the given expression and return the bound and fully analyzed tree,
 *  or NULL if there were binding errors.
 */

Tree                compiler::cmpBindExprRec(Tree expr)
{
    SymTab          ourStab = cmpGlobalST;

    treeOps         oper;
    unsigned        kind;

    assert(expr);
#if!MGDDATA
    assert((int)expr != 0xDDDDDDDD && (int)expr != 0xCCCCCCCC);
#endif

    /* Get hold of the (unbound) operator */

    oper = expr->tnOperGet ();
    kind = expr->tnOperKind();

    /* Is this a constant node? */

    if  (kind & TNK_CONST)
    {
        /* In case we get an error ... */

        cmpRecErrorPos(expr);

        switch (oper)
        {
        case TN_CNS_STR:

            if      (expr->tnFlags & TNF_STR_ASCII)
            {
            ANSI_STRLIT:
                expr->tnType   = cmpTypeCharPtr;
                expr->tnVtyp   = TYP_PTR;
            }
            else if (expr->tnFlags & TNF_STR_WIDE)
            {
            UNIC_STRLIT:
                expr->tnType   = cmpTypeWchrPtr;
                expr->tnVtyp   = TYP_PTR;
            }
            else
            {
                if  (!(expr->tnFlags & TNF_STR_STR))
                {
                    if  (cmpConfig.ccStrCnsDef == 1)
                        goto ANSI_STRLIT;
                    if  (cmpConfig.ccStrCnsDef == 2)
                        goto UNIC_STRLIT;
                }

                expr->tnType = cmpFindStringType();
                expr->tnVtyp = TYP_REF;
            }

            break;

        case TN_NULL:
            expr->tnVtyp = TYP_REF;
            expr->tnType = cmpFindObjectType();
            break;

        default:
            if  (expr->tnVtyp != TYP_ENUM)
                expr->tnType = ourStab->stIntrinsicType(expr->tnVtypGet());
            break;
        }

#ifdef  DEBUG
        expr->tnFlags |= TNF_BOUND;
#endif

        return  expr;
    }

    /* Is this a leaf node? */

    if  (kind & TNK_LEAF)
    {
        /* In case we get an error ... */

        cmpRecErrorPos(expr);

        switch (oper)
        {
        case TN_NAME:
            expr = cmpBindNameUse(expr, false, false);
            break;

        case TN_THIS:

            expr = cmpThisRef();

            /* In methods of managed value classes we implicitly fetch "*this" */

            if  (expr && cmpCurCls->sdType->tdClass.tdcValueType && cmpCurCls->sdIsManaged)
                expr = cmpCreateExprNode(NULL, TN_IND, cmpCurCls->sdType, expr);

            break;

        case TN_BASE:
            expr = cmpThisRef();
            if  (expr->tnOper != TN_ERROR)
            {
                TypDef          curTyp;

                assert(expr->tnOper == TN_LCL_SYM);
                assert(expr->tnType == cmpCurCls->sdType->tdClass.tdcRefTyp);

                /* Figure out the base class (if there is one) */

                curTyp = cmpCurCls->sdType;

                /* Managed structs don't really have a base class */

                if  (curTyp->tdClass.tdcValueType && curTyp->tdIsManaged)
                    curTyp = NULL;
                else
                    curTyp = curTyp->tdClass.tdcBase;

                /* Make sure this ref to "baseclass" is OK */

                if  (curTyp)
                {
                    expr->tnType   = curTyp->tdClass.tdcRefTyp;
                    expr->tnFlags |= TNF_LCL_BASE;
                }
                else
                    expr = cmpCreateErrNode(ERRbadBaseCall);
            }
            break;

        default:
#ifdef DEBUG
            cmpParser->parseDispTree(expr);
#endif
            assert(!"unexpected leaf node");
        }

#ifdef  DEBUG
        expr->tnFlags |= TNF_BOUND;
#endif

        return  expr;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        Tree            op1 = expr->tnOp.tnOp1;
        Tree            op2 = expr->tnOp.tnOp2;

        var_types       tp1;
        var_types       tp2;

        bool            mv1 = false;
        bool            mv2 = false;

        var_types       rvt;
        var_types       pvt;

        /* If this is an assignment, mark the target */

        if  (kind & TNK_ASGOP)
            op1->tnFlags |= TNF_ASG_DEST;

        /* Check for a few special cases first */

        switch (oper)
        {
            TypDef          type;
            size_t          size;

        case TN_DOT:
        case TN_ARROW:
            return  cmpBindDotArr(expr, false, false);

#ifdef  SETS
        case TN_DOT2:
            return  cmpBindSlicer(expr);
#endif

        case TN_CALL:
            return  cmpBindCall(expr);

        case TN_CAST:

            /* Bind the type reference and the operand */

            op1 = cmpBindExprRec(op1);
            if  (op1->tnVtyp == TYP_UNDEF)
                return op1;

            /* Get hold of the target type and check it */

            type = cmpBindExprType(expr);

            /* Are the types identical? */

            if  (type->tdTypeKind == op1->tnVtyp && varTypeIsIntegral(op1->tnVtypGet()))
            {
                // UNDONE: Mark op1 as non-lvalue, right?

                return  op1;
            }

            /* In case we get an error ... */

            cmpRecErrorPos(expr);

            /* Now perform the coercion */

            return cmpCoerceExpr(op1, type, (expr->tnFlags & TNF_EXP_CAST) != 0);

        case TN_LOG_OR:
        case TN_LOG_AND:

            /* Both operands must be conditions */

            op1 = cmpBindCondition(op1);
            op2 = cmpBindCondition(op2);

            /* The result will be boolean, of course */

            rvt = TYP_BOOL;

            // UNDONE: try to fold the condition

            goto RET_TP;

        case TN_LOG_NOT:

            /* The operand must be a condition */

            op1 = cmpBindCondition(op1);
            rvt = TYP_BOOL;

            goto RET_TP;

        case TN_NEW:
            return  cmpBindNewExpr(expr);

        case TN_ISTYPE:

            /* Bind the type reference and the operand */

            op1 = cmpBindExpr(op1);
            if  (op1->tnVtyp == TYP_UNDEF)
                return op1;

            /* Get hold of the type and check it */

            type = cmpBindExprType(expr);

            /* Both operands must be classes or arrays */

            switch (cmpActualVtyp(op1->tnType))
            {
                TypDef          optp;

            case TYP_REF:
            case TYP_ARRAY:
                break;

            case TYP_VOID:
                goto OP_ERR;

            default:

                /* Switch to the equivalent struct type */

                optp = cmpCheck4valType(op1->tnType);
                if  (!optp)
                    goto OP_ERR;

                op1->tnVtyp = TYP_CLASS;
                op1->tnType = optp;

                /* Box the sucker -- no doubt this is what the programmer wants */

                op1 = cmpCreateExprNode(NULL, TN_BOX, optp->tdClass.tdcRefTyp, op1);
                break;
            }

            switch (type->tdTypeKind)
            {
            case TYP_REF:
                type = type->tdRef.tdrBase;
                break;

            case TYP_CLASS:
            case TYP_ARRAY:
                break;

            default:
                type = cmpCheck4valType(type);
                if  (!type)
                    goto OP_ERR;
                break;
            }

            expr->tnOper               = TN_ISTYPE;

            expr->tnVtyp               = TYP_BOOL;
            expr->tnType               = cmpTypeBool;

            expr->tnOp.tnOp1           = op1;
            expr->tnOp.tnOp2           = cmpCreateExprNode(NULL, TN_NONE, type);

            /* Does the type reference a generic type argument ? */

            if  (type->tdTypeKind == TYP_CLASS &&
                 type->tdClass.tdcSymbol->sdClass.sdcGenArg)
            {
                UNIMPL(!"sorry, 'istype' against generic type argument NYI");
            }

            return  expr;

        case TN_QMARK:
            return  cmpBindQmarkExpr(expr);

        case TN_SIZEOF:
        case TN_TYPEOF:
        case TN_ARR_LEN:

            if  (op1)
            {
                /* Bind the operand so that we can see its type */

                switch (op1->tnOper)
                {
                case TN_ANY_SYM:

                    // UNDONE: Tell cmpBindName() that we just need the type of the expr

                    op1 = cmpBindNameUse(op1, false, true);

                    if  (op1->tnOper == TN_CLASS)
                    {
                        expr->tnType = type = op1->tnType;

                        /* Pretend there was no operand, just the type */

                        op1  = NULL;
                    }
                    break;

                case TN_NAME:
                    op1->tnFlags |= TNF_NAME_TYPENS;
                    op1 = cmpBindNameUse(op1, false, true);
                    break;

                case TN_DOT:
                case TN_ARROW:
                    op1 = cmpBindDotArr(op1, false, true);
                    break;

                default:
                    op1 = cmpBindExprRec(op1);
                    break;
                }

                /*
                    Check for the ugly case: "sizeof(arrayvar)" is tricky,
                    because the array normally decays into a pointer, so
                    we need to see if that's happened and "undo" it.
                 */

                if  (op1)
                {
                    type = op1->tnType;

                    switch (op1->tnOper)
                    {
                    case TN_ADDROF:
                        if  (op1->tnFlags & TNF_ADR_IMPLICIT)
                        {
                            assert((op1->tnFlags & TNF_BEEN_CAST) == 0);

                            type = op1->tnOp.tnOp1->tnType;

                            assert(type->tdTypeKind == TYP_ARRAY);
                        }
                        break;

                    case TN_CLASS:
                        op1 = NULL;
                        break;

                    case TYP_UNDEF:
                        return  op1;
                    }
                }
            }
            else
                type = expr->tnType;

            if  (oper == TN_TYPEOF)
            {
                /* Make sure the type looks OK */

                cmpBindType(type, false, false);

            CHKTPID:

                switch (type->tdTypeKind)
                {
                case TYP_REF:
                case TYP_PTR:
                    type = type->tdRef.tdrBase;
                    goto CHKTPID;

                case TYP_ENUM:
                    type->tdIsManaged = true;
                    break;

                case TYP_REFANY:

                    expr->tnOp.tnOp1  = op1;

                    expr->tnType      = cmpTypeRef();
                    expr->tnVtyp      = TYP_REF;

                    return  expr;

                case TYP_CLASS:
                case TYP_ARRAY:
                    if  (type->tdIsManaged)
                        break;

                    // Fall through ....

                default:

                    if  (type->tdTypeKind > TYP_lastIntrins)
                    {
                        cmpError(ERRtypeidOp, expr->tnType);
                        return cmpCreateErrNode();
                    }

                    type = cmpFindStdValType(type->tdTypeKindGet());
                    break;
                }

                /* Do we have a suitable instance? */

                if  (op1 && !type->tdClass.tdcValueType)
                {
                    SymDef          gsym;
                    Tree            call;

                    assert(op1->tnVtyp == TYP_REF || op1->tnVtyp == TYP_ARRAY);

                    /* Change the expression to "expr.GetClass()" */

                    gsym = cmpGlobalST->stLookupClsSym(cmpIdentGetType, cmpClassObject);
                    if  (!gsym)
                    {
                        UNIMPL(!"can this ever happen?");
                    }

                    call = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpTypeRef());

                    call->tnFncSym.tnFncObj  = op1;
                    call->tnFncSym.tnFncSym  = gsym;
                    call->tnFncSym.tnFncArgs = NULL;
                    call->tnFncSym.tnFncScp  = NULL;

                    return  call;
                }
                else
                {
                    /* We'll have to make up an instance for the typeinfo */

                    return cmpTypeIDinst(type);
                }
            }

            if  (oper == TN_ARR_LEN)
            {
                if  (type->tdTypeKind != TYP_ARRAY)
                {
                BAD_ARR_LEN:
                    cmpError(ERRbadArrLen, type); size = 1;
                }
                else
                {
                    if  (type->tdIsManaged)
                    {
                        rvt = TYP_UINT;
                        goto RET_TP;
                    }
                    else
                    {
                        DimDef          dims = type->tdArr.tdaDims;

                        assert(dims && dims->ddNext == NULL);

                        if  (dims->ddNoDim)
                            goto BAD_ARR_LEN;
                        if  (dims->ddIsConst == false)
                            goto BAD_ARR_LEN;

                        size = dims->ddSize;
                    }
                }
            }
            else
            {
                if  (type->tdIsManaged || type->tdTypeKind == TYP_NATINT
                                       || type->tdTypeKind == TYP_NATUINT)
                {
                    cmpError(ERRbadSizeof, type);
                    return cmpCreateErrNode();
                }

                size = cmpGetTypeSize(type);
            }

            expr = cmpCreateIconNode(expr, size, TYP_UINT);

#ifdef  DEBUG
            expr->tnFlags |= TNF_BOUND;
#endif

            return  expr;

        case TN_INDEX:

            /*
                Bind the first operand and see if it's a property. 
                We prevent property binding by bashing the assignment flag.
             */

            op1->tnFlags |=  TNF_ASG_DEST;
            op1 = (op1->tnOper == TN_NAME) ? cmpBindName(op1, false, false)
                                           : cmpBindExprRec(op1);
            op1->tnFlags &= ~TNF_ASG_DEST;

            tp1 = op1->tnVtypGet();
            if  (tp1 == TYP_UNDEF)
                return op1;

            assert(tp1 != TYP_TYPEDEF);

            /* Is this an indexed property access? */

            if  (op1->tnOper == TN_PROPERTY)
            {
                /* Bind the second operand */

                op2 = cmpBindExprRec(op2);
                tp2 = op2->tnVtypGet();
                if  (tp2 == TYP_UNDEF)
                    return op2;

                /* Wrap 'op2' into an argument list entry node */

                if  (op2->tnOper != TN_LIST)
                    op2 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, op2, NULL);

                /* Is this an assignment target? */

                if  (expr->tnFlags & TNF_ASG_DEST)
                {
                    /* Return the property to the caller for processing */

                    assert(op1->tnVarSym.tnVarObj);
                    assert(op1->tnVarSym.tnVarObj->tnOper != TN_LIST);

                    op1->tnVarSym.tnVarObj = cmpCreateExprNode(NULL,
                                                               TN_LIST,
                                                               cmpTypeVoid,
                                                               op1->tnVarSym.tnVarObj,
                                                               op2);

                    return  op1;
                }
                else
                {
                    /* Go and bind the property reference */

                    return  cmpBindProperty(op1, op2, NULL);
                }
            }

            goto BOUND_OP1;

#ifdef  SETS

        case TN_ALL:
        case TN_EXISTS:
        case TN_FILTER:
        case TN_UNIQUE:
        case TN_SORT:
        case TN_INDEX2:
        case TN_GROUPBY:
            return  cmpBindSetOper(expr);

        case TN_PROJECT:
            return  cmpBindProject(expr);

#endif

        case TN_ADD:

            /* Is this a recursive call? */

            if  (expr->tnFlags & TNF_ADD_NOCAT)
            {
                tp1 = op1->tnVtypGet();
                if  (tp1 == TYP_UNDEF)
                    return op1;

                assert(tp1 != TYP_TYPEDEF);

                if  (varTypeIsArithmetic(tp1))
                    mv1 = true;

                tp2 = op2->tnVtypGet();
                if  (tp2 == TYP_UNDEF)
                    return op2;

                assert(tp2 != TYP_TYPEDEF);

                if  (varTypeIsArithmetic(tp2))
                    mv2 = true;

                goto BOUND;
            }

            if  (cmpFindStringType())
            {
                cmpWarn(WRNaddStrings);
                return  cmpBindConcat(expr);
            }

            break;

        case TN_ASG_CNC:

            expr->tnOp.tnOp1 = cmpBindExprRec(op1);

            // Fall through ...

        case TN_CONCAT:

            if  (cmpFindStringType())
                return  cmpBindConcat(expr);

            break;

        case TN_ASG_ADD:

            /* Bind the target of the assignment and see if it's a string */

            op1 = cmpBindExprRec(op1);
            tp1 = op1->tnVtypGet();
            if  (tp1 == TYP_UNDEF)
                return op1;

            assert(tp1 != TYP_TYPEDEF);

            if  (cmpIsStringExpr(op1))
            {
                expr->tnOp.tnOp1 = op1;

                cmpWarn(WRNaddStrings);
                return  cmpBindConcat(expr);
            }

            goto BOUND_OP1;

        case TN_TOKEN:

            assert(op1 && op1->tnOper == TN_NOP);
            assert(op2 == NULL);

            expr->tnVtyp = TYP_CLASS;
            expr->tnType = cmpRThandleClsGet()->sdType;

            assert(expr->tnType->tdTypeKind == expr->tnVtyp);

            return  expr;
        }

        /* Bind the operand(s) of the unary/binary operator */

        if  (op1)
        {
            op1 = cmpBindExprRec(op1);
            tp1 = op1->tnVtypGet();
            if  (tp1 == TYP_UNDEF)
                return op1;

        BOUND_OP1:

            assert(tp1 != TYP_TYPEDEF);

            if  (varTypeIsArithmetic(tp1))
                mv1 = true;
        }

        if  (op2)
        {
            op2 = cmpBindExprRec(op2);
            tp2 = op2->tnVtypGet();
            if  (tp2 == TYP_UNDEF)
                return op2;

            assert(tp2 != TYP_TYPEDEF);

            if  (varTypeIsArithmetic(tp2))
                mv2 = true;
        }

    BOUND:

        /* In case we get an error ... */

        cmpRecErrorPos(expr);

        /* See if we have an 'interesting' operator */

        switch  (oper)
        {
            TypDef          type;

        case TN_ASG:
        case TN_ASG_ADD:
        case TN_ASG_SUB:
        case TN_ASG_MUL:
        case TN_ASG_DIV:
        case TN_ASG_MOD:
        case TN_ASG_AND:
        case TN_ASG_XOR:
        case TN_ASG_OR:
        case TN_ASG_LSH:
        case TN_ASG_RSH:
        case TN_ASG_RSZ:
            return  cmpBindAssignment(op1, op2, expr, oper);

        case TN_LIST:
            expr->tnVtyp = TYP_VOID;
            expr->tnType = cmpTypeVoid;
            goto RET_OP;

        case TN_ADD:
        case TN_SUB:
        case TN_MUL:
        case TN_DIV:
        case TN_MOD:
            break;

        case TN_EQ:
        case TN_NE:

            /* The result will have the type 'boolean' */

            rvt = TYP_BOOL;

            /* Classes can be compared for equality */

            if  ((tp1 == TYP_REF ||
                  tp1 == TYP_PTR ||
                  tp1 == TYP_ARRAY) && (tp2 == TYP_REF ||
                                        tp2 == TYP_PTR ||
                                        tp2 == TYP_ARRAY))
            {
                if  (cmpConvergeValues(op1, op2))
                {
                    if  (op1->tnType == cmpRefTpString &&
                         op1->tnType == cmpRefTpString)
                    {
                        if  (op1->tnOper != TN_NULL && op2->tnOper != TN_NULL)
                        {
                            /* Should we compare values or refs ? */

                            if  (cmpConfig.ccStrValCmp)
                            {
                                cmpWarn(WRNstrValCmp);

                                /* Make sure we have the string comparison method */

                                if  (!cmpStrEquals)
                                    cmpStrEquals = cmpFindStrCompMF("Equals", true);

                                /* Create a call to the method */

                                return  cmpCallStrCompMF(expr, op1, op2, cmpStrEquals);
                            }
                            else
                            {
                                cmpWarn(WRNstrRefCmp);
                            }
                        }
                    }

                    goto RET_TP;
                }
            }

            /* Booleans can also be compared */

            if  (tp1 == TYP_BOOL && tp2 == TYP_BOOL)
            {
                goto RET_TP;
            }

        case TN_LT:
        case TN_LE:
        case TN_GE:
        case TN_GT:

            /* The result will have the type 'boolean' */

            rvt = TYP_BOOL;

            /* Comparisons that are not == or != require arithmetic operands */

            if  (mv1 && mv2)
            {

            MATH_CMP:

                pvt = tp1;

                if (pvt < tp2)
                    pvt = tp2;

                if (pvt < TYP_INT)
                    pvt = TYP_INT;

                goto PROMOTE;
            }

            /* Pointers can be compared as a relation */

            if  (tp1 == TYP_PTR && tp2 == TYP_PTR)
            {
                if  (cmpConvergeValues(op1, op2))
                    goto RET_TP;
            }

            /* Enums can also be compared */

            if  (tp1 == TYP_ENUM)
            {
                if  (varTypeIsSclOrFP(tp2))
                {
                    TypDef          etp;

                    /* Is the second type an enum as well? */

                    if  (tp2 == TYP_ENUM)
                    {
                        /* Are these the same enum types? */

                        if  (symTab::stMatchTypes(op1->tnType, op2->tnType))
                        {
                            rvt = TYP_BOOL;
                            goto RET_TP;
                        }

                        cmpWarn(WRNenumComp);
                    }

                    /* Switch the first operand to its underlying type */

                    op1->tnType = etp = op1->tnType->tdEnum.tdeIntType;
                    op1->tnVtyp = tp1 = etp->tdTypeKindGet();

                    if  (tp2 == TYP_ENUM)
                        goto ENUM_CMP2;

                    goto MATH_CMP;
                }
            }
            else if (tp2 == TYP_ENUM)
            {
                TypDef          etp;

            ENUM_CMP2:

                op2->tnType = etp = op2->tnType->tdEnum.tdeIntType;;
                op2->tnVtyp = tp2 = etp->tdTypeKindGet();

                goto MATH_CMP;
            }

            /* Wide characters can be compared, of course */

            if  (tp1 == TYP_WCHAR)
            {
                if  (tp2 == TYP_WCHAR)
                    goto RET_TP;

                if  (op2->tnOper == TN_CNS_INT && !(op2->tnFlags & TNF_BEEN_CAST))
                {
                    /* Special case: wide character and character constant */

                    if  (op2->tnVtyp == TYP_CHAR)
                    {
                    WCH2:
                        op2->tnVtyp = TYP_WCHAR;
                        op2->tnType = ourStab->stIntrinsicType(TYP_WCHAR);

                        goto RET_TP;
                    }

                    /* Special case: allow compares of wchar and 0 */

                    if  (op2->tnVtyp == TYP_INT && op2->tnIntCon.tnIconVal == 0)
                        goto WCH2;
                }

                if  (!cmpConfig.ccPedantic)
                    goto INTREL;
            }

            if  (tp2 == TYP_WCHAR)
            {
                if  (op1->tnOper == TN_CNS_INT && !(op1->tnFlags & TNF_BEEN_CAST))
                {
                    /* Special case: wide character and character constant */

                    if  (op1->tnVtyp == TYP_CHAR)
                    {
                    WCH1:
                        op1->tnVtyp = TYP_WCHAR;
                        op1->tnType = ourStab->stIntrinsicType(TYP_WCHAR);

                        goto RET_TP;
                    }

                    /* Special case: allow compares of wchar and 0 */

                    if  (op1->tnVtyp == TYP_INT && op1->tnIntCon.tnIconVal == 0)
                        goto WCH1;
                }

                if  (!cmpConfig.ccPedantic)
                    goto INTREL;
            }

            /* Allow pointers to be compared against the constant 0 */

            if  (tp1 == TYP_PTR &&
                 tp2 == TYP_INT && op2->tnOper == TN_CNS_INT
                                && op2->tnIntCon.tnIconVal == 0)
            {
                if  (oper == TN_EQ || oper == TN_NE)
                {
                    /* Bash the 0 constant to the pointer type */

                    op2->tnVtyp = TYP_PTR;
                    op2->tnType = op1->tnType;

                    goto RET_TP;
                }
            }

            /* Booleans can also be compared */

            if  (tp1 == TYP_BOOL || tp2 == TYP_BOOL)
            {
                /* Normally we require both comparands to be booleans */

                if  (tp1 == TYP_BOOL && tp2 == TYP_BOOL)
                    goto RET_TP;

                /* Here only one of the operands is 'bool' */

                if  (!cmpConfig.ccPedantic)
                {

                INTREL:

                    if  (mv1)
                    {
                        pvt = tp1; if (pvt < TYP_INT) pvt = TYP_INT;
                        goto PROMOTE;
                    }

                    if  (mv2)
                    {
                        pvt = tp2; if (pvt < TYP_INT) pvt = TYP_INT;
                        goto PROMOTE;
                    }
                }
            }

            /* Are both operands references ? */

            if  (tp1 == TYP_REF && tp2 == TYP_REF)
            {
                /* Is this a string value comparison? */

                if  (op1->tnType == cmpRefTpString &&
                     op1->tnType == cmpRefTpString && cmpConfig.ccStrValCmp)
                {
                    cmpWarn(WRNstrValCmp);

                    /* Make sure we have the string comparison method */

                    if  (!cmpStrCompare)
                        cmpStrCompare = cmpFindStrCompMF("Compare", false);

                    /* Create a call to the method */

                    expr = cmpCallStrCompMF(expr, op1, op2, cmpStrCompare);

                    /* Compare the return value appropriately */

                    return  cmpCreateExprNode(NULL,
                                              oper,
                                              cmpTypeBool,
                                              expr,
                                              cmpCreateIconNode(NULL, 0, TYP_INT));
                }

                Tree            temp;

#pragma message("need to fill in code for class operator overloading")

                temp = cmpCompareValues(expr, op1, op2);
                if  (temp)
                    return  temp;

                /* Managed byrefs can also be compared */

                if  (cmpIsByRefType(op1->tnType) &&
                     cmpIsByRefType(op2->tnType))
                {
                    if  (cmpConvergeValues(op1, op2))
                        goto RET_TP;
                }
            }

            /* Last chance - check for overloaded operator */

            if  (tp1 == TYP_CLASS || tp2 == TYP_CLASS)
            {
                Tree            temp;

                temp = cmpCompareValues(expr, op1, op2);
                if  (temp)
                    return  temp;
            }

            goto OP_ERR;

        case TN_LSH:
        case TN_RSH:
        case TN_RSZ:

            /* Integer values required */

            if  (varTypeIsIntegral(tp1) &&
                 varTypeIsIntegral(tp2))
            {

            INT_SHF:

                /* Is either operand an enum? */

                if  (tp1 == TYP_ENUM) tp1 = op1->tnType->tdEnum.tdeIntType->tdTypeKindGet();
                if  (tp2 == TYP_ENUM) tp2 = op2->tnType->tdEnum.tdeIntType->tdTypeKindGet();

                /* Promote 'op1' to be at least as large as 'op2' */

                if  (tp1 < tp2)
                {
                    op1 = cmpCoerceExpr(op1, op2->tnType, false);
                    tp1 = tp2;
                }

                /* If the second operand is 'long', make it 'int' */

                if  (tp2 == TYP_LONG)
                    op2 = cmpCoerceExpr(op2, cmpTypeInt, true);

                /* Optimize away shifts by 0 */

                if  (op2->tnOper == TN_CNS_INT && op2->tnIntCon.tnIconVal == 0)
                {
                    op1->tnFlags &= ~TNF_LVALUE;
                    return op1;
                }

                rvt = tp1;
                goto RET_TP;
            }

            if  (!cmpConfig.ccPedantic)
            {
                if  ((tp1 == TYP_WCHAR || varTypeIsIntegral(tp1)) &&
                     (tp2 == TYP_WCHAR || varTypeIsIntegral(tp2)))
                {
                    goto INT_SHF;
                }
            }

            goto OP_ERR;

        case TN_OR:
        case TN_AND:
        case TN_XOR:

            /* Integers are OK */

            if  (varTypeIsIntegral(tp1) &&
                 varTypeIsIntegral(tp2))
            {
                /* Enum's can be bit'ed together, but the types better match */

                if  (tp1 == TYP_ENUM || tp2 == TYP_ENUM)
                {
                    /* If identical enum types are being or'd, leave the type alone */

                    if  (symTab::stMatchTypes(op1->tnType, op2->tnType))
                    {
                        expr->tnVtyp = tp1;
                        expr->tnType = op1->tnType;

                        goto RET_OP;
                    }

                    /* Promote any enum values to their base type */

                    if  (tp1 == TYP_ENUM)
                    {
                        TypDef          etp = op1->tnType->tdEnum.tdeIntType;

                        op1->tnType = etp;
                        op1->tnVtyp = tp1 = etp->tdTypeKindGet();
                        mv1 = true;
                    }

                    if  (tp2 == TYP_ENUM)
                    {
                        TypDef          etp = op2->tnType->tdEnum.tdeIntType;

                        op2->tnType = etp;
                        op2->tnVtyp = tp2 = etp->tdTypeKindGet();
                        mv2 = true;
                    }
                }

                if  (tp1 == TYP_BOOL && tp2 == TYP_BOOL)
                {
                    rvt = TYP_BOOL;
                    goto RET_TP;
                }

                if  (varTypeIsIntArith(tp1) && varTypeIsIntArith(tp2))
                    goto INT_MATH;
            }

            if  (!cmpConfig.ccPedantic)
            {
                if  ((tp1 == TYP_WCHAR || varTypeIsIntegral(tp1)) &&
                     (tp2 == TYP_WCHAR || varTypeIsIntegral(tp2)))
                {
                    goto INT_MATH;
                }
            }

            /* The last chance is "bool" */

            pvt = rvt = TYP_BOOL;

            goto PROMOTE;

        case TN_NOT:

            /* The operand must be an integer */

            if  (!varTypeIsIntArith(tp1))
            {
                /* Actually, we'll take an enum as well */

                if  (tp1 == TYP_ENUM)
                {
                    expr->tnVtyp = tp1;
                    expr->tnType = op1->tnType;

                    goto RET_OP;
                }

                goto OP_ERR;
            }

            /* The result is at least 'int' */

            rvt = tp1;
            if  (rvt < TYP_INT)
                 rvt = TYP_INT;

            goto RET_TP;

        case TN_NOP:
        case TN_NEG:

            /* The operand must be arithmetic */

            if  (!varTypeIsArithmetic(tp1))
                goto TRY_OVL;

            /* The result is at least 'int' */

            rvt = tp1;
            if  (rvt < TYP_INT)
                 rvt = TYP_INT;

            goto RET_TP;

        case TN_INC_PRE:
        case TN_DEC_PRE:

        case TN_INC_POST:
        case TN_DEC_POST:

            /* The operand better be an lvalue */

            if (!cmpCheckLvalue(op1, false))
                return cmpCreateErrNode();

            /* The operand must be an arithmetic lvalue */

            if  (!mv1 && tp1 != TYP_WCHAR)
            {
                /* Unmanaged pointers / managed byrefs are OK as well */

                if  (tp1 != TYP_PTR && !cmpIsByRefType(op1->tnType))
                {
                    if  (tp1 != TYP_ENUM || cmpConfig.ccPedantic)
                        goto TRY_OVL;

                    expr->tnVtyp = tp1;
                    expr->tnType = op1->tnType;

                    goto RET_OP;
                }

                /* Note: the MSIL generator does the scaling of the delta */
            }

            /* The result will have the same value as the operand */

            rvt = tp1;

            if  (rvt != TYP_PTR && !cmpIsByRefType(op1->tnType))
                goto RET_TP;

            expr->tnVtyp = tp1;
            expr->tnType = op1->tnType;

//          if (rvt == TYP_REF)
//              rvt = TYP_REF;

            goto RET_OP;

        case TN_INDEX:

            /* Make sure the left operand is an array */

            if  (tp1 != TYP_ARRAY)
            {
                if  (tp1 == TYP_PTR)
                {
                    if  (cmpConfig.ccSafeMode)
                        cmpError(ERRsafeArrX);
                }
                else
                {
                    if  (tp1 == TYP_REF)
                    {
                        TypDef          baseTyp = op1->tnType->tdRef.tdrBase;

                        if  (!baseTyp->tdIsManaged)
                            goto DO_INDX;

                    }

                    cmpError(ERRbadIndex, op1->tnType);
                    return cmpCreateErrNode();
                }
            }

        DO_INDX:

            type = cmpDirectType(op1->tnType);

            /* Coerce all of the index values to 'int' or 'uint' */

            if  (op2->tnOper == TN_LIST)
            {
                Tree            xlst = op2;
                unsigned        xcnt = 0;

                /* Only one index expression allowed with unmanaged arrays */

                if  (!type->tdIsManaged)
                    return cmpCreateErrNode(ERRmanyUmgIxx);

                do
                {
                    Tree            indx;

                    assert(xlst->tnOper == TN_LIST);
                    indx = xlst->tnOp.tnOp1;
                    assert(indx);

                    if  (cmpConfig.ccTgt64bit)
                    {
                        if  (indx->tnVtyp < TYP_NATINT ||
                             indx->tnVtyp > TYP_ULONG)
                        {
                            xlst->tnOp.tnOp1 = cmpCoerceExpr(indx, cmpTypeNatUint, false);
                        }
                    }
                    else
                    {
                        if  (indx->tnVtyp != TYP_INT &&
                             indx->tnVtyp != TYP_UINT)
                        {
                            xlst->tnOp.tnOp1 = cmpCoerceExpr(indx, cmpTypeInt, false);
                        }
                    }

                    xcnt++;

                    xlst = xlst->tnOp.tnOp2;
                }
                while (xlst);

                /* Make sure the dimension count is correct */

                if  (type->tdArr.tdaDcnt != xcnt &&
                     type->tdArr.tdaDcnt != 0)
                {
                    cmpGenError(ERRindexCnt, type->tdArr.tdaDcnt);
                    return cmpCreateErrNode();
                }
            }
            else
            {
                if  (cmpConfig.ccTgt64bit)
                {
                    if  (op2->tnVtyp < TYP_NATINT ||
                         op2->tnVtyp > TYP_ULONG)
                    {
                        op2 = cmpCoerceExpr(op2, cmpTypeNatUint, false);
                    }
                }
                else
                {
                    if  (op2->tnVtyp != TYP_INT &&
                         op2->tnVtyp != TYP_UINT)
                    {
                        op2 = cmpCoerceExpr(op2, cmpTypeInt    , false);
                    }
                }

                /* Are we indexing into a managed array? */

                if  (type->tdIsManaged)
                {
                    /* Make sure the dimension count is correct */

                    if  (type->tdArr.tdaDcnt != 1 &&
                         type->tdArr.tdaDcnt != 0)
                    {
                        cmpGenError(ERRindexCnt, type->tdArr.tdaDcnt);
                        return cmpCreateErrNode();
                    }
                }
                else
                {
                    /* Scale the index value if necessary */

                    op2 = cmpScaleIndex(op2, op1->tnType, TN_MUL);
                }
            }

            /* The result will have the type of the array element */

            expr->tnFlags   |= TNF_LVALUE;
            expr->tnOp.tnOp1 = op1;
            expr->tnOp.tnOp2 = op2;
            expr->tnType     = cmpDirectType(op1->tnType->tdArr.tdaElem);
            expr->tnVtyp     = expr->tnType->tdTypeKind;

            return  cmpDecayCheck(expr);

        case TN_IND:

            if  (cmpConfig.ccSafeMode)
                return  cmpCreateErrNode(ERRsafeInd);

            if  (tp1 != TYP_PTR && (tp1 != TYP_REF || op1->tnType->tdIsManaged))
            {
            IND_ERR:
                cmpError(ERRbadIndir, op1->tnType);
                return cmpCreateErrNode();
            }

            type = cmpDirectType(op1->tnType->tdRef.tdrBase);
            if  (type->tdTypeKind == TYP_VOID)
                goto IND_ERR;
            if  (type->tdTypeKind == TYP_FNC)
                goto IND_ERR;

            /* The result will have the type of the pointer base type  */

            expr->tnFlags   |= TNF_LVALUE;
            expr->tnOp.tnOp1 = op1;
            expr->tnOp.tnOp2 = op2;
            expr->tnType     = type;
            expr->tnVtyp     = type->tdTypeKind;

            return  cmpDecayCheck(expr);

        case TN_ADDROF:

            /* Is the operand a decayed array? */

            if  (op1->tnOper == TN_ADDROF && (op1->tnFlags & TNF_ADR_IMPLICIT))
            {
                /* Simply bash the type of the implicit "address of" operator */

                expr->tnOp.tnOp1 = op1 = op1->tnOp.tnOp1;
            }
            else
            {
                /* Make sure the operand is an lvalue */

                if (!cmpCheckLvalue(op1, true))
                    return cmpCreateErrNode();
            }

            /* Special case: "&(((foo*)0)->mem" can be folded */

            if  (op1->tnOper == TN_VAR_SYM && op1->tnVarSym.tnVarObj)
            {
                unsigned        ofs = 0;
                Tree            obj;

                /* Of course, we also have to check for nested members */

                for (obj = op1; obj->tnOper == TN_VAR_SYM; obj = obj->tnVarSym.tnVarObj)
                {
                    assert(obj->tnVarSym.tnVarSym->sdSymKind == SYM_VAR);

                    ofs += obj->tnVarSym.tnVarSym->sdVar.sdvOffset;
                }

                if  (obj->tnOper == TN_CNS_INT && !obj->tnIntCon.tnIconVal)
                {
                    /* Replace the whole thing with the member's offset */

                    expr = cmpCreateIconNode(expr, ofs, TYP_UINT);
                }
            }

            /* Create the resulting pointer/reference type */

            pvt = cmpIsManagedAddr(op1) ? TYP_REF
                                        : TYP_PTR;

            expr->tnType = cmpGlobalST->stNewRefType(pvt, op1->tnType);
            expr->tnVtyp = pvt;

            /* If we've folded the operator, return */

            if  (expr->tnOper == TN_CNS_INT)
            {
#ifdef  DEBUG
                expr->tnFlags |= TNF_BOUND;
#endif
                return  expr;
            }

            goto RET_OP;

        case TN_DELETE:

            if  (cmpConfig.ccSafeMode)
                return  cmpCreateErrNode(ERRsafeDel);

            /* The operand must be a non-constant unmanaged class pointer */

            if  (tp1 != TYP_PTR || op1->tnType->tdRef.tdrBase->tdIsManaged)
                return  cmpCreateErrNode(ERRbadDelete);

            /* This expression will yield no value */

            rvt = TYP_VOID;

            goto RET_TP;

        case TN_COMMA:

            expr->tnVtyp = tp2;
            expr->tnType = op2->tnType;

            goto RET_OP;

        case TN_THROW:

            /* Throw doesn't produce a value */

            expr->tnType = cmpTypeVoid;
            expr->tnVtyp = TYP_VOID;

            /* Is there an operand? */

            if  (!op1)
            {
                /* This is a "rethrow" */

                if  (!cmpInHndBlk)
                    cmpError(ERRbadReThrow);

                return  expr;
            }

            /*
                Make sure the operand a managed class reference derived
                from 'Exception'.
             */

            if  (!cmpCheckException(op1->tnType))
                cmpError(ERRbadEHtype, op1->tnType);

            expr->tnOper     = TN_THROW;
            expr->tnOp.tnOp1 = op1;

            /* If a statement follows, it will never be reached */

            cmpStmtReachable = false;

            return  expr;

        case TN_TYPE:
            cmpError(ERRbadTypeExpr, expr->tnType);
            return  cmpCreateErrNode();

        case TN_REFADDR:

            assert(op1);
            assert(op2 && op2->tnOper == TN_NONE);

            if  (op1->tnVtyp != TYP_REFANY)
            {
                cmpError(ERRbadExpTp, cmpGlobalST->stIntrinsicType(TYP_REFANY), op1->tnType);
                return  cmpCreateErrNode();
            }

            /* Create the resulting pointer type */

            expr->tnType = cmpGlobalST->stNewRefType(TYP_REF, op2->tnType);
            expr->tnVtyp = TYP_REF;

            goto RET_OP;

        case TN_INST_STUB:
            return  expr;

        case TN_DOT_NAME:
        case TN_ARR_INIT:
#ifdef DEBUG
            cmpParser->parseDispTree(expr);
#endif
            assert(!"should never encounter this node in cmpBindExprRec()");

        default:
#ifdef DEBUG
            cmpParser->parseDispTree(expr);
#endif
            assert(!"unexpected operator node");
        }

        /* Only binary operands allowed at this point for simplicity */

        assert(op1);
        assert(op2);

        /* At this point the operands must be arithmetic */

        if  (!mv1 || !mv2)
        {
            /* Check for some special cases (mixing of types, etc.) */

            switch (oper)
            {
            case TN_ADD:

                /* Check for "ptr + int" or "byref + int" */

                if  (tp1 == TYP_PTR || (tp1 == TYP_REF && !op1->tnType->tdIsManaged))
                {
                    if  (!varTypeIsIntegral(tp2))
                        break;

                MATH_PTR1:

                    /* Coerce the second operand to an integer value */

                    if  (cmpConfig.ccTgt64bit)
                    {
                        if  (tp2 != TYP_ULONG && tp2 != TYP_NATUINT)
                            op2 = cmpCoerceExpr(op2, cmpTypeNatInt, false);
                    }
                    else
                    {
                        if  (tp2 != TYP_UINT)
                            op2 = cmpCoerceExpr(op2, cmpTypeInt, false);
                    }

                    /* Scale the integer operand by the base type size */

                    op2 = cmpScaleIndex(op2, op1->tnType, TN_MUL);

                    /* The result will have the pointer type */

                    expr->tnVtyp = tp1;
                    expr->tnType = op1->tnType;

                    goto RET_OP;
                }

                /* Check for "int + ptr" or "int + byref" */

                if  (tp2 == TYP_PTR  || (tp2 == TYP_REF && !op2->tnType->tdIsManaged))
                {
                    if  (!varTypeIsIntegral(tp1))
                        break;

                    /* Coerce the first operand to an integer value */

                    if  (tp1 != TYP_UINT)
                        op1 = cmpCoerceExpr(op1, cmpTypeInt, false);

                    /* Scale the integer operand by the base type size */

                    op1 = cmpScaleIndex(op1, op2->tnType, TN_MUL);

                    /* The result will have the pointer type */

                    expr->tnVtyp = tp2;
                    expr->tnType = op2->tnType;

                    goto RET_OP;
                }

                /* Check for "enum/wchar + int" and "int + enum/wchar" */

                if  ((tp1 == TYP_ENUM || tp1 == TYP_WCHAR) && varTypeIsIntegral(tp2) ||
                     (tp2 == TYP_ENUM || tp2 == TYP_WCHAR) && varTypeIsIntegral(tp1))
                {

                ENUM_MATH:

                    if  (tp1 == TYP_ENUM)
                        tp1 = op1->tnType->tdEnum.tdeIntType->tdTypeKindGet();

                    assert(varTypeIsIntegral(tp1));

                    if  (tp2 == TYP_ENUM)
                        tp2 = op2->tnType->tdEnum.tdeIntType->tdTypeKindGet();

                    assert(varTypeIsIntegral(tp2));

                INT_MATH:

                    /* Promote to max(type,type2,int) */

                    rvt = tp1;
                    if  (rvt < tp2)
                         rvt = tp2;
                    if  (rvt < TYP_INT)
                         rvt = TYP_INT;

                    pvt = rvt; assert(rvt != TYP_ENUM);

                    goto PROMOTE;
                }
                break;

            case TN_SUB:

                /* Check for "ptr/byref - int" and "ptr/byref - ptr/byref" */

                if  (tp1 == TYP_PTR || cmpIsByRefType(op1->tnType))
                {
                    if  (varTypeIsIntegral(tp2))
                        goto MATH_PTR1;

                    if  (tp2 != tp1)
                        break;

                    if  (!symTab::stMatchTypes(op1->tnType, op2->tnType))
                        break;

                    /* Subtract the pointers and divide by element size */

                    expr->tnVtyp     = TYP_INT;
                    expr->tnType     = cmpTypeInt;
                    expr->tnOp.tnOp1 = op1;
                    expr->tnOp.tnOp2 = op2;

                    expr = cmpScaleIndex(expr, op1->tnType, TN_DIV);

                    return  expr;
                }

                /* Check for "enum - int" and "int - enum" */

                if  (tp1 == TYP_ENUM && varTypeIsIntegral(tp2) ||
                     tp2 == TYP_ENUM && varTypeIsIntegral(tp1))
                {
                    goto ENUM_MATH;
                }

                if  (tp1 == TYP_WCHAR)
                {
                    /*
                        Both "wchar - char const" and "wchar - wchar"
                        yield an int.
                     */

                    if  (tp2 == TYP_WCHAR ||
                         tp2 == TYP_CHAR && op2->tnOper == TN_CNS_INT)
                    {
                        rvt = TYP_INT;
                        goto RET_TP;
                    }
                }

                if  (!cmpConfig.ccPedantic)
                {
                    if  (varTypeIsArithmetic(tp1) && (tp2 == TYP_WCHAR || tp2 == TYP_BOOL))
                        goto INT_MATH;
                    if  (varTypeIsArithmetic(tp2) && (tp1 == TYP_WCHAR || tp1 == TYP_BOOL))
                        goto INT_MATH;
                }

                break;

            case TN_MUL:
            case TN_DIV:
            case TN_MOD:

                if  (cmpConfig.ccPedantic)
                    break;

                if  (varTypeIsArithmetic(tp1))
                {
                    if  (tp2 == TYP_ENUM)
                        goto ENUM_MATH;
                    if  (tp2 == TYP_WCHAR)
                        goto INT_MATH;
                }

                if  (varTypeIsArithmetic(tp2))
                {
                    if  (tp1 == TYP_ENUM)
                        goto ENUM_MATH;
                    if  (tp1 == TYP_WCHAR)
                        goto INT_MATH;
                }

                break;
            }

        TRY_OVL:

            /* If either operand is a struct, check for an overloaded operator */

            if  (tp1 == TYP_CLASS || tp2 == TYP_CLASS)
            {
                Tree        ovlx;

                expr->tnOp.tnOp1 = op1;
                expr->tnOp.tnOp2 = op2;

                ovlx = cmpCheckOvlOper(expr);
                if  (ovlx)
                    return  ovlx;
            }

            /* Jump here to report a generic "illegal type for operator" error */

        OP_ERR:

            if  (tp1 != TYP_UNDEF && tp2 != TYP_UNDEF)
            {
                Ident       opnm = cmpGlobalHT->tokenToIdent(treeOp2token(oper));

                if  (op2)
                    cmpError(ERRoperType2, opnm, op1->tnType, op2->tnType);
                else
                    cmpError(ERRoperType , opnm, op1->tnType, false);
            }

            return cmpCreateErrNode();
        }

        /* Promote both operand to either 'int' or the 'bigger' of the two types */

        rvt = TYP_INT;

        if  (tp1 > TYP_INT || tp2 > TYP_INT)
        {
            rvt = tp1;
            if  (rvt < tp2)
                 rvt = tp2;
        }

        pvt = rvt;

        /*
            At this point, we have the following values:

                rvt     ....    type of the result
                pvt     ....    type the operands should be promoted to
         */

    PROMOTE:

        if  (tp1 != pvt) op1 = cmpCoerceExpr(op1, ourStab->stIntrinsicType(pvt), false);
        if  (tp2 != pvt) op2 = cmpCoerceExpr(op2, ourStab->stIntrinsicType(pvt), false);

    RET_TP:

        expr->tnVtyp = rvt;
        expr->tnType = ourStab->stIntrinsicType(rvt);

    RET_OP:

        expr->tnOp.tnOp1 = op1;
        expr->tnOp.tnOp2 = op2;

#ifdef  DEBUG
        expr->tnFlags |= TNF_BOUND;
#endif

        /* Check for an operator with a constant operand */

        if  (op1->tnOperKind() & TNK_CONST)
        {
            /* Some operators can never be folded */

            switch (oper)
            {
            case TN_LIST:
            case TN_COMMA:
                return  expr;
            }

            /* Is this a unary or binary operator? */

            if  (op2)
            {
                if  (op2->tnOperKind() & TNK_CONST)
                {
                    switch (op1->tnOper)
                    {
                    case TN_CNS_INT: expr = cmpFoldIntBinop(expr); break;
                    case TN_CNS_LNG: expr = cmpFoldLngBinop(expr); break;
                    case TN_CNS_FLT: expr = cmpFoldFltBinop(expr); break;
                    case TN_CNS_DBL: expr = cmpFoldDblBinop(expr); break;
                    case TN_CNS_STR: expr = cmpFoldStrBinop(expr); break;
                    case TN_NULL: break;
                    default: NO_WAY(!"unexpected const type");
                    }
                }
                else
                {
                    // UNDONE: Check for things such as "0 && expr"
                }
            }
            else
            {
                switch (op1->tnOper)
                {
                case TN_CNS_INT: expr = cmpFoldIntUnop(expr); break;
                case TN_CNS_LNG: expr = cmpFoldLngUnop(expr); break;
                case TN_CNS_FLT: expr = cmpFoldFltUnop(expr); break;
                case TN_CNS_DBL: expr = cmpFoldDblUnop(expr); break;
                case TN_CNS_STR: break;
                default: NO_WAY(!"unexpected const type");
                }
            }
        }

        return  expr;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case TN_ANY_SYM:
        expr = cmpBindNameUse(expr, false, false);
        break;

    case TN_NONE:
        assert(expr->tnType);
        expr->tnVtyp = expr->tnType->tdTypeKindGet();
        break;

    case TN_ERROR:
        break;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        assert(!"unexpected node");
    }

#ifdef  DEBUG
    expr->tnFlags |= TNF_BOUND;
#endif

    return  expr;
}

/*****************************************************************************
 *
 *  Bind an array bound expression.
 */

Tree                compiler::cmpBindArrayBnd(Tree expr)
{
    if  (expr)
    {
        expr = cmpBindExpr(expr);

        if  (expr->tnVtyp != TYP_UINT)
        {
            if  (expr->tnVtyp != TYP_INT || expr->tnOper == TN_CNS_INT)
            {
                expr = cmpCoerceExpr(expr, cmpTypeUint, false);
            }
        }
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Check an array type parse tree and return the corresponding type.
 */

void                compiler::cmpBindArrayType(TypDef type, bool needDef,
                                                            bool needDim,
                                                            bool mustDim)
{
    DimDef      dims = type->tdArr.tdaDims; assert(dims);
    TypDef      elem = cmpDirectType(type->tdArr.tdaElem);

    assert(type && type->tdTypeKind == TYP_ARRAY);

    /* Can't have an unmanaged array of managed types */

    if  (type->tdIsManaged == false &&
         elem->tdIsManaged != false)
    {
        type->tdIsManaged = elem->tdIsManaged;

//      cmpError(ERRbadRefArr, elem);

        if  (elem->tdTypeKind == TYP_CLASS)
        {
            if  (isMgdValueType(elem))
                type->tdIsValArray = true;
        }

        assert(type->tdIsValArray == (type->tdIsManaged && isMgdValueType(cmpActualType(type->tdArr.tdaElem))));
    }

    /* Is this a managed array? */

    if  (type->tdIsManaged)
    {
        /* Is there any dimension at all? */

        if  (type->tdIsUndimmed)
        {
            /* Are we supposed to have a dimension here? */

            if  (needDim && (elem->tdTypeKind != TYP_ARRAY || mustDim))
                cmpError(ERRnoArrDim);
        }

        /* Check all dimensions that were specified */

        while (dims)
        {
            if  (dims->ddNoDim)
            {
                // UNDONE: What do we need to check here?
            }
            else
            {
                assert(dims->ddDimBound == false);

#ifdef  DEBUG
                dims->ddDimBound = true;
#endif

                dims->ddLoTree   = cmpBindArrayBnd(dims->ddLoTree);
                dims->ddHiTree   = cmpBindArrayBnd(dims->ddHiTree);
            }

            /* Continue with the next dimension */

            dims = dims->ddNext;
        }

        /* Now check the element type */

        cmpBindType(elem, needDef, needDim);

        /* Special handling needed for arrays of value types */

        if  (isMgdValueType(elem)) // && !type->tdArr.tdaArrCls)
        {
            /* Remember that this is an array of managed values */

            type->tdIsValArray = true;
        }
    }
    else
    {
        Tree            dimx;

        /* Is there a dimension at all? */

        if  (type->tdIsUndimmed)
        {
            /* Are we supposed to have a dimension here? */

            if  (needDim && (elem->tdTypeKind != TYP_ARRAY || mustDim))
                cmpError(ERRnoArrDim);

            needDim = true;

            goto ELEM;
        }

        assert(dims);
        assert(dims->ddNoDim == false);
        assert(dims->ddNext  == NULL);

        /* Make sure the element type is not a managed type */

        if  (elem->tdIsManaged || elem->tdTypeKind == TYP_REF)
            cmpError(ERRbadRefArr, elem);

        /* Evaluate the dimension and make sure it's constant */

        dimx = cmpBindExpr(dims->ddLoTree);

        switch (dimx->tnVtyp)
        {
        case TYP_INT:
        case TYP_UINT:
        case TYP_NATINT:
        case TYP_NATUINT:
            break;

        default:
            dimx = cmpCoerceExpr(dimx, cmpTypeInt, false);
            break;
        }

        /* Now make sure we have a constant expression */

        dimx = cmpFoldExpression(dimx);

        switch (dimx->tnOper)
        {
        case TN_CNS_INT:
            dims->ddSize = dimx->tnIntCon.tnIconVal;
            if  (dims->ddSize > 0 || !needDim)
                break;

            // Fall through ....

        default:

            if  (!needDim)
                goto ELEM;

            cmpRecErrorPos(dimx);
            cmpError(ERRbadArrSize);

            // Fall through ....

        case TN_ERROR:
            dims->ddSize = 1;
            break;
        }

        dims->ddIsConst  = true;

    ELEM:

#ifndef NDEBUG
        dims->ddDimBound = true;
#endif

        cmpBindType(type->tdArr.tdaElem, needDef, needDim);
    }
}

/*****************************************************************************
 *
 *  Resolve a type reference within a parse tree.
 */

void                compiler::cmpBindType(TypDef type, bool needDef,
                                                       bool needDim)
{
    assert(type);

AGAIN:

    switch (type->tdTypeKind)
    {
        TypDef          btyp;

    case TYP_ARRAY:
        cmpBindArrayType(type, needDef, needDim, false);
        break;

    case TYP_CLASS:
        if  (needDef)
            cmpDeclSym(type->tdClass.tdcSymbol);
//      if  (type->tdIsManaged)
//          type = type->tdClass.tdcRefTyp;
        break;

    case TYP_TYPEDEF:
        cmpDeclSym(type->tdTypedef.tdtSym);
        type = type->tdTypedef.tdtType;
        goto AGAIN;

    case TYP_REF:

        btyp = type->tdRef.tdrBase; cmpBindType(btyp, needDef, needDim);

//      if  (btyp->tdIsManaged == false)
//          cmpError(ERRumgRef, type);

        break;

    case TYP_PTR:

        btyp = type->tdRef.tdrBase; cmpBindType(btyp, needDef, needDim);

        switch (btyp->tdTypeKind)
        {
        case TYP_CLASS:
            if  (btyp->tdClass.tdcValueType)
                break;
            // Fall through ...
        case TYP_ARRAY:
            if  (!btyp->tdIsManaged)
                break;
            // Fall through ...
        case TYP_REF:
            cmpError(ERRmgdPtr, type);
            break;
        }
        break;

    case TYP_FNC:

        btyp = type->tdFnc.tdfRett;

        /* Special case: reference return type */

        if  (btyp->tdTypeKind == TYP_REF)
        {
            if  (btyp->tdRef.tdrBase->tdTypeKind == TYP_VOID)
            {
                type->tdFnc.tdfRett = cmpGlobalST->stIntrinsicType(TYP_REFANY);
            }
            else
            {
                cmpBindType(btyp->tdFnc.tdfRett, false, false);
            }
        }
        else
            cmpBindType(btyp, false, false);

        // UNDONE: bind return type and all the argument types, right?
        // ISSUE: we should probably ban non-class return refs, right?

        break;

    case TYP_ENUM:
        if  (needDef)
            cmpDeclEnum(type->tdEnum.tdeSymbol);
        break;

    default:
        assert((unsigned)type->tdTypeKind <= TYP_lastIntrins);
        break;
    }
}

/*****************************************************************************
 *
 *  Bind an array initializer of the form "{ elem-expr, elem-expr, ... }".
 */

Tree                compiler::cmpBindArrayExpr(TypDef type, int      dimPos,
                                                            unsigned elems)
{
    Scanner         ourScanner = cmpScanner;
    Parser          ourParser  = cmpParser;

    TypDef          elem;

    Tree            list = NULL;
    Tree            last = NULL;

    bool            multi;

    unsigned        count;
    unsigned        subcnt = 0;

    assert(type->tdTypeKind == TYP_ARRAY && type->tdIsManaged);

    count = 0;

    assert(ourScanner->scanTok.tok == tkLCurly);
    if  (ourScanner->scan() == tkRCurly)
        goto DONE;

    elem = cmpDirectType(type->tdArr.tdaElem);

    /* Are we processing a multi-dimensional array initializer? */

    multi = false;

    if  (type->tdArr.tdaDims &&
         type->tdArr.tdaDims->ddNext)
    {
        /* This is a multi-dimensional rectangular array */

        if  (!dimPos)
        {
            /* We're at the outermost dimension, get things started */

            dimPos = 1;
            multi  = true;

            /* Pass the same array type on to the next level */

            elem = type;
        }
        else
        {
            DimDef          dims = type->tdArr.tdaDims;
            unsigned        dcnt;

            /* Do we have any dimensions left? */

            dcnt = dimPos++;

            do
            {
                dims = dims->ddNext; assert(dims);
            }
            while (--dcnt);

            if  (dims->ddNext)
            {
                /* There is another dimension to this array */

                multi  = true;

                /* Pass the same array type on to the next level */

                elem   = type;
            }
            else
                dimPos = 0;
        }
    }
    else
    {
        assert(dimPos == 0);

        if  (elem->tdTypeKind == TYP_ARRAY)
            multi = true;
    }

    for (count = 0;;)
    {
        Tree            init;

        count++;

        /* Are we expecting a nested array? */

        if  (ourScanner->scanTok.tok == tkLCurly)
        {
            if  (multi)
            {
                /* Recursively process the nested initializer */

                init = cmpBindArrayExpr(elem, dimPos, subcnt);

                /* Check/record the element count */

                if  (!subcnt && init->tnOper == TN_ARR_INIT)
                {
                    assert(init->tnOp.tnOp2);
                    assert(init->tnOp.tnOp2->tnOper == TN_CNS_INT);

                    subcnt = init->tnOp.tnOp2->tnIntCon.tnIconVal;
                }
            }
            else
            {
                cmpError(ERRbadBrNew, elem);

                init = cmpCreateErrNode();

                ourScanner->scanSkipText(tkLCurly, tkRCurly);
                if  (ourScanner->scanTok.tok == tkRCurly)
                    ourScanner->scan();
            }
        }
        else
        {
            /* Can we accept an ordinary expression? */

            if  (dimPos)
                init = cmpCreateErrNode(ERRnoLcurly);
            else
                init = ourParser->parseExprComma();

            /* Bind the value and coerce it to the right type */

            init = cmpCoerceExpr(cmpBindExpr(init), elem, false);
        }

        /* Add the value to the list */

        list = ourParser->parseAddToNodeList(list, last, init);
        list->tnType = cmpTypeVoid;
        list->tnVtyp = TYP_VOID;

        /* Are there more initializers? */

        if  (ourScanner->scanTok.tok != tkComma)
            break;

        if  (ourScanner->scan() == tkRCurly)
            goto DONE;
    }

    if  (ourScanner->scanTok.tok != tkRCurly)
        cmpError(ERRnoCmRc);

DONE:

    // ISSUE: The following is not good enough for lots of dimensions!

    if  (elems != count && elems != 0 && dimPos)
        cmpGenError(ERRarrInitCnt, elems, count);

    ourScanner->scan();

    /* Stash the whole shebang (along with a count) under an array init node */

    return  cmpCreateExprNode(NULL,
                              TN_ARR_INIT,
                              type,
                              list,
                              cmpCreateIconNode(NULL, count, TYP_UINT));
}

/*****************************************************************************
 *
 *  Bind a {}-style array initializer.
 */

Tree                compiler::bindSLVinit(TypDef type, Tree init)
{
    parserState     save;

    /* This must be a managed array initializer */

    if  (type->tdTypeKind != TYP_ARRAY || !type->tdIsManaged)
    {
        cmpError(ERRbadBrNew, type);
        return  cmpCreateErrNode();
    }

    /* Start reading from the initializer's text */

    cmpParser->parsePrepText(&init->tnInit.tniSrcPos, init->tnInit.tniCompUnit, save);

    /* Parse and bind the initializer */

    init = cmpBindArrayExpr(type);

    /* We're done reading source text from the initializer */

    cmpParser->parseDoneText(save);

    return  init;
}

/*****************************************************************************
 *
 *  Bind a "new" expression.
 */

Tree                compiler::cmpBindNewExpr(Tree expr)
{
    TypDef          type;
    var_types       vtyp;

    Tree            init;

    assert(expr->tnOper == TN_NEW);

    /* Get hold of the initializer, if any */

    init = expr->tnOp.tnOp1;

    /* Check out the type and bind any expressions contained therein */

    type = expr->tnType;
    cmpBindType(type, true, (!init || init->tnOper != TN_SLV_INIT));
    vtyp = type->tdTypeKindGet();

    /* What kind of a value is the "new" trying to allocate? */

    switch (vtyp)
    {
        SymDef          clsSym;

    case TYP_CLASS:

        /* Make sure the type is a class not an interface */

        if  (type->tdClass.tdcFlavor == STF_INTF)
        {
            cmpError(ERRnewIntf, type);
            return cmpCreateErrNode();
        }

        /* Make sure the class is not abstract */

        clsSym = type->tdClass.tdcSymbol;

        if  (clsSym->sdIsAbstract)
        {
            cmpRecErrorPos(expr);
            cmpError(ERRnewAbstract, type);
            return cmpCreateErrNode();
        }

        /* See if the class is marked as "deprecated" */

        if  (clsSym->sdIsDeprecated)
            cmpObsoleteUse(clsSym, WRNdepCls);

        /* Is this a generic type argument ? */

        if  (clsSym->sdClass.sdcGenArg)
        {
            UNIMPL(!"sorry, 'new' on generic type argument NYI");
        }

        break;

    case TYP_ARRAY:

        /* Stash the true type under 'op2' */

        expr->tnOp.tnOp2 = cmpCreateExprNode(NULL, TN_NONE, type);

        /* Is this an unmanaged array? */

        if  (type->tdIsManaged)
            break;

        /* Switch to a pointer to the element type */

        vtyp = TYP_PTR;
        type = expr->tnType = cmpGlobalST->stNewRefType(vtyp, cmpDirectType(type->tdArr.tdaElem));
        break;

    case TYP_FNC:
    case TYP_VOID:

        cmpError(ERRbadNewTyp, type);
        return cmpCreateErrNode();

    default:

        if  (vtyp < TYP_lastIntrins)
        {
            type = cmpFindStdValType(vtyp); assert(type);
            vtyp = TYP_CLASS;
        }
        else
        {
            if  (!init)
            {
                if  (vtyp == TYP_PTR)
                    type = type->tdRef.tdrBase;

                cmpError(ERRnewNoVal, type);
                return cmpCreateErrNode();
            }
        }

        break;
    }

    /* Is this a class or is there an initializer? */

    if  (vtyp == TYP_CLASS || init)
    {
        /* Bind the initializer, if present */

        if  (init)
        {
            if  (init->tnOper == TN_SLV_INIT)
            {
                init = bindSLVinit(type, init);

                expr->tnOp.tnOp1 = init;

                expr->tnVtyp     = vtyp;
                expr->tnType     = type;

                return  expr;
            }

#ifdef  SETS
            if  (vtyp == TYP_CLASS && type->tdClass.tdcSymbol->sdClass.sdcXMLelems)
                return  cmpBindXMLinit(type->tdClass.tdcSymbol, init);
#endif

            init = cmpBindExpr(init);

            if  (init->tnVtyp == TYP_UNDEF)
                return init;
        }

        /* Is this a class? */

        if  (vtyp == TYP_CLASS)
        {
            var_types       intr = (var_types)type->tdClass.tdcIntrType;

            if  (intr != TYP_UNDEF)
            {
                /* The silly things people do ... */

                if  (init)
                {
                    assert(init->tnOper == TN_LIST);

                    if  (init->tnOp.tnOp2 == NULL)
                    {
                        /* We have something like "new Int32(val)" */

                        init = cmpCoerceExpr(init->tnOp.tnOp1,
                                             cmpGlobalST->stIntrinsicType(intr),
                                             false);

                        return  init;
                    }
                }
            }

            expr = cmpCallCtor(type, init);
            if  (!expr)
            {
                assert(type && type->tdTypeKind == TYP_CLASS);

                cmpErrorXtp(ERRnoCtorMatch, type->tdClass.tdcSymbol, init);
                return  cmpCreateErrNode();
            }

            return  expr;
        }
        else
        {
            /* Arrays can't be initialized - enforced by parser */

            assert(vtyp != TYP_ARRAY);

            /* Coerce the initializer to the expected type */

            expr->tnOp.tnOp2 = cmpCoerceExpr(init, type, false);
        }
    }

    expr->tnVtyp = vtyp;

    return  expr;
};

/*****************************************************************************
 *
 *  Add the next sub-operand to a concatenation (recursive).
 */

Tree                compiler::cmpAdd2Concat(Tree expr, Tree  list,
                                                       Tree *lastPtr)
{
    if  (expr->tnOper == TN_CONCAT || expr->tnOper == TN_ASG_CNC)
    {
        list = cmpAdd2Concat(expr->tnOp.tnOp1, list, lastPtr);
        list = cmpAdd2Concat(expr->tnOp.tnOp2, list, lastPtr);
    }
    else
    {
        Tree            addx;

        addx = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, expr, NULL);

        if  (list)
        {
            Tree            last = *lastPtr;

            assert(last && last->tnOper == TN_LIST
                        && last->tnOp.tnOp2 == NULL);

            last->tnOp.tnOp2 = addx;
        }
        else
        {
            list = addx;
        }

        *lastPtr = addx;
    }

    return  list;
}

/*****************************************************************************
 *
 *  Check the given unbound expression tree for string concatenation (this is
 *  done recursively). If the expression is a string concatenation, the tree
 *  will have the TN_CONCAT operator at the top.
 */

Tree                compiler::cmpListConcat(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    /* Special case: a '+=' node means "op1" is bound and known to be string */

    if  (expr->tnOper == TN_ASG_ADD)
         expr->tnOper =  TN_ASG_CNC;

    if  (expr->tnOper == TN_ASG_CNC)
    {
        assert(cmpIsStringExpr(op1));
        assert(op1->tnType == cmpRefTpString);

        goto BIND_OP2;
    }

    assert(expr->tnOper == TN_CONCAT ||
           expr->tnOper == TN_ADD);

    /* Bind both operands and see if either is a string */

    if  (op1->tnOper == TN_CONCAT || op1->tnOper == TN_ADD)
        op1 = cmpListConcat(op1);
    else
        op1 = cmpBindExprRec(op1);

BIND_OP2:

    if  (op2->tnOper == TN_CONCAT || op2->tnOper == TN_ADD)
        op2 = cmpListConcat(op2);
    else
        op2 = cmpBindExprRec(op2);

    expr->tnOp.tnOp1 = op1;
    expr->tnOp.tnOp2 = op2;

    if  (cmpIsStringExpr(op1) || cmpIsStringExpr(op2))
    {
        /* The concatenation operation will be bound in the second pass */

        if  (expr->tnOper != TN_ASG_CNC)
            expr->tnOper = TN_CONCAT;

        expr->tnType = cmpRefTpString;
        expr->tnVtyp = TYP_REF;
    }
    else
    {
        assert(expr->tnOper == TN_ADD);

        /* Rebind the expression, but not its operands */

        expr->tnFlags |= TNF_ADD_NOCAT;

        expr = cmpBindExprRec(expr);
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Bind the given expression tree which may (but may not) denote string
 *  concatenation.
 */

Tree                compiler::cmpBindConcat(Tree expr)
{
    unsigned        ccnt;

    SymDef          cSym;
    bool            asgOp;
    bool            skip;

    Tree            last;
    Tree            list;
    Tree            temp;

    /* Process the expression, looking for string concatenation */

    list = cmpListConcat(expr);

    /* Check whether we have string concatenation / assignment or not */

    if      (list->tnOper == TN_CONCAT)
    {
        asgOp = false;
    }
    else if (list->tnOper == TN_ASG_CNC)
    {
        asgOp =  true;
    }
    else
        return  list;

    /* Create the list of all the operands we'll concatenate */

    last = NULL;
    list = cmpAdd2Concat(list, NULL, &last);

    /*
        We walk the list of concatenands twice - the first time we fold any
        adjacent constant strings, create a simple TN_LIST string of values
        and count the actual number of strings being concatenated. Then we
        decide how to achieve the concatenation: whether to call one of the
        Concat methods that take multiple strings or the String[] flavor.
     */

    ccnt = 0;
    temp = list;
    skip = asgOp;

    do
    {
        Tree            lstx;
        Tree            strx;

        /* Pull the next entry from the list */

        assert(temp && temp->tnOper == TN_LIST);

        lstx = temp;
        temp = temp->tnOp.tnOp2;

        /* Skip the first operand of an assignment operator */

        if  (skip)
        {
            assert(asgOp);
            skip = false;

            goto NEXT;
        }

        /* Grab the next operand's value */

        strx = lstx->tnOp.tnOp1;

        /* Is the operand a string constant and is there another operand? */

        if  (strx->tnOper == TN_CNS_STR && !(strx->tnFlags & TNF_BEEN_CAST) && strx->tnType == cmpStringRef() && temp)
        {
            for (;;)
            {
                Tree            nxtx = temp->tnOp.tnOp1;

                const   char *  str1;
                size_t          len1;
                const   char *  str2;
                size_t          len2;
                        char *  strn;
                size_t          lenn;

                /* Is the next operand also a string constant? */

                if  (nxtx->tnOper != TN_CNS_STR)
                    break;

                /* Get hold of info for both strings */

                str1 = strx->tnStrCon.tnSconVal;
                len1 = strx->tnStrCon.tnSconLen;
                str2 = nxtx->tnStrCon.tnSconVal;
                len2 = nxtx->tnStrCon.tnSconLen;

                /* Replace the first operand with the concatenated string */

                lenn = len1 + len2;
                strn = (char *)cmpAllocCGen.nraAlloc(roundUp(lenn+1));
                memcpy(strn     , str1, len1);
                memcpy(strn+len1, str2, len2+1);

                strx->tnStrCon.tnSconVal = strn;
                strx->tnStrCon.tnSconLen = lenn;

                /* We've consumed the second operand, skip over it */

                lstx->tnOp.tnOp2 = temp = temp->tnOp.tnOp2;

                /* Any more operands to consider? */

                if  (temp == NULL)
                {
                    /* Is this all there is to it? */

                    if  (ccnt == 0)
                    {
                        assert(asgOp == false); // that would be truly amazing!

                        /* Neat - the whole thing folded into one string */

                        return  strx;
                    }

                    break;
                }
            }
        }
        else
        {
            /* Make sure the operand is a string */

        CHK_STR:

            if  (strx->tnType != cmpStringRef())
            {
                Tree            mksx;
                SymDef          asym;

                TypDef          type;
                TypDef          btyp;
                var_types       vtyp;

                /* If the operand is a class, look for a "ToString" method */

                type = strx->tnType;
                vtyp = strx->tnVtypGet();

            RETRY:

                switch (vtyp)
                {
                case TYP_REF:

                    btyp = cmpActualType(type->tdRef.tdrBase);
                    if  (btyp->tdTypeKind != TYP_CLASS)
                    {
                        /* We have two choices: report an error or use the referenced value */

#if 0
                        goto CAT_ERR;
#else
                        strx = cmpCreateExprNode(NULL, TN_IND, btyp, strx, NULL);
                        goto CHK_STR;
#endif
                    }

                    type = btyp;
                    goto CLSR;

                case TYP_CLASS:

                    if  (type->tdIsManaged)
                    {
                    CLSR:
                        asym = cmpGlobalST->stLookupAllCls(cmpIdentToString,
                                                           type->tdClass.tdcSymbol,
                                                           NS_NORM,
                                                           CS_DECLSOON);
                        if  (asym)
                        {
                            asym = cmpFindOvlMatch(asym, NULL, NULL);
                            if  (asym)
                            {
                                if  (vtyp == TYP_REF)
                                    goto CALL;
                                if  (asym->sdParent != cmpClassObject)
                                    goto ADDR;

                            }
                        }

                        assert(vtyp != TYP_REF);

                        /* Box the thing and use Object.toString() on it */

                        strx = cmpCreateExprNode(NULL, TN_BOX, cmpRefTpObject, strx);
                        type = cmpClassObject->sdType;

                        goto CLST;
                    }

                    // Fall through ...

                case TYP_FNC:
                case TYP_PTR:

                CAT_ERR:

                    cmpError(ERRbadConcat, type);
                    goto NEXT;

                case TYP_ARRAY:

                    /* If the array is managed, simply call "Object.ToString" on it */

                    if  (type->tdIsManaged)
                    {
                        type = cmpRefTpObject;
                        vtyp = TYP_REF;
                        goto RETRY;
                    }

                    goto CAT_ERR;

                case TYP_ENUM:

                    cmpWarn(WRNenum2str, type);

                    type = type->tdEnum.tdeIntType;
                    vtyp = type->tdTypeKindGet();
                    goto RETRY;

                case TYP_UNDEF:
                    return  strx;
                }

                /* Bash the value to be the equivalent struct and call Object.ToString on it */

                assert(vtyp <= TYP_lastIntrins);

                /* Locate the appropriate built-in value type */

                type = cmpFindStdValType(vtyp);
                if  (!type)
                    goto CAT_ERR;

            CLST:

                asym = cmpGlobalST->stLookupClsSym(cmpIdentToString, type->tdClass.tdcSymbol);
                if  (!asym)
                    goto CAT_ERR;
                asym = cmpFindOvlMatch(asym, NULL, NULL);
                if  (!asym)
                    goto CAT_ERR;

            ADDR:

                assert(type->tdTypeKind == TYP_CLASS);

                /* Take the address of the thing so that we can call ToString() */

                if  (strx->tnOper != TN_BOX)
                {
                    strx = cmpCreateExprNode(NULL,
                                             TN_ADDROF,
                                             type->tdClass.tdcRefTyp,
                                             strx,
                                             NULL);
                }

            CALL:

                // UNDONE: Check that ToString is not static

                lstx->tnOp.tnOp1 = mksx  = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpRefTpString);
                mksx->tnFncSym.tnFncSym  = asym;
                mksx->tnFncSym.tnFncArgs = NULL;
                mksx->tnFncSym.tnFncObj  = strx;
                mksx->tnFncSym.tnFncScp  = NULL;

                if  (strx->tnOper == TN_ADDROF)
                    mksx->tnFlags |= TNF_CALL_NVIRT;
            }
        }

    NEXT:

        ccnt++;
    }
    while (temp);

    assert(ccnt > 1);

    if  (!cmpIdentConcat)
        cmpIdentConcat = cmpGlobalHT->hashString("Concat");

    /* Do we have 2-3 or more operands? */

    if  (ccnt <= 3)
    {
        ArgDscRec       args;
        TypDef          type;

        /* Just a few operands, let's call the multi-string Concat method */

        if  (ccnt == 2)
        {
            cSym = cmpConcStr2Fnc;
            if  (cSym)
                goto CALL_CTOR;

            cmpParser->parseArgListNew(args,
                                       2,
                                       false, cmpRefTpString,
                                              cmpRefTpString,
                                              NULL);
        }
        else
        {
            cSym = cmpConcStr3Fnc;
            if  (cSym)
                goto CALL_CTOR;

            cmpParser->parseArgListNew(args,
                                       3,
                                       false, cmpRefTpString,
                                              cmpRefTpString,
                                              cmpRefTpString,
                                              NULL);
        }

        /* Find the appropriate String constructor */

        type = cmpGlobalST->stNewFncType(args, cmpTypeVoid);
        cSym = cmpGlobalST->stLookupClsSym(cmpIdentConcat, cmpClassString); assert(cSym);
        cSym = cmpCurST->stFindOvlFnc(cSym, type); assert(cSym);

        if  (ccnt == 2)
            cmpConcStr2Fnc = cSym;
        else
            cmpConcStr3Fnc = cSym;

    CALL_CTOR:

        /* Create the call to the constructor */

        last = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpRefTpString);
        last->tnFncSym.tnFncSym  = cSym;
        last->tnFncSym.tnFncArgs = list;
        last->tnFncSym.tnFncObj  = NULL;
        last->tnFncSym.tnFncScp  = NULL;
    }
    else
    {
        /* Lots of operands, call the String[] operator */

        if  (!cmpConcStrAFnc)
        {
            ArgDscRec       args;
            TypDef          type;

            /* Create the type "void func(String [])" */

            if  (!cmpTypeStrArr)
            {
                DimDef          dims = cmpGlobalST->stNewDimDesc(0);

                cmpTypeStrArr = cmpGlobalST->stNewArrType(dims, true, cmpRefTpString);
            }

            cmpParser->parseArgListNew(args, 1, false, cmpTypeStrArr, NULL);

            /* Find the appropriate String constructor */

            type  = cmpGlobalST->stNewFncType(args, cmpTypeVoid);
            cSym = cmpGlobalST->stLookupClsSym(cmpIdentConcat, cmpClassString); assert(cSym);
            cSym = cmpCurST->stFindOvlFnc(cSym, type); assert(cSym);

            cmpConcStrAFnc = cSym;
        }

        /* Create the array initializer expression and pass it to the ctor */

        list = cmpCreateExprNode(NULL,
                                 TN_ARR_INIT,
                                 cmpTypeStrArr,
                                 list,
                                 cmpCreateIconNode(NULL, ccnt, TYP_UINT));

        list = cmpCreateExprNode(NULL, TN_NEW , cmpTypeStrArr, list);
        list = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid  , list);

        last = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpRefTpString);
        last->tnFncSym.tnFncSym  = cmpConcStrAFnc;
        last->tnFncSym.tnFncArgs = list;
        last->tnFncSym.tnFncObj  = NULL;
        last->tnFncSym.tnFncScp  = NULL;
    }

    assert(last->tnOper == TN_FNC_SYM);

    /* Mark the call if this is an assignment operator */

    if  (asgOp)
        last->tnFlags |= TNF_CALL_STRCAT;

    /* Wrap the ctor call in a "new" node and we're done */

    return  last;
}

/*****************************************************************************
 *
 *  Bind a ?: expression.
 */

Tree                compiler::cmpBindQmarkExpr(Tree expr)
{
    Tree            op1;
    Tree            op2;

    var_types       tp1;
    var_types       tp2;

    var_types       bt1;
    var_types       bt2;

    /* The parser should make sure that the ":" operator is present */

    assert(expr->tnOper == TN_QMARK);
    assert(expr->tnOp.tnOp2->tnOper == TN_COLON);

    /* Bind the condition */

    expr->tnOp.tnOp1 = cmpBindCondition(expr->tnOp.tnOp1);

    /* Get hold of the two ":" values */

    op1 = expr->tnOp.tnOp2->tnOp.tnOp1;
    op2 = expr->tnOp.tnOp2->tnOp.tnOp2;

    /* Special case: is either operand a string constant? */

    if      (op1->tnOper == TN_CNS_STR && !(op1->tnFlags & TNF_BEEN_CAST))
    {
        if      (op2->tnOper == TN_CNS_STR && !(op2->tnFlags & TNF_BEEN_CAST))
        {

#if 0

            if  (op1->tnType == op2->tnType)
            {
                expr->tnType = op1->tnType;
                expr->tnVtyp = op1->tnVtyp;

                return  expr;
            }

#endif

            op1 = cmpBindExpr(op1);
            op2 = cmpBindExpr(op2);
        }
        else
        {
            op2 = cmpBindExpr(op2);
            op1 = cmpParser->parseCreateOperNode(TN_CAST, op1, NULL);
            op1->tnType = op2->tnType;
            op1 = cmpBindExpr(op1);
        }
    }
    else if (op2->tnOper == TN_CNS_STR && !(op2->tnFlags & TNF_BEEN_CAST))
    {
        op1 = cmpBindExpr(op1);
        op2 = cmpParser->parseCreateOperNode(TN_CAST, op2, NULL);
        op2->tnType = op1->tnType;
        op2 = cmpBindExpr(op2);
    }
    else
    {
        op1 = cmpBindExpr(op1);
        op2 = cmpBindExpr(op2);
    }

    /* Now see what the types of the operands are */

    tp1 = op1->tnVtypGet(); assert(tp1 != TYP_TYPEDEF);
    tp2 = op2->tnVtypGet(); assert(tp2 != TYP_TYPEDEF);

    /* The operands may be arithmetic */

    if  (varTypeIsArithmetic(tp1) &&
         varTypeIsArithmetic(tp2))
    {
        /* Shrink numeric constants if types are unequal */

        if  (tp1 != tp2)
        {
            op1 = cmpShrinkExpr(op1); tp1 = op1->tnVtypGet();
            op2 = cmpShrinkExpr(op2); tp2 = op2->tnVtypGet();
        }

    PROMOTE:

        /* Promote both operands to the 'bigger' type */

        if      (tp1 < tp2)
        {
            op1 = cmpCoerceExpr(op1, op2->tnType, false);
        }
        else if (tp1 > tp2)
        {
            op2 = cmpCoerceExpr(op2, op1->tnType, false);
        }

        goto GOT_QM;
    }

    /* The operands can be pointers/refs */

    if  ((tp1 == TYP_REF || tp1 == TYP_PTR) &&
         (tp2 == TYP_REF || tp2 == TYP_PTR))
    {
        /* It's perfectly fine if one of the operands is "null" */

        if      (op2->tnOper == TN_NULL)
        {
            op2 = cmpCoerceExpr(op2, op1->tnType, false);
            goto GOT_QM;
        }
        else if (op1->tnOper == TN_NULL)
        {
            op1 = cmpCoerceExpr(op1, op2->tnType, false);
            goto GOT_QM;
        }

        /* Are both things of the same flavor? */

        if  (tp1 == tp2)
        {
            if  (cmpConvergeValues(op1, op2))
                goto GOT_QM;
        }
        else
        {
            /* Special case: string literals can become "char *" */

            if  (tp1 == TYP_PTR && tp2 == TYP_REF)
            {
                if  (cmpMakeRawString(op2, op1->tnType))
                    goto GOT_QM;
            }
            else
            {
                if  (cmpMakeRawString(op1, op2->tnType))
                    goto GOT_QM;
            }
        }
    }

    /* Both operands can be arrays */

    if  (tp1 == TYP_ARRAY)
    {
        if  (cmpIsObjectVal(op2))
        {
            if  (op2->tnOper == TN_NULL)
                op2 = cmpCoerceExpr(op2, op1->tnType, false);
            else
                op1 = cmpCoerceExpr(op1, op2->tnType, false);

            goto GOT_QM;
        }

        if  (tp2 == TYP_ARRAY)
        {
            // UNDONE: compare array types!
        }
    }

    if  (tp2 == TYP_ARRAY)
    {
        if  (cmpIsObjectVal(op1))
        {
            if  (op1->tnOper == TN_NULL)
                op1 = cmpCoerceExpr(op1, op2->tnType, false);
            else
                op2 = cmpCoerceExpr(op2, op1->tnType, false);

            goto GOT_QM;
        }
    }

    /* If both operands have identical type, it's easy */

    if  (tp1 == tp2 && symTab::stMatchTypes(op1->tnType, op2->tnType))
        goto GOT_QM;

    /* We could also have enums, of course */

    if      (tp1 == TYP_ENUM)
    {
        TypDef          typ;

        /* Are both of these enums? */

        if  (tp2 == TYP_ENUM)
        {
            bt2 = cmpActualVtyp(op2->tnType);
        }
        else
        {
            if  (!varTypeIsArithmetic(tp2))
                goto ENUMN;

            bt2 = tp2;
        }

        bt1 = cmpActualVtyp(op1->tnType);

    ENUMP:

        /* Promote to whichever is the larger type, or int */

        assert(bt1 != TYP_ENUM);
        assert(bt2 != TYP_ENUM);

        if  (bt1 < bt2)
             bt1 = bt2;
        if  (bt1 < TYP_INT)
             bt1 = TYP_INT;

        typ = cmpGlobalST->stIntrinsicType(bt1);

        op1 = cmpCoerceExpr(op1, typ, false);
        op2 = cmpCoerceExpr(op2, typ, false);

        goto GOT_QM;
    }
    else if (tp2 == TYP_ENUM)
    {
        if  (varTypeIsArithmetic(tp1))
        {
            bt1 = tp1;
            bt2 = cmpActualVtyp(op2->tnType);

            goto ENUMP;
        }
    }

ENUMN:

    /* Mixing bools/wchars and arithmetic types is OK as well */

    if  (varTypeIsArithmetic(tp1) && (tp2 == TYP_BOOL || tp2 == TYP_WCHAR))
        goto PROMOTE;
    if  (varTypeIsArithmetic(tp2) && (tp1 == TYP_BOOL || tp1 == TYP_WCHAR))
        goto PROMOTE;

    /* There are no more legal ":" operand types */

    cmpRecErrorPos(expr);

    if  (tp1 != TYP_UNDEF && tp2 != TYP_UNDEF)
        cmpError(ERRoperType2, cmpGlobalHT->tokenToIdent(tkQMark), op1->tnType, op2->tnType);

    return cmpCreateErrNode();

GOT_QM:

    /* Everything's fine, create the ":" node */

    assert(symTab::stMatchTypes(op1->tnType, op2->tnType));

    expr->tnOp.tnOp2 = cmpCreateExprNode(expr->tnOp.tnOp2,
                                         TN_COLON,
                                         op1->tnType,
                                         op1,
                                         op2);

    /* The result is the type of (both of) the operands */

    expr->tnVtyp = op1->tnVtyp;
    expr->tnType = op1->tnType;

    return  expr;
}

/*****************************************************************************
 *
 *  Given an expression and a type (at least one of which is known to be
 *  a value type) see if there is an overloaded conversion operator that
 *  can convert the expression to the target type. If the conversion is
 *  not possible, NULL is returned. Otherwise, if 'origTP' on entry is
 *  non-NULL, a converted expression is converted, else the expression
 *  is returned untouched (this way the routine can be called just to
 *  see if the given conversion is possible).
 */

Tree                compiler::cmpCheckConvOper(Tree      expr,
                                               TypDef  origTP,
                                               TypDef dstType,
                                               bool   expConv, unsigned *costPtr)
{
    TypDef          srcType;

    var_types       srcVtyp;
    var_types       dstVtyp;

    SymDef          opSrcExp, opSrcImp;
    SymDef          opDstExp, opDstImp;

    unsigned        lowCost;
    SymDef          bestOp1;
    SymDef          bestOp2;

    /* Get hold of the source type */

    srcType = origTP;
    if  (!srcType)
    {
        assert(expr);

        srcType = expr->tnType;

        if  (srcType->tdTypeKind == TYP_TYPEDEF)
             srcType = srcType->tdTypedef.tdtType;
    }

    /* Make sure the destination type is the real thing */

    dstType = cmpDirectType(dstType);

    /* Either one or both of the types must be value types */

    srcVtyp = srcType->tdTypeKindGet();
    dstVtyp = dstType->tdTypeKindGet();

    assert(srcVtyp == TYP_CLASS || dstVtyp == TYP_CLASS);

    /* Find all the operators that might apply to this conversion */

    opSrcImp =
    opDstImp =
    opSrcExp =
    opDstExp = NULL;

    if  (srcVtyp == TYP_CLASS)
    {
        SymDef          srcCls = srcType->tdClass.tdcSymbol;

        opSrcImp = cmpGlobalST->stLookupOper(OVOP_CONV_IMP, srcCls);
        if  (expConv)
        opSrcExp = cmpGlobalST->stLookupOper(OVOP_CONV_EXP, srcCls);
    }

    if  (dstVtyp == TYP_CLASS)
    {
        SymDef          dstCls = dstType->tdClass.tdcSymbol;

        opDstImp = cmpGlobalST->stLookupOper(OVOP_CONV_IMP, dstCls);
        if  (expConv)
        opDstExp = cmpGlobalST->stLookupOper(OVOP_CONV_EXP, dstCls);
    }

#if 0

    printf("\nCheck user-defined conversion operator:\n");

    printf("   Src type = '%s'\n", cmpGlobalST->stTypeName(srcType, NULL, NULL, NULL, false));
    printf("   Dst type = '%s'\n", cmpGlobalST->stTypeName(dstType, NULL, NULL, NULL, false));

    printf("\n");

    if  (opSrcImp)
    {
        SymDef          sym;
        printf("opSrcImp:\n");
        for (sym = opSrcImp; sym; sym = sym->sdFnc.sdfNextOvl)
            printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
        printf("\n");
    }

    if  (opSrcExp)
    {
        SymDef          sym;
        printf("opSrcExp:\n");
        for (sym = opSrcExp; sym; sym = sym->sdFnc.sdfNextOvl)
            printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
        printf("\n");
    }

    if  (opDstImp)
    {
        SymDef          sym;
        printf("opDstImp:\n");
        for (sym = opDstImp; sym; sym = sym->sdFnc.sdfNextOvl)
            printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
        printf("\n");
    }

    if  (opDstExp)
    {
        SymDef          sym;
        printf("opDstExp:\n");
        for (sym = opDstExp; sym; sym = sym->sdFnc.sdfNextOvl)
            printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
        printf("\n");
    }

#endif

    /* Check all of the possible operators, looking for the best match */

    bestOp1 =
    bestOp2 = NULL;
    lowCost = 99999;

    if  (opSrcImp) lowCost = cmpMeasureConv(expr, dstType, lowCost, opSrcImp, &bestOp1, &bestOp2);
    if  (opDstImp) lowCost = cmpMeasureConv(expr, dstType, lowCost, opDstImp, &bestOp1, &bestOp2);
    if  (opSrcExp) lowCost = cmpMeasureConv(expr, dstType, lowCost, opSrcExp, &bestOp1, &bestOp2);
    if  (opDstExp) lowCost = cmpMeasureConv(expr, dstType, lowCost, opDstExp, &bestOp1, &bestOp2);

    /* If no conversion at all worked, return NULL */

    if  (bestOp1 == NULL)
    {
        assert(bestOp2 == NULL);
        return  NULL;
    }

    /* Is a simple boxing operation better than the best we've found? */

    if  (lowCost > 10 && dstType == cmpRefTpObject)
        return  cmpCreateExprNode(NULL, TN_BOX, dstType, expr);

    /* Did we end up with a clear winner? */

    if  (bestOp2 != NULL)
    {
        if  (origTP)
            return  NULL;

        cmpErrorQSS(ERRambigCall, bestOp1, bestOp2);
        return cmpCreateErrNode();
    }

    /* We have a single best match in "bestOp1" - are we supposed to call it? */

    if  (origTP == NULL)
    {
        ArgDef          argList;
        Tree            argExpr;

        assert(bestOp1->sdType->tdTypeKind == TYP_FNC);

//      printf("Calling conversion operator:\n\t%s\n", cmpGlobalST->stTypeName(bestOp1->sdType, bestOp1, NULL, NULL, true));

        /* Has the function been marked as "deprecated" ? */

        if  (bestOp1->sdIsDeprecated || bestOp1->sdParent->sdIsDeprecated)
        {
            if  (bestOp1->sdIsImport)
            {
                if  (bestOp1->sdIsDeprecated)
                    cmpObsoleteUse(bestOp1          , WRNdepCall);
                else
                    cmpObsoleteUse(bestOp1->sdParent, WRNdepCls);
            }
        }

        /* Get hold of the conversion's source and target type */

        argList = bestOp1->sdType->tdFnc.tdfArgs.adArgs;

        /* There should be exactly one parameter */

        assert(argList && argList->adNext == NULL);

        /* Coerce the expression to the argument type */

        argExpr = cmpCoerceExpr(expr, argList->adType, true);
        argExpr = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argExpr, NULL);

        /* Create the operator function call node */

        expr = cmpCreateExprNode(NULL, TN_FNC_SYM, bestOp1->sdType->tdFnc.tdfRett);
        expr->tnFncSym.tnFncSym  = bestOp1;
        expr->tnFncSym.tnFncArgs = argExpr;
        expr->tnFncSym.tnFncObj  = NULL;
        expr->tnFncSym.tnFncScp  = NULL;

        /* Finally, convert the result of the conversion to the target type */

        expr = cmpCoerceExpr(expr, dstType, true);
    }

    if  (costPtr) *costPtr = lowCost;

    return  expr;
}
/*****************************************************************************
 *
 *  Given an expression with at least one operator of type 'struct', see if
 *  there is an overloaded operator defined that can be called. Returns NULL
 *  if no luck, otherwise returns an expression that will yield the operator
 *  call.
 */

Tree                compiler::cmpCheckOvlOper(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    TypDef          op1Type;
    TypDef          op2Type;

    SymDef          op1Oper;
    SymDef          op2Oper;

    treeOps         oper;
    tokens          optok;
    ovlOpFlavors    opovl;

    Tree            arg1;
    Tree            arg2;
    Tree            call;

    /* Check to make sure the operator is overloadable */

    oper  = expr->tnOperGet();
    optok = treeOp2token(oper);
    opovl = cmpGlobalST->stOvlOperIndex(optok, (op2 != NULL) ? 2 : 1);
    if  (opovl == OVOP_NONE)
        return  NULL;

    /* Get hold of the two operand types */

    op1Type =       cmpDirectType(op1->tnType);
    op2Type = op2 ? cmpDirectType(op2->tnType) : cmpTypeVoid;

    /* Find all the operators that might apply to this operator */

    op1Oper =
    op2Oper = NULL;

    switch (op1Type->tdTypeKind)
    {
    case TYP_REF:
        op1Type = op1Type->tdRef.tdrBase;
        if  (op1Type->tdTypeKind != TYP_CLASS)
            break;

        // Fall through ...

    case TYP_CLASS:
        op1Oper = cmpGlobalST->stLookupOper(opovl, op1Type->tdClass.tdcSymbol);
        break;
    }

    switch (op2Type->tdTypeKind)
    {
    case TYP_REF:
        op2Type = op2Type->tdRef.tdrBase;
        if  (op2Type->tdTypeKind != TYP_CLASS)
            break;

        // Fall through ...

    case TYP_CLASS:
        op2Oper = cmpGlobalST->stLookupOper(opovl, op2Type->tdClass.tdcSymbol);
        break;
    }

    if  (op1Oper == NULL && op2Oper == NULL)
        return  NULL;

    if  (op2Oper == op1Oper)
         op2Oper = NULL;

#if 0

    printf("\nCheck user-defined overloaded operator:\n");

    printf("   op1 type = '%s'\n", cmpGlobalST->stTypeName(op1Type, NULL, NULL, NULL, false));
    printf("   op2 type = '%s'\n", cmpGlobalST->stTypeName(op2Type, NULL, NULL, NULL, false));

    printf("\n");

    if  (op1Oper)
    {
        SymDef          sym;
        printf("op1Oper:\n");
        for (sym = op1Oper; sym; sym = sym->sdFnc.sdfNextOvl)
            printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
        printf("\n");
    }

    if  (op2Oper)
    {
        SymDef          sym;
        printf("op2Oper:\n");
        for (sym = op2Oper; sym; sym = sym->sdFnc.sdfNextOvl)
            printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
        printf("\n");
    }

#endif

    /* Create an argument list tree so that we can try to bind the call */

    arg2 = op2 ? cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, op2, NULL) : NULL;
    arg1 =       cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, op1, arg2);

    call = cmpCreateExprNode(expr, TN_FNC_SYM, cmpTypeVoid);
    call->tnFlags |= TNF_CALL_CHKOVL;

    call->tnFncSym.tnFncArgs = arg1;
    call->tnFncSym.tnFncObj  = NULL;
    call->tnFncSym.tnFncScp  = NULL;

    if  (op1Oper)
    {
        if  (op2Oper)
        {
            UNIMPL(!"NYI: two sets of overloaded operators to consider");
        }
        else
            call->tnFncSym.tnFncSym  = op1Oper;
    }
    else
        call->tnFncSym.tnFncSym  = op2Oper;

    call = cmpCheckFuncCall(call);

    /* Increment/decrement operators require special handling */

    switch (oper)
    {
    case TN_INC_PRE:
    case TN_DEC_PRE:

        call->tnFlags |= TNF_CALL_ASGPRE;

    case TN_INC_POST:
    case TN_DEC_POST:

        call->tnFlags |= TNF_CALL_ASGOP;
        break;
    }

    return  call;
}

/*****************************************************************************
 *
 *  Compute the cost of converting the expression 'srcExpr' to the type given
 *  by 'dstType'. If this cost is lower than lowCost, return the new lowest
 *  cost and update *bestCn1 (or *bestCnv2 if the cost is the same).
 */

unsigned            compiler::cmpMeasureConv(Tree       srcExpr,
                                             TypDef     dstType,
                                             unsigned   lowCost,
                                             SymDef     convSym,
                                             SymDef   * bestCnv1,
                                             SymDef   * bestCnv2)
{
    int             cnvCost1;
    int             cnvCost2;
    unsigned        cnvCost;

    ArgDef          argList;

#ifdef  SHOW_OVRS_OF_CONVS
    printf("Source typ: %s\n", cmpGlobalST->stTypeName(srcExpr->tnType, NULL, NULL, NULL, false));
#endif

    do
    {
        assert(convSym->sdType->tdTypeKind == TYP_FNC);

        /* Get hold of the conversion's source and target type */

        argList = convSym->sdType->tdFnc.tdfArgs.adArgs;

        /* There should be exactly one parameter */

        assert(argList && argList->adNext == NULL);

#ifdef  SHOW_OVRS_OF_CONVS
        printf("\nConsider '%s':\n", cmpGlobalST->stTypeName(convSym->sdType, convSym, NULL, NULL, false));
//      printf("    Formal: %s\n", cmpGlobalST->stTypeName(argList->adType, NULL, NULL, NULL, false));
#endif

        /* Compute the cost of converting to the argument type */

        cnvCost1 = cmpConversionCost(srcExpr, argList->adType, true);
        if  (cnvCost1 < 0)
            goto NEXT;

#ifdef  SHOW_OVRS_OF_CONVS
        printf("    Cost 1: %d\n", cnvCost1);
#endif

        /* Add the cost of converting the return value to the target type */

        cmpConvOperExpr->tnType = convSym->sdType->tdFnc.tdfRett;
        cmpConvOperExpr->tnVtyp = cmpConvOperExpr->tnType->tdTypeKindGet();

        cnvCost2 = cmpConversionCost(cmpConvOperExpr, dstType, true);

#ifdef  SHOW_OVRS_OF_CONVS
        printf("    Cost 2: %d\n", cnvCost2);
#endif

        if  (cnvCost2 < 0)
            goto NEXT;

        /* The total cost is the sum of both costs, see if it's a new low */

        cnvCost  = cnvCost1 + cnvCost2 + 10;

//      printf("    Cost = %2u for %s\n", cnvCost, cmpGlobalST->stTypeName(convSym->sdType, convSym, NULL, NULL, true));

        if  (cnvCost < lowCost)
        {
            /* We have a new champion! */

            *bestCnv1 = convSym;
            *bestCnv2 = NULL;

            lowCost = cnvCost;
            goto NEXT;
        }

        /* It could be a draw */

        if  (lowCost == cnvCost)
        {
            assert(*bestCnv1);

            /* Remember the first two operators at this cost */

            if  (*bestCnv2 == NULL)
                 *bestCnv2  = convSym;
        }

    NEXT:

        convSym = convSym->sdFnc.sdfNextOvl;
    }
    while (convSym);

#ifdef  SHOW_OVRS_OF_CONVS
    if  (*bestCnv1) printf("\nChose '%s'\n", cmpGlobalST->stTypeName((*bestCnv1)->sdType, *bestCnv1, NULL, NULL, false));
#endif

    return  lowCost;
}

/*****************************************************************************
 *
 *  Two expressions - at least one of which is a struct - are being compared,
 *  see if this is legal. If so, return an expression that will compute the
 *  result of the comparison, otherwise return NULL.
 */

Tree                compiler::cmpCompareValues(Tree expr, Tree op1, Tree op2)
{
    Tree            call;

    TypDef          op1Type = op1->tnType;
    TypDef          op2Type = op2->tnType;

    SymDef          op1Conv;
    SymDef          op2Conv;

    treeOps         relOper  = expr->tnOperGet();

    ovlOpFlavors    ovlOper  = cmpGlobalST->stOvlOperIndex(treeOp2token(relOper), 2);

    bool            equality = (relOper == TN_EQ || relOper == TN_NE);

    /* Find all the operators that might be used for the comparison */

    if  (op1Type->tdTypeKind == TYP_CLASS &&
         op1Type->tdClass.tdcValueType)
    {
        SymDef          op1Cls = op1Type->tdClass.tdcSymbol;

        /* First look for an exact match on C++ style operator */

        op1Conv = cmpGlobalST->stLookupOper(ovlOper, op1Cls);
        if  (op1Conv)
            goto DONE_OP1;

        /* If we're testing equality, give preference to operator equals */

        if  (equality)
        {
            op1Conv = cmpGlobalST->stLookupOper(OVOP_EQUALS, op1Cls);
            if  (op1Conv)
                goto DONE_OP1;
        }

        op1Conv = cmpGlobalST->stLookupOper(OVOP_COMPARE, op1Cls);
    }
    else
        op1Conv = NULL;

DONE_OP1:

    if  (op2Type->tdTypeKind == TYP_CLASS &&
         op2Type->tdClass.tdcValueType    && op1Type != op2Type)
    {
        SymDef          op2Cls = op2Type->tdClass.tdcSymbol;

        /* First look for an exact match on C++ style operator */

        op2Conv = cmpGlobalST->stLookupOper(ovlOper, op2Cls);
        if  (op2Conv)
            goto DONE_OP1;

        /* If we're testing equality, give preference to operator equals */

        if  (equality)
        {
            op2Conv = cmpGlobalST->stLookupOper(OVOP_EQUALS, op2Cls);
            if  (op2Conv)
                goto DONE_OP2;
        }

        op2Conv = cmpGlobalST->stLookupOper(OVOP_COMPARE, op2Cls);
    }
    else
        op2Conv = NULL;

DONE_OP2:

#if     0
#ifdef  DEBUG

    if  (!strcmp(cmpCurFncSym->sdSpelling(), "<put method name here"))
    {
        printf("\nCheck user-defined comparison operator:\n");

        printf("   Op1 type = '%s'\n", cmpGlobalST->stTypeName(op1->tnType, NULL, NULL, NULL, false));
        printf("   Op2 type = '%s'\n", cmpGlobalST->stTypeName(op2->tnType, NULL, NULL, NULL, false));

        printf("\n");

        if  (op1Conv)
        {
            SymDef          sym;
            printf("op1Conv:\n");
            for (sym = op1Conv; sym; sym = sym->sdFnc.sdfNextOvl)
                printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
            printf("\n");
        }

        if  (op2Conv)
        {
            SymDef          sym;
            printf("op2Conv:\n");
            for (sym = op2Conv; sym; sym = sym->sdFnc.sdfNextOvl)
                printf("    %s\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
            printf("\n");
        }
    }

#endif
#endif

    /* See if we can pick an operator to call */

    cmpCompOperCall->tnOper = TN_LIST;

    if  (op1Conv)
    {
        if  (op2Conv)
        {
            cmpCompOperFunc->tnOp.tnOp1 = cmpCompOperFnc1;
            cmpCompOperFunc->tnOp.tnOp2 = cmpCompOperFnc2;

            cmpCompOperCall->tnOp.tnOp1 = cmpCompOperFunc;
        }
        else
            cmpCompOperCall->tnOp.tnOp1 = cmpCompOperFnc1;
    }
    else
    {
        if  (op2Conv == NULL)
            return  NULL;

        cmpCompOperCall->tnOp.tnOp1 = cmpCompOperFnc2;
    }

    /* Fill in the node to hold the arguments and conversion operator(s) */

    cmpCompOperArg1->tnOp.tnOp1         = op1;
    cmpCompOperArg1->tnOp.tnOp2         = cmpCompOperArg2;  // CONSIDER: do only once
    cmpCompOperArg2->tnOp.tnOp1         = op2;
    cmpCompOperArg2->tnOp.tnOp2         = NULL;             // CONSIDER: do only once

    cmpCompOperFnc1->tnFncSym.tnFncSym  = op1Conv;
    cmpCompOperFnc1->tnFncSym.tnFncArgs = cmpCompOperArg1;
    cmpCompOperFnc1->tnFncSym.tnFncObj  = NULL;
    cmpCompOperFnc1->tnFncSym.tnFncScp  = NULL;

    cmpCompOperFnc2->tnFncSym.tnFncSym  = op2Conv;
    cmpCompOperFnc2->tnFncSym.tnFncArgs = cmpCompOperArg1;
    cmpCompOperFnc2->tnFncSym.tnFncObj  = NULL;
    cmpCompOperFnc2->tnFncSym.tnFncScp  = NULL;

    cmpCompOperCall->tnOp.tnOp2         = cmpCompOperArg1;  // CONSIDER: do only once

    call = cmpCheckFuncCall(cmpCompOperCall);

    if  (call && call->tnOper != TN_ERROR)
    {
        SymDef          fncSym;

        Tree            arg1;
        Tree            arg2;

        /* Success - get hold of the chosen operator method */

        assert(call->tnOper == TN_FNC_SYM);
        fncSym = call->tnFncSym.tnFncSym;
        assert(fncSym->sdSymKind == SYM_FNC);
        assert(fncSym->sdFnc.sdfOper == OVOP_EQUALS  ||
               fncSym->sdFnc.sdfOper == OVOP_COMPARE ||
               fncSym->sdFnc.sdfOper == ovlOper);

        /* Create a bona fide function call tree */

        arg1 = cmpCreateExprNode(NULL, TN_LIST   , cmpTypeVoid, cmpCompOperArg2->tnOp.tnOp1, NULL);
        arg2 = cmpCreateExprNode(NULL, TN_LIST   , cmpTypeVoid, cmpCompOperArg1->tnOp.tnOp1, arg1);
        call = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpDirectType(fncSym->sdType->tdFnc.tdfRett));
        call->tnFncSym.tnFncSym  = fncSym;
        call->tnFncSym.tnFncArgs = arg2;
        call->tnFncSym.tnFncObj  = NULL;
        call->tnFncSym.tnFncScp  = NULL;

        /* Did we end up using operator equals or compare ? */

        if  (fncSym->sdFnc.sdfOper == OVOP_EQUALS)
        {
            assert(call->tnVtyp == TYP_BOOL);

            /* Compute the result */

            return  cmpCreateExprNode(NULL,
                                      (expr->tnOper == TN_EQ) ? TN_NE : TN_EQ,
                                      cmpTypeBool,
                                      call,
                                      cmpCreateIconNode(NULL, 0, TYP_BOOL));
        }

        if  (fncSym->sdFnc.sdfOper == ovlOper)
        {
            return  cmpBooleanize(call, true);
        }
        else
        {
            assert(fncSym->sdFnc.sdfOper == OVOP_COMPARE);

            assert(call->tnVtyp == TYP_BOOL ||
                   call->tnVtyp == TYP_INT);
        }

        call = cmpCreateExprNode(NULL,
                                 relOper,
                                 cmpTypeBool,
                                 call,
                                 cmpCreateIconNode(NULL, 0, TYP_INT));
    }

    return  call;
}

/*****************************************************************************
 *
 *  Return an expression that will yield the typeinfo instance for the given
 *  type:
 *
 *          System.Type::GetTypeFromHandle(tokenof(type))
 */

Tree                compiler::cmpTypeIDinst(TypDef type)
{
    Tree            expr;
    Tree            func;

    assert(type && type->tdIsManaged);

    /* Call "GetTypeFromHandle" passing it a token for the type */

    expr = cmpParser->parseCreateOperNode(TN_NOP  , NULL, NULL);
    expr->tnType = cmpDirectType(type);
    expr->tnVtyp = expr->tnType->tdTypeKindGet();

    expr = cmpParser->parseCreateOperNode(TN_TOKEN, expr, NULL);
    expr = cmpParser->parseCreateOperNode(TN_LIST , expr, NULL);
    func = cmpParser->parseCreateUSymNode(cmpFNsymGetTPHget());
    expr = cmpParser->parseCreateOperNode(TN_CALL , func, expr);

    /* Bind the expression and return it */

    return  cmpBindExpr(expr);
}

/*****************************************************************************
 *
 *  Given a property accessor method, find the corresponding property field
 *  and set *isSetPtr to true if the accessor is a "setter". Returns NULL if
 *  the property field can't be found.
 */

SymDef              compiler::cmpFindPropertyDM(SymDef accSym, bool *isSetPtr)
{
    const   char *  fnam;
    SymDef          sym;

    assert(accSym);
    assert(accSym->sdSymKind == SYM_FNC);
    assert(accSym->sdFnc.sdfProperty);

    fnam = accSym->sdSpelling();

    if      (!memcmp(fnam, "get_", 4))
    {
        *isSetPtr = false;
    }
    else if (!memcmp(fnam, "set_", 4))
    {
        *isSetPtr = true;
    }
    else
        return  NULL;

    sym = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString(fnam+4), accSym->sdParent);

    while (sym)
    {
        if  (sym->sdProp.sdpGetMeth == accSym)
        {
            assert(*isSetPtr == false);
            return  sym;
        }

        if  (sym->sdProp.sdpSetMeth == accSym)
        {
            assert(*isSetPtr ==  true);
            return  sym;
        }

        sym = sym->sdProp.sdpNextOvl;
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Given a non-empty function argument list, append the given argument(s) to
 *  the end of the list.
 */

Tree                compiler::cmpAppend2argList(Tree args, Tree addx)
{
    Tree            temp;

    assert(args && args->tnOper == TN_LIST);
    assert(addx);

    /* Some callers don't wrap a single argument value, we do it for them */

    if  (addx->tnOper != TN_LIST)
        addx = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, addx, NULL);

    /* Find the end of the argument list and attach the new addition */

    for (temp = args; temp->tnOp.tnOp2; temp = temp->tnOp.tnOp2)
    {
        assert(temp && temp->tnOper == TN_LIST);
    }

    temp->tnOp.tnOp2 = addx;

    return  args;
}

/*****************************************************************************
 *
 *  Bind a property reference. If 'args' is non-NULL, this is an indexed
 *  property reference. If 'asgx' is non-NULL, the property is a target
 *  of an assignment.
 */

Tree                compiler::cmpBindProperty(Tree      expr,
                                              Tree      args,
                                              Tree      asgx)
{
    Tree            call;

    bool            found;
    SymDef          propSym;
    SymDef          funcSym;
    TypDef          propType;

    assert(expr->tnOper == TN_PROPERTY);
    propSym = expr->tnVarSym.tnVarSym;
    assert(propSym->sdSymKind == SYM_PROP);

    /* If have an assignment, wrap its RHS as an argument node */

    if  (asgx)
    {
        assert(asgx->tnOper != TN_LIST);

        asgx = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, asgx, NULL);
    }

    /* Is this a call or a "simple" reference? */

    if  (args)
    {
        if  (args->tnOper != TN_LIST)
            args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, args, NULL);

        if  (asgx)
        {
            /* Append the RHS of the assignment to the argument list */

            args = cmpAppend2argList(args, asgx);
        }
    }
    else
    {
        args = asgx;
    }

    /* Find the appropriate method */

    found   = false;
    funcSym = cmpFindPropertyFN(propSym->sdParent, propSym->sdName, args, !asgx, &found);

    if  (!funcSym)
    {
        Ident           propName = asgx ? cmpIdentSet : cmpIdentGet;

        if  (found)
        {
            cmpError(ERRnoPropOvl, propSym->sdParent->sdName, propName, propSym->sdName);
        }
        else
        {
            cmpError(ERRnoPropSym, propSym->sdParent->sdName, propName, propSym->sdName);
        }

        return cmpCreateErrNode();
    }

    // UNDONE: Need to check whether the property is static, etc!

    /* Figure out the resulting type */

    propType = propSym->sdType;
    if  (propType->tdTypeKind == TYP_FNC)
        propType = propType->tdFnc.tdfRett;

    /* Create a call to the appropriate property accessor */

    call = cmpCreateExprNode(NULL, TN_FNC_SYM, propType);
    call->tnFncSym.tnFncSym  = funcSym;
    call->tnFncSym.tnFncArgs = args;
    call->tnFncSym.tnFncObj  = expr->tnVarSym.tnVarObj;
    call->tnFncSym.tnFncScp  = NULL;

    call = cmpCheckFuncCall(call);

    /* Is the call supposed to be non-virtual? */

    if  (expr->tnVarSym.tnVarObj &&
         expr->tnVarSym.tnVarObj->tnOper == TN_LCL_SYM)
    {
        if  (expr->tnVarSym.tnVarObj->tnFlags & TNF_LCL_BASE)
            call->tnFlags |= TNF_CALL_NVIRT;
    }

    return  call;
}

/*****************************************************************************
 *
 *  Bind a use of the "va_start" or "va_arg" intrinsic.
 */

Tree                compiler::cmpBindVarArgUse(Tree call)
{
    SymDef          fsym;

    Tree            arg1;
    Tree            arg2;

    SymDef          meth;

    Tree            expr;

    assert(call->tnOper == TN_FNC_SYM);
    fsym = call->tnFncSym.tnFncSym;

    /* Is this "va_start" ? */

    if  (fsym == cmpFNsymVAbeg)
    {
        /* Make sure we are within a varargs function */

        if  (!cmpCurFncSym || !cmpCurFncSym->sdType->tdFnc.tdfArgs.adVarArgs)
        {
            cmpError(ERRbadVarArg);
            return cmpCreateErrNode();
        }
    }
    else
    {
        assert(fsym == cmpFNsymVAget);
    }

    /* There must be two arguments */

    arg1 = call->tnFncSym.tnFncArgs;

    if  (!arg1 || !arg1->tnOp.tnOp2)
    {
        cmpError(ERRmisgArg, fsym);
        return cmpCreateErrNode();
    }

    assert(arg1->tnOper == TN_LIST);
    arg2 = arg1->tnOp.tnOp2;
    assert(arg2->tnOper == TN_LIST);

    if  (arg2->tnOp.tnOp2)
    {
        cmpError(ERRmanyArg, fsym);
        return cmpCreateErrNode();
    }

    arg1 = arg1->tnOp.tnOp1;
    arg2 = arg2->tnOp.tnOp1;

    /* The first argument must be a local of type 'ArgIterator' */

    cmpFindArgIterType();

    if  ((arg1->tnOper != TN_LCL_SYM   ) ||
         (arg1->tnFlags & TNF_BEEN_CAST) || !symTab::stMatchTypes(arg1->tnType,
                                                                  cmpClassArgIter->sdType))
    {
        cmpError(ERRnotArgIter);
        return cmpCreateErrNode();
    }

    /* Is this va_start or va_arg ? */

    if  (fsym == cmpFNsymVAbeg)
    {
        /* The second argument must be the function's last argument */

        if  ((arg2->tnOper != TN_LCL_SYM   ) ||
             (arg2->tnFlags & TNF_BEEN_CAST) ||
             !arg2->tnLclSym.tnLclSym->sdVar.sdvArgument)
        {
            cmpError(ERRnotLastArg);
            return cmpCreateErrNode();
        }

        /* Find the proper ArgIterator constructor */

        meth = cmpCtorArgIter;
        if  (!meth)
        {
            SymDef          rtah;
            ArgDscRec       args;
            TypDef          type;

            /* Find the "RuntimeArgumentHandle" type */

            rtah = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("RuntimeArgumentHandle"),
                                               NS_NORM,
                                               cmpNmSpcSystem);

            if  (!rtah || rtah->sdSymKind         != SYM_CLASS
                       || rtah->sdClass.sdcFlavor != STF_STRUCT)
            {
                cmpGenFatal(ERRbltinTp, "System::RuntimeArgumentHandle");
            }

            /* Create the appropriate argument list */

            cmpParser->parseArgListNew(args,
                                       2,
                                       false, rtah->sdType,
                                              cmpGlobalST->stNewRefType(TYP_PTR, cmpTypeVoid),
                                              NULL);

            /* Create the type and look for a matching constructor */

            type = cmpGlobalST->stNewFncType(args, cmpTypeVoid);
            meth = cmpGlobalST->stLookupOper(OVOP_CTOR_INST, cmpClassArgIter); assert(meth);
            meth = cmpCurST->stFindOvlFnc(meth, type); assert(meth);

            /* Remember the constructor for next time */

            cmpCtorArgIter = meth;
        }

        /* Wrap the call in a "va_start" node */

        expr = cmpCreateExprNode(NULL, TN_VARARG_BEG, cmpTypeVoid);

        /* This thing doesn't return any value */

        expr->tnVtyp = TYP_VOID;
        expr->tnType = cmpTypeVoid;
    }
    else
    {
        TypDef          type;

        /* The second argument must be a type */

        if  (arg2->tnOper != TN_TYPE)
            return cmpCreateErrNode(ERRbadVAarg);

        /* Make sure the type is acceptable */

        type = arg2->tnType;

        switch (type->tdTypeKind)
        {
        case TYP_ARRAY:
            UNIMPL("need to decay array to pointer, right?");

        case TYP_VOID:
            cmpError(ERRbadVAtype, type);
            return cmpCreateErrNode();
        }

        /* Wrap the call in a "va_arg" node */

        expr = cmpCreateExprNode(NULL, TN_VARARG_GET, type);

        /* Find the 'GetNextArg' method */

        meth = cmpGetNextArgFN;
        if  (!meth)
        {
            ArgDscRec       args;
            TypDef          type;

            /* Create the method type and look for a matching method */

#if MGDDATA
            args = new ArgDscRec;
#else
            memset(&args, 0, sizeof(args));
#endif

            type = cmpGlobalST->stNewFncType(args, cmpGlobalST->stIntrinsicType(TYP_REFANY));

            meth = cmpGlobalST->stLookupClsSym(cmpIdentGetNArg, cmpClassArgIter); assert(meth);
            meth = cmpCurST->stFindOvlFnc(meth, type); assert(meth);

            /* Remember the method for next time */

            cmpGetNextArgFN = meth;
        }
    }

    /* Replace the original function with the constructor/nextarg method */

    call->tnFncSym.tnFncSym  = meth;
    call->tnFncSym.tnFncArgs = NULL;

    /* The call doesn't need to be virtual */

    call->tnFlags           |= TNF_CALL_NVIRT;

    /* Stash the method and the two arguments under the vararg node */

    expr->tnOp.tnOp1 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, arg1,
                                                                     arg2);
    expr->tnOp.tnOp2 = call;

    return  expr;
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  If the given type is a collection class, returns the element type of the
 *  collection (otherwise returns NULL).
 */

TypDef              compiler::cmpIsCollection(TypDef type)
{
    SymDef          clsSym;
    SymDef          genSym;
    GenArgDscA      genArg;

    assert(type);

    /* The type must be a managed class */

    if  (type->tdTypeKind != TYP_CLASS)
        return  NULL;
    if  (type->tdIsManaged == false)
        return  NULL;

    clsSym = type->tdClass.tdcSymbol;

    /* The class needs to be an instance of a parameterized type */

    if  (!clsSym->sdClass.sdcSpecific)
        return  NULL;

    genSym = clsSym->sdClass.sdcGenClass;

    assert(genSym);
    assert(genSym->sdSymKind == SYM_CLASS);
    assert(genSym->sdClass.sdcGeneric);

    /* Now see if the class is a collection */

    if  (genSym != cmpClassGenBag &&
         genSym != cmpClassGenLump)
    {
        return  NULL;
    }

    genArg = (GenArgDscA)clsSym->sdClass.sdcArgLst;

    /* There better be exactly one actual type argument */

    if  (genArg == NULL || genArg->gaNext != NULL)
        return  NULL;

    /* Looks good, return the element type to the caller */

    assert(genArg->gaBound);

    return  genArg->gaType;
}

/*****************************************************************************
 *
 *  Bind a set-oriented operator expression.
 */

Tree                compiler::cmpBindSetOper(Tree expr)
{
    Tree            listExpr;
    Tree            declExpr;
    Tree            collExpr;
    Tree            consExpr;
    Tree            sortExpr;
    Tree            filtExpr;

    TypDef          collType;
    TypDef          elemType;
    TypDef          rsltType;

    Tree            ivarDecl;
    SymDef          ivarSym;

    SymDef          outerScp = cmpCurScp;

    treeOps         oper = expr->tnOperGet();

    assert(oper == TN_ALL     ||
           oper == TN_EXISTS  ||
           oper == TN_FILTER  ||
           oper == TN_GROUPBY ||
           oper == TN_PROJECT ||
           oper == TN_UNIQUE  ||
           oper == TN_SORT    ||
           oper == TN_INDEX2);

    assert(expr->tnOp.tnOp1);
    assert(expr->tnOp.tnOp2 || oper == TN_PROJECT);
    assert(expr->tnOp.tnOp1->tnOper == TN_LIST);

    listExpr = expr->tnOp.tnOp1;
    listExpr->tnVtyp = TYP_VOID;
    listExpr->tnType = cmpTypeVoid;

    /* Get hold of the declaration and collection-expression subtrees */

    declExpr = listExpr->tnOp.tnOp1;
    collExpr = listExpr->tnOp.tnOp2;
    consExpr =     expr->tnOp.tnOp2;

    /* Bind the expression and make sure it has an acceptable type */

    collExpr = cmpBindExprRec(collExpr);

    if  (collExpr->tnVtyp != TYP_REF)
    {
        if  (collExpr->tnVtyp == TYP_UNDEF)
            return  collExpr;

    BAD_COLL:

        cmpError(ERRnotCollExpr, collExpr->tnType);
        return cmpCreateErrNode();
    }

    collType = collExpr->tnType;
    elemType = cmpIsCollection(collType->tdRef.tdrBase);
    if  (!elemType)
        goto BAD_COLL;

    assert(elemType->tdTypeKind == TYP_CLASS);

    elemType = elemType->tdClass.tdcRefTyp;

    /* We should always have a declaration scope node */

    assert(declExpr);
    assert(declExpr->tnOper == TN_BLOCK);
    assert(declExpr->tnBlock.tnBlkStmt == NULL);

    /* Set the type of the block node */

    declExpr->tnVtyp   = TYP_VOID;
    declExpr->tnType   = cmpTypeVoid;

    /* Mark the block as compiler-created */

    declExpr->tnFlags |= TNF_BLK_NUSER;

    /* Get hold of the variable declaration */

    ivarDecl = declExpr->tnBlock.tnBlkDecl;

    assert(ivarDecl);
    assert(ivarDecl->tnOper == TN_VAR_DECL);
    assert(ivarDecl->tnDcl.tnDclNext == NULL);
    assert(ivarDecl->tnFlags & TNF_VAR_UNREAL);

    /* Process the block (i.e. the single variable declaration) */

    cmpBlockDecl(declExpr, false, false, false);

    /* Get hold of the variable symbol just defined */

    ivarSym = ivarDecl->tnDcl.tnDclSym;

    assert(ivarSym && ivarSym->sdSymKind == SYM_VAR && ivarSym->sdIsImplicit);

    /* Mark the variable as declared/defined/managed, set type, etc. */

    ivarSym->sdIsDefined       = true;
    ivarSym->sdIsManaged       = true;
    ivarSym->sdCompileState    = CS_DECLARED;
    ivarSym->sdVar.sdvCollIter = true;
    ivarSym->sdType            = elemType;

    /* Is the scope implicit ? */

    if  (hashTab::hashIsIdHidden(ivarSym->sdName))
    {
        cmpCurScp->sdIsImplicit = true;
        cmpCurScp->sdType       = elemType->tdRef.tdrBase;
    }

    /* Sort and "combined" operators need special handling */

    if  (oper == TN_INDEX2)
    {
        filtExpr = consExpr->tnOp.tnOp1;
        sortExpr = consExpr->tnOp.tnOp2;

        if      (filtExpr == NULL)
        {
            /* Change the operator into a simple  sort  node */

            expr->tnOper     = oper = TN_SORT;
            expr->tnOp.tnOp2 = sortExpr;
        }
        else if (sortExpr == NULL)
        {
            /* Change the operator into a simple filter node */

            expr->tnOper     = oper = TN_FILTER;
            expr->tnOp.tnOp2 = filtExpr;
        }
        else
        {
            NO_WAY(!"filter+sort expressions should never make it this far");
        }
    }
    else
    {
        if  (oper == TN_SORT)
        {
            sortExpr = consExpr;
            filtExpr = NULL;
        }
        else
        {
            sortExpr = NULL;
            filtExpr = consExpr;
        }
    }

    /* Is there a filter (constraint) operator ? */

    if  (filtExpr)
    {
        /* Bind the constraint expression and make sure it's a boolean */

        filtExpr = cmpBindCondition(filtExpr);

        if  (filtExpr->tnVtyp == TYP_UNDEF)
        {
            expr = filtExpr;
            goto EXIT;
        }

        /* Figure out the type of the result */

        switch(oper)
        {
        case TN_ALL:
        case TN_EXISTS:
            rsltType = cmpTypeBool;
            break;

        case TN_INDEX2:
        case TN_FILTER:
            rsltType = collType;
            break;

        case TN_UNIQUE:
            rsltType = elemType;
            break;

        default:
            NO_WAY(!"unexpected set/collection operator");
        }
    }

    /* Is there a sort operator ? */

    if  (sortExpr)
    {
        Tree            sortTerm;

        /* Bind the sort terms and make sure they have a scalar / string type */

        for (sortTerm = sortExpr; sortTerm; sortTerm = sortTerm->tnOp.tnOp2)
        {
            Tree            sortOper;

            assert(sortTerm->tnOper == TN_LIST);

            /* Make sure we give the list node a valid type */

            sortTerm->tnVtyp = TYP_VOID;
            sortTerm->tnType = cmpTypeVoid;

            /* Bind the sort term and store it back in the list node */

            sortOper = sortTerm->tnOp.tnOp1 = cmpBindExprRec(sortTerm->tnOp.tnOp1);

            /* Each sort term must yield an arithmetic or String value */

            if  (!varTypeIsArithmetic(sortOper->tnVtypGet()))
            {
                if  (sortOper->tnType != cmpRefTpString)
                    cmpError(ERRbadSortExpr, sortOper->tnType);
            }
        }

        /* The result of the sort is the same type as the input */

        rsltType = collType;
    }

    expr->tnType                 = rsltType;
    expr->tnVtyp                 = rsltType->tdTypeKindGet();

    /* Store the bound trees back in the main node */

    if  (oper == TN_INDEX2)
    {
        consExpr->tnOp.tnOp1 = sortExpr;
        consExpr->tnOp.tnOp2 = filtExpr;
    }
    else
    {
        if  (oper == TN_SORT)
        {
            consExpr = sortExpr; assert(filtExpr == NULL);
        }
        else
        {
            consExpr = filtExpr; assert(sortExpr == NULL);
        }
    }

    expr->tnOp.tnOp1->tnOp.tnOp1 = declExpr;
    expr->tnOp.tnOp1->tnOp.tnOp2 = collExpr;
    expr->tnOp.tnOp2             = consExpr;

EXIT:

    /* Make sure we restore the previous scope */

    cmpCurScp = outerScp;

    return  expr;
}

/*****************************************************************************
 *
 *  Bind a "project" operator expression.
 */

Tree                compiler::cmpBindProject(Tree expr)
{
    Tree            listExpr;
    Tree            declExpr;
    Tree            argsList;

    TypDef          rsltType;

    Tree            ivarDecl;

    SymDef          memSym;

    bool            srcSome;
    bool            srcColl;

    SymDef          outerScp = cmpCurScp;

    assert(expr && expr->tnOper == TN_PROJECT);

    rsltType = expr->tnType;

    /* Get hold of the sub-operands */

    assert(expr->tnOp.tnOp1);
    assert(expr->tnOp.tnOp2);

    listExpr = expr->tnOp.tnOp1; assert(listExpr);
    declExpr = expr->tnOp.tnOp2; assert(declExpr);

    /* Stash the target type in the topmost list node */

    listExpr->tnVtyp = TYP_CLASS;
    listExpr->tnType = rsltType;

    /* Set the type of the declaration subtree to a valid value */

    declExpr->tnVtyp = TYP_VOID;
    declExpr->tnType = cmpTypeVoid;

    /* Bind all the argument expressions */

    for (argsList = listExpr, srcSome = srcColl = false;
         argsList;
         argsList = argsList->tnOp.tnOp2)
    {
        Tree            argExpr;
        Tree            srcExpr;

        TypDef          collType;
        TypDef          elemType;
        TypDef          tempType;

        assert(argsList->tnOper == TN_LIST);

        /* Get hold of the source expression subtrees */

        argExpr = argsList->tnOp.tnOp1;
        assert(argExpr->tnOper == TN_LIST);
        assert(argExpr->tnOp.tnOp1->tnOper == TN_NAME);
        srcExpr = argExpr->tnOp.tnOp2;

        /* Set the types of the suboperands to valid values */

        argExpr->tnVtyp = argExpr->tnOp.tnOp1->tnVtyp = TYP_VOID;
        argExpr->tnType = argExpr->tnOp.tnOp1->tnType = cmpTypeVoid;

        /* Bind the expression and make sure it has an acceptable type */

        argExpr->tnOp.tnOp2 = srcExpr = cmpBindExprRec(srcExpr);

        if  (srcExpr->tnVtyp != TYP_REF)
        {
            if  (srcExpr->tnVtyp == TYP_UNDEF)
                return  srcExpr;

        BAD_SRCX:

            cmpError(ERRbadPrjx, srcExpr->tnType);
            return cmpCreateErrNode();
        }

        collType = srcExpr->tnType;
        if  (collType->tdTypeKind != TYP_REF)
            goto BAD_SRCX;

        elemType = collType->tdRef.tdrBase;
        if  (elemType->tdTypeKind != TYP_CLASS)
            goto BAD_SRCX;

        /* Do we have a collection or a simple class/struct ? */

        tempType = cmpIsCollection(elemType);

        if  (!tempType)
        {
            UNIMPL("projecting a single instance is disabled right now");

            if  (srcSome && srcColl)
                cmpError(ERRmixCollSngl);

            srcSome = true;
        }
        else
        {
            if  (srcSome && !srcColl)
                cmpError(ERRmixCollSngl);

            elemType = tempType;

            srcSome  =
            srcColl  = true;
        }

        assert(elemType->tdTypeKind == TYP_CLASS);

        elemType = elemType->tdClass.tdcRefTyp;
    }

    /* We should always have a declaration scope node */

    assert(declExpr);
    assert(declExpr->tnOper == TN_BLOCK);
    assert(declExpr->tnBlock.tnBlkStmt == NULL);

    /* Set the type of the block node */

    declExpr->tnVtyp   = TYP_VOID;
    declExpr->tnType   = cmpTypeVoid;

    /* Mark the block as compiler-created */

    declExpr->tnFlags |= TNF_BLK_NUSER;

    /* Declare the block scope -- this will declare any iteration variables */

    cmpBlockDecl(declExpr, false, false, false);

    /* Visit all the iteration variable declarations */

    for (ivarDecl = declExpr->tnBlock.tnBlkDecl, argsList = listExpr;
         ivarDecl;
         ivarDecl = ivarDecl->tnDcl.tnDclNext  , argsList = argsList->tnOp.tnOp2)
    {
        Tree            argExpr;
        SymDef          ivarSym;
        TypDef          elemType;

        /* Get hold of the declaration node */

        assert(ivarDecl);
        assert(ivarDecl->tnOper == TN_VAR_DECL);
        assert(ivarDecl->tnFlags & TNF_VAR_UNREAL);

        /* Get hold of the type of the next source expression */

        assert(argsList->tnOper == TN_LIST);
        argExpr = argsList->tnOp.tnOp1;
        assert( argExpr->tnOper == TN_LIST);
        assert( argExpr->tnOp.tnOp1->tnOper == TN_NAME);
        elemType = argExpr->tnOp.tnOp2->tnType;

        /* Do we have a collection or a simple class/struct ? */

        assert(elemType->tdTypeKind == TYP_REF);
        elemType = elemType->tdRef.tdrBase;
        assert(elemType->tdTypeKind == TYP_CLASS);

        if  (srcColl)
            elemType = cmpIsCollection(elemType);

        assert(elemType && elemType->tdTypeKind == TYP_CLASS);
        elemType = elemType->tdClass.tdcRefTyp;

        /* Get hold of the variable symbol created by cmpBlockDecl() above */

        ivarSym = ivarDecl->tnDcl.tnDclSym;

        assert(ivarSym && ivarSym->sdSymKind == SYM_VAR && ivarSym->sdIsImplicit);

//      printf("Iter type for '%s' is %s\n", ivarSym->sdSpelling(), cmpGlobalST->stTypeName(elemType, NULL, NULL, NULL, true));

        /* Mark the variable as declared/defined/managed, set type, etc. */

        ivarSym->sdIsDefined       = true;
        ivarSym->sdIsManaged       = true;
        ivarSym->sdCompileState    = CS_DECLARED;
        ivarSym->sdVar.sdvCollIter = true;
        ivarSym->sdType            = elemType;

        /* Is the scope implicit ? */

        if  (hashTab::hashIsIdHidden(ivarSym->sdName))
        {
            cmpCurScp->sdIsImplicit = true;
            cmpCurScp->sdType       = elemType->tdRef.tdrBase;
        }
    }

    /* Make sure we've consumed all the argument trees */

    assert(argsList == NULL);

    /* Walk the members of the target type and bind their initializers */

    for (memSym = rsltType->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        if  (memSym->sdSymKind  == SYM_VAR &&
             memSym->sdIsStatic == false   &&
             memSym->sdVar.sdvInitExpr)
        {
            Tree        initVal = memSym->sdVar.sdvInitExpr;

//          printf("Initializer for %s:\n", memSym->sdSpelling()); cmpParser->parseDispTree(initVal);

            initVal = cmpCoerceExpr(cmpBindExpr(initVal), memSym->sdType, false);

            memSym->sdVar.sdvInitExpr = initVal;
        }
    }

    /* Figure out the result type of the whole thing */

    if  (srcColl)
    {
        SymDef          instSym;

        /* We need to create a collection instance */

        instSym = cmpParser->parseSpecificType(cmpClassGenBag, rsltType);

        assert(instSym && instSym->sdSymKind == SYM_CLASS);

        rsltType = instSym->sdType;
    }

    assert(rsltType->tdTypeKind == TYP_CLASS);

    expr->tnType = rsltType->tdClass.tdcRefTyp;
    expr->tnVtyp = TYP_REF;

    /* Make sure we restore the previous scope */

    cmpCurScp = outerScp;

    return  expr;
}

/*****************************************************************************
 *
 *  Bind an initializer ('new' expression) for a class with XML elements.
 */

Tree                compiler::cmpBindXMLinit(SymDef clsSym, Tree init)
{
    unsigned        argCnt;
    Tree            argList;
    Tree            argLast;

    SymDef          memSym;

    Tree            call;

    if  (!cmpXPathCls)
        cmpFindXMLcls();

    assert(clsSym->sdSymKind == SYM_CLASS);
    assert(clsSym->sdClass.sdcXMLelems);

    assert(init && init->tnOper == TN_LIST);

    for (memSym = clsSym->sdScope.sdScope.sdsChildList, argList = NULL, argCnt = 0;
         init;
         init = init->tnOp.tnOp2)
    {
        SymDef          nxtSym;
        TypDef          memType;
        Tree            argExpr;

        /* Locate the next instance data member of the class */

        memSym  = cmpNextInstDM(memSym, &nxtSym);
        memType = nxtSym ? nxtSym->sdType : NULL;

        /* Grab the next expression and bail if it's an error */

        assert(init && init->tnOper == TN_LIST);

        argExpr = init->tnOp.tnOp1;
        if  (argExpr->tnOper == TN_ERROR)
            goto DONE_ARG;

        /* Special case: arrays initialized with {} */

        if  (argExpr->tnOper == TN_SLV_INIT)
        {
            argExpr = bindSLVinit(memType, argExpr);
        }
        else
        {
            argExpr = cmpBindExpr(argExpr);

            if  (memType)
                argExpr = cmpCoerceExpr(argExpr, memType, false);
        }

    DONE_ARG:

        /* Append the value to the argument list */

        argExpr = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argExpr, NULL);

        if  (argList)
            argLast->tnOp.tnOp2 = argExpr;
        else
            argList             = argExpr;

        argLast = argExpr;

        argCnt++;
    }

    /* Prepend the total argument count to the argument list */

    argList = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, cmpCreateIconNode(NULL, argCnt, TYP_UINT),
                                                            argList);

    /* Prepend the type of the class    to the argument list */

    argList = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, cmpTypeIDinst(clsSym->sdType),
                                                            argList);

    /* Find the helper function symbol */

    if  (!cmpInitXMLfunc)
    {
        SymDef          initFnc;

        initFnc = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString("createXMLinst"),
                                              cmpXPathCls);

        if  (initFnc && initFnc->sdSymKind == SYM_FNC)
        {
            cmpInitXMLfunc = initFnc;
        }
        else
            cmpGenFatal(ERRbltinMeth, "XPath::createXMLinst");
    }

    /* Create a call to the "xml new" helper */

    call = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpInitXMLfunc->sdType->tdFnc.tdfRett);

    call->tnFncSym.tnFncObj  = NULL;
    call->tnFncSym.tnFncSym  = cmpInitXMLfunc;
    call->tnFncSym.tnFncArgs = argList;
    call->tnFncSym.tnFncScp  = NULL;

    /* Mark the call as "varargs" */

    call->tnFlags           |= TNF_CALL_VARARG;

    /* Unfortunately we have to cast the result explicitly */

    call = cmpCoerceExpr(call, clsSym->sdType->tdClass.tdcRefTyp, true);

//  cmpParser->parseDispTree(call);

    return  call;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\comp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "comp.h"
#include "genIL.h"
#ifdef  OLD_IL
#include "oldIL.h"
#endif

/*****************************************************************************/

#if     0
#ifdef  DEBUG
#define SHOW_CODE_OF_THIS_FNC   "parsePrepSrc"
#endif
#endif

/*****************************************************************************
 *
 *  In the single-threaded configuration the following points to *the* one
 *  compiler and scanner instance.
 */

#ifdef  DEBUG
Compiler            TheCompiler;
Scanner             TheScanner;
#endif

/*****************************************************************************
 *
 *  A little helper to declare "interesting" names.
 */

static
Ident               declBuiltinName(HashTab hash, const char *name)
{
    Ident           iden = hash->hashString(name);

    hashTab::setIdentFlags(iden, IDF_PREDEF);

    return  iden;
}

/*****************************************************************************
 *
 *  Initialize the compiler: called once per session.
 */

bool                compiler::cmpInit()
{
    bool            result;

    /* Remember current warning settings as our defaults */

    cmpErrorSave();

    /* Set a trap for any errors */

    setErrorTrap(this);
    begErrorTrap
    {
        Scanner         scan;
        HashTab         hash;
        SymTab          stab;
        SymDef          glob;
        ArgDscRec       args;

        Parser          parser;

        /* Initialize the two global allocators */

        if  (cmpAllocPerm.nraInit(this))
            cmpFatal(ERRnoMemory);
        if  (cmpAllocCGen.nraInit(this))
            cmpFatal(ERRnoMemory);
        if  (cmpAllocTemp. baInit(this))
            cmpFatal(ERRnoMemory);

        /* Initialize a bunch of stuff */

        cmpUniConvInit();
        cmpMDsigInit();

        /* Create and initialize the global hash table */

#if MGDDATA
        hash = new HashTab;
#else
        hash =    (HashTab)cmpAllocPerm.nraAlloc(sizeof(*hash));
#endif
        if  (!hash)
            cmpFatal(ERRnoMemory);
        if  (hash->hashInit(this, 16*1024, 0, &cmpAllocPerm))
            cmpFatal(ERRnoMemory);

        cmpGlobalHT = hash;

        /* Create and initialize the scanner we will use */

#if MGDDATA
        scan = new Scanner;
#else
        scan =    (Scanner)cmpAllocPerm.nraAlloc(sizeof(*scan));
#endif
        if  (scan->scanInit(this, hash))
            cmpFatal(ERRnoMemory);

        cmpScanner  = scan;

        /* If we're debugging, make some instances available globally */

#ifdef  DEBUG
        TheCompiler = this;
        TheScanner  = scan;
#endif

        /* Create and initialize the global symbol table */

#if MGDDATA
        stab = new SymTab;
#else
        stab =    (SymTab)cmpAllocPerm.nraAlloc(sizeof(*stab));
#endif
        cmpGlobalST = stab;
        if  (!stab)
            cmpFatal(ERRnoMemory);

        stab->stInit(this, &cmpAllocPerm, hash);

        /* Create a few standard types */

        cmpTypeInt        = stab->stIntrinsicType(TYP_INT);
        cmpTypeUint       = stab->stIntrinsicType(TYP_UINT);
        cmpTypeBool       = stab->stIntrinsicType(TYP_BOOL);
        cmpTypeChar       = stab->stIntrinsicType(TYP_CHAR);
        cmpTypeVoid       = stab->stIntrinsicType(TYP_VOID);

        cmpTypeNatInt     = stab->stIntrinsicType(TYP_NATINT);
        cmpTypeNatUint    = stab->stIntrinsicType(TYP_NATUINT);

        cmpTypeCharPtr    = stab->stNewRefType(TYP_PTR, cmpTypeChar);
        cmpTypeWchrPtr    = stab->stNewRefType(TYP_PTR, stab->stIntrinsicType(TYP_WCHAR));
        cmpTypeVoidPtr    = stab->stNewRefType(TYP_PTR, cmpTypeVoid);

#if MGDDATA
        args = new ArgDscRec;
#else
        memset(&args, 0, sizeof(args));
#endif

        cmpTypeVoidFnc    = stab->stNewFncType(args,    cmpTypeVoid);

        /* Create the temp tree nodes used for overloaded operator binding */

        cmpConvOperExpr   = cmpCreateExprNode(NULL, TN_NONE   , cmpTypeVoid);

        cmpCompOperArg1   = cmpCreateExprNode(NULL, TN_LIST   , cmpTypeVoid);
        cmpCompOperArg2   = cmpCreateExprNode(NULL, TN_LIST   , cmpTypeVoid);
        cmpCompOperFnc1   = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpTypeVoid);
        cmpCompOperFnc2   = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpTypeVoid);
        cmpCompOperFunc   = cmpCreateExprNode(NULL, TN_LIST   , cmpTypeVoid);
        cmpCompOperCall   = cmpCreateExprNode(NULL, TN_LIST   , cmpTypeVoid);

        /* Create the global namespace symbol */

        glob = stab->stDeclareSym(hash->hashString("<global>"),
                                  SYM_NAMESPACE,
                                  NS_NORM,
                                  NULL);

        glob->sdNS.sdnSymtab = stab;

        /* Record the global namespace symbol */

        cmpGlobalNS       = glob;

        /* Hash some strings so we can easily detect certain symbols */

        cmpIdentSystem    = declBuiltinName(hash, "System");
        cmpIdentRuntime   = declBuiltinName(hash, "Runtime");
        cmpIdentObject    = declBuiltinName(hash, "Object");
        cmpIdentString    = declBuiltinName(hash, "String");
        cmpIdentArray     = declBuiltinName(hash, "Array");
        cmpIdentType      = declBuiltinName(hash, "Type");
        cmpIdentInvoke    = declBuiltinName(hash, "Invoke");
        cmpIdentInvokeBeg = declBuiltinName(hash, "BeginInvoke");
        cmpIdentInvokeEnd = declBuiltinName(hash, "EndInvoke");
        cmpIdentDeleg     = declBuiltinName(hash, "Delegate");
        cmpIdentMulti     = declBuiltinName(hash, "MulticastDelegate");
        cmpIdentExcept    = declBuiltinName(hash, "Exception");
        cmpIdentRTexcp    = declBuiltinName(hash, "SystemException");
        cmpIdentArgIter   = declBuiltinName(hash, "ArgIterator");

        cmpIdentEnum      = declBuiltinName(hash, "Enum");
        cmpIdentValType   = declBuiltinName(hash, "ValueType");

#ifdef  SETS
        cmpIdentDBhelper  = declBuiltinName(hash, "DBhelper");
        cmpIdentForEach   = declBuiltinName(hash, "$foreach");
#endif

        cmpIdentGetNArg   = declBuiltinName(hash, "GetNextArg");

        cmpIdentAssertAbt = declBuiltinName(hash, "__AssertAbort");
        cmpIdentEnter     = declBuiltinName(hash, "Enter");
        cmpIdentExit      = declBuiltinName(hash, "Exit");
        cmpIdentGet       = declBuiltinName(hash, "get");
        cmpIdentSet       = declBuiltinName(hash, "set");

        cmpIdentDbgBreak  = declBuiltinName(hash, "DebugBreak");

        cmpIdentXcptCode  = declBuiltinName(hash, "_exception_code");
        cmpIdentXcptInfo  = declBuiltinName(hash, "_exception_info");
        cmpIdentAbnmTerm  = declBuiltinName(hash, "_abnormal_termination");

        // UNDONE: All of the following method symbols should be
        // UNDONE: cached after they are seen for the first time.

        cmpIdentMain      = hash->hashString("main");
        cmpIdentToString  = hash->hashString("ToString");
        cmpIdentGetType   = hash->hashString("GetType");
        cmpIdentGetTpHnd  = hash->hashString("GetTypeFromHandle");
        cmpIdentVariant   = hash->hashString("Variant");

        cmpIdentVAbeg     = hash->hashString("va_start");
        cmpIdentVAget     = hash->hashString("va_arg");

        cmpIdentCompare   = hash->hashString("$compare");
        cmpIdentEquals    = hash->hashString("$equals");
        cmpIdentNarrow    = hash->hashString("$narrow");
        cmpIdentWiden     = hash->hashString("$widen");

#ifdef  SETS

        cmpIdentGenBag    = hash->hashString("bag");
        cmpIdentGenLump   = hash->hashString("lump");

        cmpIdentDBall     = hash->hashString("$all");
        cmpIdentDBsort    = hash->hashString("$sort");
        cmpIdentDBslice   = hash->hashString("$slice");
        cmpIdentDBfilter  = hash->hashString("$filter");
        cmpIdentDBexists  = hash->hashString("$exists");
        cmpIdentDBunique  = hash->hashString("$unique");
        cmpIdentDBproject = hash->hashString("$project");
        cmpIdentDBgroupby = hash->hashString("$groupby");

#endif

        /* Declare the "System" and "Runtime" namespaces */

        cmpNmSpcSystem    = stab->stDeclareSym(cmpIdentSystem,
                                               SYM_NAMESPACE,
                                               NS_NORM,
                                               cmpGlobalNS);

        cmpNmSpcSystem ->sdNS.sdnSymtab = stab;

        cmpNmSpcRuntime   = stab->stDeclareSym(cmpIdentRuntime,
                                               SYM_NAMESPACE,
                                               NS_NORM,
                                               cmpNmSpcSystem);

        cmpNmSpcRuntime->sdNS.sdnSymtab = stab;

        /* Hash the names of the standard value types */

        cmpInitStdValTypes();

        /* Create and initialize the parser */

#if MGDDATA
        parser = new Parser;
#else
        parser =    (Parser)SMCgetMem(this, sizeof(*parser));
#endif
        cmpParser = parser;

        if  (cmpParser->parserInit(this))
            cmpFatal(ERRnoMemory);
        cmpParserInit = true;

        /* Define any built-in macros */

        scan->scanDefMac("__SMC__"    , "1");
        scan->scanDefMac("__IL__"     , "1");
        scan->scanDefMac("__COMRT__"  , "1");

        if  (cmpConfig.ccTgt64bit)
            scan->scanDefMac("__64BIT__", "1");


        /* Do we have any macro definitions? */

        if  (cmpConfig.ccMacList)
        {
            StrList         macDsc;

            for (macDsc = cmpConfig.ccMacList;
                 macDsc;
                 macDsc = macDsc->slNext)
            {
                char    *       macStr  = macDsc->slString;
                char    *       macName;
                bool            undef;

                /* First see if this is a definition or undefinition */

                undef = false;

                if  (*macStr == '-')
                {
                    macStr++;
                    undef = true;
                }

                /* Now extract the macro name */

                macName = macStr;
                if  (!isalpha(*macStr) && *macStr != '_')
                    goto MAC_ERR;

                macStr++;

                while (*macStr && *macStr != '=')
                {
                    if  (!isalnum(*macStr) && *macStr != '_')
                        goto MAC_ERR;

                    macStr++;
                }

                if  (undef)
                {
                    if  (*macStr)
                        goto MAC_ERR;

                    if  (scan->scanUndMac(macName))
                        goto MAC_ERR;
                }
                else
                {
                    if  (*macStr)
                    {
                        *macStr++ = 0;
                    }
                    else
                        macStr = "";

                    if  (!scan->scanDefMac(macName, macStr))
                        goto MAC_ERR;
                }

                continue;

            MAC_ERR:

                cmpGenError(ERRbadMacDef, macDsc->slString);
            }
        }

#ifdef  CORIMP

        cmpInitMDimp();

        if  (cmpConfig.ccBaseLibs)
            cmpImportMDfile(cmpConfig.ccBaseLibs, false, true);

        for (StrList xMD = cmpConfig.ccSuckList; xMD; xMD = xMD->slNext)
            cmpImportMDfile(xMD->slString);

#endif

        /* Initialize the "using" logic */

        parser->parseUsingInit();

        /* The initialization is finished */

        result = false;

        /* End of the error trap's "normal" block */

        endErrorTrap(this);
    }
    chkErrorTrap(fltErrorTrap(this, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(this);

        /* An error occurred; free up any resources we've allocated */

        if  (cmpParser)
        {
            if  (cmpParserInit)
                cmpParser->parserDone();

#if!MGDDATA
            SMCrlsMem(this, cmpParser);
#endif
            cmpParser = NULL;
        }

        result = true;
    }

    return  result;
}

/*****************************************************************************
 *
 *  Initialize and shutdown metadata logic.
 */

void                compiler::cmpInitMD()
{
    if  (!cmpWmdd)
    {
        cmpWmdd = initializeIMD();
        if  (!cmpWmdd)
            cmpFatal(ERRopenCOR);
    }
}

/*****************************************************************************
 *
 *  Initialize and shutdown metadata emission logic.
 */

void                compiler::cmpInitMDemit()
{
    cmpInitMD();

    if  (cmpWmdd->DefineScope(getIID_CorMetaDataRuntime(),
                              0,
                              getIID_IMetaDataEmit(),
                              &cmpWmde))
    {
        cmpFatal(ERRopenCOR);
    }

    /* Create the remapper and tell the metadata engine about it */

#if MD_TOKEN_REMAP

    TokenMapper     remapper = new tokenMap;

    // UNDONE: Need to delete remapper when done, right?

    if  (cmpWmde->SetHandler(remapper))
        cmpFatal(ERRopenCOR);

#endif

    cmpPEwriter->WPEinitMDemit(cmpWmdd, cmpWmde);
}

void                compiler::cmpDoneMDemit()
{
    if (cmpWmde) { cmpWmde->Release(); cmpWmde = NULL; }
    if (cmpWase) { cmpWase->Release(); cmpWase = NULL; }
    if (cmpWmdd) { cmpWmdd->Release(); cmpWmdd = NULL; }
}

/*****************************************************************************
 *
 *  Prepare the output logic for MSIL/metadata generation.
 */

void                compiler::cmpPrepOutput()
{
    WritePE         writer;
    GenILref        gen_IL;

#ifdef  OLD_IL

    if  (cmpConfig.ccOILgen)
    {
        GenOILref       genOIL;

#if MGDDATA
        genOIL = new GenOILref;
#else
        genOIL =    (GenOILref)cmpAllocPerm.nraAlloc(sizeof(*genOIL));
#endif

        cmpOIgen = genOIL;
        return;
    }

#endif

#if MGDDATA
    writer = new WritePE;
    gen_IL = new GenILref;
#else
    writer =    (WritePE )cmpAllocPerm.nraAlloc(sizeof(*writer));
    gen_IL =    (GenILref)cmpAllocPerm.nraAlloc(sizeof(*gen_IL));
#endif

    if  (!writer->WPEinit(this, &cmpAllocPerm))
        cmpPEwriter = writer;

    if  (!gen_IL->genInit(this, writer, &cmpAllocCGen))
        cmpILgen    = gen_IL;

    /* Initialize metadata emission stuff */

    cmpInitMDemit();

    /* If we were given either a name or GUID for the image, tell metadata */

    if  (cmpConfig.ccOutGUID.Data1|
         cmpConfig.ccOutGUID.Data2|
         cmpConfig.ccOutGUID.Data3)
    {
        printf("UNDONE: Need to create custom attribute for module GUID\n");
    }

    if  (cmpConfig.ccOutName)
    {
        const   char *  name = cmpConfig.ccOutName;

        if  (cmpWmde->SetModuleProps(cmpUniConv(name, strlen(name)+1)))
            cmpFatal(ERRmetadata);
    }
}

/*****************************************************************************
 *
 *  Terminate the compiler: call once per session.
 */

bool                compiler::cmpDone(bool errors)
{
    bool            result = true;

    setErrorTrap(this);
    begErrorTrap
    {
        if  (cmpErrorCount)
        {
            errors = true;
        }
        else if (!errors)
        {
            /* If it's an EXE make sure it has an entry point */

            if  (!cmpFnSymMain && !cmpConfig.ccOutDLL)
            {
                cmpError(ERRnoEntry);
                errors = true;
            }
        }

#ifdef  OLD_IL

        if  (cmpConfig.ccOILgen)
        {
            cmpOIgen->GOIterminate(errors); assert(cmpPEwriter == NULL);
        }

#endif

        if  (cmpPEwriter)
        {
            StrList         mods;

            /* Finish IL code generation */

            if  (cmpILgen)
            {
                cmpILgen->genDone(errors); cmpILgen = NULL;
            }

            /* Add any modules the user wants in the manifest */

            for (mods = cmpConfig.ccModList; mods; mods = mods->slNext)
                cmpImportMDfile(mods->slString, true);

            /* Add any resources the user wants in the manifest */

            for (mods = cmpConfig.ccMRIlist; mods; mods = mods->slNext)
                cmpAssemblyAddRsrc(mods->slString, false);

            /* If we were given a resource file to suck in, do it now */

            if  (cmpConfig.ccRCfile)
            {
                result = cmpPEwriter->WPEaddRCfile(cmpConfig.ccRCfile);
                if  (result)
                    errors = true;
            }

            /* Are we supposed to mark our assembly as non-CLS ? */

            if  (cmpConfig.ccAsmNonCLS)
                cmpAssemblyNonCLS();

            /* Was this a safe or unsafe program? */

            if  (!cmpConfig.ccSafeMode && cmpConfig.ccAssembly)
                cmpMarkModuleUnsafe();

            /* Close out the symbol store (must do before closing the PE) */

            if  (cmpSymWriter)
            {
                /* Grab the necessary debug info from the symbol store */

                if (cmpPEwriter->WPEinitDebugDirEmit(cmpSymWriter))
                    cmpGenFatal(ERRdebugInfo);

                if  (cmpSymWriter->Close())
                    cmpGenFatal(ERRdebugInfo);

                cmpSymWriter->Release();
                cmpSymWriter = NULL;
            }

            /* Flush/write the output file */

            result = cmpPEwriter->WPEdone(cmpTokenMain, errors);

            /* Get rid of any metadata interfaces we've acquired */

            cmpDoneMDemit();

            /* Throw away the PE writer */

            cmpPEwriter = NULL;
        }

        /* End of the error trap's "normal" block */

        endErrorTrap(this);
    }
    chkErrorTrap(fltErrorTrap(this, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(this);
    }

#ifdef  CORIMP
    cmpDoneMDimp();
#endif

#ifdef  DEBUG
    TheCompiler = NULL;
    TheScanner  = NULL;
#endif

    if  (!cmpConfig.ccQuiet)
    {
//      if  (cmpFncCntSeen || cmpFncCntComp)
//      {
//          printf("\n");
//
//          if  (cmpFncCntSeen) printf("A total of %6u function/method decl's processed\n", cmpFncCntSeen);
//          if  (cmpFncCntComp) printf("A total of %6u function/method bodies  compiled\n", cmpFncCntComp);
//      }

        if  (cmpLineCnt)
            printf("%6u lines of source processed.\n", cmpLineCnt);
    }

    return  result;
}

/*****************************************************************************
 *
 *  Compile one source file.
 */

bool                compiler::cmpPrepSrc(genericRef cookie, stringBuff file,
                                                            QueuedFile buff,
                                                            stringBuff srcText)
{
    SymDef          cmpUnit;

    bool            result = false;
    Compiler        comp   = (Compiler)cookie;

#ifndef FAST
//  printf("Reading source file '%s'\n", file);
#endif

    /* Determine default management mode */


    comp->cmpManagedMode = !comp->cmpConfig.ccOldStyle;


    /* Convert the source string to a parse tree */

    cmpUnit = comp->cmpParser->parsePrepSrc(file, buff, srcText, comp->cmpGlobalST);

    comp->cmpLineCnt += comp->cmpScanner->scanGetTokenLno() - 1;

    return  !cmpUnit;
}

/*****************************************************************************
 *
 *  Allocate a block outside of any allocator - this is to be used for very
 *  large blocks with long lifetimes.
 */

genericRef          compiler::cmpAllocBlock(size_t sz)
{
#if MGDDATA

    return  new managed char [sz];

#else

    BlkList         list  = (BlkList)cmpAllocTemp.baAlloc(sizeof(*list));
    void        *   block = LowLevelAlloc(sz);

    if  (!block)
        cmpFatal(ERRnoMemory);

    list->blAddr = block;
    list->blNext = cmpAllocList;
                   cmpAllocList = list;

    return  block;

#endif
}

/*****************************************************************************
 *
 *  Display the contens of the global symbol table.
 */

#ifdef  DEBUG

void                compiler::cmpDumpSymbolTable()
{
    assert(cmpGlobalNS);
    assert(cmpGlobalNS->sdSymKind == SYM_NAMESPACE);

    cmpGlobalST->stDumpSymbol(cmpGlobalNS, 0, true, true);
}

#endif

/*****************************************************************************
 *
 *  Expand the generic vector.
 */

void                compiler::cmpVecExpand()
{
    unsigned        newSize;

    // CONSIDER: reuse deleted entries

    /* Start with a reasonable size and then keep doubling */

    newSize = cmpVecAlloc ? 2 * cmpVecAlloc
                          : 64;

    /* Allocate the new vector */

#if MGDDATA
    VecEntryDsc []  newTable = new VecEntryDsc[newSize];
#else
    VecEntryDsc *   newTable = (VecEntryDsc*)LowLevelAlloc(newSize * sizeof(*newTable));
#endif

    /* If the vector is non-empty, copy it to the new location */

    if  (cmpVecAlloc)
    {

#if MGDDATA
        UNIMPL(!"need to copy managed array value");
#else
        memcpy(newTable, cmpVecTable, cmpVecAlloc * sizeof(*newTable));
        LowLevelFree(cmpVecTable);
#endif
    }

    /* Remember the new size and address */

    cmpVecTable = newTable;
    cmpVecAlloc = newSize;
}

/*****************************************************************************
 *
 *  The pre-defined "String"/"Object"/"Class"/.... type is needed but it has
 *  not been defined yet, try to locate it somehow and blow up if we can't
 *  find it.
 */

TypDef              compiler::cmpFindStringType()
{
    if  (!cmpClassString)
        cmpGenFatal(ERRbltinTp, "String");

    cmpRefTpString = cmpClassString->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpString;
}

TypDef              compiler::cmpFindObjectType()
{
    if  (!cmpClassObject)
        cmpGenFatal(ERRbltinTp, "Object");

    cmpRefTpObject = cmpClassObject->sdType->tdClass.tdcRefTyp;
    cmpRefTpObject->tdIsObjRef = true;

    return  cmpRefTpObject;
}

TypDef              compiler::cmpFindTypeType()
{
    if  (!cmpClassType)
        cmpGenFatal(ERRbltinTp, "Type");

    cmpRefTpType = cmpClassType->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpType;
}

TypDef              compiler::cmpFindArrayType()
{
    if  (!cmpClassArray)
        cmpGenFatal(ERRbltinTp, "Array");

    cmpRefTpArray= cmpClassArray->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpArray;
}

TypDef              compiler::cmpFindDelegType()
{
    if  (!cmpClassDeleg)
        cmpGenFatal(ERRbltinTp, "Delegate");

    cmpRefTpDeleg = cmpClassDeleg->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpDeleg;
}

TypDef              compiler::cmpFindMultiType()
{
    if  (!cmpClassMulti)
        cmpGenFatal(ERRbltinTp, "MulticastDelegate");

    cmpRefTpMulti = cmpClassMulti->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpMulti;
}

TypDef              compiler::cmpFindExceptType()
{
    if  (!cmpClassExcept)
        cmpGenFatal(ERRbltinTp, "Exception");

    cmpRefTpExcept = cmpClassExcept->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpExcept;
}

TypDef              compiler::cmpFindRTexcpType()
{
    if  (!cmpClassRTexcp)
        cmpGenFatal(ERRbltinTp, "SystemException");

    cmpRefTpRTexcp = cmpClassRTexcp->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpRTexcp;
}

TypDef              compiler::cmpFindArgIterType()
{
    if  (!cmpClassArgIter)
        cmpGenFatal(ERRbltinTp, "ArgIterator");

    cmpRefTpArgIter = cmpClassArgIter->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpArgIter;
}

TypDef              compiler::cmpFindMonitorType()
{
    SymDef          temp;

    temp = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("Threading"),
                                       NS_NORM,
                                       cmpNmSpcSystem);

    if  (!temp || temp->sdSymKind != SYM_NAMESPACE)
        cmpGenFatal(ERRbltinNS, "System::Threading");

    temp = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("Monitor"),
                                       NS_NORM,
                                       temp);

    if  (!temp || temp->sdSymKind != SYM_CLASS)
        cmpGenFatal(ERRbltinTp, "System::Threading::Monitor");

    cmpClassMonitor = temp;
    cmpRefTpMonitor = temp->sdType->tdClass.tdcRefTyp;

    return  cmpRefTpMonitor;
}

void                compiler::cmpRThandleClsDcl()
{
    if  (!cmpRThandleCls)
    {
        SymDef          rthCls;

        rthCls = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("RuntimeTypeHandle"),
                                             NS_NORM,
                                             cmpNmSpcSystem);

        if  (rthCls && rthCls->sdSymKind         == SYM_CLASS
                    && rthCls->sdClass.sdcFlavor == STF_STRUCT)
        {
            cmpRThandleCls = rthCls;
        }
        else
            cmpGenFatal(ERRbltinTp, "System::RuntimeTypeHandle");
    }
}

void                compiler::cmpInteropFind()
{
    SymDef          temp;

    temp = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("InteropServices"),
                                       NS_NORM,
                                       cmpNmSpcRuntime);

    if  (temp && temp->sdSymKind == SYM_NAMESPACE)
    {
        cmpInteropSym = temp;
    }
    else
        cmpGenFatal(ERRbltinNS, "System::Runtime::InteropServices");
}

void                compiler::cmpFNsymGetTPHdcl()
{
    if  (!cmpFNsymGetTpHnd)
    {
        SymDef          ovlFnc;

        /* Look for the "Type::GetTypeFromHandle" method (it may be overloaded) */

        ovlFnc = cmpGlobalST->stLookupClsSym(cmpIdentGetTpHnd, cmpClassType);

        if  (ovlFnc)
        {
            SymDef          rthCls = cmpRThandleClsGet();

            if  (rthCls)
            {
                TypDef          rthTyp = rthCls->sdType;

                for (;;)
                {
                    ArgDscRec       argDsc = ovlFnc->sdType->tdFnc.tdfArgs;

                    if  (argDsc.adCount == 1)
                    {
                        assert(argDsc.adArgs);

                        if  (symTab::stMatchTypes(argDsc.adArgs->adType, rthTyp))
                            break;
                    }

                    ovlFnc = ovlFnc->sdFnc.sdfNextOvl;
                    if  (!ovlFnc)
                        break;
                }

                cmpFNsymGetTpHnd = ovlFnc;
            }
        }

        if  (cmpFNsymGetTpHnd == NULL)
            cmpGenFatal(ERRbltinMeth, "Type::GetTypeFromHandle(RuntimeTypeHandle)");
    }
}

void                compiler::cmpNatTypeFind()
{
    if  (!cmpNatTypeSym)
    {
        SymDef          temp;

        /* Look for the enum within the "InteropServices" package */

        temp = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("NativeType"),
                                           NS_NORM,
                                           cmpInteropGet());

        if  (temp && temp->sdSymKind == SYM_ENUM)
            cmpNatTypeSym = temp;

        if  (!cmpNatTypeSym)
            cmpGenFatal(ERRbltinTp, "System::Runtime::InteropServices::NativeType");
    }
}

void                compiler::cmpCharSetFind()
{
    if  (!cmpCharSetSym)
    {
        SymDef          temp;

        /* Look for the enum within the "InteropServices" package */

        temp = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("CharacterSet"),
                                           NS_NORM,
                                           cmpInteropGet());

        if  (temp && temp->sdSymKind == SYM_ENUM)
            cmpCharSetSym = temp;

        if  (!cmpCharSetSym)
            cmpGenFatal(ERRbltinTp, "System::Runtime::InteropServices::CharacterSet");
    }
}

#ifdef  SETS

void                compiler::cmpFindXMLcls()
{
    if  (!cmpXPathCls)
    {
        SymDef          temp;

        temp = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("XPath"),
                                           NS_NORM,
                                           cmpGlobalNS);

        if  (!temp || temp->sdSymKind != SYM_CLASS)
            cmpGenFatal(ERRbltinTp, "XPath");

        cmpXPathCls = temp;

        if  (!cmpXMLattrClass)
        {
            temp = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString("XMLclass"),
                                               cmpXPathCls);

            if  (!temp || temp->sdSymKind != SYM_CLASS)
                cmpGenFatal(ERRbltinTp, "XPath::XMLclass");

            cmpXMLattrClass = temp;
        }

        if  (!cmpXMLattrElement)
        {
            temp = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString("XMLelement"),
                                               cmpXPathCls);

            if  (!temp || temp->sdSymKind != SYM_CLASS)
                cmpGenFatal(ERRbltinTp, "XPath::XMLelement");

            cmpXMLattrElement = temp;
        }
    }
}

TypDef              compiler::cmpObjArrTypeFind()
{
    /* Have we created the "Object []" type yet ? */

    if  (!cmpObjArrType)
    {
        DimDef          dims = cmpGlobalST->stNewDimDesc(0);

        cmpObjArrType = cmpGlobalST->stNewArrType(dims, true, cmpRefTpObject);
    }

    return  cmpObjArrType;
}

#endif

/*****************************************************************************
 *
 *  Declare a symbol for "operator new / delete".
 */

SymDef              compiler::cmpDeclUmgOper(tokens tokName, const char *extName)
{
    ArgDscRec       args;
    TypDef          type;
    SymDef          fsym;
    SymXinfoLnk     desc = NULL;

    assert(tokName == tkNEW || tokName == tkDELETE);

    if  (tokName == tkNEW)
    {
        cmpParser->parseArgListNew(args,
                                   1,
                                   false, cmpTypeUint   , NULL);

//      type = cmpGlobalST->stNewFncType(args, cmpTypeVoidPtr);
        type = cmpGlobalST->stNewFncType(args, cmpTypeInt);
    }
    else
    {
        cmpParser->parseArgListNew(args,
                                   1,
//                                 false, cmpTypeVoidPtr, NULL);
                                   false, cmpTypeInt    , NULL);

        type = cmpGlobalST->stNewFncType(args, cmpTypeVoid);
    }

    fsym = cmpGlobalST->stDeclareSym(cmpGlobalHT->tokenToIdent(tokName),
                                     SYM_FNC,
                                     NS_HIDE,
                                     cmpGlobalNS);


    /* Allocate a linkage descriptor and fill it in */

#if MGDDATA
    desc = new SymXinfoLnk;
#else
    desc =    (SymXinfoLnk)cmpAllocPerm.nraAlloc(sizeof(*desc));
#endif

    desc->xiKind             = XI_LINKAGE;
    desc->xiNext             = NULL;

    desc->xiLink.ldDLLname   = "msvcrt.dll";
    desc->xiLink.ldSYMname   = extName;
    desc->xiLink.ldStrings   = 0;
    desc->xiLink.ldLastErr   = false;

    /* Store the type and linkage info in the function symbol */

    fsym->sdType             = type;
    fsym->sdFnc.sdfExtraInfo = cmpAddXtraInfo(fsym->sdFnc.sdfExtraInfo, desc);

    return  fsym;
}

/*****************************************************************************
 *
 *  The given function has been mentioned twice, and we need to check that
 *  the second declaration/definition doesn't redefine any default argument
 *  values, and we also transfer any defaults from the old function type.
 *
 *  The type that represents the merged function type is returned.
 *
 *  WARNING: Since this is here to support a dubious feature (i.e. declaring
 *           functions in more than one place), we don't bother doing this
 *           completely clean - when merging, rather than create a new copy
 *           of the argument list we simply bash the old one.
 */

TypDef              compiler::cmpMergeFncType(SymDef fncSym, TypDef newType)
{
    ArgDef          params1;
    ArgDef          params2;

    TypDef          oldType = fncSym->sdType;

    /* Both types should be matching function types */

    assert(oldType->tdTypeKind == TYP_FNC);
    assert(newType->tdTypeKind == TYP_FNC);

    /* Make sure the return type agree */

    if  (!symTab::stMatchTypes(oldType->tdFnc.tdfRett, newType->tdFnc.tdfRett))
    {
        fncSym->sdType = newType;

        cmpErrorQSS(ERRdiffMethRet, fncSym, oldType->tdFnc.tdfRett);

        return  newType;
    }

#ifdef  DEBUG

    if  (!symTab::stMatchTypes(oldType, newType))
    {
        printf("Old method type: '%s'\n", cmpGlobalST->stTypeName(oldType, fncSym, NULL, NULL, false));
        printf("New method type: '%s'\n", cmpGlobalST->stTypeName(newType, fncSym, NULL, NULL, false));
    }

    assert(symTab::stMatchTypes(oldType, newType));

#endif

    /* If the old type didn't have any argument defaults, we're done */

    if  (!oldType->tdFnc.tdfArgs.adDefs)
        return  newType;

    /* Get hold of the argument lists */

    params1 = oldType->tdFnc.tdfArgs.adArgs;
    params2 = newType->tdFnc.tdfArgs.adArgs;

    while (params1)
    {
        assert(params2);

        /* Simply copy the new parameter name to the old type */

        params1->adName = params2->adName;

        /* Continue with the next parameter */

        params1 = params1->adNext;
        params2 = params2->adNext;
    }

    assert(params1 == NULL);
    assert(params2 == NULL);

    return  oldType;
}

/*****************************************************************************
 *
 *  Invent a new name for an anonymous symbol.
 */

Ident               compiler::cmpNewAnonymousName()
{
    char            buff[16];
    Ident           name;

    sprintf(buff, "$%u", cmpCntAnonymousNames++);

    name = cmpGlobalHT->hashString(buff);
    cmpGlobalHT->hashMarkHidden(name);

    return  name;
}

/*****************************************************************************
 *
 *  Evaluate a pre-processing constant expression.
 */

bool                compiler::cmpEvalPreprocCond()
{
    Scanner         ourScanner = cmpScanner;

    constVal        cval;

    /* Get the scanner started */

    ourScanner->scan();

    /* Parse and evaluate the constant value */

    if  (cmpParser->parseConstExpr(cval))
    {
        if  (ourScanner->scanTok.tok == tkEOL)
        {
            /* We have an expression value, check it for 0 */

            switch (cval.cvVtyp)
            {
            default:        return (cval.cvValue.cvIval != 0);
            case tkLONGINT:
            case tkULONGINT:return (cval.cvValue.cvLval != 0);
            case tkFLOAT:   return (cval.cvValue.cvFval != 0);
            case tkDOUBLE:  return (cval.cvValue.cvDval != 0);
            }
        }
    }

    /* There has been an error, swallow the rest of the line */

    while (ourScanner->scanTok.tok != tkEOL)
        ourScanner->scan();

    return  false;
}

/*****************************************************************************
 *
 *  Fetch a constant value and return the corresponding expression.
 */

Tree                compiler::cmpFetchConstVal(ConstVal cval, Tree expr)
{
    /* What's the type of the constant? */

    switch (cval->cvVtyp)
    {
        __int32         ival;

    case TYP_BOOL:   ival =             1 & cval->cvValue.cvIval; goto IV;
    case TYP_CHAR:   ival = (  signed char )cval->cvValue.cvIval; goto IV;
    case TYP_UCHAR:  ival = (unsigned char )cval->cvValue.cvIval; goto IV;
    case TYP_SHORT:  ival = (  signed short)cval->cvValue.cvIval; goto IV;
    case TYP_WCHAR:
    case TYP_USHORT: ival = (unsigned short)cval->cvValue.cvIval; goto IV;
    case TYP_INT:
    case TYP_UINT:   ival =                 cval->cvValue.cvIval; goto IV;

    IV:
        expr = cmpCreateIconNode(expr,                 ival, (var_types)cval->cvVtyp);
        break;

    case TYP_LONG:
    case TYP_ULONG:
        expr = cmpCreateLconNode(expr, cval->cvValue.cvLval, (var_types)cval->cvVtyp);
        break;

    case TYP_FLOAT:
        expr = cmpCreateFconNode(expr, cval->cvValue.cvFval);
        break;

    case TYP_DOUBLE:
        expr = cmpCreateDconNode(expr, cval->cvValue.cvDval);
        break;

    case TYP_ENUM:

        if  (cval->cvType->tdEnum.tdeIntType->tdTypeKind >= TYP_LONG)
        {
            UNIMPL(!"fetch long enum value");
        }
        else
        {
            expr = cmpCreateIconNode(expr, cval->cvValue.cvIval, TYP_VOID);

            expr->tnOper = TN_CNS_INT;
            expr->tnVtyp = TYP_ENUM;
            expr->tnType = cval->cvType;
        }
        break;

    case TYP_PTR:
    case TYP_REF:

        /* Must be either a string or "null" or icon cast to pointer */

        if  (cval->cvIsStr)
        {
            assert(cval->cvType == cmpTypeCharPtr ||
                   cval->cvType == cmpTypeWchrPtr || cval->cvType == cmpFindStringType());

            expr = cmpCreateSconNode(cval->cvValue.cvSval->csStr,
                                     cval->cvValue.cvSval->csLen,
                                     cval->cvHasLC,
                                     cval->cvType);
        }
        else
        {
            /* This could be NULL or a constant cast to a pointer */

            expr = cmpCreateExprNode(expr, TN_NULL, cval->cvType);

            if  (cval->cvType == cmpFindObjectType() && !cval->cvValue.cvIval)
                return  expr;

            /* It's an integer constant cast to a pointer */

            expr->tnOper             = TN_CNS_INT;
            expr->tnIntCon.tnIconVal = cval->cvValue.cvIval;
        }
        break;

    case TYP_UNDEF:
        return cmpCreateErrNode();

    default:
#ifdef  DEBUG
        printf("\nConstant type: '%s'\n", cmpGlobalST->stTypeName(cval->cvType, NULL, NULL, NULL, false));
#endif
        UNIMPL(!"unexpected const type");
    }

    /* The type of the value is "fixed" */

    expr->tnFlags |= TNF_BEEN_CAST;

    return  expr;
}

/*****************************************************************************
 *
 *  Return the class/namespace that contains the given symbol. This is made
 *  a bit tricky by anonymous unions.
 */

SymDef              compiler::cmpSymbolOwner(SymDef sym)
{
    for (;;)
    {
        sym = sym->sdParent;

        if  (sym->sdSymKind == SYM_CLASS && sym->sdClass.sdcAnonUnion)
            continue;

        assert(sym->sdSymKind == SYM_CLASS ||
               sym->sdSymKind == SYM_NAMESPACE);

        return  sym;
    }
}

/*****************************************************************************
 *
 *  Fold any constant sub-expression in the given bound expression tree.
 */

Tree                compiler::cmpFoldExpression(Tree expr)
{
    // UNDONE: fold expr

    return  expr;
}

/*****************************************************************************
 *
 *  Returns true if the given type is an acceptable exception type.
 */

bool                compiler::cmpCheckException(TypDef type)
{
    switch (type->tdTypeKind)
    {
    case TYP_REF:

        assert(cmpClassExcept);
        assert(cmpClassRTexcp);

        if  (cmpIsBaseClass(cmpClassExcept->sdType, type->tdRef.tdrBase))
            return  true;
        if  (cmpIsBaseClass(cmpClassRTexcp->sdType, type->tdRef.tdrBase))
            return  true;

        return  false;

    default:
        return  false;

    case TYP_TYPEDEF:
        return cmpCheckException(cmpActualType(type));
    }
}

/*****************************************************************************
 *
 *  Convert a string to Unicode.
 *
 *  WARNING: This routine usually reuses the same buffer so don't call it
 *           while hanging on to any results from previous calls.
 */

#if MGDDATA

wideString          compiler::cmpUniConv(char managed [] str, size_t len)
{
    UNIMPL(!"");
    return  "hi";
}

wideString          compiler::cmpUniConv(const char *    str, size_t len)
{
    UNIMPL(!"");
    return  "hi";
}

#else

wideString          compiler::cmpUniConv(const char *    str, size_t len)
{
    /* If there are embedded nulls, we can't use mbstowcs() */

    if  (strlen(str)+1 < len)
        return cmpUniCnvW(str, &len);

    if  (len > cmpUniConvSize)
    {
        size_t          newsz;

        /* The buffer is apparently too small, so grab a bigger one */

        cmpUniConvSize = newsz = max(cmpUniConvSize*2, len + len/2);
        cmpUniConvAddr = (wchar *)cmpAllocTemp.baAlloc(roundUp(2*newsz));
    }

    mbstowcs(cmpUniConvAddr, str, cmpUniConvSize);

    return   cmpUniConvAddr;
}

wideString          compiler::cmpUniCnvW(const char *    str, size_t*lenPtr)
{
    size_t          len = *lenPtr;

    wchar       *   dst;
    const BYTE  *   src;
    const BYTE  *   end;

    bool            nch = false;

    if  (len > cmpUniConvSize)
    {
        size_t          newsz;

        /* The buffer is apparently too small, so grab a bigger one */

        cmpUniConvSize = newsz = max(cmpUniConvSize*2, len + len/2);
        cmpUniConvAddr = (wchar *)cmpAllocTemp.baAlloc(roundUp(2*newsz));
    }

    /* This is not entirely right, but it's good enough for now */

    dst = cmpUniConvAddr;
    src = (const BYTE *)str;
    end = src + len;

    do
    {
        unsigned        ch = *src++;

        if  (ch != 0xFF)
        {
            *dst++ = ch;
        }
        else
        {
            ch = *src++;

            *dst++ = ch | (*src++ << 8);
        }
    }
    while (src < end);

    *lenPtr = dst - cmpUniConvAddr; assert(*lenPtr <= len);

//  printf("Wide string = '%ls', len = %u\n", cmpUniConvAddr, *lenPtr);

    return   cmpUniConvAddr;
}

#endif

/*****************************************************************************
 *
 *  The following maps a type kind to its built-in value type name equivalent.
 */

static
const   char *      cmpStdValTpNames[] =
{
    NULL,           // UNDEF
    "Void",         // VOID
    "Boolean",      // BOOL
    "Char",         // WCHAR
    "SByte",        // CHAR
    "Byte",         // UCHAR
    "Int16",        // SHORT
    "UInt16",       // USHORT
    "Int32",        // INT
    "UInt32",       // UINT
    "IntPtr" ,      // NATINT
    "UIntPtr",      // NATUINT
    "Int64",        // LONG
    "UInt64",       // ULONG
    "Single",       // FLOAT
    "Double",       // DOUBLE
    "Extended",     // LONGDBL
};

/*****************************************************************************
 *
 *  Hash all the standard value type names and mark them as such.
 */

void                compiler::cmpInitStdValTypes()
{
    HashTab         hash = cmpGlobalHT;
    unsigned        type;

    for (type = 0; type < arraylen(cmpStdValTpNames); type++)
    {
        if  (cmpStdValTpNames[type])
        {
            Ident       name = hash->hashString(cmpStdValTpNames[type]);

            hashTab::setIdentFlags(name, IDF_STDVTP|IDF_PREDEF);

            cmpStdValueIdens[type] = name;
        }
    }
}

/*****************************************************************************
 *
 *  Given a value type, return the corresponding intrinsic type (or TYP_UNDEF
 *  if the argument doesn't represent a "built-in" value type).
 */

var_types           compiler::cmpFindStdValType(TypDef type)
{
    assert(type->tdTypeKind == TYP_CLASS);
    assert(type->tdIsIntrinsic);

    if  (type->tdClass.tdcIntrType == TYP_UNDEF)
    {
        Ident           name = type->tdClass.tdcSymbol->sdName;

        if  (hashTab::getIdentFlags(name) & IDF_STDVTP)
        {
            unsigned        vtyp;

            for (vtyp = 0; vtyp < arraylen(cmpStdValTpNames); vtyp++)
            {
                if  (cmpStdValueIdens[vtyp] == name)
                {
                    type->tdClass.tdcIntrType = vtyp;
                    break;
                }
            }
        }
    }

    return  (var_types)type->tdClass.tdcIntrType;
}


/*****************************************************************************
 *
 *  Given an intrinsic type, return the corresponding value type.
 */

TypDef              compiler::cmpFindStdValType(var_types vtp)
{
    Ident           nam;
    TypDef          typ;
    SymDef          sym;

    if  (vtp == TYP_UNDEF)
        return  NULL;

    assert(vtp < TYP_lastIntrins);
    assert(vtp < arraylen(cmpStdValueTypes));
    assert(vtp < arraylen(cmpStdValTpNames));

    /* If we've already created the type, return it */

    typ = cmpStdValueTypes[vtp];
    if  (typ)
        return  typ;

    /* Do we have "System" loaded? */

    if  (!cmpNmSpcSystem)
        return  NULL;

    /* Get hold of the type's name and look it up */

    nam = cmpStdValueIdens[vtp]; assert(nam);
    sym = cmpGlobalST->stLookupNspSym(nam, NS_NORM, cmpNmSpcSystem);

    if  (sym && sym->sdSymKind == SYM_CLASS)
    {
        cmpStdValueTypes[vtp] = sym->sdType;
        return  sym->sdType;
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Report the use of a symbol marked as obsolete (deprecated).
 */

void                compiler::cmpObsoleteUse(SymDef sym, unsigned wrn)
{
    assert(sym && sym->sdIsDeprecated);

    if  (sym->sdIsImport)
    {
        SymDef          clsSym;
        mdToken         token;

        const   void *  blobAddr;
        ULONG           blobSize;

        /* Try to get hold of the string attached to the attribute */

        switch (sym->sdSymKind)
        {
        case SYM_CLASS:
            token  = sym->sdClass.sdcMDtypedef;
            clsSym = sym;
            break;

        case SYM_FNC:
            token  = sym->sdFnc.sdfMDtoken;
            clsSym = sym->sdParent;
            break;

        default:
            goto NOSTR;
        }

        assert(clsSym && clsSym->sdSymKind == SYM_CLASS && clsSym->sdIsImport);

        if      (!clsSym->sdClass.sdcMDimporter->MDfindAttr(token,                   L"Deprecated", &blobAddr, &blobSize))
        {
        }
        else if (!clsSym->sdClass.sdcMDimporter->MDfindAttr(token, L"System.Attributes.Deprecated", &blobAddr, &blobSize))
        {
        }
        else if (!clsSym->sdClass.sdcMDimporter->MDfindAttr(token,     L"System.ObsoleteAttribute", &blobAddr, &blobSize))
        {
        }
        else
            goto NOSTR;

        if  (!blobAddr || !blobSize)
            goto NOSTR;

//      printf("Blob [%2u bytes] = '%s'\n", blobSize, (BYTE*)blobAddr+3);

        cmpWarnQns(WRNobsoleteStr, sym, (char*)blobAddr+3);

    NOSTR:

        cmpWarnQnm(wrn, sym);
    }

    sym->sdIsDeprecated = false;
}

/*****************************************************************************
 *
 *  Make sure space has been allocated for the given variable in the data
 *  section of the output file. Returns the address of the data section
 *  where its initial value is located,
 */

memBuffPtr          compiler::cmpAllocGlobVar(SymDef varSym)
{
    memBuffPtr      addr;

    assert(varSym);
    assert(varSym->sdSymKind == SYM_VAR);
    assert(varSym->sdParent->sdSymKind   != SYM_CLASS ||
           varSym->sdParent->sdIsManaged == false);

    if  (!varSym->sdVar.sdvAllocated)
    {
        TypDef          tp = cmpActualType(varSym->sdType);

        size_t          sz;
        size_t          al;

        /* The variable better not be an undimensioned array */

        assert(tp->tdTypeKind != TYP_ARRAY || !tp->tdIsUndimmed);

        /* Get hold of the size and alignment of the variable */

        if  (varSym->sdVar.sdvIsVtable)
        {
            assert(varSym->sdParent);
            assert(varSym->sdParent->sdSymKind == SYM_CLASS);
            assert(varSym->sdParent->sdIsManaged == false);

            sz = sizeof(void*) * varSym->sdParent->sdClass.sdcVirtCnt;
            al = sizeof(void*);
        }
        else
            sz = cmpGetTypeSize(tp, &al);

        /* Now reserve space in the data section */

        varSym->sdVar.sdvOffset = cmpPEwriter->WPEsecRsvData(PE_SECT_data,
                                                             sz,
                                                             al,
                                                             addr);

        /* Remember that we've allocated space for the variable */

        varSym->sdVar.sdvAllocated = true;
    }
    else
    {
        addr = cmpPEwriter->WPEsecAdrData(PE_SECT_data, varSym->sdVar.sdvOffset);
    }

    return  addr;
}

/*****************************************************************************
 *
 *  Tables used by cmpDecodeAlign() and cmpEncodeAlign().
 */

BYTE                cmpAlignDecodes[] =
{
    0,  //  0
    1,  //  1
    2,  //  2
    4,  //  3
    8,  //  4
    16  //  5
};

BYTE                cmpAlignEncodes[] =
{
    0,  //  0
    1,  //  1
    2,  //  2
    0,  //  3
    3,  //  4
    0,  //  5
    0,  //  6
    0,  //  7
    4,  //  8
    0,  //  9
    0,  // 10
    0,  // 11
    0,  // 12
    0,  // 13
    0,  // 14
    0,  // 15
    5,  // 16
};

/*****************************************************************************
 *
 *  Return the size and alignment of the type.
 */

size_t              compiler::cmpGetTypeSize(TypDef type, size_t *alignPtr)
{
    var_types       vtp;

    size_t          sz;
    size_t          al;

AGAIN:

    vtp = type->tdTypeKindGet();

    if  (vtp <= TYP_lastIntrins)
    {
        al = symTab::stIntrTypeAlign(vtp);
        sz = symTab::stIntrTypeSize (vtp);
    }
    else
    {
        switch (vtp)
        {
        case TYP_ENUM:
            cmpDeclSym(type->tdEnum.tdeSymbol);
            type = type->tdEnum.tdeIntType;
            goto AGAIN;

        case TYP_TYPEDEF:
            cmpDeclSym(type->tdTypedef.tdtSym);
            type = type->tdTypedef.tdtType;
            goto AGAIN;

        case TYP_CLASS:

            /* Make sure the class is declared */

            cmpDeclSym(type->tdClass.tdcSymbol);

            // UNDONE: Make sure the class is not managed

            al = cmpDecodeAlign(type->tdClass.tdcAlignment);
            sz =                type->tdClass.tdcSize;
            break;

        case TYP_REF:
        case TYP_PTR:
            al =
            sz = cmpConfig.ccTgt64bit ? 8 : 4;
            break;

        case TYP_ARRAY:

            /* Is this a managed array? */

            if  (type->tdIsManaged)
            {
                /* A managed array is really just a GC ref */

                al =
                sz = cmpConfig.ccTgt64bit ? 8 : 4;
            }
            else
            {
                /* Unmanaged array: use the element's alignment */

                sz = cmpGetTypeSize(type->tdArr.tdaElem, &al);

                if  (type->tdIsUndimmed)
                {
                    /* Unmanaged array without a dimension - set size to 0 */

                    sz = 0;
                }
                else
                {
                    DimDef          dims = type->tdArr.tdaDims;

                    assert(dims);
                    assert(dims->ddNext == NULL);
                    assert(dims->ddIsConst);

                    if  (!dims->ddSize)
                    {
                        cmpError(ERRemptyArray);
                        dims->ddSize = 1;
                    }

                    sz *= dims->ddSize;
                }
            }
            break;

        case TYP_FNC:
        case TYP_VOID:

            al = sz = 0;
            break;

        default:
#ifdef  DEBUG
            printf("%s: ", cmpGlobalST->stTypeName(type, NULL, NULL, NULL, false));
#endif
            NO_WAY(!"unexpected type");
        }
    }

    if  (alignPtr)
        *alignPtr = al;

    return sz;
}

/*****************************************************************************
 *
 *  Given an unmanaged (early-bound) class/struct/union, assign offsets to
 *  its members and compute its total size.
 */

void                compiler::cmpLayoutClass(SymDef clsSym)
{
    TypDef          clsTyp  = clsSym->sdType;
    bool            virtFns = clsSym->sdClass.sdcHasVptr;
    bool            isUnion = (clsTyp->tdClass.tdcFlavor == STF_UNION);

    unsigned        maxAl;
    unsigned        align;
    unsigned        offset;
    unsigned        totSiz;

    unsigned        curBFoffs;
    unsigned        curBFbpos;
    unsigned        curBFmore;
    var_types       curBFtype;

    bool            hadMem;
    SymDef          memSym;

    assert(clsSym->sdSymKind == SYM_CLASS);
    assert(clsSym->sdIsManaged == false);
    assert(clsSym->sdCompileState >= CS_DECLARED);

    if  (clsTyp->tdClass.tdcLayoutDone)
        return;

    /* Check for the case where a class embeds itself (or a derived copy) */

    if  (clsTyp->tdClass.tdcLayoutDoing)
    {
        cmpErrorQnm(ERRrecClass, clsSym);

        /* One error message for this is enough */

        clsTyp->tdClass.tdcLayoutDone = true;
        return;
    }

//  printf("Layout [%u,%u] '%s'\n", clsTyp->tdClass.tdcLayoutDoing, clsTyp->tdClass.tdcLayoutDone, clsSym->sdSpelling());

    maxAl  = cmpDecodeAlign(clsSym->sdClass.sdcDefAlign);
    align  = 1;
    offset = 0;
    totSiz = 0;
    hadMem = false;

//  printf("Max. alignment is %2u for '%s'\n", maxAl, clsSym->sdSpelling());

    clsTyp->tdClass.tdcLayoutDoing = true;

    /* Reserve space for the base class, if any */

    if  (clsTyp->tdClass.tdcBase)
    {
        TypDef          baseTyp =  clsTyp->tdClass.tdcBase;
        SymDef          baseSym = baseTyp->tdClass.tdcSymbol;

        assert(baseSym->sdSymKind == SYM_CLASS);

        if  (baseSym->sdIsManaged)
        {
            /* This can only happen after egregious errors, right? */

            assert(cmpErrorCount);
            return;
        }

        /* Make sure we've laid out the base and reserve space for it */

        cmpLayoutClass(baseSym); totSiz = offset = baseTyp->tdClass.tdcSize;

        /*
            If this class has any virtual functions and the base class
            doesn't, we'll have to add a vtable pointer in front of
            the base class.
         */

        if  (virtFns && !baseSym->sdClass.sdcHasVptr)
        {
            /* Remember that we're adding a vtable pointer */

            clsSym->sdClass.sdc1stVptr = true;

            /* Make room for the vtable pointer in the class */

            offset += sizeof(void*);
        }
    }
    else
    {
        /* Reserve space for the vtable, if any virtuals are present */

        if  (virtFns)
            offset += sizeof(void*);
    }

    /* Now assign offsets to all members */

    curBFoffs = 0;
    curBFbpos = 0;
    curBFmore = 0;
    curBFtype = TYP_UNDEF;

    for (memSym = clsSym->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        TypDef          memType;
        size_t          memSize;
        size_t          memAlign;

        if  (memSym->sdSymKind != SYM_VAR)
            continue;
        if  (memSym->sdIsStatic)
            continue;

        /* We have an instance member, get its size/alignment */

        hadMem  = true;

        /* Special case: undimensioned array in unmanaged class */

        memType = cmpActualType(memSym->sdType); assert(memType);

        if  (memType->tdIsManaged)
        {
            /* Assume that this has already been flagged as an error */

            assert(cmpErrorCount);

            /* Supply reasonable value just so that we can continue */

            memSize = memAlign = sizeof(void*);
        }
        else
        {
            TypDef          chkType = memType;
            TypDef          sizType = memType;

            if  (memType->tdTypeKind == TYP_ARRAY)
            {
                chkType = memType->tdArr.tdaElem;

                if  (memType->tdIsUndimmed && !isUnion)
                {
                    SymDef      nxtMem;

                UNDIM_ARR:

                    /* Make sure that no other non-static members follow */

                    nxtMem = memSym;
                    for (;;)
                    {
                        nxtMem = nxtMem->sdNextInScope;
                        if  (!nxtMem)
                            break;

                        if  (memSym->sdSymKind  == SYM_VAR &&
                             memSym->sdIsStatic == false)
                        {
                            cmpError(ERRbadUndimMem);
                        }
                    }

                    sizType = chkType;
                }
                else if (memType->tdArr.tdaDcnt == 1)
                {
                    DimDef          dims = memType->tdArr.tdaDims;

                    /* Make a zero-length array into an undimmed one */

                    assert(dims);
                    assert(dims->ddNext == NULL);

                    if  (dims->ddIsConst && dims->ddSize == 0 && !isUnion)
                    {
                        memType->tdIsUndimmed = true;
                        goto UNDIM_ARR;
                    }
                }
            }

            if  (chkType == clsTyp)
            {
                cmpError(ERRrecFld);
                memSize = memAlign = sizeof(void*);
            }
            else
                memSize = cmpGetTypeSize(sizType, &memAlign);
        }

        /* Honor the requested packing */

        if  (memAlign > maxAl)
             memAlign = maxAl;

        /* Keep track of the max. alignment */

        if  (align < memAlign)
             align = memAlign;

        /* Is the member a bitfield? */

        if  (memSym->sdVar.sdvBitfield)
        {
            unsigned        cnt = memSym->sdVar.sdvBfldInfo.bfWidth;
            var_types       vtp = cmpActualVtyp(memType);

            /* Is there enough room for the member in the current cell? */

            if  (symTab::stIntrTypeSize(vtp) !=
                 symTab::stIntrTypeSize(curBFtype) || cnt > curBFmore)
            {
                /* Special case: byte bitfields can straddle boundaries */

                if  (memSize == 1 && curBFmore)
                {
                    /* Add more room by stealing the next byte */

                    offset   += 1;
                    curBFmore = 8;

                    /* Keep the bit offset below 8 */

                    if  (curBFbpos >= 8)
                    {
                        curBFoffs += curBFbpos / 8;
                        curBFbpos  = curBFbpos % 8;
                    }
                }
                else
                {
                    /* We need to start a new storage cell for the bitfield */

                    offset +=  (memAlign - 1);
                    offset &= ~(memAlign - 1);

                    /* Remember where the bitfield starts */

                    curBFoffs = offset;
                                offset += memSize;

                    /* The memory cell is completely free */

                    curBFbpos = 0;
                    curBFmore = 8 * memSize;
                    curBFtype = vtp;
                }

                /* We better have enough room for the new bitfield */

                assert(cnt <= curBFmore);
            }

            /* Fit the member in the next available bit section */

            memSym->sdVar.sdvOffset            = curBFoffs;
            memSym->sdVar.sdvBfldInfo.bfOffset = curBFbpos;

//          printf("Member [bf=%2u;%2u] at offset %04X: '%s'\n", curBFbpos, cnt, curBFoffs, memSym->sdSpelling());

            /* Update the bit position/count and we're done with this one */

            curBFbpos += cnt;
            curBFmore -= cnt;
        }
        else
        {
            /* Make sure the member is properly aligned */

            offset +=  (memAlign - 1);
            offset &= ~(memAlign - 1);

            /* Record the offset of this member */

            memSym->sdVar.sdvOffset = offset;

//          printf("Member [size =%3u] at offset %04X: %s.%s\n", memSize, offset, clsSym->sdSpelling(), memSym->sdSpelling());

#if 0

            /* Is this an anonymous union? */

            if  (memType->tdTypeKind == TYP_CLASS &&
                 memType->tdClass.tdcAnonUnion)
            {
                SymDef          tmpSym;
                SymDef          aunSym = memType->tdClass.tdcSymbol;

                if  (!memType->tdClass.tdcLayoutDone)
                    cmpLayoutClass(aunSym);

                for (tmpSym = aunSym->sdScope.sdScope.sdsChildList;
                     tmpSym;
                     tmpSym = tmpSym->sdNextInScope)
                {
                    printf("Anon union member '%s'\n", tmpSym->sdSpelling());
                }
            }

#endif

            /* Bump the offset for the next member */

            offset += memSize;
        }

        /* For unions, keep track of the largest member size */

        if  (isUnion)
        {
            if  (totSiz < memSize)
                 totSiz = memSize;

            offset = 0;
        }
    }

    /* Did we have any members at all? */

    if  (hadMem)
    {
        /* Unless it's a union, use the final member offset as size */

        if  (!isUnion)
            totSiz = offset;
    }
    else
    {
        // ISSUE: Do we need to do anything special for empty classes?
    }

    /* Better round up the total size for proper alignment */

    totSiz = roundUp(totSiz, align);

    /* Record the total size and max. alignment of the type */

//  printf("Class  [align=%3u] totalsize %04X: %s\n", align, totSiz, clsSym->sdSpelling());

    clsTyp->tdClass.tdcSize        = totSiz;
    clsTyp->tdClass.tdcAlignment   = cmpEncodeAlign(align);

    clsTyp->tdClass.tdcLayoutDone  = true;
    clsTyp->tdClass.tdcLayoutDoing = false;
}

/*****************************************************************************
 *
 *  Switch to the given variable's data area so that we can output its
 *  initial value. The caller promises to hang on to the return value,
 *  and pass it on to the various cmpWritexxxInit() functions so that
 *  the value ends up in the right place.
 *
 *  Special case: when 'undim' is true, the variable being initialized
 *  is an array of unknown size. In that case we'll simply prepare the
 *  data section for output but won't reserve any space in it, since
 *  the amount of space won't be known until the entire initializer is
 *  processed.
 */

memBuffPtr          compiler::cmpInitVarBeg(SymDef varSym, bool undim)
{
    /* Prevent re-entering this logic for more than one variable at once */

#ifdef  DEBUG
    assert(cmpInitVarCur == NULL); cmpInitVarCur = varSym;
#endif

    /* Has space for the variable been allocated? */

    if  (varSym->sdVar.sdvAllocated)
    {
        if  (undim)
        {
            UNIMPL("space already allocated for undim'd array - I don't think so!");
        }

#ifdef  DEBUG
        cmpInitVarOfs = varSym->sdVar.sdvOffset;
#endif

        /* Locate the data area of the variable and return it */

        return  cmpPEwriter->WPEsecAdrData(PE_SECT_data, varSym->sdVar.sdvOffset);
    }
    else
    {
        size_t          al;
        memBuffPtr      ignore;

        /* We don't expect vtables to ever appear here */

        assert(varSym->sdVar.sdvIsVtable == false);

        /* The space has not been allocated, get the required alignment */

        cmpGetTypeSize(varSym->sdType, &al);

        /* Prepare to append the variable's value to the data section */

        varSym->sdVar.sdvOffset = cmpPEwriter->WPEsecRsvData(PE_SECT_data,
                                                             0,
                                                             al,
                                                             ignore);

        /* Remember that we've allocated space for the variable */

        varSym->sdVar.sdvAllocated = true;

#ifdef  DEBUG
        cmpInitVarOfs = varSym->sdVar.sdvOffset;
#endif

        return  memBuffMkNull();
    }
}

/*****************************************************************************
 *
 *  This function is only used in debug mode, where it helps make sure that
 *  we don't try to append more than one variable's initial value to the
 *  data section at once.
 */

#ifdef  DEBUG

void                compiler::cmpInitVarEnd(SymDef varSym)
{
    size_t          sz;

    assert(cmpInitVarCur);

    if  (varSym->sdVar.sdvIsVtable)
    {
        assert(varSym->sdParent);
        assert(varSym->sdParent->sdSymKind == SYM_CLASS);
        assert(varSym->sdParent->sdIsManaged == false);

        sz = sizeof(void*) * varSym->sdParent->sdClass.sdcVirtCnt;
    }
    else
        sz = cmpGetTypeSize(varSym->sdType);

    assert(cmpInitVarOfs == varSym->sdVar.sdvOffset + sz || cmpErrorCount);

    cmpInitVarCur = NULL;
}

#endif

/*****************************************************************************
 *
 *  Append the given blob of bits to the data section of the variable being
 *  initialized.
 */

memBuffPtr          compiler::cmpWriteVarData(memBuffPtr dest, genericBuff str,
                                                               size_t      len)
{
    if  (!memBuffIsNull(dest))
    {
        memBuffCopy(dest, str, len);
    }
    else
    {
        unsigned        offs;

        offs = cmpPEwriter->WPEsecAddData(PE_SECT_data, str, len);

        /* Make sure we are where we think we ought to be */

        assert(offs == cmpInitVarOfs);
    }

#ifdef  DEBUG
    cmpInitVarOfs += len;
#endif

    return dest;
}

/*****************************************************************************
 *
 *  Write the given constant value to the next position in the current
 *  variable's data area. The 'dest' argument points at where the data
 *  is to be writtem, and an updated address is returned. If 'dest' is
 *  NULL, we're simply appending to the data section (in which case a
 *  NULL value is returned back).
 */

memBuffPtr          compiler::cmpWriteOneInit(memBuffPtr dest, Tree expr)
{
    BYTE        *   addr;
    size_t          size;

    __int32         ival;
    __int64         lval;
    float           fval;
    double          dval;

    switch (expr->tnOper)
    {
        unsigned        offs;

    case TN_CNS_INT: ival = expr->tnIntCon.tnIconVal; addr = (BYTE*)&ival; break;
    case TN_CNS_LNG: lval = expr->tnLngCon.tnLconVal; addr = (BYTE*)&lval; break;
    case TN_CNS_FLT: fval = expr->tnFltCon.tnFconVal; addr = (BYTE*)&fval; break;
    case TN_CNS_DBL: dval = expr->tnDblCon.tnDconVal; addr = (BYTE*)&dval; break;
    case TN_NULL:    ival =                        0; addr = (BYTE*)&ival; break;

    case TN_CNS_STR:

        /* Add the string to the string pool */

        ival = cmpILgen->genStrPoolAdd(expr->tnStrCon.tnSconVal,
                                       expr->tnStrCon.tnSconLen+1,
                                       expr->tnStrCon.tnSconLCH);

        /* We will output the relative offset of the string */

        addr = (BYTE*)&ival;

        /* We also need to add a fixup for the string reference */

        offs = memBuffIsNull(dest) ? cmpPEwriter->WPEsecNextOffs(PE_SECT_data)
                                   : cmpPEwriter->WPEsecAddrOffs(PE_SECT_data, dest);

        cmpPEwriter->WPEsecAddFixup(PE_SECT_data, PE_SECT_string, offs);
        break;

    default:
        NO_WAY(!"unexpected initializer type");
    }

    /* Get hold of the size of the value */

    size = cmpGetTypeSize(expr->tnType);

    /* Now output the initializer value */

    return  cmpWriteVarData(dest, makeGenBuff(addr, size), size);
}

/*****************************************************************************
 *
 *  Parse one initializer expression (which we expect to be of an arithmetic
 *  type or a pointer/ref), return the bound constant result or NULL if there
 *  is an error.
 */

Tree                compiler::cmpParseOneInit(TypDef type)
{
    Tree            expr;

    /* Parse the expression, coerce it, bind it, fold it, mutilate it, ... */

    expr = cmpParser->parseExprComma();
    expr = cmpCreateExprNode(NULL, TN_CAST, type, expr, NULL);
    expr = cmpBindExpr(expr);
    expr = cmpFoldExpression(expr);

    /* Now see what we've ended up with */

    if  (expr->tnOperKind() & TNK_CONST)
        return  expr;

    if  (expr->tnOper == TN_ERROR)
        return  NULL;

    return  cmpCreateErrNode(ERRinitNotCns);
}

/*****************************************************************************
 *
 *  Add the given amount of padding to the variable being initialized.
 */

memBuffPtr          compiler::cmpInitVarPad(memBuffPtr dest, size_t amount)
{
    memBuffPtr      ignore;

    if  (!memBuffIsNull(dest))
        memBuffMove(dest, amount);
    else
        cmpPEwriter->WPEsecRsvData(PE_SECT_data, amount, 1, ignore);

#ifdef  DEBUG
    cmpInitVarOfs += amount;
#endif

    return  dest;
}

/*****************************************************************************
 *
 *  Initialize a scalar value; returns true if an error was encountered.
 */

bool                compiler::cmpInitVarScl(INOUT memBuffPtr REF dest,
                                                  TypDef         type,
                                                  SymDef         varSym)
{
    Tree            init;

    /* If this is the top level, prepare to initialize the variable */

    if  (varSym)
    {
        assert(memBuffIsNull(dest)); dest = cmpInitVarBeg(varSym);
    }

    /* Make sure the initializer does not start with "{" */

    if  (cmpScanner->scanTok.tok == tkLCurly)
    {
        cmpError(ERRbadBrInit, type);
        return  true;
    }

    /* Parse the initializer and make sure it's a constant */

    init = cmpParseOneInit(type);
    if  (!init || init->tnOper == TN_ERROR)
        return  true;

    assert(symTab::stMatchTypes(type, init->tnType));

    /* Output the constant */

    dest = cmpWriteOneInit(dest, init);

    /* Everything went just dandy */

    return  false;
}

/*****************************************************************************
 *
 *  Initialize an array value; returns true if an error was encountered.
 */

bool                compiler::cmpInitVarArr(INOUT memBuffPtr REF dest,
                                                  TypDef         type,
                                                  SymDef         varSym)
{
    Scanner         ourScanner = cmpScanner;

    bool            undim;

    unsigned        fsize;
    unsigned        elems;

    TypDef          base;
    bool            curl;

    /* We expect to have an unmanaged array here */

    assert(type && type->tdTypeKind == TYP_ARRAY && !type->tdIsManaged);
    assert(varSym == NULL || symTab::stMatchTypes(varSym->sdType, type));

    /* Does the array have a fixed dimension? */

    if  (type->tdIsUndimmed)
    {
        fsize = 0;
        undim = true;
    }
    else
    {
        assert(type->tdArr.tdaDims);
        assert(type->tdArr.tdaDims->ddNext == NULL);
        assert(type->tdArr.tdaDims->ddIsConst);

        fsize = type->tdArr.tdaDims->ddSize;
        undim = false;
    }

    elems = 0;

    /* If this is the top level, prepare to initialize the variable */

    if  (varSym)
    {
        assert(memBuffIsNull(dest)); dest = cmpInitVarBeg(varSym, undim);
    }

    /* Get hold of the base type */

    base = cmpDirectType(type->tdArr.tdaElem);

    /* Make sure the initializer starts with "{" */

    if  (ourScanner->scanTok.tok != tkLCurly)
    {
        genericBuff     buff;

        /* Special case: "char []" initialized with string */

        if  (ourScanner->scanTok.tok != tkStrCon || base->tdTypeKind != TYP_CHAR &&
                                                    base->tdTypeKind != TYP_UCHAR)
        {
//          printf("Base type = '%s'\n", cmpGlobalST->stTypeName(base, NULL, NULL, NULL, true));

            cmpError(ERRbadInitSt, type);
            return  true;
        }

        /* Does the array have a fixed dimension? */

        elems = ourScanner->scanTok.strCon.tokStrLen + 1;

        if  (fsize)
        {
            /* Make sure the string isn't too long */

            if  (elems > fsize)
            {
                if  (elems - 1 == fsize)
                {
                    /* Simply chop off the terminating null */

                    elems--;
                }
                else
                {
                    cmpGenError(ERRstrInitMany, fsize); elems = fsize;
                }
            }
        }

        /* Output as many characters as makes sense */

        buff = makeGenBuff(ourScanner->scanTok.strCon.tokStrVal, elems);
        dest = cmpWriteVarData(dest, buff, elems);

        if  (ourScanner->scan() == tkStrCon)
        {
            UNIMPL(!"adjacent string literals NYI in initializers");
        }

        curl = false;
        goto DONE;
    }

    ourScanner->scan();

    /* Process all the element initializers that are present */

    for (;;)
    {
        /* Special case: byte array initialized with a string */

        if  (ourScanner->scanTok.tok == tkStrCon && (base->tdTypeKind == TYP_CHAR ||
                                                     base->tdTypeKind == TYP_UCHAR))
        {
            genericBuff     buff;
            unsigned        chars;

            do
            {
                /* Does the array have a fixed dimension? */

                chars = ourScanner->scanTok.strCon.tokStrLen + 1;

                if  (fsize)
                {
                    /* Make sure the string isn't too long */

                    if  (elems + chars > fsize)
                    {
                        if  (elems + chars - 1 == fsize)
                        {
                            /* Simply chop off the terminating null */

                            chars--;
                        }
                        else
                        {
                            cmpGenError(ERRstrInitMany, fsize); chars = fsize - elems;
                        }
                    }
                }

                /* Output as many characters as makes sense */

                buff = makeGenBuff(ourScanner->scanTok.strCon.tokStrVal, chars);
                dest   = cmpWriteVarData(dest, buff, chars);
                elems += chars;
            }
            while (ourScanner->scan() == tkStrCon);
        }
        else
        {
            /* Make sure we don't have too many elements */

            if  (++elems > fsize && fsize)
            {
                cmpGenError(ERRarrInitMany, fsize);
                fsize = 0;
            }

            /* Process this particular element's initializer */

            if  (cmpInitVarAny(dest, base, NULL))
                return  true;
        }

        /* Check for more initializers; we allow ", }" for convenience */

        if  (ourScanner->scanTok.tok != tkComma)
            break;

        if  (ourScanner->scan() == tkRCurly)
            break;
    }

    curl = true;

    if  (ourScanner->scanTok.tok != tkRCurly)
    {
        cmpError(ERRnoRcurly);
        return  true;
    }

DONE:

    /* Does the array have fixed dimension? */

    if  (fsize)
    {
        /* We might have to pad the array */

        if  (elems < fsize)
            dest = cmpInitVarPad(dest, (fsize - elems) * cmpGetTypeSize(base));
    }
    else
    {
        /* Store the dimension in the array type */

        if  (varSym)
        {
            DimDef          dims;

#if MGDDATA
            dims = new DimDef;
#else
            dims =    (DimDef)cmpAllocTemp.baAlloc(sizeof(*dims));
#endif

            dims->ddNext     = NULL;
            dims->ddNoDim    = false;
            dims->ddIsConst  = true;
#ifndef NDEBUG
            dims->ddDimBound = true;
#endif
            dims->ddSize     = elems;

            varSym->sdType   = cmpGlobalST->stNewArrType(dims,
                                                         false,
                                                         type->tdArr.tdaElem);
        }
        else
        {
            UNIMPL("can we just bash the array type elem count?");
        }
    }

    /* Swallow the closing "}" and we're done */

    if  (curl)
        ourScanner->scan();

    return  false;
}

/*****************************************************************************
 *
 *  Initialize an array value; returns true if an error was encountered.
 */

bool                compiler::cmpInitVarCls(INOUT memBuffPtr REF dest,
                                                  TypDef         type,
                                                  SymDef         varSym)
{
    Scanner         ourScanner = cmpScanner;

    unsigned        curOffs;

    __int64         curBFval;
    unsigned        curBFsiz;

    SymDef          memSym;

    size_t          size;

    /* We expect to have an unmanaged class here */

    assert(type && type->tdTypeKind == TYP_CLASS && !type->tdIsManaged);
    assert(varSym == NULL || symTab::stMatchTypes(varSym->sdType, type));

    /* If this is the top level, prepare to initialize the variable */

    if  (varSym)
    {
        assert(memBuffIsNull(dest)); dest = cmpInitVarBeg(varSym);
    }

    /* Disallow initialization if there is a base class or a ctor */

    if  (type->tdClass.tdcHasCtor || type->tdClass.tdcBase)
    {
        cmpError(ERRbadBrInit, type);
        return  true;
    }

    /* Make sure the initializer starts with "{" */

    if  (ourScanner->scanTok.tok != tkLCurly)
    {
        cmpError(ERRbadInitSt, type);
        return  true;
    }

    ourScanner->scan();

    /* Process all the member initializers that are present */

    curOffs  = 0;
    curBFsiz = 0;
    curBFval = 0;

    for (memSym = type->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        TypDef          memTyp;
        size_t          memSiz;

        /* We only care about non-static instance variables */

        if  (memSym->sdSymKind != SYM_VAR)
            continue;
        if  (memSym->sdIsStatic)
            continue;

        /* Get hold of the member's type and size */

        memTyp = memSym->sdType;
        memSiz = cmpGetTypeSize(memTyp);

        /* Do we need to insert any padding? */

        if  (memSym->sdVar.sdvOffset != curOffs)
        {
            /* Is there a pending bitfield we need to flush? */

            if  (curBFsiz)
            {
                genericBuff     buff;

                /* Write out the bitfield cell we've collected */

                buff     = makeGenBuff(&curBFval, curBFsiz);
                dest     = cmpWriteVarData(dest, buff, curBFsiz);

                /* Update the offset past the bitfield cell */

                curOffs += curBFsiz;

                /* We don't have an active bitfield cell any more */

                curBFsiz = 0;
                curBFval = 0;
            }

            if  (memSym->sdVar.sdvOffset != curOffs)
                dest = cmpInitVarPad(dest, memSym->sdVar.sdvOffset - curOffs);
        }

        /* Is this a bitfield member? */

        if  (memSym->sdVar.sdvBitfield)
        {
            Tree            init;
            __int64         bval;

            /* Parse the initializer and make sure it's a constant */

            init = cmpParseOneInit(memTyp);
            if  (!init)
                return  true;

            assert(symTab::stMatchTypes(memTyp, init->tnType));

            /* Get hold of the constant value */

            assert(init->tnOper == TN_CNS_INT ||
                   init->tnOper == TN_CNS_LNG);

            bval = (init->tnOper == TN_CNS_INT) ? init->tnIntCon.tnIconVal
                                                : init->tnLngCon.tnLconVal;

            /* Are we in the middle of a bitfield cell already? */

            if  (!curBFsiz)
                curBFsiz = memSiz;

            assert(curBFsiz == memSiz);

            /* Insert the bitfield in the current cell */

            bval  &= ((1 << memSym->sdVar.sdvBfldInfo.bfWidth) - 1);
            bval <<=        memSym->sdVar.sdvBfldInfo.bfOffset;

            /* Make sure we don't have any overlap */

            assert((curBFval & bval) == 0); curBFval |= bval;
        }
        else
        {
            /* Initialize this member */

            if  (cmpInitVarAny(dest, memTyp, NULL))
                return  true;

            /* Update the current offset */

            curOffs = memSym->sdVar.sdvOffset + memSiz;
        }

        /* Check for more initializers; we allow ", }" for convenience */

        if  (ourScanner->scanTok.tok != tkComma)
            break;

        if  (ourScanner->scan() == tkRCurly)
            break;

        /* Only the first member of a union may be initialized */

        if  (type->tdClass.tdcFlavor == STF_UNION)
            break;
    }

    if  (ourScanner->scanTok.tok != tkRCurly)
    {
        cmpError(ERRnoRcurly);
        return  true;
    }

    /* Is there a pending bitfield we need to flush? */

    if  (curBFsiz)
    {
        dest = cmpWriteVarData(dest, makeGenBuff(&curBFval, curBFsiz), curBFsiz);

        curOffs += curBFsiz;
    }

    /* We might have to pad the class value */

    size = cmpGetTypeSize(type);

    if  (size > curOffs)
        dest = cmpInitVarPad(dest, size - curOffs);

    /* Swallow the closing "}" and we're done */

    ourScanner->scan();

    return  false;
}

/*****************************************************************************
 *
 *  Process an initializer of the give type (if 'varSym' is no-NULL we have
 *  the top-level initializer for the given variable).
 *
 *  Returns true if an error has been encountered.
 */

bool                compiler::cmpInitVarAny(INOUT memBuffPtr REF dest, TypDef type,
                                                                       SymDef varSym)
{
    assert(varSym == NULL || symTab::stMatchTypes(varSym->sdType, type));

    for (;;)
    {
        switch (type->tdTypeKind)
        {
        default:
            return  cmpInitVarScl(dest, type, varSym);

        case TYP_ARRAY:

            if  (type->tdIsManaged)
                return  cmpInitVarScl(dest, type, varSym);
            else
                return  cmpInitVarArr(dest, type, varSym);

        case TYP_CLASS:

            if  (type->tdIsManaged)
                return  cmpInitVarScl(dest, type, varSym);
            else
                return  cmpInitVarCls(dest, type, varSym);

        case TYP_TYPEDEF:
            type = cmpActualType(type);
            continue;
        }
    }
}

/*****************************************************************************
 *
 *  Recursively output a vtable contents.
 */

memBuffPtr          compiler::cmpGenVtableSection(SymDef     innerSym,
                                                  SymDef     outerSym,
                                                  memBuffPtr dest)
{
    SymDef          memSym;

    SymTab          ourStab = cmpGlobalST;
    TypDef          baseCls = innerSym->sdType->tdClass.tdcBase;

    if  (baseCls)
    {
        assert(baseCls->tdTypeKind == TYP_CLASS);

        dest = cmpGenVtableSection(baseCls->tdClass.tdcSymbol, outerSym, dest);
    }

    /* Look for any virtuals introduced at this level of the hierarchy */

    for (memSym = innerSym->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        SymDef          fncSym;

        if  (memSym->sdSymKind != SYM_FNC)
            continue;

        fncSym = memSym;

        do
        {
            /* Is the next method a virtual introduced in this class? */

            if  (fncSym->sdFnc.sdfVirtual && !fncSym->sdFnc.sdfOverride)
            {
                SymDef          ovrSym = fncSym;
                mdToken         mtok;

                /* Find the most-derived override of this method */

                if  (innerSym != outerSym)
                {
                    SymDef          clsSym;
                    TypDef          fncType = fncSym->sdType;
                    Ident           fncName = fncSym->sdName;

                    clsSym = outerSym;
                    do
                    {
                        SymDef          tmpSym;

                        /* Look for a matching virtual in this class */

                        tmpSym = ourStab->stLookupScpSym(fncName, clsSym);
                        if  (tmpSym)
                        {
                            tmpSym = ourStab->stFindOvlFnc(tmpSym, fncType);
                            if  (tmpSym)
                            {
                                ovrSym = tmpSym;
                                goto FND_OVR;
                            }
                        }

                        /* Continue with the base class */

                        assert(clsSym->sdType->tdClass.tdcBase);

                        clsSym = clsSym->sdType->tdClass.tdcBase->tdClass.tdcSymbol;
                    }
                    while (clsSym != innerSym);
                }

            FND_OVR:

#ifdef DEBUG
                if  (cmpConfig.ccVerbose >= 2) printf("    [%02u] %s\n", ovrSym->sdFnc.sdfVtblx, cmpGlobalST->stTypeName(ovrSym->sdType, ovrSym, NULL, NULL, true));
#endif

                /* Make sure the method has the expected position */

#ifdef  DEBUG
                assert(ovrSym->sdFnc.sdfVtblx == ++cmpVtableIndex);
#endif

                /* Get hold of the metadata token for the method */

                mtok = cmpILgen->genMethodRef(ovrSym, false);

                /* Output the value of the token */

                dest = cmpWriteVarData(dest, (BYTE*)&mtok, sizeof(mtok));
            }

            /* Continue with the next overload, if any */

            fncSym = fncSym->sdFnc.sdfNextOvl;
        }
        while (fncSym);
    }

    return  dest;
}

/*****************************************************************************
 *
 *  Initialize the contents of the given vtable.
 */

void                compiler::cmpGenVtableContents(SymDef vtabSym)
{
    memBuffPtr      init;

    SymDef          clsSym = vtabSym->sdParent;

    assert(vtabSym);
    assert(vtabSym->sdSymKind == SYM_VAR);
    assert(vtabSym->sdVar.sdvIsVtable);

    assert( clsSym);
    assert( clsSym->sdSymKind == SYM_CLASS);
    assert( clsSym->sdClass.sdcVtableSym == vtabSym);
    assert(!clsSym->sdIsManaged);
    assert(!clsSym->sdType->tdClass.tdcIntf);

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 2) printf("Generating vtable for class '%s':\n", cmpGlobalST->stTypeName(NULL, clsSym, NULL, NULL, false));
#endif

#ifdef  DEBUG
    cmpVtableIndex = 0;
#endif

    init = cmpInitVarBeg(vtabSym, false);

    /* Recursively add all the virtual method entries to the table */

    init = cmpGenVtableSection(clsSym, clsSym, init);

#ifdef  DEBUG
    assert(cmpVtableIndex == clsSym->sdClass.sdcVirtCnt);
#endif

    cmpInitVarEnd(vtabSym);
}

/*****************************************************************************
 *
 *  A class with a "pre-defined" name has just been declared, note whether
 *  it's one of the "well-known" class types, and record it if so.
 */

void                compiler::cmpMarkStdType(SymDef clsSym)
{
    Ident           clsName = clsSym->sdName;

    assert(clsSym->sdParent == cmpNmSpcSystem);
    assert(hashTab::getIdentFlags(clsName) & IDF_PREDEF);

    if  (clsName == cmpIdentType)
        cmpClassType    = clsSym;

    if  (clsName == cmpIdentObject)
        cmpClassObject  = clsSym;

    if  (clsName == cmpIdentString)
        cmpClassString  = clsSym;

    if  (clsName == cmpIdentArray)
        cmpClassArray   = clsSym;

    if  (clsName == cmpIdentExcept)
        cmpClassExcept  = clsSym;

    if  (clsName == cmpIdentRTexcp)
        cmpClassRTexcp  = clsSym;

    if  (clsName == cmpIdentArgIter)
        cmpClassArgIter = clsSym;

    if  (clsName == cmpIdentEnum)
        cmpClassEnum    = clsSym;

    if  (clsName == cmpIdentValType)
        cmpClassValType = clsSym;

    if  (clsName == cmpIdentDeleg ||
         clsName == cmpIdentMulti)
    {
        TypDef          clsTyp = clsSym->sdType;

        clsTyp->tdClass.tdcFnPtrWrap = true;
        clsTyp->tdClass.tdcFlavor    =
        clsSym->sdClass.sdcFlavor    = STF_DELEGATE;
        clsSym->sdClass.sdcBuiltin   = true;

        if  (clsName == cmpIdentDeleg)
            cmpClassDeleg  = clsSym;
        else
            cmpClassMulti = clsSym;
    }

#ifdef  SETS

    if  (clsName == cmpIdentDBhelper)
        cmpClassDBhelper = clsSym;

    if  (clsName == cmpIdentForEach)
        cmpClassForEach  = clsSym;

#endif

    /* Is this one of the "intrinsic" value types? */

    if  (hashTab::getIdentFlags(clsName) & IDF_STDVTP)
    {
        TypDef          clsTyp = clsSym->sdType;

        clsTyp->tdIsIntrinsic       = true;
        clsTyp->tdClass.tdcIntrType = TYP_UNDEF;

        cmpFindStdValType(clsTyp);
    }
}

/*****************************************************************************
 *
 *  Try to display the location of any existing definition of the given symbol.
 */

void                compiler::cmpReportSymDef(SymDef sym)
{
    const   char *  file = NULL;
    unsigned        line;

    if  (sym->sdSrcDefList)
    {
        DefList         defs;

        for (defs = sym->sdSrcDefList; defs; defs = defs->dlNext)
        {
            if  (defs->dlHasDef)
            {
                file = defs->dlComp->sdComp.sdcSrcFile;
                line = defs->dlDef.dsdSrcLno;
                break;
            }
        }
    }
    else
    {
        // UNDONE: Need to look for a member definition in its class
    }

    if  (file)
        cmpGenError(ERRerrPos, file, line);
}

/*****************************************************************************
 *
 *  Report a redefinition error of the given symbol.
 */

void                compiler::cmpRedefSymErr(SymDef oldSym, unsigned err)
{
    if  (err)
        cmpErrorQnm(err, oldSym);

    cmpReportSymDef(oldSym);
}

/*****************************************************************************
 *
 *  Make a permanent copy of the given string value.
 */

ConstStr            compiler::cmpSaveStringCns(const char *str, size_t len)
{
    ConstStr        cnss;
    char    *       buff;

#if MGDDATA

    UNIMPL(!"save string");

#else

    cnss = (ConstStr)cmpAllocPerm.nraAlloc(sizeof(*cnss));
    buff = (char   *)cmpAllocPerm.nraAlloc(roundUp(len+1));

    memcpy(buff, str, len+1);

#endif

    cnss->csLen = len;
    cnss->csStr = buff;

    return  cnss;
}

ConstStr            compiler::cmpSaveStringCns(const wchar *str, size_t len)
{
    ConstStr        cnss;
    char    *       buff;

#if MGDDATA

    UNIMPL(!"save string");

#else

    cnss = (ConstStr)cmpAllocPerm.nraAlloc(sizeof(*cnss));
    buff = (char   *)cmpAllocPerm.nraAlloc(roundUp(len+1));

    wcstombs(buff, str, len+1);

#endif

    cnss->csLen = len;
    cnss->csStr = buff;

    return  cnss;
}

/*****************************************************************************
 *
 *  Process a constant declaration: the caller supplies the variable symbol,
 *  and optionally the initialization expression (if 'init' is NULL, the
 *  initializer will be read from the input).
 */

bool                compiler::cmpParseConstDecl(SymDef  varSym,
                                                Tree    init,
                                                Tree  * nonCnsPtr)
{
    bool            OK;
    constVal        cval;
    ConstVal        cptr;

    assert(varSym && varSym->sdSymKind == SYM_VAR);

    assert(varSym->sdCompileState == CS_DECLARED);

    /* Remember that we've found an initializer */

    varSym->sdVar.sdvHadInit = true;

    /* With managed data we don't have to worry about memory leaks */

#if MGDDATA
    cptr = new constVal;
#endif

    /* Evaluate the constant value (making sure to detect recursion) */

    varSym->sdVar.sdvInEval = true;
    OK = cmpParser->parseConstExpr(cval, init, varSym->sdType, nonCnsPtr);
    varSym->sdVar.sdvInEval = false;

    if  (OK)
    {

#if!MGDDATA

        /* Create a permanent home for the constant value */

        cptr = (constVal*)cmpAllocPerm.nraAlloc(sizeof(cval)); *cptr = cval;

        /* If the constant is a string, find a permanent home for it */

        if  (cval.cvIsStr)
        {
            ConstStr        cnss = cval.cvValue.cvSval;

            cptr->cvValue.cvSval = cmpSaveStringCns(cnss->csStr, cnss->csLen);
        }

#endif

        varSym->sdCompileState  = CS_CNSEVALD;

        /* Remember the fact that this is a constant variable */

        varSym->sdVar.sdvConst  = true;
        varSym->sdVar.sdvCnsVal = cptr;
    }

    return  OK;
}

/*****************************************************************************
 *
 *  See if the specified function is the program's entry point (the caller
 *  has already checked its name).
 */

void                compiler::cmpChk4entryPt(SymDef sym)
{
    SymDef          scope = sym->sdParent;
    TypDef          type  = sym->sdType;

#ifdef  OLD_IL
    if  (cmpConfig.ccOILgen && scope != cmpGlobalNS) return;
#endif

    /* Don't bother looking for an entry point in DLL's */

    if  (cmpConfig.ccOutDLL)
        return;


    assert(scope == cmpGlobalNS);


    /* Make sure the signature is correct for main() */

    if  (type->tdFnc.tdfRett->tdTypeKind != TYP_INT &&
         type->tdFnc.tdfRett->tdTypeKind != TYP_VOID)
        goto BAD_MAIN;

    if  (type->tdFnc.tdfArgs.adVarArgs)
        goto BAD_MAIN;
    if  (type->tdFnc.tdfArgs.adCount != 1)
        goto BAD_MAIN;

    assert(type->tdFnc.tdfArgs.adArgs);
    assert(type->tdFnc.tdfArgs.adArgs->adNext == NULL);

    type = type->tdFnc.tdfArgs.adArgs->adType;

    cmpFindStringType();

    if  (type->tdTypeKind != TYP_ARRAY)
        goto BAD_MAIN;
    if  (type->tdArr.tdaElem != cmpRefTpString)
        goto BAD_MAIN;
    if  (type->tdIsUndimmed == false)
        goto BAD_MAIN;
    if  (type->tdArr.tdaDcnt != 1)
        goto BAD_MAIN;


    /* The function must not be static */

    if  (sym->sdIsStatic)
        goto BAD_MAIN;

    /* This function will be the main entry point */

    cmpEntryPointCls      = sym->sdParent;
    sym->sdFnc.sdfEntryPt = true;
    return;

BAD_MAIN:

    /* In file scope this is not allowed */

    if  (scope == cmpGlobalNS)
        cmpError(ERRbadMain);
}

/*****************************************************************************
 *
 *  Bring the given file scope symbol to "declared" state.
 */

void                compiler::cmpDeclFileSym(ExtList decl, bool fullDecl)
{
    SymTab          ourSymTab  = cmpGlobalST;
    Parser          ourParser  = cmpParser;
    Scanner         ourScanner = cmpScanner;

    parserState     save;
    TypDef          base;
    SymDef          scope;
    declMods        memMod;

    SymXinfo        xtraList   = NULL;

#ifdef DEBUG

    if  (cmpConfig.ccVerbose >= 2)
    {
        printf("%s file-scope symbol: '", fullDecl ? "Defining " : "Declaring");

        if  (decl->dlQualified)
            cmpGlobalST->stDumpQualName(decl->mlQual);
        else
            printf("%s", hashTab::identSpelling(decl->mlName));

        printf("'\n");
    }

#endif

    /* Prepare scoping state for the symbol */

    cmpCurScp = NULL;
    cmpCurCls = NULL;
    scope     =
    cmpCurNS  = cmpGlobalNS;
    cmpCurST  = cmpGlobalST;

    cmpBindUseList(decl->dlUses);

    /* Is this a qualified (member) symbol declaration? */

    if  (decl->dlQualified)
    {
        /* Bind the qualified name */

        scope = cmpBindQualName(decl->mlQual, true);

        if  (scope)
        {
            switch (scope->sdSymKind)
            {
            case SYM_CLASS:
                cmpCurCls = scope;
                cmpCurNS  = cmpSymbolNS(scope);
                break;

            case SYM_NAMESPACE:
                cmpCurNS  = scope;
                break;

            default:
                // This sure looks bogus, it will be flagged below
                break;
            }

            /* We may need to insert some "using" entries */

            if  (cmpCurNS != cmpGlobalNS)
                cmpCurUses = cmpParser->parseInsertUses(cmpCurUses, cmpCurNS);
        }
    }

    /* Start reading source text from the definition */

    cmpParser->parsePrepText(&decl->dlDef, decl->dlComp, save);

    /* Check for a linkage specifier, custom attribute, and all the other prefix stuff */

    if  (decl->dlPrefixMods)
    {
        for (;;)
        {
            switch (ourScanner->scanTok.tok)
            {
                SymXinfo        linkDesc;

                unsigned        attrMask;
                genericBuff     attrAddr;
                size_t          attrSize;
                SymDef          attrCtor;

            case tkLBrack:
            case tkEXTERN:
                linkDesc = ourParser->parseBrackAttr(true, ATTR_MASK_SYS_IMPORT, &memMod);
                xtraList = cmpAddXtraInfo(xtraList, linkDesc);
                continue;

            case tkATTRIBUTE:
                attrCtor = cmpParser->parseAttribute(ATGT_Methods|ATGT_Fields|ATGT_Constructors|ATGT_Properties,
                                                     attrMask,
                                                     attrAddr,
                                                     attrSize);
                if  (attrSize)
                {
                    xtraList = cmpAddXtraInfo(xtraList, attrCtor,
                                                        attrMask,
                                                        attrSize,
                                                        attrAddr);
                }
                continue;
            }

            break;
        }
    }
    else
    {
        /* Parse any leading modifiers */

        ourParser->parseDeclMods((accessLevels)decl->dlDefAcc, &memMod);
    }

    /* Is this a constructor body? */

    if  (decl->dlIsCtor)
    {
        base = cmpTypeVoid;
    }
    else
    {
        /* Parse the type specification */

        base = ourParser->parseTypeSpec(&memMod, true);
    }

    /* We have the type, now parse any declarators that follow */

    for (;;)
    {
        Ident           name;
        QualName        qual;
        TypDef          type;
        SymDef          newSym;

        /* Parse the next declarator */

        name = ourParser->parseDeclarator(&memMod,
                                          base,
                                          (dclrtrName)(DN_REQUIRED|DN_QUALOK),
                                          &type,
                                          &qual,
                                          true);

        if  ((name || qual) && type)
        {
            SymDef          oldSym;

//          if  (name && !strcmp(name->idSpelling(), "printf")) forceDebugBreak();

            /* Make sure we bind the type */

            cmpBindType(type, false, false);

            /* Is the name qualified? */

            scope = cmpGlobalNS;

            if  (qual)
            {
                /* We don't expect member constants to be pre-declared */

                assert(fullDecl);

                scope = cmpBindQualName(qual, true);
                if  (!scope)
                {
                    /* Here if we have a disastrous error */

                ERR:

                    if  (ourScanner->scanTok.tok == tkComma)
                        goto NEXT_DECL;
                    else
                        goto DONE_DECL;
                }

                /* Get hold of the last name in the sequence */

                name = qual->qnTable[qual->qnCount - 1];

                /* Do we have a definition of a class member? */

                if  (scope->sdSymKind == SYM_CLASS)
                {
                    /* Make sure the class has been declared */

                    cmpDeclSym(scope);

                    /* Look for the member in the class */

                    if  (type->tdTypeKind == TYP_FNC)
                    {
                        ovlOpFlavors    ovlOper = OVOP_NONE;

                        if  (name == scope->sdName)
                        {
                            ovlOper = (memMod.dmMod & DM_STATIC) ? OVOP_CTOR_STAT
                                                                 : OVOP_CTOR_INST;
                        }

                        newSym = (ovlOper == OVOP_NONE) ? ourSymTab->stLookupClsSym(   name, scope)
                                                        : ourSymTab->stLookupOperND(ovlOper, scope);
                        if  (newSym)
                        {
                            if  (newSym->sdSymKind != SYM_FNC)
                            {
                                UNIMPL(!"fncs and vars can't overload, right?");
                            }

                            /* Make sure we find the proper overloaded function */

                            newSym = ourSymTab->stFindOvlFnc(newSym, type);
                        }
                    }
                    else
                    {
                        newSym = ourSymTab->stLookupClsSym(name, scope);

                        if  (newSym && newSym->sdSymKind != SYM_VAR)
                        {
                            UNIMPL(!"fncs and vars can't overload, right?");
                        }
                    }

                    /* Was the member found in the class? */

                    if  (newSym)
                    {
                        assert(newSym->sdCompileState >= CS_DECLARED);

                        /* Mark the method (and its class) as having a definition */

                        newSym->sdIsDefined         = true;
                        scope->sdClass.sdcHasBodies = true;

                        /* Record the member symbol in the declaration descriptor */

                        decl->mlSym = newSym;

                        /* Transfer the definition record to the class symbol */

                        cmpRecordMemDef(scope, decl);

                        /* Do we have a function or data member ? */

                        if  (newSym->sdSymKind == SYM_FNC)
                        {
                            /* Copy the type to capture argument names etc. */

                            newSym->sdType = cmpMergeFncType(newSym, type);
                        }
                        else
                        {
                            /* Remember that the member has an initializer */

                            if  (ourScanner->scanTok.tok == tkAsg)
                                newSym->sdVar.sdvHadInit = true;
                        }
                    }
                    else
                    {
                        cmpError(ERRnoSuchMem, scope, qual, type);
                    }

                    goto DONE_DECL;
                }

                /* The name better belong to a namespace */

                if  (scope->sdSymKind != SYM_NAMESPACE)
                {
                    cmpError(ERRbadQualName, qual);
                    goto ERR;
                }
            }

            /* Have we already pre-declared the symbol? */

            if  (decl->mlSym)
            {
                /* This is the second pass for this constant symbol */

                assert(fullDecl);

                /* Get hold of the symbol (and make sure we didn't mess up) */

                assert(memMod.dmMod & DM_CONST);
                newSym = decl->mlSym;
//              printf("Revisit symbol [%08X->%08X] '%s' (declname = '%s')\n", decl, newSym, newSym->sdSpelling(), name->idSpelling());
                assert(newSym->sdName == name);
                assert(symTab::stMatchTypes(newSym->sdType, type));
                newSym->sdCompileState = CS_DECLARED;

                /* Now go evaluate the constant value */

                assert(ourScanner->scanTok.tok == tkAsg);

                goto EVAL_CONST;
            }

            /* Declare a symbol for the name */

            oldSym = ourSymTab->stLookupNspSym(name, NS_NORM, scope);

            if  (memMod.dmMod & DM_TYPEDEF)
            {
                assert(fullDecl);

                /* typedefs never overload, of course */

                if  (oldSym)
                {
                REDEF:

                    cmpRedefSymErr(oldSym, (scope == cmpGlobalNS) ? ERRredefName
                                                                  : ERRredefMem);
                }
                else
                {
                    TypDef      ttyp;

                    /* Declare the typedef symbol */

                    newSym = ourSymTab->stDeclareSym(name,
                                                     SYM_TYPEDEF,
                                                     NS_NORM,
                                                     scope);

                    /* Force the typedef type to be created */

                    ttyp = newSym->sdTypeGet();

                    /* Store the actual type in the typedef */

                    ttyp->tdTypedef.tdtType = cmpDirectType(type);

                    /* This symbol has been declared */

                    newSym->sdCompileState = CS_DECLARED;
                }
            }
            else
            {
                switch (type->tdTypeKind)
                {
                case TYP_FNC:

                    assert(fullDecl);

                    /* Might this be an overloaded function? */

                    if  (oldSym)
                    {
                        SymDef          tmpSym;

                        /* Can't overload global variables and functions */

                        if  (oldSym->sdSymKind != SYM_FNC)
                            goto REDEF;

                        /* Look for a function with a matching arglist */

                        tmpSym = ourSymTab->stFindOvlFnc(oldSym, type);
                        if  (tmpSym)
                        {
                            /* Is this the same exact function? */

                            if  (symTab::stMatchTypes(tmpSym->sdType, type))
                            {
                                /*
                                    Transfer the new type to the symbol if
                                    there is a definition so that the names
                                    of arguments are right for the body.
                                 */

                                if  (ourScanner->scanTok.tok == tkLCurly)
                                    tmpSym->sdType = type;

                                // UNDONE: check that function attributes agree (and transfer them), etc.
                                // UNDONE: check that default argument values aren't redefined

                                if  (tmpSym->sdIsDefined && ourScanner->scanTok.tok == tkLCurly)
                                {
                                    cmpError(ERRredefBody, tmpSym);
                                    newSym = tmpSym;
                                    goto CHK_INIT;
                                }

                                newSym = tmpSym;
                                type   = cmpMergeFncType(newSym, type);

                                /* Do we have any security/linkage info? */

                                if  (xtraList)
                                {
                                    /* Record the linkage/security specification(s) */

                                    newSym->sdFnc.sdfExtraInfo = xtraList;

                                    /* We can't import this sucker any more */

                                    newSym->sdIsImport         = false;
                                    newSym->sdFnc.sdfMDtoken   = 0;
                                }
                            }
                            else
                            {
                                /* Presumably the return types don't agree */

                                cmpError(ERRbadOvl, tmpSym, name, type);
                            }

                            goto CHK_INIT;
                        }
                        else
                        {
                            /* It's a new overload, declare a symbol for it */

                            newSym = cmpCurST->stDeclareOvl(oldSym);
                        }
                    }
                    else
                    {
                        /* This is a brand new function */

                        newSym = ourSymTab->stDeclareSym(name,
                                                         SYM_FNC,
                                                         NS_NORM,
                                                         scope);

                    }

                    /* Is the function marked as "unsafe" ? */

                    if  (memMod.dmMod & DM_UNSAFE)
                        newSym->sdFnc.sdfUnsafe = true;

                    /* Remember the type of the function */

                    newSym->sdType = type;

                    /* Record the access level */

                    newSym->sdAccessLevel = (accessLevels)memMod.dmAcc;

                    /* Record any linkage/security/custom attribute info */

                    newSym->sdFnc.sdfExtraInfo = xtraList;

                    /* This symbol has been declared */

                    newSym->sdCompileState = CS_DECLARED;

                    /* Is the function named 'main' ? */

                    if  (name == cmpIdentMain)
                        cmpChk4entryPt(newSym);

                    break;

                case TYP_VOID:
                    cmpError(ERRbadVoid, name);
                    break;

                default:

                    /* File-scope variables never overload */

                    if  (oldSym)
                        goto REDEF;

                    if  ((memMod.dmMod & (DM_CONST|DM_EXTERN)) == (DM_CONST|DM_EXTERN))
                    {
                        cmpError(ERRextCns);
                        memMod.dmMod &= ~DM_CONST;
                    }

                    /* Declare the variable symbol */

                    newSym = ourSymTab->stDeclareSym(name,
                                                     SYM_VAR,
                                                     NS_NORM,
                                                     scope);
                    newSym->sdType         = type;
                    newSym->sdAccessLevel  = (accessLevels)memMod.dmAcc;

                    /* Global variables may not have a managed type for now */

                    if  (type->tdIsManaged && !qual)
                    {
                        cmpError(ERRmgdGlobVar);
                        break;
                    }

                    /* Are we fully declaring this symbol at this point? */

                    if  (!fullDecl)
                    {
                        DefList         memDef;
                        ExtList         extDef;

                        /* No, we've done enough at this stage */

                        assert(decl->dlHasDef);
                        assert(ourScanner->scanTok.tok == tkAsg);

                        /* Transfer the definition info to the method symbol */

                        memDef = ourSymTab->stRecordSymSrcDef(newSym,
                                                              decl->dlComp,
                                                              decl->dlUses,
                                                              decl->dlDef.dsdBegPos,
//                                                            decl->dlDef.dsdEndPos,
                                                              decl->dlDef.dsdSrcLno,
//                                                            decl->dlDef.dsdSrcCol,
                                                              true);
                        memDef->dlHasDef   = true;
                        memDef->dlDeclSkip = decl->dlDeclSkip;

                        /* Record the symbol so that we don't try to redeclare it */

                        assert(decl  ->dlExtended);
                        assert(memDef->dlExtended); extDef = (ExtList)memDef;

//                      printf("Defer   symbol [%08X->%08X] '%s'\n",   decl, newSym, newSym->sdSpelling());
//                      printf("Defer   symbol [%08X->%08X] '%s'\n", extDef, newSym, newSym->sdSpelling());

                        extDef->mlSym = decl->mlSym = newSym;

                        newSym->sdVar.sdvDeferCns = (ourScanner->scanTok.tok == tkAsg);
                        goto DONE_DECL;
                    }

                    /* This symbol has been declared */

                    newSym->sdCompileState = CS_DECLARED;

                    /* Remember whether assignment is allowed */

                    if  (memMod.dmMod & DM_SEALED)
                        newSym->sdIsSealed = true;

                    /* Is there an explicit initialization? */

                    if  (decl->dlHasDef)
                    {
                        DefList         memDef;

                        /* Transfer the definition info to the variable symbol */

                        memDef = ourSymTab->stRecordSymSrcDef(newSym,
                                                              decl->dlComp,
                                                              decl->dlUses,
                                                              decl->dlDef.dsdBegPos,
//                                                            decl->dlDef.dsdEndPos,
                                                              decl->dlDef.dsdSrcLno);
                        memDef->dlHasDef   = true;
                        memDef->dlDeclSkip = decl->dlDeclSkip;
                    }
                    else
                    {
                        if  (!(memMod.dmMod & DM_EXTERN))
                            newSym->sdIsDefined = true;
                    }

                    break;
                }
            }
        }

    CHK_INIT:

        /* Is there an initializer or method body? */

        switch (ourScanner->scanTok.tok)
        {
        case tkAsg:

            /* Remember that we've found an initializer */

            if  (newSym && newSym->sdSymKind == SYM_VAR)
            {
                newSym->sdVar.sdvHadInit = true;
            }
            else
            {
                /* Make sure we don't have a typedef or function */

                if  ((memMod.dmMod & DM_TYPEDEF) || type->tdTypeKind == TYP_FNC)
                    cmpError(ERRbadInit);
            }

            /* Process the initializer */

            if  (memMod.dmMod & DM_CONST)
            {
            EVAL_CONST:

                /* Presumably the initial value of the symbol follows */

                if  (ourScanner->scan() == tkLCurly)
                {
                    /* This better be a struct or array */

                    switch (type->tdTypeKind)
                    {
                    case TYP_CLASS:
                    case TYP_ARRAY:
                        ourScanner->scanSkipText(tkLCurly, tkRCurly);
                        if  (ourScanner->scanTok.tok == tkRCurly)
                             ourScanner->scan();
                        break;

                    default:
                        cmpError(ERRbadBrInit, type);
                        break;
                    }

                    newSym->sdCompileState = CS_DECLARED;
                    break;
                }

                /* Parse and evaluate the constant value */

                cmpParseConstDecl(newSym);
            }
            else
            {
                type = cmpActualType(type);

                /* For now, we simply skip non-constant initializers */

                ourScanner->scanSkipText(tkNone, tkNone, tkComma);

                /* Special case: is the variable an undimensioned array? */

                if  (type->tdTypeKind == TYP_ARRAY && type->tdIsManaged == false
                                                   && type->tdIsUndimmed)
                {
                    SymList         list;

                    /* Add this variable to the appropriate list */

#if MGDDATA
                    list = new SymList;
#else
                    list =    (SymList)cmpAllocTemp.baAlloc(sizeof(*list));
#endif

                    list->slSym  = newSym;
                    list->slNext = cmpNoDimArrVars;
                                   cmpNoDimArrVars = list;
                }
            }

            break;

        case tkLCurly:

            if  (type->tdTypeKind != TYP_FNC)
                cmpError(ERRbadLcurly);

            /* Record the position of the function body */

            if  (newSym)
            {
                SymDef          clsSym;
                DefList         memDef;

                /* Mark the method as having a body now */

                newSym->sdIsDefined = true;

                /* If this is a class member, mark the class */

                clsSym = newSym->sdParent;
                if  (clsSym->sdSymKind == SYM_CLASS)
                    clsSym->sdClass.sdcHasBodies = true;

                /* Transfer the definition info to the method symbol */

                memDef = ourSymTab->stRecordSymSrcDef(newSym,
                                                      decl->dlComp,
                                                      decl->dlUses,
                                                      decl->dlDef.dsdBegPos,
//                                                    decl->dlDef.dsdEndPos,
                                                      decl->dlDef.dsdSrcLno);
                memDef->dlHasDef   = true;
                memDef->dlDeclSkip = decl->dlDeclSkip;
            }

            decl->dlHasDef = true;
            goto DONE_DECL;

        default:

            if  (memMod.dmMod & DM_CONST)
                cmpError(ERRnoCnsInit);

            break;
        }

    NEXT_DECL:

        /* Are there any more declarators? */

        if  (ourScanner->scanTok.tok != tkComma)
            break;

        /* Swallow the "," and go get the next declarator */

        ourScanner->scan();
    }

    /* Make sure we've consumed the expected amount of text */

    if  (ourScanner->scanTok.tok != tkSColon)
        cmpError(ERRnoSemic);

DONE_DECL:

    /* We're done reading source text from the definition */

    cmpParser->parseDoneText(save);
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  Add an XMLclass/element custom attribute to the given list.
 */

SymXinfo            compiler::cmpAddXMLattr(SymXinfo xlist, bool elem, unsigned num)
{
    SymDef          clsSym;
    Tree            argList;
    unsigned        tgtMask;

    if  (!cmpXPathCls)
        cmpFindXMLcls();

    if  (elem)
    {
        clsSym  = cmpXMLattrElement;
        tgtMask = ATGT_Fields;
        argList = cmpCreateIconNode(NULL, num, TYP_UINT);
        argList = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argList, NULL);
    }
    else
    {
        clsSym  = cmpXMLattrClass;
        tgtMask = ATGT_Classes;
        argList = NULL;
    }

    if  (clsSym)
    {
        unsigned        attrMask;
        genericBuff     attrAddr;
        size_t          attrSize;
        SymDef          attrCtor;

        attrCtor = cmpBindAttribute(clsSym, argList, tgtMask, attrMask, attrAddr, attrSize);
        if  (attrSize)
            xlist = cmpAddXtraInfo(xlist, attrCtor, attrMask, attrSize, attrAddr);
    }

    return  xlist;
}

/*****************************************************************************
 *
 *  Find the next instance data member.
 */

SymDef              compiler::cmpNextInstDM(SymDef memList, SymDef *memSymPtr)
{
    SymDef          memSym = NULL;

    if  (memList)
    {
        SymDef          xmlSym = memList->sdParent->sdClass.sdcElemsSym;

        do
        {
            if  (memList->sdSymKind == SYM_VAR &&
                 memList->sdIsStatic == false  && memList != xmlSym)
            {
                memSym = memList;
                         memList = memList->sdNextInScope;

                break;
            }

            memList = memList->sdNextInScope;
        }
        while (memList);
    }

    if  (memSymPtr) *memSymPtr = memSym;

    return  memList;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  Report any modifiers in the given mask as errors.
 */

void                compiler::cmpModifierError(unsigned err, unsigned mods)
{
    HashTab         hash = cmpGlobalHT;

    if  (mods & DM_CONST    ) cmpError(err, hash->tokenToIdent(tkCONST    ));
    if  (mods & DM_STATIC   ) cmpError(err, hash->tokenToIdent(tkSTATIC   ));
    if  (mods & DM_EXTERN   ) cmpError(err, hash->tokenToIdent(tkEXTERN   ));
    if  (mods & DM_INLINE   ) cmpError(err, hash->tokenToIdent(tkINLINE   ));
    if  (mods & DM_EXCLUDE  ) cmpError(err, hash->tokenToIdent(tkEXCLUSIVE));
    if  (mods & DM_VIRTUAL  ) cmpError(err, hash->tokenToIdent(tkVIRTUAL  ));
    if  (mods & DM_ABSTRACT ) cmpError(err, hash->tokenToIdent(tkABSTRACT ));
    if  (mods & DM_OVERRIDE ) cmpError(err, hash->tokenToIdent(tkOVERRIDE ));
    if  (mods & DM_VOLATILE ) cmpError(err, hash->tokenToIdent(tkVOLATILE ));
    if  (mods & DM_MANAGED  ) cmpError(err, hash->tokenToIdent(tkMANAGED  ));
    if  (mods & DM_UNMANAGED) cmpError(err, hash->tokenToIdent(tkUNMANAGED));
}

void                compiler::cmpMemFmod2Error(tokens tok1, tokens tok2)
{
    HashTab         hash = cmpGlobalHT;

    cmpGenError(ERRfmModifier2, hash->tokenToIdent(tok1)->idSpelling(),
                                hash->tokenToIdent(tok2)->idSpelling());
}

/*****************************************************************************
 *
 *  Add a data member to the specified class.
 */

SymDef              compiler::cmpDeclDataMem(SymDef     clsSym,
                                             declMods   memMod,
                                             TypDef     type,
                                             Ident      name)
{
    SymDef          memSym;
    unsigned        badMod;
    name_space      nameSP;

    /* Make sure the modifiers look OK */

    badMod = memMod.dmMod & ~(DM_STATIC|DM_CONST|DM_SEALED|DM_MANAGED|DM_UNMANAGED);
    if  (badMod)
        cmpModifierError(ERRdmModifier, badMod);

    /* Is this an interface member? */

    if  (clsSym->sdClass.sdcFlavor == STF_INTF)
    {
        cmpError(ERRintfDM);
    }

    /* See if the class already has a data member with a matching name */

    memSym = cmpCurST->stLookupClsSym(name, clsSym);
    if  (memSym)
    {
        cmpRedefSymErr(memSym, ERRredefMem);
        return  NULL;
    }

    /* Create a member symbol and add it to the class */

#ifdef  SETS
    nameSP = (hashTab::getIdentFlags(name) & IDF_XMLELEM) ? NS_HIDE
                                                          : NS_NORM;
#else
    nameSP = NS_NORM;
#endif

    memSym = cmpCurST->stDeclareSym(name, SYM_VAR, nameSP, clsSym);

    /* Remember the type, access level and other attributes of the member */

    memSym->sdType = type;

    assert((memMod.dmMod & DM_TYPEDEF) == 0);

    if  (memMod.dmMod & DM_STATIC)
        memSym->sdIsStatic = true;

    if  (memMod.dmMod & DM_SEALED)
        memSym->sdIsSealed = true;

    memSym->sdAccessLevel  = (accessLevels)memMod.dmAcc;
    memSym->sdIsMember     = true;

    /* Remember whether this is a member of a managed class */

    memSym->sdIsManaged    = clsSym->sdIsManaged;

    /* The member has been declared */

    memSym->sdCompileState = CS_DECLARED;

    return  memSym;
}

/*****************************************************************************
 *
 *  Add a function member (i.e. a method) to the specified class.
 */

SymDef              compiler::cmpDeclFuncMem(SymDef     clsSym,
                                             declMods   memMod,
                                             TypDef     type,
                                             Ident      name)
{
    ovlOpFlavors    ovlOper;

    SymDef          oldSym;
    SymDef          memSym;

//  printf("Declare method '%s'\n", cmpGlobalST->stTypeName(type, NULL, name, NULL, false));

    /* "extern" is never allowed on a method except for sysimport's */

    if  (memMod.dmMod & DM_EXTERN)
        cmpModifierError(ERRfmModifier, DM_EXTERN);

    /* Check for any other illegal modifier combinations */

#if 0
    if  ((memMod.dmMod & (DM_STATIC|DM_SEALED)) == (DM_STATIC|DM_SEALED))
        cmpMemFmod2Error(tkSTATIC, tkSEALED);
#endif

    /* This an overloaded operator / ctor if the name is a token */

    ovlOper = OVOP_NONE;

    if  (hashTab::tokenOfIdent(name) != tkNone)
    {
        unsigned        argc = 0;
        ArgDef          args = type->tdFnc.tdfArgs.adArgs;

        if  (args)
        {
            argc++;

            args = args->adNext;
            if  (args)
            {
                argc++;

                if  (args->adNext)
                    argc++;
            }
        }

        ovlOper = cmpGlobalST->stOvlOperIndex(hashTab::tokenOfIdent(name), argc);

        if  (ovlOper == OVOP_PROP_GET || ovlOper == OVOP_PROP_SET)
        {
            memSym = cmpCurST->stDeclareSym(NULL, SYM_FNC, NS_NORM, clsSym);
            goto FILL;
        }
    }
    else if (name == clsSym->sdName && type->tdTypeKind == TYP_FNC)
    {
        ovlOper = (memMod.dmMod & DM_STATIC) ? OVOP_CTOR_STAT : OVOP_CTOR_INST;
    }

    /* See if the class already has a method with a matching name */

    oldSym = (ovlOper == OVOP_NONE) ? cmpCurST->stLookupClsSym(   name, clsSym)
                                    : cmpCurST->stLookupOperND(ovlOper, clsSym);

    if  (oldSym)
    {
        SymDef          tmpSym;

        if  (oldSym->sdSymKind != SYM_FNC)
        {
            cmpRedefSymErr(oldSym, ERRredefMem);
            return  NULL;
        }

        /* Look for an existing method with an identical signature */

        tmpSym = cmpCurST->stFindOvlFnc(oldSym, type);
        if  (tmpSym)
        {
            cmpRedefSymErr(tmpSym, ERRredefMem);
            return  NULL;
        }

        /* The new method is a new overload */

        memSym = cmpCurST->stDeclareOvl(oldSym);

        /* Copy over some info from the existing method */

        memSym->sdFnc.sdfOverload = oldSym->sdFnc.sdfOverload;
    }
    else
    {
        // UNDONE: Need to check the base class!

        /* Create a member symbol and add it to the class */

        if  (ovlOper == OVOP_NONE)
            memSym = cmpCurST->stDeclareSym (name, SYM_FNC, NS_NORM, clsSym);
        else
            memSym = cmpCurST->stDeclareOper(ovlOper               , clsSym);
    }

FILL:

    /* Remember the type, access level and other attributes of the member */

    memSym->sdType = type;

    assert((memMod.dmMod & DM_TYPEDEF) == 0);

    if  (memMod.dmMod & DM_STATIC  ) memSym->sdIsStatic         = true;
    if  (memMod.dmMod & DM_SEALED  ) memSym->sdIsSealed         = true;
    if  (memMod.dmMod & DM_EXCLUDE ) memSym->sdFnc.sdfExclusive = true;
    if  (memMod.dmMod & DM_ABSTRACT) memSym->sdIsAbstract       = true;
    if  (memMod.dmMod & DM_NATIVE  ) memSym->sdFnc.sdfNative    = true;

    memSym->sdAccessLevel  = (accessLevels)memMod.dmAcc;

    memSym->sdIsMember     = true;

    /* Remember whether this is a member of a managed class */

    memSym->sdIsManaged    = clsSym->sdIsManaged;

    /* The member is now in "declared" state */

    memSym->sdCompileState = CS_DECLARED;

    /* Is the method marked as "unsafe" ? */

    if  (memMod.dmMod & DM_UNSAFE)
        memSym->sdFnc.sdfUnsafe = true;


    /* Record the fact that the class has some method bodies */

    clsSym->sdClass.sdcHasMeths = true;

    return  memSym;
}

/*****************************************************************************
 *
 *  Add a property member to the specified class.
 */

SymDef              compiler::cmpDeclPropMem(SymDef     clsSym,
                                             TypDef     type,
                                             Ident      name)
{
    SymDef          propSym;

    SymTab          ourStab = cmpGlobalST;

//  if  (!strcmp(name->idSpelling(), "<name>")) printf("Declare property '%s'\n", name->idSpelling());

    propSym = ourStab->stLookupProp(name, clsSym);

    if  (propSym)
    {
        SymDef          tsym;

        /* Check for a redefinition of an earlier property */

        tsym = (propSym->sdSymKind == SYM_PROP) ? ourStab->stFindSameProp(propSym, type)
                                                : propSym;

        if  (tsym)
        {
            cmpRedefSymErr(tsym, ERRredefMem);
            return  NULL;
        }

        /* The new property is a new overload */

        propSym = ourStab->stDeclareOvl(propSym);
    }
    else
    {
        propSym = ourStab->stDeclareSym(name, SYM_PROP, NS_NORM, clsSym);
    }

    propSym->sdIsMember    = true;
    propSym->sdIsManaged   = true;
    propSym->sdType        = type;

    return  propSym;
}

/*****************************************************************************
 *
 *  Save a record for the given symbol and source position, for some unknown
 *  but limited amount of time.
 */

ExtList             compiler::cmpTempMLappend(ExtList       list,
                                              ExtList     * lastPtr,
                                              SymDef        sym,
                                              SymDef        comp,
                                              UseList       uses,
                                              scanPosTP     dclFpos,
                                              unsigned      dclLine)
{
    ExtList         entry;

    if  (cmpTempMLfree)
    {
        entry = cmpTempMLfree;
                cmpTempMLfree = (ExtList)entry->dlNext;
    }
    else
    {
#if MGDDATA
        entry = new ExtList;
#else
        entry =    (ExtList)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif
    }

    entry->dlNext          = NULL;

    entry->dlDef.dsdBegPos = dclFpos;
//  entry->dlDef.dsdEndPos = dclEpos;
    entry->dlDef.dsdSrcLno = dclLine; assert(dclLine < 0xFFFF);
//  entry->dlDef.dsdSrcCol = dclCol;  assert(dclCol  < 0xFFFF);

    entry->dlHasDef        = true;
    entry->dlComp          = comp;
    entry->dlUses          = uses;
    entry->mlSym           = sym;

    /* Now add the entry to the caller's list */

    if  (list)
        (*lastPtr)->dlNext = entry;
    else
        list               = entry;

    *lastPtr = entry;

    /* Record the entry in the member symbol */

    assert(sym->sdSrcDefList == NULL); sym->sdSrcDefList = entry;

    return  list;
}

inline
void                compiler::cmpTempMLrelease(ExtList entry)
{
    entry->dlNext = cmpTempMLfree;
                    cmpTempMLfree = entry;
}

/*****************************************************************************
 *
 *  Bring the given delegate to "declared" state.
 */

void                compiler::cmpDeclDelegate(DefList decl,
                                              SymDef  dlgSym, accessLevels acc)
{
    Parser          ourParser = cmpParser;

    TypDef          dlgTyp;
    unsigned        badMod;
    parserState     save;

    declMods        mods;
    Ident           name;
    TypDef          type;

    /* Get hold of the class type */

    dlgTyp = dlgSym->sdTypeGet(); assert(dlgTyp && dlgTyp->tdClass.tdcSymbol == dlgSym);

    /* Set the base class to "Delegate"/"MultiDelegate" and fix other things as well */

    if  (dlgSym->sdClass.sdcMultiCast)
    {
        cmpMultiRef();  dlgTyp->tdClass.tdcBase = cmpClassMulti->sdType;
    }
    else
    {
        cmpDelegRef();  dlgTyp->tdClass.tdcBase = cmpClassDeleg->sdType;
    }

    dlgSym->sdCompileState  = CS_DECLARED;

    /* Start reading from the delegate declaration source text */

    ourParser->parsePrepText(&decl->dlDef, decl->dlComp, save);

    /* Parse the declaration - it looks like any other, really */

    ourParser->parseDeclMods(acc, &mods);

    /* Make sure the modifiers look OK */

    badMod = mods.dmMod & ~(DM_MANAGED|DM_UNMANAGED);
    if  (badMod)
        cmpModifierError(ERRdmModifier, badMod);

    /* Swallow "asynch" if present */

    if  (cmpScanner->scanTok.tok == tkASYNCH)
        cmpScanner->scan();

    /* Now parse the type spec and a single declarator */

    type = ourParser->parseTypeSpec(&mods, true);

    name = ourParser->parseDeclarator(&mods,
                                      type,
                                      DN_REQUIRED,
                                      &type,
                                      NULL,
                                      true);

    if  (name && type)
    {
        SymDef          msym;
        ArgDscRec       args;
        ArgDef          last;
        TypDef          tmpt;

        cmpBindType(type, false, false);

        /* Delegates must be declared as functions */

        if  (type->tdTypeKind != TYP_FNC)
        {
            cmpError(ERRdlgNonFn);
            goto DONE_DLG;
        }

        if  (cmpScanner->scanTok.tok != tkSColon)
            cmpError(ERRnoCmSc);

        /* Multicast delegates must not return a non-void value */

        if  (dlgSym->sdClass.sdcMultiCast)
        {
            if  (cmpDirectType(type->tdFnc.tdfRett)->tdTypeKind != TYP_VOID)
                cmpError(ERRmulDlgRet);
        }

        /* Declare a "Invoke" method with the delegate's type */

        mods.dmAcc = ACL_PUBLIC;
        mods.dmMod = 0;

        /* First see if the user himself has supplied an "Invoke" method */

        msym = cmpCurST->stLookupClsSym(cmpIdentInvoke, dlgSym);
        if  (msym && msym->sdSymKind == SYM_FNC)
        {
            if  (cmpCurST->stFindOvlFnc(msym, type))
                goto DONE_INVK;
        }

        msym = cmpDeclFuncMem(dlgSym, mods, type, cmpIdentInvoke); assert(msym);
        msym->sdIsSealed        = true;
        msym->sdIsDefined       = true;
        msym->sdIsImplicit      = true;
        msym->sdFnc.sdfVirtual  = true;
        msym->sdFnc.sdfRThasDef = true;
        msym->sdFnc.sdfOverride = true;

    DONE_INVK:

        /* Are we supposed to do the "asynch" thing? */

        if  (!dlgSym->sdClass.sdcAsyncDlg)
            goto DONE_ASYNC;

        /* Make sure we have the various hard-wired types we'll need */

        if  (!cmpAsyncDlgRefTp)
        {
            SymDef          asym;
            Ident           aname;

            aname = cmpGlobalHT->hashString("AsyncCallback");
            asym  = cmpGlobalST->stLookupNspSym(aname, NS_NORM, cmpNmSpcSystem);

            if  (!asym || asym->sdSymKind         != SYM_CLASS
                       || asym->sdClass.sdcFlavor != STF_DELEGATE)
            {
                UNIMPL(!"didn't find class 'System.AsyncCallbackDelegate', now what?");
            }

            cmpAsyncDlgRefTp = asym->sdTypeGet()->tdClass.tdcRefTyp;
        }

        if  (!cmpIAsyncRsRefTp)
        {
            SymDef          asym;
            Ident           aname;

            aname = cmpGlobalHT->hashString("IAsyncResult");
            asym  = cmpGlobalST->stLookupNspSym(aname, NS_NORM, cmpNmSpcSystem);

            if  (!asym || asym->sdSymKind         != SYM_CLASS
                       || asym->sdClass.sdcFlavor != STF_INTF)
            {
                UNIMPL(!"didn't find interface 'System.IAsyncResult', now what?");
            }

            cmpIAsyncRsRefTp = asym->sdTypeGet()->tdClass.tdcRefTyp;
        }

        /* Declare the "BeginInvoke" method */

        cmpGlobalST->stExtArgsBeg(args, last, type->tdFnc.tdfArgs);
        cmpGlobalST->stExtArgsAdd(args, last, cmpAsyncDlgRefTp, NULL);
        cmpGlobalST->stExtArgsAdd(args, last, cmpObjectRef()  , NULL);
        cmpGlobalST->stExtArgsEnd(args);

        tmpt = cmpGlobalST->stNewFncType(args, cmpIAsyncRsRefTp);

        msym = cmpDeclFuncMem(dlgSym, mods, tmpt, cmpIdentInvokeBeg); assert(msym);
        msym->sdIsSealed        = true;
        msym->sdIsDefined       = true;
        msym->sdIsImplicit      = true;
        msym->sdFnc.sdfVirtual  = true;
        msym->sdFnc.sdfRThasDef = true;
        msym->sdFnc.sdfOverride = true;

        /* Declare the   "EndInvoke" method */

        cmpGlobalST->stExtArgsBeg(args, last, type->tdFnc.tdfArgs, false, true);
        cmpGlobalST->stExtArgsAdd(args, last, cmpIAsyncRsRefTp, NULL);
        cmpGlobalST->stExtArgsEnd(args);

        tmpt = cmpGlobalST->stNewFncType(args, type->tdFnc.tdfRett);

        msym = cmpDeclFuncMem(dlgSym, mods, tmpt, cmpIdentInvokeEnd); assert(msym);
        msym->sdIsSealed        = true;
        msym->sdIsDefined       = true;
        msym->sdIsImplicit      = true;
        msym->sdFnc.sdfVirtual  = true;
        msym->sdFnc.sdfRThasDef = true;
        msym->sdFnc.sdfOverride = true;

    DONE_ASYNC:

        /* Declare the ctor as "ctor(Object obj, naturalint fnc)" */

#if     defined(__IL__) && !defined(_MSC_VER)
        cmpParser->parseArgListNew(args,
                                   2,
                                   true, cmpFindObjectType(), A"obj",
//                                       cmpTypeInt         , A"fnc",
                                         cmpTypeNatInt      , A"fnc",
                                         NULL);
#else
        cmpParser->parseArgListNew(args,
                                   2,
                                   true, cmpFindObjectType(),  "obj",
//                                       cmpTypeInt         ,  "fnc",
                                         cmpTypeNatInt      ,  "fnc",
                                         NULL);
#endif

        type = cmpGlobalST->stNewFncType(args, cmpTypeVoid);

        /* First see if the user himself has supplied a constructor */

        msym = cmpCurST->stLookupOperND(OVOP_CTOR_INST, dlgSym);
        if  (msym && msym->sdSymKind == SYM_FNC)
        {
            if  (cmpCurST->stFindOvlFnc(msym, type))
                goto DONE_DLG;
        }

        msym = cmpDeclFuncMem(dlgSym, mods, type, dlgSym->sdName);
        msym->sdIsDefined       = true;
        msym->sdFnc.sdfCtor     = true;
        msym->sdIsImplicit      = true;
        msym->sdFnc.sdfRThasDef = true;
    }

DONE_DLG:

    /* We're finished with this declaration */

    cmpParser->parseDoneText(save);
}

void                compiler::cmpFindHiddenBaseFNs(SymDef fncSym,
                                                   SymDef clsSym)
{
    SymTab          ourSymTab = cmpGlobalST;
    Ident           fncName   = fncSym->sdName;

    for (;;)
    {
        SymDef          baseMFN = ourSymTab->stLookupClsSym(fncName, clsSym);
        SymDef          ovlSym;

        if  (baseMFN)
        {
            /* Look for any hidden methods in the base */

            for (ovlSym = baseMFN; ovlSym; ovlSym = ovlSym->sdFnc.sdfNextOvl)
            {
                if  (!ourSymTab->stFindOvlFnc(fncSym, ovlSym->sdType))
                    cmpWarnQnm(WRNhideVirt, ovlSym);
            }

            return;
        }

        if  (!clsSym->sdType->tdClass.tdcBase)
            break;

        clsSym = clsSym->sdType->tdClass.tdcBase->tdClass.tdcSymbol;
    }
}

/*****************************************************************************
 *
 *  The given class is not explicitly 'abstract' but it contains/inherits
 *  the specified abstract method; report the appropriate diagnostic.
 */

void                compiler::cmpClsImplAbs(SymDef clsSym, SymDef fncSym)
{
    if      (cmpConfig.ccPedantic)
        cmpErrorQSS(ERRimplAbst, clsSym, fncSym);
    else
        cmpWarnSQS (WRNimplAbst, clsSym, fncSym);

    clsSym->sdIsAbstract = true;
}

/*****************************************************************************
 *
 *  We've finished declaring a class that includes some interfaces. Check any
 *  methods that implement interface methods and all that.
 */

void                compiler::cmpCheckClsIntf(SymDef clsSym)
{
    TypDef          clsTyp;
    SymDef          baseSym;

    assert(clsSym->sdSymKind == SYM_CLASS);

    /* Get hold of the class type and the base class symbol (if any) */

    clsTyp  = clsSym->sdType;

    baseSym = NULL;
    if  (clsTyp->tdClass.tdcBase)
        baseSym = clsTyp->tdClass.tdcBase->tdClass.tdcSymbol;

    /* For each interface method see if it's being implemented by the class */

    for (;;)
    {
        /* Check the interfaces of the current class */

        if  (clsTyp->tdClass.tdcIntf)
            cmpCheckIntfLst(clsSym, baseSym, clsTyp->tdClass.tdcIntf);

        /* Continue with the base class, if it has any interfaces */

        clsTyp = clsTyp->tdClass.tdcBase;
        if  (!clsTyp)
            break;
        if  (!clsTyp->tdClass.tdcHasIntf)
            break;
    }
}

SymDef              compiler::cmpFindIntfImpl(SymDef    clsSym,
                                              SymDef    ifcSym,
                                              SymDef  * impOvlPtr)
{
    SymDef          oldSym;
    SymDef          ovlSym = NULL;
    SymDef          chkSym = NULL;

    Ident           name = ifcSym->sdName;

    if  (hashTab::tokenOfIdent(name) != tkNone)
    {
        UNIMPL(!"intfimpl for an operator?! getoutahere!");
    }
    else
    {
        /* Linear search, eh ? Hmmm .... */

        for (oldSym = clsSym->sdScope.sdScope.sdsChildList;
             oldSym;
             oldSym = oldSym->sdNextInScope)
        {
            if  (oldSym->sdName    != name)
                continue;
            if  (oldSym->sdSymKind != SYM_FNC)
                continue;
            if  (oldSym->sdFnc.sdfIntfImpl == false)
                continue;

            ovlSym = oldSym;

            for (chkSym = oldSym; chkSym; chkSym = chkSym->sdFnc.sdfNextOvl)
            {
                assert(chkSym->sdFnc.sdfIntfImpl);
                assert(chkSym->sdNameSpace == NS_HIDE);

                if  (chkSym->sdFnc.sdfIntfImpSym == ifcSym)
                    goto DONE;
            }
        }
    }

DONE:

    if  (impOvlPtr)
        *impOvlPtr = ovlSym;

    return  chkSym;
}

/*****************************************************************************
 *
 *  Check the given list of interfaces (and any interfaces they inherit) for
 *  methods not implemented by the current class. Returns true if t
 */

void                compiler::cmpCheckIntfLst(SymDef        clsSym,
                                              SymDef        baseSym,
                                              TypList       intfList)
{
    SymTab          ourStab = cmpGlobalST;

    declMods        mfnMods;

    /* Process all interfaces in the list */

    while (intfList)
    {
        TypDef          intfType = intfList->tlType;
        SymDef          intfSym;

        assert(intfType->tdTypeKind        == TYP_CLASS);
        assert(intfType->tdClass.tdcFlavor == STF_INTF);

        /* Does the interface inherit any others? */

        if  (intfType->tdClass.tdcIntf)
            cmpCheckIntfLst(clsSym, baseSym, intfType->tdClass.tdcIntf);

        /* Check all the methods in this interface */

        for (intfSym = intfType->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
             intfSym;
             intfSym = intfSym->sdNextInScope)
        {
            SymDef          intfOvl;
            SymDef          implSym;

            if  (intfSym->sdSymKind != SYM_FNC)
                continue;
            if  (intfSym->sdFnc.sdfCtor)
                continue;

            assert(intfSym->sdFnc.sdfOper == OVOP_NONE);

            /* Look for a matching member in the class we're declaring */

            implSym = ourStab->stLookupClsSym(intfSym->sdName, clsSym);
            if  (implSym && implSym->sdSymKind != SYM_FNC)
                implSym = NULL;

            /* Process all overloaded flavors of the interface method */

            intfOvl = intfSym;
            do
            {
                SymDef          baseCls;
                SymDef          implOvl;

                /* Look for a matching method defined in our class */

                implOvl = implSym ? ourStab->stFindOvlFnc(implSym, intfOvl->sdType)
                                  : NULL;

                if  (implOvl)
                {
                    /* Mark the symbol as implementing an interface method */

                    implSym->sdFnc.sdfIsIntfImp = true;
                    goto NEXT_OVL;
                }

                /* Let's try the base classes as well */

                for (baseCls = clsSym;;)
                {
                    TypDef          baseTyp;

                    baseTyp = baseCls->sdType->tdClass.tdcBase;
                    if  (!baseTyp)
                        break;

                    assert(baseTyp->tdTypeKind == TYP_CLASS);
                    baseCls = baseTyp->tdClass.tdcSymbol;
                    assert(baseCls->sdSymKind  == SYM_CLASS);

                    implSym = ourStab->stLookupClsSym(intfSym->sdName, baseCls);
                    if  (implSym && implSym->sdSymKind != SYM_FNC)
                        continue;

                    if  (ourStab->stFindOvlFnc(implSym, intfOvl->sdType))
                        goto NEXT_OVL;
                }

                /* Last chance - check for a specific interface impl */

                if  (cmpFindIntfImpl(clsSym, intfOvl))
                    goto NEXT_OVL;

                /*
                    The class didn't define a matching method at all, but we
                    may need to check the base class since we need to detect
                    whether the class leaves any intf methods unimplemented.

                    If we already know that the class is abstract, we won't
                    bother with the check, of course.
                 */

                if  (!clsSym->sdIsAbstract)
                {
                    if  (baseSym)
                    {
                        /* See if a base class implements this method */

                        implOvl = ourStab->stFindInBase(intfOvl, baseSym);
                        if  (implOvl)
                        {
                            if  (ourStab->stFindOvlFnc(implOvl, intfOvl->sdType))
                                goto NEXT_OVL;
                        }
                    }

                    /* This interface method isn't implemented by the class */

                    cmpClsImplAbs(clsSym, intfOvl);
                }

                /* Add a matching abstract method to the class */

                mfnMods.dmAcc = ACL_PUBLIC;
                mfnMods.dmMod = DM_ABSTRACT|DM_VIRTUAL;

                implSym = cmpDeclFuncMem(clsSym, mfnMods, intfOvl->sdType, intfOvl->sdName);
//              printf("Pulling intf method: '%s'\n", cmpGlobalST->stTypeName(implSym->sdType, implSym, NULL, NULL, true));
                implSym->sdFnc.sdfVirtual = true;

                assert(implSym->sdIsAbstract);
                assert(implSym->sdAccessLevel == ACL_PUBLIC);

            NEXT_OVL:

                intfOvl = intfOvl->sdFnc.sdfNextOvl;
            }
            while (intfOvl);
        }

        intfList = intfList->tlNext;
    }
}

/*****************************************************************************
 *
 *  Declare the default constructor for the given class.
 */

void                compiler::cmpDeclDefCtor(SymDef clsSym)
{
    declMods        ctorMod;
    SymDef          ctorSym;

    // UNDONE: unmanaged classes may need a ctor as well!

    clearDeclMods(&ctorMod);

    ctorSym = cmpDeclFuncMem(clsSym, ctorMod, cmpTypeVoidFnc, clsSym->sdName);
    if  (ctorSym)
    {
        ctorSym->sdFnc.sdfCtor = true;
        ctorSym->sdIsImplicit  = true;
        ctorSym->sdIsDefined   = true;
        ctorSym->sdAccessLevel = ACL_PUBLIC;    // ISSUE: is this correct?

//      printf("dcl ctor %08X for '%s'\n", ctorSym, clsSym->sdSpelling());

        ctorSym->sdSrcDefList  = cmpGlobalST->stRecordMemSrcDef(clsSym->sdName,
                                                                NULL,
                                                                cmpCurComp,
                                                                cmpCurUses,
                                                                NULL,
                                                                0);
    }
}

/*****************************************************************************
 *
 *  Bring the given class to "declared" state.
 */

void                compiler::cmpDeclClass(SymDef clsSym, bool noCnsEval)
{
    SymTab          ourSymTab  = cmpGlobalST;
    Parser          ourParser  = cmpParser;
    Scanner         ourScanner = cmpScanner;

    unsigned        saveRec;

    TypDef          clsTyp;
    DefList         clsDef;
    ExtList         clsMem;

    bool            tagged;
    SymDef          tagSym;

    bool            isIntf;

    TypDef          baseCls;
    unsigned        nextVtbl;
    bool            hasVirts;
    bool            hasCtors;
    bool            hadOvlds;

    bool            hadMemInit;

    ExtList         constList;
    ExtList         constLast;

    unsigned        dclSkip = 0;

#ifdef  SETS
    unsigned        XMLecnt = 0;
#endif

    bool            rest = false;
    parserState     save;

    assert(clsSym && clsSym->sdSymKind == SYM_CLASS);

    /* If we're already at the desired compile-state, we're done */

    if  (clsSym->sdCompileState >= CS_DECLARED)
    {
        /* Does the class have any deferred initializers? */

        if  (clsSym->sdClass.sdcDeferInit && !cmpDeclClassRec)
        {
            IniList         init = cmpDeferCnsList;
            IniList         last = NULL;

            NO_WAY(!"this never seems to be reached -- until now, that is");

            // LAME: linear search

            while (init->ilCls != clsSym)
            {
                last = init;
                init = init->ilNext;
                assert(init);
            }

            if  (last)
                last->ilNext    = init->ilNext;
            else
                cmpDeferCnsList = init->ilNext;

            cmpEvalMemInits(NULL, NULL, false, init);
        }

        return;
    }

    /* Detect amd report recursive death */

    if  (clsSym->sdCompileState == CS_DECLSOON)
    {
        // UNDONE: set the source position for the error message

        cmpError(ERRcircDep, clsSym);
        clsSym->sdCompileState = CS_DECLARED;
        return;
    }

    if  (clsSym->sdIsImport)
    {
        cycleCounterPause();
        clsSym->sdClass.sdcMDimporter->MDimportClss(0, clsSym, 0, true);
        cycleCounterResume();
        return;
    }

    /* Until we get there, we're on our way there */

    clsSym->sdCompileState = CS_DECLSOON;

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 2) printf("Declare/1 class '%s'\n", clsSym->sdSpelling());
#endif

    cmpCurScp  = NULL;
    cmpCurCls  = clsSym;
    cmpCurNS   = ourSymTab->stNamespOfSym(clsSym);
    cmpCurST   = ourSymTab;

    hasVirts   = false;
    hasCtors   = false;
    hadOvlds   = false;

    constList  =
    constLast  = NULL;

    hadMemInit = false;

    /*
        If we've been invoked recursively, we'll have to defer processing
        of initializers, lest we get into an invalid recursive situation.
     */

    saveRec = cmpDeclClassRec++;
    if  (saveRec)
        noCnsEval = true;

    /* Is this an instance of a generic class ? */

    if  (clsSym->sdClass.sdcSpecific)
    {
        cmpDeclInstType(clsSym);
        return;
    }

    /* Assume that we have a plain old data type until proven otherwise */

#ifdef  SETS
    clsSym->sdClass.sdcPODTclass = true;
#endif

    /* The following loops over all the definition entries for the symbol */

    clsDef = clsSym->sdSrcDefList;
    if  (!clsDef)
        goto DONE_DEF;

LOOP_DEF:

    accessLevels    acc;
    TypDef          baseTp;
    declMods        memMod;

    SymDef          clsComp;
    UseList         clsUses;

    bool            memCond;
    bool            memDepr;
    Ident           memName;
    TypDef          memType;

    __int32         tagVal;
    bool            tagDef;

    bool            isCtor;

    bool            oldStyleDecl;

    SymXinfo        xtraList;

//  if  (!strcmp(clsSym->sdSpelling(), "<class name here>")) forceDebugBreak();

    /* Get hold of the class type */

    clsTyp = clsSym->sdTypeGet(); assert(clsTyp && clsTyp->tdClass.tdcSymbol == clsSym);

    /* Do we have a definition of the class? */

    if  (!clsDef->dlHasDef)
        goto NEXT_DEF;

    /* Tell everyone which compilation unit the source we're processing belongs to */

    cmpCurComp = clsComp = clsDef->dlComp;

    /* Prepare in case we have to report any diagnostics */

    cmpSetErrPos(&clsDef->dlDef, clsDef->dlComp);

    /* Bind any "using" declarations the class may need */

    clsUses = clsDef->dlUses; cmpBindUseList(clsUses);

    /* Mark the class type as defined */

    clsSym->sdIsDefined = true;

    /* What kind of a beast do we have ? */

    isIntf = false;

    switch (clsSym->sdClass.sdcFlavor)
    {
    default:
        break;

    case STF_UNION:
    case STF_STRUCT:
        if  (clsSym->sdIsManaged)
            clsSym->sdIsSealed = true;
        break;

    case STF_INTF:

        isIntf = true;

        /* Interfaces are abstract by default */

        clsSym->sdIsAbstract = true;
        break;
    }

    /* Is this a delegate, by any chance? */

    if  (clsSym->sdClass.sdcFlavor == STF_DELEGATE && !clsSym->sdClass.sdcBuiltin)
    {
        cmpDeclDelegate(clsDef, clsSym, ACL_DEFAULT);
        goto RET;
    }

    /* Is this an old-style file-scope class? */

    oldStyleDecl = clsSym->sdClass.sdcOldStyle = (bool)clsDef->dlOldStyle;

    /* Are we processing a tagged union? */

    tagged = clsSym->sdClass.sdcTagdUnion;

    /* If this is a generic class, we better read its "header" section */

    assert(clsSym->sdClass.sdcGeneric == false || clsDef->dlHasBase);

    /* First process any base class specifications */

    if  (clsDef->dlHasBase)
    {
        TypList         intf;

        assert(rest == false);

        /* Plain old data types don't have a base */

#ifdef  SETS
        clsSym->sdClass.sdcPODTclass = false;
#endif

        /* Start reading from the class name and skip over it */

        cmpParser->parsePrepText(&clsDef->dlDef, clsDef->dlComp, save);

        /* Remember that we've started reading from a saved text section */

        rest = true;

        /* Check for various things that may precede the class itself */

        for (;;)
        {
            switch (ourScanner->scanTok.tok)
            {
                SymXinfo        linkDesc;

                AtComment       atcList;

                unsigned        attrMask;
                genericBuff     attrAddr;
                size_t          attrSize;
                SymDef          attrCtor;

            case tkLBrack:
                linkDesc = ourParser->parseBrackAttr(true, ATTR_MASK_SYS_STRUCT|ATTR_MASK_GUID);
                clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo,
                                                              linkDesc);
                clsSym->sdClass.sdcMarshInfo = true;
                continue;

            case tkCAPABILITY:

                clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo,
                                                              ourParser->parseCapability(true));
                continue;

            case tkPERMISSION:

                clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo,
                                                              ourParser->parsePermission(true));
                continue;

            case tkAtComment:

                for (atcList = ourScanner->scanTok.atComm.tokAtcList;
                     atcList;
                     atcList = atcList->atcNext)
                {
                    switch (atcList->atcFlavor)
                    {
                    case AC_COM_CLASS:
                        break;

                    case AC_DLL_STRUCT:

                        clsSym->sdClass.sdcMarshInfo = true;
                        clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo,
                                                                      atcList);
                        break;

                    case AC_DLL_IMPORT:

                        if  (atcList->atcInfo.atcImpLink->ldDLLname == NULL ||
                             atcList->atcInfo.atcImpLink->ldSYMname != NULL)
                        {
                            cmpError(ERRclsImpName);
                        }

                        // Fall through ....

                    case AC_COM_INTF:
                    case AC_COM_REGISTER:
                        clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo,
                                                                      atcList);
                        break;

                    case AC_DEPRECATED:
                        clsSym->sdIsDeprecated = true;
                        break;

                    default:
                        cmpError(ERRbadAtCmPlc);
                        break;
                    }

                    ourScanner->scan();
                }

                continue;

            case tkATTRIBUTE:

                /* Check for the "class __attribute(AttributeTargets.xxx)" case */

                if  (ourScanner->scanLookAhead() == tkLParen)
                    break;

                 /* Parse the attribute blob */

                attrCtor = cmpParser->parseAttribute((clsSym->sdClass.sdcFlavor == STF_INTF) ? ATGT_Interfaces : ATGT_Classes,
                                                     attrMask,
                                                     attrAddr,
                                                     attrSize);

                /* Add the attribute to the list of "extra info" */

                if  (attrSize)
                {
                    clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo,
                                                                  attrCtor,
                                                                  attrMask,
                                                                  attrSize,
                                                                  attrAddr);

                    if  (attrMask)
                    {
                        clsSym->sdClass.sdcAttribute = true;

                        /* Did the ctor arglist include the "allowDups" value ? */

                        if  (attrSize >= 8)
                        {
                            /*
                                The following is utterly hideous, but then
                                so is the feature itself, isn't it?
                             */

                            if  (((BYTE*)attrAddr)[6])
                                clsSym->sdClass.sdcAttrDupOK = true;
                        }
                    }
                }

                continue;

            default:

                /* If we have "class", swallow it */

                if  (ourScanner->scanTok.tok == tkCLASS)
                    ourScanner->scan();

                break;
            }
            break;
        }

        if  (ourScanner->scanTok.tok == tkLParen)
        {
            Ident       tagName;
            SymDef      parent;

            /* This must be a tagged union */

            assert(tagged);

            /* Get hold of the tag member name and make sure it's kosher */

            ourScanner->scan(); assert(ourScanner->scanTok.tok == tkID);

            tagName = ourScanner->scanTok.id.tokIdent;

            /* Look for a member with a matching name */

            for (parent = clsSym->sdParent;;)
            {
                assert(parent->sdSymKind == SYM_CLASS);

                tagSym = cmpCurST->stLookupClsSym(tagName, parent);
                if  (tagSym)
                    break;

                if  (!symTab::stIsAnonUnion(parent))
                    break;

                parent = parent->sdParent;
            }

            if  (!tagSym || tagSym->sdSymKind != SYM_VAR
                         || tagSym->sdIsStatic)
            {
                /* There is no suitable data member with a matching name */

                cmpError(ERRbadUTag, tagName);
            }
            else
            {
                var_types           vtp = tagSym->sdType->tdTypeKindGet();

                /* Make sure the member has an integer/enum/bool type */

                if  (!varTypeIsIntegral(vtp))
                {
                    cmpError(ERRbadUTag, tagName);
                }
                else
                {
                    /* Everything looks good, record the tag symbol */

                    clsSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(clsSym->sdClass.sdcExtraInfo, tagSym, XI_UNION_TAG);
                }
            }

            /* Make sure the closing ")" is present */

            ourScanner->scan(); assert(ourScanner->scanTok.tok == tkRParen);
            ourScanner->scan();
        }

        for (;;)
        {
            TypDef          type;

            /* Do we have a generic class formal argument list? */

            if  (ourScanner->scanTok.tok == tkLT)
            {
                GenArgDsc       genArgLst;
                unsigned        genArgNum;

                assert(clsSym->sdClass.sdcGeneric);

#ifdef  SETS

                if  (clsSym->sdName == cmpIdentGenBag  && cmpCurNS == cmpGlobalNS)
                    cmpClassGenBag  = clsSym;
                if  (clsSym->sdName == cmpIdentGenLump && cmpCurNS == cmpGlobalNS)
                    cmpClassGenLump = clsSym;

#endif

                /* Pass 1: create a member symbol + type for each formal */

                for (genArgLst = clsSym->sdClass.sdcArgLst, genArgNum = 1;
                     genArgLst;
                     genArgLst = genArgLst->gaNext        , genArgNum++)
                {
                    GenArgDscF      paramDesc = (GenArgDscF)genArgLst;
                    Ident           paramName = paramDesc->gaName;
                    SymDef          paramSym;

                    assert(genArgLst->gaBound == false);

                    /* Declare a member symbol for the parameter */

                    paramSym = ourSymTab->stLookupScpSym(paramName, clsSym);
                    if  (paramSym)
                    {
                        cmpRedefSymErr(paramSym, ERRredefMem);
                        paramDesc->gaMsym = NULL;
                        continue;
                    }

                    paramSym = paramDesc->gaMsym = ourSymTab->stDeclareSym(paramName,
                                                                           SYM_CLASS,
                                                                           NS_NORM,
                                                                           clsSym);

                    paramSym->sdAccessLevel     = ACL_PRIVATE;
                    paramSym->sdIsManaged       = true;
                    paramSym->sdClass.sdcFlavor = STF_GENARG;
                    paramSym->sdClass.sdcGenArg = genArgNum;
                    paramSym->sdCompileState    = CS_DECLARED;

//                  printf("Generic arg [%08X] '%s'\n", paramSym, paramSym->sdSpelling());

                    /* Make sure we create the class type */

                    paramSym->sdTypeGet()->tdIsGenArg = true;

                    /* Set the default required base class / interface list */

                    paramDesc->gaBase = NULL; // cmpClassObject->sdType;
                    paramDesc->gaIntf = NULL;
                }

                /* Pass 2: process the formal argument bounds */

                assert(ourScanner->scanTok.tok == tkLT);

                for (genArgLst = clsSym->sdClass.sdcArgLst;
                     genArgLst;
                     genArgLst = genArgLst->gaNext)
                {
                    GenArgDscF      paramDesc = (GenArgDscF)genArgLst;
                    SymDef          paramSym  = paramDesc->gaMsym;
                    TypDef          paramType = paramSym->sdType;

                    assert(genArgLst->gaBound == false);

                    /* The argument symbol is NULL if it had an error earlier */

                    if  (paramSym)
                    {
                        ourScanner->scan(); assert(ourScanner->scanTok.tok == tkCLASS);
                        ourScanner->scan(); assert(ourScanner->scanTok.tok == tkID);
                        ourScanner->scan();

                        if  (ourScanner->scanTok.tok == tkColon)
                        {
                            UNIMPL(!"process generic arg - base");
                        }

                        if  (ourScanner->scanTok.tok == tkIMPLEMENTS)
                        {
                            UNIMPL(!"process generic arg - intf");
                        }

                        if  (ourScanner->scanTok.tok == tkINCLUDES)
                        {
                            UNIMPL(!"process generic arg - incl");
                        }
                    }
                    else
                    {
                        UNIMPL(!"skip over erroneuos generic arg");
                    }

                    paramType->tdClass.tdcBase = paramDesc->gaBase;
                    paramType->tdClass.tdcIntf = paramDesc->gaIntf;

                    /* Make sure things are still in synch */

                    assert(ourScanner->scanTok.tok == tkComma && genArgLst->gaNext != NULL ||
                           ourScanner->scanTok.tok == tkGT    && genArgLst->gaNext == NULL);
                }

                assert(ourScanner->scanTok.tok == tkGT); ourScanner->scan();
            }

            /* Is there are an "attribute" modifier? */

            if  (ourScanner->scanTok.tok == tkATTRIBUTE)
            {
                constVal        cval;

                /* Remember that this class has been marked as an attribute */

                clsSym->sdClass.sdcAttribute = true;

                if  (ourScanner->scan() != tkLParen)
                    continue;

                cmpParser->parseConstExpr(cval);
                continue;
            }

            /* Check for context info */

            if  (ourScanner->scanTok.tok == tkAPPDOMAIN)
            {
                clsTyp->tdClass.tdcContext = 1;
                ourScanner->scan();
                continue;
            }

            if  (ourScanner->scanTok.tok == tkCONTEXTFUL)
            {
                clsTyp->tdClass.tdcContext = 2;
                ourScanner->scan();
                continue;
            }

            /* Is there a base class? */

            if  (ourScanner->scanTok.tok == tkColon)
            {
                if  (isIntf)
                    goto INTFLIST;

                /* Swallow the ":" and parse the base class */

                if  (ourScanner->scan() == tkPUBLIC)
                     ourScanner->scan();

                type = cmpGetClassSpec(false);
                if  (type)
                {
                    assert(type->tdTypeKind == TYP_CLASS);

                    clsTyp->tdClass.tdcBase = type;

                    /* Make sure this inheritance is legal */

                    if  (type->tdIsManaged != clsTyp->tdIsManaged)
                        cmpError(ERRxMgdInh, type);

                    /* Managed struct can't inherit from anything */

                    if  (clsTyp->tdIsManaged && clsTyp->tdClass.tdcFlavor == STF_STRUCT)
                        cmpError(ERRstrInhCls, type);

                    /* Inherit context info by default */

                    if  (!clsTyp->tdClass.tdcContext)
                        clsTyp->tdClass.tdcContext = type->tdClass.tdcContext;

                    /* Make sure context stuff agrees with base */

                    if  (clsTyp->tdClass.tdcContext != type->tdClass.tdcContext)
                    {
                        SymDef      baseCls = type->tdClass.tdcSymbol;

                        if  ( clsSym->sdParent == cmpNmSpcSystem &&
                             baseCls->sdParent == cmpNmSpcSystem
                                        &&
                             !strcmp(baseCls->sdSpelling(), "MarshalByRefObject") &&
                             !strcmp( clsSym->sdSpelling(), "ContextBoundObject"))
                        {
                            // Allow this as a special case
                        }
                        else
                            cmpError(ERRxCtxInh, type);
                    }
                }

                if  (ourScanner->scanTok.tok != tkINCLUDES &&
                     ourScanner->scanTok.tok != tkIMPLEMENTS)
                    break;
            }

            /* Is there an interface list? */

            if  (ourScanner->scanTok.tok == tkINCLUDES ||
                 ourScanner->scanTok.tok == tkIMPLEMENTS)
            {
                TypList         intfList;
                TypList         intfLast;

            INTFLIST:

                if  (!clsSym->sdIsManaged)
                    cmpError(ERRunmIntf);

                /* Swallow the "includes" and parse the interface list */

                intfList =
                intfLast = NULL;

                do
                {
                    TypDef          type;

                    ourScanner->scan();

                    /* Get the next interface and add it to the list */

                    type = cmpGetClassSpec(true);
                    if  (type)
                        intfList = ourSymTab->stAddIntfList(type, intfList, &intfLast);
                }
                while (ourScanner->scanTok.tok == tkComma);

                clsTyp->tdClass.tdcIntf    = intfList;
                clsTyp->tdClass.tdcHasIntf = true;

                if  (ourScanner->scanTok.tok != tkColon)
                    break;
            }

            if  (ourScanner->scanTok.tok == tkLCurly)
                break;

            assert(ourScanner->scanTok.tok != tkEOF); ourScanner->scan();
        }

        /* We're done reading source text from the class base */

        assert(rest); cmpParser->parseDoneText(save); rest = false;

        /* Make sure any base classes / interfaces are declared */

        if  (clsTyp->tdClass.tdcBase)
        {
            SymDef          baseSym = clsTyp->tdClass.tdcBase->tdClass.tdcSymbol;

            cmpDeclClsNoCns(baseSym);

            if  (baseSym->sdIsSealed)
                cmpError(ERRsealedInh, baseSym);
        }

        for (intf = clsTyp->tdClass.tdcIntf; intf; intf = intf->tlNext)
            cmpDeclClsNoCns(intf->tlType->tdClass.tdcSymbol);
    }
    else
    {
        assert(tagged == false);
    }

//  printf("Class ctx = [%u] '%s'\n", clsTyp->tdClass.tdcContext, clsSym->sdSpelling());

    /* Record the base class */

    baseCls = clsTyp->tdClass.tdcBase;

    if  (clsTyp->tdIsManaged)
    {
        /* The default base of a managed class is "Object" */

        if  (!baseCls)
        {
            cmpFindObjectType();

            /* Special case: "Object" doesn't have a base class */

            if  (clsTyp == cmpClassObject->sdType)
                goto DONE_BASE;

            baseCls = clsTyp->tdClass.tdcBase = cmpClassObject->sdType;
        }

        clsTyp->tdClass.tdcHasIntf |= baseCls->tdClass.tdcHasIntf;
    }

DONE_BASE:

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 2) printf("Declare/2 class '%s'\n", clsSym->sdSpelling());
#endif

    /* Determine where we'll be adding virtuals */

    nextVtbl = baseCls ? baseCls->tdClass.tdcSymbol->sdClass.sdcVirtCnt
                       : 0;

    /* Determine default management mode */

    cmpManagedMode = clsSym->sdIsManaged;

    /* No access specifiers have been found yet */

    acc = (oldStyleDecl || isIntf) ? ACL_PUBLIC
                                   : ACL_DEFAULT;

#ifdef  SETS

    /* If this an XML class, attach the appropriate XML attribute to it */

    if  (clsSym->sdClass.sdcXMLelems)
        clsSym->sdClass.sdcExtraInfo = cmpAddXMLattr(clsSym->sdClass.sdcExtraInfo, false, 0);

#endif

    /* The loop over members starts here */

    clsMem = clsSym->sdClass.sdcMemDefList;
    if  (!clsMem)
        goto NEXT_DEF;

LOOP_MEM:

    xtraList = NULL;

    if  (clsMem->mlSym)
    {
        SymDef          memSym = clsMem->mlSym;

        /* Is this a delegate member? */

        if  (memSym->sdSymKind == SYM_CLASS &&
             memSym->sdClass.sdcFlavor == STF_DELEGATE)
        {
            cmpDeclDelegate(clsMem, memSym, acc);
            goto DONE_MEM;
        }

        /* Is this a property accessor method? */

        if  (memSym->sdSymKind == SYM_FNC && memSym->sdFnc.sdfProperty)
            goto DONE_MEM;

        /* Is the member a nested anonymous union? */

        if  (clsMem->dlAnonUnion)
        {
            SymDef          aumSym;
            Ident           memName = clsMem->mlName;

            assert(memSym->sdSymKind == SYM_CLASS);

            assert(memSym->        sdClass.sdcAnonUnion);
            assert(memSym->sdType->tdClass.tdcAnonUnion);

            /* Recursively process the anonymous union type definition */

            cmpDeclClass(memSym);

            initDeclMods(&memMod, acc);

            /* Is this really an anonymous union? */

            if  (hashTab::hashIsIdHidden(memName))
            {
                SymDef          tmpSym;

                /* Declare a data member to hold the union */

                aumSym = cmpDeclDataMem(clsSym, memMod, memSym->sdType, memName);

                /* Make sure the anonymous union members aren't redefined */

                assert(clsSym->sdSymKind == SYM_CLASS);
                assert(memSym->sdSymKind == SYM_CLASS);
                assert(memSym->sdParent  == clsSym);

                for (tmpSym = memSym->sdScope.sdScope.sdsChildList;
                     tmpSym;
                     tmpSym = tmpSym->sdNextInScope)
                {
                    Ident               name = tmpSym->sdName;

                    if  (tmpSym->sdSymKind != SYM_VAR)
                        continue;

                    /* Mark the member as belonging to an anonymoys union */

                    tmpSym->sdVar.sdvAnonUnion = true;

                    /* Make sure the enclosing class doesn't have a member with the same name */

                    if  (ourSymTab->stLookupScpSym(name, clsSym))
                        cmpError(ERRredefAnMem, name);
                }

                /* Record the member that holds the value in the union type */

                memSym->sdClass.sdcExtraInfo = cmpAddXtraInfo(memSym->sdClass.sdcExtraInfo,
                                                              aumSym,
                                                              XI_UNION_MEM);
            }
            else
            {
                /* There is a member name after all, so it's not an anonymous union */

                memSym->        sdClass.sdcAnonUnion = false;
                memSym->sdType->tdClass.tdcAnonUnion = false;

                /* Declare a data member to hold the union */

                aumSym = cmpDeclDataMem(clsSym, memMod, memSym->sdType, memName);
            }

            goto DONE_MEM;
        }
    }

    /* Start reading source text from the definition */

    assert(rest == false);
    cmpParser->parsePrepText(&clsMem->dlDef, clsMem->dlComp, save);
    rest = true;

    /* We might have to skip intervening declarators */

    dclSkip = clsMem->dlDeclSkip;

    /* The member isn't conditional or deprecated (etc) until proven so */

    memCond = memDepr = false;

    /* Note whether the member is a constructor */

    isCtor  = clsMem->dlIsCtor;

    /* Parse any leading modifiers */

    switch (ourScanner->scanTok.tok)
    {
        constVal        cval;
        bool            hadMods;
        SymXinfo        linkDesc;

    case tkEXTERN:

        /* Parse the linkage specifier */

        linkDesc = ourParser->parseBrackAttr(true, ATTR_MASK_SYS_IMPORT, &memMod);
        xtraList = cmpAddXtraInfo(xtraList, linkDesc);

        /* Remember that the class has methods with linkage specifiers */

        clsSym->sdClass.sdcHasLinks = true;

        /* The member really wasn't declared "extern" */

        memMod.dmMod &= ~DM_EXTERN;
        break;

#ifdef  SETS

    case tkXML:

        SymDef          memSym;

        assert(clsMem->dlXMLelems);

        ourScanner->scan(); assert(ourScanner->scanTok.tok == tkLParen);
        ourScanner->scan(); assert(ourScanner->scanTok.tok == tkID);

        /* Declare the member to hold all the elements/children */

        initDeclMods(&memMod, ACL_PUBLIC);

        memSym  = cmpDeclDataMem(clsSym,
                                 memMod,
                                 cmpObjArrTypeGet(),
                                 ourScanner->scanTok.id.tokIdent);

        /* Attach the appropriate XML attribute to the member */

        memSym->sdVar.sdvFldInfo    = cmpAddXMLattr(NULL, true, 0);

        /* Save the field in the class descriptor for later use */

        clsSym->sdClass.sdcElemsSym = memSym;

        ourScanner->scan();
        goto NEXT_MEM;

#endif

    case tkLBrack:
    case tkAtComment:
    case tkCAPABILITY:
    case tkPERMISSION:
    case tkATTRIBUTE:

        for (hadMods = false;;)
        {
            switch (ourScanner->scanTok.tok)
            {
                SymXinfo        linkDesc;

                AtComment       atcList;

                unsigned        attrMask;
                genericBuff     attrAddr;
                size_t          attrSize;
                SymDef          attrCtor;

            case tkLBrack:
                linkDesc = ourParser->parseBrackAttr(true, ATTR_MASK_SYS_IMPORT|ATTR_MASK_NATIVE_TYPE, &memMod);
                xtraList = cmpAddXtraInfo(xtraList, linkDesc);
                hadMods  = true;

                /* Stupid thing: parseBrackAttr() sets "extern", just clear it here */

                memMod.dmMod &= ~DM_EXTERN;
                continue;

            case tkAtComment:

                for (atcList = ourScanner->scanTok.atComm.tokAtcList;
                     atcList;
                     atcList = atcList->atcNext)
                {
                    switch (atcList->atcFlavor)
                    {
                    case AC_DLL_IMPORT:

                        /* Was there a DLL name? */

                        if  (!atcList->atcInfo.atcImpLink->ldDLLname)
                        {
                            /* The class better supply the DLL name */

                            if  (!clsSym->sdClass.sdcExtraInfo)
                            {
                        NO_DLL:
                                cmpError(ERRnoDLLname);
                            }
                            else
                            {
                                SymXinfoAtc     clsImp = cmpFindATCentry(clsSym->sdClass.sdcExtraInfo,
                                                                         AC_DLL_IMPORT);
                                if  (!clsImp)
                                    goto NO_DLL;

                                assert(clsImp->xiAtcInfo);
                                assert(clsImp->xiAtcInfo->atcFlavor == AC_DLL_IMPORT);

                                atcList->atcInfo.atcImpLink->ldDLLname = clsImp->xiAtcInfo->atcInfo.atcImpLink->ldDLLname;
                            }
                        }

                        xtraList = cmpAddXtraInfo(xtraList, atcList->atcInfo.atcImpLink);
                        break;

                    case AC_COM_METHOD:
                    case AC_COM_PARAMS:
                    case AC_DLL_STRUCTMAP:
                        xtraList = cmpAddXtraInfo(xtraList, atcList);
                        break;

                    case AC_DEPRECATED:
                        memDepr = true;
                        break;

                    case AC_CONDITIONAL:
                        memCond = !atcList->atcInfo.atcCondYes;
                        break;

                    default:
                        cmpError(ERRbadAtCmPlc);
                        break;
                    }
                }
                ourScanner->scan();
                continue;

            case tkCAPABILITY:
                xtraList = cmpAddXtraInfo(xtraList, ourParser->parseCapability(true));
                continue;

            case tkPERMISSION:
                xtraList = cmpAddXtraInfo(xtraList, ourParser->parsePermission(true));
                continue;

            case tkATTRIBUTE:
                attrCtor = cmpParser->parseAttribute(ATGT_Methods|ATGT_Fields|ATGT_Constructors|ATGT_Properties,
                                                     attrMask,
                                                     attrAddr,
                                                     attrSize);
                if  (attrSize)
                {
                    xtraList = cmpAddXtraInfo(xtraList, attrCtor,
                                                        attrMask,
                                                        attrSize,
                                                        attrAddr);
                }
                continue;

            default:
                break;
            }

            break;
        }

        if  (hadMods)
            break;

        // Fall through ...

    default:

        /* If the member record doesn't indicate an access level, use the default */

        if  (clsMem->dlDefAcc == ACL_ERROR)
             clsMem->dlDefAcc = acc;

        ourParser->parseDeclMods((accessLevels)clsMem->dlDefAcc, &memMod);

        /* Special case: constructors have no return type specifications */

        if  (isCtor)
        {
            /* Pretend we've parsed a type spec already */

            baseTp = cmpTypeVoid;

#ifdef  SETS
            if  (clsSym->sdClass.sdcXMLelems)
                cmpError(ERRctorXML);
#endif


            assert(ourScanner->scanTok.tok != tkLCurly);
            goto DCL_MEM;


        }

        break;

    case tkCASE:

        /* This must be a member of a tagged union */

        ourScanner->scan();

        /* Parse and evaluate the tag value */

        if  (ourParser->parseConstExpr(cval, NULL, tagSym->sdType))
            tagVal = cval.cvValue.cvIval;

        /* Accept both "case tagval:" and "case(tagval)" */

        if  (ourScanner->scanTok.tok == tkColon)
            ourScanner->scan();

        tagDef = false;
        goto NEXT_MEM;

    case tkDEFAULT:

        /* Check for a default property member declaration */

        if  (ourScanner->scan() == tkPROPERTY)
        {
            assert(ourScanner->scanTok.tok == tkPROPERTY || cmpErrorCount);

            ourParser->parseDeclMods(acc, &memMod);
            memMod.dmMod |= DM_DEFAULT;
            break;
        }

        /* This is the default member of a tagged union */

        ourScanner->scan();

        // UNDONE: check for duplicate default

        tagDef = true;
        goto NEXT_MEM;
    }

    /* Parse the type specification */

    baseTp = ourParser->parseTypeSpec(&memMod, true);

    /* Do we need to skip over any declarators that might be in the way? */

    if  (dclSkip)
    {
        if  (dclSkip & dlSkipBig)
        {
            NumPair         dist;

            /* We have to skip a "large" distance -- retrieve the info */

            dist = (NumPair)cmpGetVecEntry(dclSkip & ~dlSkipBig, VEC_TOKEN_DIST);

            ourScanner->scanSkipSect(dist->npNum1, dist->npNum2);
        }
        else
            ourScanner->scanSkipSect(dclSkip);
    }

    /* We have the type, now parse any declarators that follow */

    for (;;)
    {
        SymDef          msym;
        QualName        qual;
        dclrtrName      reqName;

        /* Check for an unnamed bitfield */

        if  (ourScanner->scanTok.tok == tkColon)
        {
            memType = baseTp;
            memName = cmpNewAnonymousName();

            goto BITFIELD;
        }

    DCL_MEM:

        /* Parse the next declarator */

        reqName = (dclrtrName)(DN_REQUIRED|DN_QUALOK);

#ifdef  SETS
        if  (clsMem->dlXMLelem)
            reqName = DN_OPTIONAL;
#endif

        memName = ourParser->parseDeclarator(&memMod,
                                             baseTp,
                                             reqName,
                                             &memType,
                                             &qual,
                                             true);

#ifdef  SETS

        if  (clsMem->dlXMLelem && memType)
        {
            char    *       buff = cmpScanner->scannerBuff;

            /* XML element - mangle its name */

            sprintf(buff, "@XML%u@%s", ++XMLecnt,
                                       memName ? memName->idSpelling() : "");

            memName = cmpGlobalHT->hashString(buff);
            hashTab::setIdentFlags(memName, IDF_XMLELEM);

            /* Attach the appropriate XML attribute to the member */

            xtraList = cmpAddXMLattr(xtraList, true, XMLecnt);
        }

#endif

        /* Skip the member if there were errors parsing it */

        if  (!memName || !memType)
        {
            /* Special case: qualified methods are allowed for interface impls */

            if  (qual && memType)
            {
                /* Only methods may be qualified; in particular, no property info here --right ? */

                if  (memType->tdTypeKind == TYP_FNC)
                {
                    if  (!(memMod.dmMod & DM_PROPERTY))
                    {
                        /* Looks good, we'll take care of the rest below */

                        goto DEF_MEM;
                    }

                    cmpError(ERRbadQualid);
                }
            }

            cmpParser->parseResync(tkComma, tkSColon);
            if  (ourScanner->scanTok.tok != tkComma)
                break;

            continue;
        }

    DEF_MEM:

#ifdef DEBUG

        if  (cmpConfig.ccVerbose >= 2)
        {
            printf("Declaring class member: ");
            if  (memMod.dmMod & DM_TYPEDEF)
                printf("typedef ");
            printf("%s\n", ourSymTab->stTypeName(memType, NULL, memName, NULL, true));
        }

#endif

        msym = NULL;

        /* We don't allow "managed" specifiers on class members */

        if  (memMod.dmMod & (DM_MANAGED|DM_UNMANAGED))
        {
            if  (memMod.dmMod & DM_MANAGED)
                cmpError(ERRbadMgdMod, cmpGlobalHT->tokenToIdent(tkMANAGED));
            if  (memMod.dmMod & DM_UNMANAGED)
                cmpError(ERRbadMgdMod, cmpGlobalHT->tokenToIdent(tkUNMANAGED));
        }

        /* Make sure we bind the type */

        cmpBindType(memType, false, false);

        /* Declare a symbol for the name */

        if  (memMod.dmMod & DM_TYPEDEF)
        {
            UNIMPL(!"declare typedef class member - is this even allowed?");
        }
        else
        {
            switch (memType->tdTypeKind)
            {
                tokens          memNtok;

            case TYP_FNC:

                /* Is this a property member? */

                if  (memMod.dmMod & DM_PROPERTY)
                    goto DECL_PROP;

                /* Plain old data types don't have member functions */

#ifdef  SETS
                clsSym->sdClass.sdcPODTclass = false;
#endif

                /* Was the name qualified ? */

                if  (qual && !memName)
                {
                    SymDef          ifncSym;
                    SymDef          intfSym;

                    SymDef           oldSym;

                    /* This better be a managed class with interfaces */

                    if  (!clsSym->sdIsManaged || clsSym->sdClass.sdcFlavor != STF_CLASS)
                    {
                        cmpError(ERRbadQualid);
                        break;
                    }

                    /* The name should denote an interface method */

                    ifncSym = cmpBindQualName(qual, false);
                    if  (!ifncSym)
                        break;

                    if  (ifncSym->sdSymKind != SYM_FNC)
                    {
                    BAD_IIF:
                        cmpErrorQnm(ERRintfImpl, ifncSym);
                        break;
                    }

                    if  (ifncSym->sdIsMember  == false)
                        goto BAD_IIF;
                    if  (ifncSym->sdIsManaged == false)
                        goto BAD_IIF;

                    intfSym = ifncSym->sdParent;

                    if  (intfSym->sdSymKind != SYM_CLASS)
                        goto BAD_IIF;
                    if  (intfSym->sdIsManaged == false)
                        goto BAD_IIF;
                    if  (intfSym->sdClass.sdcFlavor != STF_INTF)
                        goto BAD_IIF;

                    /* Make sure our class implements this interface */

                    if  (!cmpGlobalST->stIsBaseClass(intfSym->sdType, clsTyp))
                        goto BAD_IIF;

                    /* Get hold of the method's name */

                    memName = ifncSym->sdName; assert(memName == qual->qnTable[qual->qnCount - 1]);

                    /* Look for an existing matching method impl */

                    if  (cmpFindIntfImpl(clsSym, ifncSym, &oldSym))
                    {
                        cmpErrorQnm(ERRredefBody, ifncSym);
                        goto NEXT_MEM;
                    }

                    if  (oldSym)
                    {
                        /* The method is a new overload */

                        msym = cmpCurST->stDeclareOvl(oldSym);

                        /* Copy over some info from the existing method */

                        msym->sdFnc.sdfOverload = oldSym->sdFnc.sdfOverload;
                    }
                    else
                    {
                        /* Create a member symbol and add it to the class */

                        msym = cmpCurST->stDeclareSym(memName, SYM_FNC, NS_HIDE, clsSym);
                    }

                    /* Fill in the method's type, access level, and so on */

                    msym->sdType              = memType;
                    msym->sdAccessLevel       = (accessLevels)memMod.dmAcc;
                    msym->sdIsMember          = true;
                    msym->sdIsManaged         = true;
                    msym->sdCompileState      = CS_DECLARED;

                    msym->sdFnc.sdfIntfImpl   = true;
                    msym->sdFnc.sdfIntfImpSym = ifncSym;

                    /* Make sure the return type matches */

                    if  (!ourSymTab->stMatchTypes(        memType->tdFnc.tdfRett,
                                                  ifncSym->sdType->tdFnc.tdfRett))
                    {
                        cmpErrorQSS(ERRdiffVirtRet, msym, ifncSym);
                    }

                    /* Make sure the access level matches */

                    if  (ifncSym->sdAccessLevel < msym->sdAccessLevel)
                        cmpErrorQnm(ERRvirtAccess, ifncSym);

                    /* Skip over the rest of method processing */

                    clsSym->sdClass.sdcHasMeths = true;
                    break;
                }

                /* Interface methods have a number of restrictions */

                if  (isIntf)
                {
                    memMod.dmMod |= DM_ABSTRACT;

                    if  (memMod.dmAcc != ACL_PUBLIC &&
                         memMod.dmAcc != ACL_DEFAULT)
                    {
                        cmpError(ERRintfFNacc);
                    }
                }

                /* Declare the member function symbol */

                msym = cmpDeclFuncMem(clsSym, memMod, memType, memName);
                if  (!msym)
                    break;

                /* Remember whether the method is marked as "deprecated" */

                msym->sdIsDeprecated     = memDepr;

                // UNDONE: check to make sure the specs are legal!!!!

                msym->sdFnc.sdfExtraInfo = xtraList;

                /* Is this a constructor? */

                if  (isCtor)
                {
                    msym->sdFnc.sdfCtor = true;
                    if  (!msym->sdIsStatic)
                        hasCtors = true;
                    break;
                }
                else
                {
                    if  (memName == clsSym->sdName)
                        cmpError(ERRctorRetTP);
                }


                /* Note whether the method is overloading the base */

                if  ((memMod.dmMod & DM_OVERLOAD) || msym->sdFnc.sdfOverload)
                {
                    hadOvlds                = true;
                    msym->sdFnc.sdfOverload = true;
                }

                /* Was the method declared as 'abstract' ? */

                if  (memMod.dmMod & DM_ABSTRACT)
                {
                    if  (memMod.dmMod & DM_STATIC)
                        cmpModifierError(ERRdmModifier, DM_STATIC);


                    /* Is the class itself marked as abstract ? */

                    if  (!clsSym->sdIsAbstract)
                        cmpClsImplAbs(clsSym, msym);
                }

                /* Is this an overloaded operator method? */

                memNtok = hashTab::tokenOfIdent(memName);

                if  (memNtok != tkNone)
                {
                    ArgDef          arg1;
                    ArgDef          arg2;
                    unsigned        argc;
                    bool            argx;

                    unsigned        prec;
                    treeOps         oper;

                    /* Operators must be static (for now) */

                    if  (!msym->sdIsStatic)
                        cmpError(ERRbadOvlOp);


                    /* Count the arguments and make sure there are no defaults */

                    arg1 = memType->tdFnc.tdfArgs.adArgs;
                    argx = memType->tdFnc.tdfArgs.adExtRec;
                    argc = 0;

                    if  (!msym->sdIsStatic)
                        argc++;

                    if  (arg1)
                    {
                        argc++;

                        if  (argx && (((ArgExt)arg1)->adFlags & ARGF_DEFVAL))
                            cmpError(ERRdefOvlVal);

                        arg2 = arg1->adNext;
                        if  (arg2)
                        {
                            argc++;

                            if  (argx && (((ArgExt)arg2)->adFlags & ARGF_DEFVAL))
                                cmpError(ERRdefOvlVal);

                            if  (arg2->adNext)
                                argc++;
                        }
                    }

                    /* Conversion operators are handled a bit differently */

                    switch (memNtok)
                    {
                        bool            op1;
                        bool            op2;

                    case OPNM_CONV_EXP:
                        msym->sdFnc.sdfOper     = OVOP_CONV_EXP;
                        msym->sdFnc.sdfConvOper = true;
                        break;

                    case OPNM_CONV_IMP:
                        msym->sdFnc.sdfOper     = OVOP_CONV_IMP;
                        msym->sdFnc.sdfConvOper = true;
                        break;

                    case OPNM_EQUALS:
                        msym->sdFnc.sdfOper     = OVOP_EQUALS;
                        if  (cmpDirectType(memType->tdFnc.tdfRett)->tdTypeKind != TYP_BOOL)
                            cmpError(ERRbadOvlEq , memName);
                        goto CHK_OP_ARGTP;

                    case OPNM_COMPARE:
                        msym->sdFnc.sdfOper     = OVOP_COMPARE;
                        if  (cmpDirectType(memType->tdFnc.tdfRett)->tdTypeKind != TYP_INT)
                            cmpError(ERRbadOvlCmp, memName);
                        goto CHK_OP_ARGTP;

                    default:

                        /* Some operators may be both unary and binary */

                        op1 = cmpGlobalHT->tokenIsUnop (memNtok, &prec, &oper) && oper != TN_NONE;
                        op2 = cmpGlobalHT->tokenIsBinop(memNtok, &prec, &oper) && oper != TN_NONE;

                        if      (argc == 1 && op1)
                        {
                            TypDef          rett;

                            // OK:  unary operator and 1 argument

                            rett = cmpDirectType(memType->tdFnc.tdfRett);

                            if  (rett->tdTypeKind == TYP_REF && rett->tdIsImplicit)
                                rett = rett->tdRef.tdrBase;
                            if  (rett->tdTypeKind != TYP_CLASS &&
                                 !cmpCurST->stMatchTypes(rett, clsSym->sdType))
                            {
                                cmpError(ERRbadOvlRet, clsSym);
                            }
                        }
                        else if (argc == 2 && op2)
                        {
                            // OK: binary operator and 2 arguments
                        }
                        else
                        {
                            if      (op1 && op2)
                                cmpError(ERRbadOvlOp12, memName);
                            else if (op1)
                                cmpError(ERRbadOvlOp1 , memName);
                            else
                                cmpError(ERRbadOvlOp2 , memName);
                        }

                    CHK_OP_ARGTP:;


                    }

                    break;
                }

                /* If there is a base class or interfaces ... */

                if  (baseCls || clsTyp->tdClass.tdcIntf)
                {
                    SymDef          bsym;
                    SymDef          fsym = NULL;

                    /* Look for a matching method in the base / interfaces */

                    bsym = ourSymTab->stFindBCImem(clsSym, memName, memType, SYM_FNC, fsym, true);

                    // UNDONE: The method may appear in more than interface, etc.

                    if  (bsym)
                    {
                        if  (!(memMod.dmMod & DM_STATIC) && bsym->sdFnc.sdfVirtual)
                        {
                            /* Is the base method a property accessor ? */

                            if  (bsym->sdFnc.sdfProperty)
                            {
                                cmpErrorQnm(ERRpropAccDef, bsym);
                                break;
                            }

                            /* Make sure the return type matches */

                            if  (!ourSymTab->stMatchTypes(     memType->tdFnc.tdfRett,
                                                          bsym->sdType->tdFnc.tdfRett))
                            {
                                cmpErrorQSS(ERRdiffVirtRet, msym, bsym);
                            }

                            /* Make sure the access level matches */

                            if  (bsym->sdAccessLevel < msym->sdAccessLevel)
                                cmpErrorQnm(ERRvirtAccess, bsym);

                            /* Copy the vtable index, we'll reuse the slot */

                            msym->sdFnc.sdfVtblx    = bsym->sdFnc.sdfVtblx;
                            msym->sdFnc.sdfVirtual  = true;
                            msym->sdFnc.sdfOverride = true;
                            hasVirts                = true;
                            break;
                        }
                    }
                    else if (fsym)
                    {
                        /* See if we're hiding any base methods */

                        if  (!msym->sdFnc.sdfOverload)
                        {
                            SymDef          begSym = ourSymTab->stLookupClsSym(memName, clsSym); assert(begSym);

                            hadOvlds                  = true;
                            begSym->sdFnc.sdfBaseHide = true;
                        }
                    }
                }

                /* Has the method been explicitly declared as "virtual" ? */

                if  (memMod.dmMod & DM_VIRTUAL)
                {
                    msym->sdFnc.sdfVirtual = true;
                    hasVirts               = true;

                    /* Is the class unmanaged? */

                    if  (!clsSym->sdIsManaged)
                    {
                        /* Add a slot for this function to the vtable */

                        msym->sdFnc.sdfVtblx = ++nextVtbl;
                    }
                }
                else if (msym->sdIsAbstract     != false &&
                         msym->sdFnc.sdfVirtual == false)
                {
                    cmpErrorQnm(ERRabsNotVirt, msym); msym->sdIsAbstract = false;
                }
                break;

            case TYP_VOID:
                cmpError(ERRbadVoid, memName);
                continue;

            default:

                /* Is this an overloaded operator method? */

                if  (hashTab::tokenOfIdent(memName) != tkNone)
                {
                    UNIMPL("what kind of a data member is this?");
                }


                /* Is this a property member? */

                if  (memMod.dmMod & DM_PROPERTY)
                {
                    /* Plain old data types don't have properties */

#ifdef  SETS
                    clsSym->sdClass.sdcPODTclass = false;
#endif

                    /* Parse the argument list if it's present */

                    if  (ourScanner->scanTok.tok == tkLBrack)
                    {
                        ArgDscRec       args;

                        /* Parse the argument list */

                        ourParser->parseArgList(args);

                        /* Create the function type */

                        memType = ourSymTab->stNewFncType(args, memType);
                    }

                DECL_PROP:

                    /* Is there no "{ get/set }" thing present ? */

                    if  (ourScanner->scanTok.tok != tkLCurly)
                    {
                        if  (memMod.dmMod & DM_ABSTRACT)
                        {
                            if  (ourScanner->scanTok.tok != tkSColon)
                            {
                                cmpError(ERRnoSmLc);
                                goto NEXT_MEM;
                            }
                        }
                        else
                        {
                            cmpError(ERRnoPropDef);
                            goto NEXT_MEM;
                        }
                    }

                    /* Declare the member symbol for the property */

                    msym = cmpDeclPropMem(clsSym, memType, memName);
                    if  (!msym)
                        goto NEXT_MEM;

                    /* Record the access level of the property */

                    msym->sdAccessLevel = (accessLevels)memMod.dmAcc;

                    /* Properties in interfaces are always abstract */

                    if  (clsSym->sdClass.sdcFlavor == STF_INTF)
                        memMod.dmMod |= DM_ABSTRACT;

                    /* Is this a static/sealed/etc property? */

                    if  (memMod.dmMod & DM_SEALED)
                        msym->sdIsSealed   = true;

                    if  (memMod.dmMod & DM_DEFAULT)
                    {
                        msym->sdIsDfltProp = true;


                    }

                    if  (memMod.dmMod & DM_ABSTRACT)
                    {
                        msym->sdIsAbstract = true;

                        /* Is the class itself marked as abstract ? */

                        if  (!clsSym->sdIsAbstract)
                            cmpClsImplAbs(clsSym, msym);
                    }

                    if  (memMod.dmMod & DM_STATIC)
                    {
                        msym->sdIsStatic   = true;
                    }
                    else
                    {
                        SymDef          baseSym;
                        SymDef          tossSym = NULL;

                        /* Is this a virtual property ? */

                        if  (memMod.dmMod & DM_VIRTUAL)
                            msym->sdIsVirtProp = true;

                        /*
                            Check the base class / interfaces for a
                            matching property.
                         */

                        baseSym = ourSymTab->stFindBCImem(clsSym, memName, memType, SYM_PROP, tossSym, true);

                        if  (baseSym && baseSym->sdIsVirtProp)
                        {
                            /* The property inherits virtualness */

                            hasVirts           = true;
                            msym->sdIsVirtProp = true;

                            /* Make sure the types match */

                            if  (!ourSymTab->stMatchTypes(memType,
                                                          baseSym->sdType))
                            {
                                cmpErrorQSS(ERRdiffPropTp, msym, baseSym);
                            }
                        }
                    }

                    /* Remember whether the property is "deprecated" */

                    msym->sdIsDeprecated = memDepr;

//                  printf("Declaring property '%s'\n", ourSymTab->stTypeName(msym->sdType, msym, NULL, NULL, false));

                    if  (xtraList)
                    {
                        SymXinfo        xtraTemp;

                        /* Walk the list of specs, making sure they look kosher */

                        for (xtraTemp = xtraList; xtraTemp; xtraTemp = xtraTemp->xiNext)
                        {
                            switch (xtraTemp->xiKind)
                            {
                            case XI_ATTRIBUTE:

                                SymXinfoAttr    attrdsc = (SymXinfoAttr)xtraTemp;

                                msym->sdProp.sdpExtraInfo = cmpAddXtraInfo(msym->sdProp.sdpExtraInfo,
                                                                           attrdsc->xiAttrCtor,
                                                                           attrdsc->xiAttrMask,
                                                                           attrdsc->xiAttrSize,
                                                                           attrdsc->xiAttrAddr);
                                continue;
                            }

                            cmpError(ERRbadAtCmPlc);
                            break;
                        }

                        xtraList = NULL;
                    }

                    /* Declare the accessor methods and all that */

                    cmpDeclProperty(msym, memMod, clsDef);

                    goto NEXT_MEM;
                }

                /* Interface members have a number of restrictions */

                if  (isIntf)
                {
                    /* Only constants are allowed as interface data members */

                    if  (!(memMod.dmMod & DM_CONST))
                        cmpError(ERRintfDM);
                }

                /* Make sure that unmanaged classes don't have managed fields */

                if  (!clsSym->sdIsManaged && (memType->tdIsManaged ||
                                              memType->tdTypeKind == TYP_REF))
                {
                    cmpError(ERRumgFldMgd);
                }

                /* Declare a symbol for the member */

                msym = cmpDeclDataMem(clsSym, memMod, memType, memName);
                if  (!msym)
                    break;

                /* Remember whether the member is "deprecated" */

                msym->sdIsDeprecated = memDepr;

                /* Is the member marked as "transient" ? */

                if  (memMod.dmMod & DM_TRANSIENT)
                    msym->sdIsTransient = true;

#ifdef  SETS

                if  (clsMem->dlXMLelem)
                {
                    // UNDONE: add XMLelem custom attribute to the member
                }

                /* Plain old data types don't have static or non-public members */

                if  (msym->sdIsStatic || msym->sdAccessLevel != ACL_PUBLIC)
                    clsSym->sdClass.sdcPODTclass = false;

#endif

                /* Check for any marshalling / other specifications */

                if  (xtraList)
                {
                    SymXinfo        xtraTemp;

                    /* Walk the list of specs, making sure they look kosher */

                    for (xtraTemp = xtraList; xtraTemp; xtraTemp = xtraTemp->xiNext)
                    {
                        switch (xtraTemp->xiKind)
                        {
                        case XI_ATCOMMENT:

                            AtComment       atcList;

                            /* We only allow "@dll.structmap" for data members */

                            for (atcList = ((SymXinfoAtc)xtraTemp)->xiAtcInfo;
                                 atcList;
                                 atcList = atcList->atcNext)
                            {
                                switch (atcList->atcFlavor)
                                {
                                case AC_DLL_STRUCTMAP:

                                    /* If we have a symbol, record the info */

                                    if  (!msym)
                                        break;

                                    clsSym->sdClass.sdcMarshInfo = true;

                                    msym->sdVar.sdvMarshInfo     = true;
                                    msym->sdVar.sdvFldInfo       = cmpAddXtraInfo(msym->sdVar.sdvFldInfo,
                                                                                  atcList->atcInfo.atcMarshal);
                                    break;

                                default:
                                    goto BAD_XI;
                                }
                            }

                            continue;

                        case XI_MARSHAL:

                            msym->sdVar.sdvFldInfo  = cmpAddXtraInfo(msym->sdVar.sdvFldInfo,
                                                                     ((SymXinfoCOM)xtraTemp)->xiCOMinfo);
                            continue;

                        case XI_ATTRIBUTE:

                            SymXinfoAttr    attrdsc = (SymXinfoAttr)xtraTemp;

                            msym->sdVar.sdvFldInfo  = cmpAddXtraInfo(msym->sdVar.sdvFldInfo,
                                                                     attrdsc->xiAttrCtor,
                                                                     attrdsc->xiAttrMask,
                                                                     attrdsc->xiAttrSize,
                                                                     attrdsc->xiAttrAddr);
                            continue;
                        }

                    BAD_XI:

                        cmpError(ERRbadAtCmPlc);
                        break;
                    }

                    xtraList = NULL;
                }

                break;
            }
        }

        /* Record the member's access level */

        if  (msym)
            msym->sdAccessLevel = (accessLevels)memMod.dmAcc;

        /* Is there an initializer or method body? */

        switch (ourScanner->scanTok.tok)
        {
            unsigned        maxbf;
            constVal        cval;

            genericBuff     defFpos;
            unsigned        defLine;

        case tkAsg:

            /* Only data members can be given initializers */

            if  (memType->tdTypeKind == TYP_FNC || !clsDef)
            {
                if  (oldStyleDecl)
                {
                    cmpError(ERRbadInit);

                    /* Swallow the rest of the initializer */

                    cmpParser->parseResync(tkComma, tkSColon);
                }

                break;
            }

            /* Is this an old-style file scope class? */

            if  (oldStyleDecl && !clsSym->sdIsManaged)
            {
                /* Is this a constant member? */

                if  (memMod.dmMod & DM_CONST)
                {
                    if  (msym)
                    {
                        /* Evaluate and record the constant value */

                        ourScanner->scan();
                        cmpParseConstDecl(msym);
                    }
                    else
                    {
                        /* Error above, just skip over the initializer */

                        ourScanner->scanSkipText(tkNone, tkNone, tkComma);
                    }
                }
                else
                {
                    /* Figure out where we are */

                    defFpos = ourScanner->scanGetTokenPos(&defLine);

                    /* Swallow the initializer */

                    ourScanner->scanSkipText(tkNone, tkNone, tkComma);

                    /* Record the position of the initializer */

                    if  (msym)
                    {
                        DefList         memDef;

                        /* Mark the member var as having an initializer */

                        msym->sdIsDefined      = true;
                        msym->sdVar.sdvHadInit = true;

                        /* Remember where the initializer is, we'll come back to it later */

                        assert(clsDef);

                        memDef = ourSymTab->stRecordSymSrcDef(msym,
                                                              clsDef->dlComp,
                                                              clsDef->dlUses,
                                                              defFpos,
//                                                            ourScanner->scanGetFilePos(),
                                                              defLine);
                        memDef->dlHasDef = true;
                    }
                }
            }
            else
            {
                assert(clsMem && clsMem->dlExtended);

                clsMem->mlSym    = msym;
                clsMem->dlHasDef = true;

                /* Swallow the "=" token */

                ourScanner->scan();

                /* Figure out where we are */

                defFpos = ourScanner->scanGetTokenPos(&defLine);

                /* Swallow the constant expression */

                if  (ourScanner->scanTok.tok == tkLCurly)
                {
                    ourScanner->scanSkipText(tkLCurly, tkRCurly);
                    if  (ourScanner->scanTok.tok == tkRCurly)
                        ourScanner->scan();
                }
                else
                    ourScanner->scanSkipText(tkLParen, tkRParen, tkComma);

                /* Record the position of the constant (unless we had errors) */

                if  (msym)
                {
                    constList = cmpTempMLappend(constList, &constLast,
                                                msym,
                                                clsMem->dlComp,
                                                clsMem->dlUses,
                                                defFpos,
//                                              ourScanner->scanGetFilePos(),
                                                defLine);

                    /* Remember that we have found a member initializer */

                    hadMemInit              = true;
                    msym->sdVar.sdvHadInit  = true;
                    msym->sdVar.sdvDeferCns = true;
                }
            }
            break;

        case tkLCurly:

            /* Is this a variable? */

            if  (memType->tdTypeKind != TYP_FNC || !clsDef)
            {
                cmpError(ERRbadFNbody);

            BAD_BOD:

                /* Skip over the bogus function body */

                ourScanner->scanSkipText(tkLCurly, tkRCurly);
                if  (ourScanner->scanTok.tok == tkRCurly)
                    ourScanner->scan();

                goto NEXT_MEM;
            }

        FNC_DEF:

            /* Make sure the method isn't abstract */

            if  (memMod.dmMod & DM_ABSTRACT)
            {
                cmpError(ERRabsFNbody, msym);
                goto BAD_BOD;
            }

            assert(clsMem);

            /* Is this method conditionally disabled? */

            if  (memCond)
            {
                /* There better not be a return value */

                if  (cmpActualVtyp(msym->sdType->tdFnc.tdfRett) == TYP_VOID)
                {
                    msym->sdFnc.sdfDisabled = true;
                    goto NEXT_MEM;
                }

                cmpError(ERRbadCFNret);
            }

            /* Record the member symbol in the declaration entry */

            clsMem->mlSym     = msym;
            clsMem->dlHasDef  = true;

            /* Mark the method as having a body */

            if  (msym)
                msym->sdIsDefined = true;

            /* Remember that the class had some method bodies */

            clsSym->sdClass.sdcHasBodies = true;

            goto NEXT_MEM;

        case tkColon:

            /* Is this a base class ctor call ? */

            if  (isCtor)
            {
                assert(memType->tdTypeKind == TYP_FNC);

                /* Simply skip over the base ctor call for now */

                ourScanner->scanSkipText(tkNone, tkNone, tkLCurly);

                if  (ourScanner->scanTok.tok == tkLCurly)
                    goto FNC_DEF;

                break;
            }

            // Fall through, must be a bitfield ...

        BITFIELD:

            /* This is a bitfield */

            memType = cmpDirectType(memType);

            if  (varTypeIsIntegral(memType->tdTypeKindGet()))
            {
                maxbf = cmpGetTypeSize(memType) * 8;
            }
            else
            {
                cmpError(ERRbadBfld, memType);
                maxbf = 0;
            }

            /* A static data member can't be a bitfield */

            if  (msym->sdIsStatic)
                cmpError(ERRstmBfld);

            /* We don't support bitfields in managed classes */

            if  (clsTyp->tdIsManaged)
                cmpWarn(WRNmgdBF);

            /* Swallow the ":" and parse the bitfield width expression */

            ourScanner->scan();

            if  (cmpParser->parseConstExpr(cval))
            {
                /* Make sure the value is an integer */

                if  (!varTypeIsIntegral((var_types)cval.cvVtyp) ||
                                                   cval.cvVtyp > TYP_UINT)
                {
                    cmpError(ERRnoIntExpr);
                }
                else if (msym && msym->sdSymKind == SYM_VAR)
                {
                    unsigned        bits = cval.cvValue.cvIval;

                    /* Make sure the bitfield width isn't too big */

                    if  ((bits == 0 || bits > maxbf) && maxbf)
                    {
                        cmpGenError(ERRbadBFsize, bits, maxbf);
                    }
                    else
                    {
                        /* Record the bitfield width in the member symbol */

                        msym->sdVar.sdvBitfield         = true;
                        msym->sdVar.sdvBfldInfo.bfWidth = (BYTE)bits;
                    }
                }
            }

            break;

        default:

            if  (memType->tdTypeKind == TYP_FNC)
            {
                /* Remember the symbol, though we don't have a definition yet */

                clsMem->mlSym    = msym;
                clsMem->dlHasDef = false;


            }

            break;
        }

        /* Are there any more declarators? */

        if  (ourScanner->scanTok.tok != tkComma)
            break;

        /* Are we processing a tagged union? */

        if  (tagged)
            cmpError(ERRmulUmem);

        if  (!oldStyleDecl)
            goto NEXT_MEM;

        assert(isCtor == false);    // ISSUE: this is not allowed, right?

        /* Swallow the "," and go get the next declarator */

        ourScanner->scan();
    }

    /* Make sure we've consumed the expected amount of text */

    if  (ourScanner->scanTok.tok != tkSColon)
    {
        cmpError(ERRnoCmSc);
    }
    else
    {
        /* Are we processing a tagged union? */

        if  (tagged)
        {
            /* Make sure there isn't another member present */

            switch (ourScanner->scan())
            {
            case tkRCurly:
            case tkCASE:
            case tkDEFAULT:
                // ISSUE: Any other tokens to check for ?
                break;

            default:
                cmpError(ERRmulUmem);
                break;
            }
        }
    }

NEXT_MEM:

    /* We're done reading source text from the definition */

    assert(rest); cmpParser->parseDoneText(save); rest = false;

DONE_MEM:

    /* Process the next member, if any */

    clsMem = (ExtList)clsMem->dlNext;
    if  (clsMem)
        goto LOOP_MEM;

NEXT_DEF:

    clsDef = clsDef->dlNext;
    if  (clsDef)
        goto LOOP_DEF;

DONE_DEF:

    /* We've reached 'declared' state successfully */

    clsSym->sdCompileState = CS_DECLARED;

    /* Remember how many vtable slots we've used */

    clsSym->sdClass.sdcVirtCnt = nextVtbl;

    /* We're done reading the definition */

    if  (rest)
        cmpParser->parseDoneText(save);

    /* Actually, did we really succeed? */

    if  (clsSym->sdIsDefined)
    {
        /* If there were no ctors, we may have to add one */

        if  (!hasCtors && clsSym->sdIsManaged && !isIntf)
             cmpDeclDefCtor(clsSym);

#ifdef  SETS

        /* Is this an anonymous class ? */

        if  (clsSym->sdClass.sdcPODTclass)
        {
//          printf("NOTE: anonymous class '%s'\n", clsSym->sdSpelling());
        }

#endif

        /* Did we have any members with initializers? */

        if  (hadMemInit)
            cmpEvalMemInits(clsSym, constList, noCnsEval, NULL);

        /* Did we have any base overloads? */

        if  (hadOvlds && baseCls)
        {
            SymDef          baseSym = baseCls->tdClass.tdcSymbol;
            SymDef          memSym;

            /*
                Check all function members for being overloaded, also detect and flag
                any methods that hide (don't overload) any base class methods.
             */

            for (memSym = clsSym->sdScope.sdScope.sdsChildList;
                 memSym;
                 memSym = memSym->sdNextInScope)
            {
                SymDef          baseFnc;

                if  (memSym->sdSymKind != SYM_FNC)
                    continue;

#ifndef NDEBUG

                /* Make sure the head of the overload list is marked correctly */

                for (SymDef fncSym = memSym; fncSym; fncSym = fncSym->sdFnc.sdfNextOvl)
                {
                    assert(fncSym->sdFnc.sdfOverload == false || memSym->sdFnc.sdfOverload);
                    assert(fncSym->sdFnc.sdfBaseHide == false || memSym->sdFnc.sdfBaseHide);
                }

#endif

                if  (memSym->sdFnc.sdfBaseHide != false)
                {
                    /* Some base class methods may be hidden */

                    cmpFindHiddenBaseFNs(memSym, baseCls->tdClass.tdcSymbol);
                    continue;
                }

                /* If there are no base overloads, ignore this method */

                if  (memSym->sdFnc.sdfOverload == false)
                    continue;

                /* See if a base class contains an overload */

                baseFnc = ourSymTab->stLookupAllCls(memSym->sdName,
                                                    baseSym,
                                                    NS_NORM,
                                                    CS_DECLSOON);

                if  (baseFnc && baseFnc->sdSymKind == SYM_FNC)
                {
                    /* Mark our method as having base overloads */

                    memSym->sdFnc.sdfBaseOvl = true;
                }
            }
        }

        /* Is this a class with interfaces or an abstract base class ? */

        if  (clsTyp->tdClass.tdcFlavor != STF_INTF)
        {
            if  (clsTyp->tdClass.tdcHasIntf)
                cmpCheckClsIntf(clsSym);

            /* Is there an abstract base class? */

            if  (baseCls && baseCls->tdClass.tdcSymbol->sdIsAbstract
                         && !clsSym->                   sdIsAbstract)
            {
                SymDef          baseSym;

//              printf("Checking [%u] class '%s'\n", clsTyp->tdClass.tdcHasIntf, clsSym->sdSpelling());

                for (baseSym = baseCls->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
                     baseSym;
                     baseSym = baseSym->sdNextInScope)
                {
                    SymDef          baseOvl;
                    SymDef          implSym;

                    /* Is this a method? */

                    if  (baseSym->sdSymKind != SYM_FNC)
                    {
                        /* Is this a property member ? */

                        if  (baseSym->sdSymKind != SYM_PROP)
                            continue;

                        /* Ignore non-abstract members */

                        if  (baseSym->sdIsAbstract == false)
                            continue;

                        /* Look for a matching property in the class */

                        implSym = ourSymTab->stLookupClsSym(baseSym->sdName, clsSym);
                        if  (implSym && implSym->sdSymKind == SYM_PROP)
                            continue;

                        baseOvl = baseSym;
                        goto NON_IMPL;
                    }

                    /* Ignore property accessor methods */

                    if  (baseSym->sdFnc.sdfProperty)
                        continue;

                    /* Ignore operators, they can't be abstract anyway [ISSUE] */

                    if  (baseSym->sdFnc.sdfOper != OVOP_NONE)
                        continue;

                    /* Look for a matching member in the class we're declaring */

                    implSym = ourSymTab->stLookupClsSym(baseSym->sdName, clsSym);
                    if  (implSym && implSym->sdSymKind != SYM_FNC)
                        implSym = NULL;

                    /* Process all overloaded flavors of the method */

                    baseOvl = baseSym;
                    do
                    {
                        SymDef          implOvl;

                        /* Ignore non-abstract members */

                        if  (baseOvl->sdIsAbstract)
                        {
                            /* Look for a matching method defined in our class */

                            implOvl = implSym ? ourSymTab->stFindOvlFnc(implSym, baseOvl->sdType)
                                              : NULL;

                            if  (!implOvl)
                            {
                                /* This abstract method isn't implemented by the class */

                            NON_IMPL:

                                cmpClsImplAbs(clsSym, baseOvl);

                                clsSym->sdIsAbstract = true;

                                goto DONE_ABS;
                            }
                        }

                        baseOvl = baseOvl->sdFnc.sdfNextOvl;
                    }
                    while (baseOvl);
                }
            }
        }

    DONE_ABS:

        /* For unmanaged classes, now is the time to do layout */

        clsSym->sdClass.sdcHasVptr = hasVirts;

        if  (!clsSym->sdIsManaged)
            cmpLayoutClass(clsSym);

        /* Does the class contain any nested types? */

        if  (clsSym->sdClass.sdcNestTypes)
        {
            SymDef          memSym;

            for (memSym = clsSym->sdScope.sdScope.sdsChildList;
                 memSym;
                 memSym = memSym->sdNextInScope)
            {
                if  (memSym->sdSymKind == SYM_CLASS &&
                     memSym->sdClass.sdcAnonUnion == false)
                {
                    cmpDeclClass(memSym);
                }
            }
        }
    }
    else
    {
        /* We didn't find a definition, and that's a problem unless we invented it */

        if  (!clsSym->sdIsImplicit)
            cmpError(ERRnoClassDef, clsSym);
    }

RET:

    cmpDeclClassRec = saveRec;
}

/*****************************************************************************
 *
 *  Create a specific instance of the given method.
 */

SymDef              compiler::cmpInstanceMeth(INOUT SymDef REF newOvl,
                                                    SymDef     clsSym,
                                                    SymDef     ovlSym)
{
    ExtList         mfnDef;
    SymDef          newSym;
    TypDef          fncType;
    Ident           fncName = ovlSym->sdName;
    SymTab          ourStab = cmpCurST;

    /* Instantiate the type */

    fncType = cmpInstanceType(ovlSym->sdType);

    /* Declare the method symbol */

    if  (!newOvl)
    {
        ovlOpFlavors    ovop = ovlSym->sdFnc.sdfOper;

        /* This is the first overload, start the list */

        if  (ovop == OVOP_NONE)
            newSym = newOvl = ourStab->stDeclareSym (fncName, SYM_FNC, NS_NORM, clsSym);
        else
            newSym = newOvl = ourStab->stDeclareOper(ovop, clsSym);
    }
    else
    {
        SymDef          tmpSym;

        /* Make sure we don't end up with a duplicate */

        tmpSym = ourStab->stFindOvlFnc(newOvl, fncType);
        if  (tmpSym)
        {
            cmpRedefSymErr(tmpSym, ERRredefMem);
            return  NULL;
        }

        newSym = ourStab->stDeclareOvl(newOvl);
    }

    newSym->sdType             = fncType;

    newSym->sdIsDefined        = true;
    newSym->sdIsImplicit       = true;
    newSym->sdFnc.sdfInstance  = true;

    newSym->sdIsStatic         = ovlSym->sdIsStatic;
    newSym->sdIsSealed         = ovlSym->sdIsSealed;
    newSym->sdIsAbstract       = ovlSym->sdIsAbstract;
    newSym->sdAccessLevel      = ovlSym->sdAccessLevel;
    newSym->sdIsMember         = ovlSym->sdIsMember;
    newSym->sdIsManaged        = ovlSym->sdIsManaged;

    newSym->sdFnc.sdfCtor      = ovlSym->sdFnc.sdfCtor;
    newSym->sdFnc.sdfOper      = ovlSym->sdFnc.sdfOper;
    newSym->sdFnc.sdfNative    = ovlSym->sdFnc.sdfNative;
    newSym->sdFnc.sdfVirtual   = ovlSym->sdFnc.sdfVirtual;
    newSym->sdFnc.sdfExclusive = ovlSym->sdFnc.sdfExclusive;

    newSym->sdCompileState     = CS_DECLARED;
    newSym->sdFnc.sdfGenSym    = ovlSym;

    /* Remember which generic method we instantiated from */

    mfnDef = ourStab->stRecordMemSrcDef(fncName,
                                        NULL,
                                        NULL, // memDef->dlComp,
                                        NULL, // memDef->dlUses,
                                        NULL, // defFpos,
                                        0);   // defLine);
    mfnDef->dlHasDef     = true;
    mfnDef->dlInstance   = true;
    mfnDef->mlSym        = ovlSym;

    /* Save the definition record in the instance method */

    newSym->sdSrcDefList = mfnDef;

    /* Return the new method symbol to the caller */

    return  newSym;
}

/*****************************************************************************
 *
 *  Bring an instance of a generic class to "declared" state.
 */

void                compiler::cmpDeclInstType(SymDef clsSym)
{
    SymList         instList = NULL;

    SymDef          genSym;
    SymDef          memSym;

    int             generic;
    bool            nested;

    SymTab          ourStab = cmpCurST;

    assert(clsSym);
    assert(clsSym->sdSymKind == SYM_CLASS);
    assert(clsSym->sdCompileState < CS_DECLARED);

//  printf("Instance cls [%08X]: '%s'\n", clsSym, ourStab->stTypeName(NULL, clsSym, NULL, NULL, false));

    /* Get hold of the generic class itself */

    genSym  = clsSym->sdClass.sdcGenClass;

    /* Is this a generic instance or just a nested class ? */

    generic = clsSym->sdClass.sdcSpecific;

    if  (generic)
    {
        /* Add an entry to the current instance list */

        if  (cmpGenInstFree)
        {
            instList = cmpGenInstFree;
                       cmpGenInstFree = instList->slNext;
        }
        else
        {
#if MGDDATA
            instList = new SymList;
#else
            instList =    (SymList)cmpAllocPerm.nraAlloc(sizeof(*instList));
#endif
        }

        instList->slSym   = clsSym;
        instList->slNext  = cmpGenInstList;
                            cmpGenInstList = instList;
    }

    /* Walk all the members of the class and instantiate them */

    for (memSym = genSym->sdScope.sdScope.sdsChildList, nested = false;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        Ident           name = memSym->sdName;

//      printf("Instantiating member '%s'\n", ourStab->stTypeName(memSym->sdType, memSym, NULL, NULL, false));

        switch (memSym->sdSymKind)
        {
            SymDef          newSym;
            SymDef          ovlSym;
            SymDef          newOvl;

        case SYM_VAR:

            /* Declare the specific field */

            newSym = ourStab->stDeclareSym(name, SYM_VAR, NS_NORM, clsSym);

            newSym->sdType          = cmpInstanceType(memSym->sdType);

            newSym->sdIsStatic      = memSym->sdIsStatic;
            newSym->sdIsSealed      = memSym->sdIsSealed;
            newSym->sdAccessLevel   = memSym->sdAccessLevel;
            newSym->sdIsMember      = memSym->sdIsMember;
            newSym->sdIsManaged     = memSym->sdIsManaged;

            newSym->sdCompileState  = CS_DECLARED;
            newSym->sdVar.sdvGenSym = memSym;

//          printf("Instance var [%08X]: '%s'\n", newSym, ourStab->stTypeName(newSym->sdType, newSym, NULL, NULL, false));

            break;

        case SYM_FNC:

            newOvl = NULL;

            for (ovlSym = memSym; ovlSym; ovlSym = ovlSym->sdFnc.sdfNextOvl)
            {
                /* Property accessors are handled below */

                if  (!ovlSym->sdFnc.sdfProperty)
                    cmpInstanceMeth(newOvl, clsSym, ovlSym);
            }

            break;

        case SYM_PROP:

            for (ovlSym = memSym; ovlSym; ovlSym = ovlSym->sdProp.sdpNextOvl)
            {
                SymDef          accSym;

                /* Create the specific property instance symbol */

                newSym = cmpDeclPropMem(clsSym,
                                        cmpInstanceType(ovlSym->sdType),
                                        name);

                newSym->sdAccessLevel   = memSym->sdAccessLevel;
                newSym->sdIsStatic      = memSym->sdIsStatic;
                newSym->sdIsSealed      = memSym->sdIsSealed;
                newSym->sdIsMember      = memSym->sdIsMember;
                newSym->sdIsManaged     = memSym->sdIsManaged;
                newSym->sdIsDfltProp    = memSym->sdIsDfltProp;

                newSym->sdCompileState  = CS_DECLARED;

                /* Is this the default property of the class ? */

                if  (memSym == genSym->sdClass.sdcDefProp)
                {
                    assert(memSym->sdIsDfltProp);

                    newSym->sdIsDfltProp       = true;
                    clsSym->sdClass.sdcDefProp = newSym;
                }

                /* Instantiate the accessors (if any) */

                if  (ovlSym->sdProp.sdpGetMeth)
                {
                    accSym = ovlSym->sdProp.sdpGetMeth;
                    newOvl = ourStab->stLookupClsSym(accSym->sdName, clsSym);

                    newSym->sdProp.sdpGetMeth = cmpInstanceMeth(newOvl, clsSym, accSym);
                }

                if  (ovlSym->sdProp.sdpSetMeth)
                {
                    accSym = ovlSym->sdProp.sdpSetMeth;
                    newOvl = ourStab->stLookupClsSym(accSym->sdName, clsSym);

                    newSym->sdProp.sdpSetMeth = cmpInstanceMeth(newOvl, clsSym, accSym);
                }
            }

            break;

        case SYM_CLASS:

            /* Nested classes are handled in a separate pass below */

            if  (!memSym->sdClass.sdcGenArg)
                nested = true;

            break;

        default:
            NO_WAY(!"unexpected generic class member");
        }
    }

    /* Did we have any nested classes? */

    if  (nested)
    {
        for (memSym = genSym->sdScope.sdScope.sdsChildList;
             memSym;
             memSym = memSym->sdNextInScope)
        {
            SymDef          newSym;

            if  (memSym->sdSymKind != SYM_CLASS)
                continue;
            if  (memSym->sdClass.sdcGenArg)
                continue;

            /* Declare a new nested class symbol */

            newSym = cmpGlobalST->stDeclareSym(memSym->sdName,
                                               SYM_CLASS,
                                               NS_HIDE,
                                               clsSym);

            newSym->sdAccessLevel       = memSym->sdAccessLevel;
            newSym->sdIsManaged         = memSym->sdIsManaged;
            newSym->sdClass.sdcFlavor   = memSym->sdClass.sdcFlavor;
            newSym->sdCompileState      = CS_KNOWN;

            newSym->sdClass.sdcSpecific = false;
            newSym->sdClass.sdcArgLst   = NULL;
            newSym->sdClass.sdcGenClass = memSym;

            newSym->sdTypeGet();

            /* Recursively process the nested class */

            cmpDeclInstType(newSym);
        }
    }

    /* Looks like we've made it */

    clsSym->sdCompileState = CS_DECLARED;

    /* Move our entry from the instantiation list to the free list */

    if  (generic)
    {
        cmpGenInstList = instList->slNext;
                         instList->slNext = cmpGenInstFree;
                                            cmpGenInstFree = instList;
    }
}

/*****************************************************************************
 *
 *  Perform any type argument substitutions in the given type, return the new
 *  type.
 */

TypDef              compiler::cmpInstanceType(TypDef genType, bool chkOnly)
{
    TypDef          newType;
    SymTab          ourStab;

    var_types       kind = genType->tdTypeKindGet();

    if  (kind <= TYP_lastIntrins)
        return  genType;

    ourStab = cmpGlobalST;

    switch  (kind)
    {
        ArgDscRec       argDsc;
        SymDef          clsSym;
        ArgDef          newArgs;
        SymList         instList;

    case TYP_PTR:
    case TYP_REF:

        /* Process the base type and see if it's different */

        newType = cmpInstanceType(genType->tdRef.tdrBase, chkOnly);
        if  (newType == genType->tdRef.tdrBase)
            return  genType;

        if  (chkOnly)
            return  NULL;

        return  ourStab->stNewRefType(genType->tdTypeKindGet(),
                                      newType,
                                (bool)genType->tdIsImplicit);

    case TYP_FNC:

        /* Instantiate the return type */

        newType = cmpInstanceType(genType->tdFnc.tdfRett, chkOnly);

        /* See if we need to create a new argument list */

        argDsc  = genType->tdFnc.tdfArgs;
        newArgs = argDsc.adArgs;

        if  (newArgs)
        {
            ArgDef          argList = newArgs;

            do
            {
                if  (cmpInstanceType(argList->adType, true) != argList->adType)
                {
                    ArgDef          list;
                    ArgDef          last;
                    ArgDef          next;

                    bool            exts;

                    if  (chkOnly)
                        return  NULL;

                    /* We'll have to create a new argument list */

#if MGDDATA
                    argDsc = new ArgDscRec;
#else
                    memset(&argDsc, 0, sizeof(argDsc));
#endif

                    exts = genType->tdFnc.tdfArgs.adExtRec;

                    for (argList = newArgs, list = last = NULL;
                         argList;
                         argList = argList->adNext)
                    {
                        Ident           argName = NULL;

                        /* Create the new argument entry */

                        if  (exts)
                        {
                            ArgExt          xarg;
#if MGDDATA
                            next =
                            xarg = new ArgExt;
#else
                            next =
                            xarg =    (ArgExt)cmpAllocPerm.nraAlloc(sizeof(*xarg));
#endif
                            xarg->adFlags = ((ArgExt)argList)->adFlags;
                        }
                        else
                        {
#if MGDDATA
                            next = new ArgDef;
#else
                            next =    (ArgDef)cmpAllocPerm.nraAlloc(sizeof(*next));
#endif
                        }

                        next->adType  = cmpInstanceType(argList->adType, false);
                        next->adName  = argName;

#ifdef  DEBUG
                        next->adIsExt = exts;
#endif

                        /* Append the argument to the end of the list */

                        if  (list)
                            last->adNext = next;
                        else
                            list         = next;

                        last = next;
                    }

                    if  (last)
                        last->adNext = NULL;

                    /* Save the argument list and count */

                    argDsc.adCount = genType->tdFnc.tdfArgs.adCount;
                    argDsc.adArgs  = newArgs = list;

                    break;
                }

                argList = argList->adNext;
            }
            while (argList);
        }

        /* Has either the return type or the argument list changed? */

        if  (newArgs != genType->tdFnc.tdfArgs.adArgs ||
             newType != genType->tdFnc.tdfRett)
        {
            if  (chkOnly)
                return  NULL;

            argDsc.adExtRec = genType->tdFnc.tdfArgs.adExtRec;

            genType = ourStab->stNewFncType(argDsc, newType);
        }

        return  genType;

    case TYP_CLASS:

        /* Is this a generic type argument? */

        clsSym = genType->tdClass.tdcSymbol;

        if  (!clsSym->sdClass.sdcGenArg)
            return  genType;

        if  (chkOnly)
            return  NULL;

        /* Look for the argument in the current set of bindings */

        for (instList = cmpGenInstList;
             instList;
             instList = instList->slNext)
        {
            SymDef          argSym;
            SymDef          genCls;
            SymDef          instSym = instList->slSym;

            assert(instSym->sdSymKind == SYM_CLASS);
            assert(instSym->sdClass.sdcSpecific);

            genCls = instSym->sdClass.sdcGenClass;

            assert(genCls->sdSymKind == SYM_CLASS);
            assert(genCls->sdClass.sdcGeneric);

            argSym = ourStab->stLookupScpSym(clsSym->sdName, genCls);

            if  (argSym && argSym->sdSymKind == SYM_CLASS
                        && argSym->sdClass.sdcGenArg)
            {
                GenArgDscA      argList;
                unsigned        argNum =  clsSym->sdClass.sdcGenArg;

                /* Got the right class, now locate the argument */

                argList = (GenArgDscA)instSym->sdClass.sdcArgLst;

                while (--argNum)
                {
                    argList = (GenArgDscA)argList->gaNext; assert(argList);
                }

                assert(argList && argList->gaBound);

                return  argList->gaType;
            }
        }

        NO_WAY(!"didn't find generic argument binding");

        return  ourStab->stNewErrType(clsSym->sdName);

    case TYP_ENUM:
        return  genType;

    default:
#ifdef  DEBUG
        printf("Generic type: '%s'\n", ourStab->stTypeName(genType, NULL, NULL, NULL, false));
#endif
        UNIMPL(!"instantiate type");
    }

    UNIMPL(!"");
    return  genType;
}

/*****************************************************************************
 *
 *  Process all member initializers of the given class.
 */

void                compiler::cmpEvalMemInits(SymDef    clsSym,
                                              ExtList   constList,
                                              bool      noEval,
                                              IniList   deferLst)
{
    ExtList         constThis;
    ExtList         constLast;

    SymDef          clsComp;
    UseList         clsUses;

#ifdef  DEBUG
    clsComp = NULL;
    clsUses = NULL;
#endif

    /* Are we processing a deferred initializer list? */

    if  (deferLst)
    {
        assert(noEval == false);

        /* Get hold of the class and initializer list */

        clsSym    = deferLst->ilCls;
        constList = deferLst->ilInit;

        /* The class won't have deferred initializers shortly */

        assert(clsSym->sdClass.sdcDeferInit);
               clsSym->sdClass.sdcDeferInit = false;

        /* Setup scoping context for proper binding */

        cmpCurCls  = clsSym;
        cmpCurNS   = cmpGlobalST->stNamespOfSym(clsSym);
        cmpCurST   = cmpGlobalST;

        clsComp    = constList->dlComp;
        clsUses    = constList->dlUses;

        cmpBindUseList(clsUses);

        /* Move the entry to the free list */

        deferLst->ilNext = cmpDeferCnsFree;
                           cmpDeferCnsFree = deferLst;
    }

    /* Walk the list of initializers, looking for work to do */

    constLast = NULL;
    constThis = constList; assert(constThis);

    do
    {
        ExtList         constNext = (ExtList)constThis->dlNext;

        /* Process this member's initializer (if it hasn't happened already) */

        if  (constThis->mlSym)
        {
            SymDef          memSym = constThis->mlSym;

            assert(memSym->sdSrcDefList   == constThis);
            assert(memSym->sdCompileState == CS_DECLARED);

            /* Are we supposed to defer the initializer evaluation? */

            if  (noEval)
            {
                /* Mark the member is having a deferred initializer */

                memSym->sdVar.sdvDeferCns = true;

                /* Update the last surviving entry value */

                constLast = constThis;

                goto NEXT;
            }
            else
            {
                if  (memSym->sdCompileState <= CS_DECLARED)
                {
                    /* Record the comp-unit and use-list, just in case */

                    clsComp = constThis->dlComp;
                    clsUses = constThis->dlUses;

                    /* See if the initializer is a constant */

                    cmpEvalMemInit(constThis);
                }
            }
        }
        else
        {
            /* The initializer was already processed ("on demand") */
        }

        /* Free up the entry we've just processed */

        cmpTempMLrelease(constThis);

        /* Remove the entry from the linked list */

        if  (constLast)
        {
            assert(constLast->dlNext == constThis);
                   constLast->dlNext  = constNext;
        }
        else
        {
            assert(constList         == constThis);
                   constList          = constNext;
        }

        /* Continue with the next entry, if any */

    NEXT:

        constThis = constNext;
    }
    while (constThis);

    /* Were we told to defer all the initializers? */

    if  (noEval)
    {
        IniList         init;

        /* We'll have to come back to these initializers later */

        if  (cmpDeferCnsFree)
        {
            init = cmpDeferCnsFree;
                   cmpDeferCnsFree = init->ilNext;
        }
        else
        {
#if MGDDATA
            init = new IniList;
#else
            init =    (IniList)cmpAllocPerm.nraAlloc(sizeof(*init));
#endif
        }

        init->ilInit = constList;
        init->ilCls  = clsSym;
        init->ilNext = cmpDeferCnsList;
                       cmpDeferCnsList = init;

        /* Mark the class as having deferred initializers */

        clsSym->sdClass.sdcDeferInit = true;
    }
    else
    {
        /* Do we have any runtime initializers for static members? */

        if  (clsSym->sdClass.sdcStatInit)
        {
            /* Make sure the class has a static ctor */

            if  (!cmpGlobalST->stLookupOper(OVOP_CTOR_STAT, clsSym))
            {
                declMods        ctorMod;
                SymDef          ctorSym;

                ctorMod.dmAcc = ACL_DEFAULT;
                ctorMod.dmMod = DM_STATIC;

                ctorSym = cmpDeclFuncMem(clsSym, ctorMod, cmpTypeVoidFnc, clsSym->sdName);
                ctorSym->sdAccessLevel = ACL_PUBLIC;
                ctorSym->sdFnc.sdfCtor = true;
                ctorSym->sdIsImplicit  = true;
                ctorSym->sdIsDefined   = true;

                assert(clsComp && clsUses);

                ctorSym->sdSrcDefList  = cmpGlobalST->stRecordMemSrcDef(clsSym->sdName,
                                                                        NULL,
                                                                        clsComp,
                                                                        clsUses,
                                                                        NULL,
                                                                        0);
            }
        }
    }
}

/*****************************************************************************
 *
 *  Bring the given enum type to "declared" or "evaluated" state.
 */

void                compiler::cmpDeclEnum(SymDef enumSym, bool namesOnly)
{
    SymTab          ourSymTab  = cmpGlobalST;
    Parser          ourParser  = cmpParser;
    Scanner         ourScanner = cmpScanner;

    bool            hasAttribs = false;

    bool            oldStyleDecl;
    bool            classParent;

    __int64         enumNum;
    TypDef          enumTyp;
    DefList         enumDef;
    TypDef          baseTyp;

    SymDef          enumList;
    SymDef          enumLast;

    parserState     save;

    assert(enumSym && enumSym->sdSymKind == SYM_ENUM);

//  if  (!strcmp(enumSym->sdSpelling(), "<enum type name>")) forceDebugBreak();

    /* If we're already at the desired compile-state, we're done */

    if  (enumSym->sdCompileState >= CS_CNSEVALD)
        return;
    if  (enumSym->sdCompileState == CS_DECLARED && namesOnly)
        return;

    /* Did this enum come from an imported symbol table ? */

    if  (enumSym->sdIsImport)
    {
        cycleCounterPause();
        enumSym->sdEnum.sdeMDimporter->MDimportClss(0, enumSym, 0, true);
        cycleCounterResume();
        return;
    }

    /* Detect amd report recursive death */

    if  (enumSym->sdCompileState == CS_DECLSOON)
    {
        cmpError(ERRcircDep, enumSym);
        enumSym->sdCompileState = CS_DECLARED;
        return;
    }

    /* Look for a definition for the enum */

    for (enumDef = enumSym->sdSrcDefList; enumDef; enumDef = enumDef->dlNext)
    {
        if  (enumDef->dlHasDef)
            goto GOT_DEF;
    }

    /* No definition is available for this type, issue an error and give up */

    cmpError(ERRnoEnumDef, enumSym);

    /* Don't bother with any more work on this guy */

    enumSym->sdCompileState = CS_DECLARED;

    return;

GOT_DEF:

    assert(enumSym->sdAccessLevel != ACL_ERROR);

    cmpCurCls    = enumSym;
    cmpCurNS     = cmpGlobalST->stNamespOfSym(enumSym);
    cmpCurST     = cmpGlobalST;

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 2) printf("Declaring enum  '%s'\n", enumSym->sdSpelling());
#endif

    /* Bind any "using" declarations the enum may need */

    cmpBindUseList(enumDef->dlUses);

    /* For now we treat old-style file-scope enums differently */

    oldStyleDecl =  enumDef->dlOldStyle;
    classParent  = (enumSym->sdParent->sdSymKind == SYM_CLASS);

    /* Mark the enum type as "almost defined" */

    if  (enumSym->sdCompileState < CS_DECLARED)
        enumSym->sdCompileState = CS_DECLSOON;

    enumSym->sdIsDefined = true;

    /* Get hold of the enum type */

    enumTyp = enumSym->sdTypeGet(); assert(enumTyp && enumTyp->tdEnum.tdeSymbol == enumSym);

    /* The default underlying type is plain old int */

    baseTyp = ourSymTab->stIntrinsicType(TYP_INT);

    /* First process any base class specifications */

    cmpParser->parsePrepText(&enumDef->dlDef, enumDef->dlComp, save);

    /* Skip over the enum name and look for any custom attributes */

    while (ourScanner->scanTok.tok != tkLCurly)
    {
        switch (ourScanner->scanTok.tok)
        {
            declMods        mods;

            unsigned        attrMask;
            genericBuff     attrAddr;
            size_t          attrSize;

        case tkColon:

            clearDeclMods(&mods);

            /* Swallow the ":" and parse the base type */

            ourScanner->scan();

            if  (namesOnly)
            {
                for (;;)
                {
                    switch (ourScanner->scan())
                    {
                    case tkEOF:
                    case tkLCurly:
                    case tkSColon:
                        break;

                    default:
                        continue;
                    }

                    break;
                }
            }
            else
            {
                baseTyp = cmpParser->parseTypeSpec(&mods, true);

                if  (baseTyp)
                {
                    // ISSUE: Should we disallow the base being another enum type?

                    if  (!varTypeIsIntegral(baseTyp->tdTypeKindGet()) ||
                         baseTyp->tdTypeKind == TYP_BOOL)
                    {
                        cmpError(ERRnoIntType);
                    }
                }
            }

            break;

        case tkATTRIBUTE:

            if  (cmpParser->parseAttribute(0, attrMask, attrAddr, attrSize))
                hasAttribs = true;

            break;

        default:
            ourScanner->scan();
            break;
        }
    }

    enumTyp->tdEnum.tdeIntType = baseTyp;

    /* Process all of the members of the enum */

    assert(ourScanner->scanTok.tok == tkLCurly);

    enumNum  = 0;
    enumList =
    enumLast = NULL;

    while (ourScanner->scan() != tkRCurly)
    {
        Ident           name;
        SymDef          esym;

        SymXinfo        xtraList = NULL;

        if  (ourScanner->scanTok.tok != tkID)
        {
            /* We could have a custom attribute */

            while (ourScanner->scanTok.tok == tkATTRIBUTE)
            {
                unsigned        attrMask;
                genericBuff     attrAddr;
                size_t          attrSize;
                SymDef          attrCtor;

                attrCtor = cmpParser->parseAttribute(ATGT_Enums,
                                                     attrMask,
                                                     attrAddr,
                                                     attrSize);
                if  (attrSize)
                {
                    xtraList = cmpAddXtraInfo(xtraList, attrCtor,
                                                        attrMask,
                                                        attrSize,
                                                        attrAddr);
                }
            }

            if  (ourScanner->scanTok.tok == tkID)
                goto NAM;

            cmpError(ERRnoIdent);

        ERR:

            cmpParser->parseResync(tkComma, tkSColon);
            if  (ourScanner->scanTok.tok != tkComma)
                break;

            continue;
        }

    NAM:

        /*
            UNDONE: We don't correctly detect all recursive dependencies,
                    basically because it's too hard. Consider the
                    following enum declaration:


                    enum e
                    {
                        e1 = e3,
                        e2,
                        e3
                    };

                    We need to somehow notice that 'e3' depends on 'e2' which
                    depends on 'e1' which depends on 'e3', but this is rather
                    difficult.
         */

        name = ourScanner->scanTok.id.tokIdent;

        /* Make sure this is not a redefinition */

        esym = oldStyleDecl ? ourSymTab->stLookupNspSym(name, NS_NORM, cmpGlobalNS)
                            : ourSymTab->stLookupClsSym(name, enumSym);

        if  (esym)
        {
            /*  Name already declared - this is only OK if we're doing a second pass */

            if  (enumSym->sdCompileState == CS_DECLSOON)
            {
                cmpRedefSymErr(esym, ERRredefMem);
                goto ERR;
            }

            assert(esym->sdType == enumTyp);
        }
        else
        {
            assert(namesOnly || !oldStyleDecl);

            /* Declare the enum symbol */

            if  (oldStyleDecl)
                esym = ourSymTab->stDeclareSym(name, SYM_ENUMVAL, NS_NORM, cmpGlobalNS);
            else
                esym = ourSymTab->stDeclareSym(name, SYM_ENUMVAL, NS_NORM, enumSym);

            /* Save the enum type and other flags */

            esym->sdType        = enumTyp;
            esym->sdIsSealed    = true;
            esym->sdAccessLevel = enumSym->sdAccessLevel;

            /* Add the enum to the list */

            if  (enumLast)
                enumLast->sdEnumVal.sdeNext = esym;
            else
                enumList                    = esym;

            enumLast = esym;
        }

        /* Check for an explicit value */

        if  (ourScanner->scan() == tkAsg)
        {
            constVal        cval;

            ourScanner->scan();

            if  (namesOnly)
            {
                /* For now simply skip over the value */

                ourScanner->scanSkipText(tkNone, tkNone, tkComma);
            }
            else
            {
                /* This might be a recursive call */

                if  (esym->sdCompileState >= CS_DECLSOON)
                {
                    cmpParser->parseExprComma();
                    goto NEXT;
                }

                /* Make sure we check for a recursive dependency */

                esym->sdCompileState = CS_DECLSOON;

                /* Parse the initializer */

                if  (cmpParser->parseConstExpr(cval))
                {
                    var_types       vtp = (var_types)cval.cvVtyp;

                    if  (vtp == TYP_ENUM)
                    {
                        if  (!cmpGlobalST->stMatchTypes(enumTyp, cval.cvType))
                        {
                            if  (cval.cvType->tdEnum.tdeIntType->tdTypeKind <= baseTyp->tdTypeKind)
                                cmpWarn(WRNenumConv);
                            else
                                cmpError(ERRnoIntExpr);
                        }

                        vtp = cval.cvType->tdEnum.tdeIntType->tdTypeKindGet();
                    }
                    else
                    {
                        /* Make sure the value is an integer or enum */

                        if  (!varTypeIsIntegral((var_types)cval.cvVtyp))
                        {
                            if  (cval.cvVtyp != TYP_UNDEF)
                                cmpError(ERRnoIntExpr);
                        }
                    }

                    if  (vtp >= TYP_LONG)
                        enumNum = cval.cvValue.cvLval;
                    else
                        enumNum = cval.cvValue.cvIval;
                }
            }
        }

        /* UNDONE: Make sure the value fits in the enum's base integer type */

        esym->sdIsDefined = !namesOnly;

        /* Record any linkage/security specification */

        esym->sdEnumVal.sdeExtraInfo = xtraList;

        /* Record the value in the member */

        if  (baseTyp->tdTypeKind >= TYP_LONG)
        {
            __int64 *       valPtr;

             valPtr = (__int64*)cmpAllocPerm.nraAlloc(sizeof(*valPtr));
            *valPtr = enumNum;

            esym->sdEnumVal.sdEV.sdevLval = valPtr;
        }
        else
        {
            esym->sdEnumVal.sdEV.sdevIval = (__int32)enumNum;
        }

    NEXT:

        /* Increment the default value and look for more */

        enumNum++;


        if  (ourScanner->scanTok.tok == tkComma)
            continue;


        if  (ourScanner->scanTok.tok != tkRCurly)
            cmpError(ERRnoCmRc);

        break;
    }

    /* Terminate the list if we've created one */

    if  (enumLast)
    {
        enumLast->sdEnumVal.sdeNext   = NULL;
        enumTyp ->tdEnum   .tdeValues = enumList;
    }

    /* We're done reading source text from the definition */

    cmpParser->parseDoneText(save);

    /* We've reached 'declared' or 'evaluated' state successfully */

    if  (namesOnly)
        enumSym->sdCompileState = CS_DECLARED;
    else
        enumSym->sdCompileState = CS_CNSEVALD;

    /* Were there any attributes in front of the thing ? */

    if  (hasAttribs && !namesOnly)
    {
        cmpParser->parsePrepText(&enumDef->dlDef, enumDef->dlComp, save);

        while (ourScanner->scanTok.tok != tkLCurly)
        {
            switch (ourScanner->scanTok.tok)
            {
            case tkATTRIBUTE:

                unsigned        attrMask;
                genericBuff     attrAddr;
                size_t          attrSize;
                SymDef          attrCtor;

                /* Parse the attribute blob */

                attrCtor = cmpParser->parseAttribute(ATGT_Enums,
                                                     attrMask,
                                                     attrAddr,
                                                     attrSize);

                /* Add the attribute to the list of "extra info" */

                if  (attrSize)
                {
                    enumSym->sdEnum.sdeExtraInfo = cmpAddXtraInfo(enumSym->sdEnum.sdeExtraInfo,
                                                                  attrCtor,
                                                                  attrMask,
                                                                  attrSize,
                                                                  attrAddr);
                }

                break;

            default:
                ourScanner->scan();
                break;
            }
        }

        cmpParser->parseDoneText(save);
    }
}

/*****************************************************************************
 *
 *  Bring the given typedef to "declared" state.
 */

void                compiler::cmpDeclTdef(SymDef tdefSym)
{
    SymTab          ourSymTab  = cmpGlobalST;
    Parser          ourParser  = cmpParser;
    Scanner         ourScanner = cmpScanner;

    DefList         tdefDef;
    TypDef          tdefTyp;

    TypDef          baseTyp;
    TypDef          type;
    declMods        mods;
    Ident           name;

    parserState     save;

    assert(tdefSym && tdefSym->sdSymKind == SYM_TYPEDEF);

    /* If we're already at the desired compile-state, we're done */

    if  (tdefSym->sdCompileState >= CS_DECLARED)
        return;

    /* Make sure we have at least one definition for the typedefdef */

    tdefDef = tdefSym->sdSrcDefList;
    if  (!tdefDef)
    {
        UNIMPL(!"do we need to report an error here?");
        return;
    }

    /* Detect amd report recursive death */

    if  (tdefSym->sdCompileState == CS_DECLSOON)
    {
        cmpError(ERRcircDep, tdefSym);
        tdefSym->sdCompileState = CS_DECLARED;
        return;
    }

    /* Until we get there, we're on our way there */

    tdefSym->sdCompileState = CS_DECLSOON;

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 2) printf("Declaring typedef '%s'\n", tdefSym->sdSpelling());
#endif

    cmpCurScp    = NULL;
    cmpCurCls    = NULL;
    cmpCurNS     = tdefSym->sdParent;

    if  (cmpCurNS->sdSymKind == SYM_CLASS)
    {
        cmpCurCls = cmpCurNS;
        cmpCurNS  = cmpCurNS->sdParent;
    }

    assert(cmpCurNS->sdSymKind == SYM_NAMESPACE);

    cmpBindUseList(tdefDef->dlUses);

    /* Mark the typedef type as defined */

    tdefSym->sdIsDefined = true;

    /* Get hold of the typedef type */

    tdefTyp = tdefSym->sdTypeGet(); assert(tdefTyp && tdefTyp->tdTypedef.tdtSym == tdefSym);

    /* Start reading the typedef's declaration */

    cmpParser->parsePrepText(&tdefDef->dlDef, tdefDef->dlComp, save);

    /* Parse any leading modifiers */

    ourParser->parseDeclMods(ACL_PUBLIC, &mods);

    /* Parse the type specification */

    baseTyp = ourParser->parseTypeSpec(&mods, true);

    /* Parse the next declarator */

    name = ourParser->parseDeclarator(&mods,
                                      baseTyp,
                                      DN_REQUIRED,
                                      &type,
                                      NULL,
                                      true);

    if  (name && type)
    {
        assert(name == tdefSym->sdName);        // ISSUE: Can this ever fail? If so, issue an error?

        /* Store the actual type in the typedef */

        tdefTyp->tdTypedef.tdtType = cmpDirectType(type);

        /* Make sure the declaration is properly terminated */

        if  (ourScanner->scanTok.tok != tkSColon)
            cmpError(ERRnoSemic);
    }

    /* Have we seen any other definitions for the same tdef type? */

    for (;;)
    {
        tdefDef = tdefDef->dlNext;
        if  (!tdefDef)
            break;

        UNIMPL(!"need to report a redefinition error at the right location, or is this caught earlier?");
    }

    /* We're done reading source text from the definition */

    cmpParser->parseDoneText(save);

    /* We've reached 'declared' state successfully */

    tdefSym->sdCompileState = CS_DECLARED;
}

/*****************************************************************************
 *
 *  Process a class member initializer - the member either is a constant, or
 *  we record the initializer so that it can be later added to the appropriate
 *  constructor body.
 */

void                compiler::cmpEvalMemInit(ExtList cnsDef)
{
    Scanner         ourScanner = cmpScanner;

    SymDef          memSym;
    SymDef          clsSym;
    parserState     save;

    assert(cnsDef->dlExtended);

    memSym = cnsDef->mlSym;    assert(memSym && memSym->sdSymKind == SYM_VAR);
    clsSym = memSym->sdParent; assert(memSym && clsSym->sdSymKind == SYM_CLASS);

    assert(memSym->sdVar.sdvDeferCns);
           memSym->sdVar.sdvDeferCns = false;

    if  (memSym->sdIsStatic && memSym->sdIsSealed)
    {
        Tree            init;

        /* Prepare to read the member's initializer */

        cmpParser->parsePrepText(&cnsDef->dlDef, cnsDef->dlComp, save);

        if  (ourScanner->scanTok.tok != tkLCurly)
        {
            /* Parse the initializer expression and see if it's a constant */

            if  (cmpParseConstDecl(memSym, NULL, &init))
            {
                memSym->sdIsDefined = true;

                if  (ourScanner->scanTok.tok != tkComma &&
                     ourScanner->scanTok.tok != tkSColon)
                {
                    cmpError(ERRnoCmSc);
                }

                /* The member is a constant, no further init is necessary */

                memSym->sdSrcDefList = NULL;

                cmpParser->parseDoneText(save);
                goto DONE;
            }
        }

        cmpParser->parseDoneText(save);
    }

    /* This member will have to be initialized in the constructor(s) */

    ExtList         savDef;

    /* Set the proper flag on the class */

    if  (memSym->sdIsStatic)
        clsSym->sdClass.sdcStatInit = true;
    else
        clsSym->sdClass.sdcInstInit = true;

    /* Save a permanent copy of this member initializer */

#if MGDDATA
    UNIMPL(!"how to copy this sucker when managed?");
#else
    savDef = (ExtList)cmpAllocPerm.nraAlloc(sizeof(*savDef)); *savDef = *cnsDef;
#endif

   /* Store the (single) definition entry in the symbol */

    memSym->sdSrcDefList = savDef;

DONE:

    /* Clear the entry, we won't need it again */

    cnsDef->mlSym = NULL;

    /* This member has been processed */

    memSym->sdCompileState = CS_CNSEVALD;
}

/*****************************************************************************
 *
 *  Given a constant symbol, determine its value.
 */

void                compiler::cmpEvalCnsSym(SymDef sym, bool saveCtx)
{
    STctxSave       save;
    DefList         defs;

    assert(sym);
    assert(sym->sdSymKind  == SYM_VAR);
    assert(sym->sdIsImport == false);

    /* Check for recursion */

    if  (sym->sdCompileState == CS_DECLSOON || sym->sdVar.sdvInEval)
    {
        cmpError(ERRcircDep, sym);
        sym->sdCompileState = CS_CNSEVALD;
        return;
    }

    assert(sym->sdVar.sdvDeferCns);

    /* Save the current symbol table context information, if necessary */

    if  (saveCtx)
        cmpSaveSTctx(save);

    /* Find the definition for the symbol */

    for (defs = sym->sdSrcDefList; defs; defs = defs->dlNext)
    {
        if  (defs->dlHasDef)
        {
            ExtList     decl;

            assert(defs->dlExtended); decl = (ExtList)defs;

            if  (sym->sdParent->sdSymKind == SYM_NAMESPACE)
            {
                cmpDeclFileSym(decl, true);
            }
            else
            {
                /* Set up the context for the initializer */

                cmpCurCls = sym->sdParent; assert(cmpCurCls->sdSymKind == SYM_CLASS);
                cmpCurNS  = cmpGlobalST->stNamespOfSym(cmpCurCls);
                cmpCurST  = cmpGlobalST;

                cmpBindUseList(decl->dlUses);

                /* Now we can process the initializer */

                cmpEvalMemInit(decl);
                break;
            }
        }

        /* Non-global constants always have exactly one relevant definition */

        assert(sym->sdParent == cmpGlobalNS);
    }

    sym->sdCompileState = CS_CNSEVALD;

    /* Restore the current context information */

    if  (saveCtx)
        cmpRestSTctx(save);
}

/*****************************************************************************
 *
 *  Bring the given symbol to "declared" state (along with its children, if
 *  "recurse" is true). If "onlySyn" is non-NULL we only do this for that
 *  one symbol (and if we find it we return true).
 */

bool                compiler::cmpDeclSym(SymDef     sym,
                                         SymDef onlySym, bool recurse)
{
    SymDef          child;

    if  (onlySym && onlySym != sym)
    {
        /* Look inside this scope for the desired symbol */

        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            if  (cmpDeclSym(child, onlySym, true))
                return  true;
        }

        return  false;
    }

    /* For now, ignore classes imported from metadata */

    if  (sym->sdIsImport && sym->sdSymKind == SYM_CLASS)
        return  false;

#ifdef  __SMC__
//  if (sym->sdName) printf("Declare '%s'\n", sym->sdSpelling());
#endif

    /* We need to bring this symbol to declared state */

    if  (sym->sdCompileState < CS_DECLARED)
    {
        SymDef          scmp = cmpErrorComp;

        /* What kind of a symbol do we have? */

#ifdef  DEBUG
        if  (cmpConfig.ccVerbose >= 2)
            if  (sym != cmpGlobalNS)
                printf("Declaring '%s'\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
#endif

        switch (sym->sdSymKind)
        {
            ExtList         dcls;

        case SYM_COMPUNIT:
            break;

        case SYM_NAMESPACE:

            /* Make sure the member list is properly ordered */

            assert(sym->sdMemListOrder);

#ifdef  __SMC__
//          printf("Declare [%08X] %s\n", sym->sdNS.sdnDeclList, sym->sdSpelling());
#endif

            /* Process any top-level names in the namespace */

            for (dcls = sym->sdNS.sdnDeclList; dcls;)
            {
                ExtList         next = (ExtList)dcls->dlNext;

                /*
                    Since cmpDeclFileSym() may move the entry to another list
                    we need to stash away the 'next' link before calling it.
                 */

                if  (!dcls->dlEarlyDecl)
                    cmpDeclFileSym(dcls, true);

                dcls = next;
            }
            break;

        case SYM_ENUMVAL:
            break;

        case SYM_CLASS:
            cmpDeclClass(sym);
            break;

        case SYM_ENUM:
            cmpDeclEnum(sym);
            break;

        case SYM_TYPEDEF:
            cmpDeclTdef(sym);
            break;

        case SYM_PROP:
            sym->sdCompileState = CS_COMPILED;
            break;

        case SYM_VAR:
            if  (sym->sdVar.sdvDeferCns)
                cmpEvalCnsSym(sym, false);
            sym->sdCompileState = CS_COMPILED;
            break;

        default:
            NO_WAY(!"unexpected symbol");
        }

        cmpErrorComp = scmp;
    }

    /* Process the children if the caller so desires */

    if  (recurse && sym->sdSymKind == SYM_NAMESPACE)
    {
        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            cmpDeclSym(child, NULL, true);
        }
    }

    return  true;
}

/*****************************************************************************
 *
 *  Bring the given symbol to "declared" state - the caller has already
 *  checked for imports and the symbol being declared.
 */

bool                compiler::cmpDeclSymDoit(SymDef sym, bool noCnsEval)
{
    SymTab          ourSymTab  = cmpGlobalST;
    Parser          ourParser  = cmpParser;
    Scanner         ourScanner = cmpScanner;

    STctxSave       stabState;
    scannerState    scanState;

    assert(sym->sdCompileState < CS_DECLARED);
    assert(sym->sdIsImport == false);

    /* Suspend the scanner so that we can process this symbol's definition */

    ourScanner->scanSuspend(scanState);

    /* Save the current symbol table context information */

    cmpSaveSTctx(stabState);

    /* Declare the symbol */

    switch (sym->sdSymKind)
    {
    case SYM_CLASS:
        cmpDeclClass(sym, noCnsEval);
        break;

    case SYM_ENUM:
        cmpDeclEnum(sym);
        break;

    case SYM_TYPEDEF:
        cmpDeclTdef(sym);
        break;

    default:
        cmpDeclSym(sym, sym, false);
        break;
    }

    /* Restore the current context information */

    cmpRestSTctx(stabState);

    /* Restore the scanner's state */

    ourScanner->scanResume(scanState);

    return (sym->sdCompileState < CS_DECLARED);
}

/*****************************************************************************
 *
 *  Reverse the given member list "in place".
 */

ExtList             compiler::cmpFlipMemList(ExtList memList)
{
    DefList         tmpMem = memList;
    DefList         prvMem = NULL;

    if  (memList)
    {
        do
        {
            DefList         tempCM;

            assert(tmpMem->dlExtended);

            tempCM = tmpMem->dlNext;
                     tmpMem->dlNext = prvMem;

            prvMem = tmpMem;
            tmpMem = tempCM;
        }
        while (tmpMem);
    }

    return  (ExtList)prvMem;
}

/*****************************************************************************
 *
 *  Recursively look for any constants and enums and try to declare them.
 */

void                compiler::cmpDeclConsts(SymDef sym, bool fullEval)
{
    switch (sym->sdSymKind)
    {
        ExtList         decl;
        SymDef          child;

    case SYM_ENUM:
        cmpDeclEnum(sym, !fullEval);
        break;

    case SYM_VAR:
        if  (sym->sdVar.sdvConst && fullEval)
            cmpDeclSym(sym);
        break;

    case SYM_NAMESPACE:

        /* Make sure the member list is properly ordered */

        if  (!sym->sdMemListOrder)
        {
            sym->sdNS.sdnDeclList = cmpFlipMemList(sym->sdNS.sdnDeclList);
            sym->sdMemListOrder   = true;
        }

        /* Visit all declarations in the namespace */

        for (decl = sym->sdNS.sdnDeclList; decl; decl = (ExtList)decl->dlNext)
        {
            if  (decl->dlEarlyDecl)
                cmpDeclFileSym(decl, fullEval);
        }

        /* Recursively visit all the kid namespaces */

        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            cmpDeclConsts(child, fullEval);
        }

        break;
    }
}

/*****************************************************************************
 *
 *  Start compilation - we do things such as declare any global enum types,
 *  and so on.
 */

bool                compiler::cmpStart(const char *defOutFileName)
{
    bool            result;

    /* Set a trap for any errors */

    setErrorTrap(this);
    begErrorTrap
    {
        const   char *  outfnm;
        char            outfbf[_MAX_PATH];
        SymDef          tmpSym;
        SymList         arrLst;
        SymDef          attrCls;

        const   char *  CORname;

        char            path[_MAX_PATH ];
        char            fnam[_MAX_FNAME];
        char            fext[_MAX_EXT  ];

        /* Finalize the "using" logic */

        cmpParser->parseUsingDone();

        /*
            Now we visit all namespaces we've seen, looking for enums and
            constants to pre-declare. That is, we merely enter the names
            of the enumerator values and constants in the symbol table,
            and later, in a second pass (right below), we evaluate their
            actual values.
         */

        cmpDeclConsts(cmpGlobalNS, false);

        /* Prepare the output logic (i.e. MSIL/metadata generation) */

        cmpPrepOutput();

        /* Make sure "String", "Object" and "Class" get declared first */

        if  (cmpClassObject && !cmpClassObject->sdIsImport)
            cmpDeclSym(cmpClassObject);
        if  (cmpClassString && !cmpClassString->sdIsImport)
            cmpDeclSym(cmpClassString);
        if  (cmpClassType   && !cmpClassType  ->sdIsImport)
            cmpDeclSym(cmpClassType);

        /* Visit all namespaces again, declare constants/enum values for real */

        cmpDeclConsts(cmpGlobalNS, true);

        /* We should have bailed by now if something really bad has happened */

        assert(cmpFatalCount == 0);

        /* Declare all the symbols we've found */

        cmpDeclSym(cmpGlobalNS, NULL, true);

        /* For now, we simply bail if there are errors */

        if  (cmpErrorCount)
            goto DONE;

        /* Are there any deferred member initializers to be processed? */

        if  (cmpDeferCnsList)
        {
            IniList         temp;
            IniList         init = cmpDeferCnsList;

            cmpCurScp = NULL;

            do
            {
                /* Grab the next link, the call will trash it */

                temp = init;
                       init = init->ilNext;

                /* Process the initializers and free up the entry */

                cmpEvalMemInits(NULL, NULL, false, temp);
            }
            while (init);
        }

        /* Compile any variables that are undimensioned arrays */

        for (arrLst = cmpNoDimArrVars; arrLst; arrLst = arrLst->slNext)
            cmpCompSym(arrLst->slSym, arrLst->slSym, false);

        /* Figure out the name of the output file */

        outfnm = cmpConfig.ccOutFileName;

        if  (outfnm == NULL)
        {
            if  (cmpEntryPointCls && cmpEntryPointCls->sdSymKind == SYM_CLASS)
            {
                outfnm = cmpEntryPointCls->sdSpelling();
            }
            else if (defOutFileName && defOutFileName[0])
            {
                outfnm = defOutFileName;
            }
            else
                cmpFatal(ERRnoOutfName);

            /* Append the appropriate extension to the base file name */

            strcpy(outfbf, outfnm);
            strcat(outfbf, cmpConfig.ccOutDLL ? ".dll" : ".exe");

            outfnm = outfbf;
        }

        /* Invent a name for the image if we weren't given one */

        CORname = cmpConfig.ccOutName;

        if  (!CORname)
        {
            _splitpath(outfnm, NULL, NULL, fnam, fext);
             _makepath(path,   NULL, NULL, fnam, fext);

            CORname = path;
        }

        /* Set the module name */

        if  (cmpWmde->SetModuleProps(cmpUniConv(CORname, strlen(CORname)+1)))
            cmpFatal(ERRmetadata);

        /* Get hold of the assembly emitter interface */

        cycleCounterPause();

        if  (FAILED(cmpWmdd->DefineAssem(cmpWmde, &cmpWase)))
            cmpFatal(ERRopenCOR);

        cycleCounterResume();

        /* Are we supposed to create an assembly ? */

        if  (cmpConfig.ccAssembly)
        {
            ASSEMBLYMETADATA    assData;
            mdAssembly          assTok;

            WCHAR   *           wideName;

            char                fpath[_MAX_PATH ];
            char                fname[_MAX_FNAME];
            char                fext [_MAX_EXT  ];

            /* Fill in the assembly data descriptor */

            memset(&assData, 0, sizeof(assData));

            /* Strip drive/directory from the filename */

            _splitpath(outfnm, NULL, NULL, fname, fext);
             _makepath( fpath, NULL, NULL, fname, NULL);

            wideName = cmpUniConv(fpath, strlen(fpath)+1);

            /* Ready to start creating our assembly */

            cycleCounterPause();

            if  (FAILED(cmpWase->DefineAssembly(NULL, 0,    // originator
                                                CALG_SHA1,  // hash algorithm
                                                wideName,   // name
                                                &assData,   // assembly data
                                                NULL,       // title
                                                NULL,       // desc
                                                wideName,   // default alias
                                                0,          // flags
                                                &assTok)))
            {
                cmpFatal(ERRopenCOR);
            }

            cycleCounterResume();

            /* Record our assembly definition token for later use */

            cmpCurAssemblyTok = assTok;
        }

#ifdef  OLD_IL
        if  (cmpConfig.ccOILgen) goto SKIP_MD;
#endif

#ifdef  SETS

        /* Did we notice any collection operators in the source code? */

        if  (cmpSetOpCnt)
        {
            unsigned        count = COLL_STATE_VALS / 2;
            SymDef  *       table;

            table = cmpSetOpClsTable = (SymDef*)cmpAllocPerm.nraAlloc(count*sizeof(*cmpSetOpClsTable));

            /* Create classes to hold filter state for various argument counts */

            do
            {
                table[--count] = cmpDclFilterCls(2*count);
            }
            while (count);
        }

#endif

        /* Generate metadata for all types */

        cmpGenTypMetadata(cmpGlobalNS);

        /* remember whether we've seen class "Attribute" */

        attrCls = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("Attribute"), NS_NORM, cmpNmSpcSystem);

        if  (attrCls && attrCls->sdSymKind == SYM_CLASS && attrCls->sdClass.sdcHasBodies)
            cmpAttrClsSym = attrCls;

        attrCls = cmpGlobalST->stLookupNspSym(cmpGlobalHT->hashString("AttributeUsageAttribute"), NS_NORM, cmpNmSpcSystem);

        if  (attrCls && attrCls->sdSymKind == SYM_CLASS && attrCls->sdClass.sdcHasBodies)
            cmpAuseClsSym = attrCls;

#ifdef  DEBUG
#ifndef __IL__

        if  (1)
        {
            /* Find the "System::AttributeTargets" enum */

            Ident           tname;
            SymDef          tsym;

            tname = cmpGlobalHT->hashString("AttributeTargets");
            tsym  = cmpGlobalST->stLookupNspSym(tname, NS_NORM, cmpNmSpcSystem);

            if  (!tsym || tsym->sdSymKind != SYM_ENUM)
            {
                cmpGenFatal(ERRbltinTp, "System::AttributeTargets");
            }
            else if (tsym->sdCompileState >= CS_CNSEVALD)
            {
                /* Make sure our values agree with what it's in the library */

                struct
                {
                    const   char *  atcName;
                    unsigned        atcMask;
                }
                                check[] =
                {
                    { "Assembly"    , ATGT_Assemblies  },
                    { "Module"      , ATGT_Modules     },
                    { "Class"       , ATGT_Classes     },
                    { "Struct"      , ATGT_Structs     },
                    { "Enum"        , ATGT_Enums       },
                    { "Constructor" , ATGT_Constructors},
                    { "Method"      , ATGT_Methods     },
                    { "Property"    , ATGT_Properties  },
                    { "Field"       , ATGT_Fields      },
                    { "Event"       , ATGT_Events      },
                    { "Interface"   , ATGT_Interfaces  },
                    { "Parameter"   , ATGT_Parameters  },
                };

                for (unsigned i = 0; i < arraylen(check); i++)
                {
                    const   char *  name;
                    SymDef          mem;

                    name = check[i].atcName;
                    mem  = cmpGlobalST->stLookupScpSym(cmpGlobalHT->hashString(name), tsym);

                    if  (!mem || mem->sdSymKind != SYM_ENUMVAL)
                    {
                        printf("WARNING: didn't find enum value 'System::AttributeTargets::%s'\n", name);
                    }
                    else if (mem->sdEnumVal.sdEV.sdevIval != (int)check[i].atcMask)
                    {
                        printf("WARNING: value of 'System::AttributeTargets::%s' doesn't agree with compiler\n", name);
                    }
                }
            }
        }

#endif
#endif

#ifdef  SETS

        /* Did we notice any collection operators in the source code? */

        if  (cmpSetOpCnt)
        {
            SymDef          clsSym;
            TypDef          clsType;

            /* Create the class that will hold all the sort/filter funclets */

            clsSym = cmpGlobalST->stDeclareSym(cmpGlobalHT->hashString("$collection$funclets"),
                                               SYM_CLASS,
                                               NS_HIDE,
                                               cmpGlobalNS);

            clsSym->sdClass.sdcCollState = true;
            clsSym->sdClass.sdcFlavor    = STF_CLASS;
            clsSym->sdCompileState       = CS_DECLARED;
            clsSym->sdIsManaged          = true;
            clsSym->sdIsImplicit         = true;

            /* Create the class type and set the base to "Object" */

            clsType = clsSym->sdTypeGet();
            clsType->tdClass.tdcBase = cmpClassObject->sdType;

            /* Record the class symbol for later */

            cmpCollFuncletCls = clsSym;
        }
        else
#endif
        {
            /* Declare a class to hold any unmanaged string literals */

            SymDef          clsSym;
            TypDef          clsType;

            /* Create the class that will hold all the sort/filter funclets */

            clsSym = cmpGlobalST->stDeclareSym(cmpGlobalHT->hashString("$sc$"),
                                               SYM_CLASS,
                                               NS_HIDE,
                                               cmpGlobalNS);

            clsSym->sdClass.sdcFlavor    = STF_CLASS;
            clsSym->sdCompileState       = CS_DECLARED;
            clsSym->sdIsManaged          = true;
            clsSym->sdIsImplicit         = true;

            /* Create the class type and set the base to "Object" */

            clsType = clsSym->sdTypeGet();
            clsType->tdClass.tdcBase = cmpClassObject->sdType;

            /* Record the class symbol for later */

            cmpStringConstCls = clsSym;

            /* Make sure metadata is generated for the class */

            cmpGenClsMetadata(clsSym);
        }

        /* Generate metadata for all global functions and variables */

        cmpGenGlbMetadata(cmpGlobalNS);

        /* Generate metadata for all class/enum members */

        tmpSym = cmpTypeDefList;

        while (tmpSym)
        {
            cmpGenMemMetadata(tmpSym);

            switch (tmpSym->sdSymKind)
            {
            case SYM_CLASS:
                tmpSym = tmpSym->sdClass.sdNextTypeDef;
                break;

            case SYM_ENUM:
                tmpSym = tmpSym->sdEnum .sdNextTypeDef;
                break;

            default:
                UNIMPL(!"unexpected entry in typedef list");
            }
        }

        /* If we're generating debug info, make sure we have the right interface */

        if  (cmpConfig.ccLineNums || cmpConfig.ccGenDebug)
        {
            if  (!cmpSymWriter)
            {
                if  (cmpWmde->CreateSymbolWriter(cmpUniConv(outfnm,
                                                            strlen(outfnm)+1),
                                                            &cmpSymWriter))
                {
                    cmpFatal(ERRmetadata);
//                  cmpConfig.ccLineNums = cmpConfig.ccGenDebug = false;
                }

                assert(cmpSymWriter);
            }
        }

#ifdef  OLD_IL
    SKIP_MD:
#endif

#ifdef  OLD_IL

        if  (cmpConfig.ccOILgen)
        {
            result = cmpOIgen->GOIinitialize(this, outfnm, &cmpAllocPerm);
            goto DONE;
        }

#endif

        /* Tell the output logic what file to generate */

        cmpPEwriter->WPEsetOutputFileName(outfnm);

        /* Looks like everything went fine */

        result = false;

    DONE:

        /* End of the error trap's "normal" block */

        endErrorTrap(this);
    }
    chkErrorTrap(fltErrorTrap(this, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(this);

        /* Some kind of a fatal error occurred */

        result = true;
    }

    return  result;
}

/*****************************************************************************
 *
 *  Compile the class with the matching name and all of its dependents. If
 *  NULL is passed for the class name, all the classes in the compilation
 *  units we've seen will be compiled.
 */

bool                compiler::cmpClass(const char *name)
{
    bool            result;

    /* Don't bother if something really bad has happened */

    if  (cmpFatalCount)
        return  false;

    assert(name == NULL);   // can't allow specific class compilation for now

    /* Set a trap for any errors */

    setErrorTrap(this);
    begErrorTrap
    {
        SymList         vtbls;

        /* Compile everything we find in all the compilation units */

#ifdef  SETS

        for (;;)
        {
            unsigned        cnt = cmpClassDefCnt;

            cmpCompSym(cmpGlobalNS, NULL, true);

            if  (cnt == cmpClassDefCnt)
                break;
        }

        /* Generate any collection operator funclets we might need */

        while (cmpFuncletList)
        {
            funcletList     fclEntry;

            /* Remove the next entry from the list and generate it */

            fclEntry = cmpFuncletList;
                       cmpFuncletList = fclEntry->fclNext;

            cmpGenCollFunclet(fclEntry->fclFunc,
                              fclEntry->fclExpr);
        }

#else

        cmpCompSym(cmpGlobalNS, NULL, true);

#endif

        /* Generate any unmanaged vtables */

        for (vtbls = cmpVtableList; vtbls; vtbls = vtbls->slNext)
            cmpGenVtableContents(vtbls->slSym);

        /* Looks like we've succeeded */

        result = false;

        /* End of the error trap's "normal" block */

        endErrorTrap(this);
    }
    chkErrorTrap(fltErrorTrap(this, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(this);

        /* Some kind of a fatal error occurred */

        result = true;
    }

    return  result;
}

/*****************************************************************************
 *
 *  Set the current position to the definition location of the given member.
 */

void                compiler::cmpSetSrcPos(SymDef memSym)
{
    ExtList         defs;
    SymDef          clsSym = memSym->sdParent;

    assert(clsSym && clsSym->sdSymKind == SYM_CLASS);

    /* Try to find the source position of the member decl */

    for (defs = clsSym->sdClass.sdcMemDefList;
         defs;
         defs = (ExtList)defs->dlNext)
    {
        assert(defs->dlExtended);

        if  (defs->mlSym == memSym)
        {
            cmpErrorComp = defs->dlComp;

            cmpScanner->scanSetTokenPos(defs->dlDef.dsdSrcLno);

            return;
        }
    }

    cmpErrorComp = NULL;
    cmpErrorSrcf = NULL;
    cmpErrorTree = NULL;
}

/*****************************************************************************
 *
 *  Compile the given class.
 */

void                compiler::cmpCompClass(SymDef clsSym)
{
    ExtList         defs;
    SymDef          memSym;
    bool            genInst;

    /* Bail if the class has no method bodies at all */

    if  (!clsSym->sdClass.sdcHasBodies)
        return;

#ifdef  SETS

    if  (clsSym->sdCompileState >= CS_COMPILED)
        return;

    clsSym->sdCompileState = CS_COMPILED;

#endif

    /* Compile all members of the class */

    if  (!clsSym->sdClass.sdcSpecific)
    {
        /* Walk all the member definitions of the class */

        for (defs = clsSym->sdClass.sdcMemDefList;
             defs;
             defs = (ExtList)defs->dlNext)
        {
            assert(defs->dlExtended);

            if  (defs->dlHasDef && defs->mlSym)
            {
                SymDef          memSym = defs->mlSym;

                switch (memSym->sdSymKind)
                {
                case SYM_VAR:
                    cmpCompVar(memSym, defs);
                    break;

                case SYM_FNC:
                    cmpCompFnc(memSym, defs);
                    break;

                case SYM_CLASS:
                    cmpCompClass(memSym);
                    break;
                }
            }
        }

//      printf("Gen code for members of %s\n", clsSym->sdSpelling());

        /* Compile any compiler-declared methods */

        if  (clsSym->sdClass.sdcOvlOpers && clsSym->sdClass.sdcFlavor != STF_DELEGATE)
        {
            SymDef          ctorSym;

            ctorSym = cmpGlobalST->stLookupOper(OVOP_CTOR_STAT, clsSym);
            if  (ctorSym && ctorSym->sdIsImplicit)
                cmpCompFnc(ctorSym, NULL);

            ctorSym = cmpGlobalST->stLookupOper(OVOP_CTOR_INST, clsSym);
            while (ctorSym)
            {
                if  (ctorSym->sdIsImplicit)
                    cmpCompFnc(ctorSym, NULL);

                ctorSym = ctorSym->sdFnc.sdfNextOvl;
            }
        }
    }

    genInst = clsSym->sdClass.sdcSpecific;

    /*
        Make sure all methods have bodies, compile nested classes, and
        also make sure all constant members have been initialized.
     */

    for (memSym = clsSym->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        switch (memSym->sdSymKind)
        {
            SymDef          mfnSym;

        case SYM_FNC:

            for (mfnSym = memSym; mfnSym; mfnSym = mfnSym->sdFnc.sdfNextOvl)
            {
                if  (genInst)
                {
                    cmpCompFnc(mfnSym, NULL);
                    continue;
                }

                if  (!mfnSym->sdIsDefined     &&
                     !mfnSym->sdIsAbstract    &&
                     !mfnSym->sdFnc.sdfNative &&
                     !mfnSym->sdFnc.sdfDisabled)
                {
                    if  (!cmpFindLinkInfo(mfnSym->sdFnc.sdfExtraInfo))
                    {
                        unsigned    errNum = ERRnoFnDef;
                        SymDef      errSym = mfnSym;

                        if  (mfnSym->sdFnc.sdfProperty)
                        {
                            bool            setter;

                            /* Find the matching property symbol */

                            errSym = cmpFindPropertyDM(mfnSym, &setter);
                            if  (errSym)
                            {
                                assert(errSym->sdSymKind == SYM_PROP);

                                assert(errSym->sdProp.sdpGetMeth == mfnSym ||
                                       errSym->sdProp.sdpSetMeth == mfnSym);

                                errNum = setter ? ERRnoPropSet
                                                : ERRnoPropGet;
                            }
                            else
                                errSym = mfnSym;
                        }

                        cmpSetSrcPos(mfnSym);
                        cmpErrorQnm(errNum, errSym);
                    }
                }
            }
            break;

        case SYM_VAR:

            if  (memSym->sdIsStatic &&
                 memSym->sdIsSealed && !memSym->sdVar.sdvHadInit)
            {
                cmpSetSrcPos(memSym);
                cmpErrorQnm(ERRnoVarInit, memSym);
            }

            break;

        case SYM_CLASS:
            cmpCompClass(memSym);
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Compile the given variable.
 */

void                compiler::cmpCompVar(SymDef varSym, DefList srcDesc)
{
    parserState     save;

    memBuffPtr      addr = memBuffMkNull();

    Scanner         ourScanner = cmpScanner;

    assert(varSym->sdSymKind == SYM_VAR);

    /* Constants don't need any "compilation", right? */

    if  (varSym->sdVar.sdvConst)
        return;

    /* If the variable is read-only, it better have an initializer */

#if 0
    if  (varSym->sdIsSealed && !varSym->sdVar.sdvHadInit)
        cmpErrorQnm(ERRnoVarInit, varSym);
#endif

    /* Initializer for managed class members are handled elsewhere */

    if  (varSym->sdIsManaged)
        return;

    /* The type of the variable better not be a managed one */

    assert(varSym->sdType->tdIsManaged == false);

    assert(varSym->sdCompileState == CS_DECLARED ||
           varSym->sdCompileState == CS_CNSEVALD);

#ifdef  DEBUG

    if  (cmpConfig.ccVerbose)
    {
        printf("Compiling '%s'\n", cmpGlobalST->stTypeName(varSym->sdType, varSym, NULL, NULL, true));

        printf("    Defined at ");
        cmpGlobalST->stDumpSymDef(&srcDesc->dlDef, srcDesc->dlComp);
        printf("\n");

        UNIMPL("");
    }

#endif

#ifdef  __SMC__
//  printf("Beg compile '%s'\n", cmpGlobalST->stTypeName(varSym->sdType, varSym, NULL, NULL, true));
#endif

    /* Prepare scoping information for the function */

    cmpCurScp    = NULL;
    cmpCurCls    = NULL;
    cmpCurNS     = varSym->sdParent;

    /* Is this a class member? */

    if  (cmpCurNS->sdSymKind == SYM_CLASS)
    {
        /* Yes, update the class/namespace scope values */

        cmpCurCls = cmpCurNS;
        cmpCurNS  = cmpCurNS->sdParent;
    }

    assert(cmpCurNS->sdSymKind == SYM_NAMESPACE);

    cmpBindUseList(srcDesc->dlUses);

    /* Start reading from the symbol's definition text */

    cmpParser->parsePrepText(&srcDesc->dlDef, srcDesc->dlComp, save);

    /* Skip over to the initializer (it always starts with "=") */

    if  (srcDesc->dlDeclSkip)
        ourScanner->scanSkipSect(srcDesc->dlDeclSkip);

    // ISSUE: This seems fragile - what if "=" could appear within the declarator?

    while (ourScanner->scan() != tkAsg)
    {
        assert(ourScanner->scanTok.tok != tkEOF);
    }

    assert(ourScanner->scanTok.tok == tkAsg); ourScanner->scan();

    /* Process the variable initializer */

    cmpInitVarAny(addr, varSym->sdType, varSym);
    cmpInitVarEnd(varSym);

    /* We're done reading source text from the definition */

    cmpParser->parseDoneText(save);

#ifdef  __SMC__
//  printf("End compile '%s'\n", cmpGlobalST->stTypeName(varSym->sdType, varSym, NULL, NULL, true));
#endif

    /* The variable has been fully compiled */

    varSym->sdCompileState = CS_COMPILED;
}

/*****************************************************************************
 *
 *  Return a source file cookie (for debug info output) for the specified
 *  compilation unit.
 */

void        *       compiler::cmpSrcFileDocument(SymDef srcSym)
{
    void    *       srcDoc;

    assert(srcSym->sdSymKind == SYM_COMPUNIT);

    srcDoc = srcSym->sdComp.sdcDbgDocument;

    if  (!srcDoc)
    {
        const   char *  srcFil = srcSym->sdComp.sdcSrcFile;

        if (cmpSymWriter->DefineDocument(cmpUniConv(srcFil, strlen(srcFil)+1),
                                         &srcDoc))
        {
            cmpGenFatal(ERRdebugInfo);
        }

        srcSym->sdComp.sdcDbgDocument = srcDoc;
    }

    return  srcDoc;
}

/*****************************************************************************
 *
 *  Compile the given function.
 */

void                compiler::cmpCompFnc(SymDef fncSym, DefList srcDesc)
{
    bool            error = false;

    Tree            body;

    unsigned        fnRVA;

    TypDef          fncTyp = fncSym->sdType;
    bool            isMain = false;

    Tree            labelList  = NULL;
    SymDef          labelScope = NULL;

    nraMarkDsc      allocMark;

    Scanner         ourScanner = cmpScanner;

#ifdef  SETS
    char            bodyBuff[512];
#endif

    fncSym->sdCompileState = CS_COMPILED;

#ifdef  __SMC__
//  printf("Beg compile '%s'\n", cmpGlobalST->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true));
#endif

#ifdef  DEBUG

    if  (cmpConfig.ccVerbose)
    {
        printf("Compiling '%s'\n", cmpGlobalST->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true));

        if  (srcDesc)
        {
            printf("    Defined at ");
            cmpGlobalST->stDumpSymDef(&srcDesc->dlDef, srcDesc->dlComp);
        }

        printf("\n");
    }

#endif

    assert(fncSym->sdFnc.sdfDisabled == false);

#ifdef  OLD_IL
    if  (!cmpConfig.ccOILgen)
#endif
    {
        /* Make sure metadata for the class has been generated */

        if  (!fncSym->sdFnc.sdfMDtoken)
            cmpGenFncMetadata(fncSym);

        /* Make sure we have a token for the method */

        assert(fncSym->sdFnc.sdfMDtoken);
    }

    /* Mark the code generator allocator */

    cmpAllocCGen.nraMark(&allocMark);

    /* Set a trap for any errors */

    setErrorTrap(this);
    begErrorTrap
    {
        parserState     save;

        SymDef          owner = fncSym->sdParent;

        bool            hadGoto;

        bool            baseCT;
        bool            thisCT;

        unsigned        usrLclCnt;

#if 0
        if  (!strcmp(fncSym->sdSpelling(), "<method name>") &&
             !strcmp( owner->sdSpelling(), "<class  name>"))
        {
             forceDebugBreak();
        }
#endif

        /* Tell everyone which method we're compiling */

        cmpCurFncSym = fncSym;

        /* Prepare scoping information for the function */

        cmpCurScp    = NULL;
        cmpCurCls    = NULL;
        cmpCurNS     = owner;

        /* Is this a class member? */

        if  (cmpCurNS->sdSymKind == SYM_CLASS)
        {
            /* It's a class member -- note its management status */

            cmpManagedMode = owner->sdIsManaged;

            /* Now update the class/namespace scope values */

            cmpCurCls = cmpCurNS;

            do
            {
                cmpCurNS  = cmpCurNS->sdParent;
            }
            while (cmpCurNS->sdSymKind == SYM_CLASS);
        }
        else
            cmpManagedMode = false;

        assert(cmpCurNS && cmpCurNS->sdSymKind == SYM_NAMESPACE);

        /* Is this a function with a compiler-supplied body? */

        if  (fncSym->sdIsImplicit)
        {
            char    *       fnBody;

            /* Is this a method of an instance of a generic type ? */

            if  (fncSym->sdFnc.sdfInstance)
            {
                Tree            stub;

                assert(fncSym->sdFnc.sdfGenSym);

                /* Create a fake method body */

                stub = cmpCreateExprNode(NULL, TN_INST_STUB, cmpTypeVoid, NULL, NULL);
                stub->tnFlags |= TNF_NOT_USER;

                /* Create a block to hold the stub, the MSIL generator does the rest */

                body = cmpCreateExprNode(NULL, TN_BLOCK, cmpTypeVoid);

                body->tnBlock.tnBlkDecl = NULL;
                body->tnBlock.tnBlkStmt = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, stub, NULL);

                /* Clear all the flags the parser would otherwise set */

                labelList = NULL;

                usrLclCnt = 0;

                hadGoto   = false;
                baseCT    = fncSym->sdFnc.sdfCtor;
                thisCT    = fncSym->sdFnc.sdfCtor;

                goto GOT_FNB;
            }

            /* This is a compiler-defined function, create a body for it */

            assert(owner && owner->sdSymKind == SYM_CLASS);

            /* There is no real source code for this function */

            cmpCurFncSrcBeg = 0;

#ifdef  SETS

            /* Is this a sort/filter funclet ? */

            if  (fncSym->sdFnc.sdfFunclet)
            {
                /* Create the outermost block node and go generate the code */

                body = cmpParser->parseFuncBlock(fncSym);

                /* No need to check for initialized variable use */

                usrLclCnt = 0;

                goto GOT_FNB;
            }

            if  (owner->sdClass.sdcCollState)
            {
                unsigned        nnum;
                unsigned        ncnt;

                assert(fncSym->sdFnc.sdfCtor);

                strcpy(bodyBuff, "ctor() { baseclass(); ");

                /*
                    We need to know the number of arguments -- we figure it out from the name of the class.
                 */

                assert(memcmp(owner->sdSpelling(), CFC_CLSNAME_PREFIX, strlen(CFC_CLSNAME_PREFIX)) == 0);

                ncnt = atoi(owner->sdSpelling() + strlen(CFC_CLSNAME_PREFIX));

                assert(ncnt && ncnt <= COLL_STATE_VALS);

                for (nnum = 0; nnum < ncnt; nnum++)
                {
                    char            init[16];
                    sprintf(init, "$V%u = $A%u; ", nnum, nnum);
                    strcat(bodyBuff, init);
                }

                strcat(bodyBuff, " }\x1A");

                assert(strlen(bodyBuff) < arraylen(bodyBuff));

//              printf("Function body = '%s'\n", bodyBuff);

                fnBody = bodyBuff;
            }
            else
#endif
            {
                assert(fncSym->sdFnc.sdfCtor);

//              printf("gen ctor %08X for '%s'\n", fncSym, fncSym->sdParent->sdSpelling());

                /* Create the body for the compiler-declared ctor */

                if  (owner->sdType->tdClass.tdcValueType || fncSym->sdIsStatic)
                    fnBody = "ctor() {              }\x1A";
                else
                    fnBody = "ctor() { baseclass(); }\x1A";
            }

            /* Read from the supplied function definition */

            cmpScanner->scanString(fnBody, &cmpAllocPerm);
        }
        else
        {
            /* Make sure the function has been properly marked */

            assert(fncSym->sdIsDefined);

            /* Start reading from the symbol's definition text */

            cmpParser->parsePrepText(&srcDesc->dlDef, srcDesc->dlComp, save);

            /* Remember where the function body starts */

            cmpCurFncSrcBeg = ourScanner->scanGetTokenLno();

            if  (fncSym->sdFnc.sdfEntryPt)
            {
                /* Did we already have an entry point? */

                if  (cmpFnSymMain)
                    cmpErrorQSS(ERRmulEntry, cmpFnSymMain, fncSym);

                cmpFnSymMain = fncSym;
                isMain       = true;
            }
        }

#ifdef  SETS
        assert(cmpCurFuncletBody == NULL);
#endif

        /* Skip to the function's body (it always starts with "{") */

        while (ourScanner->scanTok.tok != tkLCurly)
        {
            assert(ourScanner->scanTok.tok != tkEOF);

            if  (ourScanner->scan() == tkColon && fncSym->sdFnc.sdfCtor)
            {
                /* Presumably we have a base class ctor call */

                break;
            }
        }

        /* Is there a definition record for the symbol? */

        if  (srcDesc)
        {
            cmpBindUseList(srcDesc->dlUses);
            cmpCurComp   = srcDesc->dlComp;
        }
        else
        {

#ifdef  SETS
            if  (owner->sdClass.sdcCollState)
            {
                cmpCurComp = NULL;
            }
            else
#endif
            {
                assert(fncSym->sdIsImplicit);
                assert(fncSym->sdSrcDefList);

                cmpBindUseList(fncSym->sdSrcDefList->dlUses);
                cmpCurComp   = fncSym->sdSrcDefList->dlComp;
            }
        }

        /* Parse the body of the function */

        body = cmpParser->parseFuncBody(fncSym, &labelList,
                                                &usrLclCnt,
                                                &hadGoto,
                                                &baseCT,
                                                &thisCT);

        if  (body)
        {
            SymDef          fnScp;
            mdSignature     fnSig;

        GOT_FNB:

#ifdef  DEBUG
#ifdef  SHOW_CODE_OF_THIS_FNC
            cmpConfig.ccDispCode = !strcmp(fncSym->sdSpelling(), SHOW_CODE_OF_THIS_FNC);
#endif
#endif

            /* Note the end source line# of the function (for debug info purposes) */

            if  (body && body->tnOper == TN_BLOCK)
                cmpCurFncSrcEnd = body->tnBlock.tnBlkSrcEnd;
            else
                cmpCurFncSrcEnd = ourScanner->scanGetTokenLno();

            if  (cmpConfig.ccLineNums || cmpConfig.ccGenDebug)
            {
                if  (cmpSymWriter->OpenMethod(fncSym->sdFnc.sdfMDtoken))
                    cmpGenFatal(ERRdebugInfo);
            }

            /* Can/should there be a call to the base class ctor? */

            cmpBaseCTcall =
            cmpBaseCTisOK = false;

            cmpThisCTcall = thisCT;

            if  (fncSym->sdFnc.sdfCtor)
            {
                TypDef          ownerTyp = owner->sdType;

                assert(owner->sdSymKind == SYM_CLASS);

                if  (ownerTyp->tdClass.tdcBase && !ownerTyp->tdClass.tdcValueType)
                {
                    cmpBaseCTcall = !baseCT;
                    cmpBaseCTisOK = true;
                }
            }

            /* Prepare the IL generator for the function */

#ifdef  OLD_IL
            if  (!cmpConfig.ccOILgen)
#endif
            {
                cmpILgen->genFuncBeg(cmpGlobalST, fncSym, usrLclCnt);

                /* Make sure metadata has been generated for the containing class */

                if  (fncSym->sdIsMember)
                {
                    assert(owner && owner->sdSymKind == SYM_CLASS);

                    cmpGenClsMetadata(owner);
                }
            }

            /* Did the function define any labels? */

            if  (labelList)
            {
                Tree            label;

                /* Create the label scope */

                cmpLabScp = labelScope = cmpGlobalST->stDeclareLcl(NULL,
                                                                   SYM_SCOPE,
                                                                   NS_HIDE,
                                                                   NULL,
                                                                   &cmpAllocCGen);

                /* Declare all the labels and create MSIL entries for them */

                for (label = labelList;;)
                {
                    Tree            labx;
                    Ident           name;

                    assert(label->tnOper == TN_LABEL);
                    labx = label->tnOp.tnOp1;
                    assert(labx);
                    assert(labx->tnOper == TN_NAME);

                    name = labx->tnName.tnNameId;

                    /* Make sure this is not a redefinition */

                    if  (cmpGlobalST->stLookupLabSym(name, labelScope))
                    {
                        cmpError(ERRlabRedef, name);
                        label->tnOp.tnOp1 = NULL;
                    }
                    else
                    {
                        SymDef          labSym;

                        /* Declare a label symbol */

                        labSym = cmpGlobalST->stDeclareLab(name,
                                                           labelScope,
                                                           &cmpAllocCGen);

                        /* Store the symbol in the label node */

                        labx->tnOper            = TN_LCL_SYM;
                        labx->tnLclSym.tnLclSym = labSym;

                        /* Create the IL label for the symbol */

                        labSym->sdLabel.sdlILlab = cmpILgen->genFwdLabGet();
                    }

                    label = label->tnOp.tnOp2;
                    if  (label == NULL)
                        break;
                    if  (label->tnOper == TN_LIST)
                    {
                        label = label->tnOp.tnOp2;
                        if  (label == NULL)
                            break;
                    }
                }
            }

            /* Generate IL for the function */

            fnScp = cmpGenFNbodyBeg(fncSym, body, hadGoto, usrLclCnt);

            /* Did we have any errors? */

            if  (cmpErrorCount)
            {
                /* Tell the MSIL generetaor to wrap up, no code is needed */

                fnRVA = cmpILgen->genFuncEnd(0, true);
            }
#ifdef  OLD_IL
            else if (cmpConfig.ccOILgen)
            {
                fnRVA = 0;
            }
#endif
            else
            {
                /* Generate a signature for local variables  */

                fnSig = cmpGenLocalSig(fnScp, cmpILgen->genGetLclCnt());

                /* Finish up codegen and get the function's RVA */

                fnRVA = cmpILgen->genFuncEnd(fnSig, false);
            }

            /* Finish up any book-keeping in the code generator */

            cmpGenFNbodyEnd();

            /* If we've successfully generated code for the function ... */

            if  (fnRVA)
            {
                unsigned        flags = miManaged|miIL;

                if  (fncSym->sdFnc.sdfExclusive)
                    flags |= miSynchronized;

                /* Set the RVA for the function's metadata definition */

                cycleCounterPause();
                if  (cmpWmde->SetRVA(fncSym->sdFnc.sdfMDtoken, fnRVA))
                    cmpFatal(ERRmetadata);
                if  (cmpWmde->SetMethodImplFlags(fncSym->sdFnc.sdfMDtoken, flags))
                    cmpFatal(ERRmetadata);
                cycleCounterResume();

                cmpFncCntComp++;

                /* Is this the main entry point? */

                if  (isMain)
                {
                    cmpTokenMain = fncSym->sdFnc.sdfMDtoken;

                    if  (cmpConfig.ccGenDebug)
                    {
                        if (cmpSymWriter->SetUserEntryPoint(fncSym->sdFnc.sdfMDtoken))
                            cmpGenFatal(ERRdebugInfo);
                    }
                }

                /* Are we generating line# info? */

                if  (cmpConfig.ccLineNums || cmpConfig.ccGenDebug)
                {
                    size_t          lineCnt = cmpILgen->genLineNumOutput(NULL,
                                                                         NULL);

                    /* Fixup lexical scope start/end offsets for debug info */

                    if  (cmpConfig.ccGenDebug)
                        cmpFixupScopes(fnScp);

                    if  (lineCnt && srcDesc)
                    {
                        void    *       srcDoc;
                        unsigned*       lineTab;
                        unsigned*       offsTab;

                        assert(cmpSymWriter);

                        /* Make sure we have a token for the source file */

                        srcDoc = cmpSrcFileDocument(srcDesc->dlComp);

                        /* Allocate and fill in the line# table */

                        lineTab = (unsigned*)cmpAllocCGen.nraAlloc(lineCnt * sizeof(*lineTab));
                        offsTab = (unsigned*)cmpAllocCGen.nraAlloc(lineCnt * sizeof(*offsTab));

                        cmpILgen->genLineNumOutput(offsTab, lineTab);

                        /* Attach the line# table to the method */

                        if  (cmpSymWriter->DefineSequencePoints(srcDoc,
                                                                lineCnt,
                                                                offsTab,
                                                                lineTab))
                        {
                            cmpGenFatal(ERRdebugInfo);
                        }
                    }
                }
            }

            if  (cmpConfig.ccLineNums || cmpConfig.ccGenDebug)
            {
                if  (cmpSymWriter->CloseMethod())
                    cmpGenFatal(ERRdebugInfo);
            }
        }

        cmpThisSym = NULL;

        if  (!fncSym->sdIsImplicit)
        {
            /* We're done reading source text from the definition */

            cmpParser->parseDoneText(save);
        }

        /* End of the error trap's "normal" block */

        endErrorTrap(this);
    }
    chkErrorTrap(fltErrorTrap(this, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(this);

        /* Remember that something horrible has happened */

        error = true;
    }

    /* Did we have any label definitions? */

    if  (labelList)
    {
        Tree            label;

        for (label = labelList;;)
        {
            Tree            labx;

            assert(label->tnOper == TN_LABEL);
            labx = label->tnOp.tnOp1;

            if  (labx)
            {
                assert(labx->tnOper == TN_LCL_SYM);

                cmpGlobalST->stRemoveSym(labx->tnLclSym.tnLclSym);
            }

            label = label->tnOp.tnOp2;
            if  (label == NULL)
                break;
            if  (label->tnOper == TN_LIST)
            {
                label = label->tnOp.tnOp2;
                if  (label == NULL)
                    break;
            }
        }
    }

    /* Release any memory we've allocated during code generation */

    cmpAllocCGen.nraRlsm(&allocMark);

#ifdef  __SMC__
//  printf("End compile '%s'\n", cmpGlobalST->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true));
#endif

    /* Raise alarm if things are in bad shape */

    if  (error)
        jmpErrorTrap(this);

    return;
}

/*****************************************************************************
 *
 *  Bring the given symbol to "compiled" state (along with its children, if
 *  "recurse" is true). If "onlySyn" is non-NULL we only do this for that
 *  one symbol (and if we find it we return true).
 */

bool                compiler::cmpCompSym(SymDef     sym,
                                         SymDef onlySym, bool recurse)
{
    SymDef          child;

//  if  (sym->sdName) printf("Compiling '%s'\n", sym->sdSpelling());

    if  (onlySym && onlySym != sym && sym->sdHasScope())
    {
        /* Look inside this scope for the desired symbol */

        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            if  (cmpCompSym(child, onlySym, true))
                return  true;
        }

        return  false;
    }

    /* No need to compile classes imported from metadata */

    if  (sym->sdIsImport && sym->sdSymKind == SYM_CLASS)
        return  false;

    /* We need to bring this symbol to compiled state */

    if  (sym->sdCompileState < CS_COMPILED)
    {
        /* What kind of a symbol do we have? */

#ifdef  DEBUG
        if  (cmpConfig.ccVerbose >= 2)
            if  (sym != cmpGlobalNS)
                printf("Compiling '%s'\n", cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, true));
#endif

        switch (sym->sdSymKind)
        {
            DefList         defs;
            bool            defd;

        case SYM_NAMESPACE:
        case SYM_COMPUNIT:
        case SYM_TYPEDEF:
        case SYM_ENUMVAL:
        case SYM_ENUM:
            break;

        case SYM_VAR:
        case SYM_FNC:

            do
            {

                /* We only expect file-scope symbols here */

                assert(sym->sdParent == cmpGlobalNS);

                /* Look for a definition of the symbol */

                defd = false;

                for (defs = sym->sdSrcDefList; defs; defs = defs->dlNext)
                {
                    if  (defs->dlHasDef)
                    {
                        defd = true;

                        if  (sym->sdSymKind == SYM_VAR)
                            cmpCompVar(sym, defs);
                        else
                            cmpCompFnc(sym, defs);
                    }
                }

                /* Space for unmanaged global vars must be allocated if no def */

                if  (!defd && sym->sdSymKind  == SYM_VAR
                           && sym->sdIsImport == false)
                {
                    SymDef          owner = sym->sdParent;

                    if  (owner->sdSymKind != SYM_CLASS || !owner->sdIsManaged)
                        cmpAllocGlobVar(sym);
                }

                /* For functions, make sure we process all overloads */

                if  (sym->sdSymKind != SYM_FNC)
                    break;

                sym = sym->sdFnc.sdfNextOvl;
            }
            while (sym);

            return  true;

        case SYM_CLASS:
            cmpCompClass(sym);
            break;

        default:
            NO_WAY(!"unexpected symbol");
        }
    }

    /* Process the children if the caller so desires */

    if  (recurse && sym->sdSymKind == SYM_NAMESPACE)
    {
        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            cmpCompSym(child, NULL, true);
        }
    }

    return  true;
}

/*****************************************************************************
 *
 *  Binds a qualified name and returns the symbol it corresponds to, or NULL
 *  if there was an error. When 'notLast' is true, the very last name is not
 *  bound, and the caller will be the one to bind it.
 */

SymDef              compiler::cmpBindQualName(QualName qual, bool notLast)
{
    SymDef          scope;
    unsigned        namex;
    unsigned        namec = qual->qnCount - (int)notLast;

    SymTab          stab  = cmpGlobalST;

    /* Bind all names in the sequence (except maybe for the last one) */

    assert((int)namec > 0);

    for (scope = NULL, namex = 0; namex < namec; namex++)
    {
        Ident           name = qual->qnTable[namex];

        /* Is this the first name or not? */

        if  (scope)
        {
            SymDef          sym;

            switch(scope->sdSymKind)
            {
            case SYM_NAMESPACE:
                sym = stab->stLookupNspSym(name, NS_NORM, scope);
                if  (!sym)
                {
                    cmpError(ERRundefNspm, scope, name);
                    return NULL;
                }
                break;

            case SYM_CLASS:
                sym = stab->stLookupClsSym(name, scope);
                if  (!sym)
                {
                    cmpError(ERRnoSuchMem, scope, name);
                    return NULL;
                }
                break;

            default:
                cmpError(ERRnoMems, scope);
                return NULL;
            }

            scope = sym;
        }
        else
        {
            /* This is the initial name, perform a "normal" lookup */

//          scope = stab->stLookupSym(name, (name_space)(NS_TYPE|NS_NORM));
            scope = stab->stLookupSym(name, NS_TYPE);
            if  (!scope)
            {
                cmpError(ERRundefName, name);
                return NULL;
            }
        }
    }

    return  scope;
}

/*****************************************************************************
 *
 *  We're declaring a symbol with a "using" list - make sure all the "using"
 *  clauses for the symbol have been bound (and report any errors that may
 *  result from the binding).
 */

void                compiler::cmpBindUseList(UseList useList)
{
    SymDef          saveScp;
    SymDef          saveCls;
    SymDef          saveNS;

    UseList         bsect;
    UseList         esect;
    UseList         outer;
    UseList         inner;

    assert(useList);
    assert(useList->ulAnchor);

    /* If the section is already bound, we're done */

    if  (useList->ulBound)
    {
        cmpCurUses = useList;
        return;
    }

    /* Find the end of this "using" section */

    bsect = esect = useList->ulNext;
    if  (!esect)
        goto EXIT;

    /* Look for the end of the section (i.e. the next anchor) */

    while (esect->ulAnchor == false)
    {
        assert(useList->ulBound == false);

        esect = esect->ulNext;
        if  (!esect)
            goto BIND;
    }

    /* We've run into the next section - has that one been bound yet? */

    if  (!esect->ulBound)
        cmpBindUseList(esect);

BIND:

//  printf("binduselist('%s' .. '%s')\n",       useList->ul.ulSym->sdSpelling(),
//                                        esect ? esect->ul.ulSym->sdSpelling() : "<END>");

    /* Nothing to do if the section is empty */

    if  (bsect == esect)
        goto EXIT;

    /*
        The rule is that the "using" clauses for a given scope are bound
        and go into effect in parallel. We do this by setting the "using"
        list just above the section we're binding and only after all of
        the clauses have been processed do we make them take effect.

        First save the current scoping state and switch to the scope that
        the "using" clauses are found in.
     */

    saveNS     = cmpCurNS;
    saveCls    = cmpCurCls;
    saveScp    = cmpCurScp;

    cmpCurUses = esect;
    cmpCurScp  = NULL;
    cmpCurCls  = NULL;
    cmpCurNS   = esect ? esect->ul.ulSym : cmpGlobalNS;

    if  (cmpCurNS->sdSymKind == SYM_CLASS)
    {
        cmpCurCls = cmpCurNS;
        cmpCurNS  = cmpCurNS->sdParent;
    }

    for (outer = bsect; outer != esect; outer = outer->ulNext)
    {
        SymDef          sym;

        /* Bind this "using" clause */

        assert(outer->ulAnchor == false);

        if  (outer->ulBound)
        {
            /* This must be the pre-bound entry we add on the outside */

            assert(outer->ul.ulSym == cmpNmSpcSystem);
            continue;
        }

        sym = cmpBindQualName(outer->ul.ulName, false);
        if  (!sym)
            goto SAVE;

        /* Check for a duplicate */

        for (inner = bsect; inner != outer; inner = inner->ulNext)
        {
            assert(inner->ulAnchor == false);
            assert(inner->ulBound  == true);

            if  (inner->ul.ulSym == sym &&
                 inner->ulAll    == outer->ulAll)
            {
                /* This is a duplicate, just ignore it */

                goto SAVE;
            }
        }

        /* Make sure the symbol is kosher */

        if  (outer->ulAll)
        {
            /* The symbol better be a namespace */

            if  (sym->sdSymKind != SYM_NAMESPACE)
            {
                    cmpError(ERRnoNSnm, outer->ul.ulName);

                sym = NULL;
                goto SAVE;
            }

            /* Make sure any external members of the namespace are imported */

            if  (sym->sdIsImport)
            {
                // UNDONE: How do we find all the members of the namespace?
            }
        }

    SAVE:

        outer->ulBound  = true;
        outer->ul.ulSym = sym;
    }

    /* Don't forget to restore the original scoping values */

    cmpCurNS  = saveNS;
    cmpCurCls = saveCls;

EXIT:

    /* Mark the section as bound and set the current "using" state */

    cmpCurUses = useList; useList->ulBound = true;
}

/*****************************************************************************
 *
 *  Find a constructor in the given class that can be called with the given
 *  argument list.
 */

SymDef              compiler::cmpFindCtor(TypDef        clsTyp,
                                          bool          chkArgs,
                                          Tree          args)
{
    SymDef          clsSym;
    SymDef          ctfSym;
    SymDef          ovlSym;

    assert(clsTyp);

    clsSym = clsTyp->tdClass.tdcSymbol;

    /* Find the constructor member */

    ctfSym = cmpGlobalST->stLookupOper(OVOP_CTOR_INST, clsSym);
    if  (!ctfSym)
        return ctfSym;

    /* Every class has to have a constructor (even if added by the compiler) */

    assert(ctfSym);
    assert(ctfSym->sdFnc.sdfCtor);

    if  (!chkArgs)
        return ctfSym;

    /* Look for a matching constructor based on the supplied arguments */

    ovlSym = cmpFindOvlMatch(ctfSym, args, NULL);
    if  (!ovlSym)
    {
        cmpErrorXtp(ERRnoCtorMatch, ctfSym, args);
        return NULL;
    }

    return ovlSym;
}

/*****************************************************************************
 *
 *  Create a 'new' expression that will allocate an instance of the given
 *  class type and pass the specified set of arguments to its constructor.
 */

Tree                compiler::cmpCallCtor(TypDef type, Tree args)
{
    SymDef          fsym;
    Tree            call;

    assert(type->tdTypeKind == TYP_CLASS);

    /* Make sure the class is fully defined */

    cmpDeclSym(type->tdClass.tdcSymbol);

    /* Delegates must be created in a certain way */

    if  (type->tdClass.tdcFlavor == STF_DELEGATE)
    {
        Tree            func;
        Tree            inst;

        SymDef          fsym;
        TypDef          dlgt;

        /* There should be only one argument */

        if  (args == NULL || args->tnOp.tnOp2)
        {
    BAD_DLG_ARG:

            cmpError(ERRdlgCTarg);
            return cmpCreateErrNode();
        }

        assert(args->tnOper == TN_LIST);

        func = args->tnOp.tnOp1;
        if  (func->tnOper != TN_FNC_PTR)
        {
            if  (func->tnOper != TN_ADDROF)
                goto BAD_DLG_ARG;
            func = func->tnOp.tnOp1;
            if  (func->tnOper != TN_FNC_SYM)
                goto BAD_DLG_ARG;

//          func->tnFncSym.tnFncObj = cmpThisRef();
        }

        assert(func->tnFncSym.tnFncArgs == NULL);

        /* Find a member function that matches the delegate */

        fsym = func->tnFncSym.tnFncSym;
        dlgt = cmpGlobalST->stDlgSignature(type);

        do
        {
            assert(fsym && fsym->sdSymKind == SYM_FNC);

            /* Does this method match the desired signature? */

            if  (symTab::stMatchTypes(fsym->sdType, dlgt))
            {
                func->tnFncSym.tnFncSym = fsym;
                goto MAKE_DLG;
            }

            fsym = fsym->sdFnc.sdfNextOvl;
        }
        while (fsym);

        cmpErrorAtp(ERRdlgNoMFN, func->tnFncSym.tnFncSym->sdParent,
                                 func->tnFncSym.tnFncSym->sdName,
                                 dlgt);

    MAKE_DLG:

        /* We'll move the instance pointer from the method node */

        inst = func->tnFncSym.tnFncObj;
               func->tnFncSym.tnFncObj = NULL;

        if  (inst)
        {
            // bash the type to avoid context warnings

            assert(inst->tnVtyp == TYP_REF); inst->tnType = cmpObjectRef();
        }
        else
        {
            inst = cmpCreateExprNode(NULL, TN_NULL, cmpObjectRef());
        }

        /* Wrap the method address in an explicit "addrof" node */

        args->tnOp.tnOp1 = cmpCreateExprNode(NULL,
                                             TN_ADDROF,
//                                           cmpGlobalST->stNewRefType(TYP_PTR, func->tnType),
                                             cmpTypeInt,
                                             func,
                                             NULL);

        /* Add the instance to the front of the list */

        args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, inst, args);
    }

    /* Create the expression "new.ctor(args)" */

    fsym = cmpFindCtor(type, false);
    if  (!fsym)
        return  NULL;

    call = cmpCreateExprNode(NULL, TN_FNC_SYM, fsym->sdType);

    call->tnFncSym.tnFncObj  = NULL;
    call->tnFncSym.tnFncSym  = fsym;
    call->tnFncSym.tnFncArgs = args;

    /* Special case: method pointer wrappers */

    if  (type->tdClass.tdcFnPtrWrap)
    {
        /* See if there is one method pointer argument */

        if  (args && args->tnOp.tnOp2 == NULL
                  && args->tnOp.tnOp1->tnOper == TN_FNC_PTR)
        {
            printf("WARNING: wrapping method pointers into delegates NYI\n");
            goto BOUND;
        }
    }

    call = cmpCheckFuncCall(call);

    if  (call->tnOper == TN_ERROR)
        return  call;

BOUND:

    /* Is this a managed value type constructor? */

    if  (type->tdClass.tdcFlavor == STF_STRUCT && type->tdIsManaged)
    {
        call->tnVtyp = TYP_CLASS;
        call->tnType = type;
    }
    else
    {
        call->tnType = type->tdClass.tdcRefTyp;
        call->tnVtyp = call->tnType->tdTypeKindGet();
    }

    return  cmpCreateExprNode(NULL, TN_NEW, call->tnType, call, NULL);
}

/*****************************************************************************
 *
 *  Parse a type specification and make sure it refers to a class/interface.
 */

TypDef              compiler::cmpGetClassSpec(bool needIntf)
{
    declMods        mods;
    TypDef          clsTyp;

    clearDeclMods(&mods);

    clsTyp = cmpParser->parseTypeSpec(&mods, true);

    if  (clsTyp)
    {
        SymDef          clsSym;

        // UNDONE: need to make sure no modifiers were present

        if  (clsTyp->tdTypeKind != TYP_CLASS)
        {
            if  (clsTyp->tdTypeKind != TYP_REF)
            {
                cmpError(ERRnoClassName);
                return  NULL;
            }

            clsTyp = clsTyp->tdRef.tdrBase; assert(clsTyp->tdTypeKind == TYP_CLASS);
        }

        /* Get hold of the class symbol and make sure it's the right flavor */

        clsSym = clsTyp->tdClass.tdcSymbol;

        if  (clsSym->sdClass.sdcFlavor == STF_INTF)
        {
            if  (needIntf == false)
                cmpError(ERRintfBase, clsSym);
        }
        else
        {
            if  (needIntf != false)
                cmpError(ERRinclCls , clsSym);
        }
    }

    return  clsTyp;
}

/*****************************************************************************
 *
 *  Return the identifier that corresponds to the name of the given property.
 */

Ident               compiler::cmpPropertyName(Ident name, bool getter)
{
    Scanner         ourScanner = cmpScanner;

    char    *       propName;

    ourScanner->scanErrNameBeg();
    propName = ourScanner->scanErrNameStrBeg();
    ourScanner->scanErrNameStrAdd(getter ? "get_" : "set_");
    ourScanner->scanErrNameStrAdd(name->idSpelling());
    ourScanner->scanErrNameStrEnd();

    /* Find or declare the member in the secret class */

    return  cmpGlobalHT->hashString(propName);
}

/*****************************************************************************
 *
 *  Process a property declaration - the data member part has already been
 *  parsed.
 */

void                compiler::cmpDeclProperty(SymDef    memSym,
                                              declMods  memMod, DefList memDef)
{
    SymTab          ourSymTab  = cmpGlobalST;
    Parser          ourParser  = cmpParser;
    Scanner         ourScanner = cmpScanner;

    bool            isAbstract = memSym->sdIsAbstract;

    SymDef          clsSym     = memSym->sdParent;
    TypDef          memType    = memSym->sdType;
    Ident           memName    = memSym->sdName;
    ArgDscRec       mfnArgs;

    bool            accList;
    unsigned        accPass;

    assert(memSym->sdSymKind == SYM_PROP);

    /* Is the property marked as "transient" ? */

    if  (memMod.dmMod & DM_TRANSIENT)
        memSym->sdIsTransient = true;

    /* Do we have an explicit list of accessors ? */

    accList = false;
    if  (ourScanner->scanTok.tok == tkLCurly)
    {
        accList = true;
    }
    else
    {
        assert(ourScanner->scanTok.tok == tkSColon && isAbstract);
    }

    /* Is this an indexed property ? */

    if  (memType->tdTypeKind == TYP_FNC)
    {
        mfnArgs = memType->tdFnc.tdfArgs;
        memType = memType->tdFnc.tdfRett;
    }
    else
    {
#if MGDDATA
        mfnArgs = new ArgDscRec;
#else
        memset(&mfnArgs, 0, sizeof(mfnArgs));
#endif
    }


    // UNDONE: check that the member's type is acceptable

    if  (accList)
        ourScanner->scan();

    for (accPass = 0; ; accPass++)
    {
        bool            getter;
        ovlOpFlavors    fnOper;
        tokens          tokNam;
        declMods        mfnMod;

        TypDef          mfnType;
        SymDef          mfnSym;

        /* If we don't have an explicit list, just make it up */

        if  (!accList)
        {
            clearDeclMods(&mfnMod);

            if  (accPass)
                goto PSET;
            else
                goto PGET;
        }

        /* Parse any leading modifiers */

        ourParser->parseDeclMods(ACL_DEFAULT, &mfnMod);

        if  (ourScanner->scanTok.tok != tkID)
        {
        BAD_PROP:
            UNIMPL("valid property name not found, now what?");
        }

        if      (ourScanner->scanTok.id.tokIdent == cmpIdentGet)
        {
        PGET:
            getter = true;
            fnOper = OVOP_PROP_GET;
            tokNam = OPNM_PROP_GET;

            if  (memSym->sdProp.sdpGetMeth)
                cmpError(ERRdupProp, ourScanner->scanTok.id.tokIdent);
        }
        else if (ourScanner->scanTok.id.tokIdent == cmpIdentSet)
        {
        PSET:
            getter = false;
            fnOper = OVOP_PROP_SET;
            tokNam = OPNM_PROP_SET;

            if  (memSym->sdProp.sdpSetMeth)
                cmpError(ERRdupProp, ourScanner->scanTok.id.tokIdent);
        }
        else
            goto BAD_PROP;

        // UNDONE: Check the modifiers to make sure nothing wierd is in there ....

        /* Invent a function type for the property */

        if  (getter)
        {
            /* The return type is the property type */

            mfnType = ourSymTab->stNewFncType(mfnArgs, memType);
        }
        else
        {
            ArgDscRec       memArgs;

            /* Append an argument with the property type to the arg list */

            if  (mfnArgs.adArgs)
            {
                memArgs = mfnArgs;
                ourSymTab->stAddArgList(memArgs, memType, cmpGlobalHT->hashString("value"));
                mfnType = ourSymTab->stNewFncType(memArgs, cmpTypeVoid);
            }
            else
            {
#if     defined(__IL__) && !defined(_MSC_VER)
                ourParser->parseArgListNew(memArgs, 1, true, memType, A"value", NULL);
#else
                ourParser->parseArgListNew(memArgs, 1, true, memType,  "value", NULL);
#endif
                mfnType = ourSymTab->stNewFncType(memArgs, cmpTypeVoid);
            }
        }

        /* Set any modifiers that may be appropriate */

        if  (isAbstract)
            mfnMod.dmMod |= DM_ABSTRACT;

        mfnMod.dmAcc = (mfnMod.dmAcc == ACL_DEFAULT) ? memSym->sdAccessLevel
                                                     : (accessLevels)mfnMod.dmAcc;

        /* Declare a method for this property */

        mfnSym = cmpDeclFuncMem(clsSym, mfnMod, mfnType, cmpPropertyName(memName, getter));

        if  (!mfnSym)
            goto ERR_ACC;

        /* Record the fact that this is a property accessor */

        mfnSym->sdFnc.sdfProperty = true;

        /* Inherit 'static'/'sealed'/'virtual' from the property data member */

        mfnSym->sdIsStatic       = memSym->sdIsStatic;
        mfnSym->sdIsSealed       = memSym->sdIsSealed;
        mfnSym->sdFnc.sdfVirtual = memSym->sdIsVirtProp;

        /* Record whether the accessor is supposed to overload the base */

        if  (memMod.dmMod & DM_OVERLOAD)
            mfnSym->sdFnc.sdfOverload = true;

        /* Record the method in the data property symbol */

        if  (getter)
            memSym->sdProp.sdpGetMeth = mfnSym;
        else
            memSym->sdProp.sdpSetMeth = mfnSym;

    ERR_ACC:

        /* Is there a function body ? */

        if  (accList && ourScanner->scan() == tkLCurly)
        {
            scanPosTP       defFpos;
            unsigned        defLine;

            if  (isAbstract)
                cmpError(ERRabsPFbody, memSym);

            /* Figure out where the body starts */

            defFpos = ourScanner->scanGetTokenPos(&defLine);

            /* Swallow the method body */

            ourScanner->scanSkipText(tkLCurly, tkRCurly);

            if  (ourScanner->scanTok.tok == tkRCurly)
                ourScanner->scan();

            if  (!isAbstract && mfnSym)
            {
                ExtList         mfnDef;

                /* Record the location of the body for later */

                mfnDef = ourSymTab->stRecordMemSrcDef(memName,
                                                      NULL,
                                                      memDef->dlComp,
                                                      memDef->dlUses,
                                                      defFpos,
                                                      defLine);
                mfnSym->sdIsDefined = true;
                mfnDef->dlHasDef    = true;
                mfnDef->mlSym       = mfnSym;

                /* Add the property method to the member list of the class */

                cmpRecordMemDef(clsSym, mfnDef);
            }
        }
        else
        {
            /* No body given for this property accessor */


            if  (ourScanner->scanTok.tok != tkSColon)
            {
                cmpError(ERRnoSemic);
                UNIMPL("resync");
            }

            // UNDONE: Remember that there is a property get/set

            if  (!accList)
            {
                if  (accPass)
                    break;
                else
                    continue;
            }

            ourScanner->scan();
        }

        if  (ourScanner->scanTok.tok == tkSColon)
            ourScanner->scan();

        if  (ourScanner->scanTok.tok == tkRCurly)
            break;
    }
}

/*****************************************************************************
 *
 *  Recursively look for a get/set property corresponding to the given data
 *  member within the class and its bases/interfaces. If a property with a
 *  matching name is found, we set *found to true (this way the caller can
 *  detect the case where a property with a matching name exists but the
 *  arguments don't match any of its accessors).
 */

SymDef              compiler::cmpFindPropertyFN(SymDef  clsSym,
                                                Ident   propName,
                                                Tree    args,
                                                bool    getter,
                                                bool  * found)
{
    SymDef          memSym;
    TypDef          clsTyp;

    /* Check the current class for a matching property */

    memSym = cmpGlobalST->stLookupClsSym(propName, clsSym);
    if  (memSym)
    {
        if  (memSym->sdSymKind != SYM_PROP)
        {
            /* A matching non-property member exists in the class, bail */

            return  NULL;
        }

        do
        {
            SymDef          propSym;

            propSym = getter ? memSym->sdProp.sdpGetMeth
                             : memSym->sdProp.sdpSetMeth;

            if  (propSym)
            {
                /*
                    Tricky situation: as indexed properties can be overloaded,
                    the method symbol pointed to from the property symbol may
                    not be the beginning of the overload list.
                 */

                propSym = cmpGlobalST->stLookupClsSym(propSym->sdName, clsSym);

                assert(propSym);

                if  (propSym->sdFnc.sdfNextOvl || propSym->sdFnc.sdfBaseOvl)
                {
                    *found = true;
                    propSym = cmpFindOvlMatch(propSym, args, NULL);     // should not use NULL
                }

                return  propSym;
            }

            memSym = memSym->sdProp.sdpNextOvl;
        }
        while (memSym);
    }

    clsTyp = clsSym->sdType;

    /* Is there a base class? */

    if  (clsTyp->tdClass.tdcBase)
    {
        /* Look in the base and bail if that triggers an error */

        memSym = cmpFindPropertyFN(clsTyp->tdClass.tdcBase->tdClass.tdcSymbol, propName, args, getter, found);
        if  (memSym)
            return  memSym;
    }

    /* Does the class include any interfaces? */

    if  (clsTyp->tdClass.tdcIntf)
    {
        TypList         ifl = clsTyp->tdClass.tdcIntf;

        memSym = NULL;

        do
        {
            SymDef          tmpSym;
            SymDef          tmpScp;

            /* Look in the interface and bail if that triggers an error */

            tmpScp = ifl->tlType->tdClass.tdcSymbol;
            tmpSym = cmpFindPropertyFN(tmpScp, propName, args, getter, found);
            if  (tmpSym == cmpGlobalST->stErrSymbol || found)
                return  tmpSym;

            if  (tmpSym)
            {
                /* We have a match, do we already have a different match? */

                if  (memSym && memSym != tmpSym)
                {
                    cmpError(ERRambigMem, propName, clsSym, tmpScp);
                    return  cmpGlobalST->stErrSymbol;
                }

                /* This is the first match, record it and continue */

                memSym = tmpSym;
                clsSym = tmpScp;
            }

            ifl = ifl->tlNext;
        }
        while (ifl);
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Add an entry to the given "symbol extra info" list.
 */

SymXinfo            compiler::cmpAddXtraInfo(SymXinfo  infoList, Linkage linkSpec)
{
#if MGDDATA
    SymXinfoLnk     entry = new SymXinfoLnk;
#else
    SymXinfoLnk     entry =    (SymXinfoLnk)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif

    entry->xiKind = XI_LINKAGE;
    entry->xiNext = infoList;

    copyLinkDesc(entry->xiLink, linkSpec);

    return  entry;
}

SymXinfo            compiler::cmpAddXtraInfo(SymXinfo infoList, AtComment atcDesc)
{
#if MGDDATA
    SymXinfoAtc     entry = new SymXinfoAtc;
#else
    SymXinfoAtc     entry =    (SymXinfoAtc)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif

    entry->xiKind    = XI_ATCOMMENT;
    entry->xiNext    = infoList;
    entry->xiAtcInfo = atcDesc;

    return  entry;
}

SymXinfo            compiler::cmpAddXtraInfo(SymXinfo infoList, MarshalInfo marshal)
{
#if MGDDATA
    SymXinfoCOM     entry = new SymXinfoCOM;
#else
    SymXinfoCOM     entry =    (SymXinfoCOM)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif

    entry->xiKind    = XI_MARSHAL;
    entry->xiCOMinfo = marshal;
    entry->xiNext    = infoList;

    return  entry;
}

SymXinfo            compiler::cmpAddXtraInfo(SymXinfo infoList, SymDef     sym,
                                                                xinfoKinds kind)
{
#if MGDDATA
    SymXinfoSym     entry = new SymXinfoSym;
#else
    SymXinfoSym     entry =    (SymXinfoSym)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif

    entry->xiKind    = kind;
    entry->xiSymInfo = sym;
    entry->xiNext    = infoList;

    return  entry;
}

SymXinfo            compiler::cmpAddXtraInfo(SymXinfo   infoList, SecurityInfo info)
{
#if MGDDATA
    SymXinfoSec     entry = new SymXinfoSec;
#else
    SymXinfoSec     entry =    (SymXinfoSec)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif

    entry->xiKind    = XI_SECURITY;
    entry->xiSecInfo = info;
    entry->xiNext    = infoList;

    return  entry;
}

SymXinfo            compiler::cmpAddXtraInfo(SymXinfo        infoList,
                                             SymDef          attrCtor,
                                             unsigned        attrMask,
                                             size_t          attrSize,
                                             genericBuff     attrAddr)
{
    SymXinfoAttr    entry;

    /* Are duplicates of this attribute allowed ? */

    if  (attrCtor->sdParent->sdClass.sdcAttrDupOK == false &&
         attrCtor->sdParent->sdClass.sdcAttribute != false)
    {
        SymXinfo        chkList;

        /* Linear search -- pretty lame, isn't it? */

        for (chkList = infoList; chkList; chkList = chkList->xiNext)
        {
            if  (chkList->xiKind == XI_ATTRIBUTE)
            {
                SymXinfoAttr    entry = (SymXinfoAttr)chkList;

                if  (entry->xiAttrCtor->sdParent == attrCtor->sdParent)
                    cmpError(ERRcustAttrDup, attrCtor->sdParent);

                break;
            }
        }
    }

#if MGDDATA
    entry = new SymXinfoAttr;
#else
    entry =    (SymXinfoAttr)cmpAllocPerm.nraAlloc(sizeof(*entry));
#endif

    entry->xiKind     = XI_ATTRIBUTE;
    entry->xiAttrCtor = attrCtor;
    entry->xiAttrMask = attrMask;
    entry->xiAttrSize = attrSize;
    entry->xiAttrAddr = attrAddr;
    entry->xiNext     = infoList;

    return  entry;
}

/*****************************************************************************
 *
 *  Look for a specific entry in the given "extra info" list.
 */

SymXinfo            compiler::cmpFindXtraInfo(SymXinfo      infoList,
                                              xinfoKinds    infoKind)
{
    while   (infoList)
    {
        if  (infoList->xiKind == infoKind)
            break;

        infoList = infoList->xiNext;
    }

    return  infoList;
}

/*****************************************************************************
 *
 *  Recursively fixes up the start/end offsets of debug info lexical scopes
 *  defined within the given scope.
 *
 *  Also emits parameters as we're walking down the tree.
 */

void                compiler::cmpFixupScopes(SymDef scope)
{
    SymDef          child;

    assert(scope->sdSymKind == SYM_SCOPE);

    if  (scope->sdScope.sdSWscopeId)
    {
        int             startOffset;
        int             endOffset;

        startOffset = cmpILgen->genCodeAddr(scope->sdScope.sdBegBlkAddr,
                                            scope->sdScope.sdBegBlkOffs);
          endOffset = cmpILgen->genCodeAddr(scope->sdScope.sdEndBlkAddr,
                                            scope->sdScope.sdEndBlkOffs);

        if (cmpSymWriter->SetScopeRange(scope->sdScope.sdSWscopeId,
                                        startOffset,
                                        endOffset))
        {
            cmpGenFatal(ERRdebugInfo);
        }
    }

    for (child = scope->sdScope.sdScope.sdsChildList;
         child;
         child = child->sdNextInScope)
    {
        if  (child->sdSymKind == SYM_SCOPE)
            cmpFixupScopes(child);
    }
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************/

SymDef              compiler::cmpDclFilterCls(unsigned args)
{
    HashTab         hash = cmpGlobalHT;

        char                    name[16];

    SymDef          clsSym;
    TypDef          clsType;

    declMods        mods;
    unsigned        nnum;

    ArgDef          lastArg;
    ArgDscRec       ctrArgs;
    TypDef          ctrType;
    SymDef          ctrSym;

    /* Declare the class itself */

    sprintf(name, "%s%02u", CFC_CLSNAME_PREFIX, args);

    clsSym = cmpGlobalST->stDeclareSym(cmpGlobalHT->hashString(name),
                                       SYM_CLASS,
                                       NS_HIDE,
                                       cmpGlobalNS);

//  printf("Declare filter state class '%s'\n", clsSym->sdSpelling());

    clsSym->sdClass.sdcCollState = true;
    clsSym->sdClass.sdcFlavor    = STF_CLASS;
    clsSym->sdCompileState       = CS_DECLARED;
    clsSym->sdIsManaged          = true;
    clsSym->sdIsImplicit         = true;

    /* Create the class type and set the base class */

    clsType = clsSym->sdTypeGet();
    clsType->tdClass.tdcBase = cmpClassObject->sdType;

    /* Declare the constructor for the state class */

    mods.dmAcc = ACL_PUBLIC;
    mods.dmMod = 0;

    assert(args <= COLL_STATE_VALS);

    // The following must match the code in cmpGenCollExpr()

    memset(&ctrArgs, 0, sizeof(ctrArgs));

    cmpGlobalST->stExtArgsBeg(ctrArgs, lastArg, ctrArgs);

    nnum = 0;
    do
    {
        char            buff[6];

        sprintf(buff, "$A%u", nnum++); cmpGlobalST->stExtArgsAdd(ctrArgs, lastArg, cmpTypeInt    , buff);
        sprintf(buff, "$A%u", nnum++); cmpGlobalST->stExtArgsAdd(ctrArgs, lastArg, cmpRefTpObject, buff);
    }
    while (nnum < args);

    cmpGlobalST->stExtArgsEnd(ctrArgs);

    ctrType = cmpGlobalST->stNewFncType(ctrArgs, cmpTypeVoid);

    ctrSym = cmpDeclFuncMem(clsSym, mods, ctrType, clsSym->sdName);
    ctrSym->sdIsDefined       = true;
    ctrSym->sdIsImplicit      = true;
    ctrSym->sdFnc.sdfCtor     = true;

    /* Declare the member(s) that will hold the state */

    nnum = 0;

    do
    {
        char            name[16];

        sprintf(name, "$V%u", nnum++);
        cmpDeclDataMem(clsSym, mods, cmpTypeInt    , hash->hashString(name));

        sprintf(name, "$V%u", nnum++);
        cmpDeclDataMem(clsSym, mods, cmpRefTpObject, hash->hashString(name));
    }
    while (nnum < args);

    return  clsSym;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  Store a length field in a custom attribute blob; return the size stored.
 */

size_t              compiler::cmpStoreMDlen(size_t len, BYTE *dest)
{
    if  (len <= 0x7F)
    {
        if  (dest)
            *dest = len;

        return 1;
    }

    if  (len <= 0x3FFF)
    {
        if  (dest)
        {
            dest[0] = (len >> 8) | 0x80;
            dest[1] =  len & 0xFF;
        }

        return 2;
    }

    assert(len <= 0x1FFFFFFF);

    if  (dest)
    {
        dest[0] = (len >> 24) | 0xC0;
        dest[1] = (len >> 16) & 0xFF;
        dest[2] = (len >> 8)  & 0xFF;
        dest[3] =  len & 0xFF;
    }

    return  4;
}

/*****************************************************************************
 *
 *  Bind a custom attribute thingie, i.e. create the serialized blob value and
 *  return the constructor that is to be called. The caller supplies the class
 *  for the attribute and the argument list specified by the gizmo.
 */

SymDef              compiler::cmpBindAttribute(SymDef           clsSym,
                                               Tree             argList,
                                               unsigned         tgtMask,
                                           OUT unsigned     REF useMask,
                                           OUT genericBuff  REF blobAddr,
                                           OUT size_t       REF blobSize)
{
    SymDef          ctrSym;
    Tree            callExpr;

    genericBuff     blob;

    size_t          size;
    Tree            argl;
    unsigned        argn;

    unsigned        arg1 = 0;

    assert(clsSym && clsSym->sdSymKind == SYM_CLASS);

    if  (argList)
        argList = cmpBindExpr(argList);

    callExpr = cmpCallCtor(clsSym->sdType, argList);
    if  (!callExpr)
    {
        cmpErrorXtp(ERRnoCtorMatch, clsSym, argList);
        return  NULL;
    }

    if  (callExpr->tnVtyp == TYP_UNDEF)
        return  NULL;

    /* Get hold of the constructor symbol and the bound argument list */

    assert(callExpr->tnOper == TN_NEW);

    assert(callExpr->tnOp.tnOp1 != NULL);
    assert(callExpr->tnOp.tnOp2 == NULL);

    callExpr = callExpr->tnOp.tnOp1;

    assert(callExpr->tnOper == TN_FNC_SYM);
    assert(callExpr->tnFncSym.tnFncObj == NULL);

    ctrSym  = callExpr->tnFncSym.tnFncSym;
    argList = callExpr->tnFncSym.tnFncArgs;

    /* Make sure all the arguments are constants, compute the blob size */

    size = 2 * sizeof(short);   // version# prefix, 0 count suffix
    argl = argList;
    argn = 0;

    while (++argn, argl)
    {
        Tree            argx;

        assert(argl->tnOper == TN_LIST);

        /* Get hold of the next argument and see what type it is */

        argx = argl->tnOp.tnOp1;

        switch (argx->tnOper)
        {
        case TN_CNS_INT:
        case TN_CNS_LNG:
        case TN_CNS_FLT:
        case TN_CNS_DBL:
            size += cmpGetTypeSize(argx->tnType);

            if  (argn == 1)
                arg1 = argx->tnIntCon.tnIconVal;

            break;

        case TN_NULL:
            size += sizeof(void *);
            break;

        case TN_CNS_STR:
            if  (argx->tnStrCon.tnSconLen)
                size += argx->tnStrCon.tnSconLen + cmpStoreMDlen(argx->tnStrCon.tnSconLen);
            else
                size += 1;
            break;

        default:
            cmpGenError(ERRnonCnsAA, argn);
            break;
        }

        /* Continue walking the argument list */

        argl  = argl->tnOp.tnOp2;
    }

    /* Find the "System::Attribute" class */

    if  (!cmpAttrClsSym)
    {
        Ident           tname;
        SymDef          tsym;

        tname = cmpGlobalHT->hashString("Attribute");
        tsym  = cmpGlobalST->stLookupNspSym(tname, NS_NORM, cmpNmSpcSystem);

        if  (!tsym || tsym->sdSymKind         != SYM_CLASS
                   || tsym->sdClass.sdcFlavor != STF_CLASS)
        {
            cmpGenFatal(ERRbltinTp, "System::Attribute");
        }

        cmpAttrClsSym = tsym;
    }

    if  (!cmpAuseClsSym)
    {
        Ident           tname;
        SymDef          tsym;

        tname = cmpGlobalHT->hashString("AttributeUsageAttribute");
        tsym  = cmpGlobalST->stLookupNspSym(tname, NS_NORM, cmpNmSpcSystem);

        if  (!tsym || tsym->sdSymKind         != SYM_CLASS
                   || tsym->sdClass.sdcFlavor != STF_CLASS)
        {
            cmpGenFatal(ERRbltinTp, "System::AttributeUsageAttribute");
        }
        else
            cmpAuseClsSym = tsym;
    }

    /* Make sure the attribute isn't misused */

    if  (!clsSym->sdClass.sdcAttribute)
    {
        TypDef          clsBase = clsSym->sdType->tdClass.tdcBase;

        /* The new thing: inheriting from System::Attribute */

        if  (clsBase && clsBase->tdClass.tdcSymbol == cmpAttrClsSym)
        {
            clsSym->sdClass.sdcAttribute = true;
        }
        else
        {
//          printf("WARNING: attached '%s' which isn't marked as a custom attribute!\n", cmpGlobalST->stTypeName(NULL, clsSym, NULL, NULL, true));
        }
    }

    if  (clsSym->sdClass.sdcAttribute)
    {
        SymXinfo        infoList;

        assert(tgtMask);

        /* Find the use mask of the attribute and check it */

        for (infoList = clsSym->sdClass.sdcExtraInfo;
             infoList;
             infoList = infoList->xiNext)
        {
            if  (infoList->xiKind == XI_ATTRIBUTE)
            {
                SymXinfoAttr    entry = (SymXinfoAttr)infoList;

                if  (!(tgtMask & entry->xiAttrMask))
                    cmpError(ERRcustAttrPlc);

                break;
            }
        }
    }

    /* Is this a "System::Attribute" attribute ? */

    useMask = 0;

    if  (clsSym == cmpAttrClsSym ||
         clsSym == cmpAuseClsSym)
    {
        if  (arg1 == 0)
            cmpError(ERRcustAttrMsk);

        useMask = arg1;
    }

    /* Allocate space for the blob */

#if MGDDATA
    blob = new managed char [size];
#else
    blob = (genericBuff)cmpAllocPerm.nraAlloc(roundUp(size));
#endif

    /* Tell the caller about the blob */

    blobAddr = blob;
    blobSize = size;

    /* Store the signature to get the blob started */

    unsigned short      ver = 1;

    memcpy(blob, &ver, sizeof(ver));
           blob   +=   sizeof(ver);

    /* Record the argument values */

    argl = argList;

    while (argl)
    {
        __int32         ival;
        __int64         lval;
        float           fval;
        double          dval;

        Tree            argx;

        void    *       valp;
        size_t          vals;

        assert(argl->tnOper == TN_LIST);

        /* Get hold of the next argument and see what type it is */

        argx = argl->tnOp.tnOp1;

        switch (argx->tnOper)
        {
        case TN_CNS_INT: ival = argx->tnIntCon.tnIconVal; valp = (BYTE*)&ival; goto INTRINS;
        case TN_CNS_LNG: lval = argx->tnLngCon.tnLconVal; valp = (BYTE*)&lval; goto INTRINS;
        case TN_CNS_FLT: fval = argx->tnFltCon.tnFconVal; valp = (BYTE*)&fval; goto INTRINS;
        case TN_CNS_DBL: dval = argx->tnDblCon.tnDconVal; valp = (BYTE*)&dval; goto INTRINS;
        case TN_NULL:    ival =                        0; valp = (BYTE*)&ival; goto INTRINS;

        INTRINS:
            vals  = cmpGetTypeSize(argx->tnType);
            break;

        case TN_CNS_STR:
            valp  = argx->tnStrCon.tnSconVal;
            vals  = argx->tnStrCon.tnSconLen;

            if  (vals)
            {
                blob += cmpStoreMDlen(vals, blob);
            }
            else
            {
                valp = &ival; ival = 0xFF;
                vals = 1;
            }
            break;

        default:
            break;
        }

        memcpy(blob, valp, vals);
               blob   +=   vals;

        /* Continue walking the argument list */

        argl = argl->tnOp.tnOp2;
    }

    /* Store the signature to get the blob started */

    static
    short       cnt = 0;

    memcpy(blob, &cnt, sizeof(cnt));
           blob   +=   sizeof(cnt);

    /* Make sure the predicted size turns out to be accurate */

    assert(blob == blobAddr + blobSize);

    return  ctrSym;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\comp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _COMP_H_
#define _COMP_H_
/*****************************************************************************/

const   unsigned    MAX_IDENT_LEN   = 1023;     // max # of chars in identifier

/*****************************************************************************/

#ifdef  __IL__
#undef  ASYNCH_INPUT_READ
#else
#define ASYNCH_INPUT_READ       1
#endif

/*****************************************************************************/

#ifndef _CONFIG_H_
#include "config.h"
#endif

#ifndef _ALLOC_H_
#include "alloc.h"
#endif

#ifndef _INFILE_H_
#include "infile.h"
#endif

#ifndef _PEWRITE_H_
#include "PEwrite.h"
#endif

#ifndef _CORWRAP_H
#include "CORwrap.h"
#endif

#ifndef _MDSTRNS_H_
#include "MDstrns.h"
#endif

#ifndef _ATTRS_H_
#include "attrs.h"
#endif

/*****************************************************************************/

#ifndef CALG_SHA1
const   unsigned    CALG_SHA1 = 0x00008004;
#endif

/*****************************************************************************/

bool                parseGUID(const char *str, GUID *guidPtr, bool curlied);
tokens              treeOp2token(treeOps oper);
bool                processOption(const char *optStr, Compiler comp);

/*****************************************************************************
 *
 *  This is here because we can't include "symbol.h" just yet due to other
 *  dependencies.
 */

enum symbolKinds
{
    SYM_ERR,
    SYM_VAR,
    SYM_FNC,
    SYM_PROP,
    SYM_LABEL,
    SYM_USING,
    SYM_GENARG,
    SYM_ENUMVAL,
    SYM_TYPEDEF,
    SYM_COMPUNIT,

    /*
        The symbol kinds that follow are the only ones that define
        scopes (i.e. they may own other symbols). This is relied
        upon in the function symDef::sdHasScope().
     */

    SYM_ENUM,
    SYM_SCOPE,
    SYM_CLASS,
    SYM_NAMESPACE,

    SYM_FIRST_SCOPED = SYM_ENUM,
};

enum str_flavors
{
    STF_NONE,                   // 0: undetermined

    STF_CLASS,                  // 1: it's a  class
    STF_UNION,                  // 2: it's a  union
    STF_STRUCT,                 // 3: it's a  struct
    STF_INTF,                   // 4: it's an interface
    STF_DELEGATE,               // 5: it's a  delegate
    STF_GENARG,                 // 6: it's a  generic class formal argument

    STF_COUNT
};

/*****************************************************************************
 *
 *  The following refers to the "namespace" in which names are looked up,
 *  this has nothing to do with the "namespace" scoping concept.
 */

enum name_space
{
    NS_NONE     = 0x0000,

    NS_NORM     = 0x0001,       // variables, members, classes, etc.
    NS_TYPE     = 0x0002,       // types
    NS_LABEL    = 0x0004,       // labels
    NS_CONT     = 0x0008,       // contains other names (used with NS_NORM/NS_TYPE)
    NS_HIDE     = 0x0010,       // not visible at all
};

/*****************************************************************************/

enum callingConvs
{
    CCNV_NONE,
    CCNV_CDECL,
    CCNV_STDCALL,
    CCNV_WINAPI,
};

/*****************************************************************************/

enum compileStates
{
    CS_NONE,
    CS_KNOWN,
    CS_PARSED,
    CS_DECLSOON,                // symbol is on its way to 'declared'
    CS_DECLARED,
    CS_CNSEVALD,                // constant evaluated if present
    CS_COMPILED,
};

enum accessLevels
{
    ACL_ERROR,

    ACL_PUBLIC,
    ACL_PROTECTED,
    ACL_DEFAULT,
    ACL_PRIVATE,
};

/*****************************************************************************
 *
 *  The following holds information about a security attribute.
 */

DEFMGMT
class   PairListRec
{
public:
    PairList            plNext;
    Ident               plName;
//  ConstStr            plValue;
    bool                plValue;        // for only true/false is allowed
};

DEFMGMT
class   SecurityDesc
{
public:
    CorDeclSecurity     sdSpec;
    bool                sdIsPerm;       // capability (false) or permission (true) ?

    UNION(sdIsPerm)
    {
    CASE(false)
        ConstStr            sdCapbStr;

    CASE(true)
        struct
        {
            SymDef              sdPermCls;
            PairList            sdPermVal;
        }
                            sdPerm;
    };
};

/*****************************************************************************
 *
 *  The following better match the values in System::AtributeTargets !
 */

enum    attrTgts
{
    ATGT_Assemblies    = 0x0001,
    ATGT_Modules       = 0x0002,
    ATGT_Classes       = 0x0004,
    ATGT_Structs       = 0x0008,
    ATGT_Enums         = 0x0010,
    ATGT_Constructors  = 0x0020,
    ATGT_Methods       = 0x0040,
    ATGT_Properties    = 0x0080,
    ATGT_Fields        = 0x0100,
    ATGT_Events        = 0x0200,
    ATGT_Interfaces    = 0x0400,
    ATGT_Parameters    = 0x0800,
};

/*****************************************************************************
 *
 *  A simple array-like table that pointers can be thrown into and a simple
 *  index is returned that can later be used to retrieve the pointer value.
 */

DEFMGMT
class   VecEntryDsc
{
public:
    const   void    *   vecValue;
#ifdef  DEBUG
    vecEntryKinds       vecKind;
#endif
};

/*****************************************************************************
 *
 *  This holds a qualified name of the form "foo.bar. .... baz". It's a simple
 *  array of identifiers and a flag as to whether the final entry was ".*".
 */

DEFMGMT
class QualNameRec
{
public:

    unsigned        qnCount     :31;    // number of identifiers
    unsigned        qnEndAll    :1;     // ends in ".*" ?

#if MGDDATA
    Ident        [] qnTable;            // the array allocated separately
#else
    Ident           qnTable[];          // the array follows in memory
#endif

};

/*****************************************************************************
 *
 *  The following describes a "/** @" style directive.
 */

enum    atCommFlavors
{
    AC_NONE,

    AC_COM_INTF,
    AC_COM_CLASS,
    AC_COM_METHOD,
    AC_COM_PARAMS,
    AC_COM_REGISTER,

    AC_DLL_IMPORT,
    AC_DLL_STRUCT,
    AC_DLL_STRUCTMAP,

    AC_CONDITIONAL,

    AC_DEPRECATED,

    AC_COUNT
};

struct  marshalDsc;
typedef marshalDsc *    MarshalInfo;
struct  marshalDsc
{
    unsigned char       marshType;          // the real type is 'CorNativeType'
    unsigned char       marshSubTp;         // element type for arrays
    unsigned char       marshModeIn;        // used only for args
    unsigned char       marshModeOut;       // used only for args
    unsigned            marshSize;          // used for fixed array types
};

struct  marshalExt : marshalDsc
{
    const   char *      marshCustG;
    const   char *      marshCustC;
    SymDef              marshCustT;
};

struct  methArgDsc;
typedef methArgDsc *    MethArgInfo;
struct  methArgDsc
{
    MethArgInfo         methArgNext;
    marshalDsc          methArgDesc;
    Ident               methArgName;
};

struct  atCommDsc;
typedef atCommDsc *     AtComment;
struct  atCommDsc
{
    AtComment           atcNext;
    atCommFlavors       atcFlavor;

    UNION(atcFlavor)
    {
    CASE(AC_DLL_IMPORT)
        Linkage             atcImpLink;

//  CASE(AC_COM_METHOD)

    CASE(AC_CONDITIONAL)
        bool                atcCondYes;

    CASE(AC_COM_INTF)
    CASE(AC_COM_REGISTER)
        struct
        {
            ConstStr            atcGUID;
            bool                atcDual;
        }
                            atcReg;

    CASE(AC_COM_METHOD)
        struct
        {
            signed int          atcVToffs;  // -1 means "none specified"
            signed int          atcDispid;  // -1 means "none specified"
        }
                            atcMethod;

    CASE(AC_COM_PARAMS)
        MethArgInfo         atcParams;

    CASE(AC_DLL_STRUCT)
        struct
        {
            unsigned    char    atcPack;
            unsigned    char    atcStrings; // matches Interop::CharacterSet
        }
                            atcStruct;

    CASE(AC_DLL_STRUCTMAP)
        MarshalInfo         atcMarshal;
    }
                        atcInfo;
};

/*****************************************************************************
 *
 *  The following holds information about a linkage specifier.
 */

DEFMGMT
class LinkDesc
{
public:

    const   char *  ldDLLname;          // DLL name
    const   char *  ldSYMname;          // entry point name

    unsigned        ldStrings   :4;     // 0=none,1=auto,2=ANSI,3=Unicode,4=Ole
    unsigned        ldLastErr   :1;     // lasterror set by fn?
    unsigned        ldCallCnv   :3;     // CC_xxx (see above)
};

#if MGDDATA

inline
void                copyLinkDesc(Linkage dst, Linkage src)
{
    dst->ldDLLname = src->ldDLLname;
    dst->ldSYMname = src->ldSYMname;
    dst->ldStrings = src->ldStrings;
    dst->ldLastErr = src->ldLastErr;
}

#else

inline
void                copyLinkDesc(LinkDesc & dst, Linkage src)
{
    memcpy(&dst, src, sizeof(dst));
}

#endif

/*****************************************************************************
 *
 *  The following holds any "extra" (rare) information about a symbol.
 */

enum    xinfoKinds
{
    XI_NONE,
    XI_LINKAGE,
    XI_MARSHAL,
    XI_SECURITY,
    XI_ATCOMMENT,
    XI_ATTRIBUTE,

    XI_UNION_TAG,
    XI_UNION_MEM,

    XI_COUNT
};

DEFMGMT
class   XinfoDsc
{
public:
    SymXinfo        xiNext;
    xinfoKinds      xiKind;
};

DEFMGMT
class   XinfoLnk  : public XinfoDsc         // linkage descriptor
{
public:
    LinkDesc        xiLink;
};

DEFMGMT
class   XinfoSec  : public XinfoDsc         // security specification
{
public:
    SecurityInfo    xiSecInfo;
};

DEFMGMT
class   XinfoAtc  : public XinfoDsc         // @comment
{
public:
    AtComment       xiAtcInfo;
};

DEFMGMT
class   XinfoCOM  : public XinfoDsc         // COM marshalling info
{
public:
    MarshalInfo     xiCOMinfo;
};

DEFMGMT
class   XinfoAttr : public XinfoDsc         // custom attribute
{
public:
    SymDef          xiAttrCtor;
    unsigned        xiAttrMask;
    size_t          xiAttrSize;
    genericBuff     xiAttrAddr;
};

DEFMGMT
class   XinfoSym  : public XinfoDsc         // tagged/anonymous union info
{
public:
    SymDef          xiSymInfo;
};

/*****************************************************************************/

struct  strCnsDsc;
typedef strCnsDsc *     strCnsPtr;
struct  strCnsDsc
{
    strCnsPtr       sclNext;
    mdToken         sclTok;
    size_t          sclAddr;
};

/*****************************************************************************/

enum    dclModBits
{
    DB_NONE,

    DB_STATIC,
    DB_EXTERN,
    DB_VIRTUAL,
    DB_ABSTRACT,
    DB_OVERRIDE,
    DB_INLINE,
    DB_EXCLUDE,
    DB_SEALED,
    DB_OVERLOAD,
    DB_NATIVE,

    DB_CONST,
    DB_VOLATILE,

    DB_MANAGED,
    DB_UNMANAGED,
    DB_UNSAFE,

    DB_PROPERTY,

    DB_TRANSIENT,
    DB_SERLZABLE,

    DB_DEFAULT,
    DB_MULTICAST,

    DB_ALL,
    DB_RESET = DB_ALL-1,

    DB_TYPEDEF,
    DB_XMODS,

    DB_CLEARED
};

enum    dclMods
{
    DM_STATIC    = (1 <<  DB_STATIC   ),
    DM_EXTERN    = (1 <<  DB_EXTERN   ),
    DM_VIRTUAL   = (1 <<  DB_VIRTUAL  ),
    DM_ABSTRACT  = (1 <<  DB_ABSTRACT ),
    DM_OVERRIDE  = (1 <<  DB_OVERRIDE ),
    DM_INLINE    = (1 <<  DB_INLINE   ),
    DM_EXCLUDE   = (1 <<  DB_EXCLUDE  ),
    DM_SEALED    = (1 <<  DB_SEALED   ),
    DM_OVERLOAD  = (1 <<  DB_OVERLOAD ),
    DM_NATIVE    = (1 <<  DB_NATIVE   ),

    DM_CONST     = (1 <<  DB_CONST    ),
    DM_VOLATILE  = (1 <<  DB_VOLATILE ),

    DM_MANAGED   = (1 <<  DB_MANAGED  ),
    DM_UNMANAGED = (1 <<  DB_UNMANAGED),
    DM_UNSAFE    = (1 <<  DB_UNSAFE   ),

    DM_PROPERTY  = (1 <<  DB_PROPERTY ),

    DM_TRANSIENT = (1 <<  DB_TRANSIENT),
    DM_SERLZABLE = (1 <<  DB_SERLZABLE),

    DM_DEFAULT   = (1 <<  DB_DEFAULT  ),
    DM_MULTICAST = (1 <<  DB_MULTICAST),

    DM_TYPEDEF   = (1 <<  DB_TYPEDEF  ),        // used only for file-scope typedefs
    DM_XMODS     = (1 <<  DB_XMODS    ),        // security modifier / other stuff present

    DM_CLEARED   = (1 <<  DB_CLEARED  ),        // modifiers have not been parsed

    DM_ALL       =((1 <<  DB_ALL) - 1 )         // used for masking
};

struct  declMods
{
    unsigned        dmMod   :24;        // mask of DM_xxx above
    unsigned char   dmAcc   : 8;        // type is accessLevels
};

inline
DeclMod             clearDeclMods(DeclMod mods)
{
    mods->dmMod = 0;
    mods->dmAcc = ACL_DEFAULT;

    return  mods;
}

inline
DeclMod              initDeclMods(DeclMod mods, accessLevels acc)
{
    mods->dmMod = 0;
    mods->dmAcc = acc;

    return  mods;
}

enum dclrtrName
{
    DN_NONE     = 0,
    DN_OPTIONAL = 1,
    DN_REQUIRED = 2,
    DN_MASK     = 3,

    DN_QUALOK = 0x80                    // combine with others to allow "foo.bar"
};

/*****************************************************************************/

DEFMGMT
class StrListRec
{
public:

    StrList             slNext;
    stringBuff          slString;
};

/*****************************************************************************/

DEFMGMT
class BlkListRec
{
public:

    BlkList             blNext;
    genericRef          blAddr;
};

/*****************************************************************************/

DEFMGMT
class   NumPairDsc
{
public:
    unsigned            npNum1;
    unsigned            npNum2;
};

/*****************************************************************************/

DEFMGMT
class   constStr
{
public:
    size_t              csLen;
    stringBuff          csStr;
};

DEFMGMT
class constVal
{
public:

    TypDef              cvType;

#ifdef  DEBUG
    var_types           cvVtyp;
#else
    unsigned char       cvVtyp;
#endif

    unsigned char       cvIsStr;    // is this a string constant?
    unsigned char       cvHasLC;    // is this a string constant with large chars?

    union
    {
        __int32             cvIval;
        __int64             cvLval;
        float               cvFval;
        double              cvDval;
        ConstStr            cvSval;
    }
                        cvValue;
};

/*****************************************************************************
 *
 *  Bitsets are used to detect uninitialized variable use. Basically, if there
 *  is a small numbers of locals we need to track, we use a simple integer bit
 *  variable, otherwise we have to use a dynamically sized array of bits. The
 *  bitsetDsc structure holds the data for each instance of a bitset, all of
 *  global state (and code that implements the behavior) is in the compiler
 *  for efficiency class.
 */

#ifdef  __64BIT__
const   size_t          bitsetSmallSize = 64;
typedef __uint64        bitsetSmallType;
#else
const   size_t          bitsetSmallSize = 32;
typedef __uint32        bitsetSmallType;
#endif

const   size_t          bitsetLargeSize =  8;
typedef genericBuff     bitsetLargeType;

DEFMGMT
struct  bitset
{
#ifdef  DEBUG
    unsigned            bsCheck;
#endif
    union
    {
        bitsetSmallType     bsSmallVal;
        bitsetLargeType     bsLargeVal;
    };
};

/*****************************************************************************
 *
 *  The following keeps track of statement nesting when compiling statements.
 */

DEFMGMT
struct  stmtNestRec
{
    StmtNest            snOuter;
    Tree                snStmtExpr;
    treeOps             snStmtKind;
    SymDef              snLabel;
    ILblock             snLabCont;
    ILblock             snLabBreak;
    bool                snHadCont;
    bool                snHadBreak;
    bitset              snDefCont;
    bitset              snDefBreak;
};

/*****************************************************************************
 *
 *  The max. inline buffer size for conversions to Unicode.
 */

const   unsigned        MAX_INLINE_NAME_LEN = 32;

/*****************************************************************************
 *
 *  Metadata import state - one is allocated per each file imported.
 */

DEFMGMT
class   metadataImp
{
private:

    Compiler            MDcomp;
    SymTab              MDstab;

    WCHAR               MDprevNam[MAX_PACKAGE_NAME];
    SymDef              MDprevSym;

    mdToken             MDdelegTok;

    mdToken             MDclsRefObsolete;           // typeref for System::ObsoleteAttribute
    mdToken             MDclsDefObsolete;           // typedef for System::ObsoleteAttribute


    mdToken             MDclsRefAttribute;          // typeref for System::Attribute
    mdToken             MDclsDefAttribute;          // typedef for System::Attribute
    mdToken             MDctrDefAttribute1;         // methdef for System::Attribute::ctor(arg1)
    mdToken             MDctrDefAttribute2;         // methdef for System::Attribute::ctor(arg2)
    mdToken             MDctrDefAttribute3;         // methdef for System::Attribute::ctor(arg3)
    mdToken             MDctrRefAttribute1;         // methref for System::Attribute::ctor(arg1)
    mdToken             MDctrRefAttribute2;         // methref for System::Attribute::ctor(arg2)
    mdToken             MDctrRefAttribute3;         // methref for System::Attribute::ctor(arg3)

public:

    MetaDataImp         MDnext;

    unsigned            MDnum;                      // importer index (used for lookups)

    WMetaDataImport    *MDwmdi;

    void                MDinit(Compiler             comp,
                               SymTab               stab)
    {
        MDcomp = comp;
        MDstab = stab;
        MDwmdi = NULL;

        MDfileTok    = 0;

        MDprevNam[0] = 0;

        MDundefCount = 0;
    }

    void                MDinit(WMetaDataImport  *   wmdi,
                               Compiler             comp,
                               SymTab               stab)
    {
        MDcomp = comp;
        MDstab = stab;
        MDwmdi = wmdi;

        MDprevNam[0] = 0;
    }

    unsigned            MDundefCount;           // bumped for unrecognized stuff

    void                MDimportCTyp(mdTypeDef      td,
                                     mdToken        ft);

    SymDef              MDimportClss(mdTypeDef      td,
                                     SymDef         clsSym,
                                     unsigned       assx,
                                     bool           deep);
    void                MDimportStab(const char *   fname,
                                     unsigned       assx    = 0,
                                     bool           asmOnly = false,
                                     bool           isBCL   = false);

    TypDef              MDimportClsr(mdTypeRef      clsRef,
                                     bool           isVal);
    TypDef              MDimportType(MDsigImport  * sig);

    ArgDef              MDimportArgs(MDsigImport  * sig,
                                     unsigned       cnt,
                                     MDargImport  * state);

    bool                MDfindAttr  (mdToken        token,
                                     wideStr        name,
                                     const void * * blobAddr,
                                     ULONG        * blobSize);

    SymDef              MDfindPropMF(SymDef         propSym,
                                     mdToken        methTok,
                                     bool           getter);

    SymDef              MDimportMem(SymDef          scope,
                                    Ident           name,
                                    mdToken         memTok,
                                    unsigned        attrs,
                                    bool            isProp,
                                    bool            fileScope,
                                    PCCOR_SIGNATURE sigAddr,
                                    size_t          sigSize);

    accessLevels        MDgetAccessLvl(unsigned attrs);

    SymDef              MDparseDotted(WCHAR *name, symbolKinds kind, bool *added);
    Ident               MDhashWideName(WCHAR *name);

    void                MDchk4CustomAttrs(SymDef sym, mdToken tok);

private:

    unsigned            MDassIndex;                 // assembly index or 0
    mdToken             MDfileTok;

    void                MDcreateFileTok();

public:

    void                MDrecordFile()
    {
        if  (!MDfileTok && MDassIndex)
            MDcreateFileTok();
    }
};

/*****************************************************************************
 *
 *  The following is used to save/restore the current symbol table context.
 */

DEFMGMT
struct STctxSave
{
    SymDef              ctxsScp;
    SymDef              ctxsCls;
    SymDef              ctxsNS;
    UseList             ctxsUses;
    SymDef              ctxsComp;
    SymDef              ctxsFncSym;
    TypDef              ctxsFncTyp;
};

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************/

const   unsigned        COLL_STATE_VALS   = 8;  // please don't ask, it's too horrible ...

const   AnsiStr         CFC_CLSNAME_PREFIX= "$DB-state$";

const   AnsiStr         CFC_ARGNAME_ITEM  = "$item";
const   AnsiStr         CFC_ARGNAME_ITEM1 = "$item1";
const   AnsiStr         CFC_ARGNAME_ITEM2 = "$item2";
const   AnsiStr         CFC_ARGNAME_STATE = "$state";

DEFMGMT
class funcletDesc
{
public:

    funcletList         fclNext;
    SymDef              fclFunc;
    SaveTree            fclExpr;
};

DEFMGMT
struct collOpNest
{
    collOpList          conOuter;
    int                 conIndex;
    SymDef              conIterVar;
};

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  The following describes an overlapped I/O file.
 */

#ifdef  ASYNCH_INPUT_READ

DEFMGMT
class   queuedFile
{
public:
    QueuedFile      qfNext;

    Compiler        qfComp;

    const   char *  qfName;         // name of the file
    size_t          qfSize;         // size in bytes
    void    *       qfBuff;         // address of contents (or NULL)
    HANDLE          qfHandle;       // handle when file is open
    HANDLE          qfEvent;        // signalled when entire contents read

#ifdef  DEBUG
    QueuedFile      qfSelf;
#endif

    OVERLAPPED      qfOdsc;

    bool            qfReady;        // file is ready to be open
    bool            qfOpen;         // file is being read
    bool            qfDone;         // file has been read
    bool            qfParsing;      // file is bein compiled
};

#else

DEFMGMT
class   queuedFile
{
};

#endif

/*****************************************************************************
 *
 *  The following defines state and members/methods that are global to the
 *  compilation process.
 */

DEFMGMT
class compiler
{
public:

    compConfig          cmpConfig;

    /************************************************************************/
    /* Main entry points for the compilation process                        */
    /************************************************************************/

    bool                cmpInit();

    static
    bool                cmpPrepSrc(genericRef cookie, stringBuff file,
                                                      QueuedFile buff    = NULL,
                                                      stringBuff srcText = NULL);

    bool                cmpStart(const char *defOutFileName);
    bool                cmpClass(const char *className = NULL);

    bool                cmpDone(bool errors);

    void                cmpPrepOutput();

    void                cmpOutputFileDone(OutFile outf){}

    WritePE             cmpPEwriter;

    /************************************************************************/
    /* Current public state of the compilation process                      */
    /************************************************************************/

public:

    SymTab              cmpCurST;           // current symbol table
    SymDef              cmpCurNS;           // the namespace   we're in
    SymDef              cmpCurCls;          // the class scope we're in
    SymDef              cmpCurScp;          // the local scope we're in
    SymDef              cmpLabScp;          // the label scope we're using
    UseList             cmpCurUses;         // the "using" clauses in effect
    SymDef              cmpCurComp;         // the current compilation unit

#ifdef  SETS
//  SymDef              cmpOuterScp;        // lookup scopes outside of global
#endif

    SymDef              cmpCurFncSym;       // function symbol we're compiling
    TypDef              cmpCurFncTyp;       // function  type  we're compiling
    TypDef              cmpCurFncRtp;       // function return type
    var_types           cmpCurFncRvt;       // function return type

    SymList             cmpLclStatListT;    // temp list of local static variables
    SymList             cmpLclStatListP;    // perm list of local static variables

    bool                cmpManagedMode;     // is default "managed" ?

    ILblock             cmpLeaveLab;        // return from try/catch label / NULL
    SymDef              cmpLeaveTmp;        // return value temp

    unsigned            cmpInTryBlk;
    unsigned            cmpInHndBlk;
    unsigned            cmpInFinBlk;

private:

    /************************************************************************/
    /* Various members used in the compilation process                      */
    /************************************************************************/

    SymDef              cmpAsserAbtSym;

public:

    unsigned            cmpFncCntSeen;
    unsigned            cmpFncCntComp;

    Ident               cmpIdentMain;
    SymDef              cmpFnSymMain;
    mdToken             cmpTokenMain;

    Ident               cmpIdentVAbeg;
    SymDef              cmpFNsymVAbeg;
    Ident               cmpIdentVAget;
    SymDef              cmpFNsymVAget;

    Ident               cmpIdentCompare;
    Ident               cmpIdentEquals;
    Ident               cmpIdentNarrow;
    Ident               cmpIdentWiden;

    Ident               cmpIdentGet;
    Ident               cmpIdentSet;
    Ident               cmpIdentExit;
    Ident               cmpIdentEnter;
    Ident               cmpIdentConcat;
    Ident               cmpIdentInvoke;
    Ident               cmpIdentInvokeBeg;
    Ident               cmpIdentInvokeEnd;
    Ident               cmpIdentVariant;
    Ident               cmpIdentToString;
    Ident               cmpIdentGetType;
    Ident               cmpIdentGetTpHnd;
    Ident               cmpIdentAssertAbt;

    Ident               cmpIdentDbgBreak;

    Ident               cmpIdentXcptCode;
    Ident               cmpIdentXcptInfo;
    Ident               cmpIdentAbnmTerm;

    Ident               cmpIdentGetNArg;
    SymDef              cmpGetNextArgFN;    // ArgIterator::GetNextArg(int)

    SymDef              cmpCtorArgIter;     // ArgIterator(int,int)

    SymDef              cmpConcStr2Fnc;     // Concat(String,String)
    SymDef              cmpConcStr3Fnc;     // Concat(String,String,String)
    SymDef              cmpConcStrAFnc;     // Concat(String[])

    SymDef              cmpStrCompare;      // string value comparison method
    SymDef              cmpStrEquals;       // string value equality   method

    SymDef              cmpFindStrCompMF(const char *name, bool retBool);
    Tree                cmpCallStrCompMF(Tree expr,
                                         Tree  op1,
                                         Tree  op2, SymDef fsym);

    SymDef              cmpFNsymCSenter;    // CriticalSection::Enter
    SymDef              cmpFNsymCSexit;     // CriticalSection::Exit

    mdToken             cmpAttrDeprec;      // attribute ref for "Deprecated"
    mdToken             cmpAttrIsDual;      // attribute ref for "IsDual"
    mdToken             cmpAttrDefProp;     // attribute ref for "DefaultMemberAttribute"
    mdToken             cmpAttrSerlzb;      // attribute ref for "SerializableAttribute"
    mdToken             cmpAttrNonSrlz;     // attribute ref for "NonSerializedAttribute"

    SymDef              cmpAttrClsSym;      // System::Attribute        symbol
    SymDef              cmpAuseClsSym;      // System::AttributeUsage   symbol
//  SymDef              cmpAttrTgtSym;      // System::AttributeTargets symbol

    SymDef              cmpMarshalCls;      // System::Runtime::InteropServices::Marshal

    SymDef              cmpStringConstCls;  // fake class for unmanaged strings

#ifdef  SETS

    SymDef              cmpXPathCls;        // class    XPath

    SymDef              cmpXMLattrClass;    // class    XPath::XML_Class
    SymDef              cmpXMLattrElement;  // class    XPath::XML_Element

    SymDef              cmpInitXMLfunc;     // function XPath::createXMLinst

    Ident               cmpIdentGenBag;
    SymDef              cmpClassGenBag;     // generic class "bag"
    Ident               cmpIdentGenLump;
    SymDef              cmpClassGenLump;    // generic class "lump"

    void                cmpFindXMLcls();

    Ident               cmpIdentCSitem;
    Ident               cmpIdentCSitem1;
    Ident               cmpIdentCSitem2;
    Ident               cmpIdentCSstate;

    Ident               cmpIdentDBhelper;
    SymDef              cmpClassDBhelper;

    Ident               cmpIdentDBall;
    Ident               cmpIdentDBsort;
    Ident               cmpIdentDBslice;
    Ident               cmpIdentDBfilter;
    Ident               cmpIdentDBexists;
    Ident               cmpIdentDBunique;
    Ident               cmpIdentDBproject;
    Ident               cmpIdentDBgroupby;

    Ident               cmpIdentForEach;
    SymDef              cmpClassForEach;
    SymDef              cmpFNsymForEachCtor;
    SymDef              cmpFNsymForEachMore;

    SymDef              cmpCompare2strings; // String::Compare(String,String)

    SaveTree            cmpCurFuncletBody;
    void                cmpGenCollFunclet(SymDef fncSym, SaveTree body);
    SymDef              cmpCollFuncletCls;
    funcletList         cmpFuncletList;

    collOpList          cmpCollOperList;
    unsigned            cmpCollOperCount;

    void                cmpGenCollExpr (Tree        expr);

    Tree                cmpCloneExpr   (Tree        expr,
                                        SymDef      oldSym,
                                        SymDef      newSym);

    SaveTree            cmpSaveTree_I1 (SaveTree    dest,
                                  INOUT size_t REF  size, __int32  val);
    SaveTree            cmpSaveTree_U1 (SaveTree    dest,
                                  INOUT size_t REF  size, __uint32 val);
    SaveTree            cmpSaveTree_U4 (SaveTree    dest,
                                  INOUT size_t REF  size, __uint32 val);
    SaveTree            cmpSaveTree_ptr(SaveTree    dest,
                                  INOUT size_t REF  size, void *   val);
    SaveTree            cmpSaveTree_buf(SaveTree    dest,
                                  INOUT size_t REF  size, void * dataAddr,
                                                          size_t dataSize);

    size_t              cmpSaveTreeRec (Tree        expr,
                                        SaveTree    dest,
                                        unsigned  * stszPtr,
                                        Tree      * stTable);

private:

    unsigned            cmpSaveIterSymCnt;
    SymDef  *           cmpSaveIterSymTab;

    #define             MAX_ITER_VAR_CNT    8

public:

    SaveTree            cmpSaveExprTree(Tree        expr,
                                        unsigned    iterSymCnt,
                                        SymDef    * iterSymTab,
                                        unsigned  * stSizPtr = NULL,
                                        Tree    * * stTabPtr = NULL);

    int                 cmpReadTree_I1 (INOUT SaveTree REF save);
    unsigned            cmpReadTree_U1 (INOUT SaveTree REF save);
    unsigned            cmpReadTree_U4 (INOUT SaveTree REF save);
    void *              cmpReadTree_ptr(INOUT SaveTree REF save);
    void                cmpReadTree_buf(INOUT SaveTree REF save, size_t dataSize,
                                                                 void * dataAddr);

    Tree                cmpReadTreeRec (INOUT SaveTree REF save);
    Tree                cmpReadExprTree(      SaveTree     save,
                                              unsigned   * lclCntPtr);

#endif

    SymDef              cmpFNsymGetTpHnd;   // Type::GetTypeFromHandle
    void                cmpFNsymGetTPHdcl();
    SymDef              cmpFNsymGetTPHget()
    {
        if  (!cmpFNsymGetTpHnd)
            cmpFNsymGetTPHdcl();

        return  cmpFNsymGetTpHnd;
    }

    SymDef              cmpRThandleCls;     // struct System::RuntimeTypeHandle
    void                cmpRThandleClsDcl();
    SymDef              cmpRThandleClsGet()
    {
        if  (!cmpRThandleCls)
            cmpRThandleClsDcl();

        return  cmpRThandleCls;
    }

    SymDef              cmpDeclUmgOper(tokens tokName, const char *extName);

    SymDef              cmpFNumgOperNew;    // unmanaged operator new
    SymDef              cmpFNumgOperNewGet()
    {
        if  (!cmpFNumgOperNew)
            cmpFNumgOperNew = cmpDeclUmgOper(tkNEW   , "??2@YAPAXI@Z");

        return  cmpFNumgOperNew;
    }

    SymDef              cmpFNumgOperDel;    // unmanaged operator delete
    SymDef              cmpFNumgOperDelGet()
    {
        if  (!cmpFNumgOperDel)
            cmpFNumgOperDel = cmpDeclUmgOper(tkDELETE, "??3@YAXPAX@Z");

        return  cmpFNumgOperDel;
    }

    Ident               cmpIdentSystem;
    SymDef              cmpNmSpcSystem;

    Ident               cmpIdentRuntime;
    SymDef              cmpNmSpcRuntime;

    Ident               cmpIdentObject;
    SymDef              cmpClassObject;
    TypDef              cmpRefTpObject;

    Ident               cmpIdentArray;
    SymDef              cmpClassArray;
    TypDef              cmpRefTpArray;

    Ident               cmpIdentString;
    SymDef              cmpClassString;
    TypDef              cmpRefTpString;

    Ident               cmpIdentType;
    SymDef              cmpClassType;
    TypDef              cmpRefTpType;

    Ident               cmpIdentDeleg;
    SymDef              cmpClassDeleg;
    TypDef              cmpRefTpDeleg;

    Ident               cmpIdentMulti;
    SymDef              cmpClassMulti;
    TypDef              cmpRefTpMulti;

    Ident               cmpIdentExcept;
    SymDef              cmpClassExcept;
    TypDef              cmpRefTpExcept;

    Ident               cmpIdentRTexcp;
    SymDef              cmpClassRTexcp;
    TypDef              cmpRefTpRTexcp;

    SymDef              cmpClassMonitor;
    TypDef              cmpRefTpMonitor;

    Ident               cmpIdentArgIter;
    SymDef              cmpClassArgIter;
    TypDef              cmpRefTpArgIter;

    Ident               cmpIdentEnum;
    SymDef              cmpClassEnum;

    Ident               cmpIdentValType;
    SymDef              cmpClassValType;

    TypDef              cmpAsyncDlgRefTp;
    TypDef              cmpIAsyncRsRefTp;

    TypDef              cmpFindArgIterType();
    TypDef              cmpFindMonitorType();
    TypDef              cmpFindStringType();
    TypDef              cmpFindObjectType();
    TypDef              cmpFindExceptType();
    TypDef              cmpFindRTexcpType();
    TypDef              cmpFindArrayType();
    TypDef              cmpFindDelegType();
    TypDef              cmpFindMultiType();
    TypDef              cmpFindTypeType();

    TypDef              cmpExceptRef()
    {
        if  (cmpRefTpExcept)
            return cmpRefTpExcept;
        else
            return cmpFindExceptType();
    }

    TypDef              cmpRTexcpRef()
    {
        if  (cmpRefTpRTexcp)
            return cmpRefTpRTexcp;
        else
            return cmpFindRTexcpType();
    }

    TypDef              cmpStringRef()
    {
        if  (cmpRefTpString)
            return cmpRefTpString;
        else
            return cmpFindStringType();
    }

    TypDef              cmpObjectRef()
    {
        if  (cmpRefTpObject)
            return cmpRefTpObject;
        else
            return cmpFindObjectType();
    }

    TypDef              cmpTypeRef()
    {
        if  (cmpRefTpType)
            return cmpRefTpType;
        else
            return cmpFindTypeType();
    }

    TypDef              cmpArrayRef()
    {
        if  (cmpRefTpArray)
            return cmpRefTpArray;
        else
            return cmpFindArrayType();
    }

    TypDef              cmpDelegRef()
    {
        if  (cmpRefTpDeleg)
            return cmpRefTpDeleg;
        else
            return cmpFindDelegType();
    }

    TypDef              cmpMultiRef()
    {
        if  (cmpRefTpMulti)
            return cmpRefTpMulti;
        else
            return cmpFindMultiType();
    }

    TypDef              cmpArgIterRef()
    {
        if  (cmpRefTpArgIter)
            return cmpRefTpArgIter;
        else
            return cmpFindArgIterType();
    }

    TypDef              cmpMonitorRef()
    {
        if  (cmpRefTpMonitor)
            return cmpRefTpMonitor;
        else
            return cmpFindMonitorType();
    }

    void                cmpInteropFind();
    SymDef              cmpInteropSym;      // System::Runtime::InteropServices
    SymDef              cmpInteropGet()
    {
        if  (!cmpInteropSym)
            cmpInteropFind();

        return  cmpInteropSym;
    }

    void                cmpNatTypeFind();
    SymDef              cmpNatTypeSym;      // System::Runtime::InteropServices::NativeType
    SymDef              cmpNatTypeGet()
    {
        if  (!cmpNatTypeSym)
            cmpNatTypeFind();

        return  cmpNatTypeSym;
    }

    void                cmpCharSetFind();
    SymDef              cmpCharSetSym;      // System::Runtime::InteropServices::CharacterSet
    SymDef              cmpCharSetGet()
    {
        if  (!cmpCharSetSym)
            cmpCharSetFind();

        return  cmpCharSetSym;
    }

#ifdef  SETS

    TypDef              cmpObjArrTypeFind();
    TypDef              cmpObjArrType;      // Object[]

    TypDef              cmpObjArrTypeGet()
    {
        if  (!cmpObjArrType)
            cmpObjArrTypeFind();

        return  cmpObjArrType;
    }

#endif

    bool                cmpIsByRefType(TypDef type);

    bool                cmpIsStringVal(Tree   expr);
    bool                cmpIsObjectVal(Tree   expr);

    unsigned            cmpIsBaseClass(TypDef baseCls, TypDef dervCls);

private:
    unsigned            cmpCntAnonymousNames;
public:
    Ident               cmpNewAnonymousName();

    void                cmpMarkStdType(SymDef clsSym);

private:

    void                cmpFindHiddenBaseFNs(SymDef fncSym, SymDef clsSym);

    SymList             cmpNoDimArrVars;

    Tree                cmpTypeIDinst(TypDef type);

#ifdef  DEBUG
    SymDef              cmpInitVarCur;
    unsigned            cmpInitVarOfs;
#endif

    memBuffPtr          cmpWriteVarData(memBuffPtr      dest,
                                        genericBuff     str,
                                        size_t          len);

    memBuffPtr          cmpInitVarPad  (memBuffPtr      dest,
                                        size_t          amount);

    bool                cmpInitVarAny  (INOUT memBuffPtr REF dest,
                                        TypDef          type,
                                        SymDef          varSym = NULL);
    bool                cmpInitVarScl  (INOUT memBuffPtr REF dest,
                                        TypDef          type,
                                        SymDef          varSym = NULL);
    bool                cmpInitVarArr  (INOUT memBuffPtr REF dest,
                                        TypDef          type,
                                        SymDef          varSym = NULL);
    bool                cmpInitVarCls  (INOUT memBuffPtr REF dest,
                                        TypDef          type,
                                        SymDef          varSym = NULL);

    memBuffPtr          cmpWriteOneInit(memBuffPtr      dest,
                                        Tree            expr);
    memBuffPtr          cmpInitVarBeg  (SymDef          varSym,
                                        bool            undim = false);
    void                cmpInitVarEnd  (SymDef          varSym);
    Tree                cmpParseOneInit(TypDef          type);

    void                cmpBindUseList (UseList         useList);

    SymDef              cmpEntryPointCls;
    void                cmpChk4entryPt (SymDef          sym);

    SymDef              cmpDeclDataMem (SymDef          clsSym,
                                        declMods        memMod,
                                        TypDef          type,
                                        Ident           name);

    SymDef              cmpDeclPropMem (SymDef          clsSym,
                                        TypDef          type,
                                        Ident           name);

    SymDef              cmpDeclFuncMem (SymDef          clsSym,
                                        declMods        memMod,
                                        TypDef          type,
                                        Ident           name);

    SymXinfo            cmpFindXtraInfo(SymXinfo        infoList,
                                        xinfoKinds      infoKind);

    SymXinfoCOM         cmpFindMarshal (SymXinfo        infoList);
    SymXinfoLnk         cmpFindLinkInfo(SymXinfo        infoList);
    SymXinfoSec         cmpFindSecSpec (SymXinfo        infoList);
    SymXinfoSym         cmpFindSymInfo (SymXinfo        infoList,
                                        xinfoKinds      kind);
    SymXinfoAtc         cmpFindATCentry(SymXinfo        infoList,
                                        atCommFlavors   flavor);

    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        SymXinfo        infoAdd)
    {
        if  (infoAdd)
        {
            infoAdd->xiNext = infoList;
            return infoAdd;
        }
        else
            return infoList;
    }

    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        MarshalInfo     marshal);
    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        SymDef          sym,
                                        xinfoKinds      kind);
    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        SecurityInfo    secInfo);
    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        AtComment        atcDesc);
    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        Linkage         linkSpec);

public: // used in the parser
    SymXinfo            cmpAddXtraInfo (SymXinfo        infoList,
                                        SymDef          attrCtor,
                                        unsigned        attrMask,
                                        size_t          attrSize,
                                        genericBuff     attrAddr);

public:
    static
    size_t              cmpDecodeAlign (unsigned        alignVal);
    static
    unsigned            cmpEncodeAlign (size_t          alignSiz);

private:

    void                cmpLayoutClass (SymDef          clsSym);

    TypDef              cmpGetClassSpec(bool            needIntf);

    void                cmpObsoleteUse (SymDef          sym,
                                        unsigned        wrn);

    SymDef              cmpFindIntfImpl(SymDef          clsSym,
                                        SymDef          ifcSym,
                                        SymDef        * impOvlPtr = NULL);

    void                cmpClsImplAbs  (SymDef          clsSym,
                                        SymDef          fncSym);

    void                cmpCheckClsIntf(SymDef          clsSym);

    void                cmpCheckIntfLst(SymDef          clsSym,
                                        SymDef          baseSym,
                                        TypList         intfList);

    void                cmpDeclProperty(SymDef          memSym,
                                        declMods        memMod,
                                        DefList         memDef);
    void                cmpDeclDelegate(DefList         decl,
                                        SymDef          dlgSym,
                                        accessLevels    acc);

    void                cmpDeclTdef    (SymDef          tdefSym);
    void                cmpDeclEnum    (SymDef          enumSym,
                                        bool            namesOnly = false);

    unsigned            cmpDeclClassRec;
    void                cmpDeclClass   (SymDef          clsSym,
                                        bool            noCnsEval = false);
    void                cmpCompClass   (SymDef          clsSym);
    void                cmpCompVar     (SymDef          varSym,
                                        DefList         srcDesc);
    void                cmpCompFnc     (SymDef          fncSym,
                                        DefList         srcDesc);

    ExtList             cmpFlipMemList (ExtList         nspMem);

    IniList             cmpDeferCnsFree;
    IniList             cmpDeferCnsList;

    void                cmpEvalMemInit (ExtList         cnsDef);
    void                cmpEvalMemInits(SymDef          clsSym,
                                        ExtList         constList,
                                        bool            noEval,
                                        IniList         deferLst);

    void                cmpEvalCnsSym  (SymDef          sym,
                                        bool            saveCtx);

    void                cmpDeclConsts  (SymDef          scope,
                                        bool            fullEval);

    bool                cmpDeclSym     (SymDef          sym,
                                        SymDef          onlySym,
                                        bool            recurse);

    bool                cmpCompSym     (SymDef          sym,
                                        SymDef          onlySym,
                                        bool            recurse);

    void                cmpDeclFileSym (ExtList         decl,
                                        bool            fullDecl);

    bool                cmpDeclSymDoit (SymDef          sym,
                                        bool            noCnsEval = false);

    bool                cmpDeclClsNoCns(SymDef          sym);

    void                cmpSaveSTctx   (STctxSave      & save);
    void                cmpRestSTctx   (STctxSave      & save);

public:

    bool                cmpDeclSym     (SymDef          sym);

    memBuffPtr          cmpAllocGlobVar(SymDef          varSym);

    size_t              cmpGetTypeSize (TypDef          type,
                                        size_t    *     alignPtr = NULL);

    static
    void                cmpRecordMemDef(SymDef          clsSym,
                                        ExtList         decl);

    /************************************************************************/
    /*  Logic that checks for uninitialized variable use                    */
    /************************************************************************/

    bool                cmpChkVarInit;          // enables the whole thing

    bool                cmpChkMemInit;          // need to check static mem init?

    unsigned            cmpLclVarCnt;           // # of local variables to track

    bool                cmpGotoPresent;         // irreducible flow-graph?

    bitset              cmpVarsDefined;         // vars known to be defined
    bitset              cmpVarsFlagged;         // vars already flagged

    bitset              cmpVarsIgnore;          // used for unneeded args

    void                cmpChkMemInits();

    void                cmpChkVarInitBeg(unsigned lclVarCnt, bool hadGoto);
    void                cmpChkVarInitEnd();

    void                cmpChkVarInitExprRec(Tree expr);
    void                cmpChkVarInitExpr   (Tree expr)
    {
        if  (cmpChkVarInit)
            cmpChkVarInitExprRec(expr);
    }

    void                cmpCheckUseCond(Tree expr, OUT bitset REF yesBS,
                                                   bool           yesSkip,
                                                   OUT bitset REF  noBS,
                                                   bool            noSkip);

    /************************************************************************/
    /*  Helper logic that maintains bitsets                                 */
    /************************************************************************/

    size_t              cmpLargeBSsize;         // size of large bitset or 0

    void                cmpBitSetInit(unsigned lclVarCnt)
    {
        if  (lclVarCnt > bitsetSmallSize)
            cmpLargeBSsize = (lclVarCnt + bitsetLargeSize - 1) / bitsetLargeSize;
        else
            cmpLargeBSsize = 0;
    }

    void                cmpBS_bigStart (  OUT bitset REF bs)
    {
#ifdef  DEBUG
        bs.bsCheck = 0xBEEFDEAD;
#endif
    }

    void                cmpBS_bigCreate(  OUT bitset REF bs);
    void                cmpBitSetCreate(  OUT bitset REF bs)
    {
        if  (cmpLargeBSsize)
            cmpBS_bigCreate(bs);
        else
            bs.bsSmallVal = 0;
    }

    void                cmpBS_bigDone  (IN    bitset REF bs);
    void                cmpBitSetDone  (IN    bitset REF bs)
    {
        if  (cmpLargeBSsize)
            cmpBS_bigDone(bs);
    }

    void                cmpBS_bigWrite (INOUT bitset REF bs, unsigned pos,
                                                             unsigned val);
    void                cmpBitSetWrite (INOUT bitset REF bs, unsigned pos,
                                                             unsigned val)
    {
        assert(val == 0 || val == 1);

        if  (cmpLargeBSsize)
        {
            cmpBS_bigWrite(bs, pos, val);
        }
        else
        {
            bitsetSmallType mask = (bitsetSmallType)1 << pos;

            assert(pos < bitsetSmallSize);

            if  (val)
                bs.bsSmallVal |=  mask;
            else
                bs.bsSmallVal &= ~mask;
        }
    }

    void                cmpBS_bigCreate(  OUT bitset REF dst,
                                        IN    bitset REF src);
    void                cmpBitSetCreate(  OUT bitset REF dst,
                                        IN    bitset REF src)
    {
        if  (cmpLargeBSsize)
        {
            cmpBS_bigCreate(dst, src);
        }
        else
        {
            dst.bsSmallVal = src.bsSmallVal;
        }
    }

    void                cmpBS_bigAssign(  OUT bitset REF dst,
                                        IN    bitset REF src);
    void                cmpBitSetAssign(  OUT bitset REF dst,
                                        IN    bitset REF src)
    {
        if  (cmpLargeBSsize)
        {
            cmpBS_bigAssign(dst, src);
        }
        else
        {
            dst.bsSmallVal = src.bsSmallVal;
        }
    }

    unsigned            cmpBS_bigRead  (IN    bitset REF bs, unsigned pos);
    unsigned            cmpBitSetRead  (IN    bitset REF bs, unsigned pos)
    {
        if  (cmpLargeBSsize)
        {
            return  cmpBS_bigRead(bs, pos);
        }
        else
        {
            assert(pos < bitsetSmallSize);

            return  ((bs.bsSmallVal & ((bitsetSmallType)1 << pos)) != 0);
        }
    }

    void                cmpBS_bigUnion (INOUT bitset REF bs1,
                                        IN    bitset REF bs2);
    void                cmpBitSetUnion (INOUT bitset REF bs1,
                                        IN    bitset REF bs2)
    {
        if  (cmpLargeBSsize)
        {
            cmpBS_bigUnion(bs1, bs2);
        }
        else
        {
            bs1.bsSmallVal |= bs2.bsSmallVal;
        }
    }

    void                cmpBS_bigIntsct(INOUT bitset REF bs1,
                                        IN    bitset REF bs2);
    void                cmpBitSetIntsct(INOUT bitset REF bs1,
                                        IN    bitset REF bs2)
    {
        if  (cmpLargeBSsize)
        {
            cmpBS_bigIntsct(bs1, bs2);
        }
        else
        {
            bs1.bsSmallVal &= bs2.bsSmallVal;
        }
    }

    /************************************************************************/
    /*  In case anyone wants to know how much work we've been doing         */
    /************************************************************************/

public:
    unsigned            cmpLineCnt;

    /************************************************************************/
    /* Members used for statement reachability analysis                     */
    /************************************************************************/

private:

    bool                cmpStmtReachable;

    void                cmpErrorReach(Tree stmt);

    void                cmpCheckReach(Tree stmt)
    {
        if  (!cmpStmtReachable)
            cmpErrorReach(stmt);
    }

    /************************************************************************/
    /* Pointers to the hash table, scanner, symbol manager, ...             */
    /************************************************************************/

public:

    Scanner             cmpScanner;
    Parser              cmpParser;

    block_allocator     cmpAllocTemp;       // limited lifetime allocs
    norls_allocator     cmpAllocPerm;       // this never goes away
    norls_allocator     cmpAllocCGen;       // used for MSIL generation

#ifdef  DLL
    void    *           cmpOutputFile;      // when compiling to memory
#endif

private:

    BlkList             cmpAllocList;

public:

    genericRef          cmpAllocBlock(size_t sz);

    /************************************************************************/
    /* The following is the root of all evil - er - symbols and such        */
    /************************************************************************/

    HashTab             cmpGlobalHT;        // global hash   table
    SymTab              cmpGlobalST;        // global symbol table
    SymDef              cmpGlobalNS;        // global namespace symbol

    /************************************************************************/
    /* Pre-defined standard types                                           */
    /************************************************************************/

    TypDef              cmpTypeInt;
    TypDef              cmpTypeBool;
    TypDef              cmpTypeChar;
    TypDef              cmpTypeVoid;
    TypDef              cmpTypeUint;
    TypDef              cmpTypeNatInt;
    TypDef              cmpTypeNatUint;

    TypDef              cmpTypeCharPtr;
    TypDef              cmpTypeWchrPtr;
    TypDef              cmpTypeVoidPtr;

    TypDef              cmpTypeVoidFnc;     // void fnc()
    TypDef              cmpTypeStrArr;      // String[]

    /************************************************************************/
    /* Generic type support                                                 */
    /************************************************************************/

    SymList             cmpGenInstList;     // current set of instantiations
    SymList             cmpGenInstFree;     // list of free instantiation desc's

    GenArgDscA          cmpGenArgAfree;     // list of free actual arg descriptors

    void                cmpDeclInstType(SymDef clsSym);

    TypDef              cmpInstanceType(TypDef genType, bool chkOnly = false);

    SymDef              cmpInstanceMeth(INOUT SymDef REF newOvl,
                                              SymDef     clsSym,
                                              SymDef     ovlSym);

    /************************************************************************/
    /* Members related to error reporting                                   */
    /************************************************************************/

    SymDef              cmpErrorSym;
    SymDef              cmpErrorComp;
    const   char *      cmpErrorSrcf;
    Tree                cmpErrorTree;

    unsigned            cmpErrorCount;
    unsigned            cmpFatalCount;
    unsigned            cmpMssgsCount;

    unsigned            cmpErrorMssgDisabled;

#if TRAP_VIA_SETJMP
    ErrTrap             cmpErrorTraps;
#endif

private:

    void                cmpSetSrcPos(SymDef memSym);

    void                cmpShowMsg (unsigned errNum, const char *kind, va_list args);

    const   char *      cmpErrorGenTypName(TypDef typ);
    const   char *      cmpErrorGenSymName(SymDef sym, bool qual = false);
    const   char *      cmpErrorGenSymName(Ident name, TypDef type);

    void                cmpReportSymDef(SymDef sym);
    void                cmpRedefSymErr (SymDef sym, unsigned err);

public:

    void                cmpErrorInit();
    void                cmpErrorSave();

    // The following is accessed by the scanner (we have no friends)

    BYTE                cmpInitialWarn[WRNcountWarn];

    // NOTE: Use the varargs version with extreme care -- no type checking!

    void                cmpSetErrPos(DefSrc def, SymDef compUnit);

    void                cmpCntError();

    void    _cdecl      cmpGenWarn (unsigned errNum, ...);
    void    _cdecl      cmpGenError(unsigned errNum, ...);
    void    _cdecl      cmpGenFatal(unsigned errNum, ...);

    void                cmpError   (unsigned errNum)
    {
        cmpGenError(errNum);
    }

    void                cmpWarn    (unsigned wrnNum)
    {
        cmpGenWarn (wrnNum);
    }

    void                cmpFatal   (unsigned errNum)
    {
        cmpGenFatal(errNum);
    }

    void                cmpFatal   (unsigned errNum, SymDef    sym);

    void                cmpError   (unsigned errNum, Ident    name);
    void                cmpError   (unsigned errNum, SymDef    sym);
    void                cmpError   (unsigned errNum, QualName qual);
    void                cmpError   (unsigned errNum, TypDef   type);
    void                cmpError   (unsigned errNum, Ident    name, TypDef type,
                                                                    bool   glue);
    void                cmpError   (unsigned errNum, TypDef   typ1, TypDef typ2);
    void                cmpError   (unsigned errNum, TypDef    typ, Ident  name);
    void                cmpError   (unsigned errNum, SymDef    sym, Ident  name,
                                                                    TypDef type);
    void                cmpError   (unsigned errNum, Ident    name, TypDef typ1,
                                                                    TypDef typ2);
    void                cmpError   (unsigned errNum, Ident    name, SymDef sym1,
                                                                    SymDef sym2);
    void                cmpError   (unsigned errNum, Ident    nam1, Ident  nam2,
                                                                    Ident  nam3);
    void                cmpError   (unsigned errNum, SymDef    sym, Ident  name);
    void                cmpError   (unsigned errNum, SymDef    sym, QualName qual,
                                                                    TypDef type);
    void                cmpErrorXtp(unsigned errNum, SymDef    sym, Tree   args);
    void                cmpErrorQnm(unsigned errNum, SymDef    sym);
    void                cmpErrorQSS(unsigned errNum, SymDef    sm1, SymDef sym2);
    void                cmpErrorQSS(unsigned errNum, SymDef    sym, TypDef type);
    void                cmpErrorAtp(unsigned errNum, SymDef    sym, Ident  name,
                                                                    TypDef type);
    void                cmpErrorSST(unsigned errNum, stringBuff str,
                                                     SymDef    sym,
                                                     TypDef    typ);

    void                cmpWarn    (unsigned wrnNum, TypDef   typ1, TypDef typ2);
    void                cmpWarn    (unsigned wrnNum, QualName name);
    void                cmpWarn    (unsigned wrnNum, TypDef   type);
    void                cmpWarnQnm (unsigned wrnNum, SymDef    sym);
    void                cmpWarnQns (unsigned wrnNum, SymDef    sym, AnsiStr str);
    void                cmpWarnNqn (unsigned wrnNum, unsigned  val, SymDef  sym);
    void                cmpWarnSQS (unsigned wrnNum, SymDef   sym1, SymDef sym2);

    unsigned            cmpStopErrorMessages();
    bool                cmpRestErrorMessages(unsigned errcnt = 0);

    void                cmpModifierError(unsigned err, unsigned mods);
    void                cmpMemFmod2Error(tokens tok1, tokens tok2);

    /************************************************************************/
    /* Members used for handling unmanaged classes                          */
    /************************************************************************/

public:

    SymList             cmpVtableList;      // list of vtables to generate
    unsigned            cmpVtableCount;

private:

#ifdef  DEBUG
    unsigned            cmpVtableIndex;
#endif

    void                cmpGenVtableContents(SymDef      vtabSym);

    memBuffPtr          cmpGenVtableSection (SymDef     innerSym,
                                             SymDef     outerSym,
                                             memBuffPtr dest);

    /************************************************************************/
    /* Members used for handling value types                                */
    /************************************************************************/

    void                cmpInitStdValTypes();

    Ident               cmpStdValueIdens[TYP_lastIntrins];
    TypDef              cmpStdValueTypes[TYP_lastIntrins];

public:

    var_types           cmpFindStdValType(TypDef    typ);
    TypDef              cmpFindStdValType(var_types vtp);

    TypDef              cmpCheck4valType(TypDef type);

    /************************************************************************/
    /* Members used to bind expressions                                     */
    /************************************************************************/

    SymDef              cmpThisSym;
    Tree                cmpThisRef();
    Tree                cmpThisRefOK();

private:

    Tree                cmpAllocExprRaw  (Tree          expr,
                                          treeOps       oper);

    Tree                cmpCreateExprNode(Tree          expr,
                                          treeOps       oper,
                                          TypDef        type);
    Tree                cmpCreateExprNode(Tree          expr,
                                          treeOps       oper,
                                          TypDef        type,
                                          Tree          op1,
                                          Tree          op2 = NULL);

    Tree                cmpCreateIconNode(Tree          expr,
                                          __int32       val,
                                          var_types     typ);
    Tree                cmpCreateLconNode(Tree          expr,
                                          __int64       val,
                                          var_types     typ);
    Tree                cmpCreateFconNode(Tree          expr,
                                          float         val);
    Tree                cmpCreateDconNode(Tree          expr,
                                          double        val);
    Tree                cmpCreateSconNode(stringBuff    str,
                                          size_t        len,
                                          unsigned      wide,
                                          TypDef        type);
    Tree                cmpCreateErrNode (unsigned      errn = 0);
    Tree                cmpCreateVarNode (Tree          expr,
                                          SymDef        sym);

    Tree                cmpAppend2argList(Tree          args,
                                          Tree          addx);

    /*----------------------------------------------------------------------*/

    void                cmpRecErrorPos   (Tree          expr);

    bool                cmpExprIsErr     (Tree          expr);

    /*----------------------------------------------------------------------*/

    Tree                cmpFoldIntUnop   (Tree          args);
    Tree                cmpFoldLngUnop   (Tree          args);
    Tree                cmpFoldFltUnop   (Tree          args);
    Tree                cmpFoldDblUnop   (Tree          args);

    Tree                cmpFoldIntBinop  (Tree          args);
    Tree                cmpFoldLngBinop  (Tree          args);
    Tree                cmpFoldFltBinop  (Tree          args);
    Tree                cmpFoldDblBinop  (Tree          args);
    Tree                cmpFoldStrBinop  (Tree          args);

    /*----------------------------------------------------------------------*/

    Tree                cmpShrinkExpr    (Tree          expr);
    Tree                cmpCastOfExpr    (Tree          expr,
                                          TypDef        type,
                                          bool          explicitCast);
    var_types           cmpConstSize     (Tree          expr,
                                          var_types     vtp);

    bool                cmpCheckException(TypDef        type);

public:
    bool                cmpCheckAccess   (SymDef        sym);

private:
    bool                cmpCheckAccessNP (SymDef        sym);

    bool                cmpCheckLvalue   (Tree          expr,
                                          bool          addr,
                                          bool          noErr = false);

    Tree                cmpCheckFuncCall (Tree          call);

    bool                cmpConvergeValues(INOUT Tree REF op1,
                                          INOUT Tree REF op2);

    Tree                cmpRefMemberVar  (Tree          expr,
                                          SymDef        sym,
                                          Tree          objPtr = NULL);

    TypDef              cmpMergeFncType  (SymDef        fncSym,
                                          TypDef        type);

    SymDef              cmpFindOvlMatch  (SymDef        fncSym,
                                          Tree          args,
                                          Tree          thisArg);

    bool                cmpMakeRawStrLit (Tree          expr,
                                          TypDef        type,
                                          bool          chkOnly    = false);
    bool                cmpMakeRawString (Tree          expr,
                                          TypDef        type,
                                          bool          chkOnly    = false);

    int                 cmpConversionCost(Tree          srcExpr,
                                          TypDef        dstType,
                                          bool          noUserConv = false);

    /*----------------------------------------------------------------------*/

    SymDef              cmpSymbolNS      (SymDef        sym);
    SymDef              cmpSymbolOwner   (SymDef        sym);

    TypDef              cmpGetActualTP   (TypDef        type);

public:

    TypDef              cmpActualType    (TypDef        type);
    TypDef              cmpDirectType    (TypDef        type);

    var_types           cmpActualVtyp    (TypDef        type);
    var_types           cmpDirectVtyp    (TypDef        type);

    static
    var_types           cmpEnumBaseVtp   (TypDef        type);

    /*----------------------------------------------------------------------*/

public:

    bool                cmpIsManagedAddr (Tree          expr);

    /*----------------------------------------------------------------------*/

private:

    ExtList             cmpTempMLfree;

    ExtList             cmpTempMLappend  (ExtList       list,
                                          ExtList     * lastPtr,
                                          SymDef        sym,
                                          SymDef        comp,
                                          UseList       uses,
                                          scanPosTP     dclFpos,
                                          unsigned      dclLine);

    void                cmpTempMLrelease (ExtList       entry);

    /*----------------------------------------------------------------------*/

#ifndef NDEBUG

    void                cmpChk4ctxChange (TypDef        type1,
                                          TypDef        type2,
                                          unsigned      flags);

#endif

    bool                cmpDiffContext   (TypDef        cls1,
                                          TypDef        cls2);

private:
    Tree                cmpDecayArray    (Tree          expr);
public:
    Tree                cmpDecayCheck    (Tree          expr);

    TypDef              cmpGetRefBase    (TypDef        reftyp);

    var_types           cmpSymbolVtyp    (SymDef        sym);

    /*----------------------------------------------------------------------*/

private:

    size_t              cmpStoreMDlen    (size_t            len,
                                          BYTE  *           dest = NULL);

public:

    SymDef              cmpBindAttribute (SymDef            clsSym,
                                          Tree              argList,
                                          unsigned          tgtMask,
                                      OUT unsigned    REF   useMask,
                                      OUT genericBuff REF   blobAddr,
                                      OUT size_t      REF   blobSize);

    /*----------------------------------------------------------------------*/

    void                cmpDeclDefCtor   (SymDef        clsSym);

private:

    SymDef              cmpFindCtor      (TypDef        clsTyp,
                                          bool          chkArgs,
                                          Tree          args = NULL);

    Tree                cmpCallCtor      (TypDef        type,
                                          Tree          args);

#ifdef  SETS

    Tree                cmpBindProject   (Tree          expr);
    Tree                cmpBindSetOper   (Tree          expr);

    // pre-allocate collection operator state classes

    SymDef  *           cmpSetOpClsTable;
    SymDef              cmpDclFilterCls  (unsigned      args);
public:
    unsigned            cmpSetOpCnt;

    TypDef              cmpIsCollection  (TypDef        type);

    unsigned            cmpClassDefCnt;

#endif

public:

    Tree                cmpBindCondition (Tree          cond);
    int                 cmpEvalCondition (Tree          cond);

    ConstStr            cmpSaveStringCns (const  char * str,
                                          size_t        len);
    ConstStr            cmpSaveStringCns (const wchar * str,
                                          size_t        len);

private:

    Tree                cmpBindVarArgUse (Tree          call);

    SymDef              cmpBindQualName  (QualName      name,
                                          bool          notLast);

    bool                cmpParseConstDecl(SymDef        varSym,
                                          Tree          init  = NULL,
                                          Tree        * ncPtr = NULL);

    Tree                cmpBooleanize    (Tree          expr,
                                          bool          sense);

    Tree                cmpFetchConstVal (ConstVal      cval,
                                          Tree          expr = NULL);

    SymDef              cmpFindPropertyDM(SymDef        accSym,
                                          bool        * isSetPtr);

    SymDef              cmpFindPropertyFN(SymDef        clsSym,
                                          Ident         propName,
                                          Tree          args,
                                          bool          getter,
                                          bool        * found);

public:
    Ident               cmpPropertyName  (Ident         name,
                                          bool          getter);

private:
    Tree                cmpBindProperty  (Tree          expr,
                                          Tree          args,
                                          Tree          asgx);

    Tree                cmpScaleIndex    (Tree          expr,
                                          TypDef        type,
                                          treeOps       oper);

    Tree                cmpBindArrayExpr (TypDef        type,
                                          int           dimPos = 0,
                                          unsigned      elems  = 0);

    Tree                cmpBindArrayBnd  (Tree          expr);
    void                cmpBindArrayType (TypDef        type,
                                          bool          needDef,
                                          bool          needDim,
                                          bool          mustDim);

public:

    TypDef              cmpBindExprType  (Tree          expr);

    void                cmpBindType      (TypDef        type,
                                          bool          needDef,
                                          bool          needDim);

    bool                cmpIsStringExpr  (Tree          expr);

private:

    Tree                cmpBindQmarkExpr (Tree          expr);

    Tree                bindSLVinit      (TypDef        type,
                                          Tree          init);

    Tree                cmpBindNewExpr   (Tree          expr);

    Tree                cmpAdd2Concat    (Tree          expr,
                                          Tree          list,
                                          Tree        * lastPtr);
    Tree                cmpListConcat    (Tree          expr);
    Tree                cmpBindConcat    (Tree          expr);

    Tree                cmpBindCall      (Tree          tree);

    Tree                cmpBindNameUse   (Tree          tree,
                                          bool          isCall,
                                          bool          classOK);

    Tree                cmpBindName      (Tree          tree,
                                          bool          isCall,
                                          bool          classOK);

    Tree                cmpRefAnUnionMem (Tree          expr);

    Tree                cmpBindDotArr    (Tree          tree,
                                          bool          isCall,
                                          bool          classOK);

#ifdef  SETS

public:

    static
    SymDef              cmpNextInstDM    (SymDef        memList,
                                          SymDef    *   memSymPtr);

private:

    Tree                cmpBindSlicer    (Tree          expr);

    Tree                cmpBindXMLinit   (SymDef        clsSym,
                                          Tree          init);

    SymXinfo            cmpAddXMLattr    (SymXinfo      xlist,
                                          bool          elem,
                                          unsigned      num);

#endif

    Tree                cmpBindThisRef   (SymDef        sym);

    Tree                cmpBindAssignment(Tree          dstx,
                                          Tree          srcx,
                                          Tree          tree,
                                          treeOps       oper = TN_ASG);

    Tree                cmpCompOperArg1;
    Tree                cmpCompOperArg2;
    Tree                cmpCompOperFnc1;
    Tree                cmpCompOperFnc2;
    Tree                cmpCompOperFunc;
    Tree                cmpCompOperCall;

    Tree                cmpCompareValues (Tree          expr,
                                          Tree          op1,
                                          Tree          op2);

    Tree                cmpConvOperExpr;

    unsigned            cmpMeasureConv   (Tree          srcExpr,
                                          TypDef        dstType,
                                          unsigned      lowCost,
                                          SymDef        convSym,
                                          SymDef      * bestCnv1,
                                          SymDef      * bestCnv2);

    Tree                cmpCheckOvlOper  (Tree          expr);

    Tree                cmpCheckConvOper (Tree          expr,
                                          TypDef        srcTyp,
                                          TypDef        dstTyp,
                                          bool          expConv,
                                          unsigned    * costPtr = NULL);

    Tree                cmpUnboxExpr     (Tree          expr,
                                          TypDef        type);

    Tree                cmpBindExprRec   (Tree          expr);

public:

    Tree                cmpCoerceExpr    (Tree          expr,
                                          TypDef        type, bool explicitCast);

    Tree                cmpBindExpr      (Tree          expr);

    Tree                cmpFoldExpression(Tree          expr);

    /************************************************************************/
    /* Members used for generating IL                                       */
    /************************************************************************/

    GenILref            cmpILgen;

    stmtNestRec         cmpStmtLast;
    StmtNest            cmpStmtNest;

    SymDef              cmpFilterObj;

    bool                cmpBaseCTisOK;
    bool                cmpBaseCTcall;
    bool                cmpThisCTcall;

    SymDef              cmpTempVarMake   (TypDef        type);
    void                cmpTempVarDone   (SymDef        tsym);

#ifdef  SETS

    void                cmpStmtConnect   (Tree          stmt);

    void                cmpStmtSortFnc   (Tree          sortList);
    void                cmpStmtProjFnc   (Tree          sortList);

    void                cmpStmtForEach   (Tree          stmt,
                                          SymDef        lsym = NULL);

#endif

    void                cmpStmtDo        (Tree          stmt,
                                          SymDef        lsym = NULL);
    void                cmpStmtFor       (Tree          stmt,
                                          SymDef        lsym = NULL);
    void                cmpStmtTry       (Tree          stmt,
                                          Tree          pref = NULL);
    void                cmpStmtExcl      (Tree          stmt);
    void                cmpStmtWhile     (Tree          stmt,
                                          SymDef        lsym = NULL);
    void                cmpStmtSwitch    (Tree          stmt,
                                          SymDef        lsym = NULL);

    void                cmpStmt          (Tree          stmt);

#ifndef NDEBUG
    bool                cmpDidCTinits;
#endif
    void                cmpAddCTinits    ();

    SymDef              cmpBlockDecl     (Tree          blockDcl,
                                          bool          outer,
                                          bool          genDecl,
                                          bool          isCatch);
    SymDef              cmpBlock         (Tree          block,
                                          bool          outer);

    SymDef              cmpGenFNbodyBeg  (SymDef        fncSym,
                                          Tree          body,
                                          bool          hadGoto,
                                          unsigned      lclVarCnt);
    void                cmpGenFNbodyEnd();

#ifdef  OLD_IL
    GenOILref           cmpOIgen;
#endif

    /************************************************************************/
    /* Members used for metadata output                                     */
    /************************************************************************/

public:

    WMetaDataDispenser *cmpWmdd;
    WMetaDataEmit      *cmpWmde;
    WAssemblyEmit      *cmpWase;

private:

    mdAssembly          cmpCurAssemblyTok;

    mdTypeRef           cmpLinkageClass;        // fake class for entry points

#ifdef  DEBUG
    unsigned            cmpGenLocalSigLvx;
#endif

    void                cmpSecurityMD    (mdToken       token,
                                          SymXinfo      infoList);

    void                cmpGenLocalSigRec(SymDef        scope);

    wchar   *           cmpGenMDname     (SymDef        sym,
                                          bool          full,
                                          wchar  *      buffAddr,
                                          size_t        buffSize,
                                          wchar  *    * buffHeapPtr);

    SymDef              cmpTypeDefList;
    SymDef              cmpTypeDefLast;

    void                cmpGenTypMetadata(SymDef        sym);
    void                cmpGenGlbMetadata(SymDef        sym);
    void                cmpGenMemMetadata(SymDef        sym);

    wchar   *           cmpArrayClsPref  (SymDef        sym,
                                          wchar *       dest,
                                          int           delim,
                                          bool          fullPath = false);
    wchar   *           cmpArrayClsName  (TypDef        type,
                                          bool          nonAbstract,
                                          wchar *       dest,
                                          wchar *       nptr);

    Tree                cmpFakeXargsVal;

    void                cmpAddCustomAttrs(SymXinfo      infoList,
                                          mdToken       owner);

    void                cmpSetGlobMDoffsR(SymDef        scope,
                                          unsigned      dataOffs);

public:

    void                cmpSetGlobMDoffs (unsigned      dataOffs);
    void                cmpSetStrCnsOffs (unsigned       strOffs);

    mdToken             cmpMDstringLit   (wchar *       str,
                                          size_t        len);

    TypDef              cmpGetBaseArray  (TypDef        type);

    mdToken             cmpArrayEAtoken  (TypDef        arrType,
                                          unsigned      dimCnt,
                                          bool          store,
                                          bool          addr = false);

    mdToken             cmpArrayCTtoken  (TypDef         arrType,
                                          TypDef        elemType,
                                          unsigned      dimCnt);

    mdToken             cmpArrayTpToken  (TypDef        type,
                                          bool          nonAbstract = false);

    mdToken             cmpPtrTypeToken  (TypDef        type);

    mdToken             cmpClsEnumToken  (TypDef        type);

    PCOR_SIGNATURE      cmpTypeSig       (TypDef        type,
                                          size_t      * lenPtr);
    mdSignature         cmpGenLocalSig   (SymDef        scope,
                                          unsigned      count);
    void                cmpGenMarshalInfo(mdToken       token,
                                          TypDef        type,
                                          MarshalInfo   info);
    PCOR_SIGNATURE      cmpGenMarshalSig (TypDef        type,
                                          MarshalInfo   info,
                                          size_t      * lenPtr);
    PCOR_SIGNATURE      cmpGenMemberSig  (SymDef        memSym,
                                          Tree          xargs,
                                          TypDef        memTyp,
                                          TypDef        prefTp,
                                          size_t      * lenPtr);
    void                cmpGenFldMetadata(SymDef        fldSym);
    mdSignature         cmpGenSigMetadata(TypDef        fncTyp,
                                          TypDef        pref  = NULL);
    mdToken             cmpGenFncMetadata(SymDef        fncSym,
                                          Tree          xargs = NULL);
    mdToken             cmpGenClsMetadata(SymDef        clsSym,
                                          bool          extref = false);
    mdToken             cmpStringConstTok(size_t        addr,
                                          size_t        size);
    unsigned            cmpStringConstCnt;
    strCnsPtr           cmpStringConstList;

    void                cmpFixupScopes   (SymDef        scope);

    void                cmpAttachMDattr  (mdToken       target,
                                          wideStr       oldName,
                                          AnsiStr       newName,
                                          mdToken     * newTokPtr,
                                          unsigned      valTyp = 0,
                                          const void  * valPtr = NULL,
                                          size_t        valSiz = 0);
private:

    // fixed table of assembly tokens

    unsigned            cmpAssemblyRefCnt;

    mdAssembly          cmpAssemblyRefTab[32];
    mdAssemblyRef       cmpAssemblyRefTok[32];
    WAssemblyImport *   cmpAssemblyRefImp[32];
    BYTE *              cmpAssemblyRefXXX[32];

    unsigned            cmpAssemblyBCLx;

public:

    void                cmpAssemblyTkBCL(unsigned assx)
    {
        cmpAssemblyBCLx = assx;
    }

    bool                cmpAssemblyIsBCL(unsigned assx)
    {
        assert(assx && assx <= cmpAssemblyRefCnt);

        return  (assx == cmpAssemblyBCLx);
    }

    mdExportedType           cmpAssemblySymDef(SymDef sym, mdTypeDef defTok = 0);
    mdAssemblyRef       cmpAssemblyAddRef(mdAssembly ass, WAssemblyImport *imp);

    unsigned            cmpAssemblyRefAdd(mdAssembly ass, WAssemblyImport *imp, BYTE *cookie = NULL)
    {
        assert(cmpAssemblyRefCnt < arraylen(cmpAssemblyRefTab));

        cmpAssemblyRefTab[cmpAssemblyRefCnt] = ass;
        cmpAssemblyRefImp[cmpAssemblyRefCnt] = imp;
        cmpAssemblyRefXXX[cmpAssemblyRefCnt] = cookie;

        return  ++cmpAssemblyRefCnt;
    }

    mdAssemblyRef       cmpAssemblyRefRec(unsigned assx)
    {
        assert(assx && assx <= cmpAssemblyRefCnt);

        assx--;

        assert(cmpAssemblyRefTab[assx]);

        if  (cmpAssemblyRefTok[assx] == 0)
             cmpAssemblyRefTok[assx] = cmpAssemblyAddRef(cmpAssemblyRefTab[assx],
                                                         cmpAssemblyRefImp[assx]);

        return  cmpAssemblyRefTok[assx];
    }

    WAssemblyImport *   cmpAssemblyGetImp(unsigned assx)
    {
        assert(assx && assx <= cmpAssemblyRefCnt);

        assert(cmpAssemblyRefTab[assx-1]);

        return cmpAssemblyRefImp[assx-1];
    }

    mdToken             cmpAssemblyAddFile(wideStr  fileName,
                                           bool     doHash,
                                           unsigned flags = 0);

    void                cmpAssemblyAddType(wideStr  typeName,
                                           mdToken  defTok,
                                           mdToken  scpTok,
                                           unsigned flags);

    void                cmpAssemblyAddRsrc(AnsiStr  fileName,
                                           bool     internal);

    void                cmpAssemblyNonCLS();

    void                cmpMarkModuleUnsafe();

    /************************************************************************/
    /* Members used for conversion to Unicode                               */
    /************************************************************************/

public:

    wchar               cmpUniConvBuff[MAX_INLINE_NAME_LEN+1];

    size_t              cmpUniConvSize;
    wchar   *           cmpUniConvAddr;

    void                cmpUniConvInit()
    {
        cmpUniConvAddr = cmpUniConvBuff;
        cmpUniConvSize = MAX_INLINE_NAME_LEN;
    }

#if MGDDATA
    String              cmpUniConv(char managed [] str, size_t len);
#endif
    wideString          cmpUniConv(const char *    str, size_t len);
    wideString          cmpUniCnvW(const char *    str, size_t*lenPtr);

    wideString          cmpUniConv(Ident name)
    {
        return          cmpUniConv(name->idSpelling(), name->idSpellLen());
    }

    /************************************************************************/
    /* Members used to create metadata signatures                           */
    /************************************************************************/

private:

    char                cmpMDsigBuff[256];                  // default buffer

    size_t              cmpMDsigSize;                       // size of current buff
    char    *           cmpMDsigHeap;                       // non-NULL if on heap

#ifndef NDEBUG
    bool                cmpMDsigUsed;                       // to detect recursion
#endif

    char    *           cmpMDsigBase;                       // buffer start addr
    char    *           cmpMDsigNext;                       // next byte to store
    char    *           cmpMDsigEndp;                       // buffer end addr

    void                cmpMDsigExpand(size_t size);

public:

    void                cmpMDsigInit()
    {
        cmpMDsigBase = cmpMDsigBuff;
        cmpMDsigEndp = cmpMDsigBase + sizeof(cmpMDsigBuff);
        cmpMDsigSize = sizeof(cmpMDsigBuff) - 4;
#ifndef NDEBUG
        cmpMDsigUsed = false;
#endif
        cmpMDsigHeap = NULL;
    }

    void                cmpMDsigStart ();
    PCOR_SIGNATURE      cmpMDsigEnd   (size_t     *sizePtr);

    void                cmpMDsigAddStr(const char *str, size_t len);
    void                cmpMDsigAddStr(const char *str)
    {
                        cmpMDsigAddStr(str, strlen(str)+1);
    }

    void                cmpMDsigAdd_I1(int         val);    // fixed-size  8-bit int
    void                cmpMDsigAddCU4(unsigned    val);    // compressed unsigned
    void                cmpMDsigAddTok(mdToken     tok);    // compressed token

    void                cmpMDsigAddTyp(TypDef      type);

    /************************************************************************/
    /* Metadata import stuff                                                */
    /************************************************************************/

    MetaDataImp         cmpMDlist;
    MetaDataImp         cmpMDlast;
    unsigned            cmpMDcount;

    void                cmpInitMD();

    void                cmpInitMDimp ();
    void                cmpDoneMDimp ();

    void                cmpInitMDemit();
    void                cmpDoneMDemit();

    MetaDataImp         cmpAddMDentry();

    IMetaDataImport   * cmpFindImporter(SymDef globSym);

    void                cmpImportMDfile(const char *fname   = NULL,
                                        bool        asmOnly = false,
                                        bool        isBCL   = false);

private:
    void                cmpFindMDimpAPIs(SymDef                   typSym,
                                         IMetaDataImport        **imdiPtr,
                                         IMetaDataAssemblyEmit  **iasePtr,
                                         IMetaDataAssemblyImport**iasiPtr);
public:

    void                cmpMakeMDimpTref(SymDef clsSym);
    void                cmpMakeMDimpFref(SymDef fncSym);
    void                cmpMakeMDimpDref(SymDef fldSym);
    void                cmpMakeMDimpEref(SymDef etpSym);

    /************************************************************************/
    /* Metadata debug output                                                */
    /************************************************************************/

    unsigned            cmpCurFncSrcBeg;
    unsigned            cmpCurFncSrcEnd;

    WSymWriter         *cmpSymWriter;

    void               *cmpSrcFileDocument(SymDef srcSym);

    /************************************************************************/
    /* Generic utility vector deal to convert pointer to small indices      */
    /************************************************************************/

private:

#if MGDDATA
    VecEntryDsc []      cmpVecTable;
#else
    VecEntryDsc *       cmpVecTable;
#endif

    unsigned            cmpVecCount;        // number of items stored
    unsigned            cmpVecAlloc;        // size currently allocated

    void                cmpVecExpand();

public:

    unsigned            cmpAddVecEntry(const void * val, vecEntryKinds kind)
    {
        assert(val != NULL);

        if  (cmpVecCount >= cmpVecAlloc)
            cmpVecExpand();

        assert(cmpVecCount < cmpVecAlloc);

#ifdef  DEBUG
        cmpVecTable[cmpVecCount].vecKind  = kind;
#endif
        cmpVecTable[cmpVecCount].vecValue = val;

        return  ++cmpVecCount;
    }

    const   void *      cmpGetVecEntry(unsigned x, vecEntryKinds kind)
    {
        assert(x && x <= cmpVecCount);

        assert(cmpVecTable[x - 1].vecKind == kind);
        return cmpVecTable[x - 1].vecValue;
    }

//  bool                cmpDelVecEntry(unsigned x, vecEntryKinds kind);

    /************************************************************************/
    /* Miscellaneous members                                                */
    /************************************************************************/

    bool                cmpEvalPreprocCond();

#ifdef DEBUG
    void                cmpDumpSymbolTable();
#endif

    bool                cmpParserInit;       // has the parser been initialized?
};

/*****************************************************************************
 *
 *  For easier debugging of the compiler itself. NOTE: This is not thread-safe!
 */

#ifdef  DEBUG
#ifndef __SMC__
extern  Compiler        TheCompiler;
extern  Scanner         TheScanner;
#endif
#endif

/*****************************************************************************
 *
 *  The following is used to temporarily disable error messages.
 */

inline
unsigned                compiler::cmpStopErrorMessages()
{
    cmpErrorMssgDisabled++;
    return  cmpMssgsCount;
}

inline
bool                    compiler::cmpRestErrorMessages(unsigned errcnt)
{
    cmpErrorMssgDisabled--;
    return  cmpMssgsCount > errcnt;
}

/*****************************************************************************
 *
 *  In non-debug mode the following function doesn't need to do any work.
 */

#ifndef DEBUG
inline  void            compiler::cmpInitVarEnd(SymDef varSym){}
#endif

/*****************************************************************************/

#include "symbol.h"
#include "type.h"

/*****************************************************************************/

inline
void    *           SMCgetMem(Compiler comp, size_t size)
{
    return  comp->cmpAllocTemp.baAlloc      (size);
}

inline
void    *           SMCgetM_0(Compiler comp, size_t size)
{
    return  comp->cmpAllocTemp.baAllocOrNull(size);
}

inline
void                SMCrlsMem(Compiler comp, void *block)
{
            comp->cmpAllocTemp.baFree(block);
}

/*****************************************************************************
 *
 *  Each symbol table manages its own names and symbol/type entries.
 */

DEFMGMT
class symTab
{
    Compiler            stComp;
    unsigned            stOwner;

public:
    HashTab             stHash;

    norls_allocator *   stAllocPerm;        // used for all  non-local allocs

private:
    norls_allocator *   stAllocTemp;        // used for function-local allocs

public:

    void                stInit(Compiler             comp,
                               norls_allocator    * alloc,
                               HashTab              hash   = NULL,
                               unsigned             ownerx = 0);

    /************************************************************************/
    /* Members used to manage symbol entries                                */
    /************************************************************************/

    DefList             stRecordSymSrcDef(SymDef    sym,
                                          SymDef    st,
                                          UseList   uses, scanPosTP dclFpos,
//                                                        scanPosTP dclEpos,
                                                          unsigned  dclLine,
//                                                        unsigned  dclCol,
                                          bool      ext = false);

    ExtList             stRecordMemSrcDef(Ident     name,
                                          QualName  qual,
                                          SymDef    comp,
                                          UseList   uses, scanPosTP dclFpos,
//                                                        scanPosTP dclEpos,
                                                          unsigned  dclLine);

    /*-------------------------------------------------------------------*/

    TypDef              stDlgSignature(TypDef       dlgTyp);

    /*-------------------------------------------------------------------*/

    ovlOpFlavors        stOvlOperIndex(tokens       token,
                                       unsigned     argCnt = 0);
    Ident               stOvlOperIdent(ovlOpFlavors oper);

    /*-------------------------------------------------------------------*/

    SymDef              stFindOvlFnc  (SymDef       fsym,
                                       TypDef       type);
    SymDef              stFindOvlProp (SymDef       psym,
                                       TypDef       type);

    SymDef              stFindSameProp(SymDef       psym,
                                       TypDef       type);

    SymDef              stDeclareSym  (Ident        name,
                                       symbolKinds  kind,
                                       name_space   nspc,
                                       SymDef       scope);

    SymDef              stDeclareOper (ovlOpFlavors oper,
                                       SymDef       scope);

    SymDef              stDeclareLab  (Ident        name,
                                       SymDef       scope, norls_allocator*alloc);

    SymDef              stDeclareOvl  (SymDef       fsym);

    SymDef              stDeclareNcs  (Ident        name,
                                       SymDef       scope,
                                       str_flavors  flavor);

    SymDef              stDeclareLcl  (Ident        name,
                                       symbolKinds  kind,
                                       name_space   nspc,
                                       SymDef       scope,
                                       norls_allocator *alloc);

#ifdef DEBUG

    void                stDumpSymDef  (DefSrc       def,
                                       SymDef       comp);

    void                stDumpSymbol  (SymDef       sym,
                                       int          indent,
                                       bool         recurse,
                                       bool         members);

    void                stDumpQualName(QualName     name);

    void                stDumpUsings  (UseList      uses,
                                       unsigned     indent);

#endif

    SymDef              stSearchUsing (INOUT UseList REF uses,
                                       Ident             name,
                                       name_space        nsp);

private:

    SymDef              stFindInClass (Ident        name,
                                       SymDef       scope,
                                       name_space   symNS);

public:

    SymDef              stFindInBase  (SymDef       memSym,
                                       SymDef       scope);

    SymDef              stFindBCImem  (SymDef       clsSym,
                                       Ident        name,
                                       TypDef       type,
                                       symbolKinds  kind,
                                 INOUT SymDef   REF matchFN,
                                       bool         baseOnly);

    SymDef              stLookupAllCls(Ident        name,
                                       SymDef       scope,
                                       name_space   symNS,
                                       compileStates state);

    SymDef              stLookupProp  (Ident        name,
                                       SymDef       scope);

    SymDef              stLookupOperND(ovlOpFlavors oper,
                                       SymDef       scope);
    SymDef              stLookupOper  (ovlOpFlavors oper,
                                       SymDef       scope);

    SymDef              stLookupNspSym(Ident        name,
                                       name_space   symNS,
                                       SymDef       scope);

    SymDef              stLookupClsSym(Ident        name,
                                       SymDef       scope);

    SymDef              stLookupScpSym(Ident        name,
                                       SymDef       scope);

    SymDef              stLookupLclSym(Ident        name,
                                       SymDef       scope);

#ifdef  SETS
    SymDef              stImplicitScp;
#endif

    SymDef              stLookupSym   (Ident        name,
                                       name_space   symNS);

    SymDef              stLookupLabSym(Ident        name,
                                       SymDef       scope)
    {
        return  stLookupNspSym(name, NS_HIDE, scope);
    }

    void                stRemoveSym   (SymDef       sym);

    static
    SymDef              stNamespOfSym (SymDef       sym)
    {
        assert(sym->sdSymKind == SYM_VAR  ||
               sym->sdSymKind == SYM_FNC  ||
               sym->sdSymKind == SYM_ENUM ||
               sym->sdSymKind == SYM_CLASS);

        do
        {
            sym = sym->sdParent; assert(sym);
        }
        while (sym->sdSymKind == SYM_CLASS);
        assert(sym->sdSymKind == SYM_NAMESPACE);

        return sym;
    }

    static
    SymDef              stErrSymbol;        // to indicate error conditions

    /************************************************************************/
    /* Members used to manage type descriptors                              */
    /************************************************************************/

public:

    void                stInitTypes  (unsigned      refHashSz = 512,
                                      unsigned      arrHashSz = 128);

    void                stExtArgsBeg (  OUT ArgDscRec REF newArgs,
                                        OUT ArgDef    REF lastRef,
                                            ArgDscRec     oldArgs,
                                            bool          prefix  = false,
                                            bool          outOnly = false);
    void                stExtArgsAdd (INOUT ArgDscRec REF newArgs,
                                      INOUT ArgDef    REF lastArg,
                                            TypDef        argType,
                                            const char *  argName = NULL);
    void                stExtArgsEnd (INOUT ArgDscRec REF newArgs);

    void                stAddArgList (INOUT ArgDscRec REF args,
                                      TypDef        type,
                                      Ident         name);

    TypList             stAddIntfList(TypDef        type,
                                      TypList       list,
                                      TypList *     lastPtr);

    TypDef              stNewClsType (SymDef        tsym);
    TypDef              stNewEnumType(SymDef        tsym);

    TypDef              stNewRefType (var_types     kind,
                                      TypDef        elem = NULL,
                                      bool          impl = false);

    DimDef              stNewDimDesc (unsigned      size);
    TypDef              stNewGenArrTp(unsigned      dcnt,
                                      TypDef        elem,
                                      bool          generic);
    TypDef              stNewArrType (DimDef        dims,
                                      bool          mgd,
                                      TypDef        elem = NULL);
    TypDef              stNewFncType (ArgDscRec     args,
                                      TypDef        rett = NULL);

    TypDef              stNewTdefType(SymDef        tsym);

    TypDef              stNewErrType (Ident         name);

private:

    TypDef              stAllocTypDef(var_types     kind);

    static
    unsigned            stTypeHash   (TypDef        type,
                                      int           ival,
                                      bool          bval1,
                                      bool          bval2 = false);

    TypDef              stRefTypeList;
    unsigned            stRefTpHashSize;
    TypDef         *    stRefTpHash;

    TypDef              stArrTypeList;
    unsigned            stArrTpHashSize;
    TypDef         *    stArrTpHash;

#ifdef  SETS
    static
    unsigned            stAnonClassHash(TypDef clsTyp);
#endif

    static
    unsigned            stComputeTypeCRC(TypDef typ);

    static
    unsigned            stComputeArgsCRC(TypDef typ);

private:
    TypDef              stIntrinsicTypes[TYP_lastIntrins + 1];
public:
    TypDef              stIntrinsicType(var_types vt)
    {
        assert((unsigned)vt <= TYP_lastIntrins);

        return  stIntrinsicTypes[vt];
    };

    static
    bool                stArgsMatch  (TypDef typ1, TypDef typ2);
    static
    bool                stMatchArrays(TypDef typ1, TypDef typ2, bool subtype);
    static
    bool                stMatchTypes (TypDef typ1, TypDef typ2);
    static
    bool                stMatchType2 (TypDef typ1, TypDef typ2);

private:
    static
    BYTE                stIntrTypeSizes [TYP_COUNT];
    static
    BYTE                stIntrTypeAligns[TYP_COUNT];

public:
    static
    size_t              stIntrTypeSize (var_types type);
    static
    size_t              stIntrTypeAlign(var_types type);

    static
    normString          stClsFlavorStr(unsigned flavor);
    static
    normString          stIntrinsicTypeName(var_types);

    unsigned            stIsBaseClass(TypDef baseCls, TypDef dervCls);

    static
    bool                stIsAnonUnion(SymDef clsSym);
    static
    bool                stIsAnonUnion(TypDef clsTyp);

    static
    bool                stIsObjectRef(TypDef type);

    /************************************************************************/
    /* Members used for error reporting (and debugging of the compiler)     */
    /************************************************************************/

private:

    char    *           typeNameNext;
    char    *           typeNameAddr;
    TypDef  *           typeNameDeft;
    bool    *           typeNameDeff;

    void                pushTypeChar(int ch);
#if MGDDATA
    void                pushTypeStr (String     str);
#else
    void                pushTypeStr (const char*str);
#endif
    void                pushTypeSep (bool       refOK = false,
                                     bool       arrOK = false);

    void                pushTypeNstr(SymDef     sym,
                                     bool       fullName);
    void                pushQualNstr(QualName   name);

    void                pushTypeInst(SymDef     clsSym);

    void                pushTypeArgs(TypDef     type);
    void                pushTypeDims(TypDef     type);

    void                pushTypeName(TypDef     type,
                                     bool       isptr,
                                     bool       qual);

    void                pushFullName(TypDef     typ,
                                     SymDef     sym,
                                     Ident      name,
                                     QualName   qual,
                                     bool       fullName);

    bool                stDollarClsMode;

public:

    //  get "outer$inner" string for nested class names

    void                stTypeNameSetDollarClassMode(bool dollars)
    {
        stDollarClsMode = dollars;
    }

    stringBuff          stTypeName(TypDef       typ,
                                   SymDef       sym         = NULL,
                                   Ident        name        = NULL,
                                   QualName     qual        = NULL,
                                   bool         fullName    = false,
                                   stringBuff   destBuffPos = NULL);


    const   char *      stErrorTypeName(TypDef   type);
    const   char *      stErrorTypeName(Ident    name, TypDef type);
    const   char *      stErrorSymbName(SymDef    sym, bool   qual = false,
                                                       bool notype = false);
    const   char *      stErrorIdenName(Ident    name, TypDef type = NULL);
    const   char *      stErrorQualName(QualName name, TypDef type = NULL);
};

/*****************************************************************************/

inline
bool                symTab::stMatchTypes(TypDef typ1, TypDef typ2)
{
    if  (typ1 == typ2)
        return  true;

    if  (typ1 && typ2)
        return  stMatchType2(typ1, typ2);

    return  false;
}

/*****************************************************************************
 *
 *  Returns the size (in bytes) of the given intrinsic type.
 */

inline
size_t              symTab::stIntrTypeSize(var_types type)
{
    assert(type < sizeof(stIntrTypeSizes)/sizeof(stIntrTypeSizes[0]));
    assert(stIntrTypeSizes[type] || type == TYP_NATINT || type == TYP_NATUINT);

    return stIntrTypeSizes[type];
}

/*****************************************************************************
 *
 *  Returns the alignment of the given intrinsic type.
 */

inline
size_t              symTab::stIntrTypeAlign(var_types type)
{
    assert(type < sizeof(stIntrTypeAligns)/sizeof(stIntrTypeAligns[0]));
    assert(stIntrTypeAligns[type]);

    return stIntrTypeAligns[type];
}

/*****************************************************************************
 *
 *  A wrapper around stIsBaseClass() that makes sure the derived class has
 *  been declared before calling it.
 */

inline
unsigned            compiler::cmpIsBaseClass(TypDef baseCls, TypDef dervCls)
{
    if  (dervCls->tdClass.tdcSymbol->sdCompileState < CS_DECLARED)
        cmpDeclSym(dervCls->tdClass.tdcSymbol);

    return  cmpGlobalST->stIsBaseClass(baseCls, dervCls);
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\config.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _CONFIG_H_
#define _CONFIG_H_
/*****************************************************************************/

enum compilerPhases
{
    CPH_NONE,
    CPH_START,
    CPH_PARSING,
};

struct  compConfig
{
    compilerPhases  ccCurPhase;     // determines which options are allowed

    #define CMDOPT(name, type, phase, defval) type cc##name;
    #include "options.h"

    BYTE            ccWarning[WRNcountWarn];
};

enum    enumConfig
{
    #define CMDOPT(name, type, phase, defval) CC_##name,
    #include "options.h"

    CC_COUNT
};

// The table holding the default value (and other info) about each compiler
// option is initialized (i.e. filled with values) in the macros.cpp file.

struct  optionDesc
{
    unsigned            odValueOffs :16;
    unsigned            odValueSize :8;

    unsigned            odMaxPhase  :8;

    NatInt              odDefault;
};

#ifndef __SMC__
extern  optionDesc      optionInfo[CC_COUNT];
#endif

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\cor-temp.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
typedef  char * AnsiStr;
typedef wchar * wideStr;

const   wideStr COR_REQUIRES_SECOBJ_CUSTOM_VALUE      = L"REQ_SO";
const   AnsiStr COR_REQUIRES_SECOBJ_CUSTOM_VALUE_ANSI = A"REQ_SO";

#if 0

const   size_t          MAX_PACKAGE_NAME = 255;
const   size_t          MAX_CLASS_NAME   = 255;

const
uint   COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF;

#endif

struct  COR_ILMETHOD_SECT_SMALL : IMAGE_COR_ILMETHOD_SECT_SMALL
{
public:
        const BYTE* Data() { return(((const BYTE*) this) + sizeof(COR_ILMETHOD_SECT_SMALL)); }
};

struct  COR_ILMETHOD_SECT_FAT : IMAGE_COR_ILMETHOD_SECT_FAT
{
public:
        const BYTE* Data() { return(((const BYTE*) this) + sizeof(COR_ILMETHOD_SECT_FAT)); }
};

struct  COR_ILMETHOD_SECT
{
    const COR_ILMETHOD_SECT_FAT  * AsFat  () { return((COR_ILMETHOD_SECT_FAT  *) this); }
    const COR_ILMETHOD_SECT_SMALL* AsSmall() { return((COR_ILMETHOD_SECT_SMALL*) this); }
    const COR_ILMETHOD_SECT      * Align  () { return((COR_ILMETHOD_SECT      *) ((int)(((uint*)this) + 3) & ~3));  }
};

struct  COR_ILMETHOD_FAT : IMAGE_COR_ILMETHOD_FAT
{
public:

        bool     IsFat() { return((Flags & CorILMethod_FormatMask) == CorILMethod_FatFormat); }
        unsigned GetMaxStack() { return(MaxStack); }
        unsigned GetCodeSize() { return(CodeSize); }
        unsigned GetLocalVarSigTok() { return(LocalVarSigTok); }
        BYTE*    GetCode() { return(((BYTE*) this) + 4*Size); }
        const COR_ILMETHOD_SECT* GetSect() {
                if (!(Flags & CorILMethod_MoreSects)) return(NULL);
                return(((COR_ILMETHOD_SECT*) (GetCode() + GetCodeSize()))->Align());
                }
};


struct  OSINFO
{
        DWORD           dwOSPlatformId;                 // Operating system platform.
        DWORD           dwOSMajorVersion;               // OS Major version.
        DWORD           dwOSMinorVersion;               // OS Minor version.
};


struct  ASSEMBLYMETADATA
{
        USHORT          usMajorVersion;                 // Major Version.
        USHORT          usMinorVersion;                 // Minor Version.
        USHORT          usBuildNumber;                  // Build Number.
        USHORT          usRevisionNumber;               // Revision Number.
        LCID            *rLocale;                               // Locale array.
        ULONG           ulLocale;                               // [IN/OUT] Size of the locale array/Actual # of entries filled in.
        DWORD           *rProcessor;                    // Processor ID array.
        ULONG           ulProcessor;                    // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
        OSINFO          *rOS;                                   // OSINFO array.
        ULONG           ulOS;                                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
};

inline
unsigned    TypeFromToken(mdToken tk) { return (tk & 0xff000000); }

const mdToken mdTokenNil             = ((mdToken)0);
const mdToken mdModuleNil            = ((mdModule)mdtModule);
const mdToken mdTypeDefNil           = ((mdTypeDef)mdtTypeDef);
const mdToken mdInterfaceImplNil     = ((mdInterfaceImpl)mdtInterfaceImpl);
const mdToken mdTypeRefNil           = ((mdTypeRef)mdtTypeRef);
const mdToken mdCustomAttributeNil   = ((mdCustomAttribute)mdtCustomAttribute);
const mdToken mdMethodDefNil         = ((mdMethodDef)mdtMethodDef);
const mdToken mdFieldDefNil          = ((mdFieldDef)mdtFieldDef);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\error.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

/*****************************************************************************/

#include "error.h"

/*****************************************************************************/

#if defined(__IL__) && defined(_MSC_VER)
int     _cdecl      vsprintf(char *buff, const char *fmt, va_list args);
#endif

/*****************************************************************************/

void                compiler::cmpErrorInit()
{
    assert(sizeof( cmpConfig.ccWarning) == sizeof( warnDefault));
    assert(sizeof(*cmpConfig.ccWarning) == sizeof(*warnDefault));

    memcpy(cmpConfig.ccWarning, warnDefault, sizeof(warnDefault));
}

void                compiler::cmpErrorSave()
{
    assert(sizeof( cmpConfig.ccWarning) == sizeof( cmpInitialWarn));
    assert(sizeof(*cmpConfig.ccWarning) == sizeof(*cmpInitialWarn));

    memcpy(cmpInitialWarn, cmpConfig.ccWarning, sizeof(cmpConfig.ccWarning));
}

/*****************************************************************************/

void                compiler::cmpShowMsg(unsigned      errNum,
                                         const char *  kind,
                                         va_list       args)
{
    const   char *  srcf;
    char            buff[1024];

    assert(errNum != ERRnone);

    if  (cmpErrorMssgDisabled)
        return;

    /* Form the error message string */

    vsprintf(buff, errorTable[errNum], args);

    /* Display the source file */

    if      (cmpErrorComp)
    {
        srcf = cmpErrorComp->sdComp.sdcSrcFile;
    }
    else if (cmpErrorSrcf)
    {
        srcf = cmpErrorSrcf;
    }
    else
        goto NO_SRCF;

    printf("%s", srcf);

    /* Display the current source position */

    if      (cmpErrorTree && cmpErrorTree->tnLineNo)
    {
//      printf("(%u,%u): ", cmpErrorTree->tnLineNo,
//                          cmpErrorTree->tnColumn);
        printf("(%u): "   , cmpErrorTree->tnLineNo);
    }
    else if (cmpScanner->scanGetSourceLno())
    {
//      printf("(%u,%u): ", cmpScanner->scanGetSourceLno(),
//                          cmpScanner->scanGetTokenCol());
        printf("(%u): "   , cmpScanner->scanGetSourceLno());
    }
    else
        printf(": ");

NO_SRCF:

    /* Bash the number if this is a warning */

    if  (errNum >= WRNfirstWarn)
         errNum -= WRNfirstWarn - 4000;

    /* Display the error/warning number */

    printf("%s S%04d: ", kind, errNum);

    /* Display the message */

    printf("%s\n", buff);

    /* Make sure we reset the error string logic */

    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpCntError()
{
    if  (++cmpErrorCount >= cmpConfig.ccMaxErrs)
        cmpFatal(ERR2manyErrs);

#ifdef  DEBUG
    if  (!cmpErrorMssgDisabled) forceDebugBreak();
#endif

}

/*****************************************************************************/

void    _cdecl      compiler::cmpGenWarn(unsigned wrnNum, ...)
{
    va_list         args;

    assert(wrnNum >= WRNfirstWarn);
    assert(wrnNum <  WRNafterWarn);

    if  (!cmpConfig.ccWarning[wrnNum - WRNfirstWarn])
        return;

    if  (cmpErrorMssgDisabled)
        return;

    va_start(args, wrnNum);

    cmpShowMsg(wrnNum, cmpConfig.ccWarnErr ? "error" : "warning", args);
    va_end(args);

    if  (cmpConfig.ccWarnErr)
        cmpCntError();
}

/*****************************************************************************/

void    _cdecl      compiler::cmpGenError(unsigned errNum, ...)
{
    va_list         args;

    assert(errNum < WRNfirstWarn);

    cmpMssgsCount++;

    if  (cmpErrorMssgDisabled)
        return;

    va_start(args, errNum);

    cmpShowMsg(errNum, "error", args);
    va_end(args);

    cmpCntError();
}

/*****************************************************************************/

void    _cdecl      compiler::cmpGenFatal(unsigned errNum, ...)
{
    va_list         args;

    assert(errNum < WRNfirstWarn);

    va_start(args, errNum);

    cmpShowMsg(errNum, "fatal error", args);
    va_end(args);

    cmpErrorCount++;
    cmpFatalCount++;

    forceDebugBreak();

    jmpErrorTrap(this);
}

/*****************************************************************************/

const   char *      compiler::cmpErrorGenSymName(SymDef sym, bool qual)
{
    char *          nstr = cmpScanner->scanErrNameStrBeg();

    assert(sym);

    cmpGlobalST->stTypeName(sym->sdType, sym, NULL, NULL, qual, nstr);

    cmpScanner->scanErrNameStrAdd(nstr);
    cmpScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************/

const   char *      compiler::cmpErrorGenSymName(Ident name, TypDef type)
{
    char *          nstr = cmpScanner->scanErrNameStrBeg();

    cmpGlobalST->stTypeName(type, NULL, name, NULL, false, nstr);

    cmpScanner->scanErrNameStrAdd(nstr);
    cmpScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************/

const   char *      compiler::cmpErrorGenTypName(TypDef typ)
{
    char *          nstr = cmpScanner->scanErrNameStrBeg();

    cmpGlobalST->stTypeName(typ, NULL, NULL, NULL, false, nstr);

    cmpScanner->scanErrNameStrAdd(nstr);
    cmpScanner->scanErrNameStrEnd();

    return nstr;
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, Ident name)
{
    cmpGenError(errNum, hashTab::identSpelling(name));
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, SymDef sym)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorSymbName(sym));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, TypDef typ)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorTypeName(typ));
    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpWarn (unsigned wrnNum, TypDef typ)
{
    cmpScanner->scanErrNameBeg();
    cmpGenWarn (wrnNum, cmpGlobalST->stErrorTypeName(typ));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, QualName qual)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorQualName(qual));
    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpWarn (unsigned wrnNum, QualName qual)
{
    cmpScanner->scanErrNameBeg();
    cmpGenWarn (wrnNum, cmpGlobalST->stErrorQualName(qual));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, Ident name, TypDef type,
                                                                    bool   glue)
{
    if  (glue && type && type->tdTypeKind != TYP_FNC)
        type = NULL;

    cmpScanner->scanErrNameBeg();
    if  (glue)
        cmpGenError(errNum, cmpGlobalST->stErrorIdenName(name, type));
    else
        cmpGenError(errNum, name->idSpelling(), cmpGlobalST->stErrorTypeName(type));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, SymDef sym, QualName qual,
                                                                    TypDef   type)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, sym->sdSpelling(),
                        cmpGlobalST->stErrorQualName(qual, type));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, TypDef typ1, TypDef typ2)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorTypeName(typ1),
                        cmpGlobalST->stErrorTypeName(typ2));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, Ident name, TypDef typ1,
                                                                    TypDef typ2)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, name->idSpelling(),
                        cmpGlobalST->stErrorTypeName(typ1),
                        cmpGlobalST->stErrorTypeName(typ2));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, SymDef sym, Ident name)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorSymbName(sym), name->idSpelling());
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, TypDef typ, Ident  name)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorTypeName(NULL, typ),
                        name->idSpelling());
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, SymDef sym, Ident  name,
                                                                    TypDef type)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpGlobalST->stErrorSymbName(sym),
                        cmpGlobalST->stErrorTypeName(name,type));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, Ident name, SymDef sym1,
                                                                    SymDef sym2)
{
    cmpScanner->scanErrNameBeg();

    cmpGenError(errNum, name->idSpelling(),
                        cmpErrorGenSymName(sym1, true),
                        cmpErrorGenSymName(sym2, true));

    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpError(unsigned errNum, Ident nam1,
                                                        Ident nam2,
                                                        Ident nam3)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, nam1->idSpelling(), nam2->idSpelling(), nam3->idSpelling());
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpErrorQnm(unsigned errNum, SymDef sym)
{
    cmpScanner->scanErrNameBeg();
    cmpGenError(errNum, cmpErrorGenSymName(sym, true));
    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpFatal   (unsigned errNum, SymDef sym)
{
    cmpScanner->scanErrNameBeg();
    cmpGenFatal(errNum, cmpErrorGenSymName(sym, true));
    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpWarnQnm (unsigned wrnNum, SymDef sym)
{
    cmpScanner->scanErrNameBeg();
    cmpGenWarn (wrnNum, cmpErrorGenSymName(sym, true));
    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpWarnQns (unsigned wrnNum, SymDef   sym, AnsiStr str)
{
    cmpScanner->scanErrNameBeg();
    cmpGenWarn (wrnNum, cmpErrorGenSymName(sym, true), str);
    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpWarnNqn (unsigned wrnNum, unsigned val, SymDef sym)
{
    cmpScanner->scanErrNameBeg();
    cmpGenWarn (wrnNum, val, cmpErrorGenSymName(sym, true));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpErrorSST(unsigned errNum, stringBuff   str,
                                                           SymDef       sym,
                                                           TypDef       typ)
{
    assert(typ && typ->tdTypeKind != TYP_UNDEF);

    cmpScanner->scanErrNameBeg();

    cmpGenError(errNum, str, cmpErrorGenSymName(sym, true),
                             cmpErrorGenTypName(typ));

    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpErrorAtp(unsigned errNum, SymDef       sym,
                                                           Ident        name,
                                                           TypDef       type)
{
    assert(type && type->tdTypeKind == TYP_FNC);

    cmpScanner->scanErrNameBeg();

    cmpGenError(errNum, cmpErrorGenSymName(sym, true),
                        cmpErrorGenSymName(name, type));

    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpErrorQSS(unsigned errNum, SymDef sym1,
                                                           SymDef sym2)
{
    cmpScanner->scanErrNameBeg();

    cmpGenError(errNum, cmpErrorGenSymName(sym1, true),
                        cmpErrorGenSymName(sym2, true));

    cmpScanner->scanErrNameEnd();
}

void                compiler::cmpErrorQSS(unsigned errNum, SymDef sym,
                                                           TypDef type)
{
    cmpScanner->scanErrNameBeg();

    cmpGenError(errNum, cmpErrorGenSymName(sym, false),
                        cmpGlobalST->stErrorTypeName(type));

    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpWarn(unsigned wrnNum, TypDef typ1,
                                                       TypDef typ2)
{
    cmpScanner->scanErrNameBeg();
    cmpGenWarn (wrnNum, cmpGlobalST->stErrorTypeName(typ1),
                        cmpGlobalST->stErrorTypeName(typ2));
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpWarnSQS(unsigned wrnNum, SymDef sym1,
                                                          SymDef sym2)
{
    cmpScanner->scanErrNameBeg();

    cmpGenWarn (wrnNum, cmpErrorGenSymName(sym1, true),
                        cmpErrorGenSymName(sym2, true));

    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/

void                compiler::cmpErrorXtp(unsigned errNum, SymDef sym, Tree args)
{
    char *          nstr;

    cmpScanner->scanErrNameBeg();

    nstr = cmpScanner->scanErrNameStrBeg();

    cmpGlobalST->stErrorSymbName(sym, true, true);
    cmpScanner->scanErrNameStrApp("(");

    if  (args)
    {
        char    *       tstr = nstr + strlen(nstr);

        for (;;)
        {
            Tree            argx;

            assert(args->tnOper == TN_LIST);
            argx = args->tnOp.tnOp1;

            if  (argx->tnOper == TN_NULL && !(argx->tnFlags & TNF_BEEN_CAST))
            {
                cmpScanner->scanErrNameStrAdd("null"); tstr += 4;
            }
            else
            {
                assert(argx->tnType->tdTypeKind != TYP_UNDEF);

                cmpGlobalST->stTypeName(argx->tnType, NULL, NULL, NULL, false, tstr);
                cmpScanner->scanErrNameStrAdd(tstr);
                tstr += strlen(tstr);
            }

            args = args->tnOp.tnOp2;
            if  (!args)
                break;

            cmpScanner->scanErrNameStrAdd(", "); tstr += 2;
        }
    }

    cmpScanner->scanErrNameStrAdd(")");
    cmpScanner->scanErrNameStrEnd();

    cmpGenError(errNum, nstr);
    cmpScanner->scanErrNameEnd();
}

/*****************************************************************************/
#if !TRAP_VIA_SETJMP

int                 __SMCfilter(Compiler comp, int exceptCode, void *exceptInfo)
{
    return  (exceptCode == SMC_ERROR_CODE);
}

void                __SMCraiseErr()
{
    RaiseException(SMC_ERROR_CODE, 0, 1, NULL);
}

#endif
/*****************************************************************************/
#ifndef NDEBUG

void    __cdecl     __AssertAbort(const char *why, const char *file, unsigned line)
{
    Compiler        comp;
    char            buff[1024];

   *buff = 0;
    comp = TheCompiler;

    if  (comp)
    {
        const   char *  srcf;

        /* Get the current source position */

        if      (comp->cmpErrorComp)
        {
            srcf = comp->cmpErrorComp->sdComp.sdcSrcFile;
        }
        else if (comp->cmpErrorSrcf)
        {
            srcf = comp->cmpErrorSrcf;
        }
        else
            goto NO_SRCF;

        sprintf(buff+strlen(buff), "%s", srcf);

        /* Display the current source position */

        if  (comp->cmpErrorTree && comp->cmpErrorTree->tnLineNo)
        {
//          sprintf(buff+strlen(buff), "(%u,%u) : ", comp->cmpErrorTree->tnLineNo,
//                                                   comp->cmpErrorTree->tnColumn);
            sprintf(buff+strlen(buff), "(%u) : "   , comp->cmpErrorTree->tnLineNo);
        }
        else
        {
//          sprintf(buff+strlen(buff), "(%u,%u) : ", comp->cmpScanner->scanGetSourceLno(),
//                                                   comp->cmpScanner->scanGetTokenCol());
            sprintf(buff+strlen(buff), "(%u) : "   , comp->cmpScanner->scanGetSourceLno());
        }
    }

NO_SRCF:

    sprintf(buff+strlen(buff), "error XXXXX: %s(%u) failed assertion '%s'\n", file, line, why);

#ifdef  GUI_VERSION

    wsprintf(buff, ": Assertion failed '%s'\n", why);
    OutputDebugString(buff);

#else

    printf(buff);
#ifndef __IL__
    fflush(stdout);
#endif

    forceDebugBreak();
    exit(2);

#endif

}

#endif
/*****************************************************************************/
#ifdef  __IL__
#ifndef _MSC_VER
/*****************************************************************************/

static  char    *   hex(unsigned val, char *pos, bool upper, unsigned fillSize = 0)
{
    size_t          nlen = 0;

    if  (val)
    {
        do
        {
            int     nibl;
            int     hexc;

            nibl  = val & 0xF;
            val >>= 4;

            if  (nibl > 9)
            {
                nibl -= 10;

                if  (upper)
                    hexc = nibl + 'A';
                else
                    hexc = nibl + 'a';
            }
            else
            {
                hexc = nibl + '0';
            }

            *--pos = hexc; nlen++;
        }
        while (val);
    }
    else
    {
        *--pos = '0'; nlen++;
    }

    while (nlen < fillSize--)
        *--pos = '0';

    return  pos;
}

int     _cdecl      vsprintf(char *buff, const char *fmt, va_list args)
{
    char    *       p = buff;

#ifndef __64BIT__       // the code won't compile for 64 bits

    bool            fmtBeg;
    bool            fmtNeg;
    bool            fmtLng;
    bool            fmtZrf;
    bool            fmtSgn = false;
    bool            fmtI64 = false;
    size_t          fmtDec = 0;
    size_t          fmtLen = 0;

    fmtBeg = false;

    while (*fmt)
    {
        int             ch = *fmt++;

        if  (fmtBeg)
        {
            switch (ch)
            {
            case '-':
                fmtNeg = true;
                break;

            case 'l':
                fmtLng = true;
                break;

            case '0':
                if  (!fmtLen)
                {
                    fmtZrf = true;
                    break;
                }

                // Fall through ...

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                fmtLen = fmtLen * 10 + (ch - '0');
                break;

            case '.':
                fmtDec = fmtLen;
                fmtLen = 0;
                break;

            case 's':
            case 'c':
                {
                    /* Format a string or character */

                    char        tmp[5];
                    char *      str;
                    size_t      len;

                    if  (ch == 's')
                    {
                        str = va_arg(args, char*);

                        if  (str)
                        {
                            len    = strlen(str);
                        }
                        else
                        {
                            strcpy(tmp, "null");
                            str    = tmp;
                            len    = 4;
                        }
                    }
                    else
                    {
                        tmp[0] = va_arg(args, int);
                        tmp[1] = 0;
                        str    = tmp;
                        len    = 1;
                    }

                    if  (fmtLen > len)
                    {
                        if  (fmtNeg)
                        {
                            for (size_t tmp = len; tmp; tmp--)
                                *p++ = *str++;
                        }

                        while (fmtLen > len)
                        {
                            *p++ = ' ';
                            fmtLen--;
                        }

                        if  (fmtNeg)
                            len = 0;
                    }

                    // Copy 'len' characters

                    while (len--)
                        *p++ = *str++;
                }

                fmtBeg = false;
                break;

            case 'u':
            case 'd':
                {
                    char        buff[32];
                    char    *   temp = buff+1;
                    size_t      nlen;

                    if  (fmtI64)
                    {
                        __int64     val = va_arg(args, __int64);

                        // ignore the high bits

                        sprintf(temp, (ch == 'd') ? "%d" : "%u", (int)val);

                        if  (fmtSgn && ch == 'd' && val >= 0)
                        {
                            assert(temp == buff+1);

                            *--temp = '+';
                        }
                    }
                    else
                    {
                        unsigned    val = va_arg(args, __int32);

                        sprintf(temp, (ch == 'd') ? "%d" : "%u", val);

                        if  (fmtSgn && ch == 'd' && (int)val >= 0)
                        {
                            assert(temp == buff+1);

                            *--temp = '+';
                        }
                    }

                    nlen = strlen(temp);

                    while (nlen < fmtLen--)
                        *p++ = fmtZrf ? '0' : ' ';

                    while (*temp)
                        *p++ = *temp++;
                }
                fmtBeg = false;
                break;

            case 'f':
                {
                    double      val = va_arg(args, double);

                    char        buff[32];
                    char    *   temp = buff;
                    size_t      nlen;

                    sprintf(buff, "%f", val);
                    nlen = strlen(temp);

                    while (nlen < fmtLen--)
                        *p++ = fmtZrf ? '0' : ' ';

                    while (*temp)
                        *p++ = *temp++;
                }
                fmtBeg = false;
                break;

            case 'x':
            case 'X':
                {
                    char        buff[32];
                    char    *   temp;
                    size_t      nlen;

                    buff[sizeof(buff)-1] = 0;

                    if  (fmtI64)
                    {
                        unsigned __int64    val = va_arg(args, unsigned __int64);

                        temp = hex((unsigned)(val & 0xFFFFFFFF), buff + sizeof(buff) - 1, (ch == 'X'), 8);
                        temp = hex((unsigned)(val >> 32       ), temp                   , (ch == 'X'));
                    }
                    else
                    {
                        unsigned            val = va_arg(args, unsigned __int32);

                        temp = hex(val, buff + sizeof(buff) - 1, (ch == 'X'));
                    }

                    nlen = buff + sizeof(buff) - temp;

                    while (nlen < fmtLen--)
                        *p++ = fmtZrf ? '0' : ' ';

                    while (*temp)
                        *p++ = *temp++;
                }
                fmtBeg = false;
                break;

            case '*':
                fmtLen = va_arg(args, int);
                if  ((int)fmtLen < 0)
                {
                    fmtLen = -(int)fmtLen;
                    fmtNeg = true;
                }
                break;

            case 'I':

                /* This better be "I64" */

                if  (fmt[0] == '6' &&
                     fmt[1] == '4')
                {
                    fmt   += 2;
                    fmtI64 = true;

                    break;
                }

            case 'L':
                fmtI64 = true;
                break;

            case '+':
                fmtSgn = true;
                break;

            default:
                static char *nullPtr; *nullPtr = 0;
                return 0;
            }
        }
        else
        {
            switch (ch)
            {
            case '%':
                if  (*fmt != '%')
                {
                    fmtBeg = true;
                    fmtLen =
                    fmtDec = 0;
                    fmtNeg =
                    fmtLng =
                    fmtZrf =
                    fmtI64 = false;
                    break;
                }

                fmt++;

                // Fall through ...

            default:
                *p++ = ch;
                break;
            }
        }
    }

    *p = 0;

#endif

    return  p - buff;
}

int                 vprintf(const char *fmt, va_list args)
{
    char            buff[1024];
    int             size;

#ifndef __64BIT__       // the code won't compile for 64 bits

    size = vsprintf(buff, fmt, args);
    if  (size >= sizeof(buff))
    {
        NO_WAY(!"vprintf buffer not large enough");
        exit(-1);
    }

    printf(buff);

#endif

    return  size;
}

/*****************************************************************************/
#endif
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\error.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _ERROR_H_
#define _ERROR_H_
/*****************************************************************************/

#ifndef TRAP_VIA_SETJMP
#define TRAP_VIA_SETJMP 0
#endif

#ifdef  __IL__
#if     TRAP_VIA_SETJMP
#error  Sorry, can not use setjmp() for trapping errors in managed MSIL; use SEH.
#endif
#endif

/*****************************************************************************/
#if TRAP_VIA_SETJMP

#include <setjmp.h>

struct  errTrapDesc;
typedef errTrapDesc*ErrTrap;
struct  errTrapDesc
{
    ErrTrap         etdPrev;
    jmp_buf         etdJmpBuf;
};

#endif
/*****************************************************************************/

#ifndef __SMC__

#undef  SMC_ERR
#undef  SMC_WR1
#undef  SMC_WRN
#define SMC_ERR(name, lvl, str)  name,
#define SMC_WR1(name, lvl, str)  name, WRNfirstWarn = name,
#define SMC_WRN(name, lvl, str)  name,
enum    errors
{
    #include "errors.h"

    WRNafterWarn
};
#undef  SMC_ERR
#undef  SMC_WR1
#undef  SMC_WRN

const
unsigned    WRNcountWarn = WRNafterWarn - WRNfirstWarn + 1;

extern  const   char *   errorTable[];
extern  const   char *   errorTable[];

extern  BYTE            warnDefault[WRNcountWarn];

#endif

/*****************************************************************************/

#ifndef _COMP_H_
#include "comp.h"
#endif

/*****************************************************************************/
#if TRAP_VIA_SETJMP
/*****************************************************************************/

#ifndef __IL__
//#pragma message("NOTE: using setjmp for error traps")
#endif

#define                 setErrorTrap(comp)                                  \
                                                                            \
    errTrapDesc         __trap;                                             \
                                                                            \
    __trap.etdPrev = comp->cmpErrorTraps;                                   \
                     comp->cmpErrorTraps = &__trap;

#define                 begErrorTrap                                        \
                                                                            \
                                                                            \
    int  __errc = setjmp(__trap.etdJmpBuf);                                 \
    if  (__errc == 0)

#define                 endErrorTrap(comp)                                  \
                                                                            \
        comp->cmpErrorTraps = __trap.etdPrev;

#define                 chkErrorTrap(hand) hand
#define                 fltErrorTrap(comp, xcod, xinf)                      \
                                                                            \
    else

#define                 hndErrorTrap(comp)                                  \
                                                                            \
        comp->cmpErrorTraps = __trap.etdPrev;

inline  void            jmpErrorTrap(Compiler comp)
{
     assert(comp->cmpErrorTraps);
    longjmp(comp->cmpErrorTraps->etdJmpBuf, 1);
}

/*****************************************************************************/
#else   // !TRAP_VIA_SETJMP
/*****************************************************************************/

#ifndef __IL__
//#pragma message("NOTE: using SEH for error traps")
#endif

extern  int             __SMCfilter  (Compiler  comp, int   xcptCode,
                                                      void *xcptInfo);
extern  void            __SMCraiseErr();

const   unsigned        SMC_ERROR_CODE = 0x02345678;

inline  void            setErrorTrap(Compiler comp){}
#define                 begErrorTrap    __try

inline  void            endErrorTrap(Compiler comp){}

#define                 chkErrorTrap __except
#define                 fltErrorTrap __SMCfilter

inline  void            hndErrorTrap(Compiler comp){}
inline  void            endErrorTrap(){}

inline  void            jmpErrorTrap(Compiler comp)
{
    __SMCraiseErr();
}

/*****************************************************************************/
#endif  // !TRAP_VIA_SETJMP
/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\corimp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include <sys/types.h>
#include <sys/stat.h>

/*****************************************************************************
 *
 *  Helpers to fetch various pieces of a COM99 signature.
 */

class   MDsigImport
{
public:

    void                MDSIinit(Compiler comp,
                                 SymTab   stab, PCCOR_SIGNATURE  sigptr,
                                                size_t           sigsiz)
    {
        MDSIsigPtr = sigptr;
#ifdef  DEBUG
        MDSIsigMax = sigptr + sigsiz;
#endif
        MDSIcomp   = comp;
        MDSIstab   = stab;
    }

    Compiler            MDSIcomp;
    SymTab              MDSIstab;

    PCCOR_SIGNATURE     MDSIsigPtr;

#ifdef  DEBUG
    PCCOR_SIGNATURE     MDSIsigMax;
#endif

    void                MDSIchkEnd()
    {
        assert(MDSIsigPtr == MDSIsigMax);
    }

    unsigned            MDSIreadUI1()
    {
        assert(MDSIsigPtr < MDSIsigMax);
        return*MDSIsigPtr++;
    }

    unsigned            MDSIpeekUI1()
    {
        assert(MDSIsigPtr < MDSIsigMax);
        return*MDSIsigPtr;
    }

    int                 MDSIreadI4()
    {
        int             temp;
        MDSIsigPtr += CorSigUncompressSignedInt(MDSIsigPtr, &temp); assert(MDSIsigPtr <= MDSIsigMax);
        return temp;
    }

    ULONG               MDSIreadUI4()
    {
        ULONG           temp;
        MDSIsigPtr += CorSigUncompressData(MDSIsigPtr, &temp); assert(MDSIsigPtr <= MDSIsigMax);
        return temp;
    }

    CorElementType      MDSIreadETP()
    {
        CorElementType  temp;
        MDSIsigPtr += CorSigUncompressElementType(MDSIsigPtr, &temp); assert(MDSIsigPtr <= MDSIsigMax);
        return temp;
    }

    mdToken             MDSIreadTok()
    {
        mdToken         temp;
        MDSIsigPtr += CorSigUncompressToken(MDSIsigPtr, &temp); assert(MDSIsigPtr <= MDSIsigMax);
        return temp;
    }
};

/*****************************************************************************
 *
 *  When importing an argument list the following structure (whose address is
 *  passed along) holds the state of the argument list conversion process.
 */

struct MDargImport
{
    bool            MDaiExtArgDef;
    HCORENUM        MDaiParamEnum;
    mdToken         MDaiMethodTok;
    mdToken         MDaiNparamTok;
};

/*****************************************************************************
 *
 *  Import and convert a class type from COM99 metadata.
 */

TypDef              metadataImp::MDimportClsr(mdTypeRef clsRef, bool isVal)
{
    SymDef          clsSym;
    bool            clsNew;
    TypDef          clsTyp;

    WCHAR           clsName[MAX_CLASS_NAME];
    ULONG           lenClsName;

    symbolKinds     symKind;

    var_types       vtyp;

    /* Get the fully qualified name of the referenced type */

    if  (TypeFromToken(clsRef) == mdtTypeRef)
    {
        if  (FAILED(MDwmdi->GetTypeRefProps(clsRef, 0,
                                            clsName, arraylen(clsName), NULL)))
        {
            MDcomp->cmpFatal(ERRreadMD);
        }
    }
    else
    {

        DWORD           typeFlag;

        if  (FAILED(MDwmdi->GetTypeDefProps(clsRef,
                                            clsName, arraylen(clsName), &lenClsName,
                                            &typeFlag, NULL)))
        {
            MDcomp->cmpFatal(ERRreadMD);
        }

        symKind = SYM_CLASS;    // UNDONE: we don't whether we have enum or class!!!!!!

        /* Is this a nested class ? */

        if  ((typeFlag & tdVisibilityMask) >= tdNestedPublic &&
             (typeFlag & tdVisibilityMask) <= tdNestedFamORAssem)
        {
            mdTypeDef           outerTok;
            TypDef              outerCls;
            SymDef              outerSym;
            LPWSTR              tmpName;
            Ident               clsIden;

            if  (MDwmdi->GetNestedClassProps(clsRef, &outerTok))
                MDcomp->cmpFatal(ERRreadMD);

            /* Resolve the outer class token to a class symbol */

            outerCls = MDimportClsr(outerTok, false); assert(outerCls);
            outerSym = outerCls->tdClass.tdcSymbol;

            /* Lookup the nested class and declare it if it doesn't exist yet */

            tmpName = wcsrchr(clsName, '.');        // ISSUE: this is pretty awful
            if (!tmpName)
                tmpName = clsName;
            else
                tmpName++;

            /* Got the naked nested class name, now look for it */

            clsIden = MDhashWideName(tmpName);
            clsSym  = MDstab->stLookupScpSym(clsIden, outerSym);

            if  (!clsSym)
                clsSym = MDstab->stDeclareSym(clsIden, symKind, NS_NORM, outerSym);

            goto GOT_TYPE;
        }
    }

    /* Is this a class or enum ref ? */

    symKind = SYM_CLASS;

    /* Convert the dotted name to a symbol */

    clsNew  = false;
    clsSym  = MDparseDotted(clsName, SYM_CLASS, &clsNew);

    if  (!clsSym)
        return  NULL;

GOT_TYPE:

    symKind = clsSym->sdSymKindGet();

//  printf("Typeref '%s'\n", clsSym->sdSpelling());

    /* We better get the right kind of a symbol back */

    assert(clsSym);
    assert(clsSym->sdSymKind == symKind);

    if  (clsNew || clsSym->sdCompileState < CS_DECLSOON)
    {
        mdTypeRef       clsd;
        WMetaDataImport*wmdi;

        /* Do we have a typedef ? */

        if  (TypeFromToken(clsRef) == mdtTypeDef)
        {
            clsSym = MDimportClss(clsRef, NULL, 0, false);
            goto GOT_CLS;
        }

        /* The class hasn't been seen yet, we'll import it later if needed */

        if  (MDwmdi->ResolveTypeRef(clsRef,
                                    getIID_IMetaDataImport(),
                                    &wmdi,
                                    &clsd) != S_OK)
        {
            MDcomp->cmpFatal(ERRundefTref, clsSym);
        }

#if 0

        save the scope/typeref in the symbol for later retrieval (when needed)

#else

        /* For now (to test things) we eagerly suck everything */

        MetaDataImp     cimp;

        for (cimp = MDcomp->cmpMDlist; cimp; cimp = cimp->MDnext)
        {
            if  (cimp->MDwmdi == wmdi)
                break;
        }

        if  (!cimp)
        {
            cimp = MDcomp->cmpAddMDentry();
            cimp->MDinit(wmdi, MDcomp, MDstab);
        }

        clsSym = cimp->MDimportClss(clsd, NULL, 0, false);

#endif

    }

GOT_CLS:

    clsTyp = clsSym->sdTypeGet();

    if  (clsSym->sdSymKind == SYM_CLASS)
    {
        assert(clsTyp->tdTypeKind == TYP_CLASS);

        /* Check for some "known" classes */

        if  ((hashTab::getIdentFlags(clsSym->sdName) & IDF_PREDEF) &&
             clsSym->sdParent == MDcomp->cmpNmSpcSystem)
        {
            MDcomp->cmpMarkStdType(clsSym);
        }

        /* Is this an intrinsic type "in disguise" ? */

        vtyp = (var_types)clsTyp->tdClass.tdcIntrType;

        if  (vtyp != TYP_UNDEF)
            clsTyp = MDstab->stIntrinsicType(vtyp);
    }
    else
    {
        clsTyp->tdEnum.tdeIntType = MDstab->stIntrinsicType(TYP_INT);
    }

    return clsTyp;
}

/*****************************************************************************
 *
 *  The following maps a metadata type onto our own var_types value.
 */

static
BYTE                CORtypeToSMCtype[] =
{
    TYP_UNDEF,  // ELEMENT_TYPE_END
    TYP_VOID,   // ELEMENT_TYPE_VOID
    TYP_BOOL,   // ELEMENT_TYPE_BOOLEAN
    TYP_WCHAR,  // ELEMENT_TYPE_CHAR
    TYP_CHAR,   // ELEMENT_TYPE_I1
    TYP_UCHAR,  // ELEMENT_TYPE_U1
    TYP_SHORT,  // ELEMENT_TYPE_I2
    TYP_USHORT, // ELEMENT_TYPE_U2
    TYP_INT,    // ELEMENT_TYPE_I4
    TYP_UINT,   // ELEMENT_TYPE_U4
    TYP_LONG,   // ELEMENT_TYPE_I8
    TYP_ULONG,  // ELEMENT_TYPE_U8
    TYP_FLOAT,  // ELEMENT_TYPE_R4
    TYP_DOUBLE, // ELEMENT_TYPE_R8
};

/*****************************************************************************
 *
 *  Import and convert a single type from COM99 metadata.
 */

TypDef              metadataImp::MDimportType(MDsigImport *sig)
{
    CorElementType  etp = sig->MDSIreadETP();

    if      (etp < sizeof(CORtypeToSMCtype)/sizeof(CORtypeToSMCtype[0]))
    {
        return  MDstab->stIntrinsicType((var_types)CORtypeToSMCtype[etp]);
    }
    else if (etp & ELEMENT_TYPE_MODIFIER)
    {
        switch (etp)
        {
        case ELEMENT_TYPE_SENTINEL:
            UNIMPL(!"modified type");
        }
    }
    else
    {
//      printf("etp = %u\n", etp); fflush(stdout); DebugBreak();

        switch (etp)
        {
            TypDef          type;
            DimDef          dims;
            DimDef          dlst;
            unsigned        dcnt;


        case ELEMENT_TYPE_CLASS:
            return  MDimportClsr(sig->MDSIreadTok(), false)->tdClass.tdcRefTyp;

        case ELEMENT_TYPE_VALUETYPE:
            return  MDimportClsr(sig->MDSIreadTok(),  true);

        case ELEMENT_TYPE_SZARRAY:

            /* Read the element type */

            type = MDimportType(sig);

            /* Create the dimension descriptor */

            dims = MDstab->stNewDimDesc(0);

            /* Create and return the array type */

            return  MDstab->stNewArrType(dims, true, type);

        case ELEMENT_TYPE_BYREF:

            /* Read the element type */

            type = MDimportType(sig);

            /* Create and return the ref type */

            return  MDstab->stNewRefType(TYP_REF, type);

        case ELEMENT_TYPE_PTR:

            /* Read the element type */

            type = MDimportType(sig);

            /* Create and return the ptr type */

            return  MDstab->stNewRefType(TYP_PTR, type);

        case ELEMENT_TYPE_ARRAY:

            /* Read the element type */

            type = MDimportType(sig);

            /* Get the array rank */

            dcnt = sig->MDSIreadUI4();

            /* Create the dimension descriptor */

            dims = NULL;
            while (dcnt--)
            {
                DimDef      last = dims;

                dims         = MDstab->stNewDimDesc(0);
                dims->ddNext = last;
            }

            /* Get the number of dimensions given */

            dcnt = sig->MDSIreadUI4();
            dlst = dims;
            while (dcnt--)
            {
                dlst->ddIsConst = true;
                dlst->ddNoDim   = false;
                dlst->ddSize    = sig->MDSIreadI4();

                dlst = dlst->ddNext;
            }

            /* Get the number of lower bounds given */

            dcnt = sig->MDSIreadUI4();
            dlst = dims;
            while (dcnt--)
            {
                int             lb = sig->MDSIreadI4();

                if  (lb)
                {
                    UNIMPL("need to save array lower-bound");
                }

                dlst = dlst->ddNext;
            }

            /* Create and return the array type */

            return  MDstab->stNewArrType(dims, true, type);

        case ELEMENT_TYPE_OBJECT:
            return  MDcomp->cmpObjectRef();

        case ELEMENT_TYPE_STRING:
            return  MDcomp->cmpStringRef();

        case ELEMENT_TYPE_TYPEDBYREF:
            return  MDstab->stIntrinsicType(TYP_REFANY);

        case ELEMENT_TYPE_I:
            return  MDstab->stIntrinsicType(TYP_NATINT);

        case ELEMENT_TYPE_U:
            return  MDstab->stIntrinsicType(TYP_NATUINT);

        case ELEMENT_TYPE_CMOD_OPT:
            sig->MDSIreadTok();         // ISSUE: warning???
            return  MDimportType(sig);

        case ELEMENT_TYPE_CMOD_REQD:
            MDundefCount++;
            sig->MDSIreadTok();
            return  MDimportType(sig);
//          return  MDstab->stIntrinsicType(TYP_UNDEF);

        default:
#ifdef  DEBUG
            printf("COR type value = %u = 0x%02X\n", etp, etp);
#endif
            UNIMPL(!"unexpected COR type");
        }
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Hash the given unicode name.
 */

Ident               metadataImp::MDhashWideName(WCHAR *name)
{
    char            buff[256];

    assert(wcslen(name) < sizeof(buff));

    wcstombs(buff, name, sizeof(buff)-1);

    return  MDcomp->cmpGlobalHT->hashString(buff);
}

/*****************************************************************************
 *
 *  Convert a fully qualified namespace or class name to its corresponding
 *  entry in the global symbol table (adding it if it isn't already there
 *  when 'add' is true, returning NULL when called with 'add' set to false).
 */

SymDef              metadataImp::MDparseDotted(WCHAR *name, symbolKinds kind,
                                                             bool      * added)
{
    symbolKinds     ckind  = SYM_NAMESPACE;
    SymDef          scope  = MDcomp->cmpGlobalNS;
    SymTab          symtab = MDstab;

//  printf("Declare NS sym '%ls'\n", name);

    *added = false;

    for (;;)
    {
        SymDef          newScp;
        WCHAR   *       delim;
        Ident           iden;
        bool            last;

        /* Find the next delimiter (if any) */

        delim = wcschr(name, '.');
        if  (delim)
        {
            *delim = 0;

            last = false;
        }
        else
        {
            // nested class names are mangled!

            delim = wcschr(name, '$');

            if  (delim)
            {
                *delim = 0;

                last  = false;
                ckind = SYM_CLASS;
            }
            else
            {
                last  = true;
                ckind = kind;
            }
        }

        /* Look for an existing namespace entry */

        iden = MDhashWideName(name);

        if  (scope->sdSymKind == SYM_CLASS)
            newScp = symtab->stLookupScpSym(iden,          scope);
        else
            newScp = symtab->stLookupNspSym(iden, NS_NORM, scope);

        if  (newScp)
        {
            /* Symbol already exists, make sure it's the right kind */

            if  (newScp->sdSymKindGet() != ckind)
            {
                if  (newScp->sdSymKind == SYM_ENUM && ckind == SYM_CLASS)
                {
                }
                else
                {
                    /* This is not legal, issue an error message or something? */

                    UNIMPL(!"redef of symbol in metadata, now what?");
                }
            }
        }
        else
        {
            /* Symbol not known yet, define a new symbol */

            newScp = symtab->stDeclareSym(iden, ckind, NS_NORM, scope);

            /* Tell the caller about what we've done */

            *added = true;

            /* Is this a namespace symbol? */

            if      (ckind == SYM_NAMESPACE)
            {
                /* Record which symbol table the namespace uses */

                newScp->sdNS.sdnSymtab = symtab;
            }
            else if (ckind == SYM_CLASS)
            {
                /* Well, we don't really know anything at all about this class */

                newScp->sdCompileState = CS_NONE;
            }
        }

        scope = newScp;

        /* Done if no more delimiters are present */

        if  (!delim)
            break;

        /* Continue with the character that follows the delimiter */

        name = delim + 1;
    }

    return  scope;
}

/*****************************************************************************
 *
 *  Map a set of MD type / member attributes to an access level.
 */

accessLevels        metadataImp::MDgetAccessLvl(unsigned attrs)
{
    assert(fdFieldAccessMask == mdMemberAccessMask);
    assert(fdPublic          == mdPublic);
    assert(fdPrivate         == mdPrivate);
    assert(fdFamily          == mdFamily);

    switch (attrs & fdFieldAccessMask)
    {
    case fdPublic : return ACL_PUBLIC;
    case fdPrivate: return ACL_PRIVATE;
    case fdFamily : return ACL_PROTECTED;
    default:        return ACL_DEFAULT;
    }
}

/*****************************************************************************
 *
 *  Check for any custom attributes attached to the given symbol.
 */

void                metadataImp::MDchk4CustomAttrs(SymDef sym, mdToken tok)
{
    HCORENUM        attrEnum = NULL;

    /* Are there any custom attributes at all ? */

    if  (!FAILED(MDwmdi->EnumCustomAttributes(&attrEnum, tok, 0, NULL, 0, NULL)) && attrEnum)
    {
        ULONG           attrCnt;

        if  (!FAILED(MDwmdi->CountEnum(attrEnum, &attrCnt)) && attrCnt)
        {
            /* Check for interesting custom values */

            MDwmdi->CloseEnum(attrEnum); attrEnum = NULL;

            for (;;)
            {
                mdToken         attrTok;
                mdToken         attrRef;
                mdToken         methTok;

                const void    * attrValAddr;
                ULONG           attrValSize;

                if  (MDwmdi->EnumCustomAttributes(&attrEnum,
                                                  tok,
                                                  0,
                                                  &attrTok,
                                                  1,
                                                  &attrCnt))
                    break;

                if  (!attrCnt)
                    break;

                if  (MDwmdi->GetCustomAttributeProps(attrTok,
                                                     NULL,
                                                     &attrRef,
                                                     &attrValAddr,
                                                     &attrValSize))
                    break;

                /* Check for an attribute we've seen before */

                methTok = 0;

            AGAIN:

                switch (TypeFromToken(attrRef))
                {
                    DWORD           typeFlag;
                    mdToken         scope;

                    WCHAR           symName[MAX_PACKAGE_NAME];

                case mdtTypeRef:

                    if  (attrRef == MDclsRefObsolete)
                    {
                        sym->sdIsDeprecated = true;
                        break;
                    }

                    if  (attrRef == MDclsRefAttribute)
                        goto GOT_ATTR;


                    if  (FAILED(MDwmdi->GetTypeRefProps(attrRef, 0,
                                                        symName, arraylen(symName), NULL)))
                    {
                        break;
                    }

#if 0
                    if  (methTok)
                        printf("Custom attribute (mem): '%ls::ctor'\n", symName);
                    else
                        printf("Custom attribute (ref): '%ls'\n"      , symName);
#endif

                    goto GOT_NAME;

                case mdtTypeDef:

                    if  (attrRef == MDclsDefObsolete)
                    {
                        sym->sdIsDeprecated = true;
                        break;
                    }

                    if  (attrRef == MDclsDefAttribute)
                        goto GOT_ATTR;


                    if  (FAILED(MDwmdi->GetTypeDefProps(attrRef,
                                                        symName, arraylen(symName), NULL,
                                                        &typeFlag, NULL)))
                    {
                        MDcomp->cmpFatal(ERRreadMD);
                    }

                    /* Forget it if the type is a nested class */

                    if  ((typeFlag & tdVisibilityMask) >= tdNestedPublic &&
                         (typeFlag & tdVisibilityMask) <= tdNestedFamORAssem)
                    {
                        break;
                    }

#if 0
                    if  (methTok)
                        printf("Custom attribute (mem): '%ls::ctor'\n", symName);
                    else
                        printf("Custom attribute (def): '%ls'\n"      , symName);
#endif

                GOT_NAME:

                    if  (wcsncmp(symName, L"System.Reflection.", 18))
                        break;

                    if  (wcscmp(symName+18, L"ObsoleteAttribute") == 0)
                    {
                        sym->sdIsDeprecated = true;

                        if  (TypeFromToken(attrRef) == mdtTypeRef)
                            MDclsDefObsolete  = attrRef;
                        else
                            MDclsDefObsolete  = attrRef;

                        break;
                    }


                    if  (wcscmp(symName+18, L"Attribute") == 0)
                    {
                        const void *    blobAddr;
                        ULONG           blobSize;

                        if  (TypeFromToken(attrRef) == mdtTypeRef)
                            MDclsDefAttribute = attrRef;
                        else
                            MDclsDefAttribute = attrRef;

                    GOT_ATTR:

//                      printf("Class '%s' has Attribute [%08X]\n", sym->sdSpelling());

                        /* Ignore if it's not a ctor-ref or we don't have a class */

                        if  (!methTok)
                            break;

                        if  (sym->sdSymKind != SYM_CLASS)
                            break;

                        if  (MDwmdi->GetCustomAttributeProps(attrTok, NULL, NULL, &blobAddr,
                                                                                  &blobSize))
                            break;

                        sym->sdClass.sdcAttribute = true;

                        switch (blobSize)
                        {
                        case 6:

                            /* No argument at all, this must be "Attribute" itself */

                            break;

                        case 8:

                            if  (TypeFromToken(methTok) == mdtMemberRef)
                                MDctrRefAttribute1 = methTok;
                            else
                                MDctrDefAttribute1 = methTok;

                            break;

                        case 9:

                            if  (TypeFromToken(methTok) == mdtMemberRef)
                                MDctrRefAttribute2 = methTok;
                            else
                                MDctrDefAttribute2 = methTok;

                            if  (((BYTE*)blobAddr)[6] != 0)
                                sym->sdClass.sdcAttrDupOK = true;

                            break;

                        case 10:

                            if  (TypeFromToken(methTok) == mdtMemberRef)
                                MDctrRefAttribute3 = methTok;
                            else
                                MDctrDefAttribute3 = methTok;

                            if  (((BYTE*)blobAddr)[6] != 0)
                                sym->sdClass.sdcAttrDupOK = true;

                            break;

                        default:
                            printf("WARNING: unexpected custom attribute blob size %u\n", blobSize);
                            break;
                        }
                        break;
                    }

                    break;

                case mdtMemberRef:

                                        methTok = attrRef;

                    if  (attrRef == MDctrRefAttribute1)
                        goto GOT_ATTR;
                    if  (attrRef == MDctrRefAttribute2)
                        goto GOT_ATTR;
                    if  (attrRef == MDctrRefAttribute3)
                        goto GOT_ATTR;

                    if  (FAILED(MDwmdi->GetMemberRefProps(attrRef,
                                                         &scope,
                                                          symName, arraylen(symName), NULL,
                                                          NULL, NULL)))
                    {
                        break;
                    }

                GOT_METH:

                    /* The method better be a constructor */

                    if  (wcscmp(symName, L".ctor"))     // NOTE: s/b OVOP_STR_CTOR_INST
                        break;

                    attrRef = scope;
                    goto AGAIN;

                case mdtMethodDef:

                                        methTok = attrRef;

                    if  (attrRef == MDctrDefAttribute1)
                        goto GOT_ATTR;
                    if  (attrRef == MDctrDefAttribute2)
                        goto GOT_ATTR;
                    if  (attrRef == MDctrDefAttribute3)
                        goto GOT_ATTR;

                    if  (FAILED(MDwmdi->GetMethodProps   (attrRef,
                                                         &scope,
                                                          symName, arraylen(symName), NULL,
                                                          NULL,
                                                          NULL, NULL,
                                                          NULL,
                                                          NULL)))
                    {
                        break;
                    }

                    goto GOT_METH;

                default:
                    printf("Found custom attribute: ?token? = %08X\n", attrRef);
                    break;
                }
            }
        }

        MDwmdi->CloseEnum(attrEnum);
    }
}

/*****************************************************************************
 *
 *  Import and convert an argument list from COM99 metadata.
 */

ArgDef              metadataImp::MDimportArgs(MDsigImport * sig,
                                              unsigned      cnt,
                                              MDargImport  *state)
{
    TypDef          argType;
    Ident           argName;
    ArgDef          argDesc;
    ArgDef          argNext;
    size_t          argDsiz;

    unsigned        argFlags = 0;
//  constVal        argDef;

    /* Is this a "byref" argument? */

    if  (sig->MDSIpeekUI1() == ELEMENT_TYPE_BYREF)
    {
         sig->MDSIreadUI1();

        argFlags = ARGF_MODE_INOUT;

        state->MDaiExtArgDef = true;
    }

    /* Do we have a functioning parameter enumerator? */

    if  (state->MDaiParamEnum)
    {
        const   char *  paramName;
        ULONG           paramNlen;
        ULONG           paramAttr;
        ULONG           cppFlags;

        const   void *  defVal;
        ULONG           cbDefVal;
//      VARIANT         defValue;

        ULONG           paramCnt = 0;

        /* Get the info about the current parameter */

        if  (MDwmdi->GetNameFromToken(state->MDaiNparamTok,
                                      &paramName)
                         ||
             MDwmdi->GetParamProps   (state->MDaiNparamTok,
                                      NULL,
                                      NULL,
//                                    paramName, sizeof(paramName)/sizeof(paramName[0]),
                                      NULL, 0,
                                      &paramNlen,
                                      &paramAttr,
                                      &cppFlags,
                                      &defVal,
                                      &cbDefVal))
        {
            /* Couldn't get parameter info for some reason ... */

            MDwmdi->CloseEnum(state->MDaiParamEnum); state->MDaiParamEnum = NULL;
        }

        /* Hash the argument name */

        argName = MDcomp->cmpGlobalHT->hashString(paramName);

        /* Is this an "out" argument? */

#if 0

        if  (paramAttr & pdOut)
        {
            argFlags |= (paramAttr & pdIn) ? ARGF_MODE_INOUT
                                           : ARGF_MODE_OUT;

            state->MDaiExtArgDef = true;
        }

#endif

        // UNDONE: Grab argument default value, and whatever else we need ....

        /* Advance to the next argument */

        if  (MDwmdi->EnumParams(&state->MDaiParamEnum,
                                 state->MDaiMethodTok,
                                &state->MDaiNparamTok,
                                1,
                                &paramCnt) || paramCnt != 1)
        {
            /* Couldn't get parameter info for some reason ... */

            MDwmdi->CloseEnum(state->MDaiParamEnum); state->MDaiParamEnum = NULL;
        }
    }
    else
    {
        argName = NULL; assert(sig->MDSIpeekUI1() != ELEMENT_TYPE_BYREF);
    }

    /* Extract the argument type from the signature */

    argType = MDimportType(sig);

    /* Is this the last argument? */

    if  (cnt > 1)
    {
        /* Recursively import the rest of the arguments */

        argNext = MDimportArgs(sig, cnt - 1, state);
    }
    else
    {
        /* No more arguments to import */

        argNext = NULL;
    }

    /* Allocate an argument entry */

    argDsiz = state->MDaiExtArgDef ? sizeof(ArgExtRec)
                                   : sizeof(ArgDefRec);

#if MGDDATA
    argDesc = new ArgDef;
#else
    argDesc =    (ArgDef)MDcomp->cmpAllocPerm.nraAlloc(argDsiz);
#endif

    /* Record the argument type and name */

    argDesc->adType  = argType;
    argDesc->adName  = argName;
    argDesc->adNext  = argNext;

#ifdef  DEBUG
    argDesc->adIsExt = state->MDaiExtArgDef;
#endif

    /* Fill in any extra info if we're creating extended descriptors */

    if  (state->MDaiExtArgDef)
    {
        ArgExt          argXdsc = (ArgExt)argDesc;

//      argXdsc->adDefVal = argDef;
        argXdsc->adFlags  = argFlags;
    }
    else
    {
        assert(argFlags == 0);
    }

    return  argDesc;
}

/*****************************************************************************
 *
 *  Import and convert information about a field/method from COM99 metadata.
 */

SymDef              metadataImp::MDimportMem(SymDef          scope,
                                             Ident           memName,
                                             mdToken         memTok,
                                             unsigned        attrs,
                                             bool            isProp,
                                             bool            fileScope,
                                             PCCOR_SIGNATURE sigAddr,
                                             size_t          sigSize)
{
    SymDef          memSym;
    MDsigImport     memSig;
    TypDef          memType;

    unsigned        sdfCtor;
    bool            sdfProp;

    BYTE            call;

    unsigned        MDundefStart;

    /* Start reading from the signature string */

    memSig.MDSIinit(MDcomp, MDstab, sigAddr, sigSize);

    /* Track constructor/property accessor state for methods */

    sdfCtor = sdfProp = false;

#if 0

    printf("Importing member [%04X] '%s.%s'\n", attrs, scope->sdSpelling(), memName->idSpelling());

#if 0
    if  (sigAddr)
    {
        BYTE    *       sig = (BYTE*)sigAddr;

        printf("    Signature:");

        while (sig < sigAddr+sigSize)
            printf(" 0x%02X", *sig++);

        printf("\n");

        fflush(stdout);
    }
#endif

#endif

    /* Get the calling convention byte */

    call = memSig.MDSIreadUI1();

    /* We need to notice members that references unrecognized metadata */

    MDundefStart = MDundefCount;

    /* Do we have a field or a method? */

    if  ((call & IMAGE_CEE_CS_CALLCONV_MASK) == IMAGE_CEE_CS_CALLCONV_FIELD)
    {
        /* Import/convert the member's type */

        memType = MDimportType(&memSig);

        /* Declare the member symbol */

        if  (scope->sdSymKind == SYM_ENUM)
        {
            if  (!(attrs & fdStatic))
            {
                /* This must be the fake enum type instance member */

                scope->sdType->tdEnum.tdeIntType = memType;

                return  NULL;
            }

            memSym  = MDstab->stDeclareSym(memName,          SYM_ENUMVAL       , NS_NORM, scope);
        }
        else
        {
            memSym  = MDstab->stDeclareSym(memName, isProp ? SYM_PROP : SYM_VAR, NS_NORM, scope);

            /* Record any other interesting attributes */

            if  (attrs & fdInitOnly    ) memSym->sdIsSealed     = true;
//          if  (attrs & fdVolatile    ) memSym->memIsVolatile  = true;
//          if  (attrs & fdTransient   ) memSym->memIsTransient = true;

            /* Record the member's token */

            memSym->sdVar.sdvMDtoken = memTok;
        }

        /* For globals we record the importer index */

        if  (fileScope)
        {
            memSym->sdVar.sdvImpIndex = MDnum;

//          printf("Importer %2u originated '%s'\n", MDnum, MDstab->stTypeName(NULL, memSym, NULL, NULL, true));

            /* Make sure the index fit in the [bit]field */

            assert(memSym->sdVar.sdvImpIndex == MDnum);
        }
    }
    else
    {
        ULONG           argCnt;
        TypDef          retType;
        ArgDscRec       argDesc;
        SymDef          oldSym;

        ovlOpFlavors    ovlop  = OVOP_NONE;

        bool            argExt = false;

        /* Get the argument count */

        argCnt  = memSig.MDSIreadUI4();

        /* Get the return type */

        retType = MDimportType(&memSig);

        /* Munge the name if it's a ctor or operator */

        if  ((attrs & mdSpecialName) && !isProp)
        {
            stringBuff      memNstr = memName->idSpelling();

            /* Is this an instance or static constructor? */

            if  (!strcmp(memNstr, OVOP_STR_CTOR_INST))
            {
                assert((attrs & mdStatic) == 0);
                ovlop   = OVOP_CTOR_INST;
                sdfCtor = true;
                goto DONE_OVLOP;
            }

            if  (!strcmp(memNstr, OVOP_STR_CTOR_STAT))
            {
                assert((attrs & mdStatic) != 0);
                ovlop   = OVOP_CTOR_STAT;
                sdfCtor = true;
                goto DONE_OVLOP;
            }

            assert(MDcomp->cmpConfig.ccNewMDnames);

            ovlop = MDname2ovop(memNstr);

            if  (ovlop == OVOP_NONE)
            {
                /* This better be a property accessor method, right? */

                if  (memcmp(memNstr, "get_", 4) && memcmp(memNstr, "set_", 4))
                {
#ifdef  DEBUG
                    if  (!strchr(memNstr, '.'))
                    {
                        // Some new magic thing ...

                        if  (memcmp(memNstr, "add_", 4) && memcmp(memNstr, "remove_", 7))
                            printf("WARNING: Strange 'specialname' method '%s' found in '%s'\n", memNstr, scope->sdSpelling());
                    }
#endif
                }
                else
                {
                    sdfProp = true;
                }
            }
        }

    DONE_OVLOP:

        /* Get the argument list, if present */

#if MGDDATA
        argDesc = new ArgDscRec;
#else
        memset(&argDesc, 0, sizeof(argDesc));
#endif

        if  (argCnt)
        {
            MDargImport     paramState;
            ULONG           paramCnt  = 0;

            /* Start the parameter enumerator */

            paramState.MDaiParamEnum = NULL;
            paramState.MDaiExtArgDef = argExt;
            paramState.MDaiMethodTok = memTok;

            if  (MDwmdi->EnumParams(&paramState.MDaiParamEnum,
                                    memTok,
                                    &paramState.MDaiNparamTok,
                                    1,
                                    &paramCnt) || paramCnt != 1)
            {
                /* Couldn't get parameter info for some reason ... */

                MDwmdi->CloseEnum(paramState.MDaiParamEnum); paramState.MDaiParamEnum = NULL;
            }

            /* Recursively import the argument list */

            argDesc.adCount  = argCnt;
            argDesc.adArgs   = MDimportArgs(&memSig, argCnt, &paramState);

            /* Close the argument enumerator */

            MDwmdi->CloseEnum(paramState.MDaiParamEnum);

            /* Remember whether we have extended argument descriptors */

            argExt = paramState.MDaiExtArgDef;
        }
        else
            argDesc.adArgs   = NULL;

        /* Fill in the argument descriptor */

        argDesc.adCount   = argCnt;
        argDesc.adExtRec  = argExt;
        argDesc.adVarArgs = false;

        /* Figure out the calling convention */

        switch (call & IMAGE_CEE_CS_CALLCONV_MASK)
        {
        case IMAGE_CEE_CS_CALLCONV_DEFAULT:
        case IMAGE_CEE_CS_CALLCONV_STDCALL:
        case IMAGE_CEE_CS_CALLCONV_THISCALL:
        case IMAGE_CEE_CS_CALLCONV_FASTCALL:
            break;

        case IMAGE_CEE_CS_CALLCONV_VARARG:
            argDesc.adVarArgs = true;
        case IMAGE_CEE_CS_CALLCONV_C:
            break;
        }

        /* Create the function type */

        memType = MDstab->stNewFncType(argDesc, retType);

        /* Look for an existing symbol with a matching name */

        if (isProp)
        {
            oldSym = MDstab->stLookupProp(memName, scope);
            if  (oldSym)
            {
                /* Check for a redefinition of an earlier property */

                memSym = MDstab->stFindSameProp(oldSym, memType);
                if  (memSym)
                {
                    UNIMPL(!"redefined property in metadata - now what?");
                }

                /* The new property is a new overload */

                memSym = MDstab->stDeclareOvl(oldSym);
            }
            else
            {
                memSym = MDstab->stDeclareSym(memName, SYM_PROP, NS_NORM, scope);
            }

            memSym->sdCompileState = CS_DECLARED;

            /* Record any other interesting attributes */

//          if  (attrs & prFinal   ) memSym->sdIsSealed   = true;
//          if  (attrs & prAbstract) memSym->sdIsAbstract = true;

            memSym->sdAccessLevel = ACL_PUBLIC;

            /* The property is static if there is no "this" pointer */

            if  (!(call & IMAGE_CEE_CS_CALLCONV_HASTHIS))
                memSym->sdIsStatic = true;

            goto DONE_SIG;
        }

        if  (fileScope)
        {
            assert(ovlop == OVOP_NONE);

            oldSym = MDstab->stLookupNspSym(memName, NS_NORM, scope);
        }
        else if (ovlop == OVOP_NONE)
        {
            oldSym = MDstab->stLookupClsSym(memName,          scope);
        }
        else
        {
            oldSym = MDstab->stLookupOper  (ovlop,            scope);
        }

        /* Is this an overload of an existing method? */

        if  (oldSym)
        {
            if  (oldSym->sdSymKind != SYM_FNC)
            {
                UNIMPL(!"fncs and vars can't overload, right?");
            }

            /* Look for a function with a matching arglist */

            memSym = MDstab->stFindOvlFnc(oldSym, memType);

            if  (memSym)
            {
#ifdef  DEBUG
                SymDef newSym = MDstab->stDeclareOvl(memSym); newSym->sdType = memType;
                printf("Old overload: '%s'\n", MDstab->stTypeName(NULL, memSym, NULL, NULL, true));
                printf("New overload: '%s'\n", MDstab->stTypeName(NULL, newSym, NULL, NULL, true));
#endif
                UNIMPL(!"duplicate method found, what to do?");
            }

            /* It's a new overload, declare a symbol for it */

            memSym = MDstab->stDeclareOvl(oldSym);
        }
        else
        {
            /* This is a brand new function */

            if  (ovlop == OVOP_NONE)
                memSym = MDstab->stDeclareSym (memName, SYM_FNC, NS_NORM, scope);
            else
                memSym = MDstab->stDeclareOper(ovlop, scope);
        }

        /* Record the member's token */

        memSym->sdFnc.sdfMDtoken = memTok;
        memSym->sdFnc.sdfMDfnref = 0;


        /* Record whether the method is a constructor */

        memSym->sdFnc.sdfCtor     = sdfCtor;

        /* Record whether the method is a property accessor */

        memSym->sdFnc.sdfProperty = sdfProp;

        /* Record any other interesting attributes */

        if  (attrs & mdFinal       ) memSym->sdIsSealed         = true;
        if  (attrs & mdAbstract    ) memSym->sdIsAbstract       = true;

//      if  (attrs & mdAgile       ) memSym->                   = true;
//      if  (attrs & mdNotRemotable) memSym->                   = true;
//      if  (attrs & mdSynchronized) memSym->sdFnc.sdfExclusive = true;

        /* Some crazy compilers mark ctors as virtual */

        if  (attrs & mdVirtual)
            if  (!sdfCtor)           memSym->sdFnc.sdfVirtual = true;

        /* For globals we record the importer index */

        if  (fileScope)
        {
            memSym->sdFnc.sdfImpIndex = MDnum;

//          printf("Importer %2u originated '%s'\n", MDnum, MDstab->stTypeName(NULL, memSym, NULL, NULL, true));

            /* Make sure the index fit in the [bit]field */

            assert(memSym->sdFnc.sdfImpIndex == MDnum);
        }
    }

    /* Figure out and record the member's access level */

    memSym->sdAccessLevel = MDgetAccessLvl(attrs);

DONE_SIG:

    /* The member signature should have been consumed by now */

    memSig.MDSIchkEnd();

    /* Remember that the member is an import */

    memSym->sdIsImport = true;

    /* Remember whether this is a member or a global variable/function */

    memSym->sdIsMember = !fileScope;

    /* Record the member's type */

    memSym->sdType     = memType;

    /* Record other tidbits of information about the member */

    assert(fdStatic == mdStatic);

    if  (attrs & fdStatic)
        memSym->sdIsStatic = true;

//  if  (MDwmdi->GetCustomAttributeByName(memTok,                   L"Deprecated", NULL, NULL) == S_OK)
//      memSym->sdIsDeprecated = true;
//  if  (MDwmdi->GetCustomAttributeByName(memTok, L"System.Attributes.Deprecated", NULL, NULL) == S_OK)
//      memSym->sdIsDeprecated = true;
//  if  (MDwmdi->GetCustomAttributeByName(memTok,     L"System.ObsoleteAttribute", NULL, NULL) == S_OK)
//      memSym->sdIsDeprecated = true;

    MDchk4CustomAttrs(memSym, memTok);

    /* Did the member use unrecognized metadata? */

    if  (MDundefStart != MDundefCount)
    {
#if 0
        memSym->sdNameSpace = (name_space)(memSym->sdNameSpace & ~(NS_NORM|NS_TYPE));
#else
        MDcomp->cmpErrorQnm(ERRunknownMD, memSym);
        memSym->sdType      = MDstab->stIntrinsicType(TYP_UNDEF);
#endif

        MDundefCount = MDundefStart;
    }

    return memSym;
}

/*****************************************************************************
 *
 *  Find the property accessor method that corresponds to the given property.
 */

SymDef              metadataImp::MDfindPropMF(SymDef    propSym,
                                              mdToken   methTok,
                                              bool      getter)
{
    Ident           mfnName = MDcomp->cmpPropertyName(propSym->sdName, getter);
    SymDef          mfnSym  = MDstab->stLookupClsSym(mfnName, propSym->sdParent);

    if  (mfnSym)
    {
        do
        {
            if  (mfnSym->sdFnc.sdfMDtoken == methTok)
                return  mfnSym;

            mfnSym = mfnSym->sdFnc.sdfNextOvl;
        }
        while (mfnSym);
    }

    /* The creator of this DLL probably used different naming conventions */

    for (mfnSym = propSym->sdParent->sdScope.sdScope.sdsChildList;
         mfnSym;
         mfnSym = mfnSym->sdNextInScope)
    {
        SymDef          ovlSym;

        if (mfnSym->sdSymKind != SYM_FNC)
            continue;

        ovlSym = mfnSym;
        do
        {
            if  (ovlSym->sdFnc.sdfMDtoken == methTok)
                return  ovlSym;

            ovlSym = ovlSym->sdFnc.sdfNextOvl;
        }
        while (ovlSym);
    }
#ifdef  DEBUG
    printf("Could not find accessor for %s [%08X]\n", propSym->sdSpelling(), methTok);
#endif

    return  NULL;
}

/*****************************************************************************
 *
 *  Import metadata for a single class.
 */

SymDef              metadataImp::MDimportClss(mdTypeDef td,
                                              SymDef    clsSym,
                                              unsigned  assx, bool deep)
{
    WMetaDataImport*wmdi = MDwmdi;

    bool            fileScope;

    TypDef          clsTyp;
    str_flavors     clsKind;
    Ident           clsIden;

    WCHAR           scpName[MAX_CLASS_NAME];
//  WCHAR           clsName[MAX_CLASS_NAME];

    DWORD           typeFlg;

    mdTypeRef       baseTok;

    /* Do we already have a class symbol? */

    if  (clsSym)
    {
        /* Presumably we're importing the members of the class/enum */

        assert(td == 0);
        assert(clsSym->sdSymKind == SYM_ENUM ||
               clsSym->sdSymKind == SYM_CLASS);
        assert(clsSym->sdIsImport);
        assert(clsSym->sdCompileState < CS_DECLARED);

        /* Get hold of the token for the class */

        td = (clsSym->sdSymKind == SYM_CLASS) ? clsSym->sdClass.sdcMDtypedef
                                              : clsSym->sdEnum .sdeMDtypedef;
    }

    if  (!td)
    {
        /* We're importing the global scope */

        fileScope = true;

#ifdef  DEBUG
        if  (MDcomp->cmpConfig.ccVerbose >= 4) printf("Import Filescope\n");
#endif

        /* We'll enter any symbols we find in the global namespace */

        clsSym = MDcomp->cmpGlobalNS;
    }
    else
    {
        unsigned        typContextVal;
        bool            typIsDelegate;
        bool            typIsStruct;
        bool            typIsEnum;

        char            nameTemp[MAX_CLASS_NAME];

        const   char *  clsName;
        SymDef          scopeSym;
        symbolKinds     symKind;
        accessLevels    clsAcc;

        fileScope = false;

        /* Ask for the details for the current typedef */

        if  (wmdi->GetNameFromToken(td, &clsName))
            MDcomp->cmpFatal(ERRreadMD);

        if  (wmdi->GetTypeDefProps(td,
                                   scpName, sizeof(scpName)/sizeof(scpName[0])-1, NULL,
                                   &typeFlg,
                                   &baseTok))
        {
            MDcomp->cmpFatal(ERRreadMD);
        }

        /*
            Sad thing: we have to resolve the base class (if any) to detect
            things such as structs and enums (no, I'm not making this up).
         */

        typContextVal = 0;
        typIsDelegate = false;
        typIsStruct   = false;
        typIsEnum     = false;

        if  (baseTok && baseTok != mdTypeRefNil)
        {
            char            nameBuff[MAX_CLASS_NAME];
            const   char *  typeName;

            if  (TypeFromToken(baseTok) == mdtTypeRef)
            {
                WCHAR           clsTypeName[MAX_CLASS_NAME];

                /* Get hold of the base class name */

                if  (MDwmdi->GetTypeRefProps(baseTok,
                                             0,
                                             clsTypeName,
                                             arraylen(clsTypeName),
                                             NULL))
                    goto NOT_HW_BASE;

                if  (wcsncmp(clsTypeName, L"System.", 7))
                    goto NOT_HW_BASE;

                /* Convert the class name to normal characters */

                wcstombs(nameBuff, clsTypeName+7, sizeof(nameBuff)-1);

                typeName = nameBuff;
            }
            else
            {
                SymDef          baseSym;

                /* Get hold the base class type */

                baseSym = MDimportClss(baseTok, NULL, 0, false);
                assert(baseSym && baseSym->sdSymKind == SYM_CLASS);

                /* Does the class belong to "System" ? */

                if  (baseSym->sdParent != MDcomp->cmpNmSpcSystem)
                    goto NOT_HW_BASE;

                /* Get hold of the class name */

                typeName = baseSym->sdSpelling();
            }

            if      (!strcmp(typeName,          "Delegate") ||
                     !strcmp(typeName, "MulticastDelegate"))
            {
                typIsDelegate = true;
            }
            else if (!strcmp(typeName, "ValueType"))
            {
                typIsStruct   = true;
            }
            else if (!strcmp(typeName, "Enum"))
            {
                typIsEnum     = true;
            }
            else if (!strcmp(typeName, "MarshalByRefObject"))
            {
                typContextVal = 1;
            }
            else if (!strcmp(typeName, "ContextBoundObject"))
            {
                typContextVal = 2;
            }
        }

    NOT_HW_BASE:

        // ISSUE:

        WCHAR       *   scpNameTmp = wcsrchr(scpName, '.');

        if  (scpNameTmp)
            *scpNameTmp = 0;
        else
            scpName[0] = 0;

#ifdef  DEBUG

        if  (MDcomp->cmpConfig.ccVerbose >= 4)
        {
            printf("Import [%08X] ", assx);

            if      (typIsEnum)
                printf("Enum      ");
            else if (typeFlg & tdInterface)
                printf("Interface ");
            else
                printf("Class     ");

            if  (scpName[0])
                printf("%ls.", scpName);

            printf("%s'\n", clsName);
        }

#endif

//      if  (!strcmp(clsName, "AttributeTargets")) printf("Import class '%s'\n", clsName);

        /* Is this a nested class ? */

        assert(tdNotPublic < tdPublic);

        if  ((typeFlg & tdVisibilityMask) > tdPublic)
        {
            mdTypeDef           outerTok;
            TypDef              outerCls;

            if  (wmdi->GetNestedClassProps(td, &outerTok))
                MDcomp->cmpFatal(ERRreadMD);

            // Ignore nesting if name is mangled !!!!!!!

            if  (!strchr(clsName, '$'))
            {
                /* Resolve the outer class token to a class symbol */

                outerCls = MDimportClsr(outerTok, false); assert(outerCls);
                scopeSym = outerCls->tdClass.tdcSymbol;

                goto GOT_SCP;
            }
        }

        /* Enter this class/interface in the global symbol table */

        if  (*scpName)
        {
            if  (wcscmp(MDprevNam, scpName))
            {
                bool            toss;

                /* The namespace has changed, enter it in the symbol table */

                wcscpy(MDprevNam, scpName);

                MDprevSym = MDparseDotted(scpName, SYM_NAMESPACE, &toss);
            }

            scopeSym = MDprevSym;
        }
        else
        {
            scopeSym = MDcomp->cmpGlobalNS;
        }

    GOT_SCP:

        /* Remember that the namespace contains import members */

        scopeSym->sdIsImport = true;

        /* Figure out what kind of a symbol we're dealing with */

        if  (typIsEnum)
        {
            symKind = SYM_ENUM;
        }
        else
        {
            symKind = SYM_CLASS;

            if      (typIsStruct)
                clsKind = STF_STRUCT;
            else if (typeFlg & tdInterface)
                clsKind = STF_INTF;
            else
                clsKind = STF_CLASS;
        }

        /* Figure out the access level of the class */

        switch (typeFlg & tdVisibilityMask)
        {
        case tdPublic:
        case tdNestedPublic:        clsAcc = ACL_PUBLIC   ; break;
        case tdNestedFamily:        clsAcc = ACL_PROTECTED; break;
        case tdNestedPrivate:       clsAcc = ACL_PRIVATE  ; break;

//      case tdNotPublic:
//      case tdNestedAssembly:
//      case tdNestedFamANDAssem:
//      case tdNestedFamORAssem:
        default:                    clsAcc = ACL_DEFAULT  ; break;
        }

        /* check for mangled nested class name */

        if  (strchr(clsName, '$') && *clsName != '$')
        {
            strcpy(nameTemp, clsName);

            for (clsName = nameTemp;;)
            {
                char *          dollar;
                SymDef          scpSym;

                dollar = strchr(clsName, '$');
                if  (!dollar)
                    break;

                *dollar = 0;

//              printf("Outer class name: '%s'\n", clsName);

                assert(*clsName);

                clsIden = MDcomp->cmpGlobalHT->hashString(clsName);

                if  (scopeSym->sdSymKind == SYM_CLASS)
                    scpSym  = MDstab->stLookupScpSym(clsIden,          scopeSym);
                else
                    scpSym  = MDstab->stLookupNspSym(clsIden, NS_NORM, scopeSym);

                if  (!scpSym)
                {
                    /* Outer class doesn't exist, declare it now */

                    scpSym = MDstab->stDeclareSym(clsIden, SYM_CLASS, NS_NORM, scopeSym);

                    /* Well, we don't really know anything at all about this class */

                    scpSym->sdCompileState = CS_NONE;
                }

                scopeSym = scpSym;
                clsName  = dollar + 1;
            }

//          printf("Final class name: '%s'\n", clsName);
        }

        clsIden = MDcomp->cmpGlobalHT->hashString(clsName);

        /* Note that the caller may have supplied the symbol */

        if  (!clsSym)
        {
            if  (scopeSym->sdSymKind == SYM_CLASS)
                clsSym = MDstab->stLookupScpSym(clsIden,          scopeSym);
            else
                clsSym = MDstab->stLookupNspSym(clsIden, NS_NORM, scopeSym);
        }

        if  (clsSym)
        {
            /* Symbol already exists, make sure it's the right kind */

            if  (clsSym->sdSymKindGet() != symKind)
            {
                /* Issue an error message or something? */

                UNIMPL(!"unexpected redef of class/enum symbol, now what?");
            }

            // ISSUE: We also need to check that (BYTE)clsSym->sdClass.sdcFlavor != (BYTE)clsKind), right?

            /* Bail if this type has already been imported */

            if  (clsSym->sdCompileState >= CS_DECLARED)
                return clsSym;

            clsTyp = clsSym->sdType;
            if  (clsTyp == NULL)
                goto DCL_CLS;

            if  (clsSym->sdCompileState == CS_NONE)
            {
                assert(clsTyp == NULL);
                goto DCL_CLS;
            }

            /* The access level of the type should agree, right? */

            assert(clsSym->sdAccessLevel == clsAcc || scopeSym->sdSymKind == SYM_CLASS);
        }
        else
        {
            /* Class not known yet, declare it */

            clsSym = MDstab->stDeclareSym(clsIden, symKind, NS_NORM, scopeSym);

        DCL_CLS:

            /* Assume everything is managed until proven otherwise */

            clsSym->sdIsManaged   = true;

            /* Check for any custom attributes on the type */

//          if  (MDwmdi->GetCustomAttributeByName(td,                   L"Deprecated", NULL, NULL) == S_OK)
//              clsSym->sdIsDeprecated = true;
//          if  (MDwmdi->GetCustomAttributeByName(td, L"System.Attributes.Deprecated", NULL, NULL) == S_OK)
//              clsSym->sdIsDeprecated = true;
//          if  (MDwmdi->GetCustomAttributeByName(td,     L"System.ObsoleteAttribute", NULL, NULL) == S_OK)
//              clsSym->sdIsDeprecated = true;

            MDchk4CustomAttrs(clsSym, td);

            /* Record the access level of the type */

            clsSym->sdAccessLevel = clsAcc;

            /* Create the class/enum type */

            if  (symKind == SYM_CLASS)
            {
                /* Record the "flavor" (i.e. class/struct/union) */

                clsSym->sdClass.sdcFlavor = clsKind;

                /* We can now create the class type */

                clsTyp = MDstab->stNewClsType(clsSym);

                /* Has explicit layout been specified for the class ? */

                if  ((typeFlg & tdLayoutMask) == tdExplicitLayout)
                {
                    DWORD           al;
                    ULONG           fc;
                    ULONG           sz;

//                  clsSym->sdIsManaged = false;

                    if  (wmdi->GetClassLayout(td, &al, NULL, 0, &fc, &sz))
                        MDcomp->cmpFatal(ERRreadMD);

//                  printf("Layout info [%u,%u] for class '%s'\n", sz, al, clsSym->sdSpelling());

                    clsTyp->tdClass.tdcSize       = sz;
                    clsTyp->tdClass.tdcAlignment  = MDcomp->cmpEncodeAlign(al);
                    clsTyp->tdClass.tdcLayoutDone = true;

#if 0

                    if  (fc)
                    {
                        COR_FIELD_OFFSET *  fldOffs;

                        COR_FIELD_OFFSET *  fldPtr;
                        unsigned            fldCnt;

                        printf("%3u field offset records for '%s'\n", fc, clsSym->sdSpelling());

                        fldOffs = new COR_FIELD_OFFSET[fc];

                        if  (wmdi->GetClassLayout(td, &al, fldOffs, fc, &fc, &sz))
                            MDcomp->cmpFatal(ERRreadMD);

                        for (fldCnt = fc, fldPtr = fldOffs;
                             fldCnt;
                             fldCnt--   , fldPtr++)
                        {
                            printf("    Field [rid=%08X,%s=%04X]\n", fldPtr->ridOfField,
                                                                     (typeFlg & tdExplicitLayout) ? "offs" : "seq#",
                                                                     fldPtr->ulOffset);
                        }

                        printf("\n");

                        delete [] fldOffs;
                    }

#endif

                }

                /* Remember whether this is a value type */

                if  (typIsStruct)
                {
                    clsTyp->tdClass.tdcValueType = true;
                }

                /* Check for a "known" class name */

                if  ((hashTab::getIdentFlags(clsIden) & IDF_PREDEF) &&
                     scopeSym == MDcomp->cmpNmSpcSystem)
                {
                    MDcomp->cmpMarkStdType(clsSym);
                }
            }
            else
            {
                clsSym->sdType = clsTyp = MDstab->stNewEnumType(clsSym);

                clsTyp->tdEnum.tdeIntType = MDstab->stIntrinsicType(TYP_INT);
            }

            /* The class/enum is now in a slightly better shape now */

            clsSym->sdCompileState = CS_KNOWN;
        }

#if 0
        if  (!strcmp(clsSym->sdSpelling(), "SystemException"))
            printf("Import type '%s'\n", clsSym->sdSpelling());
#endif

        /* Mark the type symbol as a metadata import */

        clsSym->sdIsImport            = true;
        clsSym->sdCompileState        = CS_KNOWN;

        /* Are we importing a class or emum ? */

        if  (symKind == SYM_CLASS)
        {
            /* Remember where the class type came from */

            clsSym->sdClass.sdcMDtypedef  = td;
            clsSym->sdClass.sdcMDtypeImp  = 0;
            clsSym->sdClass.sdcMDimporter = this;

            if  (typeFlg & tdAbstract)
                clsSym->sdIsAbstract = true;
            if  (typeFlg & tdSealed)
                clsSym->sdIsSealed   = true;

            /* Record the owning assembly (if we don't have one already) */

            if  (clsSym->sdClass.sdcAssemIndx == 0)
                 clsSym->sdClass.sdcAssemIndx = assx;

            /* Is the class a delegate ? */

            if  (typIsDelegate)
            {
                clsTyp = clsSym->sdType;

                assert(clsTyp && clsTyp->tdTypeKind == TYP_CLASS);

                clsTyp->tdClass.tdcFnPtrWrap = true;
                clsTyp->tdClass.tdcFlavor    =
                clsSym->sdClass.sdcFlavor    = STF_DELEGATE;
            }
        }
        else
        {
            clsSym->sdEnum .sdeMDtypedef  = td;
            clsSym->sdEnum .sdeMDtypeImp  = 0;
            clsSym->sdEnum .sdeMDimporter = this;

            /* Record the owning assembly (if we don't have one already) */

            if  (clsSym->sdEnum .sdeAssemIndx == 0)
                 clsSym->sdEnum .sdeAssemIndx = assx;
        }

        /* Are we supposed to suck the members of the class/enum ? */

        if  (!deep)
            return  clsSym;

        /* The class/enum type will be 'declared' shortly */

        clsSym->sdCompileState = CS_DECLARED;
        clsSym->sdIsDefined    = true;

        /* Skip the next part if we have an enum type */

        if  (symKind == SYM_ENUM)
        {
            clsSym->sdCompileState = CS_CNSEVALD;

            assert(clsTyp);
            assert(clsTyp->tdTypeKind == TYP_ENUM);

            goto SUCK_MEMS;
        }

        assert(symKind == SYM_CLASS);

        /* Get hold of the class type */

        clsTyp = clsSym->sdType; assert(clsTyp && clsTyp->tdTypeKind == TYP_CLASS);

        /* Recursively import the base class, if one is present */

        if  (baseTok && baseTok != mdTypeRefNil)
        {
            TypDef          baseTyp;

            if  (TypeFromToken(baseTok) == mdtTypeRef)
                baseTyp = MDimportClsr(baseTok, false);
            else
                baseTyp = MDimportClss(baseTok, NULL, 0, deep)->sdType;

            /* Record the base class */

            clsTyp->tdClass.tdcBase      = baseTyp;
            clsTyp->tdClass.tdcFnPtrWrap = baseTyp->tdClass.tdcFnPtrWrap;

            /* If the base class is "Delegate", so is this class */

            if  (baseTyp->tdClass.tdcFlavor == STF_DELEGATE)
            {
                clsTyp->tdClass.tdcFlavor =
                clsSym->sdClass.sdcFlavor = STF_DELEGATE;
            }
        }
        else
        {
            /* We set the base of all interfaces to "Object" */

            if  (clsTyp->tdClass.tdcFlavor == STF_INTF)
                clsTyp->tdClass.tdcBase = MDcomp->cmpClassObject->sdType;
        }

        /* Is this a value type with an explicit layout? */

        if  (typeFlg & tdExplicitLayout)
        {
            assert(clsTyp->tdClass.tdcLayoutDone);
        }
        else
        {
            clsTyp->tdClass.tdcAlignment  = 0;
            clsTyp->tdClass.tdcSize       = 0;
        }

        /* Ask for any interfaces the class includes */

        const unsigned  intfMax  = 8;
        HCORENUM        intfEnum = NULL;
        mdInterfaceImpl intfToks[intfMax];
        ULONG           intfCnt;

        TypList         intfList = NULL;
        TypList         intfLast = NULL;

        for (;;)
        {
            unsigned        intfNum;

            if  (MDwmdi->EnumInterfaceImpls(&intfEnum,
                                            td,
                                            intfToks,
                                            intfMax,
                                            &intfCnt))
            {
                break;
            }

            if  (!intfCnt)
                break;

            for (intfNum = 0; intfNum < intfCnt; intfNum++)
            {
                mdTypeDef       intfClass;
                mdTypeRef       intfIntf;
                TypDef          intfType;

                if  (MDwmdi->GetInterfaceImplProps(intfToks[intfNum],
                                                   &intfClass,
                                                   &intfIntf))
                {
                    MDcomp->cmpFatal(ERRreadMD);
                }

                if  (TypeFromToken(intfIntf) == mdtTypeRef)
                    intfType = MDimportClsr(intfIntf, false);
                else
                    intfType = MDimportClss(intfIntf, NULL, 0, deep)->sdType;

                /* Add an entry to the interface list */

                intfList = MDstab->stAddIntfList(intfType, intfList, &intfLast);
            }
        }

        clsSym->sdType->tdClass.tdcIntf = intfList;
    }

SUCK_MEMS:

    /* Iterate over all members (fields and methods) */

    HCORENUM        memEnum;
    unsigned        memNum;

    for (memEnum = NULL, memNum = 0;; memNum++)
    {
        unsigned        memInd;
        mdMemberRef     memDsc[32];
        ULONG           memCnt;

        /* Get the next batch of members */

        if  (wmdi->EnumMembers(&memEnum,
                               td,
                               memDsc,
                               sizeof(memDsc)/sizeof(memDsc[0]),
                               &memCnt) != S_OK)
            break;

        /* If we got no members we must be done */

        if  (!memCnt)
            break;

        for (memInd=0; memInd < memCnt; ++memInd)
        {
            Ident           memIden;
            SymDef          memSym;

//          WCHAR           memName[255];   // ISSUE: fixed-size buffer?????
            const   char *  memName;

            PCCOR_SIGNATURE sigAddr;
            ULONG           sigSize;

            ULONG           memFlag;
            ULONG           cnsType;
            const   void *  cnsAddr;
            ULONG           cbValue;

            DWORD           attrs;

            /* Get the scoop on this member */

            if  (wmdi->GetNameFromToken(memDsc[memInd], &memName))
            {
                MDcomp->cmpFatal(ERRreadMD);
            }

            if  (wmdi->GetMemberProps(memDsc[memInd],
                                      NULL,
//                                    memName, sizeof(memName)/sizeof(memName[0])-1, 0,
                                      NULL, 0, NULL,
                                      &attrs,
                                      &sigAddr, &sigSize,
                                      NULL,
                                      &memFlag,
                                      &cnsType, &cnsAddr, &cbValue))
            {
                MDcomp->cmpFatal(ERRreadMD);
            }

            /* Hash the member name into our hash table */

            memIden = MDcomp->cmpGlobalHT->hashString(memName);
//          memIden = MDhashWideName(memName);

            /* Import/convert the member */

            memSym  = MDimportMem(clsSym,
                                  memIden,
                                  memDsc[memInd],
                                  attrs,
                                  false,
                                  fileScope,
                                  sigAddr,
                                  sigSize);
            if  (!memSym)
                continue;

            memSym->sdIsManaged = clsSym->sdIsManaged;

            /* Is this a data or function or enum member? */

            if  (memSym->sdSymKind == SYM_FNC)
            {
                if  (memFlag & mdPinvokeImpl)
                    memSym->sdFnc.sdfNative = true;
            }
            else
            {
                assert(memSym->sdSymKind == SYM_VAR ||
                       memSym->sdSymKind == SYM_ENUMVAL);

                /* Is this a constant? */

                if  (cnsAddr)
                {
                    var_types       vtyp;
                    ConstVal        cptr;

                    /* Allocate space for the constant value, if this is a variable */

                    if  (memSym->sdSymKind == SYM_VAR)
                    {
#if MGDDATA
                        cptr = new ConstVal;
#else
                        cptr =    (ConstVal)MDcomp->cmpAllocPerm.nraAlloc(sizeof(*cptr));
#endif
                    }

                    switch (cnsType)
                    {
                        __int32         ival;

                    case ELEMENT_TYPE_BOOLEAN:
                    case ELEMENT_TYPE_U1:
                        ival = *(unsigned char  *)cnsAddr;
                        goto INT_CNS;

                    case ELEMENT_TYPE_I1:
                        ival = *(  signed char  *)cnsAddr;
                        goto INT_CNS;

                    case ELEMENT_TYPE_I2:
                        ival = *(  signed short *)cnsAddr;
                        goto INT_CNS;

                    case ELEMENT_TYPE_U2:
                    case ELEMENT_TYPE_CHAR:
                        ival = *(unsigned short *)cnsAddr;
                        goto INT_CNS;

                    case ELEMENT_TYPE_I4:
                    case ELEMENT_TYPE_U4:
                        ival = *(           int *)cnsAddr;

                    INT_CNS:

                        /* Special case: enum member */

                        if  (memSym->sdSymKind == SYM_ENUMVAL)
                        {
                            memSym->sdEnumVal.sdEV.sdevIval = ival;

                        DONE_EMV:

                            assert(clsTyp);
                            assert(clsTyp->tdTypeKind == TYP_ENUM);

                            memSym->sdType = clsTyp;

                            goto DONE_INI;
                        }
                        cptr->cvValue.cvIval = ival;
                        break;

                    case ELEMENT_TYPE_I8:
                    case ELEMENT_TYPE_U8:
                        if  (memSym->sdSymKind == SYM_ENUMVAL)
                        {
                            UNIMPL(!"record 64-bit enum value");
                            goto DONE_EMV;
                        }
                        cptr->cvValue.cvLval = *(__int64*)cnsAddr;
                        break;

                    case ELEMENT_TYPE_R4:
                        assert(memSym->sdSymKind == SYM_VAR);
                        cptr->cvValue.cvFval = *(float  *)cnsAddr;
                        break;

                    case ELEMENT_TYPE_R8:
                        assert(memSym->sdSymKind == SYM_VAR);
                        cptr->cvValue.cvDval = *(double *)cnsAddr;
                        break;

                    case ELEMENT_TYPE_STRING:
                        assert(memSym->sdSymKind == SYM_VAR);
                        cptr->cvValue.cvSval = MDcomp->cmpSaveStringCns((wchar*)cnsAddr,
                                                                 wcslen((wchar*)cnsAddr));
                        cptr->cvType  = memSym->sdType;
                        cptr->cvVtyp  = memSym->sdType->tdTypeKindGet();
                        cptr->cvHasLC = false;
                        goto DONE_CNS;

                    default:
                        NO_WAY(!"Unexpected const type in metadata");
                        break;
                    }

                    /* Record the type of the constant */

                    assert(cnsType < arraylen(CORtypeToSMCtype));

                    cptr->cvVtyp = vtyp = (var_types)CORtypeToSMCtype[cnsType];
                    cptr->cvType = MDstab->stIntrinsicType(vtyp);

                DONE_CNS:

                    /* Remember the fact that this is a constant variable */

                    memSym->sdVar.sdvConst  = true;
                    memSym->sdVar.sdvCnsVal = cptr;

                DONE_INI:

                    memSym->sdCompileState  = CS_CNSEVALD;
                }
            }

#ifdef  DEBUG

            if  (MDcomp->cmpConfig.ccVerbose >= 4)
            {
                if  (fileScope)
                {
                    printf("       %-10s", (memSym->sdSymKind == SYM_FNC) ? "Function" : "Variable");
                }
                else
                {
                    printf("       %-10s", (memSym->sdSymKind == SYM_FNC) ? "Method" : "Field");
                }

                printf("'%s'\n", MDstab->stTypeName(NULL, memSym, NULL, NULL));
            }

#endif

            /* This member is now fully declared */

            memSym->sdCompileState = CS_DECLARED;
        }
    }

    wmdi->CloseEnum(memEnum);

    /* Iterate over all properties */

    HCORENUM        propEnum;
    unsigned        propNum;

    for (propEnum = NULL, propNum = 0;; propNum++)
    {
        unsigned        propInd;
        mdProperty      propDsc[32];
        ULONG           propCnt;

        /* Get the next batch of properties */

        if  (wmdi->EnumProperties(&propEnum,
                                  td,
                                  propDsc,
                                  sizeof(propDsc)/sizeof(propDsc[0]),
                                  &propCnt) != S_OK)
            break;

        /* If we got no properties we must be done */

        if  (!propCnt)
            break;

        for (propInd=0; propInd < propCnt; ++propInd)
        {
            Ident           propIden;
            const   char *  propName;
            TypDef          propType;
            SymDef          propSym;

            PCCOR_SIGNATURE sigAddr;
            ULONG           sigSize;

            mdMethodDef     propGet;
            mdMethodDef     propSet;

            DWORD           flags;
            SymDef          sym;

            /* Get the scoop on this property */

            if  (wmdi->GetNameFromToken(propDsc[propInd], &propName))
                MDcomp->cmpFatal(ERRreadMD);

            if  (wmdi->GetPropertyProps(propDsc[propInd],
                                        NULL,
                                        NULL, 0, NULL,
                                        &flags,
                                        &sigAddr, &sigSize,
                                        NULL, NULL, NULL,
                                        &propSet,
                                        &propGet,
                                        NULL, 0, NULL))
            {
                MDcomp->cmpFatal(ERRreadMD);
            }

            /* Hash the property name into our hash table */

            propIden = MDcomp->cmpGlobalHT->hashString(propName);

            /* Import/convert the member */

            propSym  = MDimportMem(clsSym,
                                   propIden,
                                   propDsc[propInd],
                                   flags,
                                   true,
                                   false,
                                   sigAddr,
                                   sigSize);

            propSym->sdIsManaged = true;

            /* Is this an indexed property? */

            propType = propSym->sdType;

            if  (propType->tdTypeKind == TYP_FNC && !propType->tdFnc.tdfArgs.adCount)
            {
                /* Not an indexed property, just use the return type */

                propSym->sdType = propType->tdFnc.tdfRett;
            }

//          printf("Property: '%s'\n", MDstab->stTypeName(propSym->sdType, propSym, NULL, NULL, true));

            /* Locate the corresponding accessor methods */

            if  (propGet != mdMethodDefNil)
            {
                sym = MDfindPropMF(propSym, propGet,  true);
                if  (sym)
                {
                    propSym->sdProp.sdpGetMeth = sym;
//                  printf("Prop get = '%s'\n", sym->sdSpelling());
                    propSym->sdIsVirtProp     |= sym->sdFnc.sdfVirtual;
                }
            }

            if  (propSet != mdMethodDefNil)
            {
                sym = MDfindPropMF(propSym, propSet, false);
                if  (sym)
                {
                    propSym->sdProp.sdpSetMeth = sym;
//                  printf("Prop set = '%s'\n", sym->sdSpelling());
                    propSym->sdIsVirtProp     |= sym->sdFnc.sdfVirtual;
                }
            }
        }
    }

    wmdi->CloseEnum(propEnum);

    assert(clsSym->sdSymKind != SYM_ENUM || (clsTyp->tdEnum.tdeIntType != NULL &&
                                             clsTyp->tdEnum.tdeIntType->tdTypeKind <= TYP_UINT));


    return  clsSym;
}

/*****************************************************************************
 *
 *  Locate a given custom attribute attached to the specified token.
 */

bool                metadataImp::MDfindAttr(mdToken token,
                                            wideStr name, const void * *blobAddr,
                                                          ULONG        *blobSize)
{
    int             ret;

    *blobAddr = NULL;
    *blobSize = 0;

    cycleCounterPause();
    ret = MDwmdi->GetCustomAttributeByName(token, name, blobAddr, blobSize);
    cycleCounterResume();

    return  (ret != S_OK);
}

/*****************************************************************************
 *
 *  Add a manifest definition for the given input type.
 */

void                metadataImp::MDimportCTyp(mdTypeDef td, mdToken ft)
{
    WCHAR           typName[MAX_CLASS_NAME  ];

    DWORD           typeFlg;

    if  (FAILED(MDwmdi->GetTypeDefProps(td,
                                        typName, sizeof(typName)/sizeof(typName[0])-1, NULL,
                                        &typeFlg,
                                        NULL)))
    {
        MDcomp->cmpFatal(ERRreadMD);
    }

#if 0

    printf("%s type = '", ((typeFlg & tdVisibilityMask) == tdPublic) ? "Public  "
                                                                     : "Non-pub ");

    printf("%ls'\n", typName);

#endif

    /* Is this a public type ? */

    if  ((typeFlg & tdVisibilityMask) == tdPublic)
    {
        /* Add a type definition to the manifest */

        MDcomp->cmpAssemblyAddType(typName, td, ft, tdPublic);
    }
}

/*****************************************************************************
 *
 *  Locate the metadata importer interface value for the given global symbol.
 */

IMetaDataImport   * compiler::cmpFindImporter(SymDef globSym)
{
    MetaDataImp     cimp;
    unsigned        index;

    assert(globSym->sdSymKind == SYM_FNC ||
           globSym->sdSymKind == SYM_VAR);

    index = (globSym->sdSymKind == SYM_FNC) ? globSym->sdFnc.sdfImpIndex
                                            : globSym->sdVar.sdvImpIndex;

    for (cimp = cmpMDlist; cimp; cimp = cimp->MDnext)
    {
        if  (cimp->MDnum == index)
        {

#if 0   // ISSUE: not sure whether the following is needed or not

            if  (cimp->MDnum > 1)   // s/b something like "!cmpAssemblyIsBCL(assx)"
                cimp->MDrecordFile();

#endif

            return  uwrpIMDIwrapper(cimp->MDwmdi);
        }
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Import metadata from the given file.
 */

void                metadataImp::MDimportStab(const char *  filename,
                                              unsigned      assx,
                                              bool          asmOnly,
                                              bool          isBCL)
{
    HCORENUM        typeEnum;
    unsigned        typeNum;

    SymTab          symtab = MDstab;

    WMetaDataImport*wmdi;

    WCHAR           wfname[255];
    WCHAR   *       wfnptr;

    mdToken         fileTok;

    assert(MDcomp->cmpWmdd);

    /* Create the input file name */

    wfnptr = wcscpy(wfname, L"file:") + 5;
    mbstowcs(wfnptr, filename, sizeof(wfname)-1-(wfnptr-wfname));

    /* See if the file is an assembly */

    MDassIndex = 0;

    if  (!assx && !asmOnly)
    {
        WAssemblyImport*wasi;
        BYTE    *       cookie;
        mdAssembly      assTok;

        /* Try to create an assembly importer against the file */

        if  (MDcomp->cmpWmdd->OpenAssem(wfname,
                                        0,
                                        getIID_IMetaDataAssemblyImport(),
                                        filename,
                                        &assTok,
                                        &cookie,
                                        &wasi) >= 0)
        {
            mdAssembly      toss;

            /* Add the assembly to the assembly table */

            assx = MDcomp->cmpAssemblyRefAdd(assTok, wasi, cookie);

            /* Record the assembly index if there is a manifest */

            if  (!FAILED(wasi->GetAssemblyFromScope(&toss)))
                MDassIndex = assx;

//          printf("Ass = %u\n", MDassIndex);

            /* Remember the BCL assembly token */

            if  (isBCL)
                MDcomp->cmpAssemblyTkBCL(assx);
        }
    }

    /* Open the metadata in the file */

    if  (MDcomp->cmpWmdd->OpenScope(wfname,
                                    0,
                                    getIID_IMetaDataImport(),
                                    &wmdi))
    {
        MDcomp->cmpGenFatal(ERRopenMDbad, filename);
    }

    /* Do we need to create a file entry in our own assembly for this guy? */

    if  (asmOnly)
    {
        fileTok = MDcomp->cmpAssemblyAddFile(wfnptr, true);
        MDassIndex = assx;
    }

    /* Make the import interface available to the rest of the class */

    MDwmdi = wmdi;

    /* Pass 1: enumerate top-level typedefs and enter them in the symbol table */

    for (typeEnum = NULL, typeNum = 0; ; typeNum++)
    {
        mdTypeDef       typeRef;
        ULONG           count;

        /* Ask for the next typedef */

        if  (wmdi->EnumTypeDefs(&typeEnum, &typeRef, 1, &count) != S_OK)
            break;
        if  (!count)
            break;

        if  (asmOnly)
            MDimportCTyp(typeRef, fileTok);
        else
            MDimportClss(typeRef, NULL, assx, false);
    }

    wmdi->CloseEnum(typeEnum);

    /* Import any names declared at file scope */

    MDimportClss(0, NULL, assx, false);

    /* Everything has been imported, release the metadata importer */

    wmdi->Release();
}

void                metadataImp::MDcreateFileTok()
{
    if  (!MDfileTok)
    {
        WCHAR           name[128];

        if  (FAILED(MDwmdi->GetScopeProps(name, arraylen(name), NULL, NULL)))
            MDcomp->cmpFatal(ERRmetadata);

//      printf("Assembly index = %u for '%ls'\n", MDassIndex, name);

        MDfileTok = MDcomp->cmpAssemblyAddFile(name, false);
    }
}

/*****************************************************************************
 *
 *  Initialize metadata importing stuff.
 */

void                compiler::cmpInitMDimp()
{
    cmpInitMD(); assert(cmpWmdd);
}

/*****************************************************************************
 *
 *  Initialize metadata importing stuff.
 */

void                compiler::cmpDoneMDimp()
{
    // UNDONE: release all importer instances as well!!!
}

/*****************************************************************************
 *
 *  Create a metadata importer and add it to the global importer list.
 */

MetaDataImp         compiler::cmpAddMDentry()
{
    MetaDataImp     cimp;

#if MGDDATA
    cimp = new MetaDataImp;
#else
    cimp =    (MetaDataImp)cmpAllocTemp.baAlloc(sizeof(*cimp));
#endif

    cimp->MDnum  = ++cmpMDcount;

    /* Append the importer to the global list */

    cimp->MDnext = NULL;

    if  (cmpMDlist)
        cmpMDlast->MDnext = cimp;
    else
        cmpMDlist         = cimp;

    cmpMDlast = cimp;

    return  cimp;
}

/*****************************************************************************
 *
 *  Import the metadata from the given file (pass NULL to import MSCORLIB).
 */

void                compiler::cmpImportMDfile(const char *  fname,
                                              bool          asmOnly,
                                              bool          isBCL)
{
    MetaDataImp     cimp;
    char            buff[_MAX_PATH];

    /* Create the importer and initialize it [ISSUE: need to trap errors?] */

    cimp = cmpAddMDentry();

    cycleCounterPause();
    cimp->MDinit(this, cmpGlobalST);
    cycleCounterResume();

    /* Make sure we have a valid filename to import */

    if  (!fname || !*fname)
        fname = "MSCORLIB.DLL";

    /* Find the specified file on the search path */

    if  (!SearchPathA(NULL, fname, NULL, sizeof(buff), buff, NULL))
    {
        StrList         path;

        /* Try any additional path that may have been specified */

        for (path = cmpConfig.ccPathList; path; path = path->slNext)
        {
            _Fstat          fileInfo;

            strcpy(buff, path->slString);
            strcat(buff, "\\");
            strcat(buff, fname);

            /* See if the file exists */

            if  (!_stat(buff, &fileInfo))
                goto GOTIT;
        }

        cmpGenFatal(ERRopenMDerr, fname);
    }

GOTIT:

//  printf("Found metadata file '%s'\n", buff);

    /* We're ready to import the file */

    cycleCounterPause();
    cimp->MDimportStab(buff, 0, asmOnly, isBCL);
    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Get hold of all the various interfaces we need to pass to the metadata
 *  API's to create import references.
 */

void                compiler::cmpFindMDimpAPIs(SymDef                   typSym,
                                               IMetaDataImport        **imdiPtr,
                                               IMetaDataAssemblyEmit  **iasePtr,
                                               IMetaDataAssemblyImport**iasiPtr)
{
    unsigned        assx;

    MetaDataImp     imp;

    assert(typSym->sdIsImport);

    if  (typSym->sdSymKind == SYM_CLASS)
    {
        assert(typSym->sdClass.sdcMDtypedef);

        imp  = typSym->sdClass.sdcMDimporter;
        assx = typSym->sdClass.sdcAssemIndx;
    }
    else
    {
        assert(typSym->sdSymKind == SYM_ENUM);

        assert(typSym->sdEnum .sdeMDtypedef);

        imp  = typSym->sdEnum .sdeMDimporter;
        assx = typSym->sdEnum .sdeAssemIndx;
    }

    assert(imp);

    *imdiPtr = uwrpIMDIwrapper(imp->MDwmdi);
    *iasePtr = cmpWase ? uwrpIASEwrapper(cmpWase) : NULL;
    *iasiPtr = NULL;

    if  (assx == 0)
    {
        *iasePtr = NULL;
    }
    else
    {
        *iasiPtr = uwrpIASIwrapper(cmpAssemblyGetImp(assx));

//      imp->MDrecordFile();
    }
}

/*****************************************************************************
 *
 *  Create a typeref for the specified import class.
 */

void                compiler::cmpMakeMDimpTref(SymDef clsSym)
{
    IMetaDataImport        *imdi;
    IMetaDataAssemblyEmit  *iase;
    IMetaDataAssemblyImport*iasi;

    mdTypeRef               clsr;

    assert(clsSym->sdIsImport);
    assert(clsSym->sdSymKind == SYM_CLASS);
    assert(clsSym->sdClass.sdcMDtypedef);
    assert(clsSym->sdClass.sdcMDtypeImp == 0);

    cmpFindMDimpAPIs(clsSym, &imdi, &iase, &iasi);

    cycleCounterPause();

    if  (FAILED(cmpWmde->DefineImportType(iasi,
                                          NULL,
                                          0,
                                          imdi,
                                          clsSym->sdClass.sdcMDtypedef,
                                          iase,
                                          &clsr)))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();

    clsSym->sdClass.sdcMDtypeImp = clsr;

    //if  (cmpConfig.ccAssembly && clsSym->sdClass.sdcAssemIndx)
    //    cmpAssemblySymDef(clsSym);
}

/*****************************************************************************
 *
 *  Create a typeref for the specified import enum.
 */

void                compiler::cmpMakeMDimpEref(SymDef etpSym)
{
    IMetaDataImport        *imdi;
    IMetaDataAssemblyEmit  *iase;
    IMetaDataAssemblyImport*iasi;

    mdTypeRef               etpr;

    assert(etpSym->sdIsImport);
    assert(etpSym->sdSymKind == SYM_ENUM);
    assert(etpSym->sdEnum.sdeMDtypedef);
    assert(etpSym->sdEnum.sdeMDtypeImp == 0);

    cmpFindMDimpAPIs(etpSym, &imdi, &iase, &iasi);

    cycleCounterPause();

    if  (FAILED(cmpWmde->DefineImportType(iasi,
                                          NULL,
                                          0,
                                          imdi,
                                          etpSym->sdEnum.sdeMDtypedef,
                                          iase,
                                          &etpr)))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();

    etpSym->sdEnum.sdeMDtypeImp = etpr;
}

/*****************************************************************************
 *
 *  Create a methodref for the specified import method.
 */

void                compiler::cmpMakeMDimpFref(SymDef fncSym)
{
    mdMemberRef     fncr;

    assert(fncSym->sdIsImport);
    assert(fncSym->sdFnc.sdfMDtoken != 0);
    assert(fncSym->sdFnc.sdfMDfnref == 0);

    cycleCounterPause();

    if  (fncSym->sdIsMember)
    {
        IMetaDataImport        *imdi;
        IMetaDataAssemblyEmit  *iase;
        IMetaDataAssemblyImport*iasi;

        SymDef                  clsSym = fncSym->sdParent;
        mdTypeRef               clsRef = clsSym->sdClass.sdcMDtypeImp;

        assert(clsSym->sdSymKind == SYM_CLASS);
        assert(clsSym->sdIsImport);

        /* Make sure the class has an import typeref */

        if  (!clsRef)
        {
            cmpMakeMDimpTref(clsSym);
            clsRef = clsSym->sdClass.sdcMDtypeImp;
        }

        cmpFindMDimpAPIs(clsSym, &imdi, &iase, &iasi);

        /* Now create the methodref */

        if  (FAILED(cmpWmde->DefineImportMember(iasi,
                                                NULL,
                                                0,
                                                imdi,
                                                fncSym->sdFnc.sdfMDtoken,
                                                iase,
                                                clsRef,
                                                &fncr)))
        {
            cmpFatal(ERRmetadata);
        }
    }
    else
    {
        if  (FAILED(cmpWmde->DefineImportMember(NULL, // iasi,
                                                NULL,
                                                0,
                                                cmpFindImporter(fncSym),
                                                fncSym->sdFnc.sdfMDtoken,
                                                NULL, // iase,
                                                mdTokenNil,
                                                &fncr)))
        {
            cmpFatal(ERRmetadata);
        }
    }

    cycleCounterResume();

//  printf("Imp func ref: %04X = '%s'\n", fncr, fncSym->sdSpelling());

    fncSym->sdFnc.sdfMDfnref = fncr;
}

/*****************************************************************************
 *
 *  Create a memberref for the specified import global var / static data member.
 */

void                compiler::cmpMakeMDimpDref(SymDef fldSym)
{
    mdMemberRef     fldr;

    assert(fldSym->sdIsImport);
    assert(fldSym->sdVar.sdvMDtoken != 0);
    assert(fldSym->sdVar.sdvMDsdref == 0);

    cycleCounterPause();

    if  (fldSym->sdIsMember)
    {
        IMetaDataImport        *imdi;
        IMetaDataAssemblyEmit  *iase;
        IMetaDataAssemblyImport*iasi;

        SymDef                  clsSym = fldSym->sdParent;
        mdTypeRef               clsRef = clsSym->sdClass.sdcMDtypeImp;

        assert(clsSym->sdSymKind == SYM_CLASS);
        assert(clsSym->sdIsImport);

        /* Make sure the class has an import typeref */

        if  (!clsRef)
        {
            cmpMakeMDimpTref(clsSym);
            clsRef = clsSym->sdClass.sdcMDtypeImp;
        }

        cmpFindMDimpAPIs(clsSym, &imdi, &iase, &iasi);

        /* Now create the memberref */

        if  (FAILED(cmpWmde->DefineImportMember(iasi,
                                                NULL,
                                                0,
                                                imdi,
                                                fldSym->sdVar.sdvMDtoken,
                                                iase,
                                                clsRef,
                                                &fldr)))
        {
            cmpFatal(ERRmetadata);
        }
    }
    else
    {
        if  (FAILED(cmpWmde->DefineImportMember(NULL, // iasi,
                                                NULL,
                                                0,
                                                cmpFindImporter(fldSym),
                                                fldSym->sdVar.sdvMDtoken,
                                                NULL, // iase,
                                                mdTokenNil,
                                                &fldr)))
        {
            cmpFatal(ERRmetadata);
        }
    }

    cycleCounterResume();

    fldSym->sdVar.sdvMDsdref = fldr;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\errors.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// First all of the fatal errors:

SMC_ERR(ERRnone         ,0, NULL                                                  )
SMC_ERR(ERRinternal     ,0, "INTERNAL COMPILER ERROR: %s"                         )
SMC_ERR(ERR2manyErrs    ,0, "Too many error messages"                             )
SMC_ERR(ERRnoMemory     ,0, "Out of memory"                                       )
SMC_ERR(ERRerrDir       ,0, "Error directive"                                     )
SMC_ERR(ERRbltinNS      ,0, "Could not locate system namespace '%s'"              )
SMC_ERR(ERRbltinTp      ,0, "Could not locate system class '%s'"                  )
SMC_ERR(ERRbltinMeth    ,0, "Could not locate system method '%s'"                 )

SMC_ERR(ERRopenRdErr    ,0, "Could not open source file '%s' for reading"         )
SMC_ERR(ERRopenWrErr    ,0, "Could not open target file '%s' for writing"         )
SMC_ERR(ERRreadErr      ,0, "Could not read source file '%s'"                     )
SMC_ERR(ERRopenMDerr    ,0, "Could not open '%s' for metadata input (use -s<filename> to specify location)")
SMC_ERR(ERRreadMD       ,0, "Could not read metadata"                             )
SMC_ERR(ERRopenMDbad    ,0, "Could not read metadata from file '%s'"              )
SMC_ERR(ERRwriteErr     ,0, "Could not write to output file '%s'"                 )
SMC_ERR(ERRopenCOR      ,0, "Could not initialize Common Language Runtime"                   )
SMC_ERR(ERRmetadata     ,0, "Could not create metadata"                           )
SMC_ERR(ERRdebugInfo    ,0, "Could not emit debugging information"                )
SMC_ERR(ERRundefTref    ,0, "Could not resolve metadata reference to type '%s'"   )
SMC_ERR(ERRbadInputFF   ,0, "Invalid input file format in '%s': expected a %s file")
SMC_ERR(ERRnoOutfName   ,0, "Name of output file not specified, please use -O"    )

// End of fatal errors, other errors begin:

SMC_ERR(ERRidTooLong    ,0, "Identifier too long"                                 )
SMC_ERR(ERRbadNumber    ,0, "Invalid number"                                      )
SMC_ERR(ERRillegalChar  ,0, "Invalid character"                                   )
SMC_ERR(ERRbadCharCns   ,0, "Invalid character constant"                          )
SMC_ERR(ERRbadEscCh     ,0, "Invalid escape character"                            )
SMC_ERR(ERRnoStrEnd     ,0, "Unterminated string constant"                        )
SMC_ERR(ERRnoCmtEnd     ,0, "Unterminated comment"                                )
SMC_ERR(ERRnestCmt      ,0, "Nested comment"                                      )
SMC_ERR(ERRnoUnicodeEsc ,0, "Expected Unicode escape sequence"                    )
SMC_ERR(ERRbadPPdir     ,0, "Malformed '#' directive"                             )
SMC_ERR(ERRnoEOL        ,0, "End of line expected"                                )
SMC_ERR(ERRnoEndif      ,0, "Missing 'endif' for directive on line %u"            )

SMC_ERR(ERRnoClassDef   ,0, "Cannot find definition for class '%s'"               )
SMC_ERR(ERRnoEnumDef    ,0, "Cannot find definition for enum '%s'"                )
SMC_ERR(ERRnoEOF        ,0, "Expected end of file"                                )
SMC_ERR(ERRnoColon      ,0, "Expected ':'"                                        )
SMC_ERR(ERRnoComma      ,0, "Expected ','"                                        )
SMC_ERR(ERRnoSemic      ,0, "Expected ';'"                                        )
SMC_ERR(ERRnoLparen     ,0, "Expected '('"                                        )
SMC_ERR(ERRnoRparen     ,0, "Expected ')'"                                        )
SMC_ERR(ERRnoRbrack     ,0, "Expected ']'"                                        )
SMC_ERR(ERRnoLcurly     ,0, "Expected '{'"                                        )
SMC_ERR(ERRnoRcurly     ,0, "Expected '}'"                                        )
SMC_ERR(ERRnoEqual      ,0, "Expected '='"                                        )
SMC_ERR(ERRnoGt         ,0, "Expected '>'"                                        )
SMC_ERR(ERRnoCmRc       ,0, "Expected ',' or '}'"                                 )
SMC_ERR(ERRnoCmSc       ,0, "Expected ',' or ';'"                                 )
SMC_ERR(ERRnoSmLc       ,0, "Expected ';' or '{'"                                 )
SMC_ERR(ERRnoIN         ,0, "Expected 'in'"                                       )
#ifdef  SETS
SMC_ERR(ERRnoSortTerm   ,0, "Expected ']]' or ':' or 'sortby'"                    )
SMC_ERR(ERRnoCmRbr2     ,0, "Expected ']]' or ','"                                )
#endif

SMC_ERR(ERRbadLcurly    ,0, "Unexpected '{' found"                                )
SMC_ERR(ERRbadElse      ,0, "'else' without a matching 'if'"                      )
SMC_ERR(ERRbadEndif     ,0, "'endif' without a matching 'if'"                     )
SMC_ERR(ERRnoEOX        ,0, "Expected operator or end of expression"              )

SMC_ERR(ERRnoDecl       ,0, "Expected declaration"                                )
SMC_ERR(ERRnoIdent      ,0, "Expected identifier"                                 )
SMC_ERR(ERRnoString     ,0, "String expected"                                     )
SMC_ERR(ERRnoType       ,0, "Expected type specifier"                             )
SMC_ERR(ERRbadQualid    ,0, "Qualified name not allowed here"                     )
SMC_ERR(ERRbadQualName  ,0, "Invalid qualified name '%s'"                         )
SMC_ERR(ERRidNotType    ,0, "The name '%s' doesn't denote a type"                 )
SMC_ERR(ERRundefName    ,0, "Undefined name '%s'"                                 )
SMC_ERR(ERRnoSuchMem    ,0, "The class '%s' doesn't contain a member '%s'"        )
SMC_ERR(ERRbadMain      ,0, "Function must be declared as 'int main(String [])'"  )
SMC_ERR(ERRbadAccSpec   ,0, "This access specifier is not allowed here"           )
SMC_ERR(ERRdupModifier  ,0, "Duplicate modifier"                                  )
SMC_ERR(ERRdupIntfc     ,0, "Duplicate interface include specifier"               )
SMC_ERR(ERRbadModifier  ,0, "Illegal type modifier(s)"                            )
SMC_ERR(ERRdmModifier   ,0, "A data member cannot be declared with '%s'"          )
SMC_ERR(ERRfmModifier   ,0, "A method cannot be declared with '%s'"               )
SMC_ERR(ERRlvModifier   ,0, "A local variable cannot be declared with '%s'"       )
SMC_ERR(ERRfmModifier2  ,0, "A method cannot be both '%s' and '%s'"               )
SMC_ERR(ERRlvAccess     ,0, "Access specifiers not allowed with local variables"  )
SMC_ERR(ERRnoClassName  ,0, "Class name expected"                                 )
SMC_ERR(ERRnotAclass    ,0, "'%s' does not denote a class"                        )
SMC_ERR(ERRbadIdent     ,0, "Unexpected identifier"                               )
SMC_ERR(ERRbadNSmem     ,0, "Illegal namespace member"                            )
SMC_ERR(ERRredefMem     ,0, "The member '%s' has already been declared"           )
SMC_ERR(ERRredefName    ,0, "The name '%s' has already been declared"             )
SMC_ERR(ERRredefBody    ,0, "Two bodies given for '%s'"                           )
SMC_ERR(ERRredefEnum    ,0, "The enum type '%s' has already been defined"         )
SMC_ERR(ERRredefClass   ,0, "The class '%s' has already been defined"             )
SMC_ERR(ERRredefLcl     ,0, "Local variable '%s' has already been declared"       )
SMC_ERR(ERRcircDep      ,0, "'%s' has a circular dependency"                      )
SMC_ERR(ERRundefCls     ,0, "Cannot find definition for class '%s'"               )
SMC_ERR(ERRnoCnsInit    ,0, "Members declared 'const' must be initialized"        )
SMC_ERR(ERRnoVarInit    ,0, "Initialization not found for '%s'"                   )
SMC_ERR(ERRdupMemInit   ,0, "Member '%s' has already been initialized"            )
SMC_ERR(ERRrecClass     ,0, "Attempt to include a copy of class '%s' in itself"   )
SMC_ERR(ERRextCns       ,0, "A variable can't be 'const' and 'extern'"            )
SMC_ERR(ERRbadInit      ,0, "Initializer not allowed here"                        )
SMC_ERR(ERRnoIntType    ,0, "Integer type expected"                               )
SMC_ERR(ERRnoIntExpr    ,0, "Integer constant expression expected"                )
SMC_ERR(ERRnoCnsExpr    ,0, "Constant expression expected"                        )
SMC_ERR(ERRbadArrSize   ,0, "Array size must be a positive constant"              )
SMC_ERR(ERRbadFnBody    ,0, "Variable has illegal initializer"                    )
SMC_ERR(ERRbadBfld      ,0, "A bitfield may not have type '%s'"                   )
///////(ERRmgdBfld      ,0, "Managed classes may not have bitfield members"       )
SMC_ERR(ERRstmBfld      ,0, "A bitfield may not be 'static'"                      )
SMC_ERR(ERRbadBFsize    ,0, "Bitfield can't have witdh of %u (underlying type has %u bits)")
SMC_ERR(ERRbfldAddr     ,0, "Cannot take address of bitfield member '%s'"         )
SMC_ERR(ERRbadOvl       ,0, "Overloaded '%s' and '%s' differ only in return type" )
SMC_ERR(ERRbadUTag      ,0, "Tag '%s' is not a suitable data member"              )
SMC_ERR(ERRbadUmem      ,0, "Expected tagged union member - 'case' or 'default'"  )
SMC_ERR(ERRmulUmem      ,0, "A tagged union section may contain only a single member")
SMC_ERR(ERRbadExpTp     ,0, "Expected value of type '%s' not '%s'"                )
SMC_ERR(ERRnoNspMem     ,0, "The namespace '%s' doesn't contain '%s'"             )
SMC_ERR(ERRnoClsMem     ,0, "The class '%s' doesn't contain '%s'"                 )
SMC_ERR(ERRnoTPmems     ,0, "'%s' doesn't contain any types"                      )
SMC_ERR(ERRnoMems       ,0, "'%s' doesn't contain any members"                    )
SMC_ERR(ERRnoGlobNm     ,0, "Undefined global name '%s'"                          )
SMC_ERR(ERRbadCall      ,0, "Call of a non-function"                              )
SMC_ERR(ERRnoOvlMatch   ,0, "No overloaded method matches the call '%s'"          )
SMC_ERR(ERRnoDlgMatch   ,0, "The argument '%s' doesn't match delegate '%s'"       )
SMC_ERR(ERRhideMatch    ,0, "Matching base class method '%s' is hidden"           )
SMC_ERR(ERRmisgArg      ,0, "Missing arguments in call to '%s'"                   )
SMC_ERR(ERRmanyArg      ,0, "Too many arguments in call to '%s'"                  )
SMC_ERR(ERRbadArgValNam ,0, "Value for argument '%s' of '%s' cannot be converted from '%s'" )
SMC_ERR(ERRbadArgValNum ,0, "Value for argument %s of '%s' cannot be converted from '%s'" )
SMC_ERR(ERRbadMgdMod    ,0, "Only namespaces and classes may be declared '%s'"    )
SMC_ERR(ERRmgdGlobVar   ,0, "File-scope variables may not have managed type for now")
SMC_ERR(ERRmgdStatVar   ,0, "Local static variables may not have managed type for now")
SMC_ERR(ERRbadUnmInt    ,0, "An interface cannot be declared 'unmanaged'"         )
SMC_ERR(ERRbadGlobInt   ,0, "An interface cannot be declared in global scope"     )
SMC_ERR(ERRassgCns      ,0, "Cannot assign to constant '%s'"                      )
SMC_ERR(ERRassgLit      ,0, "Cannot assign to a constant"                         )
SMC_ERR(ERRnotLvalue    ,0, "Lvalue required here"                                )
SMC_ERR(ERRbadIndex     ,0, "A value of type '%s' cannot be indexed with '[]'"    )
SMC_ERR(ERRnoArrDim     ,0, "Array dimension missing"                             )
SMC_ERR(ERRbadBrInit    ,0, "Variable of type '%s' cannot be initialized via '{}'")
SMC_ERR(ERRbadBrNew     ,0, "A value of type '%s' cannot be initialized with '{}'")
SMC_ERR(ERRnoArrSize    ,0, "Array without a dimension not allowed here"          )
SMC_ERR(ERRbadUndimMem  ,0, "Undimensioned array member must be last in struct"   )
SMC_ERR(ERRemptyArray   ,0, "Unmanaged arrays may not have 0 size"                )
SMC_ERR(ERRbadPtrUse    ,0, "The pointer type '%s' cannot be used here"           )
SMC_ERR(ERRbadMgInit    ,0, "Variables of managed type '%s' cannot be initialized via '{}'")
SMC_ERR(ERRarrInitMany  ,0, "Too many initializers specified for array, %u expected")
SMC_ERR(ERRstrInitMany  ,0, "Initializer string too long, %u characters expected" )
SMC_ERR(ERRlvInvisible  ,0, "Cannot use local variable '%s' before its declaration")
SMC_ERR(ERRnoNSnm       ,0, "The name '%s' doesn't denote a namespace"            )
SMC_ERR(ERRambigUse     ,0, "Two symbols in used namespaces match: '%s' and '%s'" )
SMC_ERR(ERRdiffMethRet  ,0, "Method '%s' was earlier declared with return type '%s'")
SMC_ERR(ERRdiffVirtRet  ,0, "Return type of virtual method '%s' differs from '%s'")
SMC_ERR(ERRvirtAccess   ,0, "Cannot reduce access level of overridden method '%s'")
SMC_ERR(ERRdiffPropTp   ,0, "Type of virtual property '%s' differs from '%s'"     )
SMC_ERR(ERRdupDefProp   ,0, "Class has already has a default property with another name: '%s'")
SMC_ERR(ERRnoPropDef    ,0, "Expected '{' followed by property accessor method declaration")
SMC_ERR(ERRpropAccDef   ,0, "Method conflicts with property accessor '%s'"        )
SMC_ERR(ERRnewIntf      ,0, "Cannot create an instance of an interface type '%s'" )
SMC_ERR(ERRnewAbstract  ,0, "Cannot create an instance of an abstract class '%s'" )
SMC_ERR(ERRbadNewTyp    ,0, "Cannot create an instance of type '%s'"              )
SMC_ERR(ERRnewNoVal     ,0, "'new' expression for type '%s' requires an initial value")
SMC_ERR(ERRnoCtorMatch  ,0, "The class doesn't have a constructor that matches '%s'")
SMC_ERR(ERRintfImpl     ,0, "Cannot create an instance of an interface type '%s'" )
SMC_ERR(ERRintfBase     ,0, "A class cannot inherit from an interface: '%s'"      )
SMC_ERR(ERRsealedInh    ,0, "Cannot inherit from sealed type '%s'"                )
SMC_ERR(ERRstrInhCls    ,0, "A struct cannot inherit from class '%s'"             )
SMC_ERR(ERRunmIntf      ,0, "Unmanaged classes may not include interfaces"        )
SMC_ERR(ERRinclCls      ,0, "Only interfaces may be included: '%s'"               )
SMC_ERR(ERRxMgdInh      ,0, "Management of base class '%s' doesn't match derived class")
SMC_ERR(ERRxCtxInh      ,0, "Context flavor of base class '%s' doesn't match derived class")
SMC_ERR(ERRctxAddr      ,0, "Cannot take address of member of a appdomain/contextful class '%s'")
SMC_ERR(ERRbadEHtype    ,0, "Type '%s' is not a class derived from 'Exception'"   )
SMC_ERR(ERRbadReThrow   ,0, "Argument to 'throw' is required outside of a catch block")
SMC_ERR(ERRtryNoBlk     ,0, "'try' block expected, '{' not found"                 )
SMC_ERR(ERRnoHandler    ,0, "'catch', 'finally', or 'except' expected following 'try' block")
SMC_ERR(ERRfinExit      ,0, "Attempt to prematurely exit from a 'finally' block"  )
SMC_ERR(ERRbadFNbody    ,0, "Function body unexpected for a variable"             )
SMC_ERR(ERRdupProp      ,0, "Duplicate property '%s' declaration"                 )
SMC_ERR(ERRdupArg       ,0, "More than one argument named '%s'"                   )
SMC_ERR(ERRnotClass     ,0, "Cannot use '%s' here, it doesn't denote a class"     )
SMC_ERR(ERRsyntax       ,0, "Syntax error"                                        )
SMC_ERR(ERRnoDim        ,0, "Missing array dimension"                             )
SMC_ERR(ERRbadSizeof    ,0, "Illegal operand of 'sizeof'"                         )
SMC_ERR(ERRoperType     ,0, "Can't apply operator '%s' to type '%s'"              )
SMC_ERR(ERRoperType2    ,0, "Can't apply operator '%s' to types '%s' and '%s'"    )
SMC_ERR(ERRnotAfunc     ,0, "Illegal call: '%s' doesn't denote a function"        )
SMC_ERR(ERRtypedefNm    ,0, "Typedef name '%s' has to match the tag name '%s'"    )
SMC_ERR(ERRmemWOthis    ,0, "Reference to non-static member '%s' without an object")
SMC_ERR(ERRundefNspm    ,0, "The namespace '%s' doesn't have a member '%s'"       )
SMC_ERR(ERRbadDotOp     ,0, "The '.' operator cannot be applied to a value of type '%s'")
SMC_ERR(ERRbadArrOp     ,0, "The '->' operator cannot be applied to a value of type '%s'")
SMC_ERR(ERRnotMember    ,0, "The type '%s' doesn't have a member '%s'"            )
SMC_ERR(ERRmsgArgs      ,0, "Need argument list for call to member '%s'"          )
SMC_ERR(ERRbadArgs      ,0, "The member '%s' is not a function"                   )
SMC_ERR(ERRambigCall    ,0, "Call is ambiguous between '%s' and '%s'"             )
SMC_ERR(ERRambigConv    ,0, "Conversion is ambiguous: '%s' and '%s'"              )
SMC_ERR(ERRambigMem     ,0, "The member '%s' is ambiguous: found in '%s' and '%s'")
SMC_ERR(ERRbadCastImp   ,0, "Cannot implicitly convert from type '%s' to '%s'"    )
SMC_ERR(ERRbadCastExp   ,0, "A value of type '%s' cannot be cast to type '%s'"    )
SMC_ERR(ERRbadCastNul   ,0, "'null' cannot be converted to type '%s'"             )
SMC_ERR(ERRdivZero      ,0, "Division by constant 0"                              )
SMC_ERR(ERRbadMgdTyp    ,0, "'managed' not followed by an array in type"          )
SMC_ERR(ERRbadUnmTyp    ,0, "'unmanaged' not followed by an array in type"        )
SMC_ERR(ERRbadArrowNC   ,0, "'->' cannot be used after a namespace or class name" )
SMC_ERR(ERRbadIndir     ,0, "The indirection operator cannot be applied to '%s'"  )
SMC_ERR(ERRlabRedef     ,0, "A label with the name '%s' has already been defined" )
SMC_ERR(ERRundefLab     ,0, "The label '%s' has not been defined"                 )
SMC_ERR(ERRbadBreak     ,0, "'break' is not allowed here, not in a switch or loop")
SMC_ERR(ERRbadCont      ,0, "'continue' is not allowed here, not in a loop"       )
SMC_ERR(ERRbadCase      ,0, "'case' only allowed within 'switch' statements"      )
SMC_ERR(ERRbadDefl      ,0, "'default' only allowed within 'switch' statements"   )
SMC_ERR(ERRdupDefl      ,0, "Duplicate 'default' label in a 'switch' statement"   )
SMC_ERR(ERRdupCaseVal   ,0, "The case label '%s' was specified more than once"    )
SMC_ERR(ERRnoMemName    ,0, "A member name was expected"                          )
SMC_ERR(ERRredefAnMem   ,0, "Type containing anonymous union already has a member '%s'")
SMC_ERR(ERRglobAnon     ,0, "Anonymous unions may only be declared within classes/structs")
SMC_ERR(ERRbadThis      ,0, "'this' can only be used in non-static methods"       )
SMC_ERR(ERRnoWhile      ,0, "A 'do' statement must end with a 'while' condition"  )
SMC_ERR(ERRbadVoid      ,0, "Parameters and variables cannot have type 'void'"    )
SMC_ERR(ERRbadInitSt    ,0, "A variable of type '%s' cannot be initialized this way")
SMC_ERR(ERRinitNotCns   ,0, "A variable initializer must be a constant value"     )
SMC_ERR(ERRnoLinkStr    ,0, "A linkage name string required in import declaration")
SMC_ERR(ERRbadLinkStr   ,0, "Linkage string must look like 'DLLname:entrypoint'"  )
SMC_ERR(ERRbadArrLen    ,0, "The type '%s' is not an acceptable operand for 'arraylen'")
SMC_ERR(ERRcantRet      ,0, "Can't return a value from a 'void' method"           )
SMC_ERR(ERRmisgRet      ,0, "Expected return value of type '%s'"                  )
SMC_ERR(ERRbadOperNm    ,0, "Operator name not valid"                             )
SMC_ERR(ERRintfDM       ,0, "Interfaces may only include methods and constants"   )
SMC_ERR(ERRintfDup      ,0, "Interfaces '%s' has already been specified"          )
SMC_ERR(ERRtypeidOp     ,0, "The 'typeid' operator cannot be applied to type '%s'")
SMC_ERR(ERRbadConcat    ,0, "Cannot concatenate a string and a value of type '%s'")
SMC_ERR(ERRchgClsFlv    ,0, "Type '%s' was declared elsewhere as '%s'"            )
SMC_ERR(ERRnotClsVal    ,0, "Cannot use a value of type '%s' here, class expected")
SMC_ERR(ERRbadOvlOp     ,0, "Overloaded operator must be a 'static' method"       )
SMC_ERR(ERRbadOvlOpC    ,0, "Overloaded operators must have one or two arguments" )
SMC_ERR(ERRbadOvlOp1    ,0, "Overloaded operator '%s' must have one argument"     )
SMC_ERR(ERRbadOvlOp2    ,0, "Overloaded operator '%s' must have two arguments"    )
SMC_ERR(ERRbadOvlOp12   ,0, "Overloaded operator '%s' must have one or two arguments")
SMC_ERR(ERRbadOvlOpT    ,0, "Overloaded operator must take an argument of type '%s'")
SMC_ERR(ERRbadOvlRet    ,0, "Overloaded operator must return '%s'"                )
SMC_ERR(ERRbadOvlAcc    ,0, "Overloaded operator must be declared 'public'        ")
SMC_ERR(ERRbadOvlEq     ,0, "Overloaded operator '%s' must return 'bool'"         )
SMC_ERR(ERRbadOvlCmp    ,0, "Overloaded operator '%s' must return 'int'"          )
SMC_ERR(ERRdefOvlVal    ,0, "Overloaded operator arguments may not have defaults"  )
SMC_ERR(ERRimplAbst     ,0, "Class '%s' is implicitly abstract, it doesn't implement '%s'")
SMC_ERR(ERRabsFNbody    ,0, "Cannot define a body for abstract method '%s'"       )
SMC_ERR(ERRabsPFbody    ,0, "Cannot define a body for abstract property accessor '%s'")
SMC_ERR(ERRabsNotVirt   ,0, "The method '%s' was declared 'abstract' but not 'virtual'")
SMC_ERR(ERRmsgPFbody    ,0, "Missing body for property accessor '%s'"             )
SMC_ERR(ERRintfFNacc    ,0, "Cannot define an interface method to be 'protected' or 'private'")
SMC_ERR(ERRnoPropSym    ,0, "Class '%s' has no '%s' property with the name '%s'"  )
SMC_ERR(ERRnoPropOvl    ,0, "Class '%s' has no '%s' property '%s' that matches the argument list"  )
SMC_ERR(ERRbadBaseCall  ,0, "Use of 'baseclass' is only allowed in a constructor of a class that has a base class")
SMC_ERR(ERRctorRetTP    ,0, "Method name matches that of the class, if you're declaring a constructor please omit the return type")
SMC_ERR(ERRbadAlign     ,0, "Alignment value must be 1,2,4,8,18 or push/pop"      )
SMC_ERR(ERRnoAccess     ,0, "Access to '%s' is not permitted here"                )
SMC_ERR(ERRnotFlx       ,0, "The '%s' function can only be used in a filter expression")
SMC_ERR(ERRnotHnd       ,0, "The '%s' function can only be used in an SEH handler")
SMC_ERR(ERRumgRef       ,0, "References are not allowed for now (use 'out' or 'inout' for byref args)")
SMC_ERR(ERRmgdPtr       ,0, "Pointers to managed classes not allowed: '%s'"       )
SMC_ERR(ERRbyref2refany ,0, "Typed byref's (void &) may not be passed by reference")
SMC_ERR(ERRbadRefArr    ,0, "Cannot declare an unmanaged array of '%s'"           )
SMC_ERR(ERRbadTagMem    ,0, "Tagged unions can only contain fields and methods"   )
SMC_ERR(ERRbadStrCase   ,0, "'case' labels only allowed in tagged union members"  )
SMC_ERR(ERRumgFldMgd    ,0, "Members of unmanaged types may not of be managed type")
SMC_ERR(ERRchgMgmt      ,0, "Management is confused: '%s' was declared earlier as '%s'")
SMC_ERR(ERRrecFld       ,0, "A value type cannot contain a member with its own type")
SMC_ERR(ERRsafeInd      ,0, "Pointer indirection is not allowed in typesafe mode" )
SMC_ERR(ERRsafeDel      ,0, "'delete' is not allowed in typesafe mode"            )
SMC_ERR(ERRsafeArrX     ,0, "Unmanaged array indexing is not allowed in typesafe mode")
SMC_ERR(ERRunsafeCast   ,0, "Cast from '%s' to '%s' is not allowed in typesafe mode")
SMC_ERR(ERRmulEntry     ,0, "Image has more than entry point: '%s' and '%s'"      )
SMC_ERR(ERRnoEntry      ,0, "Image has no entry point, it should be declared as 'void main(String [] args)'")
SMC_ERR(ERRundefUse     ,0, "The value of '%s' may be used before definition"     )
SMC_ERR(ERRbadVarArg    ,0, "varargs functions cannot be used here"               )
SMC_ERR(ERRnotArgIter   ,0, "Expected a local variable of type 'va_list'"         )
SMC_ERR(ERRnotLastArg   ,0, "Expected the last fixed argument of the current function")
SMC_ERR(ERRbadVAtype    ,0, "The type '%s' cannot be used as a vararg type"       )
SMC_ERR(ERRbadDelete    ,0, "'delete' requires a pointer to an unmanaged class"   )
SMC_ERR(ERRnoFnDef      ,0, "No definition was found for method '%s'"             )
SMC_ERR(ERRnoPropGet    ,0, "No definition was found for 'get' accessor of property '%s'")
SMC_ERR(ERRnoPropSet    ,0, "No definition was found for 'set' accessor of property '%s'")
SMC_ERR(ERRbadCFNret    ,0, "A method marked as '@conditional' must return 'void'")
SMC_ERR(ERRbadNameUse   ,0, "'%s' cannot be used in this context"                 )
SMC_ERR(ERRmanyUmgIxx   ,0, "Multiple index expressions may not be used with unmanaged arrays")
SMC_ERR(ERRindexCnt     ,0, "Expected %u index expressions"                       )
SMC_ERR(ERRua2manyDims  ,0, "An unmanaged array may only have one dimension"      )
SMC_ERR(ERRnoDimDcl     ,0, "Expected array dimension or '*'"                     )
SMC_ERR(ERRarrInitCnt   ,0, "Expected %u sub-array initializers, %u found"        )
SMC_ERR(ERRbadVAarg     ,0, "va_arg() expects a va_list value and a type argument")
SMC_ERR(ERRbadTypeExpr  ,0, "Expression, not type '%s', expected here"            )
SMC_ERR(ERRnoBaseInit   ,0, "Base initializer expected after ':': '%s(args)' or 'baseclass(args)'")
SMC_ERR(ERRbadPrgOpt    ,0, "Invalid #pragma option parameter"                    )
SMC_ERR(ERRerrPos       ,0, "Previous diagnostic refers to declaration at %s(%u)" )
SMC_ERR(ERRunknownMD    ,0, "Symbol '%s' references unknown metadata construct(s)")

SMC_ERR(ERRbadMacDef    ,0, "Illegal macro definition for '%s'"                   )
SMC_ERR(ERRmacPlace     ,0, "#define must precede any use of identifier '%s'"     )
SMC_ERR(ERRmacRedef     ,0, "'%s' was referenced before definition as macro"      )

SMC_ERR(ERRdlgNonFn     ,0, "A delegate must be declared as a function"           )
SMC_ERR(ERRdlgCTarg     ,0, "A delegate instance must be created from a bound method")
SMC_ERR(ERRdlgNoMFN     ,0, "No method in '%s' matches '%s'"                      )
SMC_ERR(ERRmulDlgRet    ,0, "A multicast delegate must return 'void'"             )

SMC_ERR(ERRbadAtCmPlc   ,0, "This '@comment' thing not allowed here"              )
SMC_ERR(ERRbadAtCmSubd  ,0, "Invalid '%s' comment sub-directive: '%s'"            )
SMC_ERR(ERRbadAtCmForm  ,0, "Incorrect '%s' comment syntax"                       )
SMC_ERR(ERRnoDLLname    ,0, "Missing DLL name, must be specified on method or class")
SMC_ERR(ERRclsImpName   ,0, "Only DLL name may be specified for a class"          )

SMC_ERR(ERRbadSecActn   ,0, "'%s' is not a recognized security action"            )
SMC_ERR(ERRnonCnsAA     ,0, "Argument %u in attribute arglist is not a constant"  )
SMC_ERR(ERRcustAttrPlc  ,0, "Custom atttribute '%s' not allowed here"             )
SMC_ERR(ERRcustAttrDup  ,0, "Custom atttribute '%s' may not be specified more than once")
SMC_ERR(ERRcustAttrMsk  ,0, "Invalid custom atttribute placement mask"            )

SMC_ERR(ERRnoClsGt      ,0, "'class' or '>' expected"                             )
SMC_ERR(ERRnoCmGt       ,0, "Expected ',' or '>'"                                 )
SMC_ERR(ERRumgGenCls    ,0, "Only managed classes and interfaces may be generic"  )
SMC_ERR(ERRmisgGenArg   ,0, "Expected actual type for generic parameter '%s'"     )
SMC_ERR(ERRgenArg       ,0, "Actual type for parameter '%s' must be a managed class/interface")
SMC_ERR(ERRgenArgBase   ,0, "Actual type for parameter '%s' doesn't have '%s' as a base")
SMC_ERR(ERRgenArgIntf   ,0, "Actual type for parameter '%s' doesn't have '%s' as an interface")
SMC_ERR(ERRgenNested    ,0, "Nested classes may not be generic"                   )

SMC_ERR(ERRbadAttr      ,0, "Attribute syntax incorrect (see compiler file parser.cpp for details)")
SMC_ERR(ERRplcAttr      ,0, "This attribute is not allowed here"                  )
SMC_ERR(ERRbadGUID      ,0, "Invalid GUID string '%s', should be of the form HHHHHHHH-HHHH-HHHH-HHHH-HHHHHHHHHHHH")

#ifdef  SETS
SMC_ERR(ERRnotCollExpr  ,0, "Expected collection expression, not a value of type '%s'")
SMC_ERR(ERRbadSortExpr  ,0, "Expected scalar/string sort expression, not a value of type '%s'")
SMC_ERR(ERRbadConnOps   ,0, "Invlaid operators for 'connect' statement"           )
SMC_ERR(ERRnoOvlOper    ,0, "No overloaded 'operator %s' found in type '%s'"      )
SMC_ERR(ERRimplAmbig    ,0, "Ambiguous use of implicitly scoped name '%s'"        )
SMC_ERR(ERRnoSetCons    ,0, "Operand must be [[]] or a constraint/sort term must be present")
SMC_ERR(ERRignSort      ,0, "Sort clause is meaningless for operand of filter clause")
SMC_ERR(ERRsliceKind    ,0, "Only non-static data members and properties of a collection can be 'sliced'")
SMC_ERR(ERRbadXMLpos    ,0, "Invalid XML element declaration"                     )
SMC_ERR(ERRctorXML      ,0, "Classes with XML elements may not have user-defined constructors")
SMC_ERR(ERRnewXMLextra  ,0, "Excess values specified for XML class instance"      )
SMC_ERR(ERRnewXML2few   ,0, "Not enough values specified for XML class instance"  )
SMC_ERR(ERRnewXMLbadlc  ,0, "Invalid {}-style argument for XML class member '%s'" )
SMC_ERR(ERRmultImpl     ,0, "Cannot have multiple implicit scopes (for now)"      )
SMC_ERR(ERRmixCollSngl  ,0, "Cannot mix collection and singleton source values"   )
SMC_ERR(ERRbadPrjx      ,0, "Expected collection or class/struct expression"      )
#endif

// All warnings must be here at the end (i.e. no errors allowed after the warnings)

SMC_WR1(WRNasgNoUse     ,0, "Local variable '%s' is initialized but never used"   )
SMC_WRN(WRNbadPragma    ,0, "Unrecognized #pragma directive '%s' ignored"         )
SMC_WRN(WRNbadPrep      ,1, "Ignoring unrecognized directive '#%s'"               )
SMC_WRN(WRNignoreCV     ,0, "Ignoring const/volatile modifier"                    )
SMC_WRN(WRNenumComp     ,0, "Comparing values of two different enum types"        )
SMC_WRN(WRNloseBits     ,1, "Conversion from '%s' to '%s' may lose precision"     )
SMC_WRN(WRNzeroPtr      ,1, "Using '0' instead of 'null' is in poor style"        )
SMC_WRN(WRNvoidFnc      ,1, "Using '(void)' for parameterless functions is obsolete")
SMC_WRN(WRNignoreLnk    ,1, "C++ external linkage specifier ignored"              )
SMC_WRN(WRNgeneric      ,1, "%s"                                                  )
SMC_WRN(WRNunkAttr      ,1, "Ignoring unrecognized attribute '%s'"                )
SMC_WRN(WRNnoArgName    ,0, "Argument declaration without a name"                 )
SMC_WRN(WRNunreach      ,1, "Unreachable code"                                    )
SMC_WRN(WRNimplAbst     ,1, "Class '%s' is implicitly abstract, it doesn't implement '%s'")
SMC_WRN(WRNbadAtCm      ,1, "Unrecognized comment directive '%s' ignored"         )
SMC_WRN(WRNignAtCm      ,1, "Ignoring comment directive '%s'"                     )
SMC_WRN(WRNmgdBF        ,1, "Ignoring bitfield declaration in a managed class"    )
SMC_WRN(WRNbadMgdStr    ,1, "Unions should not be declared 'managed', it doesn't really work right now")
SMC_WRN(WRNundefUse     ,1, "The value of '%s' may be used before definition"     )
SMC_WRN(WRNnoFnDef      ,1, "No definition was found for method '%s'"             )
SMC_WRN(WRNignoring     ,1, "Ignoring %s"                                         )
SMC_WRN(WRNnoNSnm       ,1, "Ignoring 'using %s' - it doesn't denote a namespace" )
SMC_WRN(WRNdepCall      ,1, "Call to deprecated method '%s'"                      )
SMC_WRN(WRNdepCls       ,1, "Use of deprecated class '%s'"                        )
SMC_WRN(WRNdepFld       ,1, "Use of deprecated field '%s'"                        )
SMC_WRN(WRNdepProp      ,1, "Use of deprecated property '%s'"                     )
SMC_WRN(WRNdepEnum      ,1, "Use of deprecated enum value '%s'"                   )
SMC_WRN(WRNmacroArgs    ,1, "Pre-processor macros with arguments not supported, ignoring #define directive")
SMC_WRN(WRNconvert      ,1, "Converting value of type '%s' to '%s'"               )
SMC_WRN(WRNbadEsc       ,1, "Unrecognized escape sequence \\%c"                   )
SMC_WRN(WRNskipAtCm     ,1, "Found '@' gizmo in regular comment, ignoring it"     )
SMC_WRN(WRNstmtNoUse    ,1, "Outermost statement expression has no side effect"   )
SMC_WRN(WRNpgm2big      ,1, "Image size exceeds specified maximum: 0x%08X vs. 0x%08X")
SMC_WRN(WRNimplOut      ,1, "Argument %u may be modified by the call to '%s'"     )
SMC_WRN(WRNenum2str     ,1, "Converting '%s' to String using its underlying integer type")
SMC_WRN(WRNunsConst     ,1, "Implicit conversion of a negative constant to an unsigned type")
SMC_WRN(WRNaddStrings   ,0, "Using '+' to concatenate strings is deprecated, please use '%%%%'")
SMC_WRN(WRNstrRefCmp    ,9, "Comparing String references doesn't compare the string values")
SMC_WRN(WRNhideVirt     ,0, "Base class member function '%s' hidden, not overloaded")
SMC_WRN(WRNobsoleteStr  ,1, "'%s' has been marked as obsolete: '%s'"              )
SMC_WRN(WRNoperPrec     ,1, "Comparisons have precedence over bitwise operators, did you forget parens?"  )
SMC_WRN(WRNctxFlavor    ,1, "Implicit conversion from '%s' to '%s' may cause context grief")
SMC_WRN(WRNobsolete     ,9, "Obsolete language feature used: %s"                  )
SMC_WRN(WRNstrValCmp    ,1, "Relational operator compares string values"          )
SMC_WRN(WRNenumConv     ,0, "Mixing values of two different enum types"           )
SMC_WRN(WRNlongDiff     ,1, "Use of 'long' is not encouraged, please use 'longint'")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\corexp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "genIL.h"

//////////////////////////////////////////////////////////////////////////////
//
//  The following flags have not yet been converted to the new format (custom
//  atrributes):
//
//      System.Runtime.InteropServices.ComImportAttribute     tdImport
//      System.Runtime.InteropServices.DllImportAttribute     PInvoke stuff
//      System.Runtime.InteropServices.MethodImplAttribute    miPreserveSig, miSynchronized, etc
//
//  The following one needs to be done in comp.cpp:
//
//      System.Runtime.InteropServices.GuidAttribute          guid in ModuleRec

/*****************************************************************************
 *
 *  Map the access level of a type / member to MD flags.
 */

unsigned            ACCtoFlags(SymDef sym)
{
    static
    unsigned        accFlags[] =
    {
        0,              // ACL_ERROR
        mdPublic,       // ACL_PUBLIC
        mdFamily,       // ACL_PROTECTED
        mdFamORAssem,   // ACL_DEFAULT
        mdPrivate,      // ACL_PRIVATE
    };

    assert(accFlags[ACL_PRIVATE  ] == mdPrivate);
    assert(accFlags[ACL_DEFAULT  ] == mdFamORAssem);
    assert(accFlags[ACL_PROTECTED] == mdFamily);
    assert(accFlags[ACL_PUBLIC   ] == mdPublic);

    assert(sym->sdAccessLevel != ACL_ERROR);
    assert(sym->sdAccessLevel < arraylen(accFlags));

    return  accFlags[sym->sdAccessLevel];
}

/*****************************************************************************
 *
 *  Map our type to a metadata type.
 */

BYTE                intrinsicSigs[] =
{
    ELEMENT_TYPE_END,       // TYP_UNDEF
    ELEMENT_TYPE_VOID,      // TYP_VOID
    ELEMENT_TYPE_BOOLEAN,   // TYP_BOOL
    ELEMENT_TYPE_CHAR,      // TYP_WCHAR

    ELEMENT_TYPE_I1,        // TYP_CHAR
    ELEMENT_TYPE_U1,        // TYP_UCHAR
    ELEMENT_TYPE_I2,        // TYP_SHORT
    ELEMENT_TYPE_U2,        // TYP_USHORT
    ELEMENT_TYPE_I4,        // TYP_INT
    ELEMENT_TYPE_U4,        // TYP_UINT
    ELEMENT_TYPE_I,         // TYP_NATINT
    ELEMENT_TYPE_U,         // TYP_NATUINT
    ELEMENT_TYPE_I8,        // TYP_LONG
    ELEMENT_TYPE_U8,        // TYP_ULONG
    ELEMENT_TYPE_R4,        // TYP_FLOAT
    ELEMENT_TYPE_R8,        // TYP_DOUBLE
    ELEMENT_TYPE_R8,        // TYP_LONGDBL
    ELEMENT_TYPE_TYPEDBYREF,// TYP_REFANY
};

#if 0
unsigned        cycles()
{
__asm   push    EDX
__asm   _emit   0x0F
__asm   _emit   0x31
__asm   pop     EDX
};
#endif

/*****************************************************************************
 *
 *  Attach the given security specification to the typedef/methoddef token.
 */

void                compiler::cmpSecurityMD(mdToken token, SymXinfo infoList)
{
    while (infoList)
    {
        SecurityInfo    secInfo;
        CorDeclSecurity secKind;
        ConstStr        secStr;

        wchar    *      strStr;
        size_t          strLen;

        mdPermission    secTok;

        wchar           secBuff[300];

        /* Ignore the entry if it's not a security thing */

        if  (infoList->xiKind != XI_SECURITY)
            goto NEXT;

        /* Get hold of the descriptor and the action kind */

        secInfo = ((SymXinfoSec)infoList)->xiSecInfo;
        secKind = secInfo->sdSpec;

        /* What kind of a security thing do we have? */

        if  (secInfo->sdIsPerm)
        {
            const   char *  name;
            PairList        list;

            /* Form the fully qualified name of the class */

            name = cmpGlobalST->stTypeName(NULL, secInfo->sdPerm.sdPermCls, NULL, NULL, true);

            /* Start creating the monstrosity */

            wcscpy(secBuff                  , L"<PermissionSpecification><PermissionSet><Permission><Class><Name>");
            wcscpy(secBuff + wcslen(secBuff), cmpUniConv(name, strlen(name) + 1));
            wcscpy(secBuff + wcslen(secBuff), L"</Name></Class><StateData>");

            for (list = secInfo->sdPerm.sdPermVal; list; list = list->plNext)
            {
                wcscpy(secBuff + wcslen(secBuff), L"<Param><Name>");
                wcscpy(secBuff + wcslen(secBuff), cmpUniConv(list->plName));
                wcscpy(secBuff + wcslen(secBuff), L"</Name><Value>");
                wcscpy(secBuff + wcslen(secBuff), list->plValue ? L"true" : L"false");
                wcscpy(secBuff + wcslen(secBuff), L"</Value></Param>");
            }

            wcscpy(secBuff + wcslen(secBuff), L"</StateData></Permission></PermissionSet></PermissionSpecification>");
        }
        else
        {
            secStr = secInfo->sdCapbStr;
            strLen = secStr->csLen;
            strStr = cmpUniConv(secStr->csStr, strLen+1);

            wcscpy(secBuff          , L"<PermissionSpecification><CapabilityRef>");

            if  (*strStr == '{')
            {
                wcscpy(secBuff + wcslen(secBuff), L"<GUID>");
                wcscpy(secBuff + wcslen(secBuff), strStr);
                wcscpy(secBuff + wcslen(secBuff), L"</GUID>");
            }
            else
            {
                wcscpy(secBuff + wcslen(secBuff), L"<URL>");
                wcscpy(secBuff + wcslen(secBuff), strStr);
                wcscpy(secBuff + wcslen(secBuff), L"</URL>");
            }

            wcscpy(secBuff + wcslen(secBuff), L"</CapabilityRef></PermissionSpecification>");
        }

        assert(wcslen(secBuff) < arraylen(secBuff));

//      printf("Permission string [%u]: '%ls\n", wcslen(secBuff), secBuff);

        cycleCounterPause();

//      unsigned beg = cycles();
//      static unsigned tot;

#if     1

        if  (FAILED(cmpWmde->DefinePermissionSet(token,
                                                 secKind,
                                                 secBuff,
                                                 wcslen(secBuff)*sizeof(*secBuff),
                                                 &secTok)))
        {
#ifdef  DEBUG
            printf("Bad news - permission set string didn't pass muster:\n");
            printf("    '%ls'\n", secBuff);
#endif
            cmpFatal(ERRmetadata);
        }

#endif

//      unsigned end = cycles();
//      tot += end - beg - 10;
//      printf("cycle count = %u (%6.3lf sec)\n", end - beg - 10, (end - beg)/450000000.0);
//      printf("total count = %u (%6.3lf sec)\n",            tot,        tot /450000000.0);

        cycleCounterResume();

    NEXT:

        infoList = infoList->xiNext;
    }
}

/*****************************************************************************
 *
 *  Attach a simple custom attribute to the given token.
 */

void                compiler::cmpAttachMDattr(mdToken       target,
                                              wideStr       oldName,
                                              AnsiStr       newName,
                                              mdToken     * newTokPtr,
                                              unsigned      valTyp,
                                              const void  * valPtr,
                                              size_t        valSiz)
{
    /* Have we created the appropriate token yet ? */

    if  (*newTokPtr == 0)
    {
        wchar               nameBuff[MAX_CLASS_NAME];
        mdToken             tref;

        unsigned            sigSize;
        COR_SIGNATURE       sigBuff[6];

        // Should use real class here, the following might create dups!

#if 0
        wcscpy(nameBuff, L"System/Attributes/");
        wcscat(nameBuff, oldName);
#else
        wcscpy(nameBuff, oldName);
#endif

        cycleCounterPause();

        if  (cmpWmde->DefineTypeRefByName(mdTokenNil, nameBuff, &tref))
            cmpFatal(ERRmetadata);

        cycleCounterResume();

        /* Form the signature - one or no arguments */

        sigBuff[0] = IMAGE_CEE_CS_CALLCONV_DEFAULT|IMAGE_CEE_CS_CALLCONV_HASTHIS;
        sigBuff[1] = 0;
        sigBuff[2] = ELEMENT_TYPE_VOID;

        sigSize = 3;

        if  (valTyp)
        {
            sigBuff[1] = 1;
            sigBuff[3] = valTyp; sigSize++;
        }

        /* Create the methodref for the constructor */

        cycleCounterPause();

        if  (cmpWmde->DefineMemberRef(tref, L".ctor", sigBuff, sigSize, newTokPtr))
            cmpFatal(ERRmetadata);

        cycleCounterResume();
    }

    /* Add the custom attribute to the target token */

    cycleCounterPause();

    if  (cmpWmde->DefineCustomAttribute(target, *newTokPtr, valPtr, valSiz, NULL))
        cmpFatal(ERRmetadata);

    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Attach any custom attributes in the given list to the given token.
 */

void                compiler::cmpAddCustomAttrs(SymXinfo infoList, mdToken owner)
{
    cycleCounterPause();

    while (infoList)
    {
        if  (infoList->xiKind == XI_ATTRIBUTE)
        {
            mdToken         ctrTok;

            SymXinfoAttr    entry   = (SymXinfoAttr)infoList;
            SymDef          ctorSym = entry->xiAttrCtor;

            /* Careful - we need to avoid out-of-order methoddef emission */

            if  (ctorSym->sdIsImport || ctorSym->sdFnc.sdfMDtoken)
            {
                ctrTok = cmpILgen->genMethodRef(ctorSym, false);
            }
            else
            {
                /*
                    The following is just plain horrible. We need to get
                    the token for the ctor, but if the ctor is defined
                    locally and its methoddef hasn't been generated yet,
                    we have to create a (redundant) methodref instead.
                 */

                if  (cmpFakeXargsVal == NULL)
                     cmpFakeXargsVal = cmpCreateExprNode(NULL, TN_NONE, cmpTypeVoid);

                ctrTok = cmpGenFncMetadata(ctorSym, cmpFakeXargsVal);

                assert(ctorSym->sdFnc.sdfMDtoken == ctrTok); ctorSym->sdFnc.sdfMDtoken = 0;
            }

            if  (cmpWmde->DefineCustomAttribute(owner,
                                                ctrTok,
                                                entry->xiAttrAddr,
                                                entry->xiAttrSize,
                                                NULL))
            {
                cmpFatal(ERRmetadata);
            }
        }

        infoList = infoList->xiNext;
    }

    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Generate metadata for the given function symbol (and, if the symbol is
 *  a method of a class, make sure the metadata for that class is also
 *  generated).
 *
 *  If the "xargs" value is non-zero, we're supposed to create a varargs
 *  signature and the "xargs" value gives the arguments passed to "...".
 */

mdToken             compiler::cmpGenFncMetadata(SymDef fncSym, Tree xargs)
{
    WMetaDataEmit * emitIntf;

    SymXinfoLnk     linkInfo;

    bool            isIntfFnc;
    SymDef          ownerSym;
    mdTypeDef       ownerTD;

    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    wchar   *       fncName;
    mdToken         fncTok;
    TypDef          fncTyp;

    bool            mangle;

    bool            genref = false;

    unsigned        flags;

    /* Don't do this twice for the same method */

    if  (fncSym->sdFnc.sdfMDtoken && !xargs)
        return  fncSym->sdFnc.sdfMDtoken;

    /* Is this method conditionally disabled? */

    if  (fncSym->sdFnc.sdfDisabled)
    {
        fncSym->sdFnc.sdfMDtoken = -1;
        return  -1;
    }

    /* Get hold of the function type */

    fncTyp = fncSym->sdType; assert(fncTyp->tdTypeKind == TYP_FNC);

    /* Get hold of any linkage information that may be present */

    linkInfo  = cmpFindLinkInfo(fncSym->sdFnc.sdfExtraInfo);

    /* Figure out the owning type, whether we need to mangle the name, etc. */

    ownerSym  = fncSym->sdParent;
    isIntfFnc = false;

    if  (ownerSym->sdSymKind == SYM_CLASS)
    {
        if  (xargs)
        {
            if  (xargs == cmpFakeXargsVal)
            {
                mdToken         savedTD;

                /*
                    This is the awful case where we have a reference to
                    a method that is defined in the current compilation
                    but we haven't generated it's methoddef yet; we can
                    not simply ask for the methoddef right now because
                    that would cause metadata output ordering  to get
                    messed up. Rather, we just emit a (redundant) ref
                    for the method (and if necessary a typeref for its
                    class as well).
                 */

                xargs = NULL;

                savedTD = ownerSym->sdClass.sdcMDtypedef;
                          ownerSym->sdClass.sdcMDtypedef = 0;

                ownerTD = cmpGenClsMetadata(ownerSym, true);

                          ownerSym->sdClass.sdcMDtypedef = savedTD;

//              printf("Stupid ref [%08X] to '%s'\n", ownerTD, cmpGlobalST->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true));

                genref  = true;
            }
            else
            {
                /* Is the method an external import ? */

                if  (fncSym->sdIsImport)
                {
                    /* Generate a typeref for the containing class */

                    ownerTD = ownerSym->sdClass.sdcMDtypeImp;

                    if  (!ownerTD)
                    {
                        cmpMakeMDimpTref(ownerSym);
                        ownerTD = ownerSym->sdClass.sdcMDtypeImp;
                    }
                }
                else
                {
                    /* Class defined locally, just use its typedef token */

                    ownerTD = fncSym->sdFnc.sdfMDtoken;
                }
            }

            assert(ownerTD);
        }
        else
        {
            /* Get hold of the appropriate class token */

            ownerTD = ownerSym->sdClass.sdcMDtypedef;

            if  (!ownerTD)
            {
                /* Generate metadata for the containing class */

                cmpGenClsMetadata(ownerSym);

                /* The class should now have a typedef */

                ownerTD = ownerSym->sdClass.sdcMDtypedef; assert(ownerTD);
            }

            /* May have called recursively */

            if  (fncSym->sdFnc.sdfMDtoken && !xargs)
                return  fncSym->sdFnc.sdfMDtoken;
        }

        mangle = false;

        if  (ownerSym->sdClass.sdcFlavor == STF_INTF)
            isIntfFnc = true;
    }
    else
    {
        /* This is a global/namespace function */

        ownerTD = 0;
        mangle  = false;

        /* Has this function been defined or is it external? */

        if  (!fncSym->sdIsDefined && !linkInfo && !xargs)
        {
            /* Is this a fake function? */

            if  ((hashTab::getIdentFlags(fncSym->sdName) & IDF_PREDEF) && fncSym->sdParent == cmpGlobalNS)
            {
                return  (fncSym->sdFnc.sdfMDtoken = -1);
            }
        }
    }

    /* Figure out the flags */

    flags  = 0;

    if  (fncSym->sdIsMember && !mangle)
    {
        flags |= ACCtoFlags(fncSym);

#if STATIC_UNMANAGED_MEMBERS
        if  (!ownerSym->sdType->tdIsManaged)
        {
            flags |= mdStatic;
        }
        else
#endif
        if  (fncSym->sdIsStatic)
        {
            assert(fncSym->sdFnc.sdfVirtual == false);
            assert(fncSym->sdIsAbstract     == false);

            flags |= mdStatic;
        }
        else
        {
            if  (fncSym->sdIsAbstract)
                flags |= mdAbstract;

            if  (fncSym->sdFnc.sdfVirtual && fncSym->sdAccessLevel != ACL_PRIVATE)
                flags |= mdVirtual;

            if  (fncSym->sdIsSealed)
            {
                flags |= mdFinal;


            }
        }
    }
    else
    {
        flags |= mdStatic|mdPublic;
    }

#ifndef __SMC__
//  if  (!strcmp(fncSym->sdSpelling(), "cmpError") && !xargs)
//      printf("Define method def for [%08X] '%s'\n", fncSym, cmpGlobalST->stTypeName(NULL, fncSym, NULL, NULL, true));
//  if  (!strcmp(      fncSym->sdSpelling(), "cmpGenError") && xargs)
//  if  (!strcmp(cmpCurFncSym->sdSpelling(), "cmpDeclClass"))
//      printf("This is the bug, set a breakpoint at %s(%u)\n", __FILE__, __LINE__);
//  if  (!strcmp(fncSym->sdSpelling(), "")) forceDebugBreak();
#endif

    /* Create a signature for the method */

    sigPtr = (PCOR_SIGNATURE)cmpGenMemberSig(fncSym, xargs, fncTyp, NULL, &sigLen);

    /* Get hold of the function name, or make one up */

    if  (fncSym)
    {
        const   char *  symName;

        if  (fncSym->sdFnc.sdfCtor)
        {
            symName = fncSym->sdIsStatic ? OVOP_STR_CTOR_STAT
                                         : OVOP_STR_CTOR_INST;

            flags |= mdSpecialName;
        }
        else
        {
            flags |= mdSpecialName;

            if  (fncSym->sdFnc.sdfOper == OVOP_NONE)
            {
                symName = fncSym->sdName->idSpelling();

                if  (!fncSym->sdFnc.sdfProperty)
                    flags &= ~mdSpecialName;
            }
            else
            {
                assert(cmpConfig.ccNewMDnames);

//              printf("Setting 'special name' bit for '%s' -> '%s'\n", fncSym->sdSpelling(), MDovop2name(fncSym->sdFnc.sdfOper));

                symName = MDovop2name(fncSym->sdFnc.sdfOper); assert(symName);
            }
        }

        fncName = cmpUniConv(symName, strlen(symName)+1);
    }
    else
    {
        fncName = L"fptr";
    }

    /* Create the method metadata definition */

    emitIntf = cmpWmde;

    if  (xargs || genref)
    {
        cycleCounterPause();

#if 1
        if  (FAILED(emitIntf->DefineMemberRef(ownerTD,  // owning typedef
                                              fncName,  // function name
                                              sigPtr,   // signature addr
                                              sigLen,   // signature len
                                              &fncTok)))// the resulting token
        {
            cmpFatal(ERRmetadata);
        }
#else
        int ret =   emitIntf->DefineMemberRef(ownerTD,  // owning typedef
                                              fncName,  // function name
                                              sigPtr,   // signature addr
                                              sigLen,   // signature len
                                              &fncTok); // the resulting token
        if  (FAILED(ret))
            cmpFatal(ERRmetadata);
        if  (ret)
            printf("Duplicate member ref %04X for '%s'\n", fncTok, cmpGlobalST->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true));
#endif

        cycleCounterResume();

        if  (!xargs)
            fncSym->sdFnc.sdfMDtoken = fncTok;
    }
    else
    {
        bool            genArgNames;
        unsigned        implFlags;
        SymXinfo        funcInfo;

        SymXinfoAtc     clsMeth;
        MethArgInfo     clsArgs;

        /* Get hold of any "extra" information attached to the function */

        funcInfo  = fncSym->sdFnc.sdfExtraInfo;

        /* Is this a fake method supplied by the runtime? */

        implFlags = fncSym->sdFnc.sdfRThasDef ? miRuntime
                                              : miIL;

        /* Do we have a linkage specification for the function? */

        if  (linkInfo)
            flags |= mdPinvokeImpl;

        /* Do we have explicit method argument info? */

        clsMeth = NULL;
        clsArgs = NULL;

        if  (funcInfo)
        {
            SymXinfoAtc     clsTemp;

            /* Look for a @com.method entry */

            clsMeth = cmpFindATCentry(funcInfo, AC_COM_METHOD);

            /* Look for a @com.params entry */

            clsTemp = cmpFindATCentry(funcInfo, AC_COM_PARAMS);
            if  (clsTemp)
               clsArgs = clsTemp->xiAtcInfo->atcInfo.atcParams;
        }

        /* Is this a native method? */

        if  (fncSym->sdFnc.sdfNative && !linkInfo)
            implFlags |= miInternalCall;

        /* Has the function been marked for exclusive access? */

        if  (fncSym->sdFnc.sdfExclusive)
            implFlags |= miSynchronized;

        /* Is the function an unmanaged import ? */

        if  (linkInfo)  // ISSUE: this may not be the correct condition for the flag
            implFlags |= miPreserveSig;

//      printf("NOTE: define method MD for '%s'\n", cmpGlobalST->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true)); fflush(stdout);

//      static int x; if (++x == 0) forceDebugBreak();

        cycleCounterPause();

        if  (emitIntf->DefineMethod(ownerTD,    // owning typedef
                                    fncName,    // function name
                                    flags,      // method attrs
                                    sigPtr,     // signature addr
                                    sigLen,     // signature len
                                    0,          // RVA (fill in later)
                                    implFlags,  // impl flags
                                    &fncTok))   // the resulting token
        {
            cmpFatal(ERRmetadata);
        }

        if  (fncSym->sdFnc.sdfIntfImpl)
        {
            SymDef          ifncSym;
            mdToken         ifncTok;

            /* Get hold of the method being implemented */

            ifncSym = fncSym->sdFnc.sdfIntfImpSym; assert(ifncSym);
            ifncTok = ifncSym->sdFnc.sdfMDtoken;   assert(ifncTok);

            if  (emitIntf->DefineMethodImpl(ownerTD,    // owning typedef
                                            fncTok,     // Method Body
                                            ifncTok))   // interface method token
            {
                cmpFatal(ERRmetadata);
            }
        }

        cycleCounterResume();

        fncSym->sdFnc.sdfMDtoken = fncTok;

        /* Do we need to generate extended argument attributes? */

        genArgNames = (linkInfo || cmpConfig.ccParamNames
                                || cmpConfig.ccGenDebug
                                || fncTyp->tdFnc.tdfArgs.adAttrs);

        if  (fncTyp->tdFnc.tdfArgs.adExtRec || genArgNames)
        {
            ArgDef          argList;
            MarshalInfo     argInfo;

            unsigned        argNum = 1;
            bool            argExt = fncTyp->tdFnc.tdfArgs.adExtRec;

            /* Should we generate marshalling info for the return type? */

            if  (isIntfFnc || clsArgs)
            {
                MethArgInfo     argTemp;
                mdToken         argTok;

                /* Output the return type entry (as argument #0) */

                cycleCounterPause();

                if  (emitIntf->DefineParam(fncTok,            // method
                                           0,                 // argument #
                                           NULL,              // argument name
                                           pdOut,             // attributes
                                           ELEMENT_TYPE_VOID, // default val type
                                           NULL,              // default val value
                                           -1,
                                           &argTok))          // the resulting token
                {
                    cmpFatal(ERRmetadata);
                }

                cycleCounterResume();

                /* Generate marshalling info */

                argInfo = NULL;

                for (argTemp = clsArgs; argTemp; argTemp = argTemp->methArgNext)
                {
                    if  (!argTemp->methArgName)
                        continue;

                    if  (hashTab::tokenOfIdent(argTemp->methArgName) == tkRETURN)
                    {
                        argInfo = &argTemp->methArgDesc;
                        break;
                    }
                }

                cmpGenMarshalInfo(argTok, fncTyp->tdFnc.tdfRett, argInfo);
            }

            /* Are we adding an explicit "this" argument ? */

#if STATIC_UNMANAGED_MEMBERS

            if  (!fncSym->sdIsManaged && fncSym->sdIsMember)
            {
                if  (genArgNames) // || argExt)
                {
                    mdToken         argTok;

                    cycleCounterPause();

                    if  (emitIntf->DefineParam(fncTok,            // method
                                               argNum,            // argument #
                                               L"this",           // argument name
                                               0,                 // attributes
                                               ELEMENT_TYPE_VOID, // default val type
                                               NULL,              // default val value
                                               0,                 // default value length
                                               &argTok))          // the resulting token
                    {
                        cmpFatal(ERRmetadata);
                    }

                    cycleCounterResume();
                }

                argNum++;
            }

#endif

            /* Process the "real" arguments */

            for (argList = fncTyp->tdFnc.tdfArgs.adArgs;
                 argList;
                 argList = argList->adNext, argNum++)
            {
                wchar   *       argName  = NULL;
                unsigned        argFlags;
                unsigned        argDefTp = ELEMENT_TYPE_VOID;
                void    *       argDefVP = NULL;

                /* Figure out the argument mode */

                argFlags = 0;

                if  (argExt)
                {
                    unsigned        tmpFlags;
                    ArgExt          argXdsc = (ArgExt)argList;

                    assert(argList->adIsExt);

                    tmpFlags = argXdsc->adFlags;

                    if      (tmpFlags & (ARGF_MODE_OUT|ARGF_MODE_INOUT))
                    {
                        if  (tmpFlags & ARGF_MODE_INOUT)
                            argFlags = pdOut|pdIn;
                        else
                            argFlags = pdOut;
                    }
                    else if (tmpFlags & ARGF_MARSH_ATTR)
                    {
                        SymXinfo        attr = argXdsc->adAttrs;

                        assert(attr && attr->xiNext == NULL
                                    && attr->xiKind == XI_MARSHAL);

                        SymXinfoCOM     desc = (SymXinfoCOM)attr;
                        MarshalInfo     info = desc->xiCOMinfo;

//                      printf("Arg mode = %d/%d\n", info->marshModeIn, info->marshModeOut);

                        if  (info->marshModeIn ) argFlags = pdIn;
                        if  (info->marshModeOut) argFlags = pdOut;
                    }

                    /* Is there a default value? */

//                  if  (argXdsc->adFlags & ARGF_DEFVAL)
//                  {
//                      argFlags |= pdHasDefault;
//                  }
                }

                /* Do we have explicit marshalling info for the argument? */

                if  (clsArgs)
                {
                    /* Replace the mode value with the info given */

                    argFlags &= ~(pdIn|pdOut);

                    if  (clsArgs->methArgDesc.marshModeIn ) argFlags |= pdIn;
                    if  (clsArgs->methArgDesc.marshModeOut) argFlags |= pdOut;
                }

                /* If we need to, output the argument name */

                if  (genArgNames && argList->adName)
                    argName = cmpUniConv(argList->adName);

                /* Do we have anything worth saying about this parameter? */

                if  (argName  != NULL ||
                     argFlags != 0    ||
                     argDefVP != NULL || linkInfo || clsArgs || fncTyp->tdFnc.tdfArgs.adAttrs)
                {
                    mdToken         argTok;

                    cycleCounterPause();

                    if  (emitIntf->DefineParam(fncTok,        // method
                                               argNum,        // argument #
                                               argName,       // argument name
                                               argFlags,      // attributes
                                               argDefTp,      // default val type
                                               argDefVP,      // default val value
                                               -1,
                                               &argTok))      // the resulting token
                    {
                        cmpFatal(ERRmetadata);
                    }

                    cycleCounterResume();

                    /* Do we have explicit marshalling info for the argument? */

                    if  (clsArgs)
                    {
                        /* Output native marshalling information */

                        cmpGenMarshalInfo(argTok, argList->adType, &clsArgs->methArgDesc);

                        /* Skip past the current argument */

                        clsArgs = clsArgs->methArgNext;
                    }
                    else if (fncTyp->tdFnc.tdfArgs.adAttrs)
                    {
                        ArgExt          argXdsc  = (ArgExt)argList;
                        unsigned        argFlags = argXdsc->adFlags;

                        assert(argExt && argList->adIsExt);

                        if  (argFlags & ARGF_MARSH_ATTR)
                        {
                            SymXinfo        attr = argXdsc->adAttrs;

                            assert(attr && attr->xiNext == NULL
                                        && attr->xiKind == XI_MARSHAL);

                            SymXinfoCOM     desc = (SymXinfoCOM)attr;
                            MarshalInfo     info = desc->xiCOMinfo;

                            if  (argFlags & (ARGF_MODE_OUT|ARGF_MODE_INOUT))
                            {
                                info->marshModeOut = true;

                                if  (argFlags & ARGF_MODE_INOUT)
                                    info->marshModeIn = true;
                            }

                            cmpGenMarshalInfo(argTok, argList->adType, info);
                        }
                    }
                }
            }
        }

        /* Has the function been marked as "deprecated" ? */

        if  (fncSym->sdIsDeprecated)
        {
            cmpAttachMDattr(fncTok, L"System.ObsoleteAttribute",
                                     "System.ObsoleteAttribute", &cmpAttrDeprec); // , ELEMENT_TYPE_STRING);
        }

        /* Do we have a linkage specification for the function? */

        if  (linkInfo)
        {
            const   char *  DLLname;
            size_t          DLLnlen;
            const   char *  SYMname;
            size_t          SYMnlen;

            mdModuleRef     modRef;
            unsigned        flags;

            /* Get hold of the name strings */

            DLLname = linkInfo->xiLink.ldDLLname; assert(DLLname);
            DLLnlen = strlen(DLLname);
            SYMname = linkInfo->xiLink.ldSYMname; if (!SYMname) SYMname = fncSym->sdSpelling();
            SYMnlen = strlen(SYMname);

            /* Get hold of a module ref for the DLL */

            cycleCounterPause();

            if  (FAILED(emitIntf->DefineModuleRef(cmpUniConv(DLLname, DLLnlen+1),
                                                  &modRef)))
            {
                cmpFatal(ERRmetadata);
            }

            cycleCounterResume();

            /* Figure out the attributes */

            switch (linkInfo->xiLink.ldStrings)
            {
            default: flags = pmCharSetNotSpec; break;
            case  1: flags = pmCharSetAuto   ; break;
            case  2: flags = pmCharSetAnsi   ; break;
            case  3: flags = pmCharSetUnicode; break;
            }

            if  (linkInfo->xiLink.ldLastErr)
                flags |= pmSupportsLastError;

            // UNDONE: Don't hard-wire calling convention

#if 1

            if  (!strcmp(DLLname, "msvcrt.dll"))
            {
                flags |= pmCallConvCdecl;

//              if  (linkInfo->xiLink.ldCallCnv != CCNV_CDECL)
//                  printf("WARNING: %s::%s isn't cdecl \n", DLLname, SYMname);
            }
            else
            {
                flags |= pmCallConvStdcall;

//              if  (linkInfo->xiLink.ldCallCnv != CCNV_WINAPI)
//                  printf("WARNING: %s::%s isn't winapi\n", DLLname, SYMname);
            }

#else

            switch (linkInfo->xiLink.ldCallCnv)
            {
            case CCNV_CDECL  : flags |= pmCallConvCdecl  ; break;
            case CCNV_WINAPI : flags |= pmCallConvWinapi ; break;
            case CCNV_STDCALL: flags |= pmCallConvStdcall; break;
            default:         /* ??????????????????????? */ break;
            }

#endif

            /* Now set the PInvoke info on the method */

            cycleCounterPause();

            if  (emitIntf->DefinePinvokeMap(fncTok,
                                            flags,
                                            cmpUniConv(SYMname, SYMnlen+1),
                                            modRef))
            {
                cmpFatal(ERRmetadata);
            }

            cycleCounterResume();
        }

        /* Do we have any security specifications for the function? */

        if  (cmpFindSecSpec(funcInfo))
            cmpSecurityMD(fncSym->sdFnc.sdfMDtoken, funcInfo);

        /* Do we have a vtable slot specification for the method? */

        if  (clsMeth)
        {
            assert(clsMeth->xiAtcInfo);
            assert(clsMeth->xiAtcInfo->atcFlavor == AC_COM_METHOD);

//          printf("VTslot=%2d, DISPID=%2d for '%s'\n", clsMeth->xiAtcInfo->atcInfo.atcMethod.atcVToffs,
//                                                      clsMeth->xiAtcInfo->atcInfo.atcMethod.atcDispid,
//                                                      fncSym->sdSpelling());
        }

        /* Look for any custom attributes that the method might have */

        if  (funcInfo)
            cmpAddCustomAttrs(funcInfo, fncTok);
    }

    return  fncTok;
}

/*****************************************************************************
 *
 *  Generate metadata for the given function signature.
 */

mdSignature         compiler::cmpGenSigMetadata(TypDef fncTyp, TypDef pref)
{
    assert(fncTyp->tdTypeKind == TYP_FNC);

    if  (!fncTyp->tdFnc.tdfPtrSig)
    {
        PCOR_SIGNATURE  sigPtr;
        size_t          sigLen;
        mdSignature     sigTok;

        /* Create a signature for the method */

        sigPtr = (PCOR_SIGNATURE)cmpGenMemberSig(NULL, NULL, fncTyp, pref, &sigLen);

        /* Get a token for the signature */

        cycleCounterPause();

        if  (FAILED(cmpWmde->GetTokenFromSig(sigPtr, sigLen, &sigTok)))
            cmpFatal(ERRmetadata);

        cycleCounterResume();

        fncTyp->tdFnc.tdfPtrSig = sigTok;
    }

    return  fncTyp->tdFnc.tdfPtrSig;
}

/*****************************************************************************
 *
 *  Generate metadata for the given global / static data member symbol (and,
 *  if the symbol is a member of a class, make sure the metadata for that
 *  class is also generated).
 */

void                compiler::cmpGenFldMetadata(SymDef fldSym)
{
    SymDef          ownerSym;
    mdTypeDef       ownerTD;

    __int32         ival;
    __int64         lval;
    float           fval;
    double          dval;

    wchar   *       constBuf;
    unsigned        constTyp;
    void    *       constPtr;

    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    unsigned        flags;

    bool            mangle;

    __int32         eval;

    mdToken         ftok;

    /* Figure out the owning type */

    ownerSym = fldSym->sdParent;

    if  (ownerSym->sdSymKind == SYM_CLASS)
    {
        assert(fldSym->sdSymKind == SYM_VAR);
        assert(fldSym->sdVar.sdvGenSym == NULL || fldSym->sdIsStatic);

        /* Don't do this twice for the same field */

        if  (fldSym->sdVar.sdvMDtoken)
            return;

        ownerTD = ownerSym->sdClass.sdcMDtypedef;
        if  (!ownerTD)
        {
            /* Generate metadata for the containing class */

            cmpGenClsMetadata(ownerSym);

            /* May have called recursively */

            if  (fldSym->sdVar.sdvMDtoken)
                return;

            /* The class should now have a typedef */

            ownerTD = ownerSym->sdClass.sdcMDtypedef; assert(ownerTD);
        }

        mangle = false;
    }
    else if (fldSym->sdSymKind == SYM_ENUMVAL)
    {
        TypDef          type = fldSym->sdType; assert(type->tdTypeKind == TYP_ENUM);
        SymDef          esym = type->tdEnum.tdeSymbol;

        ownerTD = esym->sdEnum.sdeMDtypedef; assert(ownerTD);
        mangle  = false;
    }
    else
    {
        ownerTD = 0;
        mangle  = false;
    }

    /* Figure out the flags */

    flags = ACCtoFlags(fldSym);

    if  (fldSym->sdIsMember)
    {
        /* This is a (data) member of a class */

        if  (fldSym->sdIsStatic)
            flags |= fdStatic;
    }
    else
    {
        if  (fldSym->sdIsStatic || ownerSym == cmpGlobalNS)
        {
            /* Must be a global (or local static) unmanaged variable */

            flags |= fdStatic|fdHasFieldRVA;

            if  (ownerSym->sdSymKind == SYM_SCOPE)
                flags = fdPrivateScope|fdStatic|fdHasFieldRVA;
        }
    }

    if  (fldSym->sdIsSealed)
        flags |= fdInitOnly;

    /* Is there a constant value we need to attach to the member? */

    constTyp = ELEMENT_TYPE_VOID;
    constPtr = NULL;
    constBuf = NULL;

    switch (fldSym->sdSymKind)
    {
        var_types       vtp;

    case SYM_VAR:

        if  (fldSym->sdVar.sdvConst)
        {
            ConstVal        cval = fldSym->sdVar.sdvCnsVal;
            var_types       vtyp = (var_types)cval->cvVtyp;

            assert(fldSym->sdCompileState >= CS_CNSEVALD);

            /* What's the type of the constant? */

        GEN_CNS:

            flags |=  fdLiteral|fdStatic;
            flags &= ~fdInitOnly;

            switch (vtyp)
            {
            case TYP_BOOL:
            case TYP_CHAR:
            case TYP_UCHAR:
            case TYP_WCHAR:
            case TYP_SHORT:
            case TYP_USHORT:
            case TYP_INT:
            case TYP_UINT:
                ival = cval->cvValue.cvIval; constPtr = &ival;
                break;

            case TYP_LONG:
            case TYP_ULONG:
                lval = cval->cvValue.cvLval; constPtr = &lval;
                break;

            case TYP_FLOAT:
                fval = cval->cvValue.cvFval; constPtr = &fval;
                break;

            case TYP_DOUBLE:
                dval = cval->cvValue.cvDval; constPtr = &dval;
                break;

            case TYP_ENUM:
                vtyp = cval->cvType->tdEnum.tdeIntType->tdTypeKindGet();
                goto GEN_CNS;

            case TYP_PTR:
            case TYP_REF:

                /* Must be either a string or "null" */

                if  (cval->cvIsStr)
                {
                    size_t          len = cval->cvValue.cvSval->csLen;

                    constBuf = (wchar*)SMCgetMem(this, roundUp((len+1)*sizeof(*constBuf)));

                    mbstowcs(constBuf, cval->cvValue.cvSval->csStr, len+1);

                    constTyp = ELEMENT_TYPE_STRING;
                    constPtr = constBuf;
                    goto DONE_CNS;
                }
                else
                {
                    ival = 0; constPtr = &ival;

                    constTyp = ELEMENT_TYPE_I4;
                    goto DONE_CNS;
                }
                break;

            case TYP_UNDEF:
                break;

            default:
#ifdef  DEBUG
                printf("\nConstant type: '%s'\n", cmpGlobalST->stTypeName(cval->cvType, NULL, NULL, NULL, false));
#endif
                UNIMPL(!"unexpected const type");
            }

            assert(vtyp < arraylen(intrinsicSigs)); constTyp = intrinsicSigs[vtyp];
        }
        break;

    case SYM_ENUMVAL:

        flags |=  fdLiteral|fdStatic;
        flags &= ~fdInitOnly;

        assert(fldSym->sdType->tdTypeKind == TYP_ENUM);

        vtp = fldSym->sdType->tdEnum.tdeIntType->tdTypeKindGet();

        if  (vtp < TYP_LONG)
        {
            eval     =  fldSym->sdEnumVal.sdEV.sdevIval;

            constTyp = ELEMENT_TYPE_I4;
            constPtr = &eval;
        }
        else
        {
            lval     = *fldSym->sdEnumVal.sdEV.sdevLval;

            constTyp = ELEMENT_TYPE_I8;
            constPtr = &lval;
        }
        break;
    }

DONE_CNS:

    /* Create a signature for the member */

    sigPtr  = (PCOR_SIGNATURE)cmpGenMemberSig(fldSym, NULL, NULL, NULL, &sigLen);

    /* Create the member metadata definition */

#ifndef __IL__
//  if  (!strcmp(fldSym->sdSpelling(), "e_cblp")) __asm int 3
#endif

//  printf("NOTE: define field  MD for '%s'\n", cmpGlobalST->stTypeName(NULL, fldSym, NULL, NULL, true)); fflush(stdout);

    cycleCounterPause();

    if  (cmpWmde->DefineField(ownerTD,                      // owning typedef
                              cmpUniConv(fldSym->sdName),   // member name
                              flags,                        // member attrs
                              sigPtr,                       // signature addr
                              sigLen,                       // signature len
                              constTyp,                     // constant type
                              constPtr,                     // constant value
                              -1,                           // optional length
                              &ftok))                       // resulting token
    {
        cmpFatal(ERRmetadata);
    }

    /* Has the member been marked as "deprecated" ? */

    if  (fldSym->sdIsDeprecated)
    {
        cmpAttachMDattr(ftok, L"System.ObsoleteAttribute"            ,
                               "System.ObsoleteAttribute"            , &cmpAttrDeprec);
    }

    if  (fldSym->sdIsTransient)
    {
        cmpAttachMDattr(ftok, L"System.NonSerializedAttribute",
                               "System.NonSerializedAttribute", &cmpAttrNonSrlz);
    }

    cycleCounterResume();

    /* Look for any custom attributes that the member might have */

    SymXinfo        fldInfo = NULL;

    if  (fldSym->sdSymKind == SYM_VAR)
    {
        if  (!fldSym->sdVar.sdvConst    &&
             !fldSym->sdVar.sdvBitfield &&
             !fldSym->sdVar.sdvLocal)
        {
            fldInfo = fldSym->sdVar.sdvFldInfo;
        }
    }
    else
    {
        if  (fldSym->sdSymKind == SYM_ENUMVAL)
            fldInfo = fldSym->sdEnumVal.sdeExtraInfo;
    }

    if  (fldInfo)
    {
        cmpAddCustomAttrs(fldInfo, ftok);

        do
        {
            if  (fldInfo->xiKind == XI_MARSHAL)
            {
                SymXinfoCOM     desc = (SymXinfoCOM)fldInfo;
                MarshalInfo     info = desc->xiCOMinfo;

                cmpGenMarshalInfo(ftok, fldSym->sdType, info);
            }

            fldInfo = fldInfo->xiNext;
        }
        while (fldInfo);
    }

    if  (fldSym->sdSymKind == SYM_VAR)
        fldSym->sdVar.sdvMDtoken = ftok;

    if  (constBuf)
        SMCrlsMem(this, constBuf);
}

/*****************************************************************************
 *
 *  Return a token for a fake static field that will represent an unmanaged
 *  string literal.
 */

mdToken             compiler::cmpStringConstTok(size_t addr, size_t size)
{
    mdToken         stok;
    char            name[16];

    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    strCnsPtr       sclDesc;

    sprintf(name, "$%u", ++cmpStringConstCnt);

    assert(cmpStringConstCls);
    assert(cmpStringConstCls->sdClass.sdcMDtypedef);

    /* Form the signature for the member */

    /* Generate a value type with the same size  as the string */
    
    WMetaDataEmit * emitIntf;

    mdTypeDef       tdef;
    char            typName[16];

    /* For now we use a fake struct with the right size */

    static
    unsigned        strCnt;

    sprintf(typName, "$STR%08X", strCnt++);

    emitIntf = cmpWmde;

    cycleCounterPause();

    /* Set the base type to "System::ValueType" */

    assert(cmpClassValType && cmpClassValType->sdSymKind == SYM_CLASS);

    /* Create the fake struct type */

    if  (emitIntf->DefineTypeDef(cmpUniConv(typName, strlen(typName)+1),
                                 tdSequentialLayout|tdSealed,
                                 cmpClsEnumToken(cmpClassValType->sdType),
                                 NULL,
                                 &tdef))
    {
        cmpFatal(ERRmetadata);
    }

    /* Don't forget to set the alignment and size */

    if  (emitIntf->SetClassLayout(tdef, 1, NULL, size))
        cmpFatal(ERRmetadata);

    cycleCounterResume();

    /* Generate signature */

    cmpMDsigStart();
    
    cmpMDsigAdd_I1(IMAGE_CEE_CS_CALLCONV_FIELD);
    
    cmpMDsigAddCU4(ELEMENT_TYPE_VALUETYPE);
    cmpMDsigAddTok(tdef);
    
    sigPtr = cmpMDsigEnd(&sigLen);

    /* Add the member to the metadata */

    cycleCounterPause();

    if  (cmpWmde->DefineField(cmpStringConstCls->sdClass.sdcMDtypedef,
                              cmpUniConv(name, strlen(name)+1),
                              fdPrivateScope|fdStatic|fdHasFieldRVA,
                              sigPtr,
                              sigLen,
                              ELEMENT_TYPE_VOID,
                              NULL,
                              -1,
                              &stok))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();

    sclDesc = (strCnsPtr)SMCgetMem(this, sizeof(*sclDesc));

    sclDesc->sclTok  = stok;
    sclDesc->sclAddr = addr;
    sclDesc->sclNext = cmpStringConstList;
                       cmpStringConstList = sclDesc;

    return stok;
}

/*****************************************************************************
 *
 *  Return a typedef/typeref token for the given class/enum type.
 */

mdToken             compiler::cmpClsEnumToken(TypDef type)
{
    SymDef          tsym;
    mdToken         token;

AGAIN:

    if  (type->tdTypeKind == TYP_CLASS)
    {
        tsym = type->tdClass.tdcSymbol;

        /* Is this an imported class? */

        if  (tsym->sdIsImport)
        {
            /* Do we have a typeref for the class yet? */

            if  (!tsym->sdClass.sdcMDtypeImp)
            {
                cmpMakeMDimpTref(tsym);

                //if  (tsym->sdClass.sdcAssemIndx && cmpConfig.ccAssembly)
                //    cmpAssemblySymDef(tsym);
            }

            token = tsym->sdClass.sdcMDtypeImp;
        }
        else
        {
            /* Make sure metadata for the class has been emitted */

            if  (!tsym->sdClass.sdcMDtypedef)
                cmpGenClsMetadata(tsym);

            token = tsym->sdClass.sdcMDtypedef;
        }
    }
    else
    {
        if  (type->tdTypeKind != TYP_ENUM)
        {
            if  (type->tdTypeKind == TYP_TYPEDEF)
            {
                type = type->tdTypedef.tdtType;
                goto AGAIN;
            }

            /* Must have had errors, return any random value */

            assert(type->tdTypeKind == TYP_UNDEF);
            return  1;
        }

        tsym = type->tdEnum.tdeSymbol;

        /* Is this an imported enum? */

        if  (tsym->sdIsImport)
        {
            /* Do we have a typeref for the class yet? */

            if  (!tsym->sdEnum.sdeMDtypeImp)
            {
                cmpMakeMDimpEref (tsym);

                //if  (tsym->sdEnum.sdeAssemIndx && cmpConfig.ccAssembly)
                //    cmpAssemblySymDef(tsym);
            }

            token = tsym->sdEnum.sdeMDtypeImp;
        }
        else
        {
            /* Make sure metadata for the enum has been emitted */

            if  (!tsym->sdEnum.sdeMDtypedef)
                cmpGenClsMetadata(tsym);

            token = tsym->sdEnum.sdeMDtypedef;
        }
    }

    return  token;
}

/*****************************************************************************
 *
 *  Return a metadata token to represent the given string literal.
 */

mdToken             compiler::cmpMDstringLit(wchar *str, size_t len)
{
    mdToken         strTok;

    cycleCounterPause();

    if  (cmpWmde->DefineUserString(str, len, &strTok))
        cmpFatal(ERRmetadata);

    cycleCounterResume();

    return  strTok;
}

/*****************************************************************************
 *
 *  Low-level helpers used to construct signature blobs.
 */

void                compiler::cmpMDsigStart()
{
    assert(cmpMDsigUsed == false);
#ifndef NDEBUG
    cmpMDsigUsed = true;
#endif
    cmpMDsigNext = cmpMDsigBase;
}

void                compiler::cmpMDsigExpand(size_t more)
{
    char    *       buff;
    size_t          size;
    size_t          osiz;

    /* Figure out the size to allocate; we double the buffer, at least */

    size = cmpMDsigSize + more;
    if  (more < cmpMDsigSize)
         size = 2 * cmpMDsigSize;

    /* Round up the size to just under a page multiple */

    size +=  (OS_page_size-1);
    size &= ~(OS_page_size-1);
    size -= 32;

    /* Allocate the new buffer */

#if MGDDATA
    buff = new managed char [size];
#else
    buff = (char *)LowLevelAlloc(size);
#endif

    /* Copy the current buffer contents to the new location */

    osiz = cmpMDsigNext - cmpMDsigBase;

    assert(osiz <= cmpMDsigSize + 4 && osiz + more <= size);

    memcpy(buff, cmpMDsigBase, osiz);

    /* Free up the previous buffer if it's on the heap */

    if  (cmpMDsigHeap)
        LowLevelFree(cmpMDsigHeap);

    /* Switch to the new buffer and we're ready to continue */

    cmpMDsigBase =
    cmpMDsigHeap = buff;
    cmpMDsigSize = size - 4;
    cmpMDsigNext = buff + osiz;
    cmpMDsigEndp = buff + cmpMDsigSize;
}

PCOR_SIGNATURE      compiler::cmpMDsigEnd(size_t *sizePtr)
{
    assert(cmpMDsigNext <= cmpMDsigEndp);

    *sizePtr = cmpMDsigNext-cmpMDsigBase;

#ifndef NDEBUG
    cmpMDsigUsed = false;
#endif

    return  (PCOR_SIGNATURE)cmpMDsigBase;
}

void                compiler::cmpMDsigAddStr(const char *str, size_t len)
{
    assert(len);

    if  (cmpMDsigNext + len > cmpMDsigEndp)
        cmpMDsigExpand(len);

    memcpy(cmpMDsigNext, str, len);
           cmpMDsigNext   +=  len;
}

inline
void                compiler::cmpMDsigAdd_I1(int val)
{
    if  (cmpMDsigNext >= cmpMDsigEndp)
        cmpMDsigExpand(1);

    *cmpMDsigNext++ = val;
}

void                compiler::cmpMDsigAddCU4(unsigned val)
{
    if  (val <= 0x7F)
    {
        cmpMDsigAdd_I1(val);
    }
    else
    {
        char            buff[8];

        if  (cmpMDsigNext + 8 >= cmpMDsigEndp)
            cmpMDsigExpand(8);

        cmpMDsigAddStr(buff, CorSigCompressData(val, buff));
    }
}

void                compiler::cmpMDsigAddTok(mdToken tok)
{
    char            buff[8];

    if  (cmpMDsigNext + 8 >= cmpMDsigEndp)
        cmpMDsigExpand(8);

    cmpMDsigAddStr(buff, CorSigCompressToken(tok, buff));
}

/*****************************************************************************
 *
 *  Generate a signature for the given type.
 */

PCOR_SIGNATURE      compiler::cmpTypeSig(TypDef type, size_t *lenPtr)
{
            cmpMDsigStart ();
            cmpMDsigAddTyp(type);
    return  cmpMDsigEnd   (lenPtr);
}

/*****************************************************************************
 *
 *  Append a signature of the given type to the current signature blob.
 */

void                compiler::cmpMDsigAddTyp(TypDef type)
{
    var_types       vtyp;

AGAIN:

    vtyp = type->tdTypeKindGet();

    if  (vtyp <= TYP_lastIntrins)
    {
    INTRINS:

        assert(vtyp < arraylen(intrinsicSigs));

        cmpMDsigAdd_I1(intrinsicSigs[vtyp]);
        return;
    }

    switch (vtyp)
    {
        mdToken         token;

    case TYP_REF:

        type = cmpActualType(type->tdRef.tdrBase);
        if  (type->tdTypeKind != TYP_CLASS || type->tdClass.tdcValueType)
        {
            cmpMDsigAdd_I1(ELEMENT_TYPE_BYREF);
            goto AGAIN;
        }

        // It's a reference to a class, so fall through ...

    case TYP_CLASS:

        if  (type->tdClass.tdcSymbol == cmpClassString)
        {
            cmpMDsigAdd_I1(ELEMENT_TYPE_STRING);
            return;
        }

        if  (type->tdClass.tdcValueType || !type->tdIsManaged)
        {
            if  (type->tdClass.tdcIntrType != TYP_UNDEF)
            {
                vtyp = (var_types)type->tdClass.tdcIntrType;
                goto INTRINS;
            }

            token = cmpClsEnumToken(type); assert(token);

            cmpMDsigAddCU4(ELEMENT_TYPE_VALUETYPE);
            cmpMDsigAddTok(token);
            return;
        }


        token = cmpClsEnumToken(type); assert(token);

        cmpMDsigAddCU4(ELEMENT_TYPE_CLASS);
        cmpMDsigAddTok(token);

        return;

    case TYP_ENUM:

        if  (cmpConfig.ccIntEnums)
        {
            type = type->tdEnum.tdeIntType;
            goto AGAIN;
        }

        token = cmpClsEnumToken(type); assert(token);

        cmpMDsigAddCU4(ELEMENT_TYPE_VALUETYPE);
        cmpMDsigAddTok(token);
        return;

    case TYP_TYPEDEF:

        type = type->tdTypedef.tdtType;
        goto AGAIN;

    case TYP_PTR:
        type = cmpActualType(type->tdRef.tdrBase);
        if  (type->tdTypeKind == TYP_FNC)
        {
            cmpMDsigAdd_I1(ELEMENT_TYPE_I4);
            return;
        }
        cmpMDsigAdd_I1(ELEMENT_TYPE_PTR);
        goto AGAIN;

    case TYP_ARRAY:

        assert(type->tdIsValArray == (type->tdIsManaged && isMgdValueType(cmpActualType(type->tdArr.tdaElem))));

        if  (type->tdIsManaged)
        {
            TypDef          elem = cmpDirectType(type->tdArr.tdaElem);
            DimDef          dims = type->tdArr.tdaDims; assert(dims);

            if  (dims->ddNext)
            {
                cmpMDsigAddCU4(ELEMENT_TYPE_ARRAY);
                cmpMDsigAddTyp(elem);
                cmpMDsigAddCU4(type->tdArr.tdaDcnt);
                cmpMDsigAddCU4(0);
                cmpMDsigAddCU4(0);
            }
            else
            {
                cmpMDsigAddCU4(ELEMENT_TYPE_SZARRAY);
                cmpMDsigAddTyp(elem);
            }
        }
        else
        {
            assert(type->tdIsValArray  == false);

            if  (!type->tdArr.tdaTypeSig)
            {
                WMetaDataEmit * emitIntf;

                mdTypeDef       tdef;
                char            name[16];

                size_t          sz;
                size_t          al;

                sz = cmpGetTypeSize(type, &al);

                /* For now we use a fake struct with the right size */

                static
                unsigned        arrCnt;

                sprintf(name, "$ARR%08X", arrCnt++);

                emitIntf = cmpWmde;

                cycleCounterPause();

                /* Set the base type to "System::ValueType" */

                assert(cmpClassValType && cmpClassValType->sdSymKind == SYM_CLASS);

                /* Create the fake struct type */

                if  (emitIntf->DefineTypeDef(cmpUniConv(name, strlen(name)+1),
                                             tdSequentialLayout|tdSealed,
                                             cmpClsEnumToken(cmpClassValType->sdType),
                                             NULL,
                                             &tdef))
                {
                    cmpFatal(ERRmetadata);
                }

                /* Don't forget to set the alignment and size */

                if  (emitIntf->SetClassLayout(tdef, al, NULL, sz))
                    cmpFatal(ERRmetadata);

                cycleCounterResume();

                type->tdArr.tdaTypeSig = tdef;
            }

            cmpMDsigAddCU4(ELEMENT_TYPE_VALUETYPE);
            cmpMDsigAddTok(type->tdArr.tdaTypeSig);
        }
        return;

    default:

#ifdef  DEBUG
        printf("Type '%s'\n", cmpGlobalST->stTypeName(type, NULL, NULL, NULL, false));
#endif
        UNIMPL(!"output user type sig");
    }
}

/*****************************************************************************
 *
 *  Recursively generates signatures for all local variables contained within
 *  the given scope.
 */

void                compiler::cmpGenLocalSigRec(SymDef scope)
{
    SymDef          child;

    for (child = scope->sdScope.sdScope.sdsChildList;
         child;
         child = child->sdNextInScope)
    {
        if  (child->sdSymKind == SYM_SCOPE)
        {
            cmpGenLocalSigRec(child);
        }
        else
        {
            if  (child->sdIsStatic)
                continue;
            if  (child->sdVar.sdvConst && !child->sdIsSealed)
                continue;

            assert(child->sdSymKind == SYM_VAR);
            assert(child->sdVar.sdvLocal);

            if  (child->sdVar.sdvArgument)
                continue;
            if  (child->sdIsImplicit)
                continue;

//          printf("Add local to sig [%2u/%2u]: '%s'\n", child->sdVar.sdvILindex, cmpGenLocalSigLvx, cmpGlobalST->stTypeName(NULL, child, NULL, NULL, false));

#ifdef  DEBUG
            assert(child->sdVar.sdvILindex == cmpGenLocalSigLvx); cmpGenLocalSigLvx++;
#endif

            cmpMDsigAddTyp(child->sdType);
        }
    }
}

/*****************************************************************************
 *
 *  Generate metadata signature for the local variables declared within
 *  the given scope.
 */

mdSignature         compiler::cmpGenLocalSig(SymDef scope, unsigned count)
{
    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    mdSignature     sigTok;

    genericRef      tmpLst;

#ifdef  DEBUG
    cmpGenLocalSigLvx = 0;
#endif

    /* Construct the signature for all non-argument locals */

    cmpMDsigStart();

    /* First thing is the magic value and count of locals */

    cmpMDsigAdd_I1(IMAGE_CEE_CS_CALLCONV_LOCAL_SIG);
    cmpMDsigAddCU4(count);

    /* Next come the signatures for all the user-declared locals */

    cmpGenLocalSigRec(scope);

    /* Next we add signatures for amy temps created during MSIL gen */

    tmpLst = cmpILgen->genTempIterBeg();

    if  (tmpLst)
    {
        do
        {
            TypDef          tmpTyp;

//          printf("Type of temp #%02X is '%s'\n", cmpGenLocalSigLvx, symTab::stIntrinsicTypeName(((ILtemp)tmpLst)->tmpType->tdTypeKindGet()));

#ifdef  DEBUG
            assert(((ILtemp)tmpLst)->tmpNum == cmpGenLocalSigLvx); cmpGenLocalSigLvx++;
#endif

            /* Get the type of the current temp and advance the iterator */

            tmpLst = cmpILgen->genTempIterNxt(tmpLst, tmpTyp);

            // map 'void' to ELEMENT_BYREF / int

            if  (tmpTyp->tdTypeKind == TYP_VOID)
            {
                cmpMDsigAdd_I1(ELEMENT_TYPE_BYREF);
                cmpMDsigAdd_I1(ELEMENT_TYPE_I4);
                continue;
            }

            /* Append this temp to the signature */

            cmpMDsigAddTyp(tmpTyp);
        }
        while (tmpLst);
    }

    sigPtr = cmpMDsigEnd(&sigLen);

    /* Make sure we found the expected number of locals and temps */

    assert(cmpGenLocalSigLvx == count);

    /* Now create a metadata token from the signature and return it */

    if  (sigLen > 2)
    {
        cycleCounterPause();

        if  (FAILED(cmpWmde->GetTokenFromSig(sigPtr, sigLen, &sigTok)))
            cmpFatal(ERRmetadata);

        cycleCounterResume();

        return  sigTok;
    }
    else
        return  0;
}

/*****************************************************************************
 *
 *  Create a dotted unicode name for the given symbol.
 */

wchar   *           compiler::cmpArrayClsPref(SymDef sym,
                                              wchar *dest,
                                              int    delim, bool fullPath)
{
    wchar   *       name;
    SymDef          parent = sym->sdParent; assert(parent);

    if  ((parent->sdSymKind == sym->sdSymKind || fullPath) && parent != cmpGlobalNS)
    {
        dest = cmpArrayClsPref(parent, dest, delim, fullPath); *dest++ = delim;
    }

    name = cmpUniConv(sym->sdName);

    wcscpy(dest, name);

    return  dest + wcslen(name);
}

/*****************************************************************************
 *
 *  Create a fake array class name of the form "System.Integer2[]".
 */

wchar   *           compiler::cmpArrayClsName(TypDef type,
                                              bool   nonAbstract, wchar *dest,
                                                                  wchar *nptr)
{
    SymDef          csym;
    SymDef          psym;

    var_types       vtyp = type->tdTypeKindGet();

    if  (vtyp <= TYP_lastIntrins)
    {
        /* Locate the appropriate built-in value type */

        type = cmpFindStdValType(vtyp); assert(type);
    }
    else
    {
        switch (vtyp)
        {
        case TYP_ARRAY:

            assert(type->tdIsManaged);

             dest = cmpArrayClsName(type->tdArr.tdaElem, nonAbstract, dest, nptr);
            *dest++ = '[';

            if  (type->tdIsGenArray && !nonAbstract)
            {
                *dest++ = '?';
            }
            else
            {
                DimDef          dims;

                for (dims = type->tdArr.tdaDims;;)
                {
                    dims = dims->ddNext;
                    if  (!dims)
                        break;
                    *dest++ = ',';
                }
            }

            *dest++ = ']';

            return  dest;

        case TYP_REF:

            type = type->tdRef.tdrBase;
            break;

        case TYP_CLASS:
            break;

        default:
            NO_WAY(!"unexpected array element type");
        }
    }

    assert(type->tdTypeKind == TYP_CLASS);
    assert(type->tdIsManaged);

    csym = type->tdClass.tdcSymbol;
    psym = csym->sdParent;

    while (psym->sdSymKind == SYM_CLASS)
        psym = psym->sdParent;

    assert(psym && psym->sdSymKind == SYM_NAMESPACE);

    /* Form the namespace and class name */

    if  (psym != cmpGlobalNS)
        nptr = cmpArrayClsPref(psym, nptr, '.');

    *nptr = 0;

    return  cmpArrayClsPref(csym, dest, '$');
}

/*****************************************************************************
 *
 *  Return a typeref token for the given managed array type.
 */

mdToken             compiler::cmpArrayTpToken(TypDef type, bool nonAbstract)
{
    if  (!nonAbstract || !type->tdIsGenArray)
        type = cmpGetBaseArray(type);

    assert(type);
    assert(type->tdIsManaged);
    assert(type->tdTypeKind == TYP_ARRAY);

    if  (!type->tdArr.tdaTypeSig)
    {
        mdTypeSpec      arrTok;
        PCOR_SIGNATURE  sigPtr;
        size_t          sigLen;

                 cmpMDsigStart ();
                 cmpMDsigAddTyp(type);
        sigPtr = cmpMDsigEnd   (&sigLen);

        cycleCounterPause();

        if  (FAILED(cmpWmde->GetTokenFromTypeSpec(sigPtr, sigLen, &arrTok)))
            cmpFatal(ERRmetadata);

        cycleCounterResume();

        type->tdArr.tdaTypeSig = arrTok;
    }

    return  type->tdArr.tdaTypeSig;
}

/*****************************************************************************
 *
 *  Return a methodref token for a constructor that will allocate the given
 *  managed array type.
 */

mdToken             compiler::cmpArrayCTtoken(TypDef  arrType,
                                              TypDef elemType, unsigned dimCnt)
{
    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    mdToken         fncTok;

    bool            loBnds = (bool)arrType->tdIsGenArray;

    // UNDONE: Look for an existing methodref token to reuse ....

    cmpMDsigStart();
    cmpMDsigAdd_I1(IMAGE_CEE_CS_CALLCONV_DEFAULT|IMAGE_CEE_CS_CALLCONV_HASTHIS);
    cmpMDsigAddCU4(loBnds ? 2*dimCnt : dimCnt);
    cmpMDsigAdd_I1(ELEMENT_TYPE_VOID);

    do
    {
        cmpMDsigAdd_I1(ELEMENT_TYPE_I4);
        if  (loBnds)
            cmpMDsigAdd_I1(ELEMENT_TYPE_I4);
    }
    while (--dimCnt);

    char tempSigBuff[256];
    sigPtr = (PCOR_SIGNATURE) tempSigBuff;
    PCOR_SIGNATURE  tempSig = cmpMDsigEnd(&sigLen);
    assert(sigLen < 256);           // FIX this limitation, or at least fail
    memcpy(sigPtr, tempSig, sigLen);

    cycleCounterPause();

    if  (FAILED(cmpWmde->DefineMemberRef(cmpArrayTpToken(arrType, true),
                                         L".ctor",    // s/b OVOP_STR_CTOR_INST
                                         sigPtr,
                                         sigLen,
                                         &fncTok)))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();

    return  fncTok;
}

/*****************************************************************************
 *
 *  Return a methodref token of the element accessor method for the given
 *  managed array type.
 */

mdToken             compiler::cmpArrayEAtoken(TypDef        arrType,
                                              unsigned      dimCnt,
                                              bool          store,
                                              bool          addr)
{
    TypDef          elemTp = arrType->tdArr.tdaElem;

    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    mdToken         fncTok;
    wchar   *       fncName;

    // UNDONE: Look for an existing methodref token to reuse ....

    cmpMDsigStart();
    cmpMDsigAdd_I1(IMAGE_CEE_CS_CALLCONV_DEFAULT|IMAGE_CEE_CS_CALLCONV_HASTHIS);
    cmpMDsigAddCU4(dimCnt + (int)store);

    if      (store)
    {
        fncName = L"Set";

        cmpMDsigAdd_I1(ELEMENT_TYPE_VOID);
    }
    else
    {
        if (addr)
        {
            fncName = L"Address";
            cmpMDsigAdd_I1(ELEMENT_TYPE_BYREF);
        }
        else
        {
            fncName = L"Get";
        }

        cmpMDsigAddTyp(elemTp);
    }

    do
    {
        cmpMDsigAdd_I1(ELEMENT_TYPE_I4);
    }
    while (--dimCnt);

    if  (store)
        cmpMDsigAddTyp(elemTp);

    char tempSigBuff[256];
    sigPtr = (PCOR_SIGNATURE) tempSigBuff;
    PCOR_SIGNATURE  tempSig = cmpMDsigEnd(&sigLen);
    assert(sigLen < 256);           // FIX this limitation, or at least fail
    memcpy(sigPtr, tempSig, sigLen);

    cycleCounterPause();

    if  (FAILED(cmpWmde->DefineMemberRef(cmpArrayTpToken(arrType),
                                         fncName,
                                         sigPtr,
                                         sigLen,
                                         &fncTok)))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();

    return  fncTok;
}

/*****************************************************************************
 *
 *  Create a metadata type signature for the given pointer type.
 */

mdToken             compiler::cmpPtrTypeToken(TypDef type)
{
    mdTypeSpec      ptrTok;

    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

             cmpMDsigStart ();
             cmpMDsigAddTyp(type);
    sigPtr = cmpMDsigEnd   (&sigLen);

    cycleCounterPause();
    if  (FAILED(cmpWmde->GetTokenFromTypeSpec(sigPtr, sigLen, &ptrTok)))
        cmpFatal(ERRmetadata);
    cycleCounterResume();

    return  ptrTok;
}

/*****************************************************************************
 *
 *  Create a metadata signature for the given function/data member.
 */

PCOR_SIGNATURE      compiler::cmpGenMemberSig(SymDef memSym,
                                              Tree   xargs,
                                              TypDef memTyp,
                                              TypDef prefTp, size_t *lenPtr)
{
    unsigned        call;
    ArgDef          args;

    /* Get hold of the member type, if we have a symbol */

    if  (memSym)
    {
        assert(memTyp == NULL || memTyp == memSym->sdType);

        memTyp = memSym->sdType;
    }
    else
    {
        assert(memTyp != NULL);
    }

    /* Start generating the member signature */

    cmpMDsigStart();

    /* Do we have a data or function member? */

    if  (memTyp->tdTypeKind == TYP_FNC)
    {
        unsigned        argCnt;
        TypDef          retTyp = memTyp->tdFnc.tdfRett;
        bool            argExt = memTyp->tdFnc.tdfArgs.adExtRec;

        /* Compute and emit the calling convention value */

        call = IMAGE_CEE_CS_CALLCONV_DEFAULT;

        if  (memTyp->tdFnc.tdfArgs.adVarArgs)
            call  = IMAGE_CEE_CS_CALLCONV_VARARG;
        if  (memSym && memSym->sdSymKind == SYM_PROP)
            call |= IMAGE_CEE_CS_CALLCONV_PROPERTY;

        if  (memSym && memSym->sdIsMember && !memSym->sdIsStatic)
        {
#if STATIC_UNMANAGED_MEMBERS
            if  (!memSym->sdIsManaged)
            {
                assert(prefTp == NULL);
                prefTp = memSym->sdParent->sdType->tdClass.tdcRefTyp;
                assert(prefTp->tdTypeKind == TYP_PTR);
            }
            else
#endif
                call |= IMAGE_CEE_CS_CALLCONV_HASTHIS;
        }

        argCnt = memTyp->tdFnc.tdfArgs.adCount;

        cmpMDsigAdd_I1(call);

        /* Output the argument count */

        if  (xargs)
        {
            Tree            xtemp;

            /* force memberrefs to always be used for vararg calls */

            if  (xargs->tnOper != TN_LIST)
            {
                xargs = NULL;
            }
            else
            {
                for (xtemp = xargs; xtemp; xtemp = xtemp->tnOp.tnOp2)
                {
                    assert(xtemp->tnOper == TN_LIST);
                    argCnt++;
                }
            }
        }

        if  (prefTp)
            argCnt++;

        cmpMDsigAddCU4(argCnt);

        /* Output the return type signature */

        cmpMDsigAddTyp(retTyp);

        /* Output the argument types */

        if  (prefTp)
            cmpMDsigAddTyp(prefTp);

        for (args = memTyp->tdFnc.tdfArgs.adArgs; args; args = args->adNext)
        {
            TypDef          argType = args->adType;

            /* Do we have extended parameter attributes? */

            if  (argExt)
            {
                unsigned        flags;

                assert(args->adIsExt);

                flags = ((ArgExt)args)->adFlags;

#if 0

                if      (flags & (ARGF_MODE_OUT|ARGF_MODE_INOUT))
                {
                    /* This is a byref argument */

                    cmpMDsigAdd_I1(ELEMENT_TYPE_BYREF);
                }
                else if (flags & ARGF_MODE_REF)
                {
                    /* map "raw" byref args onto "int" */

                    argType = cmpTypeInt;
                }

#else

                if      (flags & (ARGF_MODE_OUT|ARGF_MODE_INOUT|ARGF_MODE_REF))
//              if      (flags & ARGF_MODE_REF)
                {
                    /* This is a byref argument */

                    cmpMDsigAdd_I1(ELEMENT_TYPE_BYREF);
                }

#endif

            }

            cmpMDsigAddTyp(argType);
        }

        /* Append any "extra" argument types */

        if  (xargs)
        {
            cmpMDsigAdd_I1(ELEMENT_TYPE_SENTINEL);

            do
            {
                TypDef          argType;

                assert(xargs->tnOper == TN_LIST);

                argType = xargs->tnOp.tnOp1->tnType;

                // managed arrays don't work with varargs, pass as Object

                if  (argType->tdTypeKind == TYP_ARRAY && argType->tdIsManaged)
                    argType = cmpRefTpObject;

                cmpMDsigAddTyp(argType);

                xargs = xargs->tnOp.tnOp2;
            }
            while (xargs);
        }
    }
    else
    {
        assert(xargs == NULL);

        /* Emit the calling convention value */

        cmpMDsigAdd_I1(IMAGE_CEE_CS_CALLCONV_FIELD);

        /* Output the member type signature */

        cmpMDsigAddTyp(memTyp);
    }

    /* We're done, return the result */

    return  cmpMDsigEnd(lenPtr);
}

static
BYTE                intrnsNativeSigs[] =
{
    NATIVE_TYPE_END,        // TYP_UNDEF
    NATIVE_TYPE_VOID,       // TYP_VOID
    NATIVE_TYPE_BOOLEAN,    // TYP_BOOL
    NATIVE_TYPE_END,        // TYP_WCHAR        used to be _SYSCHAR

    NATIVE_TYPE_I1,         // TYP_CHAR
    NATIVE_TYPE_U1,         // TYP_UCHAR
    NATIVE_TYPE_I2,         // TYP_SHORT
    NATIVE_TYPE_U2,         // TYP_USHORT
    NATIVE_TYPE_I4,         // TYP_INT
    NATIVE_TYPE_U4,         // TYP_UINT
    NATIVE_TYPE_I4,         // TYP_NATINT       s/b naturalint !!!
    NATIVE_TYPE_U4,         // TYP_NATUINT      s/b naturaluint!!!
    NATIVE_TYPE_I8,         // TYP_LONG
    NATIVE_TYPE_U8,         // TYP_ULONG
    NATIVE_TYPE_R4,         // TYP_FLOAT
    NATIVE_TYPE_R8,         // TYP_DOUBLE
    NATIVE_TYPE_R8,         // TYP_LONGDBL
    NATIVE_TYPE_VOID,       // TYP_REFANY
};

/*****************************************************************************
 *
 *  Create a marshalling signature blob, given a type and an optional
 *  marshalling spec.
 */

PCOR_SIGNATURE      compiler::cmpGenMarshalSig(TypDef       type,
                                               MarshalInfo  info,
                                               size_t     * lenPtr)
{
    var_types       vtyp;

    cmpMDsigStart();

    if  (info && info->marshType != NATIVE_TYPE_END)
    {
        switch (info->marshType)
        {
            marshalExt *    iext;
            wchar           nam1[MAX_CLASS_NAME];
             char           nam2[MAX_CLASS_NAME];

        case NATIVE_TYPE_MAX:

            /* This is "CUSTOM" */

//          printf("WARNING: not sure what to do with 'custom' attribute (arg type is '%s'),\n", cmpGlobalST->stTypeName(type, NULL, NULL, NULL, true));
//          printf("         simply generating 'NATIVE_TYPE_BSTR' for now.\n");

            cmpMDsigAdd_I1(NATIVE_TYPE_BSTR);
            goto DONE;

        case NATIVE_TYPE_CUSTOMMARSHALER:

            iext = (marshalExt*)info;

            cmpMDsigAdd_I1(NATIVE_TYPE_CUSTOMMARSHALER);

            assert(iext->marshCustG);
            cmpMDsigAddStr(iext->marshCustG, strlen(iext->marshCustG));
            cmpMDsigAdd_I1(0);

            assert(iext->marshCustT);
            cmpArrayClsPref(iext->marshCustT, nam1, '.', true);
            wcstombs(nam2, nam1, sizeof(nam2)-1);
            cmpMDsigAddStr(nam2, strlen(nam2));
            cmpMDsigAdd_I1(0);

            if  (iext->marshCustC)
                cmpMDsigAddStr(iext->marshCustC, strlen(iext->marshCustC));

            cmpMDsigAdd_I1(0);
            goto DONE;

        default:

            assert(info->marshType && info->marshType < NATIVE_TYPE_MAX);

            cmpMDsigAdd_I1(info->marshType);

            if  (info->marshSize  && (int )info->marshSize  != (int) -1)
                cmpMDsigAddCU4(info->marshSize);

            if  (info->marshSubTp && (BYTE)info->marshSubTp != (BYTE)-1)
                cmpMDsigAdd_I1(info->marshSubTp);

            goto DONE;
        }
    }

    vtyp = type->tdTypeKindGet();

    if  (vtyp <= TYP_lastIntrins)
    {
        assert(vtyp < arraylen(intrnsNativeSigs));
        assert(intrnsNativeSigs[vtyp] != NATIVE_TYPE_END);

        cmpMDsigAdd_I1(intrnsNativeSigs[vtyp]);
    }
    else
    {
        switch (vtyp)
        {
            SymDef          clsSym;

        case TYP_ARRAY:

            // ISSUE: This sure doesn't seem quite right ....

            cmpMDsigAdd_I1(NATIVE_TYPE_ARRAY);
            cmpMDsigAdd_I1(1);
            goto DONE;

        case TYP_REF:

            /* Does this look like an embedded struct? */

            type = type->tdRef.tdrBase;

            if  (type->tdTypeKind != TYP_CLASS)
                break;

        case TYP_CLASS:

            clsSym = type->tdClass.tdcSymbol;

            /* Special cases: String and Variant */

            if  (clsSym->sdParent == cmpNmSpcSystem)
            {
                if  (clsSym->sdName == cmpIdentVariant)
                {
                    cmpMDsigAdd_I1(NATIVE_TYPE_VARIANT);
                    goto DONE;
                }

                if  (clsSym->sdName == cmpIdentString)
                {
                    cmpMDsigAdd_I1(NATIVE_TYPE_LPSTR);
                    goto DONE;
                }
            }

            goto DONE;

        case TYP_ENUM:
            cmpMDsigAdd_I1(intrnsNativeSigs[type->tdEnum.tdeIntType->tdTypeKind]);
            goto DONE;
        }

#ifdef  DEBUG
        printf("%s: ", cmpGlobalST->stTypeName(type, NULL, NULL, NULL, true));
#endif
        NO_WAY(!"unexpected @dll.struct type");
    }

DONE:

    return  cmpMDsigEnd(lenPtr);
}

/*****************************************************************************
 *
 *  Add a reference to the given assembly.
 */

mdAssemblyRef       compiler::cmpAssemblyAddRef(mdAssembly      ass,
                                                WAssemblyImport*imp)
{
    mdAssemblyRef   assRef;
    ASSEMBLYMETADATA assData;

    const   void *  pubKeyPtr;
    ULONG           pubKeySiz;

    wchar           anameBuff[_MAX_PATH];

    DWORD           flags;

    cycleCounterPause();

    /* Get the properties of the referenced assembly */

    memset(&assData, 0, sizeof(assData));

    if  (FAILED(imp->GetAssemblyProps(ass,
                                      NULL, //&pubKeyPtr,
                                      &pubKeySiz,
                                      NULL,             // hash algorithm
                                      anameBuff, arraylen(anameBuff), NULL,
                                      &assData,
                                      &flags)))
    {
        cmpFatal(ERRmetadata);
    }

//  printf("Assembly name returned from GetAssemblyProps: '%ls'\n", anameBuff);

    /* Allocate any non-empty arrays */

    assert(assData.rOS     == NULL);

    if  (assData.ulOS)
        assData.rOS     = (OSINFO *)malloc(assData.ulOS     * sizeof(OSINFO));

    if  (assData.ulProcessor)
        assData.rProcessor = (DWORD *)malloc(assData.ulProcessor * sizeof(DWORD));

    if (pubKeySiz)
        pubKeyPtr = (PBYTE)malloc(pubKeySiz * sizeof(BYTE));

    if  (FAILED(imp->GetAssemblyProps(ass,
                                      &pubKeyPtr,
                                      &pubKeySiz,
                                      NULL,             // hash algorithm
                                      NULL, 0, NULL,
                                      &assData,
                                      NULL)))
    {
        cmpFatal(ERRmetadata);
    }

    /* Now create the assembly reference */

    assert(cmpWase);

    if  (FAILED(cmpWase->DefineAssemblyRef(pubKeyPtr,
                                           pubKeySiz,
                                           anameBuff,   // name
                                           &assData,    // metadata
                                           NULL, 0,     // hash
                                           flags,
                                           &assRef)))
    {
        cmpFatal(ERRmetadata);
    }

#ifndef __SMC__

    if  (assData.rOS)
        delete (void*)assData.rOS;

#endif

    cycleCounterResume();

    return  assRef;
}

/*****************************************************************************
 *
 *  Add a definition for the given type (which may be a locally defined type
 *  (when 'tdefTok' is non-zero) or a type imported from another assembly).
 */

mdExportedType           compiler::cmpAssemblySymDef(SymDef sym, mdTypeDef tdefTok)
{
    mdExportedType       typeTok;
    mdToken             implTok;
    unsigned            flags;

    wchar               nameBuff[MAX_CLASS_NAME];

    assert(cmpConfig.ccAssembly);

    assert(sym->sdSymKind == SYM_CLASS ||
           sym->sdSymKind == SYM_ENUM);

    /* Make sure we have a reference to the appropriate assembly */

    if  (tdefTok == 0)
    {
        flags   = tdNotPublic;

        tdefTok = mdTypeDefNil;
        implTok = cmpAssemblyRefRec((sym->sdSymKind == SYM_CLASS)
                                        ? sym->sdClass.sdcAssemIndx
                                        : sym->sdEnum .sdeAssemIndx);
    }
    else
    {
        if  (cmpConfig.ccAsmNoPubTp)
            return  0;

        /* If we've done this already, return the ComType */

        if  (sym->sdSymKind == SYM_CLASS)
        {
            if  (sym->sdClass.sdcAssemRefd)
                return  sym->sdClass.sdcComTypeX;
        }
        else
        {
            if  (sym->sdEnum .sdeAssemRefd)
                return  sym->sdEnum .sdeComTypeX;
        }

        implTok = 0;

        flags   = (sym->sdAccessLevel == ACL_PUBLIC) ? tdPublic
                                                     : tdNotPublic;
        /* Do we have a nested class/enum ? */

        if  (sym->sdParent->sdSymKind == SYM_CLASS)
        {
            flags   = tdNestedPublic;
            implTok = sym->sdParent->sdClass.sdcComTypeX; assert(implTok);
        }
    }

    /* Now add an entry for this type to our assembly */

    assert(cmpWase);

    /* Form the fully qualified name for the type */

    if  (sym->sdParent->sdSymKind == SYM_CLASS)
    {
        SymDef          nst = sym;
        SymDef          nsp;

        wchar_t     *   nxt;

        while (nst->sdParent->sdSymKind == SYM_CLASS)
            nst = nst->sdParent;

        nsp = nst->sdParent;

        if  (nsp != cmpGlobalNS)
        {
            cmpArrayClsPref(nsp, nameBuff, '.', true);
            nxt = nameBuff + wcslen(nameBuff);
            *nxt++ = '.';
        }
        else
        {
            nxt = nameBuff; nameBuff[0] = 0;
        }

        nsp = nst->sdParent; nst->sdParent = cmpGlobalNS;
        cmpArrayClsPref(sym, nxt, '$', true);
        nst->sdParent = nsp;
    }
    else
        cmpArrayClsPref(sym, nameBuff, '.', true);

//  printf("Adding ref for ComType '%ls'\n", nameBuff);

    /* Create the type definition token */

    if  (FAILED(cmpWase->DefineExportedType(nameBuff,   // cmpUniConv(sym->sdName),
                                            implTok,    // owner assembly
                                            tdefTok,    // typedef
                                            flags,      // type flags
                                            &typeTok)))
    {
        cmpFatal(ERRmetadata);
    }

    /* A reference for this type has been added */

    if  (sym->sdSymKind == SYM_CLASS)
    {
        sym->sdClass.sdcAssemRefd = true;
        if  (tdefTok != mdTypeDefNil)
            sym->sdClass.sdcComTypeX = typeTok;
    }
    else
    {
        sym->sdEnum .sdeAssemRefd = true;
        if  (tdefTok != mdTypeDefNil)
            sym->sdEnum .sdeComTypeX = typeTok;
    }

    return  typeTok;
}

/*****************************************************************************
 *
 *  Add the given file to our assembly.
 */

mdToken             compiler::cmpAssemblyAddFile(wideStr    fileName,
                                                 bool       doHash,
                                                 unsigned   flags)
{
    mdToken         fileTok;

    BYTE            hashBuff[128];
    WCHAR           nameBuff[_MAX_PATH ];
    WCHAR              fname[_MAX_FNAME];
    WCHAR              fext [_MAX_EXT  ];

    const   void *  hashAddr = NULL;
    DWORD           hashSize = 0;

//  printf("Add ref for file '%ls\n", fileName);

    /* Are we supposed to compute the hash ? */

    if  (doHash)
    {
        unsigned        hashAlg = 0;
        BYTE    *       hashPtr = hashBuff;

        /* Compute the hash for the file */

        cycleCounterPause();

        if  (FAILED(WRAPPED_GetHashFromFileW(fileName,
                                            &hashAlg,
                                             hashPtr,
                                             arraylen(hashBuff),
                                            &hashSize)))
        {
            cmpFatal(ERRopenCOR);
        }

        cycleCounterResume();

        assert(hashPtr  == hashBuff);
        assert(hashSize <= arraylen(hashBuff));

        hashAddr = hashBuff;
    }

    /* Strip drive/directory from the filename */

    _wsplitpath(fileName, NULL, NULL, fname, fext);
     _wmakepath(nameBuff, NULL, NULL, fname, fext);

    /* Add the output file to the assembly */

    if  (!flags)
        flags = ffContainsMetaData;

    assert(cmpWase);

    cycleCounterPause();

    if  (FAILED(cmpWase->DefineFile(nameBuff,
                                    hashAddr,
                                    hashSize,
                                    flags,
                                    &fileTok)))
    {
        cmpFatal(ERRopenCOR);
    }

    cycleCounterResume();

    return  fileTok;
}

/*****************************************************************************
 *
 *  Add a definition for the given type to our assembly.
 */

void                compiler::cmpAssemblyAddType(wideStr  typeName,
                                                 mdToken  defTok,
                                                 mdToken  scpTok,
                                                 unsigned flags)
{
    mdToken         typeTok;

    assert(cmpWase);

    cycleCounterPause();

    if  (FAILED(cmpWase->DefineExportedType(typeName,
                                       scpTok,      // owner token
                                       defTok,      // typedef
                                       flags,       // type flags
                                       &typeTok)))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Add the given resource to our assembly (as an internal/external assembly
 *  resource).
 */

void                compiler::cmpAssemblyAddRsrc(AnsiStr fileName, bool internal)
{
    WCHAR           name[_MAX_PATH ];
    char            path[_MAX_PATH ];
    char            fnam[_MAX_FNAME];
    char            fext[_MAX_EXT  ];

    mdToken         fileTok;
    mdToken         rsrcTok;

    wcscpy(name, cmpUniConv(fileName, strlen(fileName)));

    fileTok = cmpAssemblyAddFile(name, true, ffContainsNoMetaData);

    _splitpath(fileName, NULL, NULL, fnam, fext);
     _makepath(path    , NULL, NULL, fnam, fext);

    assert(cmpWase);

    cycleCounterPause();

    if  (FAILED(cmpWase->DefineManifestResource(cmpUniConv(path, strlen(path)),
                                                fileTok,
                                                0,
                                                0,
                                                &rsrcTok)))
    {
        cmpFatal(ERRmetadata);
    }

    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Mark our assembly as non-CLS compliant.
 */

void                compiler::cmpAssemblyNonCLS()
{
    mdToken         toss = 0;

    assert(cmpCurAssemblyTok);

    cmpAttachMDattr(cmpCurAssemblyTok,
                   L"System.NonCLSCompliantAttribute",
                    "System.NonCLSCompliantAttribute",
                    &toss);
}

/*****************************************************************************
 *
 *  Mark the current module as containing unsafe code.
 */

void                compiler::cmpMarkModuleUnsafe()
{
    assert(cmpCurAssemblyTok);

    cycleCounterPause();

    // Blob describing the security custom attribute constructor and properties.
    // This is kind of messy (and exactly the same format as "normal" custom
    // attributes), so if VC has a nicer way of generating them, you might want
    // to use that instead.
    // The security custom attribute we're using follows the format (missing out
    // the System.Security.Permission namespace for brevity):
    //  SecurityPermission(SecurityAction.RequestMinimum), SkipVerification=true
    // i.e. the constructor takes a single argument (an enumerated type)
    // specifying we want to make a security request that's minimal (i.e. it
    // must be granted or the assembly won't load) and we want to set a single
    // property on the attribute (SkipVerification set to the boolean true).

    static BYTE     rbAttrBlob[] =
    {
        0x01, 0x00,                             // Version 1
        dclRequestMinimum, 0x00, 0x00, 0x00,    // Constructor arg value
        0x01, 0x00,                             // Number of properties/fields
        SERIALIZATION_TYPE_PROPERTY,            // It's a property
        SERIALIZATION_TYPE_BOOLEAN,             // The type is boolean
        0x10,                                   // Property name length
        0x53, 0x6B, 0x69, 0x70, 0x56, 0x65,     // Property name
        0x72, 0x69, 0x66, 0x69, 0x63, 0x61,
        0x74, 0x69, 0x6F, 0x6E,
        0x01                                    // Property value
    };

    // Build typeref to the security action code enumerator (needed to build a
    // signature for the following CA).
    mdTypeRef tkEnumerator;

    if  (FAILED(cmpWmde->DefineTypeRefByName(mdTokenNil,
                                             L"System.Security.Permissions.SecurityAction",
                                             &tkEnumerator)))
        cmpFatal(ERRmetadata);

    // Build signature for security CA constructor.
    static COR_SIGNATURE rSig[] =
    {
        IMAGE_CEE_CS_CALLCONV_DEFAULT|IMAGE_CEE_CS_CALLCONV_HASTHIS,
        1,
        ELEMENT_TYPE_VOID,
        ELEMENT_TYPE_VALUETYPE,
        0, 0, 0, 0
    };

    ULONG ulTokenLength;
    ULONG ulSigLength;
    ulTokenLength = CorSigCompressToken(tkEnumerator, &rSig[4]);
    ulSigLength = 4 + ulTokenLength;

    // Build typeref to the security CA (in mscorlib.dll).
    mdTypeRef tkAttributeType;
    mdMemberRef tkAttributeConstructor;
    if  (FAILED(cmpWmde->DefineTypeRefByName(mdTokenNil,
                                             L"System.Security.Permissions.SecurityPermissionAttribute",
                                             &tkAttributeType)))
        cmpFatal(ERRmetadata);

    // Build a memberref to the constructor of the CA.
    if  (FAILED(cmpWmde->DefineMemberRef(tkAttributeType,
                                         L".ctor",
                                         rSig,
                                         ulSigLength,
                                         &tkAttributeConstructor)))
        cmpFatal(ERRmetadata);

    // A descriptor for the above custom attribute (an array of these form a
    // SecurityAttributeSet).
    COR_SECATTR     sAttr;

    // Link to the CA constructor.
    sAttr.tkCtor = tkAttributeConstructor;

    // Link to the blob defined above.
    sAttr.pCustomAttribute  = (const void *)&rbAttrBlob;
    sAttr.cbCustomAttribute = sizeof(rbAttrBlob);

    // Attach the security attribute set to the assemblydef metadata token.
    if  (FAILED(cmpWmde->DefineSecurityAttributeSet(cmpCurAssemblyTok,
                                                    &sAttr,
                                                    1,
                                                    NULL)))
        cmpFatal(ERRmetadata);

    cycleCounterResume();
}

/*****************************************************************************
 *
 *  Attach a marshalling thingamabobber to the given token.
 */

void                compiler::cmpGenMarshalInfo(mdToken token, TypDef       type,
                                                               MarshalInfo  info)
{
    PCOR_SIGNATURE  sigPtr;
    size_t          sigLen;

    /* Weird special case: don't generate anything for wchar */

    if  (type->tdTypeKind == TYP_WCHAR)
        return;

    /* Create the marshalling signature */

    sigPtr = cmpGenMarshalSig(type, info, &sigLen);

    /* Attach the signature to the token, if non-empty */

    if  (sigLen)
    {
        cycleCounterPause();
        if  (cmpWmde->SetFieldMarshal(token, sigPtr, sigLen))
            cmpFatal(ERRmetadata);
        cycleCounterResume();
    }
}

/*****************************************************************************
 *
 *  Create a Unicode fully qualified metadata name for the given class or
 *  namespace.
 */

wchar   *           compiler::cmpGenMDname(SymDef sym,
                                           bool  full, wchar  *     buffAddr,
                                                       size_t       buffSize,
                                                       wchar  *   * buffHeapPtr)
{
    wchar   *       heapBuff = NULL;
    wchar   *       fullName;

    size_t          nameLen;
    SymDef          tempSym;
    wchar   *       nameDst;

    wchar           delim;

    symbolKinds     symKind = sym->sdSymKindGet();

    /* Do we need to prefix the name? */

    if  (sym == cmpGlobalNS)
    {
        fullName = NULL;
        goto DONE;
    }

    if  (sym->sdParent->sdSymKindGet() != symKind && !full)
    {
        /*
            We can only use the cmpUniConv() buffer once, so we'll
            use it for classes and save namespace names elsewhere.
         */

        if  (symKind == SYM_CLASS && sym->sdClass.sdcSpecific)
        {
            stringBuff      instName;

            /* Construct the class instance name and convert to Unicode */

            instName = cmpGlobalST->stTypeName(NULL, sym, NULL, NULL, false);

            fullName = cmpUniConv(instName, strlen(instName)+1);
        }
        else
            fullName = cmpUniConv(sym->sdName);

        if  (symKind != SYM_CLASS)
        {
            /* Use the local buffer */

            assert(strlen(sym->sdSpelling()) < buffSize);

            wcscpy(buffAddr, fullName); fullName = buffAddr;
        }

        goto DONE;
    }

    /* Compute the length of the qualified name */

    nameLen = 0;
    tempSym = sym;
    for (;;)
    {
        size_t          nlen;

        if  (tempSym->sdSymKind == SYM_CLASS && tempSym->sdClass.sdcSpecific)
            nlen = strlen(cmpGlobalST->stTypeName(NULL, tempSym, NULL, NULL, false));
        else
            nlen = tempSym->sdSpellLen();

        nameLen += nlen;

    SKIP:

        tempSym  = tempSym->sdParent;
        if  (tempSym == NULL)
            break;

        if  (full)
        {
            if  (tempSym->sdSymKind == SYM_CLASS)
                goto SKIP;
        }

        if  (tempSym->sdSymKindGet() != symKind || tempSym == cmpGlobalNS)
        {
            if  (!full)
                break;
        }

        nameLen++;
    }

    if  (nameLen < buffSize)
    {
        fullName = buffAddr;
    }
    else
    {
        heapBuff =
        fullName = (wchar*)SMCgetMem(this, roundUp((nameLen+1)*sizeof(*heapBuff)));
    }

    /* Now add the names to the buffer, in reverse order */

    delim   = (sym->sdSymKind == SYM_NAMESPACE || full) ? '.' : '$';

    nameDst = fullName + nameLen;
    tempSym = sym;
    for (;;)
    {
        size_t          thisLen = tempSym->sdSpellLen();
        wchar   *       uniName = cmpUniConv(tempSym->sdName);

        if  (tempSym->sdSymKind == SYM_CLASS && tempSym->sdClass.sdcSpecific)
        {
            const   char *  instName;

            instName = cmpGlobalST->stTypeName(NULL, tempSym, NULL, NULL, false);

            thisLen = strlen(instName);
            uniName = cmpUniConv(instName, thisLen+1);
        }
        else
        {
            thisLen = tempSym->sdSpellLen();
            uniName = cmpUniConv(tempSym->sdName);
        }

        *nameDst  = delim;
         nameDst -= thisLen;

        memcpy(nameDst, uniName, 2*thisLen);

        tempSym  = tempSym->sdParent;
        if  (tempSym->sdSymKindGet() != symKind || tempSym == cmpGlobalNS)
            break;

        nameDst--;
    }
    fullName[nameLen] = 0;

    fullName = nameDst; assert(nameDst == fullName);

DONE:

    *buffHeapPtr = heapBuff;

    return  fullName;
}

/*****************************************************************************
 *
 *  Generate metadata for the given class/enum (unless it's already been done).
 */

mdToken             compiler::cmpGenClsMetadata(SymDef clsSym, bool extref)
{
    bool            isClass;

    TypDef          clsTyp;

    SymDef          nspSym;

    GUID            GUIDbuf;
    GUID    *       GUIDptr = NULL;
    SymXinfoAtc     clsGUID = NULL;

    mdToken         intfTmp[55];
    mdToken *       intfTab = NULL;
    mdToken         baseTok = 0;

    unsigned        flags;

    mdTypeDef       tdef;

    wchar           nspBuff[MAX_PACKAGE_NAME];
    wchar   *       nspName;
    wchar   *       nspHeap = NULL;

    wchar           clsBuff[MAX_CLASS_NAME];
    wchar   *       clsName;
    wchar   *       clsHeap = NULL;

    wchar           fullName[MAX_PACKAGE_NAME + MAX_CLASS_NAME + 1];

    mdToken         clsToken;

    WMetaDataEmit * emitIntf;

    assert(clsSym);
    assert(clsSym->sdIsImport == false || extref);

    /* Get hold of the class/enum type */

    clsTyp = clsSym->sdType;

    /* Is this a class or enum? */

    if  (clsSym->sdSymKind == SYM_CLASS)
    {
        /* If the class has no method bodies, it will be external */

        if  (!clsSym->sdClass.sdcHasBodies && !extref)
        {
            // Being managed or no methods at all is the same as methods with bodies

            if  (!clsSym->sdClass.sdcHasMeths || clsSym->sdIsManaged || clsSym->sdClass.sdcHasLinks)
                clsSym->sdClass.sdcHasBodies = true;
            else
                extref = true;
        }

        /* Bail if we already have a typedef/ref */

        if  (clsSym->sdClass.sdcMDtypedef)
            return  clsSym->sdClass.sdcMDtypedef;

        /* Get hold of the token for the base class */

        if  (clsTyp->tdClass.tdcBase && clsTyp->tdIsManaged)
        {
            baseTok = cmpClsEnumToken(clsTyp->tdClass.tdcBase);

            /* Set the base class token to nil for interfaces */

            if  (clsTyp->tdClass.tdcFlavor == STF_INTF)
                baseTok = mdTypeRefNil;
        }

        /* Does the class implement any interfaces? */

        if  (clsTyp->tdClass.tdcIntf)
        {
            TypList     intfLst;
            unsigned    intfNum;

            /* Create the interface table */

            for (intfLst = clsTyp->tdClass.tdcIntf, intfNum = 0;
                 intfLst;
                 intfLst = intfLst->tlNext        , intfNum++)
            {
                if  (intfNum == arraylen(intfTmp) - 1)
                {
                    UNIMPL("oops, too many interfaces - allocate a buffer on the heap to keep the lot");
                }

                intfTmp[intfNum] = cmpClsEnumToken(intfLst->tlType);
            }

            intfTmp[intfNum] = 0; intfTab = intfTmp;
        }

        isClass = true;
    }
    else
    {
        assert(clsSym->sdSymKind == SYM_ENUM);

        if  (cmpConfig.ccIntEnums)
            clsSym->sdEnum.sdeMDtypedef = -1;

        /* Bail if we already have a typedef/ref */

        if  (clsSym->sdEnum.sdeMDtypedef)
            return  clsSym->sdEnum.sdeMDtypedef;

        isClass = false;

        /* For managed enums, pretend we inherit from Object */

        if  (clsSym->sdIsManaged)
            baseTok = cmpClsEnumToken(cmpClassObject->sdType);
    }

    /* Convert the namespace and class names */

    if  (cmpConfig.ccTestMask & 1)
    {
        /* Make sure the containing class has been processed */

        nspName = NULL;
        clsName = cmpGenMDname(clsSym, true, clsBuff, arraylen(clsBuff), &clsHeap);

//      printf("New-style type name: '%ls'\n", clsName);

        goto CAT_NAME;
    }

    for (nspSym = clsSym->sdParent;
         nspSym->sdSymKind == SYM_CLASS;
         nspSym = nspSym->sdParent)
    {
        assert(nspSym && nspSym != cmpGlobalNS);
    }

    nspName = cmpGenMDname(nspSym, false, nspBuff, arraylen(nspBuff), &nspHeap);
    clsName = cmpGenMDname(clsSym, false, clsBuff, arraylen(clsBuff), &clsHeap);

//  printf("NSP name = '%ls'\n", nspName);
//  printf("CLS name = '%ls'\n", clsName);
//  printf("\n");

CAT_NAME:

    // @todo:  This might need some cleanup.
#ifdef DEBUG
    ULONG ulFullNameLen;
    ulFullNameLen = 0;
    if (nspName)
        ulFullNameLen = wcslen(nspName) + 2;
    ulFullNameLen += wcslen(clsName) + 1;
    assert(ulFullNameLen <= (MAX_PACKAGE_NAME + MAX_CLASS_NAME + 1));
#endif

    fullName[0] = 0;
    if (nspName)
    {
        wcscpy(fullName, nspName);
        wcscat(fullName, L".");
    }
    wcscat(fullName, clsName);

//  printf("Full type name: '%ls'\n", fullName);

    /* Is this an external reference? */

    if  (extref)
    {
        mdToken         tref;
        mdToken         oref = mdTokenNil;

        if  (clsSym->sdParent->sdSymKind == SYM_CLASS)
        {
            oref = cmpGenClsMetadata(clsSym->sdParent);
        }

        cycleCounterPause();

        if  (FAILED(cmpWmde->DefineTypeRefByName(oref, fullName, &tref)))
            cmpFatal(ERRmetadata);

        cycleCounterResume();

        /* Are we creating an assembly ? */

        if  (cmpConfig.ccAssembly)
        {
            /* Is the type an assembly import ? */

            if  (clsSym->sdSymKind == SYM_CLASS)
            {
                if  (clsSym->sdClass.sdcAssemIndx != 0 &&
                     clsSym->sdClass.sdcAssemRefd == false)
                {
                    //cmpAssemblySymDef(clsSym);
                }
            }
            else
            {
                if  (clsSym->sdEnum .sdeAssemIndx != 0 &&
                     clsSym->sdEnum .sdeAssemRefd == false)
                {
                    //cmpAssemblySymDef(clsSym);
                }
            }
        }

        clsSym->sdClass.sdcMDtypedef = clsToken = tref;

        goto DONE;
    }

    /* Get hold of the emitter interface we need to use */

    emitIntf = cmpWmde;

    /* Construct the appropriate "flags" value */

    if  (clsSym->sdParent->sdSymKind == SYM_CLASS)
    {
        static
        unsigned        nestedClsAccFlags[] =
        {
            0,                      // ACL_ERROR
            tdNestedPublic,         // ACL_PUBLIC
            tdNestedFamily,         // ACL_PROTECTED
            tdNestedFamORAssem,     // ACL_DEFAULT
            tdNestedPrivate,        // ACL_PRIVATE
        };

        assert(nestedClsAccFlags[ACL_PUBLIC   ] == tdNestedPublic);
        assert(nestedClsAccFlags[ACL_PROTECTED] == tdNestedFamily);
        assert(nestedClsAccFlags[ACL_DEFAULT  ] == tdNestedFamORAssem);
        assert(nestedClsAccFlags[ACL_PRIVATE  ] == tdNestedPrivate);

        assert(clsSym->sdAccessLevel != ACL_ERROR);
        assert(clsSym->sdAccessLevel < arraylen(nestedClsAccFlags));

        flags = nestedClsAccFlags[clsSym->sdAccessLevel];
    }
    else
    {
        switch (clsSym->sdAccessLevel)
        {
        case ACL_DEFAULT:
            flags = 0;
            break;

        case ACL_PUBLIC:
            flags = tdPublic;
            break;

        default:
            flags = 0;
            break;
        }
    }

    if  (isClass)
    {
        assert(clsSym->sdClass.sdcFlavor == clsTyp->tdClass.tdcFlavor);

        /* Is this a managed class? */

        if  (!clsTyp->tdIsManaged)
            flags  |= tdSealed|tdSequentialLayout;

        /* Is this a value type? */

        if  (clsTyp->tdClass.tdcValueType || !clsTyp->tdIsManaged)
        {
            flags |= tdSealed;

            /* Set the base type to "System::ValueType" */

            assert(cmpClassValType && cmpClassValType->sdSymKind == SYM_CLASS);

            baseTok = cmpClsEnumToken(cmpClassValType->sdType);
        }

        /* Has the class been marked as "@dll.struct" ? */

        if  (clsSym->sdClass.sdcMarshInfo)
            flags |= tdSequentialLayout;

        /* Is this an interface? */

        if  (clsTyp->tdClass.tdcFlavor == STF_INTF)
            flags |= tdInterface;

        /* Is the class sealed? */

        if  (clsSym->sdIsSealed)
            flags |= tdSealed;

        /* Is the class abstract? */

        if  (clsSym->sdIsAbstract)
            flags |= tdAbstract;

        /* Is the class serializable? */
        if (clsSym->sdClass.sdcSrlzable) {
            flags |= tdSerializable;
        }

        /* Do we have a GUID specification for the class? */

        if  (clsSym->sdClass.sdcExtraInfo)
        {
            atCommFlavors   flavor;

            flavor  = (clsTyp->tdClass.tdcFlavor == STF_INTF) ? AC_COM_INTF
                                                              : AC_COM_REGISTER;

            clsGUID = cmpFindATCentry(clsSym->sdClass.sdcExtraInfo, flavor);
            if  (clsGUID)
            {
                const   char *  GUIDstr;

                assert(clsGUID->xiAtcInfo);
                assert(clsGUID->xiAtcInfo->atcFlavor == flavor);

                GUIDstr = clsGUID->xiAtcInfo->atcInfo.atcReg.atcGUID->csStr;

//              printf("GUID='%s'\n", GUIDstr);

                if  (parseGUID(GUIDstr, &GUIDbuf, false))
                    cmpGenError(ERRbadGUID, GUIDstr);

                GUIDptr = &GUIDbuf;

                /* Strange thing - mark interfaces as "import" (why?) */

                if  (clsSym->sdClass.sdcFlavor == STF_INTF)
                    flags |= tdImport;
            }

            /* Do we have ansi/unicode/etc information? */

            if  (clsSym->sdClass.sdcMarshInfo)
            {
                SymXinfoAtc     clsStr;

                clsStr = cmpFindATCentry(clsSym->sdClass.sdcExtraInfo, AC_DLL_STRUCT);
                if  (clsStr)
                {
                    assert(clsStr->xiAtcInfo);
                    assert(clsStr->xiAtcInfo->atcFlavor == AC_DLL_STRUCT);

                    switch (clsStr->xiAtcInfo->atcInfo.atcStruct.atcStrings)
                    {
                    case  2: flags |= tdAnsiClass   ; break;
                    case  3: flags |= tdUnicodeClass; break;
                    case  4: flags |= tdAutoClass   ; break;
                    default: /* ??? warning ???? */   break;
                    }
                }
            }
        }
    }
    else
    {
        /* This is an enum type */

        flags  |= tdSealed;

        /* Set the base type to "System::Enum" */

        assert(cmpClassEnum && cmpClassEnum->sdSymKind == SYM_CLASS);

        baseTok = cmpClsEnumToken(cmpClassEnum->sdType);
    }

//  printf("NOTE: Define MD for class '%s'\n", clsSym->sdSpelling()); fflush(stdout);

    /* Ready to create the typedef for the class */

    assert(extref == false);

    cycleCounterPause();

    /* Is this a type nested within a class? */

    if  (clsSym->sdParent->sdSymKind == SYM_CLASS)
    {
        if  (emitIntf->DefineNestedType(fullName,       // class     name
                                        flags,          // attributes
                                        baseTok,        // base class
                                        intfTab,        // interfaces
                                        clsSym->sdParent->sdClass.sdcMDtypedef,    // enclosing class
                                        &tdef))         // resulting token
        {
            cmpFatal(ERRmetadata);
        }
    }
    else
    {
        if  (emitIntf->DefineTypeDef(fullName,      // class     name
                                     flags,         // attributes
                                     baseTok,       // base class
                                     intfTab,       // interfaces
                                     &tdef))        // resulting token
        {
            cmpFatal(ERRmetadata);
        }
    }

    cycleCounterResume();

    /* Are we processing a class or enum type ? */

    if  (isClass)
    {
        /* Save the typedef token in the class */

        clsSym->sdClass.sdcMDtypedef = tdef;

        /* Append this type to the list of generated typedefs */

        if  (cmpTypeDefList)
            cmpTypeDefLast->sdClass.sdNextTypeDef = clsSym;
        else
            cmpTypeDefList                        = clsSym;

        cmpTypeDefLast = clsSym;

        /* Is this an unmanaged class with an explicit layout ? */

        if  (!clsTyp->tdIsManaged && clsTyp->tdClass.tdcLayoutDone)
        {
            size_t          sz;
            size_t          al;

            assert(clsSym->sdClass.sdcMarshInfo == false);

            /* Set the layout for the class type */

            sz = cmpGetTypeSize(clsTyp, &al);

//          printf("Packing = %u for [%08X] '%ls'\n", al, tdef, clsName);

            cycleCounterPause();

            if  (emitIntf->SetClassLayout(tdef, al, NULL, sz))
                cmpFatal(ERRmetadata);

            cycleCounterResume();
        }

        /* Has the class been marked as "deprecated" ? */

        if  (clsSym->sdIsDeprecated)
        {
            cmpAttachMDattr(tdef, L"System.ObsoleteAttribute"           ,
                                   "System.ObsoleteAttribute"           , &cmpAttrDeprec);
        }

        /* Is the class serializable? */

        if  (clsSym->sdClass.sdcSrlzable)
        {
            cmpAttachMDattr(tdef, L"System.SerializableAttribute",
                                   "System.SerializableAttribute", &cmpAttrSerlzb);
        }

        /* Is this a non-dual interface? */

        if  (clsGUID && !clsGUID->xiAtcInfo->atcInfo.atcReg.atcDual
                     && clsSym->sdClass.sdcFlavor == STF_INTF)
        {
            unsigned        nondual = 0x00010001;

            cmpAttachMDattr(tdef, L"System.Runtime.InteropServices.InterfaceTypeAttribute",
                                   "System.Runtime.InteropServices.InterfaceTypeAttribute",
                                   &cmpAttrIsDual,
                                   ELEMENT_TYPE_I2,
                                   &nondual,
                                   2 + sizeof(unsigned short));
        }

        /* Do we have a security specification for the class? */

        if  (cmpFindSecSpec(clsSym->sdClass.sdcExtraInfo))
            cmpSecurityMD(tdef, clsSym->sdClass.sdcExtraInfo);

        /* Look for any custom attributes that the class might have */

        if  (clsSym->sdClass.sdcExtraInfo)
            cmpAddCustomAttrs(clsSym->sdClass.sdcExtraInfo, tdef);
    }
    else
    {
        clsSym->sdEnum .sdeMDtypedef = tdef;

        /* Append this type to the list of generated typedefs */

        if  (cmpTypeDefList)
            cmpTypeDefLast->sdEnum.sdNextTypeDef = clsSym;
        else
            cmpTypeDefList                       = clsSym;

        cmpTypeDefLast = clsSym;

        /* Look for any custom attributes that the enum  might have */

        if  (clsSym->sdEnum .sdeExtraInfo)
            cmpAddCustomAttrs(clsSym->sdEnum .sdeExtraInfo, tdef);
    }

    /* Are we creating an assembly and do we have a public type ? */

//			  create manifest entries for all types, not just public ones;
//            note that there is a matching version in cmpAssemblySymDef()

    //if  (cmpConfig.ccAssembly) // && clsSym->sdAccessLevel == ACL_PUBLIC)
    //    cmpAssemblySymDef(clsSym, tdef);

    clsToken = tdef;

DONE:

    if  (nspHeap) SMCrlsMem(this, nspHeap);
    if  (clsHeap) SMCrlsMem(this, clsHeap);

    return  clsToken;
}

/*****************************************************************************
 *
 *  Generate metadata for any types defined within the given symbol.
 */

void                compiler::cmpGenTypMetadata(SymDef sym)
{
    if  (sym->sdIsImport && sym->sdSymKind != SYM_NAMESPACE)
        return;

    if  (sym->sdCompileState < CS_DECLARED)
    {
        /* If this is a nested class, declare it now */

        if  (sym->sdSymKind == SYM_CLASS)
        {
            cmpDeclSym(sym);

            if  (sym->sdCompileState < CS_DECLARED)
                goto KIDS;
        }
        else
            goto KIDS;
    }

    switch (sym->sdSymKind)
    {
    case SYM_CLASS:

        // force base class / interfaces to be generated first

        if  (sym->sdType->tdClass.tdcBase)
        {
            SymDef          baseSym = sym->sdType->tdClass.tdcBase->tdClass.tdcSymbol;

            if  (!baseSym->sdIsImport)
                cmpGenClsMetadata(baseSym);
        }

        if  (sym->sdType->tdClass.tdcIntf)
        {
            TypList     intfLst;

            for (intfLst = sym->sdType->tdClass.tdcIntf;
                 intfLst;
                 intfLst = intfLst->tlNext)
            {
                SymDef          intfSym = intfLst->tlType->tdClass.tdcSymbol;

                if  (!intfSym->sdIsImport)
                    cmpGenClsMetadata(intfSym);
            }
        }

        cmpGenClsMetadata(sym);
        break;

    case SYM_ENUM:
        cmpGenClsMetadata(sym);
        return;
    }

KIDS:

    /* Process any children the type might have */

    if  (sym->sdHasScope())
    {
        SymDef          child;

        for (child = sym->sdScope.sdScope.sdsChildList;
             child;
             child = child->sdNextInScope)
        {
            if  (child->sdHasScope())
                cmpGenTypMetadata(child);
        }
    }
}

/*****************************************************************************
 *
 *  Generate metadata for any global functions and variables contained within
 *  the given namespace.
 */

void                compiler::cmpGenGlbMetadata(SymDef sym)
{
    SymDef          child;

    assert(sym->sdSymKind == SYM_NAMESPACE);

    /* Process all children */

    for (child = sym->sdScope.sdScope.sdsChildList;
         child;
         child = child->sdNextInScope)
    {
        switch (child->sdSymKind)
        {
            SymDef          ovl;

        case SYM_FNC:

            if  (child->sdIsImport)
                continue;

            for (ovl = child; ovl; ovl = ovl->sdFnc.sdfNextOvl)
            {
                if  (!ovl->sdIsImplicit)
                {
//                  printf("Gen metadata for global fnc '%s'\n", ovl->sdSpelling());
                    cmpGenFncMetadata(ovl);
                }
            }
            break;

        case SYM_VAR:

//          if  (!strcmp(child->sdSpelling(), "CORtypeToSMCtype")) printf("yo!\n");

            if  (child->sdIsImport)
                continue;

            if  (child->sdIsMember && !child->sdIsStatic)
                break;

//          printf("Gen metadata for global var '%s'\n", child->sdSpelling());
            cmpGenFldMetadata(child);
            break;

        case SYM_NAMESPACE:
            cmpGenGlbMetadata(child);
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Generate metadata for the members of the given class/enum.
 */

void                compiler::cmpGenMemMetadata(SymDef sym)
{
    TypDef          type;
    SymDef          memSym;

    assert(sym->sdIsImport == false);

    type = sym->sdType; assert(type);

    if  (sym->sdSymKind == SYM_CLASS)
    {
        unsigned        packing;
        bool            hasProps;

        bool            isIntf = (sym->sdClass.sdcFlavor == STF_INTF);

//      printf("genMDbeg(%d) '%s'\n", doMembers, sym->sdSpelling());

        /* Do we have packing/etc information for the class? */

        packing = 0;

        if  (sym->sdClass.sdcExtraInfo)
        {
            SymXinfoAtc     clsStr;

            clsStr = cmpFindATCentry(sym->sdClass.sdcExtraInfo, AC_DLL_STRUCT);
            if  (clsStr)
            {
                assert(clsStr->xiAtcInfo);
                assert(clsStr->xiAtcInfo->atcFlavor == AC_DLL_STRUCT);

                packing = clsStr->xiAtcInfo->atcInfo.atcStruct.atcPack;

                if  (packing == 0) packing = 8;
            }
        }

//      printf("Gen metadata for members of '%s'\n", sym->sdSpelling());

#ifndef __IL__
//      if  (!strcmp(sym->sdSpelling(), "hashTab")) __asm int 3
#endif

        /* Do we need to create the silly layout table? */

        COR_FIELD_OFFSET *  fldTab = NULL;
        COR_FIELD_OFFSET *  fldPtr = NULL;
        unsigned            fldCnt = 0;

        if  (!type->tdIsManaged && cmpConfig.ccGenDebug)
        {
            /* Count non-static data members */

            for (memSym = sym->sdScope.sdScope.sdsChildList, fldCnt = 0;
                 memSym;
                 memSym = memSym->sdNextInScope)
            {
                if  (memSym->sdSymKind == SYM_VAR && !memSym->sdIsStatic
                                                  && !memSym->sdVar.sdvGenSym)
                {
                    fldCnt++;
                }
            }

            if  (fldCnt)
            {
                /* Allocate the field layout table */

                fldTab =
                fldPtr = (COR_FIELD_OFFSET*)SMCgetMem(this, (fldCnt+1)*sizeof(*fldTab));
            }
        }

        /* Generate metadata for all members */

        for (memSym = sym->sdScope.sdScope.sdsChildList, hasProps = false;
             memSym;
             memSym = memSym->sdNextInScope)
        {
            switch (memSym->sdSymKind)
            {
                SymDef          ovlSym;

            case SYM_VAR:

                /* Skip any instance members of generic instance classes */

                if  (memSym->sdVar.sdvGenSym && !memSym->sdIsStatic)
                    break;

                /* Ignore any non-static members of unmanaged classes */

                if  (memSym->sdIsManaged == false &&
                     memSym->sdIsMember  != false &&
                     memSym->sdIsStatic  == false)
                     break;

                /* Generate metadata for the data member */

                cmpGenFldMetadata(memSym);

                /* Are we generating field layout/marshalling info? */

                if  (memSym->sdIsStatic)
                    break;

                if  (sym->sdClass.sdcMarshInfo)
                {
                    SymXinfoCOM     marsh;

                    /* Get hold of the marshalling info descriptor */

                    marsh = NULL;
                    if  (!memSym->sdVar.sdvConst)
                        marsh = cmpFindMarshal(memSym->sdVar.sdvFldInfo);

                    /* Generate marshalling info for the field */

                    cmpGenMarshalInfo(memSym->sdVar.sdvMDtoken,
                                      memSym->sdType,
                                      marsh ? marsh->xiCOMinfo : NULL);
                }
                else if (fldPtr)
                {
                    /* Here we must have an unmanaged class member */

                    assert(type->tdIsManaged == false && cmpConfig.ccGenDebug);

                    /* Append an entry to the field layout table */

                    fldPtr->ridOfField = memSym->sdVar.sdvMDtoken;
                    fldPtr->ulOffset   = memSym->sdVar.sdvOffset;

                    fldPtr++;
                }
                break;

            case SYM_FNC:

                for (ovlSym = memSym; ovlSym; ovlSym = ovlSym->sdFnc.sdfNextOvl)
                    cmpGenFncMetadata(ovlSym);

                /* Special case: System::Attribute needs an attribute of itself */

                if  (sym == cmpAttrClsSym || sym == cmpAuseClsSym)
                {
                    for (ovlSym = memSym; ovlSym; ovlSym = ovlSym->sdFnc.sdfNextOvl)
                    {
                        if  (ovlSym->sdFnc.sdfCtor)
                        {
                            if  (ovlSym->sdType->tdFnc.tdfArgs.adCount == 1)
                            {
                                unsigned short  blob[3];

                                /* Add the custom attribute to the target token */

                                assert(sym->sdClass.sdcMDtypedef);
                                assert(ovlSym->sdFnc.sdfMDtoken);

                                blob[0] = 1;
                                blob[1] = 4;
                                blob[2] = 0;

                                cycleCounterPause();

                                if  (cmpWmde->DefineCustomAttribute(sym->sdClass.sdcMDtypedef,
                                                                    ovlSym->sdFnc.sdfMDtoken,
                                                                    &blob,
                                                                    sizeof(short) + sizeof(int),
                                                                    NULL))
                                    cmpFatal(ERRmetadata);

                                cycleCounterResume();

                                break;
                            }
                        }
                    }
                }

                break;

            case SYM_PROP:

                hasProps = true;
                break;

            case SYM_CLASS:
                break;

            default:
#ifdef  DEBUG
                printf("'%s': ", cmpGlobalST->stTypeName(NULL, memSym, NULL, NULL, true));
#endif
                NO_WAY(!"unexpected member");
            }
        }

        /*
            Do any of the fields of the class have marshalling info,
            do we have packing information for the class, or is this
            an unmanaged class and are we generating debug info ?
         */

        if  (fldTab || packing)
        {
            if  (!type->tdIsManaged && cmpConfig.ccGenDebug)
            {
                assert(fldPtr == fldCnt + fldTab);

                fldPtr->ridOfField = mdFieldDefNil;
                fldPtr->ulOffset   = 0;

                if  (!packing)
                    packing = sizeof(int);
            }
            else
            {
                fldTab = NULL;
            }

//          printf("Packing = %u for [%08X] '%s'\n", packing, sym->sdClass.sdcMDtypedef, sym->sdSpelling());

            cycleCounterPause();

            if  (cmpWmde->SetClassLayout(sym->sdClass.sdcMDtypedef, packing, fldTab, 0))
                cmpFatal(ERRmetadata);

            cycleCounterResume();

            /* If we allocated a field table, free it now */

            if  (fldTab)
                SMCrlsMem(this, fldTab);
        }

        /* Did we encounter any properties? */

        if  (hasProps)
        {
            for (memSym = sym->sdScope.sdScope.sdsChildList;
                 memSym;
                 memSym = memSym->sdNextInScope)
            {
                SymDef          opmSym;

                if  (memSym->sdSymKind != SYM_PROP)
                    continue;

                for (opmSym = memSym; opmSym; opmSym = opmSym->sdProp.sdpNextOvl)
                {
                    TypDef          memTyp = opmSym->sdType;;

                    PCOR_SIGNATURE  sigPtr;
                    size_t          sigLen;

                    mdMethodDef     mtokGet;
                    mdMethodDef     mtokSet;

                    mdProperty      propTok;

                    unsigned        flags;

                    assert(opmSym->sdSymKind == SYM_PROP);
                    assert(opmSym->sdProp.sdpMDtoken == 0);

                    /* Generate the property member's signature */

                    if  (memTyp->tdTypeKind == TYP_FNC)
                    {
                        sigPtr = (PCOR_SIGNATURE)cmpGenMemberSig(opmSym, NULL, NULL, NULL, &sigLen);
                    }
                    else
                    {
                        unsigned        flags;

                        // pretend it's a method

                        flags = IMAGE_CEE_CS_CALLCONV_DEFAULT|
                                IMAGE_CEE_CS_CALLCONV_PROPERTY;

                        if  (!opmSym->sdIsStatic)
                            flags |= IMAGE_CEE_CS_CALLCONV_HASTHIS;

                        cmpMDsigStart();
                        cmpMDsigAdd_I1(flags);
                        cmpMDsigAddCU4(0);
                        cmpMDsigAddTyp(memTyp);

                        sigPtr = cmpMDsigEnd(&sigLen);
                    }

                    /* Get hold of the getter/setter accessor tokens, if any */

                    mtokGet = 0;
                    if  (opmSym->sdProp.sdpGetMeth)
                    {
                        assert(opmSym->sdProp.sdpGetMeth->sdSymKind == SYM_FNC);
                        assert(opmSym->sdProp.sdpGetMeth->sdFnc.sdfMDtoken);

                        mtokGet = opmSym->sdProp.sdpGetMeth->sdFnc.sdfMDtoken;
                    }

                    mtokSet = 0;
                    if  (opmSym->sdProp.sdpSetMeth)
                    {
                        assert(opmSym->sdProp.sdpSetMeth->sdSymKind == SYM_FNC);
                        assert(opmSym->sdProp.sdpSetMeth->sdFnc.sdfMDtoken);

                        mtokSet = opmSym->sdProp.sdpSetMeth->sdFnc.sdfMDtoken;
                    }

                    flags = 0;

                    /* We're ready to generate metadata for the property */

                    cycleCounterPause();

                    if  (cmpWmde->DefineProperty(sym->sdClass.sdcMDtypedef,
                                                 cmpUniConv(opmSym->sdName),
                                                 flags,
                                                 sigPtr,
                                                 sigLen,
                                                 ELEMENT_TYPE_VOID,
                                                 NULL,
                                                 -1,
                                                 mtokSet,
                                                 mtokGet,
                                                 NULL,
                                                 &propTok))
                    {
                        cmpFatal(ERRmetadata);
                    }

                    cycleCounterResume();

                    /* Has the property been marked as "deprecated" ? */

                    if  (memSym->sdIsDeprecated)
                    {
                        cmpAttachMDattr(propTok, L"System.ObsoleteAttribute"            ,
                                                  "System.ObsoleteAttribute"            , &cmpAttrDeprec);
                    }

                    /* Is the property "default" ? */

                    if  (memSym->sdIsDfltProp)
                    {
                        cmpAttachMDattr(propTok, L"System.Reflection.DefaultMemberAttribute",
                                                  "System.Reflection.DefaultMemberAttribute", &cmpAttrDefProp);
                    }

                    /* Output any custom properties */

                    if  (opmSym->sdProp.sdpExtraInfo)
                        cmpAddCustomAttrs(opmSym->sdProp.sdpExtraInfo, propTok);

//                  printf("MD for prop [%08X] '%s'\n", propTok, cmpGlobalST->stTypeName(opmSym->sdType, opmSym, NULL, NULL, true));

                    opmSym->sdProp.sdpMDtoken = propTok;
                }
            }
        }

//      printf("genMDend(%d) '%s'\n", doMembers, sym->sdSpelling());
    }
    else
    {
        assert(sym->sdSymKind == SYM_ENUM);

        PCOR_SIGNATURE      sigPtr;
        size_t              sigLen;

        mdTypeSpec          fakeTok;

        if  (cmpConfig.ccIntEnums)
            return;

        /* Create a signature for the underlying integer type */

                 cmpMDsigStart ();
                 cmpMDsigAdd_I1(IMAGE_CEE_CS_CALLCONV_FIELD);
                 cmpMDsigAddTyp(sym->sdType->tdEnum.tdeIntType);
        sigPtr = cmpMDsigEnd   (&sigLen);

//      printf("Gen metadata for enumids of '%s'\n", sym->sdSpelling());

        cycleCounterPause();

        if  (cmpWmde->DefineField(sym->sdEnum.sdeMDtypedef,
                                  L"value__",
                                  fdPublic,
                                  sigPtr,
                                  sigLen,
                                  ELEMENT_TYPE_VOID,
                                  NULL,
                                  -1,
                                  &fakeTok))
        {
            cmpFatal(ERRmetadata);
        }

        cycleCounterResume();

        if  (!sym->sdIsManaged && !cmpConfig.ccGenDebug)
            return;

        /* Generate metadata for the actual enumerator values */

        for (memSym = type->tdEnum.tdeValues;
             memSym;
             memSym = memSym->sdEnumVal.sdeNext)
        {
            assert(memSym->sdSymKind == SYM_ENUMVAL);

            cmpGenFldMetadata(memSym);
        }
    }
}

/*****************************************************************************
 *
 *  Set RVA's (in metadata) for all global variables.
 */

void                compiler::cmpSetGlobMDoffsR(SymDef scope, unsigned dataOffs)
{
    SymDef          sym;

    for (sym = scope->sdScope.sdScope.sdsChildList;
         sym;
         sym = sym->sdNextInScope)
    {
        switch (sym->sdSymKind)
        {
        case SYM_VAR:

#ifndef __IL__
//          if  (!strcmp(sym->sdSpelling(), "optionInfo")) __asm int 3
#endif

            if  (sym->sdIsImport == false &&
                 sym->sdIsMember == false)
            {
                assert(sym->sdVar.sdvMDtoken);

//              printf("Set RVA to %08X for '%s'\n", sym->sdVar.sdvOffset + dataOffs, sym->sdSpelling());

                if  (FAILED(cmpWmde->SetFieldRVA(sym->sdVar.sdvMDtoken, sym->sdVar.sdvOffset + dataOffs)))
                    cmpFatal(ERRmetadata);
            }
            break;

        case SYM_CLASS:
            if  (!sym->sdIsManaged)
            {
                SymDef          mem;

                for (mem = sym->sdScope.sdScope.sdsChildList;
                     mem;
                     mem = mem->sdNextInScope)
                {
                    if  (mem->sdSymKind == SYM_VAR && mem->sdIsStatic)
                    {
//                      printf("Set RVA to %08X for '%s'\n", mem->sdVar.sdvOffset + dataOffs, mem->sdSpelling());

                        if  (FAILED(cmpWmde->SetFieldRVA(mem->sdVar.sdvMDtoken, mem->sdVar.sdvOffset + dataOffs)))
                            cmpFatal(ERRmetadata);
                    }
                }
            }
            break;

        case SYM_NAMESPACE:
            cmpSetGlobMDoffsR(sym, dataOffs);
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Set RVA's (in metadata) for all string constants.
 */

void            compiler::cmpSetStrCnsOffs(unsigned strOffs)
{
    for (strCnsPtr str = cmpStringConstList; str; str = str->sclNext)
    {
        if  (FAILED(cmpWmde->SetFieldRVA(str->sclTok, str->sclAddr + strOffs)))
            cmpFatal(ERRmetadata);
    }
}

void                compiler::cmpSetGlobMDoffs(unsigned dataOffs)
{

    SymList         list;

    /* Set RVA's for all static local variables of all functions */

    for (list = cmpLclStatListP; list; list = list->slNext)
    {
        SymDef         varSym = list->slSym;

        assert(varSym->sdSymKind == SYM_VAR);
        assert(varSym->sdVar.sdvLocal == false);
        assert(varSym->sdIsStatic);
        assert(varSym->sdType && !varSym->sdIsManaged);

        if  (FAILED(cmpWmde->SetFieldRVA(varSym->sdVar.sdvMDtoken, varSym->sdVar.sdvOffset + dataOffs)))
            cmpFatal(ERRmetadata);
    }

    /* Set RVA's for all global variables (recursively) */

    cmpSetGlobMDoffsR(cmpGlobalNS, dataOffs);
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\foldexpr.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include <float.h>

/*****************************************************************************/

static
double              toDouble(unsigned __int64 val)
{
    __int64         iv = (__int64)val;
    double          dv = (double )iv;

    if  (iv < 0)
        dv += 4294967296.0 * 4294967296.0;  // this is 2**64

    return  dv;
}

/*****************************************************************************
 *
 *  Try to fold a binary operator with two string literal operands.
 */

Tree                compiler::cmpFoldStrBinop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    assert(op1->tnOper == TN_CNS_STR);
    assert(op2->tnOper == TN_CNS_STR);

    const   char *  sv1 = op1->tnStrCon.tnSconVal;
//  size_t          sl1 = op1->tnStrCon.tnSconLen;

    const   char *  sv2 = op2->tnStrCon.tnSconVal;
//  size_t          sl2 = op2->tnStrCon.tnSconLen;

    __int32         rel;

    switch (expr->tnOper)
    {
    case TN_EQ : rel = (strcmp(sv1, sv2) == 0); break;
    case TN_NE : rel = (strcmp(sv1, sv2) != 0); break;
    case TN_LT : rel = (strcmp(sv1, sv2) <  0); break;
    case TN_LE : rel = (strcmp(sv1, sv2) <= 0); break;
    case TN_GE : rel = (strcmp(sv1, sv2) >= 0); break;
    case TN_GT : rel = (strcmp(sv1, sv2) >  0); break;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

    assert(expr->tnVtyp <= TYP_INT);

    expr->tnOper             = TN_CNS_INT;
    expr->tnIntCon.tnIconVal = rel;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a unary operator with a 32-bit integer constant operand.
 */

Tree                compiler::cmpFoldIntUnop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;

    assert(op1->tnOper == TN_CNS_INT);

    // ISSUE: Does the following work for enum types and small integers?

    __int32         iv1 = op1->tnIntCon.tnIconVal;

    bool            uns = varTypeIsUnsigned(cmpActualVtyp(expr->tnType));

    /* Special case: cast of 'null' or 'int -> ptr' */

    if  (op1->tnVtyp == TYP_REF || op1->tnVtyp == TYP_PTR)
    {
        assert(expr->tnOper == TN_CAST);

        assert(expr->tnVtyp == TYP_REF  ||
               expr->tnVtyp == TYP_PTR  ||
               expr->tnVtyp == TYP_INT  ||
               expr->tnVtyp == TYP_UINT ||
               expr->tnVtyp == TYP_ARRAY);

        goto BASH_TYPE;
    }

    assert(op1->tnVtyp <= TYP_UINT || op1->tnVtyp == TYP_ENUM);

    switch (expr->tnOper)
    {
        var_types       dstVtp;

    case TN_CAST:

        dstVtp = expr->tnVtypGet();

    CAST_REP:

        switch (dstVtp)
        {
        case TYP_PTR:
        case TYP_REF:

            // The only address that can be cast is 'null'

            break;

        case TYP_CHAR  : iv1 = (  signed char )iv1; break;
        case TYP_UCHAR : iv1 = (unsigned char )iv1; break;
        case TYP_SHORT : iv1 = (  signed short)iv1; break;
        case TYP_USHORT:
        case TYP_WCHAR : iv1 = (unsigned short)iv1; break;

        case TYP_INT   :
        case TYP_UINT  : break;

        case TYP_LONG:

            /* Bash the node operator (in addition to the type) */

            op1->tnOper             = TN_CNS_LNG;
            op1->tnLngCon.tnLconVal = (__int64)(uns ? (unsigned)iv1
                                                    :           iv1);
            goto BASH_TYPE;

        case TYP_FLOAT:

            /* Bash the node operator (in addition to the type) */

            op1->tnOper             = TN_CNS_FLT;
            op1->tnFltCon.tnFconVal = (float  )(uns ? (unsigned)iv1
                                                    :           iv1);
            goto BASH_TYPE;

        case TYP_DOUBLE:

            /* Bash the node operator (in addition to the type) */

            op1->tnOper             = TN_CNS_DBL;
            op1->tnDblCon.tnDconVal = (double )(uns ? (unsigned)iv1
                                                    :           iv1);
            goto BASH_TYPE;

        case TYP_CLASS:
            // ISSUE: Should we fold this ?
            return  expr;

        case TYP_ENUM:
            dstVtp = expr->tnType->tdEnum.tdeIntType->tdTypeKindGet();
            goto CAST_REP;

        default:

            // UNDONE: need to handle more cases

#ifdef DEBUG
            cmpParser->parseDispTree(expr);
#endif
            NO_WAY(!"unhandled cast type");
            return expr;
        }

        op1->tnIntCon.tnIconVal = iv1;

        /* Bash the type of the operand and return it */

    BASH_TYPE:

        op1->tnVtyp   = expr->tnVtyp;
        op1->tnType   = expr->tnType;
        op1->tnFlags |= TNF_BEEN_CAST;

        return op1;

    case TN_NEG:
        iv1 = -iv1;
        break;

    case TN_NOT:
        iv1 = ~iv1;
        break;

    case TN_LOG_NOT:
        iv1 = !iv1;
        break;

    case TN_NOP:
        break;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

    assert(expr->tnVtyp <= TYP_UINT || expr->tnVtyp == TYP_ENUM);

    expr->tnOper             = TN_CNS_INT;
    expr->tnIntCon.tnIconVal = iv1;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a binary operator with 32-bit integer constant operands.
 */

Tree                compiler::cmpFoldIntBinop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    assert(op1->tnOper == TN_CNS_INT && (op1->tnVtyp <= TYP_UINT || op1->tnVtyp == TYP_ENUM));
    assert(op2->tnOper == TN_CNS_INT && (op2->tnVtyp <= TYP_UINT || op2->tnVtyp == TYP_ENUM));

    __int32         iv1 = op1->tnIntCon.tnIconVal;
    __int32         iv2 = op2->tnIntCon.tnIconVal;

    bool            uns = varTypeIsUnsigned(cmpActualVtyp(expr->tnType));

    switch (expr->tnOper)
    {
    case TN_ADD: iv1  += iv2; break;
    case TN_SUB: iv1  -= iv2; break;
    case TN_MUL: iv1  *= iv2; break;

    case TN_DIV: if (iv2 == 0) goto INT_DIV_ZERO;
                 if (uns)
                     iv1  = (unsigned)iv1 / (unsigned)iv2;
                 else
                     iv1 /= iv2;
                 break;

    case TN_MOD: if (iv2 == 0) goto INT_DIV_ZERO;
                 if (uns)
                     iv1  = (unsigned)iv1 % (unsigned)iv2;
                 else
                     iv1 %= iv2;
                 break;

    case TN_OR : iv1  |= iv2; break;
    case TN_XOR: iv1  ^= iv2; break;
    case TN_AND: iv1  &= iv2; break;

    // ISSUE: Need to check for signed/unsigned shift count!

    case TN_LSH: iv1 <<= iv2; break;
    case TN_RSH: if (uns)
                     iv1   = (unsigned)iv1 >> iv2;
                 else
                     iv1 >>= iv2;
                 break;

    case TN_EQ : iv1 = (iv1 == iv2); break;
    case TN_NE : iv1 = (iv1 != iv2); break;

    case TN_LT : if (uns)
                     iv1 = ((unsigned)iv1 <  (unsigned)iv2);
                 else
                     iv1 = (iv1 <  iv2);
                 break;
    case TN_LE : if (uns)
                     iv1 = ((unsigned)iv1 <= (unsigned)iv2);
                 else
                     iv1 = (iv1 <  iv2);
                 break;
    case TN_GE : if (uns)
                     iv1 = ((unsigned)iv1 >= (unsigned)iv2);
                 else
                     iv1 = (iv1 <  iv2);
                 break;
    case TN_GT : if (uns)
                     iv1 = ((unsigned)iv1 >  (unsigned)iv2);
                 else
                     iv1 = (iv1 <  iv2);
                 break;

    case TN_LOG_OR : iv1 = iv1 || iv2; break;
    case TN_LOG_AND: iv1 = iv1 && iv2; break;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

    assert(expr->tnVtyp <= TYP_UINT || expr->tnVtyp == TYP_ENUM);

    expr->tnOper             = TN_CNS_INT;
    expr->tnIntCon.tnIconVal = iv1;

    return expr;

INT_DIV_ZERO:

    cmpError(ERRdivZero);

    expr->tnOper             = TN_ERROR;
    expr->tnIntCon.tnIconVal = 0;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a unary operator with a 64-bit integer constant operand.
 */

Tree                compiler::cmpFoldLngUnop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;

    assert(op1->tnOper == TN_CNS_LNG);

    // ISSUE: Does the following work for enum types and small integers?

    __int64         lv1 = op1->tnLngCon.tnLconVal;

    bool            uns = varTypeIsUnsigned(cmpActualVtyp(expr->tnType));

    /* Special case: cast of 'null' */

    if  (op1->tnVtyp == TYP_REF)
    {
        assert(lv1 == 0);
        assert(expr->tnVtyp == TYP_REF ||
               expr->tnVtyp == TYP_PTR ||
               expr->tnVtyp == TYP_ARRAY);

        goto BASH_TYPE;
    }

    assert(op1->tnVtyp == TYP_LONG  ||
           op1->tnVtyp == TYP_ULONG ||
           op1->tnVtyp == TYP_ENUM);

    switch (expr->tnOper)
    {
    case TN_CAST:

        switch (expr->tnVtyp)
        {
        case TYP_REF:

            // The only address that can be cast is 'null'

            break;

        case TYP_CHAR  : lv1 = (  signed char )lv1; break;
        case TYP_UCHAR : lv1 = (unsigned char )lv1; break;
        case TYP_SHORT : lv1 = (  signed short)lv1; break;
        case TYP_USHORT:
        case TYP_WCHAR : lv1 = (unsigned short)lv1; break;

        case TYP_LONG  :
        case TYP_ULONG : break;

        case TYP_INT:
        case TYP_UINT:

            /* Bash the node operator (in addition to the type) */

            op1->tnOper             = TN_CNS_INT;
            op1->tnIntCon.tnIconVal = (__int32)lv1;
            goto BASH_TYPE;

        case TYP_FLOAT:

            /* Bash the node operator (in addition to the type) */

            uns = varTypeIsUnsigned(cmpActualVtyp(op1->tnType));

            op1->tnOper             = TN_CNS_FLT;
            op1->tnFltCon.tnFconVal = (float  )(uns ? toDouble(lv1)
                                                    :          lv1);
            goto BASH_TYPE;

        case TYP_DOUBLE:

            /* Bash the node operator (in addition to the type) */

            uns = varTypeIsUnsigned(cmpActualVtyp(op1->tnType));

            op1->tnOper             = TN_CNS_DBL;
            op1->tnDblCon.tnDconVal = uns ? toDouble(lv1)
                                          :  (double)lv1;
            goto BASH_TYPE;

        default:

            // UNDONE: need to handle more cases

#ifdef DEBUG
            cmpParser->parseDispTree(expr);
#endif
            NO_WAY(!"unhandled cast type");
            return expr;
        }

        op1->tnLngCon.tnLconVal = lv1;

        /* Bash the type of the operand and return it */

    BASH_TYPE:

        op1->tnVtyp = expr->tnVtyp;
        op1->tnType = expr->tnType;

        return op1;

    case TN_NEG:
        lv1 = -lv1;
        break;

    case TN_NOT:
        lv1 = ~lv1;
        break;

    case TN_LOG_NOT:
        lv1 = !lv1;
        break;

    case TN_NOP:
        break;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

    assert(expr->tnVtyp == TYP_LONG  ||
           expr->tnVtyp == TYP_ULONG ||
           expr->tnVtyp == TYP_ENUM);

    expr->tnOper             = TN_CNS_LNG;
    expr->tnLngCon.tnLconVal = lv1;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a binary operator with __int64 constant operands.
 */

Tree                compiler::cmpFoldLngBinop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    bool            rel;

    bool            uns = varTypeIsUnsigned(expr->tnVtypGet());

    assert(op1->tnOper == TN_CNS_LNG && (op1->tnVtyp == TYP_LONG || op1->tnVtyp == TYP_ULONG || op1->tnVtyp == TYP_ENUM));

    __int64         lv1 = op1->tnLngCon.tnLconVal;
    __int64         lv2;

    if  (op2->tnOper == TN_CNS_INT)
    {
        __int32         iv2 = op2->tnIntCon.tnIconVal;

        /* This must be a shift */

        switch (expr->tnOper)
        {
            // ISSUE: Need to check for signed/unsigned shift count, right ?

        case TN_LSH:
            lv1 <<= iv2;
            goto DONE;

        case TN_RSH:
            if (uns)
                lv1   = (unsigned)lv1 >> iv2;
            else
                lv1 >>= iv2;
            goto DONE;

        case TN_RSZ:
            lv1   = (unsigned)lv1 >> iv2;
            goto DONE;
        }
    }

    assert(op2->tnOper == TN_CNS_LNG && (op2->tnVtyp == TYP_LONG || op2->tnVtyp == TYP_ULONG || op2->tnVtyp == TYP_ENUM));

    lv2 = op2->tnLngCon.tnLconVal;

    switch (expr->tnOper)
    {
    case TN_ADD: lv1  += lv2; break;
    case TN_SUB: lv1  -= lv2; break;
    case TN_MUL: lv1  *= lv2; break;

    case TN_DIV: if (lv2 == 0) goto LNG_DIV_ZERO;
                 if (uns)
                     lv1  = (unsigned)lv1 / (unsigned)lv2;
                 else
                     lv1 /= lv2;
                 break;

    case TN_MOD: if (lv2 == 0) goto LNG_DIV_ZERO;
                 if (uns)
                     lv1  = (unsigned)lv1 % (unsigned)lv2;
                 else
                     lv1 %= lv2;
                 break;

    case TN_OR : lv1  |= lv2; break;
    case TN_XOR: lv1  ^= lv2; break;
    case TN_AND: lv1  &= lv2; break;

    case TN_EQ : rel = (lv1 == lv2); goto RELOP;
    case TN_NE : rel = (lv1 != lv2); goto RELOP;

    case TN_LT : if (uns)
                     rel = ((unsigned)lv1 <  (unsigned)lv2);
                 else
                     rel = (lv1 <  lv2);
                 goto RELOP;
    case TN_LE : if (uns)
                     rel = ((unsigned)lv1 <= (unsigned)lv2);
                 else
                     rel = (lv1 <  lv2);
                 goto RELOP;
    case TN_GE : if (uns)
                     rel = ((unsigned)lv1 >= (unsigned)lv2);
                 else
                     rel = (lv1 <  lv2);
                 goto RELOP;
    case TN_GT : if (uns)
                     rel = ((unsigned)lv1 >  (unsigned)lv2);
                 else
                     rel = (lv1 <  lv2);
                 goto RELOP;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

DONE:

    assert(expr->tnVtyp == TYP_LONG  ||
           expr->tnVtyp == TYP_ULONG ||
           expr->tnVtyp == TYP_ENUM);

    expr->tnOper             = TN_CNS_LNG;
    expr->tnLngCon.tnLconVal = lv1;

    return expr;

RELOP:

    assert(expr->tnVtyp <= TYP_INT);

    expr->tnOper             = TN_CNS_INT;
    expr->tnIntCon.tnIconVal = rel;

    return expr;

LNG_DIV_ZERO:

    cmpError(ERRdivZero);

    expr->tnOper             = TN_ERROR;
    expr->tnLngCon.tnLconVal = 0;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a unary operator with a float constant operand.
 */

Tree                compiler::cmpFoldFltUnop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;

    assert(op1->tnOper == TN_CNS_FLT && op1->tnVtyp == TYP_FLOAT);

    float           fv1 = op1->tnFltCon.tnFconVal;

    if  (_isnan(fv1))
        return  expr;

    switch (expr->tnOper)
    {
    case TN_NEG:
        fv1 = -fv1;
        break;

    case TN_NOP:
        break;

    case TN_CAST:

        switch (expr->tnVtyp)
        {
            __int32         i;
            __int64         l;

        case TYP_CHAR:   i = (  signed char   )fv1; goto FLT2INT;
        case TYP_UCHAR:  i = (unsigned char   )fv1; goto FLT2INT;
        case TYP_SHORT:  i = (  signed short  )fv1; goto FLT2INT;
        case TYP_USHORT: i = (unsigned short  )fv1; goto FLT2INT;
        case TYP_WCHAR:  i = (int)      (wchar)fv1; goto FLT2INT;
        case TYP_INT:    i = (  signed int    )fv1; goto FLT2INT;
        case TYP_UINT:   i = (unsigned int    )fv1; goto FLT2INT;

        FLT2INT:

            expr->tnOper             = TN_CNS_INT;
            expr->tnIntCon.tnIconVal = i;
            break;

        case TYP_LONG:   l = (  signed __int64)fv1; goto FLT2LNG;
        case TYP_ULONG:  l = (unsigned __int64)fv1; goto FLT2LNG;

        FLT2LNG:

            expr->tnOper             = TN_CNS_LNG;
            expr->tnLngCon.tnLconVal = l;
            break;

        case TYP_DOUBLE:

            expr->tnOper             = TN_CNS_DBL;
            expr->tnDblCon.tnDconVal = (double)fv1;
            return expr;

        default:
            NO_WAY(!"unexpect type of cast");
        }

        return  expr;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

    assert(expr->tnVtyp == TYP_FLOAT);

    expr->tnOper             = TN_CNS_FLT;
    expr->tnFltCon.tnFconVal = fv1;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a binary operator with float constant operands.
 */

Tree                compiler::cmpFoldFltBinop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    assert(op1->tnOper == TN_CNS_FLT && op1->tnVtyp == TYP_FLOAT);
    assert(op2->tnOper == TN_CNS_FLT && op2->tnVtyp == TYP_FLOAT);

    float           fv1 = op1->tnFltCon.tnFconVal;
    float           fv2 = op2->tnFltCon.tnFconVal;

    __int32         rel;

    if  (_isnan(fv1) || _isnan(fv2))
    {
        if  (expr->tnOperKind() & TNK_RELOP)
        {
            rel = (expr->tnOper == TN_NE);
            goto RELOP;
        }
        else
        {
            goto DONE;
        }
    }


    switch (expr->tnOper)
    {
    case TN_ADD: fv1 += fv2; break;
    case TN_SUB: fv1 -= fv2; break;
    case TN_MUL: fv1 *= fv2; break;
    case TN_DIV: fv1 /= fv2; break;

    case TN_MOD: return expr;

    case TN_EQ : rel = (fv1 == fv2); goto RELOP;
    case TN_NE : rel = (fv1 != fv2); goto RELOP;
    case TN_LT : rel = (fv1 <  fv2); goto RELOP;
    case TN_LE : rel = (fv1 <= fv2); goto RELOP;
    case TN_GE : rel = (fv1 >= fv2); goto RELOP;
    case TN_GT : rel = (fv1 >  fv2); goto RELOP;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

DONE:

    assert(expr->tnVtyp == TYP_FLOAT);

    expr->tnOper             = TN_CNS_FLT;
    expr->tnFltCon.tnFconVal = fv1;

    return expr;

RELOP:

    assert(expr->tnVtyp <= TYP_INT);

    expr->tnOper             = TN_CNS_INT;
    expr->tnIntCon.tnIconVal = rel;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a unary operator with a double constant operand.
 */

Tree                compiler::cmpFoldDblUnop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;

    assert(op1->tnOper == TN_CNS_DBL && op1->tnVtyp == TYP_DOUBLE);

    double          dv1 = op1->tnDblCon.tnDconVal;

    if  (_isnan(dv1))
        return  expr;

    switch (expr->tnOper)
    {
    case TN_NEG:
        dv1 = -dv1;
        break;

    case TN_NOP:
        break;

    case TN_CAST:

        switch (expr->tnVtyp)
        {
            __int32         i;
            __int64         l;

        case TYP_CHAR:   i = (  signed char   )dv1; goto DBL2INT;
        case TYP_UCHAR:  i = (unsigned char   )dv1; goto DBL2INT;
        case TYP_SHORT:  i = (  signed short  )dv1; goto DBL2INT;
        case TYP_USHORT: i = (unsigned short  )dv1; goto DBL2INT;
        case TYP_WCHAR:  i = (int)      (wchar)dv1; goto DBL2INT;
        case TYP_INT:    i = (  signed int    )dv1; goto DBL2INT;
        case TYP_UINT:   i = (unsigned int    )dv1; goto DBL2INT;

        DBL2INT:

            expr->tnOper             = TN_CNS_INT;
            expr->tnIntCon.tnIconVal = i;
            break;

        case TYP_LONG:   l = (  signed __int64)dv1; goto DBL2LNG;
#ifdef  __SMC__
        case TYP_ULONG:  l = (  signed __int64)dv1; goto DBL2LNG;
#else
        case TYP_ULONG:  l = (unsigned __int64)dv1; goto DBL2LNG;
#endif

        DBL2LNG:

            expr->tnOper             = TN_CNS_LNG;
            expr->tnLngCon.tnLconVal = l;
            break;

        case TYP_FLOAT:

            expr->tnOper             = TN_CNS_FLT;
            expr->tnFltCon.tnFconVal = (float)dv1;
            break;

        default:
            NO_WAY(!"unexpect type of cast");
        }

        return expr;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

    assert(expr->tnVtyp == TYP_DOUBLE);

    expr->tnOper             = TN_CNS_DBL;
    expr->tnDblCon.tnDconVal = dv1;

    return expr;
}

/*****************************************************************************
 *
 *  Try to fold a binary operator with double constant operands.
 */

Tree                compiler::cmpFoldDblBinop(Tree expr)
{
    Tree            op1 = expr->tnOp.tnOp1;
    Tree            op2 = expr->tnOp.tnOp2;

    assert(op1->tnOper == TN_CNS_DBL && op1->tnVtyp == TYP_DOUBLE);
    assert(op2->tnOper == TN_CNS_DBL && op2->tnVtyp == TYP_DOUBLE);

    double          dv1 = op1->tnDblCon.tnDconVal;
    double          dv2 = op2->tnDblCon.tnDconVal;

    __int32         rel;

    if  (_isnan(dv1) || _isnan(dv2))
    {
        if  (expr->tnOperKind() & TNK_RELOP)
        {
            rel = (expr->tnOper == TN_NE);
            goto RELOP;
        }
        else
        {
            goto DONE;
        }
    }

    switch (expr->tnOper)
    {
    case TN_ADD: dv1 += dv2; break;
    case TN_SUB: dv1 -= dv2; break;
    case TN_MUL: dv1 *= dv2; break;
    case TN_DIV: dv1 /= dv2; break;

    case TN_MOD: return expr;

    case TN_EQ : rel = (dv1 == dv2); goto RELOP;
    case TN_NE : rel = (dv1 != dv2); goto RELOP;
    case TN_LT : rel = (dv1 <  dv2); goto RELOP;
    case TN_LE : rel = (dv1 <= dv2); goto RELOP;
    case TN_GE : rel = (dv1 >= dv2); goto RELOP;
    case TN_GT : rel = (dv1 >  dv2); goto RELOP;

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        NO_WAY(!"unexpected operator");
    }

DONE:

    assert(expr->tnVtyp == TYP_DOUBLE);

    expr->tnOper             = TN_CNS_DBL;
    expr->tnDblCon.tnDconVal = dv1;

    return expr;

RELOP:

    assert(expr->tnVtyp <= TYP_INT);

    expr->tnOper             = TN_CNS_INT;
    expr->tnIntCon.tnIconVal = rel;

    return expr;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\genil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _GENIL_H_
#define _GENIL_H_
/*****************************************************************************/
#ifndef __PREPROCESS__
/*****************************************************************************/
#include "opcodes.h"
/*****************************************************************************/

#ifdef  DEBUG
#define DISP_IL_CODE    1
#endif

#if     DISP_IL_CODE
const   unsigned    IL_OPCDSP_LEN = 20;
#endif

/*****************************************************************************
 *
 *  The following structure keeps tracks of all the exception handlers defined
 *  in the current function.
 */

DEFMGMT
class   handlerDsc
{
public:
    Handler         EHnext;

    ILblock         EHtryBegPC;
    ILblock         EHtryEndPC;

    ILblock         EHhndBegPC;
    ILblock         EHhndEndPC;

    ILblock         EHfilterPC;

    mdToken         EHhndType;

    bool            EHisFinally;
};

/*****************************************************************************
 *
 *  The 'ILblock' structure and related logic is used to generate MSIL into
 *  snippets connected via jumps, in order to allow things such as jump
 *  optimizations to be done easily. Basically, the 'ILblock' structure
 *  describes a single basic block (i.e. a clump of IL).
 */

DEFMGMT class ILfixupDsc
{
public:

    ILfixup             ILfixNext;

    unsigned            ILfixOffs   :28;
    WPEstdSects         ILfixSect   :4;
};

DEFMGMT class ILswitchDsc
{
public:

    unsigned            ILswtSpan;
    unsigned            ILswtCount;
    vectorTree          ILswtTable;
    ILblock             ILswtBreak;
};

DEFMGMT class ILblockDsc
{
public:

    ILblock             ILblkNext;
    ILblock             ILblkPrev;

    ILfixup             ILblkFixups;

#ifndef NDEBUG
    ILblock             ILblkSelf;      // for consistency checks
#endif

    unsigned            ILblkOffs;
#if DISP_IL_CODE
    unsigned            ILblkNum;
#endif

    unsigned            ILblkJumpSize:16;// jump size (estimate)
    unsigned            ILblkJumpCode:12;// CEE_NOP / CEE_BLE / etc.
    unsigned            ILblkFlags   :4; // see ILBF_xxxx below

    UNION(ILblkJumpCode)
    {
    CASE(CEE_SWITCH)
        ILswitch            ILblkSwitch;    // switch statement info

    DEFCASE
        ILblock             ILblkJumpDest;  // jump target block or 0
    };

    genericBuff         ILblkCodeAddr;  // addr of MSIL for this block
    unsigned            ILblkCodeSize;  // size of MSIL for this block
};

const   unsigned    ILBF_REACHABLE  = 0x01;

#ifdef  DEBUG
const   unsigned    ILBF_USED       = 0x02; // for forward-referenced labels
const   unsigned    ILBF_LABDEF     = 0x04; // label def has been displayed
#endif

inline
size_t              genILblockOffsBeg(ILblock block)
{
    assert(block);

    return  block->ILblkOffs;
}

inline
size_t              genILblockOffsEnd(ILblock block)
{
    assert(block);
    assert(block->ILblkNext);

    return  block->ILblkNext->ILblkOffs;
}

/*****************************************************************************
 *
 *  The following holds additional information about a switch statement,
 *  and is pointed to by the corresponding TN_SWITCH node (which in turn
 *  is referenced by the 'cbJumpDest' field of ILblock).
 */

struct swtGenDsc
{
    ILblock             sgdLabBreak;    // break   label
    ILblock             sgdLabDefault;  // default label

    unsigned short      sgdCodeSize;    // opcode size

    unsigned            sgdMinVal;      // min. case value
    unsigned            sgdMaxVal;      // max. case value
    unsigned            sgdCount;       // count of cases
};

/*****************************************************************************
 *
 *  The following is used to keep track of allocated temporaries.
 */

DEFMGMT
class   ILtempDsc
{
public:
    ILtemp          tmpNext;            // next of same type
    ILtemp          tmpNxtN;            // next in order of slot index
#ifdef  DEBUG
    genericRef      tmpSelf;            // to detect bogus values
#endif
    TypDef          tmpType;            // type the temp can hold
    unsigned        tmpNum;             // the slot number
};

/*****************************************************************************
 *
 *  The following is used to maintain the string pool.
 */

const   size_t      STR_POOL_BLOB_SIZE = OS_page_size;

DEFMGMT
class   strEntryDsc
{
public:
    StrEntry        seNext;             // next in list
    size_t          seSize;             // total allocated data size
    size_t          seFree;             // available data size
    size_t          seOffs;             // relative base offset of this blob
    genericBuff     seData;             // the data of this blob
};

/*****************************************************************************/

typedef
unsigned            genStkMarkTP;       // used to mark/restore stack level

/*****************************************************************************
 *
 *  The following is used to describe each opcode; see ILopcodeCodes[] and
 *  ILopcodeStack[] for details.
 */

struct  ILencoding
{
    unsigned        ILopc1  :8;
    unsigned        ILopc2  :8;
    unsigned        ILopcL  :2;
};

/*****************************************************************************
 *
 *  The following structure describes each recorded line#.
 */

DEFMGMT
class   lineInfoRec
{
public:

    LineInfo        lndNext;

    unsigned        lndLineNum;

    ILblock         lndBlkAddr;
    size_t          lndBlkOffs;
};

/*****************************************************************************
 *
 *  The following is used for multi-dimensional rectangular array initializers.
 */

struct  mulArrDsc
{
    mulArrDsc   *   madOuter;
    unsigned        madIndex;
    unsigned        madCount;
};

/*****************************************************************************/

struct  genCloneDsc;    // for now this type fully declared in genIL.cpp

/*****************************************************************************/

// The name is just too long, declare a short-cut:

#if MGDDATA
typedef       IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT            EH_CLAUSE;
typedef       IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT managed [] EH_CLAUSE_TAB;
typedef       IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT managed [] EH_CLAUSE_TBC;
#else
typedef       IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT            EH_CLAUSE;
typedef       IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT         *  EH_CLAUSE_TAB;
typedef const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT         *  EH_CLAUSE_TBC;
#endif

/*****************************************************************************/

DEFMGMT
class   genIL
{
private:

    Compiler        genComp;
    SymTab          genStab;
    norls_allocator*genAlloc;
    Parser          genParser;
    WritePE         genPEwriter;

    /************************************************************************/
    /*  Keeps track of the local variable and argument count                */
    /************************************************************************/

private:
    unsigned        genLclCount;
    unsigned        genArgCount;
    unsigned        genTmpCount;
    unsigned        genTmpBase;

    unsigned        genGetLclIndex(SymDef varSym);

public:

    unsigned        genNextLclNum()
    {
        return  genLclCount++;
    }

    unsigned        genNextArgNum()
    {
        return  genArgCount++;
    }

    unsigned        genGetLclCnt()
    {
        return  genLclCount + genTmpCount;
    }

    /************************************************************************/
    /*  The current fucntion scope and symbol                               */
    /************************************************************************/

    SymDef          genFncScope;
    SymDef          genFncSym;

    /************************************************************************/
    /*  This holds the current and maximum virtual execution stack level.   */
    /************************************************************************/

public:

    unsigned        genCurStkLvl;
    unsigned        genMaxStkLvl;

private:

    void            markStkLvl(INOUT genStkMarkTP REF stkMark)
    {
        stkMark = genCurStkLvl;
    }

    void            restStkLvl(INOUT genStkMarkTP REF stkMark)
    {
        genCurStkLvl = stkMark;
    }

    void            genMarkStkMax()
    {
        if  (genMaxStkLvl < genCurStkLvl)
             genMaxStkLvl = genCurStkLvl;
    }

    void            genUpdateStkLvl(unsigned op);

    /************************************************************************/
    /*  These are used for bufferring of opcodes to form sections           */
    /************************************************************************/

    BYTE    *       genBuffAddr;
    BYTE    *       genBuffNext;
    BYTE    *       genBuffLast;

    void            genBuffInit();
    void            genBuffFlush();

    ILblock         genAllocBlk();

    genericRef      genBegBlock(ILblock block = NULL);
    ILblock         genEndBlock(unsigned jumpCode, ILblock jumpDest = NULL);

    BYTE    *       genJmp32(BYTE *dst, ILblock dest, unsigned offs);

public:

    void            genSwitch(var_types     caseTyp,
                              unsigned      caseSpn,
                              unsigned      caseCnt,
                              __uint64      caseMin,
                              vectorTree    caseTab,
                              ILblock       caseBrk);

    void            genSwtCmpJmp(int cval, ILblock lab)
    {
        genIntConst(cval);
        genOpcode_lab(CEE_BEQ, lab);
    }

private:

    bool            genCurBlkNonEmpty();
    size_t          genCurOffset();

public:

    ILblock         genBuffCurAddr();
    size_t          genBuffCurOffs();

    unsigned        genCodeAddr(genericRef block, size_t offset);

    /************************************************************************/
    /*  Low-level routines that generate individual MSIL opcodes              */
    /************************************************************************/

    void            genILdata_I1(int         v);
    void            genILdata_I2(int         v);
    void            genILdata_I4(int         v);
    void            genILdata_I8(__int64     v);
    void            genILdata_R4(float       v);
    void            genILdata_R8(double      v);
    void            genILdataStr(unsigned    o);
    void            genILdataRVA(unsigned    o, WPEstdSects s);
//  void            genILdata   (const void *data, size_t size);

    void            genILdataFix(WPEstdSects s);

    void            genOpcodeOper(unsigned op);
    unsigned        genOpcodeEnc (unsigned op);
    size_t          genOpcodeSiz (unsigned op);

    void            genOpcode    (unsigned op);
    void            genOpcodeNN  (unsigned op);
    void            genOpcode_I1 (unsigned op, int         v);
    void            genOpcode_U1 (unsigned op, unsigned    v);
    void            genOpcode_U2 (unsigned op, unsigned    v);
    void            genOpcode_I4 (unsigned op, int         v);
    void            genOpcode_I8 (unsigned op, __int64     v);
    void            genOpcode_R4 (unsigned op, float       v);
    void            genOpcode_R8 (unsigned op, double      v);
    void            genOpcode_lab(unsigned op, ILblock     l);
    void            genOpcode_tok(unsigned op, mdToken     t);
    void            genOpcode_str(unsigned op, unsigned    offs);
    void            genOpcode_RVA(unsigned op, WPEstdSects sect,
                                               unsigned    offs);

#if DISP_IL_CODE

    char    *       genDispILnext;
    char            genDispILbuff[IL_OPCDSP_LEN+64];
    unsigned        genDispILinsLst;

    void            genDispILins_I1(int     v);
    void            genDispILins_I2(int     v);
    void            genDispILins_I4(int     v);
    void            genDispILins_I8(__int64 v);
    void            genDispILins_R4(float   v);
    void            genDispILins_R8(double  v);

    void            genDispILopc   (const char *name, const char *suff = NULL);
    void            genDispILinsBeg(unsigned op);
    void    __cdecl genDispILinsEnd(const char *fmt, ...);

#endif

public:
    mdToken         genMethodRef (SymDef fncSym, bool   virtRef);   // called from comp
private:
    mdToken         genVarargRef (SymDef fncSym, Tree      call);
    mdToken         genInfFncRef (TypDef fncTyp, TypDef thisArg);
    mdToken         genMemberRef (SymDef fldSym);
    mdToken         genTypeRef   (TypDef type);
    mdToken         genValTypeRef(TypDef type);

public:

    void            genJump(ILblock dest)
    {
        genOpcode_lab(CEE_BR, dest);
    }

    void            genJcnd(ILblock dest, unsigned opcode)
    {
        genOpcode_lab(opcode, dest);
    }

    void            genLeave(ILblock dest)
    {
        genOpcode_lab(CEE_LEAVE, dest);
    }

    void            genAssertFail(Tree expr)
    {
        genExpr(expr, false);
//      genOpcode(CEE_BREAK);   // ISSUE: when should we generate a break?
    }

#ifdef  SETS

    void            genRetTOS()
    {
        assert(genCurStkLvl <= 1 || genComp->cmpErrorCount != 0);
        genOpcode(CEE_RET);
        genCurStkLvl = 0;
    }

    void            genStoreMember(SymDef dest, Tree expr)
    {
        genOpcode(CEE_DUP);
        genExpr(expr, true);
        genOpcode_tok(CEE_STFLD, genMemberRef(dest));
    }

#endif

    /************************************************************************/
    /*  Keep track of line# info (for debugging)                            */
    /************************************************************************/

private:

    bool            genLineNums;
    bool            genLineNumsBig;
    bool            genLineOffsBig;

    LineInfo        genLineNumList;
    LineInfo        genLineNumLast;

    unsigned        genLineNumLastLine;
    ILblock         genLineNumLastBlk;
    size_t          genLineNumLastOfs;

    void            genLineNumInit();
    void            genLineNumDone();

    void            genRecExprAdr(Tree expr);

public:
    void            genRecExprPos(Tree expr)
    {
        if  (genLineNums)
            genRecExprAdr(expr);
    }

    size_t          genLineNumOutput(unsigned *offsTab, unsigned *lineTab);

    /************************************************************************/
    /*  Generate code for a block, statement, expression, etc.              */
    /************************************************************************/

private:

    void            genCloneAddrBeg(genCloneDsc *clone, Tree     addr,
                                                        unsigned offs = 0);
    void            genCloneAddrUse(genCloneDsc *clone);
    void            genCloneAddrEnd(genCloneDsc *clone);

    void            genGlobalAddr(Tree expr);

    void            genAddr(Tree addr, unsigned offs = 0);

    bool            genGenAddressOf(Tree addr, bool oneUse, unsigned *tnumPtr = NULL,
                                                            TypDef   *ttypPtr = NULL);
    bool            genCanTakeAddr(Tree expr);

    var_types       genExprVtyp(Tree expr);

    void            genRelTest(Tree cond, Tree op1,
                                          Tree op2, int     sense,
                                                    ILblock labTrue);

    unsigned        genArrBounds(TypDef type, OUT TypDef REF elemRef);

    void            genMulDimArrInit(Tree       expr,
                                     TypDef     type,
                                     DimDef     dims,
                                     unsigned   temp,
                                     mulArrDsc *next,
                                     mulArrDsc *outer);
    void            genArrayInit    (Tree       expr);

    void            genFncAddr(Tree expr);
    void            genNewExpr(Tree expr, bool valUsed, Tree dstx = NULL);
    void            genAsgOper(Tree expr, bool valUsed);
    unsigned        genConvOpcode(var_types dst, var_types src);
    ILopcodes       genBinopOpcode(treeOps oper, var_types type);

    void            genCTSindexAsgOp(Tree expr, int delta, bool post, bool asgop, bool valUsed);
    void            genIncDecByExpr(int delta, TypDef type);
    void            genIncDec(Tree expr, int delta, bool post, bool valUsed);
    void            genLclVarAdr(unsigned slot);
    void            genLclVarAdr(SymDef varSym);
    void            genLclVarRef(SymDef varSym, bool store);
    void            genArgVarRef(unsigned slot, bool store);
    void            genStringLit(TypDef type, const char *str, size_t len, int wide = 0);

public:

    void            genAnyConst(__int64 val, var_types vtp);
    void            genLngConst(__int64 val);
    void            genIntConst(__int32 val);

    void            genInstStub();

    void            genLclVarRef(unsigned  index, bool store);

    ILblock         genTestCond(Tree cond, bool sense);

    void            genExprTest(Tree            expr,
                                int             sense,
                                int             genJump, ILblock labTrue,
                                                         ILblock labFalse);

    /*----------------------------------------------------------------------*/

    void            genBitFieldLd(Tree      expr, bool didAddr, bool valUsed);
    void            genBitFieldSt(Tree      dstx, Tree newx,
                                                  Tree asgx,
                                                  int  delta,
                                                  bool post,    bool valUsed);

    /*----------------------------------------------------------------------*/

    void            genStmtRet   (Tree      retv);
    void            genSideEff   (Tree      expr);
    void            genCast      (Tree      expr, TypDef type, unsigned flags);
    void            genCall      (Tree      expr, bool valUsed);
    void            genRef       (Tree      expr, bool store);
    unsigned        genAdr       (Tree      expr, bool compute = false);
    void            genExpr      (Tree      stmt, bool valUsed);

    /************************************************************************/
    /*  The following are used to process labels and jumps                  */
    /************************************************************************/

#if DISP_IL_CODE
    const   char *  genDspLabel(ILblock lab);
    void            genDspLabDf(ILblock lab);
#endif

    ILblock         genBwdLab();
    ILblock         genFwdLabGet();
    void            genFwdLabDef(ILblock block);

    size_t          genJumpMaxSize(unsigned opcode);
    unsigned        genShortenJump(unsigned opcode, size_t *newSize);

    /************************************************************************/
    /*  The following keeps track of temporary labels                       */
    /************************************************************************/

#if DISP_IL_CODE
    const   char *  genTempLabName();
    unsigned        genTempLabCnt;
#endif

    void            genTempLabInit()
    {
#if DISP_IL_CODE
        genTempLabCnt = 0;
#endif
    }

    /************************************************************************/
    /*  The following keeps track of temporary variables                    */
    /************************************************************************/

    unsigned        genTempVarCnt [TYP_COUNT];
    ILtemp          genTempVarUsed[TYP_COUNT];
    ILtemp          genTempVarFree[TYP_COUNT];

    ILtemp          genTempList;
    ILtemp          genTempLast;

    void            genTempVarInit();   // called at startup
    void            genTempVarDone();   // called at shutdown

    void            genTempVarBeg(unsigned lclCnt);
    void            genTempVarEnd();

#ifdef  DEBUG
    void            genTempVarChk();    // checks that all temps have been freed
#else
    void            genTempVarChk(){}
#endif

public:

    unsigned        genTempVarGet(TypDef type);
    void            genTempVarRls(TypDef type, unsigned tnum);

    void            genTempVarNew(SymDef tsym)
    {
        tsym->sdVar.sdvILindex = genTempVarGet(tsym->sdType);
    }

    void            genTempVarEnd(SymDef tsym)
    {
        genTempVarRls(tsym->sdType, tsym->sdVar.sdvILindex);
    }

    genericRef      genTempIterBeg()
    {
        return  genTempList;
    }

    genericRef      genTempIterNxt(genericRef iter, OUT TypDef REF typRef);

    /************************************************************************/
    /*  The following handles exception handlers                            */
    /************************************************************************/

private:

    Handler         genEHlist;
    Handler         genEHlast;
    unsigned        genEHcount;

public:

    void            genEHtableInit();
    size_t          genEHtableCnt()
    {
        return  genEHcount;
    }

    void            genEHtableWrt(EH_CLAUSE_TAB tbl);

    void            genEHtableAdd(ILblock tryBegPC,
                                  ILblock tryEndPC,
                                  ILblock filterPC,
                                  ILblock hndBegPC,
                                  ILblock hndEndPC,
                                  TypDef  catchTyp, bool isFinally = false);

    void            genCatchBeg(SymDef argSym);
    void            genCatchEnd(bool reachable){}

    void            genExcptBeg(SymDef tsym);
    void            genFiltExpr(Tree expr, SymDef esym)
    {
        genCurStkLvl++;
        genLclVarRef(esym->sdVar.sdvILindex, true);
        genExpr(expr, true);
        genOpcode(CEE_ENDFILTER);
    }

    void            genEndFinally()
    {
        genOpcode(CEE_ENDFINALLY);
    }

    /************************************************************************/
    /*  The following are used for collection operator codegen              */
    /************************************************************************/

#ifdef  SETS

    void            genNull()
    {
        genOpcode(CEE_LDNULL);
    }

    void            genCallNew(SymDef fncSym, unsigned argCnt, bool notUsed = false)
    {
        assert(fncSym);
        assert(fncSym->sdSymKind == SYM_FNC);
        assert(fncSym->sdFnc.sdfCtor);

        genOpcode_tok(CEE_NEWOBJ, genMethodRef(fncSym, false));
        genCurStkLvl -= argCnt;

        if  (notUsed)
            genOpcode(CEE_POP);
    }

    void            genCallFnc(SymDef fncSym, unsigned argCnt)
    {
        assert(fncSym);
        assert(fncSym->sdSymKind == SYM_FNC);

        genOpcode_tok(CEE_CALL  , genMethodRef(fncSym, false));
        genCurStkLvl -= argCnt;
    }

    void            genFNCaddr(SymDef fncSym)
    {
        assert(fncSym);
        assert(fncSym->sdSymKind == SYM_FNC);
        assert(fncSym->sdIsStatic);

        genOpcode_tok(CEE_LDFTN, genMethodRef(fncSym, false));
    }

    void            genVarAddr(SymDef varSym)
    {
        genLclVarAdr(varSym);
    }

    void            genConnect(Tree op1, Tree expr1, SymDef addf1,
                               Tree op2, Tree expr2, SymDef addf2);

    void            genSortCmp(Tree val1, Tree val2, bool last);

#endif

    /************************************************************************/
    /*  These are used to create and manage code sections                   */
    /************************************************************************/

    void            genSectionBeg();
    size_t          genSectionEnd();

    BYTE    *       genSectionCopy(BYTE *dst, unsigned baseRVA);

    /************************************************************************/
    /* We keep the code blocks on a doubly-linked list and assign them      */
    /* numbers order of creation (and later in order of visiting).          */
    /************************************************************************/

    ILblock         genILblockList;
    ILblock         genILblockLast;
    ILblock         genILblockCur;
    unsigned        genILblockLabNum;

    size_t          genILblockOffs;

    /************************************************************************/
    /*  Debugging members                                                   */
    /************************************************************************/

#if DISP_IL_CODE
    bool            genDispCode;
#endif

    /************************************************************************/
    /*  The following implements the string pool                            */
    /************************************************************************/

    unsigned        genStrPoolOffs;

    StrEntry        genStrPoolList;
    StrEntry        genStrPoolLast;

public:

    void            genStrPoolInit();
    unsigned        genStrPoolAdd (const void *str, size_t len, int wide = 0);
    unsigned        genStrPoolSize();
    void            genStrPoolWrt (memBuffPtr dest);

    /************************************************************************/
    /*  Main entry points to initialize/shutdown and generate code          */
    /************************************************************************/

public:

    bool            genInit    (Compiler        comp,
                                WritePE         writer,
                                norls_allocator*alloc);

    void            genDone    (bool            errors);

    void            genFuncBeg (SymTab          stab,
                                SymDef          fncSym,
                                unsigned        lclCnt);

    unsigned        genFuncEnd (mdSignature     sigTok,
                                bool            hadErrs);
};

/*****************************************************************************
 *
 *  Return a block that can be used to make forward jump references.
 */

inline
ILblock             genIL::genFwdLabGet()
{
    return  genAllocBlk();
}

/*****************************************************************************
 *
 *  Generate load/store of a local variable/argument.
 */

inline
void                genIL::genLclVarRef(unsigned index, bool store)
{
    if  (index <= 3)
    {
        assert(CEE_LDLOC_0 + 1 == CEE_LDLOC_1);
        assert(CEE_LDLOC_0 + 2 == CEE_LDLOC_2);
        assert(CEE_LDLOC_0 + 3 == CEE_LDLOC_3);

        assert(CEE_STLOC_0 + 1 == CEE_STLOC_1);
        assert(CEE_STLOC_0 + 2 == CEE_STLOC_2);
        assert(CEE_STLOC_0 + 3 == CEE_STLOC_3);

        genOpcode((store ? CEE_STLOC_0
                         : CEE_LDLOC_0) + index);
    }
    else
    {
        unsigned        opcode = store ? CEE_STLOC
                                       : CEE_LDLOC;

        assert(CEE_STLOC_S == CEE_STLOC + (CEE_LDLOC_S-CEE_LDLOC));
        if  (index < 256)
            genOpcode_U1(opcode + (CEE_LDLOC_S-CEE_LDLOC), index);
        else
            genOpcode_I4(opcode, index);
    }
}

inline
void                genIL::genArgVarRef(unsigned index, bool store)
{
    if  (index <= 3 && !store)
    {
        assert(CEE_LDARG_0 + 1 == CEE_LDARG_1);
        assert(CEE_LDARG_0 + 2 == CEE_LDARG_2);
        assert(CEE_LDARG_0 + 3 == CEE_LDARG_3);

        genOpcode(CEE_LDARG_0 + index);
    }
    else
    {
        unsigned        opcode = store ? CEE_STARG
                                       : CEE_LDARG;

        assert(CEE_STARG_S == CEE_STARG + (CEE_LDARG_S-CEE_LDARG));
        if  (index < 256)
            genOpcode_U1(opcode + (CEE_LDARG_S-CEE_LDARG), index);
        else
            genOpcode_I4(opcode, index);
    }
}

/*****************************************************************************/
#endif//__PREPROCESS__
/*****************************************************************************/
#endif//_GENIL_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\genil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "genIL.h"

#include <float.h>

/*****************************************************************************/
#ifndef __SMC__

extern
ILencoding          ILopcodeCodes[];
extern
signed  char        ILopcodeStack[];

#if     DISP_IL_CODE
extern
const   char *      opcodeNames[];
#endif

#endif//__SMC__
/*****************************************************************************
 *
 *  The max. size of each "blob" of MSIL opcodes is given by the following value.
 */

const
size_t              genBuffSize = 1000;

/*****************************************************************************
 *
 *  We need to patch the "ptr" flavors of loads/stores to
 *  use I8 instead of I4 in 64-bit mode.
 */

#ifndef __SMC__
extern
unsigned            opcodesIndLoad[];
extern
unsigned            opcodesIndStore[];
extern
unsigned            opcodesArrLoad[];
extern
unsigned            opcodesArrStore[];
#endif

/*****************************************************************************
 *
 *  Initialize the MSIL generator.
 */

bool                genIL::genInit(Compiler comp, WritePE writer, norls_allocator *alloc)
{
    genComp     = comp;
    genAlloc    = alloc;
    genPEwriter = writer;

    genBuffAddr = (BYTE *)comp->cmpAllocPerm.nraAlloc(genBuffSize);

    genTempLabInit();
    genTempVarInit();

    genStrPoolInit();

    if  (genComp->cmpConfig.ccTgt64bit)
    {
        assert(opcodesIndLoad [TYP_PTR] == CEE_LDIND_I4);
               opcodesIndLoad [TYP_PTR] =  CEE_LDIND_I8;
        assert(opcodesIndStore[TYP_PTR] == CEE_STIND_I4);
               opcodesIndStore[TYP_PTR] =  CEE_STIND_I8;
        assert(opcodesArrLoad [TYP_PTR] == CEE_LDELEM_I4);
               opcodesArrLoad [TYP_PTR] =  CEE_LDELEM_I8;
        assert(opcodesArrStore[TYP_PTR] == CEE_STELEM_I4);
               opcodesArrStore[TYP_PTR] =  CEE_STELEM_I8;
    }

    return  false;
}

/*****************************************************************************
 *
 *  Shutdown the MSIL generator.
 */

void                genIL::genDone(bool errors)
{
    /* If we had no errors, it's worth finishing the job */

    if  (!errors)
    {
        size_t          strSize;

        /* Allocate space for the string pool */

        strSize = genStrPoolSize();

        /* Did we have any strings? */

        if  (strSize)
        {
            memBuffPtr      strBuff;

            /* Allocate the space in the appropriate section of the PE file */

            genPEwriter->WPEallocString(strSize, sizeof(wchar), strBuff);

            /* Output the contents of the string pool */

            genStrPoolWrt(strBuff);
        }
    }

    genTempVarDone();
}

/*****************************************************************************
 *
 *  Return a methoddef/ref for the given function symbol.
 */

mdToken             genIL::genMethodRef(SymDef fncSym, bool isVirt)
{
    if  (fncSym->sdIsImport)
    {
        if  (!fncSym->sdFnc.sdfMDfnref)
        {
            assert(fncSym->sdReferenced == false);
                   fncSym->sdReferenced = true;

            genComp->cmpMakeMDimpFref(fncSym);
        }

         assert(fncSym->sdFnc.sdfMDfnref);
        return  fncSym->sdFnc.sdfMDfnref;
    }
    else
    {
        if  (!fncSym->sdFnc.sdfMDtoken)
        {
            assert(fncSym->sdReferenced == false);
                   fncSym->sdReferenced = true;

            genComp->cmpGenFncMetadata(fncSym);
        }

         assert(fncSym->sdFnc.sdfMDtoken);
        return  fncSym->sdFnc.sdfMDtoken;
    }
}

/*****************************************************************************
 *
 *  Return a methodref for the given function type (this is used to generate
 *  signatures for an indirect function calls).
 */

mdToken             genIL::genInfFncRef(TypDef fncTyp, TypDef thisArg)
{
    assert(fncTyp->tdTypeKind == TYP_FNC);

    if  (!fncTyp->tdFnc.tdfPtrSig)
    {
        genComp->cmpGenSigMetadata(fncTyp, thisArg);
        assert(fncTyp->tdFnc.tdfPtrSig);
    }

    return  fncTyp->tdFnc.tdfPtrSig;
}

/*****************************************************************************
 *
 *  Generate a signature for a varargs call that has extra arguments.
 */

mdToken             genIL::genVarargRef(SymDef fncSym, Tree call)
{
    TypDef          fncTyp = fncSym->sdType;
    unsigned        fixCnt;
    Tree            argExp;

    assert(call->tnOper == TN_FNC_SYM);
    assert(call->tnFlags & TNF_CALL_VARARG);

    /* Find the first "extra" argument */

    assert(fncTyp->tdTypeKind == TYP_FNC);

    argExp = call->tnFncSym.tnFncArgs; assert(argExp);
    fixCnt = fncTyp->tdFnc.tdfArgs.adCount;

    while (fixCnt)
    {
        assert(argExp && argExp->tnOper == TN_LIST);

        argExp = argExp->tnOp.tnOp2;
        fixCnt--;
    }

    /* force a methodref to be created */

    if  (!argExp)
    {
        argExp = call->tnFncSym.tnFncArgs->tnOp.tnOp1; assert(argExp->tnOper != TN_LIST);
    }

    assert(argExp);

    return  genComp->cmpGenFncMetadata(fncSym, argExp);
}

/*****************************************************************************
 *
 *  Return a memberdef/ref for the given static data member.
 */

mdToken             genIL::genMemberRef(SymDef fldSym)
{
    assert(fldSym->sdSymKind == SYM_VAR);

    if  (fldSym->sdIsImport)
    {
        if  (!fldSym->sdVar.sdvMDsdref)
        {
            genComp->cmpMakeMDimpDref(fldSym);
            assert(fldSym->sdVar.sdvMDsdref);
        }

        return  fldSym->sdVar.sdvMDsdref;
    }
    else
    {
        if  (fldSym->sdVar.sdvGenSym && !fldSym->sdIsStatic)
            fldSym = fldSym->sdVar.sdvGenSym;

        if  (!fldSym->sdVar.sdvMDtoken)
        {
            genComp->cmpGenFldMetadata(fldSym);
            assert(fldSym->sdVar.sdvMDtoken);
        }

        return  fldSym->sdVar.sdvMDtoken;
    }
}

/*****************************************************************************
 *
 *  Return a token for the specified type (for intrinsic types we return
 *  a reference to the corresponding value type, such as "Integer2").
 */

mdToken             genIL::genTypeRef(TypDef type)
{
    var_types       vtp = type->tdTypeKindGet();

    if  (vtp <= TYP_lastIntrins)
    {
        /* Locate the appropriate built-in value type */

        type = genComp->cmpFindStdValType(vtp);
        if  (!type)
            return  0;

        vtp = TYP_CLASS; assert(vtp == type->tdTypeKind);
    }

    switch (vtp)
    {
    case TYP_REF:
        type = type->tdRef.tdrBase;
    case TYP_ENUM:
    case TYP_CLASS:
        return  genComp->cmpClsEnumToken(type);

    case TYP_ARRAY:
        return  genComp->cmpArrayTpToken(type, true);

    case TYP_PTR:
        return  genComp->cmpPtrTypeToken(type);

    default:
#ifdef  DEBUG
        printf("Type '%s': ", genStab->stIntrinsicTypeName(vtp));
#endif
        UNIMPL(!"unexpected type");
        return 0;
    }
}

/*****************************************************************************
 *
 *  Return a token for the specified unmanaged class/struct/union type.
 */

inline
mdToken             genIL::genValTypeRef(TypDef type)
{
    return  genComp->cmpClsEnumToken(type);
}

/*****************************************************************************
 *
 *  Return the encoding for the given MSIL opcode.
 */

unsigned            genIL::genOpcodeEnc(unsigned op)
{
    const
    ILencoding  *   opc;

    assert(op <  CEE_count);
    assert(op != CEE_ILLEGAL);
    assert(op != CEE_UNREACHED);

    opc = ILopcodeCodes + op;

    switch (opc->ILopcL)
    {
    case 1:
        assert(opc->ILopc1 == 0xFF);
        return opc->ILopc2;

    case 2:
        UNIMPL(!"return 2-byte opcode");
        return  0;

    default:
        NO_WAY(!"unexpected encoding length");
        return  0;
    }
}

/*****************************************************************************
 *
 *  Return the size (in bytes) of the encoding for the given MSIL opcode.
 */

inline
size_t              genIL::genOpcodeSiz(unsigned op)
{
    assert(op <  CEE_count);
    assert(op != CEE_ILLEGAL);
    assert(op != CEE_UNREACHED);

    return  ILopcodeCodes[op].ILopcL;
}

/*****************************************************************************
 *
 *  The following returns the current MSIL block and offset within it.
 */

ILblock             genIL::genBuffCurAddr()
{
    return genILblockCur;
}

size_t              genIL::genBuffCurOffs()
{
    return genBuffNext - genBuffAddr;
}

/*****************************************************************************
 *
 *  Given an MSIL block and offset within in, return the actual MSIL offset
 *  within the function body.
 */

unsigned            genIL::genCodeAddr(genericRef block, size_t offset)
{
    assert(((ILblock)block)->ILblkSelf == block);
    return ((ILblock)block)->ILblkOffs + offset;
}

/*****************************************************************************
 *
 *  Initialize the emit buffer logic.
 */

void                genIL::genBuffInit()
{
    genBuffNext    = genBuffAddr;
    genBuffLast    = genBuffAddr + genBuffSize - 10;
}

/*****************************************************************************
 *
 *  Allocate and clear an MSIL block descriptor.
 */

ILblock             genIL::genAllocBlk()
{
    ILblock         block;

#if MGDDATA

    block = new ILblock;

#else

    block =    (ILblock)genAlloc->nraAlloc(sizeof(*block));

    // ISSUE: Using memset() is simple and safe, but pretty slow....

    memset(block, 0, sizeof(*block));

#endif

//  if  ((int)genFncSym == 0xCD1474 && (int)block == 0xCF016C) forceDebugBreak();

#ifndef NDEBUG
    block->ILblkSelf     = block;
#endif
#if DISP_IL_CODE
    block->ILblkNum      = ++genILblockLabNum;
#endif
    block->ILblkJumpCode = CEE_NOP;

    /* Make sure the jump opcode didn't get truncated */

    assert(block->ILblkJumpCode == CEE_NOP);

    return block;
}

/*****************************************************************************
 *
 *  Return non-zero if the current emit block is non-empty.
 */

inline
bool                genIL::genCurBlkNonEmpty()
{
    assert(genILblockCur);

    return  (bool)(genBuffNext != genBuffAddr);
}

/*****************************************************************************
 *
 *  Return the MSIL offset of the current instruction.
 */

inline
size_t              genIL::genCurOffset()
{
    return  genILblockOffs + (genBuffNext - genBuffAddr);
}

/*****************************************************************************
 *
 *  Start a new block of code; return a code block 'cookie' which the caller
 *  promises to store with the basic block this code clump corresponds to.
 */

genericRef          genIL::genBegBlock(ILblock block)
{
    assert(genILblockCur == NULL);

    /* Initialize the bufferring logic */

    genBuffInit();

    /* Allocate a new code block if the caller didn't supply one */

    if  (!block)
    {
        /* Is the previous block empty? */

        block = genILblockLast;

        if  (block->ILblkCodeSize == 0 &&
             block->ILblkJumpCode == CEE_NOP)
        {
            /* The previous block is empty - simply 'reopen' it */

            goto GOT_BLK;
        }

        block = genAllocBlk();
    }

//  if ((int)block == 0x03421ff0) forceDebugBreak();

    /* Append the block to the list */

    genILblockLast->ILblkNext = block;
                                block->ILblkPrev = genILblockLast;
                                                   genILblockLast = block;

GOT_BLK:

    /* The block will be the new current block */

    genILblockCur      = block;

    /* This block has no fixups yet */

    block->ILblkFixups = NULL;

    /* Record the code offset */

    block->ILblkOffs   = genILblockOffs;

//  printf("Beg MSIL block %08X\n", block);

    return block;
}

/*****************************************************************************
 *
 *  Return a conservative estimate of the max. size of the given jump (or 0
 *  if the opcode doesn't designate a jump).
 */

size_t              genIL::genJumpMaxSize(unsigned opcode)
{
    if  (opcode == CEE_NOP || opcode == CEE_UNREACHED)
    {
        return  0;
    }
    else
    {
        return  5;
    }
}

/*****************************************************************************
 *
 *  Return the short form of the given jump opcode along with the smaller size.
 */

unsigned            genIL::genShortenJump(unsigned opcode, size_t *newSize)
{
    *newSize = 2;

    if (opcode == CEE_LEAVE)
        return CEE_LEAVE_S;

    assert(opcode == CEE_BEQ    ||
           opcode == CEE_BNE_UN ||
           opcode == CEE_BLE    ||
           opcode == CEE_BLE_UN ||
           opcode == CEE_BLT    ||
           opcode == CEE_BLT_UN ||
           opcode == CEE_BGE    ||
           opcode == CEE_BGE_UN ||
           opcode == CEE_BGT    ||
           opcode == CEE_BGT_UN ||
           opcode == CEE_BR     ||
           opcode == CEE_BRTRUE ||
           opcode == CEE_BRFALSE);

    /* Make sure we can get away with a simple increment */

    assert(CEE_BRFALSE+ (CEE_BR_S - CEE_BR) == CEE_BRFALSE_S);
    assert(CEE_BRTRUE + (CEE_BR_S - CEE_BR) == CEE_BRTRUE_S);
    assert(CEE_BEQ    + (CEE_BR_S - CEE_BR) == CEE_BEQ_S   );
    assert(CEE_BNE_UN + (CEE_BR_S - CEE_BR) == CEE_BNE_UN_S);
    assert(CEE_BLE    + (CEE_BR_S - CEE_BR) == CEE_BLE_S   );
    assert(CEE_BLE_UN + (CEE_BR_S - CEE_BR) == CEE_BLE_UN_S);
    assert(CEE_BLT    + (CEE_BR_S - CEE_BR) == CEE_BLT_S   );
    assert(CEE_BLT_UN + (CEE_BR_S - CEE_BR) == CEE_BLT_UN_S);
    assert(CEE_BGE    + (CEE_BR_S - CEE_BR) == CEE_BGE_S   );
    assert(CEE_BGE_UN + (CEE_BR_S - CEE_BR) == CEE_BGE_UN_S);
    assert(CEE_BGT    + (CEE_BR_S - CEE_BR) == CEE_BGT_S   );
    assert(CEE_BGT_UN + (CEE_BR_S - CEE_BR) == CEE_BGT_UN_S);

    return  opcode + (CEE_BR_S - CEE_BR);
}

/*****************************************************************************
 *
 *  Finish the current code block; when 'jumpCode' is not equal to CEE_NOP,
 *  there is an implied jump following the block and the jump target is given
 *  by 'jumpDest'.
 */

ILblock             genIL::genEndBlock(unsigned jumpCode, ILblock jumpDest)
{
    size_t          size;
    ILblock         block;

    size_t          jumpSize;

    /* Get hold of the current block */

    block = genILblockCur; assert(block);

    /* Compute the size of the block */

    size = block->ILblkCodeSize = genBuffNext - genBuffAddr;

    /* Is the block non-empty? */

    if  (size)
    {
        /* Allocate a more permanent home for the code */

#if MGDDATA

        BYTE    []      codeBuff;

        codeBuff = new managed BYTE[size];
        UNIMPL(!"need to call arraycopy or some such");

#else

        BYTE    *       codeBuff;

        codeBuff = (BYTE *)genAlloc->nraAlloc(roundUp(size));
        memcpy(codeBuff, genBuffAddr, size);

#endif

        block->ILblkCodeAddr = codeBuff;
    }

#ifndef NDEBUG
    genILblockCur = NULL;
#endif

    /* Record the jump that follows the block */

    jumpSize = genJumpMaxSize(jumpCode);

    block->ILblkJumpCode = jumpCode;
    block->ILblkJumpDest = jumpDest;
    block->ILblkJumpSize = jumpSize;

    /* Make sure the jump opcode/size didn't get truncated */

    assert(block->ILblkJumpCode == jumpCode);
    assert(block->ILblkJumpSize == jumpSize);

    /* Update the current code offset */

    genILblockOffs += size + block->ILblkJumpSize;

    return block;
}

/*****************************************************************************
 *
 *  Finish the current code block, it ends with a switch opcode.
 */

void                genIL::genSwitch(var_types      caseTyp,
                                     unsigned       caseSpn,
                                     unsigned       caseCnt,
                                     __uint64       caseMin,
                                     vectorTree     caseTab,
                                     ILblock        caseBrk)
{
    size_t          size;
    ILswitch        sdesc;
    ILblock         block;

    /* Subtract minimum value if non-zero */

    if  (caseMin)
    {
        genAnyConst(caseMin, caseTyp);
        genOpcode(CEE_SUB);
    }

    /* End the current block and attach a switch "jump" */

    block = genEndBlock(CEE_NOP);

#if DISP_IL_CODE
    genDispILinsBeg(CEE_SWITCH);
    genDispILinsEnd("(%u entries)", caseCnt);
#endif

    /* Allocate the switch descriptor */

#if MGDDATA
    sdesc = new ILswitch;
#else
    sdesc =    (ILswitch)genAlloc->nraAlloc(sizeof(*sdesc));
#endif

    sdesc->ILswtSpan     = caseSpn;
    sdesc->ILswtCount    = caseCnt;
    sdesc->ILswtTable    = caseTab;
    sdesc->ILswtBreak    = caseBrk;

    /* Compute the size of the switch opcode */

    size = genOpcodeSiz(CEE_SWITCH) + (caseSpn + 1) * sizeof(int);

    /* Store the case label info in the block */

    block->ILblkJumpCode = CEE_SWITCH;
    block->ILblkSwitch   = sdesc;

    /* Set the jump size of the block and update the current offset */

    block->ILblkJumpSize = size;
    genILblockOffs      += size;

    /* Make sure the jump opcode/size didn't get truncated */

    assert(block->ILblkJumpCode == CEE_SWITCH);
    assert(block->ILblkJumpSize == size);

    /* The switch opcode pops the value from the stack */

    genCurStkLvl--;

    /* Start a new block for code that follows */

    genBegBlock();
}

/*****************************************************************************
 *
 *  Record a fixup for a RVA for the specified section at the current point
 *  in the MSIL stream.
 */

void                genIL::genILdataFix(WPEstdSects s)
{
    ILfixup         fix;

    // ISSUE: Should we reuse fixup entries across method codegen?

#if MGDDATA
    fix = new ILfixup;
#else
    fix =    (ILfixup)genAlloc->nraAlloc(sizeof(*fix));
#endif

    fix->ILfixOffs = genBuffCurOffs();
    fix->ILfixSect = s;
    fix->ILfixNext = genILblockCur->ILblkFixups;
                     genILblockCur->ILblkFixups = fix;
}

/*****************************************************************************
 *
 *  The emit buffer is full. Simply end the current block and start a new one.
 */

void                genIL::genBuffFlush()
{
    genEndBlock(CEE_NOP);
    genBegBlock();
}

/*****************************************************************************
 *
 *  Start emitting code for a function.
 */

void                genIL::genSectionBeg()
{
    genMaxStkLvl    =
    genCurStkLvl    = 0;

    genLclCount     =
    genArgCount     = 0;

    /* Create the initial block - it will remain empty */

    genILblockCur   = NULL;
    genILblockList  =
    genILblockLast  = genAllocBlk();

    /* Open the initial code block */

    genBegBlock();
}

/*****************************************************************************
 *
 *  Finish emitting code for a function.
 */

size_t              genIL::genSectionEnd()
{
    ILblock         block;
    size_t          size;

    /* Close the current block */

    genEndBlock(CEE_NOP);

    /* Optimize jumps */

//  if  (optJumps)
//      genOptJumps();

#if VERBOSE_BLOCKS
    genDispBlocks("FINAL GEN");
#endif

    /* Compute the total size of the code */

    for (block = genILblockList, size = 0;
         block;
         block = block->ILblkNext)
    {
        block->ILblkOffs = size;

//      printf("Block at %04X has size %02X\n", size, block->ILblkCodeSize);

        size += block->ILblkCodeSize;

        if      (block->ILblkJumpCode == CEE_NOP ||
                 block->ILblkJumpCode == CEE_UNREACHED)
        {
            assert(block->ILblkJumpSize == 0);
        }
        else if (block->ILblkJumpCode == CEE_SWITCH)
        {
            // The size of a switch opcode doesn't change

            size += block->ILblkJumpSize;
        }
        else
        {
            int             dist;

            /* We need to figure out whether this can be a short jump */

            dist = block->ILblkJumpDest->ILblkOffs - (size + 2);

//          printf("Block at %08X [1]: src = %u, dst = %u, dist = %d\n", block, size + 2, block->ILblkJumpDest->ILblkOffs, dist);

            if  (dist >= -128 && dist < 128)
            {
                size_t          newSize;

                /* This jump will be a short one */

                block->ILblkJumpCode = genShortenJump(block->ILblkJumpCode, &newSize);
                block->ILblkJumpSize = newSize;
            }

//          printf("           + jump size %02X\n", block->ILblkJumpSize);

            size += block->ILblkJumpSize;
        }
    }

    return  size;
}

/*****************************************************************************
 *
 *  A little helper to generate 32-bit label offsets.
 */

inline
BYTE    *           genIL::genJmp32(BYTE *dst, ILblock dest, unsigned offs)
{
    *(int *)dst = dest->ILblkOffs - offs;
    return  dst + sizeof(int);
}

/*****************************************************************************
 *
 *  Write the MSIL for the current to the given target address.
 */

BYTE    *           genIL::genSectionCopy(BYTE *dst, unsigned baseRVA)
{
    ILblock         block;

    BYTE    *       base = dst;

    /* Change the base RVA to a simple relative section offset */

    baseRVA -= genPEwriter->WPEgetCodeBase(); assert((int)baseRVA >= 0);

    /* Walk the block list, emitting each one in turn (along with any fixups) */

    for (block = genILblockList;
         block;
         block = block->ILblkNext)
    {
        size_t          csize = block->ILblkCodeSize;

#ifdef  DEBUG
//      if  (block->ILblkOffs != (unsigned)(dst - base))
//          printf("block offset predicted at %04X, actual %04X\n", block->ILblkOffs, (unsigned)(dst - base));
#endif

        assert(block->ILblkOffs == (unsigned)(dst - base));

        /* Copy the code for the block */

#if MGDDATA
        UNIMPL(!"need to call arraycopy");
#else
        memcpy(dst, block->ILblkCodeAddr, csize);
#endif

        /* Are there any fixups in this block? */

        if  (block->ILblkFixups)
        {
            unsigned        ofs;
            ILfixup         fix;

            /* Compute the RVA of the block */

            ofs = baseRVA + block->ILblkOffs;

            /* Now report all the fixups for this code block */

            for (fix = block->ILblkFixups; fix; fix = fix->ILfixNext)
            {

#ifdef  DEBUG
//              printf("Code fixup at offset %04X for section '%s'\n",
//                  ofs + fix->ILfixOffs,
//                  genPEwriter->WPEsecName(fix->ILfixSect));
#endif

                genPEwriter->WPEsecAddFixup(PE_SECT_text, fix->ILfixSect,
                                                          fix->ILfixOffs + ofs);
            }
        }

        /* Update the destination pointer */

        dst += csize;

        /* Now generate the trailing jump, if there is one */

        switch (block->ILblkJumpCode)
        {
        case CEE_NOP:
        case CEE_UNREACHED:
            break;

        case CEE_SWITCH:
            {
                unsigned        opc;
                size_t          siz;

                unsigned        base;

                __int64         lastv;
                bool            first;

                ILswitch        sdesc = block->ILblkSwitch;
                unsigned        count = sdesc->ILswtCount;
                vectorTree      table = sdesc->ILswtTable;
                ILblock         brklb = sdesc->ILswtBreak;
                unsigned        tlcnt = sdesc->ILswtSpan;
                unsigned        clnum;

#ifdef  DEBUG
                unsigned        tgcnt = 0;
#endif

                /* Output the opcode followed by the count */

                opc = genOpcodeEnc(CEE_SWITCH);
                siz = genOpcodeSiz(CEE_SWITCH);

                memcpy(dst, &opc, siz); dst += siz;
                memcpy(dst, &tlcnt, 4); dst += 4;

                assert(siz + 4*(tlcnt+1) == block->ILblkJumpSize);

                /* Figure out the base for the label references */

                base = block->ILblkOffs + block->ILblkCodeSize
                                        + block->ILblkJumpSize;

                /* Now output the offsets of the case labels */

                assert(count);

                clnum = 0;

                do
                {
                    Tree            clabx;
                    __int64         clabv;
                    ILblock         label;

                    /* Grab the next case label entry */

                    clabx = table[clnum]; assert(clabx && clabx->tnOper == TN_CASE);

                    /* Get hold of the label and the case value */

                    label = clabx->tnCase.tncLabel; assert(label);
                    clabx = clabx->tnCase.tncValue; assert(clabx);

                    assert(clabx->tnOper == TN_CNS_INT ||
                           clabx->tnOper == TN_CNS_LNG);

                    clabv = (clabx->tnOper == TN_CNS_INT) ? clabx->tnIntCon.tnIconVal
                                                          : clabx->tnLngCon.tnLconVal;

                    /* Make sure any gaps are filled with 'break' */

                    if  (clnum == 0)
                    {
                        lastv = clabv;
                        first = false;
                    }

                    assert(clabv >= lastv);

                    while (clabv > lastv++)
                    {
#ifdef  DEBUG
                        tgcnt++;
#endif
                        dst = genJmp32(dst, brklb, base);
                    }

                    clnum++;

#ifdef  DEBUG
                    tgcnt++;
#endif

                    /* Generate the case label's address */

                    dst = genJmp32(dst, label, base);
                }
                while (--count);

                assert(tgcnt == tlcnt);
            }
            break;

        default:
            {
                size_t          size;
                unsigned        jump;
                unsigned        code;
                int             dist;

                /* This is a "simple" jump to a label */

                size = block->ILblkJumpSize;
                jump = block->ILblkJumpCode;
                code = genOpcodeEnc(jump);

                /* Compute the jump distance */

                dist = block->ILblkJumpDest->ILblkOffs - (dst + size - base);

//              printf("Block at %08X [2]: src = %u, dst = %u, dist = %d\n", block, dst + size - base, block->ILblkJumpDest->ILblkOffs, dist);

                /* Append the opcode  of the jump */

                assert((code & ~0xFF) == 0); *dst++ = code;

                /* Append the operand of the jump */

                if  (size < 4)
                {
                    /* This must be a short jump */

                    assert(jump == CEE_BR_S      ||
                           jump == CEE_BRTRUE_S  ||
                           jump == CEE_BRFALSE_S ||
                           jump == CEE_BEQ_S     ||
                           jump == CEE_BNE_UN_S  ||
                           jump == CEE_BLE_S     ||
                           jump == CEE_BLE_UN_S  ||
                           jump == CEE_BLT_S     ||
                           jump == CEE_BLT_UN_S  ||
                           jump == CEE_BGE_S     ||
                           jump == CEE_BGE_UN_S  ||
                           jump == CEE_BGT_S     ||
                           jump == CEE_BGT_UN_S  ||
                           jump == CEE_LEAVE_S);

                    assert(size == 2);
                    assert(dist == (signed char)dist);
                }
                else
                {
                    /* This must be a long  jump */

                    assert(jump == CEE_BR        ||
                           jump == CEE_BRTRUE    ||
                           jump == CEE_BRFALSE   ||
                           jump == CEE_BEQ       ||
                           jump == CEE_BNE_UN    ||
                           jump == CEE_BLE       ||
                           jump == CEE_BLE_UN    ||
                           jump == CEE_BLT       ||
                           jump == CEE_BLT_UN    ||
                           jump == CEE_BGE       ||
                           jump == CEE_BGE_UN    ||
                           jump == CEE_BGT       ||
                           jump == CEE_BGT_UN    ||
                           jump == CEE_LEAVE);

                    assert(size == 5);
                }

                size--; memcpy(dst, &dist, size); dst += size;
            }
            break;
        }
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Create a unique temporary label name.
 */

#if DISP_IL_CODE

const   char    *   genIL::genTempLabName()
{
    static
    char            temp[16];

    sprintf(temp, "$t%04u", ++genTempLabCnt);

    return  temp;
}

#endif

/*****************************************************************************
 *
 *  Check that all temps have been freed.
 */

#ifdef  DEBUG

void                genIL::genTempVarChk()
{
    unsigned        i;

    for (i = 0; i < TYP_COUNT; i++) assert(genTempVarCnt [i] ==    0);
    for (i = 0; i < TYP_COUNT; i++) assert(genTempVarUsed[i] == NULL);
    for (i = 0; i < TYP_COUNT; i++) assert(genTempVarFree[i] == NULL);
}

#endif

/*****************************************************************************
 *
 *  Initialize the temp tracking logic.
 */

void                genIL::genTempVarInit()
{
    memset(genTempVarCnt , 0, sizeof(genTempVarCnt ));
    memset(genTempVarUsed, 0, sizeof(genTempVarUsed));
    memset(genTempVarFree, 0, sizeof(genTempVarFree));
}

/*****************************************************************************
 *
 *  Shutdown the temp tracking logic.
 */

void                genIL::genTempVarDone()
{
    genTempVarChk();
}

/*****************************************************************************
 *
 *  Start using temps - called at the beginning of codegen for a function.
 */

void                genIL::genTempVarBeg(unsigned lclCnt)
{
    genTmpBase  = lclCnt;
    genTmpCount = 0;

    genTempList =
    genTempLast = NULL;

    genTempVarChk();
}

/*****************************************************************************
 *
 *  Finish using temps - called at the end of codegen for a function.
 */

void                genIL::genTempVarEnd()
{
    assert(genTmpBase == genLclCount || genComp->cmpErrorCount);

    memset(genTempVarFree, 0, sizeof(genTempVarFree));

    genTempVarChk();
}

/*****************************************************************************
 *
 *  Allocate a temp of the given type.
 */

unsigned            genIL::genTempVarGet(TypDef type)
{
    unsigned        vtp = type->tdTypeKind;

    unsigned        num;
    ILtemp          tmp;

//  printf("Creating temp of type '%s'\n", genStab->stTypeName(type, NULL));

    /* Map pointer temps to integers and all refs to Object */

    switch (vtp)
    {
    case TYP_ARRAY:
        if  (!type->tdIsManaged)
            goto UMG_PTR;

        // Fall through ...

    case TYP_REF:
        type = genComp->cmpObjectRef();
        break;

    case TYP_ENUM:
        type = type->tdEnum.tdeIntType;
        vtp  = type->tdTypeKind;
        break;

    case TYP_PTR:
    UMG_PTR:
        type = genComp->cmpTypeInt;
        vtp  = TYP_INT;
        break;
    }

    /* Is there a free temp available? */

    tmp = genTempVarFree[vtp];

    if  (tmp)
    {
        /* Is this a struct type? */

        if  (vtp == TYP_CLASS)
        {
            ILtemp          lst = NULL;

            /* We better get a precise match on the type */

            for (;;)
            {
                ILtemp          nxt = tmp->tmpNext;

                if  (symTab::stMatchTypes(tmp->tmpType, type))
                {
                    /* Match - reuse this temp */

                    if  (lst)
                    {
                        lst->tmpNext = nxt;
                    }
                    else
                    {
                        genTempVarFree[vtp] = lst;
                    }

                    break;
                }

                /* Are there more temps to consider? */

                lst = tmp;
                tmp = nxt;

                if  (!tmp)
                    goto GET_TMP;
            }
        }
        else
        {
            /* Remove the temp from the free list */

            genTempVarFree[vtp] = tmp->tmpNext;
        }
    }
    else
    {
        /* Here we need to allocate a new temp */

    GET_TMP:

        /* Grab a local slot# for the temp */

        num = genTmpBase + genTmpCount++;

        /* Allocate a temp descriptor */

#if MGDDATA
        tmp = new ILtemp;
#else
        tmp =    (ILtemp)genAlloc->nraAlloc(sizeof(*tmp));
#endif

#ifdef  DEBUG
        tmp->tmpSelf = tmp;
#endif

        /* Record the temporary number, type, etc. */

        tmp->tmpNum  = num;
        tmp->tmpType = type;

        /* Append the temp to the global temp list */

        tmp->tmpNxtN = NULL;

        if  (genTempList)
            genTempLast->tmpNxtN = tmp;
        else
            genTempList          = tmp;

        genTempLast = tmp;
    }

    /* Append the temp  to  the used list */

    tmp->tmpNext = genTempVarUsed[vtp];
                   genTempVarUsed[vtp] = tmp;

    /* Return the temp number to the caller */

    return  tmp->tmpNum;
}

/*****************************************************************************
 *
 *  Release the given temp.
 */

void                genIL::genTempVarRls(TypDef type, unsigned tnum)
{
    unsigned        vtp = type->tdTypeKind;

    ILtemp       *  ptr;
    ILtemp          tmp;

    switch (vtp)
    {
    case TYP_PTR:

        /* Map pointer temps to integers [ISSUE: is this correct?] */

        type = genComp->cmpTypeInt;
        vtp  = TYP_INT;
        break;

    case TYP_ENUM:

        /* Map enums to their underlying type */

        type = type->tdEnum.tdeIntType;
        vtp  = type->tdTypeKind;
        break;
    }

    /* Remove the entry from the used list */

    for (ptr = &genTempVarUsed[vtp];;)
    {
        tmp = *ptr; assert(tmp);

        if  (tmp->tmpNum == tnum)
        {
            /* Remove the temp from the used list */

            *ptr = tmp->tmpNext;

            /* Append the temp  to  the free list */

            tmp->tmpNext = genTempVarFree[vtp];
                           genTempVarFree[vtp] = tmp;

            return;
        }

        ptr = &tmp->tmpNext;
    }
}

/*****************************************************************************
 *
 *  Temp iterator: return the type of the given temp and return a cookie for
 *  the next one.
 */

genericRef          genIL::genTempIterNxt(genericRef iter, OUT TypDef REF typRef)
{
    ILtemp          tmp = (ILtemp)iter;

    assert(tmp->tmpSelf == tmp);

    typRef = tmp->tmpType;

    return  tmp->tmpNxtN;
}

/*****************************************************************************/
#if     DISP_IL_CODE
/*****************************************************************************/

const   char *  DISP_BCODE_PREFIX   = "       ";
const   int     DISP_STKLVL         =  1;       // enable for debugging of MSIL generation

/*****************************************************************************/

#ifndef __SMC__
const char *        opcodeName(unsigned op);    // moved into macros.cpp
#endif

/*****************************************************************************/

void                genIL::genDispILopc(const char *name, const char *suff)
{
    static  char    temp[128];

    strcpy(temp, name);
    if  (suff)
        strcat(temp, suff);

    printf(" %-11s   ", temp);
}

void                genIL::genDispILinsBeg(unsigned op)
{
    assert(op != CEE_ILLEGAL);
    assert(op != CEE_count);

    if  (genDispCode)
    {
        if  (DISP_STKLVL)
        {
            printf("[%04X", genCurOffset());
            if  ((int)genCurStkLvl >= 0 && genComp->cmpErrorCount == 0)
                printf(":%2d] ", genCurStkLvl);
            else
                printf( "   ] ");
        }
        else
            printf(DISP_BCODE_PREFIX);

        genDispILinsLst  = op;

        genDispILnext    = genDispILbuff;
        genDispILnext[0] = 0;
    }
}

void                genIL::genDispILins_I1(int v)
{
    if  (genComp->cmpConfig.ccDispILcd)
    {
        char            buff[8];
        sprintf(buff, "%02X ", v & 0xFF);
        strcat(genDispILnext, buff);
    }
}

void                genIL::genDispILins_I2(int v)
{
    if  (genComp->cmpConfig.ccDispILcd)
    {
        char            buff[8];
        sprintf(buff, "%04X ", v & 0xFFFF);
        strcat(genDispILnext, buff);
    }
}

void                genIL::genDispILins_I4(int v)
{
    if  (genComp->cmpConfig.ccDispILcd)
    {
        char            buff[12];
        sprintf(buff, "%08X ", v);
        strcat(genDispILnext, buff);
    }
}

void                genIL::genDispILins_I8(__int64 v)
{
    if  (genComp->cmpConfig.ccDispILcd)
    {
        char            buff[20];
        sprintf(buff, "%016I64X ", v);
        strcat(genDispILnext, buff);
    }
}

void                genIL::genDispILins_R4(float v)
{
    if  (genComp->cmpConfig.ccDispILcd)
    {
        char            buff[16];
        sprintf(buff, "%f ", v);
        strcat(genDispILnext, buff);
    }
}

void                genIL::genDispILins_R8(double v)
{
    if  (genComp->cmpConfig.ccDispILcd)
    {
        char            buff[20];
        sprintf(buff, "%lf ", v);
        strcat(genDispILnext, buff);
    }
}

void    __cdecl     genIL::genDispILinsEnd(const char *fmt, ...)
{
    if  (genDispCode)
    {
        va_list     args; va_start(args, fmt);

        assert(genDispILinsLst != CEE_ILLEGAL);

        if  (genComp->cmpConfig.ccDispILcd)
        {
            genDispILbuff[IL_OPCDSP_LEN] = 0;

            printf("%*s ", -(int)IL_OPCDSP_LEN, genDispILbuff);
        }

        genDispILopc(opcodeName(genDispILinsLst));

        vprintf(fmt, args);
        printf("\n");

        genDispILinsLst = CEE_ILLEGAL;
    }
}

/*****************************************************************************/
#endif//DISP_IL_CODE
/*****************************************************************************
 *
 *  The following helpers output data of various sizes / formats to the IL
 *  stream.
 */

inline
void                genIL::genILdata_I1(int v)
{
    if  (genBuffNext   >= genBuffLast) genBuffFlush();

#if DISP_IL_CODE
    genDispILins_I1(v);
#endif

    *genBuffNext++ = v;
}

inline
void                genIL::genILdata_I2(int v)
{
    if  (genBuffNext+1 >= genBuffLast) genBuffFlush();

    *(__int16 *)genBuffNext = v;    // WARNING: This is not endian-safe!

#if DISP_IL_CODE
    genDispILins_I2(v);
#endif

    genBuffNext += sizeof(__int16);
}

inline
void                genIL::genILdata_I4(int v)
{
    if  (genBuffNext+3 >= genBuffLast) genBuffFlush();

    *(__int32 *)genBuffNext = v;    // WARNING: This is not endian-safe!

#if DISP_IL_CODE
    genDispILins_I4(v);
#endif

    genBuffNext += sizeof(__int32);
}

inline
void                genIL::genILdata_R4(float v)
{
    if  (genBuffNext+3 >= genBuffLast) genBuffFlush();

    *(float *)genBuffNext = v;

#if DISP_IL_CODE
    genDispILins_R4(v);
#endif

    genBuffNext += sizeof(float);
}

inline
void                genIL::genILdata_R8(double v)
{
    if  (genBuffNext+7 >= genBuffLast) genBuffFlush();

    *(double *)genBuffNext = v;

#if DISP_IL_CODE
    genDispILins_R8(v);
#endif

    genBuffNext += sizeof(double);
}

void                genIL::genILdataStr(unsigned o)
{
    genILdataFix(PE_SECT_string);

    *(__int32 *)genBuffNext = o;    // WARNING: This is not endian-safe!

#if DISP_IL_CODE
    genDispILins_I4(o);
#endif

    genBuffNext += sizeof(__int32);
}

void                genIL::genILdataRVA(unsigned o, WPEstdSects s)
{
    if  (genBuffNext+3 >= genBuffLast) genBuffFlush();

    genILdataFix(s);

    *(__int32 *)genBuffNext = o;    // WARNING: This is not endian-safe!

#if DISP_IL_CODE
    genDispILins_I4(o);
#endif

    genBuffNext += sizeof(__int32);
}

void                genIL::genILdata_I8(__int64 v)
{
    if  (genBuffNext+7 >= genBuffLast) genBuffFlush();

    *(__int64 *)genBuffNext = v;    // WARNING: This is not endian-safe!

#if DISP_IL_CODE
    genDispILins_I8(v);
#endif

    genBuffNext += sizeof(__int64);
}

/*****************************************************************************
 *
 *  Generate the encoding for the given MSIL opcode.
 */

void                genIL::genOpcodeOper(unsigned op)
{
    const
    ILencoding  *   opc;

    assert(op <  CEE_count);
    assert(op != CEE_ILLEGAL);
    assert(op != CEE_UNREACHED);

    genCurStkLvl += ILopcodeStack[op]; genMarkStkMax();

#ifndef NDEBUG
    if  ((int)genCurStkLvl < 0 && !genComp->cmpErrorCount)
    {
        genDispILinsEnd("");
        NO_WAY(!"bad news, stack depth is going negative");
    }
#endif

    opc = ILopcodeCodes + op;

    switch (opc->ILopcL)
    {
    case 1:
        assert(opc->ILopc1 == 0xFF);
        genILdata_I1(opc->ILopc2);
        break;

    case 2:
        genILdata_I1(opc->ILopc1);
        genILdata_I1(opc->ILopc2);
        break;

    case 0:
        UNIMPL(!"output large opcode");

    default:
        NO_WAY(!"unexpected encoding length");
    }
}

/*****************************************************************************
 *
 *  Update the current stack level to reflect the effects of the given IL
 *  opcode.
 */

inline
void                genIL::genUpdateStkLvl(unsigned op)
{
    assert(op <  CEE_count);
    assert(op != CEE_ILLEGAL);
    assert(op != CEE_UNREACHED);

    genCurStkLvl += ILopcodeStack[op];
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with no operands.
 */

void                genIL::genOpcode(unsigned op)
{
    assert(op != CEE_NOP);

#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);

#if DISP_IL_CODE
    genDispILinsEnd("");
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a single 8-bit signed int operand.
 */

void                genIL::genOpcode_I1(unsigned op, int v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_I1(v1);

#if DISP_IL_CODE
    genDispILinsEnd("%d", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a single 8-bit unsigned int operand.
 */

void                genIL::genOpcode_U1(unsigned op, unsigned v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_I1(v1);

#if DISP_IL_CODE
    genDispILinsEnd("%u", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a single 16-bit unsigned int operand.
 */

void                genIL::genOpcode_U2(unsigned op, unsigned v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_I2(v1);

#if DISP_IL_CODE
    genDispILinsEnd("%u", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a single 32-bit signed int operand.
 */

void                genIL::genOpcode_I4(unsigned op, int v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_I4(v1);

#if DISP_IL_CODE
    if  (v1 < 0 || v1 >= 10)
        genDispILinsEnd("%d ; 0x%X", v1, v1);
    else
        genDispILinsEnd("%d", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a single 64-bit signed int operand.
 */

void                genIL::genOpcode_I8(unsigned op, __int64 v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_I8(v1);

#if DISP_IL_CODE
    genDispILinsEnd("%Ld", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a 'float' operand.
 */

void                genIL::genOpcode_R4(unsigned op, float v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_R4(v1);

#if DISP_IL_CODE
    genDispILinsEnd("%f", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a 'double' operand.
 */

void                genIL::genOpcode_R8(unsigned op, double v1)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_R8(v1);

#if DISP_IL_CODE
    genDispILinsEnd("%lf", v1);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a token operand.
 */

void                genIL::genOpcode_tok(unsigned op, mdToken tok)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdata_I4(tok);

#if DISP_IL_CODE
    genDispILinsEnd("tok[%04X]", tok);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a RVA operand.
 */

void                genIL::genOpcode_RVA(unsigned op, WPEstdSects sect,
                                                      unsigned    offs)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdataRVA(offs, sect);

#if DISP_IL_CODE
    genDispILinsEnd("[%s + 0x%04X]", genPEwriter->WPEsecName(sect), offs);
#endif
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a string operand.
 */

void                genIL::genOpcode_str(unsigned op, unsigned offs)
{
#if DISP_IL_CODE
    genDispILinsBeg(op);
#endif

    genOpcodeOper(op);
    genILdataStr(offs);

    // The caller is required to call genDispILinsEnd(), since only
    // he knows whether the string is ANSI or Unicode.
}

/*****************************************************************************
 *
 *  Generate an opcode if it's not a NOP.
 */

void                genIL::genOpcodeNN(unsigned op)
{
    if  (op != CEE_NOP)
        genOpcode(op);
}

/*****************************************************************************/
#if DISP_IL_CODE

const   char *      genIL::genDspLabel(ILblock lab)
{
    if  (genDispCode)
    {
        assert(lab->ILblkNum);

        static  char    temp[16];
        sprintf(temp, "L_%02u", lab->ILblkNum);        // watch out: static buffer!
        return  temp;
    }
    else
        return NULL;
}

void                genIL::genDspLabDf(ILblock lab)
{
    if  (genDispCode)
    {
        if  (!(lab->ILblkFlags & ILBF_LABDEF))
        {
            if  (genComp->cmpConfig.ccDispILcd)
                printf("%*s ", IL_OPCDSP_LEN, "");

            printf("%s:\n", genDspLabel(lab));

            lab->ILblkFlags |= ILBF_LABDEF;
        }
    }
}

#endif//DISP_IL_CODE
/*****************************************************************************
 *
 *  Return a block that can be used to make jump references to the current
 *  position.
 */

ILblock             genIL::genBwdLab()
{
    /* Is the current block non-empty? */

    if  (genCurBlkNonEmpty())
    {
        /* End the current block and start a new one */

        genEndBlock(CEE_NOP);
        genBegBlock();
    }

#if DISP_IL_CODE
    genDspLabDf(genILblockCur);
#endif

    return  genILblockCur;
}

/*****************************************************************************
 *
 *  Define the given forward reference block as being the current position.
 */

void                genIL::genFwdLabDef(ILblock block)
{
    assert(block);

    genEndBlock(CEE_NOP);

#if DISP_IL_CODE
    genDspLabDf(block);
#endif

    genBegBlock(block);
}

/*****************************************************************************
 *
 *  Generate an MSIL instruction with a jump target (label) operand.
 */

void                genIL::genOpcode_lab(unsigned op, ILblock lab)
{
    assert(lab);

#if DISP_IL_CODE
    genDispILinsBeg(op);
    genDispILinsEnd("%s", genDspLabel(lab));
#endif

    genUpdateStkLvl(op);

    genEndBlock(op, lab);
    genBegBlock();
}

/*****************************************************************************
 *
 *  Generate an integer constant value.
 */

void                genIL::genIntConst(__int32 val)
{
    if  (val >= -128 && val < 128)
    {
        if  (val >= -1 && val <= 8)
        {
            static
            unsigned        constOpc[] =
            {
                CEE_LDC_I4_M1,
                CEE_LDC_I4_0,
                CEE_LDC_I4_1,
                CEE_LDC_I4_2,
                CEE_LDC_I4_3,
                CEE_LDC_I4_4,
                CEE_LDC_I4_5,
                CEE_LDC_I4_6,
                CEE_LDC_I4_7,
                CEE_LDC_I4_8,
            };

            genOpcode(constOpc[val+1]);
        }
        else
        {
            genOpcode_I1(CEE_LDC_I4_S, val);
        }
    }
    else
        genOpcode_I4(CEE_LDC_I4, val);
}

/*****************************************************************************
 *
 *  Generate a 64-bit integer constant value.
 */

inline
void                genIL::genLngConst(__int64 val)
{
    genOpcode_I8(CEE_LDC_I8, val);
}

/*****************************************************************************
 *
 *  Generate a small integral constant value with the given type.
 */

void                genIL::genAnyConst(__int64 val, var_types vtp)
{
    switch (vtp)
    {
    default:
        genIntConst((__int32)val);
        return;

    case TYP_LONG:
    case TYP_ULONG:
        genLngConst(         val);
        return;

    case TYP_FLOAT:
        genOpcode_R4(CEE_LDC_R4, (  float)val);
        return;

    case TYP_DOUBLE:
    case TYP_LONGDBL:
        genOpcode_R8(CEE_LDC_R8, ( double)val);
        return;
    }
}

/*****************************************************************************
 *
 *  Returns the local variable / argument index of the given variable.
 */

inline
unsigned            genIL::genGetLclIndex(SymDef varSym)
{
    assert(varSym->sdSymKind == SYM_VAR);
    assert(varSym->sdVar.sdvLocal);
    assert(varSym->sdParent->sdSymKind == SYM_FNC ||
           varSym->sdParent->sdSymKind == SYM_SCOPE);

#ifdef  DEBUG

    if      (varSym->sdVar.sdvArgument)
    {
        assert(varSym->sdVar.sdvILindex <  genArgCount);
    }
    else if (varSym->sdIsImplicit)
    {
        assert(varSym->sdVar.sdvILindex >= genTmpBase);
        assert(varSym->sdVar.sdvILindex <  genTmpBase + genTmpCount);
    }
    else
    {
        assert(varSym->sdVar.sdvILindex <  genLclCount);
    }

#endif

    return varSym->sdVar.sdvILindex;
}

/*****************************************************************************
 *
 *  Generate load/store of a local variable/argument.
 */

inline
void                genIL::genLclVarRef(SymDef varSym, bool store)
{
    unsigned        index;

    assert(varSym);
    assert(varSym->sdSymKind == SYM_VAR);

    index = genGetLclIndex(varSym);

    if  (varSym->sdVar.sdvArgument)
        genArgVarRef(index, store);
    else
        genLclVarRef(index, store);
}

/*****************************************************************************
 *
 *  Generate the address of a local variable/argument.
 */

void                genIL::genLclVarAdr(SymDef varSym)
{
    unsigned        index;

    assert(varSym);
    assert(varSym->sdSymKind == SYM_VAR);

    index = genGetLclIndex(varSym);

    if  (varSym->sdVar.sdvArgument)
    {
        // UNDONE: Check for reference arguments

        if  (index < 256)
            genOpcode_U1(CEE_LDARGA_S, index);
        else
            genOpcode_I4(CEE_LDARGA  , index);
    }
    else
    {
        if  (index < 256)
            genOpcode_U1(CEE_LDLOCA_S, index);
        else
            genOpcode_I4(CEE_LDLOCA  , index);
    }
}

/*****************************************************************************
 *
 *  Generate the address of a local variable.
 */

inline
void                genIL::genLclVarAdr(unsigned slot)
{
    if  (slot < 256)
        genOpcode_U1(CEE_LDLOCA_S, slot);
    else
        genOpcode_I4(CEE_LDLOCA  , slot);
}

/*****************************************************************************
 *
 *  Unfortunately, the compiler is too lazy to convert all tree nodes that
 *  have enum type to have the actual underlying integer types, so we do
 *  this here.
 */

inline
var_types           genIL::genExprVtyp(Tree expr)
{
    var_types       vtp = expr->tnVtypGet();

    if  (vtp == TYP_ENUM)
        vtp = genComp->cmpActualVtyp(expr->tnType);

    return  vtp;
}

/*****************************************************************************
 *
 *  Returns the reverse of a comparison operator.
 */

static  treeOps     revRel[] =
{
    TN_NE,          // TN_EQ
    TN_EQ,          // TN_NE
    TN_GE,          // TN_LT
    TN_GT,          // TN_LE
    TN_LT,          // TN_GE
    TN_LE,          // TN_GT
};

/*****************************************************************************
 *
 *  Map a relational tree node operator to the corresponding MSIL opcode that
 *  will branch when the condition is satisfied.
 */

static  unsigned    relToOpcSgn[] =
{
    CEE_BEQ,        // TN_EQ
    CEE_BNE_UN,     // TN_NE
    CEE_BLT,        // TN_LT
    CEE_BLE,        // TN_LE
    CEE_BGE,        // TN_GE
    CEE_BGT,        // TN_GT
};

static  unsigned    relToOpcUns[] =
{
    CEE_BEQ,        // TN_EQ
    CEE_BNE_UN,     // TN_NE
    CEE_BLT_UN,     // TN_LT
    CEE_BLE_UN,     // TN_LE
    CEE_BGE_UN,     // TN_GE
    CEE_BGT_UN,     // TN_GT
};

/*****************************************************************************
 *
 *  Map a relational tree node operator to the corresponding MSIL opcode that
 *  will compute (materialize) the value of the condition.
 */

struct  cmpRelDsc
{
    unsigned short      crdOpcode;
    unsigned char       crdNegate;
};

static  cmpRelDsc   relToMopSgn[] =
{
  { CEE_CEQ   , 0 },// TN_EQ
  { CEE_CEQ   , 1 },// TN_NE
  { CEE_CLT   , 0 },// TN_LT
  { CEE_CGT   , 1 },// TN_LE
  { CEE_CLT   , 1 },// TN_GE
  { CEE_CGT   , 0 },// TN_GT
};

static  cmpRelDsc   relToMopUns[] =
{
  { CEE_CEQ   , 0 },// TN_EQ
  { CEE_CEQ   , 1 },// TN_NE
  { CEE_CLT_UN, 0 },// TN_LT
  { CEE_CGT_UN, 1 },// TN_LE
  { CEE_CLT_UN, 1 },// TN_GE
  { CEE_CGT_UN, 0 },// TN_GT
};

/*****************************************************************************
 *
 *  Generate code that will jump to 'labTrue' if 'op1 <relOper> op2' is 'sense'.
 */

void                genIL::genRelTest(Tree cond, Tree op1,
                                                 Tree op2, int      sense,
                                                           ILblock  labTrue)
{
    unsigned    *   relTab;

    treeOps         relOper = cond->tnOperGet();
    treeOps         orgOper = relOper;

    var_types       vtp = genExprVtyp(op1);

    /* Reverse the comparison, if appropriate */

    if  (!sense)
    {
        relOper = revRel[relOper - TN_EQ];
        cond->tnFlags ^= TNF_REL_NANREV;
    }

    /* Both operands should have the same type */

#ifdef DEBUG
    if  (op1->tnVtypGet() != op2->tnVtypGet())
    {
        printf("\n"); genComp->cmpParser->parseDispTree(op1);
        printf("\n"); genComp->cmpParser->parseDispTree(op2);
    }
#endif

    assert(op1->tnVtypGet() == op2->tnVtypGet());

    genExpr(op1, true);
    genExpr(op2, true);

    assert(relToOpcSgn[TN_EQ - TN_EQ] == CEE_BEQ);
    assert(relToOpcSgn[TN_NE - TN_EQ] == CEE_BNE_UN);
    assert(relToOpcSgn[TN_LT - TN_EQ] == CEE_BLT);
    assert(relToOpcSgn[TN_LE - TN_EQ] == CEE_BLE);
    assert(relToOpcSgn[TN_GE - TN_EQ] == CEE_BGE);
    assert(relToOpcSgn[TN_GT - TN_EQ] == CEE_BGT);

    assert(relToOpcUns[TN_EQ - TN_EQ] == CEE_BEQ);
    assert(relToOpcUns[TN_NE - TN_EQ] == CEE_BNE_UN);
    assert(relToOpcUns[TN_LT - TN_EQ] == CEE_BLT_UN);
    assert(relToOpcUns[TN_LE - TN_EQ] == CEE_BLE_UN);
    assert(relToOpcUns[TN_GE - TN_EQ] == CEE_BGE_UN);
    assert(relToOpcUns[TN_GT - TN_EQ] == CEE_BGT_UN);

    if  (varTypeIsUnsigned(vtp))
    {
        relTab = relToOpcUns;
    }
    else if (varTypeIsFloating(vtp) && (cond->tnFlags & TNF_REL_NANREV))
    {
        relTab = relToOpcUns;
    }
    else
        relTab = relToOpcSgn;

    assert(relOper - TN_EQ < arraylen(relToOpcUns));
    assert(relOper - TN_EQ < arraylen(relToOpcSgn));

    genOpcode_lab(relTab[relOper - TN_EQ], labTrue);
}

/*****************************************************************************
 *
 *  Generate code that will test the given expression for non-zero and jump
 *  to the appropriate label.
 */

void                genIL::genExprTest(Tree            expr,
                                       int             sense,
                                       int             genJump, ILblock labTrue,
                                                                ILblock labFalse)
{
    /* Just in case we'll want to generate line# info for the condition */

//  genRecordExprAddr(expr);

AGAIN:

    /* Is the condition a short-circuit or relational operator? */

    switch (expr->tnOper)
    {
        Tree            oper;
        ILblock         labTmp;

    case TN_LOG_OR:

        /*
            For a test of an "||" condition, we generate the following:

                    <op1>
                    JccTrue  labTrue
            tmpFalse:
                    <op2>
         */

        labTmp = genFwdLabGet();

        if  (sense)
            genExprTest(expr->tnOp.tnOp1, true, true, labTrue , labTmp);
        else
            genExprTest(expr->tnOp.tnOp1, true, true, labFalse, labTmp);

    SC_FIN:

        genFwdLabDef(labTmp);

        if  (genJump)
        {
            expr = expr->tnOp.tnOp2;
            goto AGAIN;
        }

        genExpr(expr->tnOp.tnOp2, true);
        break;

    case TN_LOG_AND:

        /*
            For a test of an "&&" condition, we generate the following:

                    <op1>
                    JccFalse labFalse
            tmpTrue:
                    <op2>
         */

        labTmp = genFwdLabGet();

        if  (sense)
            genExprTest(expr->tnOp.tnOp1, false, true, labFalse, labTmp);
        else
            genExprTest(expr->tnOp.tnOp1, false, true, labTrue , labTmp);

        goto SC_FIN;

    case TN_LOG_NOT:

        /* Logical negation: "flip" the sense of the comparison and repeat */

        oper = expr->tnOp.tnOp1;

        expr->tnFlags &= ~TNF_REL_NANREV;
        expr->tnFlags |= (oper->tnFlags & TNF_REL_NANREV) ^ TNF_REL_NANREV;

        expr   = oper;
        sense  = !sense;
        goto AGAIN;

    case TN_EQ:
    case TN_NE:

        if  (!genJump)
            break;

        if  ((expr->tnOp.tnOp2->tnOper == TN_CNS_INT &&
              expr->tnOp.tnOp2->tnIntCon.tnIconVal == 0) ||
              expr->tnOp.tnOp2->tnOper == TN_NULL)
        {
            if  (expr->tnOper == TN_EQ)
                sense ^= 1;

            genExpr(expr->tnOp.tnOp1, true);
            genOpcode_lab(sense ? CEE_BRTRUE : CEE_BRFALSE, labTrue);
            return;
        }

        // Fall through ....

    case TN_LE:
    case TN_GE:
    case TN_LT:
    case TN_GT:

        if  (!genJump)
            break;

        genRelTest(expr, expr->tnOp.tnOp1,
                         expr->tnOp.tnOp2, sense, labTrue);
        return;

    case TN_ISTYPE:

        assert(expr->tnOp.tnOp2->tnOper == TN_NONE);

        genExpr(expr->tnOp.tnOp1, true);
        genOpcode_tok(CEE_ISINST, genTypeRef(expr->tnOp.tnOp2->tnType));
        genOpcode_lab(sense ? CEE_BRTRUE : CEE_BRFALSE, labTrue);
        return;

    case TN_COMMA:
        genExpr(expr->tnOp.tnOp1, false);
        expr = expr->tnOp.tnOp2;
        goto AGAIN;

    default:
        genExpr(expr, true);
        break;
    }

    /* Generate the final jump, if the caller requested it */

    if  (genJump)
    {
        genOpcode_lab(sense ? CEE_BRTRUE
                            : CEE_BRFALSE, labTrue);
    }
}

/*****************************************************************************
 *
 *  Create a temporary label; test the expression 'pt' for zero/non-zero,
 *  and jump to that temporary label if the expression is logically equal
 *  to 'sense'. Return the temporary label to the caller for further use.
 */

ILblock             genIL::genTestCond(Tree cond, bool sense)
{
    ILblock         labYo;
    ILblock         labNo;

    /* We'll need 2 labels, one of them will be returned to the caller */

    labYo = genFwdLabGet();
    labNo = genFwdLabGet();

    genExprTest(cond, sense, true, labYo, labNo);

    genFwdLabDef(labNo);

    return labYo;
}

/*****************************************************************************
 *
 *  Generate the address of the given global variable (static data members
 *  of unmanaged classes are also acceptable).
 */

void                genIL::genGlobalAddr(Tree expr)
{
    SymDef          sym;

    /* Get hold of the variable symbol */

    assert(expr->tnOper == TN_VAR_SYM);

    sym = expr->tnVarSym.tnVarSym; assert(sym->sdSymKind == SYM_VAR);

    /* Generate the side effects in the object expression */

    if  (expr->tnVarSym.tnVarObj)
        genSideEff(expr->tnVarSym.tnVarObj);

    /* Make sure the variable has been assigned an address */

    if  (!sym->sdVar.sdvAllocated)
        genComp->cmpAllocGlobVar(sym);

    /* Push the address of the global variable */

    genOpcode_tok(CEE_LDSFLDA, genMemberRef(sym));
}

/*****************************************************************************
 *
 *  Generate the address given by an address expression and a constant offset.
 */

void                genIL::genAddr(Tree addr, unsigned offs)
{
    genExpr(addr, true);

    if  (offs)
    {
        genIntConst(offs);
        genOpcode(CEE_ADD);
    }
}

/*****************************************************************************
 *
 *  Opcodes to load/store various types of values from various locations.
 */

static
unsigned            opcodesIndLoad[] =
{
    /* UNDEF   */  CEE_ILLEGAL,
    /* VOID    */  CEE_ILLEGAL,
    /* BOOL    */  CEE_LDIND_I1,
    /* WCHAR   */  CEE_LDIND_U2,
    /* CHAR    */  CEE_LDIND_I1,
    /* UCHAR   */  CEE_LDIND_U1,
    /* SHORT   */  CEE_LDIND_I2,
    /* USHORT  */  CEE_LDIND_U2,
    /* INT     */  CEE_LDIND_I4,
    /* UINT    */  CEE_LDIND_U4,
    /* NATINT  */  CEE_LDIND_I,
    /* NATUINT */  CEE_LDIND_I,
    /* LONG    */  CEE_LDIND_I8,
    /* ULONG   */  CEE_LDIND_I8,
    /* FLOAT   */  CEE_LDIND_R4,
    /* DOUBLE  */  CEE_LDIND_R8,
    /* LONGDBL */  CEE_LDIND_R8,
    /* REFANY  */  CEE_ILLEGAL,
    /* ARRAY   */  CEE_LDIND_REF,   // is this correct?
    /* CLASS   */  CEE_ILLEGAL,
    /* FNC     */  CEE_ILLEGAL,
    /* REF     */  CEE_LDIND_REF,
    /* PTR     */  CEE_LDIND_I4,
};

static
unsigned            opcodesIndStore[] =
{
    /* UNDEF   */  CEE_ILLEGAL,
    /* VOID    */  CEE_ILLEGAL,
    /* BOOL    */  CEE_STIND_I1,
    /* WCHAR   */  CEE_STIND_I2,
    /* CHAR    */  CEE_STIND_I1,
    /* UCHAR   */  CEE_STIND_I1,
    /* SHORT   */  CEE_STIND_I2,
    /* USHORT  */  CEE_STIND_I2,
    /* INT     */  CEE_STIND_I4,
    /* UINT    */  CEE_STIND_I4,
    /* NATINT  */  CEE_STIND_I,
    /* NATUINT */  CEE_STIND_I,
    /* LONG    */  CEE_STIND_I8,
    /* ULONG   */  CEE_STIND_I8,
    /* FLOAT   */  CEE_STIND_R4,
    /* DOUBLE  */  CEE_STIND_R8,
    /* LONGDBL */  CEE_STIND_R8,
    /* REFANY  */  CEE_ILLEGAL,
    /* ARRAY   */  CEE_STIND_REF,
    /* CLASS   */  CEE_ILLEGAL,
    /* FNC     */  CEE_ILLEGAL,
    /* REF     */  CEE_STIND_REF,
    /* PTR     */  CEE_STIND_I4,
};

static
unsigned            opcodesArrLoad[] =
{
    /* UNDEF   */  CEE_ILLEGAL,
    /* VOID    */  CEE_ILLEGAL,
    /* BOOL    */  CEE_LDELEM_I1,
    /* WCHAR   */  CEE_LDELEM_U2,
    /* CHAR    */  CEE_LDELEM_I1,
    /* UCHAR   */  CEE_LDELEM_U1,
    /* SHORT   */  CEE_LDELEM_I2,
    /* USHORT  */  CEE_LDELEM_U2,
    /* INT     */  CEE_LDELEM_I4,
    /* UINT    */  CEE_LDELEM_U4,
    /* NATINT  */  CEE_LDELEM_I,
    /* NATUINT */  CEE_LDELEM_I,
    /* LONG    */  CEE_LDELEM_I8,
    /* ULONG   */  CEE_LDELEM_I8,
    /* FLOAT   */  CEE_LDELEM_R4,
    /* DOUBLE  */  CEE_LDELEM_R8,
    /* LONGDBL */  CEE_LDELEM_R8,
    /* REFANY  */  CEE_ILLEGAL,
    /* ARRAY   */  CEE_LDELEM_REF,
    /* CLASS   */  CEE_ILLEGAL,
    /* FNC     */  CEE_ILLEGAL,
    /* REF     */  CEE_LDELEM_REF,
    /* PTR     */  CEE_LDELEM_I4,
};

static
unsigned            opcodesArrStore[] =
{
    /* UNDEF   */  CEE_ILLEGAL,
    /* VOID    */  CEE_ILLEGAL,
    /* BOOL    */  CEE_STELEM_I1,
    /* WCHAR   */  CEE_STELEM_I2,
    /* CHAR    */  CEE_STELEM_I1,
    /* UCHAR   */  CEE_STELEM_I1,
    /* SHORT   */  CEE_STELEM_I2,
    /* USHORT  */  CEE_STELEM_I2,
    /* INT     */  CEE_STELEM_I4,
    /* UINT    */  CEE_STELEM_I4,
    /* NATINT  */  CEE_STELEM_I,
    /* NATUINT */  CEE_STELEM_I,
    /* LONG    */  CEE_STELEM_I8,
    /* ULONG   */  CEE_STELEM_I8,
    /* FLOAT   */  CEE_STELEM_R4,
    /* DOUBLE  */  CEE_STELEM_R8,
    /* LONGDBL */  CEE_STELEM_R8,
    /* REFANY  */  CEE_ILLEGAL,
    /* ARRAY   */  CEE_STELEM_REF,
    /* CLASS   */  CEE_ILLEGAL,
    /* FNC     */  CEE_ILLEGAL,
    /* REF     */  CEE_STELEM_REF,
    /* PTR     */  CEE_STELEM_I4,
};

/*****************************************************************************
 *
 *  Generate the address part of an lvalue (for example, if the lvalue is a
 *  member, generate the address of the object). Returns the number of items
 *  that comprise the address (0 for non-members, 1 for members, 2 for array
 *  members).
 *
 *  Note that sometimes we need to take the address of something that doesn't
 *  have one, in which case we introduce a temp and use its address (hard to
 *  believe, but it does happen with method calls on intrinsic values). It is
 *  extremely important to keep the function genCanTakeAddr() below in synch
 *  with the kinds of expressions genAdr(expr, true) will accept.
 */

unsigned            genIL::genAdr(Tree expr, bool compute)
{
    switch (expr->tnOper)
    {
        SymDef          sym;
        TypDef          typ;

        unsigned        xcnt;

    case TN_LCL_SYM:

        if  (compute)
        {
            genLclVarAdr(expr->tnLclSym.tnLclSym);
            return  1;
        }
        break;

    case TN_VAR_SYM:

        sym = expr->tnVarSym.tnVarSym;

        assert(sym->sdSymKind      == SYM_VAR);
        assert(sym->sdVar.sdvLocal == false);
        assert(sym->sdVar.sdvConst == false);

        /* Is this a non-static class member? */

        if  (sym->sdIsMember && !sym->sdIsStatic)
        {
            Tree            addr;
            unsigned        offs;

            /* Get hold of the instance address value */

            addr = expr->tnVarSym.tnVarObj; assert(addr);

            /* Do we have an offset we need to add? */

            offs = 0;

            if  (!sym->sdIsManaged)
            {
                offs = sym->sdVar.sdvOffset;

                /* Special case: fold offset for "foo.bar.baz...." */

                while (addr->tnOper == TN_VAR_SYM &&
                       addr->tnVtyp == TYP_CLASS)
                {
                    sym = addr->tnVarSym.tnVarSym;

                    assert(sym->sdSymKind      == SYM_VAR);
                    assert(sym->sdVar.sdvLocal == false);
                    assert(sym->sdVar.sdvConst == false);

                    if  (sym->sdIsMember == false)
                        break;
                    if  (sym->sdIsStatic)
                        break;
                    if  (sym->sdIsManaged)
                        break;

                    offs += sym->sdVar.sdvOffset;

                    addr = addr->tnVarSym.tnVarObj; assert(addr);
                }
            }

            if  (addr->tnVtyp == TYP_CLASS)
            {
                assert(sym->sdIsManaged);
                assert(offs == 0);

                genExpr(addr, true);
            }
            else
            {
                /* Don't take the address of a function by mistake */

                if  (addr->tnOper == TN_ADDROF)
                {
                    Tree            oper = addr->tnOp.tnOp1;

                    if  (oper->tnOper == TN_FNC_SYM ||
                         oper->tnOper == TN_FNC_PTR)
                    {
                        UNIMPL(!"should never get here");
                    }
                }

                /* Fold the offset if we have a global variable address */

                genAddr(addr, offs);
            }

            /* Is this member of a managed class? */

            if  (sym->sdIsManaged && compute)
                genOpcode_tok(CEE_LDFLDA, genMemberRef(sym));

            return 1;
        }

        if  (sym->sdIsManaged)
        {
            assert(sym->sdIsMember);        // assume managed global vars don't exist

            /* Is this a static data member of a managed class? */

            if  (expr->tnVarSym.tnVarObj)
                genSideEff(expr->tnVarSym.tnVarObj);

            if  (compute)
            {
                genOpcode_tok(CEE_LDSFLDA, genMemberRef(sym));
                return  1;
            }
            else
                return  0;
        }

        /* Here we have an unmanaged global variable */

        if  (compute)
        {
            genGlobalAddr(expr);
            return  1;
        }

        return  0;

    case TN_IND:
        genExpr(expr->tnOp.tnOp1, true);
        return  1;

    case TN_INDEX:

        /* Get hold of the array type */

        typ = genComp->cmpDirectType(expr->tnOp.tnOp1->tnType);

        /* Generate the address of the array */

        genExpr(expr->tnOp.tnOp1, true);

        /* Generate the dimension list */

        if  (expr->tnOp.tnOp2->tnOper == TN_LIST)
        {
            Tree            xlst;

            assert(typ->tdTypeKind == TYP_ARRAY);
            assert(typ->tdIsManaged);

            xlst = expr->tnOp.tnOp2;
            xcnt = 0;

            do
            {
                assert(xlst && xlst->tnOper == TN_LIST);

                genExpr(xlst->tnOp.tnOp1, true);

                xlst = xlst->tnOp.tnOp2;

                xcnt++;
            }
            while (xlst);

            assert(xcnt > 1);
            assert(xcnt == typ->tdArr.tdaDcnt || !typ->tdArr.tdaDcnt);
        }
        else
        {
            genExpr(expr->tnOp.tnOp2, true); xcnt = 1;
        }

        /* Is this a managed or unmanaged array? */

        switch (typ->tdTypeKind)
        {
        case TYP_ARRAY:

            assert(typ->tdIsValArray == (typ->tdIsManaged && isMgdValueType(genComp->cmpActualType(typ->tdArr.tdaElem))));

            if  (typ->tdIsManaged)
            {
                if  (compute)
                {
                    if  (xcnt == 1 && !typ->tdIsGenArray)
                    {
                        genOpcode_tok(CEE_LDELEMA, genValTypeRef(typ->tdArr.tdaElem));
                    }
                    else
                    {
                        genOpcode_tok(CEE_CALL, genComp->cmpArrayEAtoken(typ, xcnt, false, true));
                        genCurStkLvl -= xcnt;
                    }

                    return  1;
                }
                else
                {
                    return  xcnt + 1;
                }
            }

            assert(xcnt == 1);
            break;

        case TYP_PTR:
            break;

        case TYP_REF:
            assert(typ->tdIsManaged == false);
            break;

        default:
            NO_WAY(!"index applied to weird address");
            break;
        }

        // ISSUE: Are we supposed to do scaling here?

        genOpcode(CEE_ADD);
        return 1;

    case TN_ERROR:
        return 1;

    default:
#ifdef DEBUG
        genComp->cmpParser->parseDispTree(expr);
#endif
        assert(!"invalid/unhandled expression in genAdr()");
    }

    return 0;
}

/*****************************************************************************
 *
 *  Return true if it's possible to directly compute the address of the given
 *  expression.
 */

inline
bool                genIL::genCanTakeAddr(Tree expr)
{
    switch (expr->tnOper)
    {
        TypDef          type;

    case TN_LCL_SYM:
    case TN_VAR_SYM:
    case TN_IND:
        return  true;

    case TN_INDEX:

        /* For now, we disallow taking the address of a Common Type System array element */

        type = expr->tnOp.tnOp1->tnType;
        if  (type->tdTypeKind && type->tdIsManaged && !type->tdIsValArray)
            return  false;
        else
            return  true;
    }

    return  false;
}

/*****************************************************************************
 *
 *  Generate the load/store part of an lvalue (the object address (if we're
 *  loading/storing a member) has already been generated).
 */

void                genIL::genRef(Tree expr, bool store)
{
    switch (expr->tnOper)
    {
        SymDef          sym;
        TypDef          type;
        var_types       vtyp;

    case TN_LCL_SYM:

        sym = expr->tnLclSym.tnLclSym;

        assert(sym->sdSymKind == SYM_VAR);
        assert(sym->sdVar.sdvLocal);

        genLclVarRef(sym, store);
        return;

    case TN_VAR_SYM:

        /* Get hold of the member symbol */

        sym  = expr->tnVarSym.tnVarSym; assert(sym->sdSymKind == SYM_VAR);

        /* Generate the Common Type System load/store opcode */

        if  (sym->sdIsMember == false ||
             sym->sdIsStatic != false)
        {
            genOpcode_tok(store ? CEE_STSFLD
                                : CEE_LDSFLD, genMemberRef(sym));
        }
        else
        {
            if  (sym->sdIsManaged)
            {
                genOpcode_tok(store ? CEE_STFLD
                                    : CEE_LDFLD, genMemberRef(sym));
            }
            else
            {
                /* Member of an unmanaged class, use an indirect load/store */

                vtyp = expr->tnVtypGet();

                switch (vtyp)
                {
                case TYP_CLASS:

                    /* Push the value type on the stack */

                    genOpcode_tok(CEE_LDOBJ, genValTypeRef(expr->tnType));
                    return;

                case TYP_ENUM:
                    vtyp = compiler::cmpEnumBaseVtp(expr->tnType);
                    break;
                }

                assert(vtyp < arraylen(opcodesIndLoad ));
                assert(vtyp < arraylen(opcodesIndStore));

                genOpcode((store ? opcodesIndStore
                                 : opcodesIndLoad)[vtyp]);
            }
        }

        return;

    case TN_INDEX:

        /* Is this a managed or unmanaged array? */

        type = genComp->cmpDirectType(expr->tnOp.tnOp1->tnType);

        if  (type->tdTypeKind == TYP_ARRAY && type->tdIsManaged)
        {
            TypDef              etyp;
            unsigned            dcnt = type->tdArr.tdaDcnt;

            /* Is this a multi-dimensional/generic managed array? */

            if  (dcnt > 1 || dcnt == 0)
            {
                /* Figure out the number of dimensions */

                if  (!dcnt)
                {
                    Tree            xlst = expr->tnOp.tnOp2;

                    do
                    {
                        assert(xlst && xlst->tnOper == TN_LIST);

                        dcnt++;

                        xlst = xlst->tnOp.tnOp2;
                    }
                    while (xlst);
                }

        ELEM_HELPER:

                genOpcode_tok(CEE_CALL, genComp->cmpArrayEAtoken(type, dcnt, store));
                genCurStkLvl -= dcnt;
                if  (store)
                    genCurStkLvl -= 2;
                return;
            }

            etyp = expr->tnType;
            vtyp = genExprVtyp(expr);

            /* Is this an array of intrinsic values? */

            if  (etyp->tdTypeKind == TYP_CLASS)
            {
                if  (etyp->tdClass.tdcIntrType == TYP_UNDEF)
                {
                    /* Call the "get element" helper to fetch the value */

                    goto ELEM_HELPER;
                }

                vtyp = (var_types)etyp->tdClass.tdcIntrType;
            }

            assert(vtyp < arraylen(opcodesArrLoad ));
            assert(vtyp < arraylen(opcodesArrStore));

            genOpcode((store ? opcodesArrStore
                             : opcodesArrLoad)[vtyp]);

            return;
        }

        /* If we have an array here it better have exactly one dimension */

        assert(type->tdTypeKind != TYP_ARRAY || type->tdArr.tdaDcnt == 1);

        // Fall through, unmanaged array same as indirection ....

    case TN_IND:

        vtyp = expr->tnVtypGet();

        if  (vtyp == TYP_ENUM)
            vtyp = compiler::cmpEnumBaseVtp(expr->tnType);

        assert(vtyp < arraylen(opcodesIndLoad ));
        assert(vtyp < arraylen(opcodesIndStore));

        if  (vtyp == TYP_CLASS)
        {
            assert(store == false);

            /* Push the astruct value on the stack */

            genOpcode_tok(CEE_LDOBJ, genValTypeRef(expr->tnType));
            return;
        }

        genOpcode((store ? opcodesIndStore
                         : opcodesIndLoad)[vtyp]);

        return;

    default:
#ifdef DEBUG
        genComp->cmpParser->parseDispTree(expr);
#endif
        assert(!"invalid/unhandled expression in genRef()");
    }
}

/*****************************************************************************
 *
 *  Generate the address of the given expression (works for any expression by
 *  introducing a temp for the value and using its address when necessary).
 */

bool                genIL::genGenAddressOf(Tree addr,
                                           bool oneUse, unsigned *tnumPtr,
                                                        TypDef   *ttypPtr)
{
    if  (genCanTakeAddr(addr))
    {
        genAdr(addr, true);

        return  false;
    }
    else
    {
        unsigned        tempNum;
        TypDef          tempType;

        /* Store the value in a temp */

        tempType = addr->tnType;
        tempNum  = genTempVarGet(tempType);

        /* Special case: "new" of a value type */

        if  (addr->tnOper == TN_NEW    &&
             addr->tnVtyp == TYP_CLASS) // && addr->tnType->tdIsIntrinsic == false) ??????????????????
        {
            /* Direct "new" into the temp we've just created */

            genLclVarAdr(tempNum);
            genCall(addr, false);
        }
        else
        {
            genExpr(addr, true);
            genLclVarRef(tempNum,  true);
        }

        /* Compute the address of the temp */

        genLclVarAdr(tempNum);

        /* Are we supposed to free up the temp right away? */

        if  (oneUse)
        {
            genTempVarRls(tempType, tempNum);
            return  false;
        }
        else
        {
            *tnumPtr = tempNum;
            *ttypPtr = tempType;

            return  true;
        }
    }
}

/*****************************************************************************
 *
 *  Generate the address of a function.
 */

void                genIL::genFncAddr(Tree expr)
{
    SymDef          fncSym;
    mdToken         fncTok;

    assert(expr->tnOper == TN_FNC_SYM || expr->tnOper == TN_FNC_PTR);
    assert(expr->tnFncSym.tnFncSym->sdSymKind == SYM_FNC);

    fncSym = expr->tnFncSym.tnFncSym;
    fncTok = genMethodRef(fncSym, false);

    if  (fncSym->sdFnc.sdfVirtual != false &&
         fncSym->sdIsStatic       == false &&
         fncSym->sdIsSealed       == false &&
         fncSym->sdAccessLevel    != ACL_PRIVATE)
    {
        genOpcode    (CEE_DUP);
        genOpcode_tok(CEE_LDVIRTFTN, fncTok);
    }
    else
        genOpcode_tok(CEE_LDFTN    , fncTok);
}

/*****************************************************************************
 *
 *  Given a binary operator, return the opcode to compute it.
 */

ILopcodes           genIL::genBinopOpcode(treeOps oper, var_types type)
{
    static
    unsigned        binopOpcodesSgn[] =
    {
        CEE_ADD,    // TN_ADD
        CEE_SUB,    // TN_SUB
        CEE_MUL,    // TN_MUL
        CEE_DIV,    // TN_DIV
        CEE_REM,    // TN_MOD

        CEE_AND,    // TN_AND
        CEE_XOR,    // TN_XOR
        CEE_OR ,    // TN_OR

        CEE_SHL,    // TN_SHL
        CEE_SHR,    // TN_SHR
        CEE_SHR_UN, // TN_SHZ

        CEE_BEQ,    // TN_EQ
        CEE_BNE_UN, // TN_NE
        CEE_BLT,    // TN_LT
        CEE_BLE,    // TN_LE
        CEE_BGE,    // TN_GE
        CEE_BGT,    // TN_GT
    };

    static
    unsigned        binopOpcodesUns[] =
    {
        CEE_ADD,    // TN_ADD
        CEE_SUB,    // TN_SUB
        CEE_MUL,    // TN_MUL
        CEE_DIV_UN, // TN_DIV
        CEE_REM_UN, // TN_MOD

        CEE_AND,    // TN_AND
        CEE_XOR,    // TN_XOR
        CEE_OR ,    // TN_OR

        CEE_SHL,    // TN_SHL
        CEE_SHR_UN, // TN_SHR
        CEE_SHR_UN, // TN_SHZ

        CEE_BEQ,    // TN_EQ
        CEE_BNE_UN, // TN_NE
        CEE_BLT_UN, // TN_LT
        CEE_BLE_UN, // TN_LE
        CEE_BGE_UN, // TN_GE
        CEE_BGT_UN, // TN_GT
    };

    if  (oper < TN_ADD || oper > TN_GT)
    {
        if  (oper > TN_ASG)
        {
            if  (oper > TN_ASG_RSZ)
                return  CEE_NOP;

            assert(TN_ASG_ADD - TN_ASG_ADD == TN_ADD - TN_ADD);
            assert(TN_ASG_SUB - TN_ASG_ADD == TN_SUB - TN_ADD);
            assert(TN_ASG_MUL - TN_ASG_ADD == TN_MUL - TN_ADD);
            assert(TN_ASG_DIV - TN_ASG_ADD == TN_DIV - TN_ADD);
            assert(TN_ASG_MOD - TN_ASG_ADD == TN_MOD - TN_ADD);
            assert(TN_ASG_AND - TN_ASG_ADD == TN_AND - TN_ADD);
            assert(TN_ASG_XOR - TN_ASG_ADD == TN_XOR - TN_ADD);
            assert(TN_ASG_OR  - TN_ASG_ADD == TN_OR  - TN_ADD);
            assert(TN_ASG_LSH - TN_ASG_ADD == TN_LSH - TN_ADD);
            assert(TN_ASG_RSH - TN_ASG_ADD == TN_RSH - TN_ADD);
            assert(TN_ASG_RSZ - TN_ASG_ADD == TN_RSZ - TN_ADD);

            assert(oper >= TN_ASG_ADD);
            assert(oper <= TN_ASG_RSZ);

            oper = (treeOps)(oper - (TN_ASG_ADD - TN_ADD));
        }
        else
            return  CEE_NOP;
    }

    assert(oper >= TN_ADD);
    assert(oper <= TN_GT);

    return  (ILopcodes)(varTypeIsUnsigned(type) ? binopOpcodesUns[oper - TN_ADD]
                                                : binopOpcodesSgn[oper - TN_ADD]);
}

/*****************************************************************************
 *
 *  The following can be used when one needs to make a copy of some address.
 */

struct   genCloneDsc
{
    Tree            gcdAddr;        // address or NULL if temp is being used
    unsigned        gcdOffs;        // to be added to address
    unsigned        gcdTemp;        // temp number (when gcdAddr==NULL)
    TypDef          gcdType;        // type of temp
    bool            gcdGlob;        // address of a global variable?
};

void                genIL::genCloneAddrBeg(genCloneDsc *clone, Tree addr, unsigned offs)
{
    unsigned        temp;

    /* Save the offset */

    clone->gcdOffs = offs;

    /* Do we have an address of a global variable or a simple pointer value? */

    if  (!offs)
    {
        if  (addr->tnOper == TN_LCL_SYM)
        {
            /* Simple pointer value */

            clone->gcdAddr = addr;
            clone->gcdGlob = false;

            genExpr(addr, true);
            return;
        }

        if  (addr->tnOper == TN_ADDROF)
        {
            Tree            base = addr->tnOp.tnOp1;

            if  (base->tnOper == TN_VAR_SYM)
            {
                SymDef          sym;

                /* Only static members / globals are acceptable */

                sym = base->tnVarSym.tnVarSym; assert(sym->sdSymKind == SYM_VAR);

                if  (sym->sdIsMember == false ||
                     sym->sdIsStatic != false)
                {
                    /* Address of a global variable */

                    clone->gcdAddr = base;
                    clone->gcdGlob = true;

                    assert(offs == 0);

                    genGlobalAddr(base);
                    return;
                }
            }
        }
    }

    /* Oh well, let's use a temp */

    clone->gcdAddr = NULL;
    clone->gcdTemp = temp = genTempVarGet(addr->tnType);
    clone->gcdType = addr->tnType;

    /* Store the address in the temp and reload it */

    genExpr     (addr,  true);

    if  (offs)
    {
        genIntConst(offs);
        genOpcode(CEE_ADD);
    }

    genLclVarRef(temp,  true);
    genLclVarRef(temp, false);
}

void                genIL::genCloneAddrUse(genCloneDsc *clone)
{
    if  (clone->gcdAddr)
    {
        assert(clone->gcdOffs == 0);

        if  (clone->gcdGlob)
        {
            /* Address of a global variable */

            genGlobalAddr(clone->gcdAddr);
        }
        else
        {
            /* Simple pointer value */

            genExpr(clone->gcdAddr, true);
        }
    }
    else
    {
        /* Temp variable */

        genLclVarRef(clone->gcdTemp, false);
    }
}

void                genIL::genCloneAddrEnd(genCloneDsc *clone)
{
    if  (!clone->gcdAddr)
        genTempVarRls(clone->gcdType, clone->gcdTemp);
}

/*****************************************************************************
 *
 *  Load the value of a bitfield.
 */

void                genIL::genBitFieldLd(Tree expr, bool didAddr, bool valUsed)
{
    Tree            addr;
    unsigned        offs;
    var_types       btyp;
    unsigned        bpos;
    unsigned        blen;

    /* Get hold of the address and offset */

    assert(expr->tnOper == TN_BFM_SYM);

    addr = expr->tnBitFld.tnBFinst;
    offs = expr->tnBitFld.tnBFoffs;

    if  (!valUsed)
    {
        assert(didAddr == false);

        /* Go figure ... */

        genSideEff(addr);
        return;
    }

    /* How big is the bitfield and what is its type? */

    btyp = genComp->cmpActualVtyp(expr->tnBitFld.tnBFmsym->sdType);
    bpos = expr->tnBitFld.tnBFpos;
    blen = expr->tnBitFld.tnBFlen;

    /* Compute the address of the bitfield, unless caller already did that */

    if  (!didAddr)
        genAddr(addr, offs);

    /* Load the bitfield cell and shift/mask it as appropriate */

    assert(btyp < arraylen(opcodesIndLoad)); genOpcode(opcodesIndLoad[btyp]);

    /* Is the bitfield unsigned? */

    if  (varTypeIsUnsigned(btyp))
    {
        assert(btyp != TYP_LONG);

        /* Unsigned bitfield - shift if necessary and then mask */

        if  (bpos)
        {
            genIntConst(bpos);
            genOpcode(CEE_SHR_UN);
        }

        if  (btyp == TYP_ULONG)
            genLngConst(((__uint64)1 << blen) - 1);
        else
            genIntConst(((unsigned)1 << blen) - 1);

        genOpcode(CEE_AND);
    }
    else
    {
        unsigned    size;
        unsigned    diff;

        /* Signed bitfield - shift left and then right */

        assert(btyp != TYP_ULONG);

        /* Compute how far left we need to shift */

        size = (btyp == TYP_LONG) ? 64 : 32;
        diff = size - (bpos + blen); assert((int)diff >= 0);

        if  (diff)
        {
            genIntConst(diff);
            genOpcode(CEE_SHL);
        }

        genIntConst(bpos + diff);
        genOpcode(CEE_SHR);
    }
}

/*****************************************************************************
 *
 *  Compute a new bitfield value and store it. In the simplest case, 'newx' is
 *  the new value to be assigned. If 'newx' is NULL, we either have an inc/dec
 *  operator (in which case 'delta' and 'post' yield the value and ordering of
 *  the increment/decrement) or 'asgx' specifies an assignment operator (which
 *  must be TN_ASG_OR or TN_ASG_AND).
 */

void                genIL::genBitFieldSt(Tree   dstx,
                                         Tree   newx,
                                         Tree   asgx,
                                         int    delta,
                                         bool   post, bool valUsed)
{
    Tree            addr;
    unsigned        offs;
    var_types       btyp;
    unsigned        bpos;
    unsigned        blen;

    bool            ncns;

    __uint64        mask;
    __uint64        lval;
    __uint32        ival;

    genCloneDsc     clone;

    bool            nilCns  = false;
    bool            logCns  = false;

    bool            tempUse = false;
    unsigned        tempNum;

    /* Get hold of the address and offset */

    assert(dstx->tnOper == TN_BFM_SYM);

    addr = dstx->tnBitFld.tnBFinst;
    offs = dstx->tnBitFld.tnBFoffs;

    /* How big is the bitfield and what is its type? */

    btyp = genComp->cmpActualVtyp(dstx->tnBitFld.tnBFmsym->sdType);
    bpos = dstx->tnBitFld.tnBFpos;
    blen = dstx->tnBitFld.tnBFlen;
    mask = ((__uint64)1 << blen) - 1;

    /* We'll need to duplicate the address */

    genCloneAddrBeg(&clone, addr, offs);

    /* Is this an assignment or increment/decrement operator? */

    if  (newx == NULL)
    {
        treeOps         oper;

        /* Check for a special case: "|= icon" or "&= icon" */

        if  (asgx)
        {
            /* This is an assignment operator */

            assert(post);

            /* Get hold of the operator and the RHS */

            oper = asgx->tnOperGet();
            newx = asgx->tnOp.tnOp2;

            if  (oper == TN_ASG_OR || oper == TN_ASG_AND)
            {
                if  (newx->tnOper == TN_CNS_INT ||
                     newx->tnOper == TN_CNS_LNG)
                {
                    logCns = true;
                    goto ASGOP;
                }
            }
        }

        /* Load the old value of the bitfield */

        genCloneAddrUse(&clone);
        genBitFieldLd(dstx, true, true);

    ASGOP:

        /* For post-operators whose result value is used, save the old value */

        if  (post && valUsed)
        {
            tempNum = genTempVarGet(dstx->tnType);
            tempUse = true;

            genLclVarRef(tempNum,  true);
            genLclVarRef(tempNum, false);
        }

        /* Compute the new value */

        if  (asgx)
        {
            /* This is an assignment operator */

            assert((asgx->tnOperKind() & TNK_ASGOP) && oper != TN_ASG);
            assert(asgx->tnOp.tnOp1 == dstx);

            /* Special case: "|= icon" or "&= icon" */

            if  (logCns)
            {
                switch (newx->tnOper)
                {
                case TN_CNS_INT:

                    ival = (newx->tnIntCon.tnIconVal & (__uint32)mask) << bpos;

                    if  (oper == TN_ASG_OR)
                    {
                        genIntConst(ival);
                        goto COMBINE;
                    }
                    else
                    {
                        genCloneAddrUse(&clone);
                        assert(btyp < arraylen(opcodesIndLoad));
                        genOpcode(opcodesIndLoad[btyp]);

                        genIntConst(ival | ~((__uint32)mask << bpos));
                        genOpcode(CEE_AND);
                        goto STORE;
                    }

                case TN_CNS_LNG:

                    lval = (newx->tnLngCon.tnLconVal & (__uint64)mask) << bpos;

                    if  (oper == TN_ASG_OR)
                    {
                        genLngConst(lval);
                        goto COMBINE;
                    }
                    else
                    {
                        genCloneAddrUse(&clone);
                        assert(btyp < arraylen(opcodesIndLoad));
                        genOpcode(opcodesIndLoad[btyp]);

                        genLngConst(lval | ~((__uint64)mask << bpos));
                        genOpcode(CEE_AND);
                        goto STORE;
                    }

                default:
                    NO_WAY(!"no way");
                }
            }

            /* Compute the new value */

            genExpr(newx, true);
            genOpcode(genBinopOpcode(oper, btyp));
        }
        else
        {
            /* This is an increment/decrement operator */

            if  (delta > 0)
            {
                genAnyConst( delta, btyp);
                genOpcode(CEE_ADD);
            }
            else
            {
                genAnyConst(-delta, btyp);
                genOpcode(CEE_SUB);
            }
        }

        /* Mask off any extra bits from the result */

        if  (btyp == TYP_LONG || btyp == TYP_ULONG)
            genLngConst((__uint64)mask);
        else
            genIntConst((__uint32)mask);

        genOpcode(CEE_AND);

        /* Go store the new value in the bitfield */

        ncns = false;
        goto SHIFT;
    }

    /* Evaluate the new value and mask it off */

    if  (btyp == TYP_LONG || btyp == TYP_ULONG)
    {
        if  (newx->tnOper == TN_CNS_LNG)
        {
            ncns = true;

            /* Don't bother OR'ing zeros */

            lval = (__uint64)mask & newx->tnLngCon.tnLconVal;

            if  (lval)
                genLngConst(lval << bpos);
            else
                nilCns = true;

            goto COMBINE;
        }
        else
        {
            ncns = false;

            genExpr(newx, true);
            genLngConst((__uint64)mask);
            genOpcode(CEE_AND);
        }
    }
    else
    {
        if  (newx->tnOper == TN_CNS_INT)
        {
            ncns = true;

            /* Don't bother OR'ing zeros */

            ival = (__uint32)mask & newx->tnIntCon.tnIconVal;

            if  (ival)
                genIntConst(ival << bpos);
            else
                nilCns = true;

            goto COMBINE;
        }
        else
        {
            ncns = false;

            genExpr(newx, true);
            genIntConst((__uint32)mask);
            genOpcode(CEE_AND);
        }
    }

    /* Is the new value used and is it an unsigned non-constant? */

    if  (valUsed && !ncns && varTypeIsUnsigned(btyp))
    {
        /* Store the new (masked) value in a temp */

        tempUse = true;
        tempNum = genTempVarGet(dstx->tnType);

        genLclVarRef(tempNum,  true);
        genLclVarRef(tempNum, false);
    }

SHIFT:

    /* Shift the new value if the bit position is non-zero */

    if  (bpos)
    {
        genIntConst(bpos);
        genOpcode(CEE_SHL);
    }

COMBINE:

    /* Load and mask off the old value of the bitfield */

    genCloneAddrUse(&clone);

    assert(btyp < arraylen(opcodesIndLoad)); genOpcode(opcodesIndLoad[btyp]);

    if  (!logCns)
    {
        if  (btyp == TYP_LONG || btyp == TYP_ULONG)
            genLngConst(~((((__uint64)1 << blen) - 1) << bpos));
        else
            genIntConst(~((((unsigned)1 << blen) - 1) << bpos));

        genOpcode(CEE_AND);
    }

    /* Place the new bits in the cell value */

    if  (!nilCns)
        genOpcode(CEE_OR);

STORE:

    /* Store the new cell value in the class */

    assert(btyp < arraylen(opcodesIndStore)); genOpcode(opcodesIndStore[btyp]);

    /* Load the new value if necessary */

    if  (valUsed)
    {
        if  (ncns)
        {
            /* The new value is a constant */

            // UNDONE: for signed bitfields we have to bash the upper bits!

            if  (newx->tnOper == TN_CNS_LNG)
                genLngConst(lval);
            else
                genIntConst(ival);
        }
        else
        {
            /* Either load the saved value or reload the bitfield */

            if  (tempUse)
            {
                genLclVarRef(tempNum, false);
                genTempVarRls(dstx->tnType, tempNum);
            }
            else
            {
                genCloneAddrUse(&clone);

                genBitFieldLd(dstx, true, true);
            }
        }
    }

    genCloneAddrEnd(&clone);
}

/*****************************************************************************
 *
 *  Use the following to figure out the opcode needed to convert from one
 *  arithmetic type to another.
 */

unsigned            genIL::genConvOpcode(var_types src, var_types dst)
{
    unsigned        opcode;

    const
    unsigned        opcodesConvMin = TYP_BOOL;
    const
    unsigned        opcodesConvMax = TYP_LONGDBL;

    static
    unsigned        opcodesConv[][opcodesConvMax - opcodesConvMin + 1] =
    {
    // from       to BOOL           WCHAR          CHAR           UCHAR          SHORT          USHORT         INT            UINT           NATINT         NATUINT        LONG           ULONG           FLOAT          DOUBLE         LONGDBL
    /* BOOL    */  { CEE_NOP      , CEE_CONV_U2  , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* WCHAR   */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_U8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* CHAR    */  { CEE_ILLEGAL  , CEE_NOP      , CEE_NOP      , CEE_CONV_U1  , CEE_CONV_I2  , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* UCHAR   */  { CEE_ILLEGAL  , CEE_NOP      , CEE_CONV_I1  , CEE_NOP      , CEE_CONV_I2  , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_U8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* SHORT   */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* USHORT  */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_NOP      , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_U8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* INT     */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* UINT    */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_NOP      , CEE_NOP      , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_U8  , CEE_CONV_U8  , CEE_CONV_R_UN, CEE_CONV_R_UN, CEE_CONV_R_UN},
    /* NATINT  */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_NOP      , CEE_NOP      , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* NATUINT */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_NOP      , CEE_NOP      , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R_UN, CEE_CONV_R_UN, CEE_CONV_R_UN},
    /* LONG    */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_CONV_I   , CEE_CONV_U   , CEE_NOP      , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_CONV_R8  },
    /* ULONG   */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_NOP      , CEE_CONV_R_UN, CEE_CONV_R_UN, CEE_CONV_R_UN},
    /* FLOAT   */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_NOP      , CEE_CONV_R8  , CEE_CONV_R8  },
    /* DOUBLE  */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_NOP      , CEE_NOP      },
    /* LONGDBL */  { CEE_ILLEGAL  , CEE_CONV_U2  , CEE_CONV_I1  , CEE_CONV_U1  , CEE_CONV_I2  , CEE_CONV_U2  , CEE_CONV_I4  , CEE_CONV_U4  , CEE_CONV_I   , CEE_CONV_U   , CEE_CONV_I8  , CEE_CONV_U8  , CEE_CONV_R4  , CEE_CONV_R8  , CEE_NOP      },
    };

    assert(src != TYP_ENUM && "enums should never make it here");
    assert(dst != TYP_ENUM && "enums should never make it here");

    assert(src >= opcodesConvMin);
    assert(src <= opcodesConvMax);

    assert(dst >= opcodesConvMin);
    assert(dst <= opcodesConvMax);

    opcode = opcodesConv[src - opcodesConvMin][dst - opcodesConvMin];

#ifdef DEBUG
    if  (opcode == CEE_ILLEGAL)
    {
        printf("Don't have an opcode for conversion of '%s' to '%s'.\n", genStab->stIntrinsicTypeName(src),
                                                                         genStab->stIntrinsicTypeName(dst));
    }
#endif

    assert(opcode != CEE_ILLEGAL);

    return opcode;
}

/*****************************************************************************
 *
 *  Generate code to cast the given expression to the specified type.
 */

void                genIL::genCast(Tree expr, TypDef type, unsigned flags)
{
    unsigned        opcode;

    TypDef          srcTyp = expr->tnType;
    var_types       srcVtp = expr->tnVtypGet();
    var_types       dstVtp = type->tdTypeKindGet();

AGAIN:

    /* Is this an arithmetic conversion? */

    if  (varTypeIsArithmetic(srcVtp) &&
         varTypeIsArithmetic(dstVtp))
    {

    ARITH:

        genExpr(expr, true);

        opcode = genConvOpcode(srcVtp, dstVtp);

        if  (opcode == CEE_count)
        {
            /* This is a special case: we have to convert to 'int' first */

            genOpcode(genConvOpcode(srcVtp, TYP_INT));

            opcode =  genConvOpcode(TYP_INT, dstVtp);

            assert(opcode != CEE_NOP);
            assert(opcode != CEE_count);
            assert(opcode != CEE_ILLEGAL);
        }
        else if ((srcVtp == TYP_LONG || srcVtp == TYP_ULONG) && dstVtp < TYP_INT)
        {
            genOpcode(CEE_CONV_I4);
        }
        else if (opcode == CEE_CONV_R_UN)
        {
            genOpcode(opcode);

            opcode = (dstVtp == TYP_FLOAT) ? CEE_CONV_R4
                                           : CEE_CONV_R8;
        }

        if  (opcode != CEE_NOP)
            genOpcode(opcode);

        return;
    }

    switch (dstVtp)
    {
    case TYP_WCHAR:
        assert(varTypeIsArithmetic(srcVtp) || srcVtp == TYP_WCHAR || srcVtp == TYP_BOOL);
        goto ARITH;

    case TYP_CHAR:
    case TYP_UCHAR:
    case TYP_SHORT:
    case TYP_USHORT:
    case TYP_INT:
    case TYP_UINT:
    case TYP_NATINT:
    case TYP_NATUINT:
    case TYP_LONG:
    case TYP_ULONG:
    case TYP_FLOAT:
    case TYP_DOUBLE:

        if  (srcVtp == TYP_REF)
        {
            assert(expr->tnOper == TN_CNS_STR);
            genExpr(expr, true);
            return;
        }

        if  (srcVtp == TYP_PTR && genComp->cmpConfig.ccTgt64bit)
        {
//          printf("Possible bad cast at %s(%u)\n", genComp->cmpErrorComp->sdComp.sdcSrcFile,
//                                                  genComp->cmpErrorTree->tnLineNo);
            srcVtp =  TYP_NATUINT;
        }

        assert(varTypeIsArithmetic(srcVtp) || srcVtp == TYP_WCHAR || srcVtp == TYP_BOOL);
        goto ARITH;

    case TYP_REF:

        type = type->tdRef.tdrBase;

    case TYP_ARRAY:

        assert(dstVtp == TYP_REF ||
               dstVtp == TYP_ARRAY);

        assert(srcVtp == TYP_REF ||
               srcVtp == TYP_ARRAY);

        genExpr(expr, true);

        if  (flags & TNF_CHK_CAST)
        {
            if  (type->tdIsGenArg)
            {
                printf("WARNING: cast to generic type argument '%s' will not be checked\n", genStab->stTypeName(type, NULL));
            }
            else
                genOpcode_tok(CEE_CASTCLASS, genTypeRef(type));
        }

#if 0

        if  (flags & TNF_CTX_CAST)
        {
            unsigned        srcCtx = 0;
            unsigned        dstCtx = 0;

            if  (srcVtp == TYP_REF)
            {
                srcTyp = srcTyp->tdRef.tdrBase;
                if  (srcTyp->tdTypeKind == TYP_CLASS)
                    srcCtx = srcTyp->tdClass.tdcContext;
            }

            if  (type->tdTypeKindGet() == TYP_CLASS)
                dstCtx = type->tdClass.tdcContext;

//          printf("Src type [%u] '%s'\n", srcCtx, genStab->stTypeName(expr->tnType, NULL));
//          printf("Dst type [%u] '%s'\n", dstCtx, genStab->stTypeName(type        , NULL));

            assert((srcCtx == 2) != (dstCtx == 2));

            genOpcode(srcCtx ? CEE_TOPROXY : CEE_FROMPROXY);
        }

#endif

        return;

    case TYP_PTR:

        /* Presumably a cast that doesn't really change anything [ISSUE: is this correct?] */

        genExpr(expr, true);
        return;

    case TYP_ENUM:

        dstVtp = compiler::cmpEnumBaseVtp(type);
        goto AGAIN;

    case TYP_REFANY:

        assert(expr->tnOper == TN_ADDROF);

        genExpr(expr, true);

        genOpcode_tok(CEE_MKREFANY, genTypeRef(expr->tnOp.tnOp1->tnType));

        return;

    case TYP_BOOL:

        /* Casts to bool should never be encountered here */

        NO_WAY(!"unexpected cast to bool found in codegen");

    default:
#ifdef DEBUG
        genComp->cmpParser->parseDispTree(expr);
        printf("The above expression is, alas, being cast to '%s'\n", genStab->stTypeName(type, NULL));
#endif
        assert(!"invalid cast type");
    }
}

/*****************************************************************************
 *
 *  Add the given delta to an operand of the specified type.
 */

void                genIL::genIncDecByExpr(int delta, TypDef type)
{
    bool            convVal = false;
    var_types       valType = type->tdTypeKindGet();

    /* See what type we're dealing with */

    switch (valType)
    {
    case TYP_PTR:
    case TYP_REF:

        /* Scale the delta value by the size of the pointed-to type */

        delta  *= genComp->cmpGetTypeSize(type->tdRef.tdrBase);

#pragma message("forcing 64-bit increment value")
        valType = genComp->cmpConfig.ccTgt64bit ? TYP_LONG : TYP_INT;
        break;

    case TYP_CHAR:
    case TYP_UCHAR:
    case TYP_WCHAR:
    case TYP_SHORT:
    case TYP_USHORT:

        /* We'll have to shrink the new value to maintain precision */

        convVal = true;
        break;
    }

    /* Compute the new value by adding/subtracting the delta */

    if  (delta > 0)
    {
        genAnyConst( delta, valType);
        genOpcode(CEE_ADD);
    }
    else
    {
        genAnyConst(-delta, valType);
        genOpcode(CEE_SUB);
    }

    /* Convert the value if necessary */

    if  (convVal)
        genOpcodeNN(genConvOpcode(TYP_INT, valType));
}

/*****************************************************************************
 *
 *  Generate an assignment operator (such as "+=") or a pre/post increment or
 *  decrement where the target is a Common Type System array element. The arguments should be
 *  passed in as follows:
 *
 *      op=
 *
 *              expr     ....   the op= node itself
 *              delta    ....   ignored
 *              post     ....   false
 *              asgop    ....   true
 *
 *      ++/--
 *
 *              expr     ....   the target
 *              delta    ....   the amount to be added
 *              post     ....   true if the operator is post-inc/dec
 *              asgop    ....   false
 */

void                genIL::genCTSindexAsgOp(Tree    expr,
                                            int     delta,
                                            bool    post,
                                            bool    asgop, bool valUsed)
{
    TypDef          dstType;
    var_types       dstVtyp;

    Tree            dstExpr;
    Tree            srcExpr;

    Tree            addrExp;
    Tree            indxExp;

    unsigned        tempNum;
    unsigned        indxTmp;
    unsigned        addrTmp;

    if  (asgop)
    {
        dstExpr = expr->tnOp.tnOp1;
        srcExpr = expr->tnOp.tnOp2;
    }
    else
    {
        dstExpr = expr;
        srcExpr = NULL;
    }

    dstType = dstExpr->tnType;
    dstVtyp = dstExpr->tnVtypGet();

    assert(dstExpr->tnOper == TN_INDEX);
    assert(dstExpr->tnOp.tnOp1->tnVtyp == TYP_ARRAY);
    assert(dstExpr->tnOp.tnOp1->tnType->tdIsManaged);

    /* Get hold of the address/index expressions and generate them */

    addrExp = dstExpr->tnOp.tnOp1; genExpr(addrExp, true);
    indxExp = dstExpr->tnOp.tnOp2; genExpr(indxExp, true);

    /* Grab temps for the address and index and save both */

    addrTmp = genTempVarGet(addrExp->tnType);
    indxTmp = genTempVarGet(indxExp->tnType);

    genLclVarRef(indxTmp, true);
    genOpcode(CEE_DUP);
    genLclVarRef(addrTmp, true);

    /* Reload the index, leaving [addr,index] on the stack */

    genLclVarRef(indxTmp, false);

    /* Reload the addr and index and fetch the old value */

    genLclVarRef(addrTmp, false);
    genLclVarRef(indxTmp, false);
    genRef(dstExpr, false);

    /* Both of the temps can be freed up now */

    genTempVarRls(indxExp->tnType, indxTmp);
    genTempVarRls(addrExp->tnType, addrTmp);

    /* Do we need the result of the expression? */

    if  (valUsed)
    {
        /* Yes, grab a temp for it then */

        tempNum = genTempVarGet(dstType);

        /* Save the old value if necessary */

        if  (post)
        {
            genOpcode(CEE_DUP);
            genLclVarRef(tempNum, true);
        }
    }

    /* Compute the new value */

    if  (asgop)
    {
        assert(post == false);

        /* Compute the RHS value */

        genExpr(srcExpr, true);

        /* Generate the opcode to perform the operation */

        genOpcode(genBinopOpcode(expr->tnOperGet(), expr->tnVtypGet()));

        /* If the value is smaller than int, convert it before assigning */

        if  (dstVtyp < TYP_INT && dstVtyp != TYP_BOOL)  // is this right?????
            genOpcode(genConvOpcode(TYP_INT, dstVtyp));
    }
    else
    {
        genIncDecByExpr(delta, dstType);
    }

    if  (valUsed)
    {
        /* Save the new value if necessary */

        if  (!post)
        {
            genOpcode(CEE_DUP);
            genLclVarRef(tempNum, true);
        }

        /* Store the new value in the target */

        genRef(dstExpr, true);

        /* Reload the saved value and free up the temp */

        genLclVarRef(tempNum, false);
        genTempVarRls(dstType, tempNum);
    }
    else
    {
        /* Store the new value in the target */

        genRef(dstExpr, true);
    }
}

/*****************************************************************************
 *
 *  Generate code for an ++ / -- operator.
 */

void                genIL::genIncDec(Tree expr, int delta, bool post, bool valUsed)
{
    unsigned        addrCnt;
    unsigned        tempNum;

#ifdef  DEBUG
    unsigned        stkLvl = genCurStkLvl;
#endif

    /* Bitfield operations are handled elsewhere */

    if  (expr->tnOper == TN_BFM_SYM)
    {
        genBitFieldSt(expr, NULL, NULL, delta, post, valUsed);
        return;
    }

    /* Generate the object pointer value, if one is needed */

    addrCnt = genAdr(expr);

    if  (addrCnt)
    {
        if  (addrCnt == 1)
        {
            /* There is an object address: duplicate it */

            genOpcode(CEE_DUP);
        }
        else
        {
            Tree            addrExp;
            Tree            indxExp;

            unsigned        indxTmp;
            unsigned        addrTmp;

            assert(addrCnt == 2);
            assert(expr->tnOper == TN_INDEX);

            /* We have a Common Type System array element, save address and index */

            addrExp = expr->tnOp.tnOp1;
            indxExp = expr->tnOp.tnOp2;

            /* Grab temps for the address and index and save both */

            addrTmp = genTempVarGet(addrExp->tnType);
            indxTmp = genTempVarGet(indxExp->tnType);

            genLclVarRef(indxTmp, true);
            genOpcode(CEE_DUP);
            genLclVarRef(addrTmp, true);

            /* Reload the index, leaving [addr,index] on the stack */

            genLclVarRef(indxTmp, false);

            /* Reload the addr and index and fetch the old value */

            genLclVarRef(addrTmp, false);
            genLclVarRef(indxTmp, false);
            genRef(expr, false);

            /* Both of the temps can be freed up now */

            genTempVarRls(indxExp->tnType, indxTmp);
            genTempVarRls(addrExp->tnType, addrTmp);

            /* Do we need the result of the expression? */

            if  (valUsed)
            {
                tempNum = genTempVarGet(expr->tnType);

                /* Save the old value if necessary */

                if  (post != false)
                {
                    genOpcode(CEE_DUP);
                    genLclVarRef(tempNum, true);
                }

                /* Compute the new value */

                genIncDecByExpr(delta, expr->tnType);

                /* Save the new value if necessary */

                if  (post == false)
                {
                    genOpcode(CEE_DUP);
                    genLclVarRef(tempNum, true);
                }

                /* Store the new value in the target */

                genRef(expr, true);

                /* Reload the saved value and free up the temp */

                genLclVarRef(tempNum, false);
                genTempVarRls(expr->tnType, tempNum);
            }
            else
            {
                /* Compute the new value */

                genIncDecByExpr(delta, expr->tnType);

                /* Store the new value in the target */

                genRef(expr, true);
            }

            return;
        }
    }

    /* Load the old value */

    genRef(expr, false);

    /* If the result of is used, we'll need a temp */

    if  (valUsed)
    {
        /* Grab a temp of the right type */

        tempNum = genTempVarGet(expr->tnType);

        if  (post)
        {
            /* Save the old value in the temp */

            genLclVarRef(tempNum, true);

            /* Reload the old value so we can inc/dec it */

            genLclVarRef(tempNum, false);
        }
    }

    genIncDecByExpr(delta, expr->tnType);

    /* Is this a pre-inc/dec or post-inc/dec operator? */

    if  (post)
    {
        /* Store the new value in the lvalue */

        genRef(expr, true);
    }
    else
    {
        if  (valUsed)
        {
            /* Save a copy of the new value in the temp */

            genOpcode(CEE_DUP);
            genLclVarRef(tempNum, true);
        }

        /* Store the new value in the lvalue */

        genRef(expr, true);
    }

    /* Load the old/new value from the temp where we saved it */

    if  (valUsed)
    {
        genLclVarRef(tempNum, false);

        /* If we grabbed a temp, free it now */

        genTempVarRls(expr->tnType, tempNum);
    }

    assert(genCurStkLvl == stkLvl + (int)valUsed);
}

/*****************************************************************************
 *
 *  Generate code for an assignment operator (e.g. "+=").
 */

void                genIL::genAsgOper(Tree expr, bool valUsed)
{
    Tree            op1     = expr->tnOp.tnOp1;
    Tree            op2     = expr->tnOp.tnOp2;

    var_types       dstType =  op1->tnVtypGet();

    bool            haveAddr;
    unsigned        tempNum;

    /* Check for a bitfield target */

    if  (op1->tnOper == TN_BFM_SYM)
    {
        genBitFieldSt(op1, NULL, expr, 0, true, valUsed);
        return;
    }

    /* We'll need to refer to the target address twice or thrice */

    switch (op1->tnOper)
    {
        unsigned        checkCnt;

        SymDef          sym;

    case TN_LCL_SYM:

    SREF:

        /* Load the old value of the destination */

        genExpr(op1, true);

        haveAddr = false;
        break;

    case TN_VAR_SYM:

        sym = op1->tnVarSym.tnVarSym; assert(sym->sdSymKind == SYM_VAR);

        /* Is this a non-static class member? */

        if  (!sym->sdIsMember)
            goto SREF;
        if  (sym->sdIsStatic)
            goto SREF;

        /* For managed members we use ldfld/stfld */

        if  (sym->sdIsManaged)
        {
            genExpr(op1->tnVarSym.tnVarObj, true);
            goto SAVE;
        }

        // Fall through ...

    case TN_IND:

    ADDR:

        checkCnt = genAdr(op1, true); assert(checkCnt == 1);

    SAVE:

        haveAddr = true;

        /* Make a copy of the address */

        genOpcode(CEE_DUP);

        /* Load the old value of the destination */

        genRef(op1, false);
        break;

    case TN_INDEX:

        /* Is this a managed or unmanaged array? */

        if  (op1->tnOp.tnOp1->tnVtyp == TYP_ARRAY &&
             op1->tnOp.tnOp1->tnType->tdIsManaged)
        {
            genCTSindexAsgOp(expr, 0, false, true, valUsed);
            return;
        }

        goto ADDR;

    default:
        NO_WAY(!"unexpected asgop dest");
    }

    /* Compute the RHS value */

    genExpr(op2, true);

    /* Generate the opcode to perform the operation */

    genOpcode(genBinopOpcode(expr->tnOperGet(), genExprVtyp(expr)));

    /* If the value is smaller than int, convert it before assigning */

    if  (dstType < TYP_INT && dstType != TYP_BOOL)  // is this right?????
        genOpcode(genConvOpcode(TYP_INT, dstType));

    /* Did we have an indirection or a simple local variable destination? */

    if  (haveAddr)
    {
        if  (valUsed)
        {
            /* Save a copy of the new value in a temp */

            tempNum = genTempVarGet(expr->tnType);

            genOpcode(CEE_DUP);
            genLclVarRef(tempNum, true);
        }

        /* Store the new value in the target */

        genRef(op1, true);

        /* Is the result of the assignment used? */

        if  (valUsed)
        {
            /* Load the saved value and free up the temp */

            genLclVarRef(tempNum, false);
            genTempVarRls(expr->tnType, tempNum);
        }
    }
    else
    {
        genRef(op1, true);

        if  (valUsed)
            genRef(op1, false);
    }
}

/*****************************************************************************
 *
 *  Generate any side effects in the given expression.
 */

void                genIL::genSideEff(Tree expr)
{
    treeOps         oper;
    unsigned        kind;

AGAIN:

    assert(expr);
#if!MGDDATA
    assert((int)expr != 0xCCCCCCCC && (int)expr != 0xDDDDDDDD);
#endif
    assert(expr->tnType && expr->tnType->tdTypeKind == expr->tnVtyp);

    /* Classify the root node */

    oper = expr->tnOperGet ();
    kind = expr->tnOperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (TNK_CONST|TNK_LEAF))
        return;

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        /* Is this an assignment or a potential exception? */

        if  ((kind & TNK_ASGOP) || expr->tnOperMayThrow())
        {
            genExpr(expr, false);
            return;
        }

        /* Is there a second operand? */

        if  (expr->tnOp.tnOp2)
        {
            if  (expr->tnOp.tnOp1)
                genSideEff(expr->tnOp.tnOp1);

            expr = expr->tnOp.tnOp2;
            goto AGAIN;
        }

        expr = expr->tnOp.tnOp1;
        if  (expr)
            goto AGAIN;

        return;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case TN_VAR_SYM:
        expr = expr->tnVarSym.tnVarObj;
        if  (expr)
            goto AGAIN;
        return;

    case TN_FNC_SYM:
        genCall(expr, false);
        return;
    }
}

/*****************************************************************************
 *
 *  Generate MSIL for the bounds of an array being allocated.
 */

unsigned            genIL::genArrBounds(TypDef type, OUT TypDef REF elemRef)
{
    TypDef          elem;
    unsigned        dcnt;
    DimDef          dims;

    assert(type->tdTypeKind == TYP_ARRAY && type->tdIsManaged);

    elem = genComp->cmpDirectType(type->tdArr.tdaElem);

    /* Recursively process the element if it's also an array type */

    if  (elem->tdTypeKind == TYP_ARRAY && elem->tdIsManaged)
    {
        dcnt    = genArrBounds(elem, elemRef);
    }
    else
    {
        dcnt    = 0;
        elemRef = elem;
    }

    dims = type->tdArr.tdaDims; assert(dims);

    do
    {
        if  (dims->ddNoDim)
        {
            genIntConst(0);
        }
        else
        {
            assert(dims->ddDimBound);

            if  (dims->ddIsConst)
                genIntConst(dims->ddSize);
            else
                genExpr(dims->ddLoTree, true);

            if  (dims->ddHiTree)
                genExpr(dims->ddHiTree, true);
        }

        dcnt++;

        dims = dims->ddNext;
    }
    while (dims);

    return  dcnt;
}

/*****************************************************************************
 *
 *  Generate MSIL for a "new" expression. If "dstx" is non-NULL the result of
 *  the expression is to be assigned to the given destination.
 */

void                genIL::genNewExpr(Tree expr, bool valUsed, Tree dstx)
{
    TypDef          type;
    var_types       otyp;
    var_types       vtyp;

    assert(expr->tnOper == TN_NEW);

    /* Make sure the caller didn't mess up */

    assert(dstx == NULL || expr->tnVtyp == TYP_CLASS && !expr->tnType->tdIsIntrinsic);

    /* What kind of a value is the "new" trying to allocate? */

    type = expr->tnType;
    if  (expr->tnOp.tnOp2 && expr->tnOp.tnOp2->tnOper == TN_NONE)
        type = expr->tnOp.tnOp2->tnType;

    vtyp = otyp = type->tdTypeKindGet();

    if  (vtyp <= TYP_lastIntrins)
    {
        /* Locate the appropriate built-in value type */

        type = genComp->cmpFindStdValType(vtyp); assert(type);
        vtyp = TYP_CLASS; assert(vtyp == type->tdTypeKind);
    }

    switch (vtyp)
    {
        ILblock         labTemp;

    case TYP_CLASS:
        if  (dstx)
        {
            unsigned        cnt;

            cnt = genAdr(dstx, true); assert(cnt == 1);

            genCall(expr, false);

            assert(valUsed == false);
        }
        else
        {
            unsigned        tmp = genTempVarGet(type);

            genLclVarAdr(tmp);
            genCall(expr, false);

            if  (valUsed)
                genLclVarRef(tmp, false);

            genTempVarRls(type, tmp);
        }
        return;

    case TYP_REF:
        if  (expr->tnOp.tnOp1->tnFlags & TNF_CALL_STRCAT)
        {
            genCall(expr, valUsed);
        }
        else
        {
            genCall(expr, true);
            if  (!valUsed)
                genOpcode(CEE_POP);
        }
        return;

    case TYP_PTR:

        assert(dstx == NULL);

        /* Generate the size of the class and call 'operator new' */

        genIntConst(genComp->cmpGetTypeSize(type->tdRef.tdrBase));
        genOpcode_tok(CEE_CALL, genMethodRef(genComp->cmpFNumgOperNewGet(), false));

        /* Duplicate the result so that we can test it */

        labTemp = genFwdLabGet();

        genOpcode(CEE_DUP);
        genOpcode_lab(CEE_BRFALSE, labTemp);
        genCurStkLvl--;

        /* Now call the ctor for the class */

        genOpcode(CEE_DUP);
        genCall(expr->tnOp.tnOp1, false);

        /* The result will remain on the stack */

        genFwdLabDef(labTemp);
        return;

    case TYP_ARRAY:

        /* Are we allocating a managed or unmanaged array? */

        if  (type->tdIsManaged)
        {
            TypDef          elem;
            unsigned        slvl = genCurStkLvl;
            unsigned        dcnt = 0;

            /* Is there an array initializer? */

            if  (expr->tnOp.tnOp1)
            {
                assert(expr->tnOp.tnOp1->tnOper == TN_ARR_INIT ||
                       expr->tnOp.tnOp1->tnOper == TN_ERROR);
                genExpr(expr->tnOp.tnOp1, valUsed);
                return;
            }

            /* We need to generate the list of dimensions */

            dcnt = genArrBounds(type, elem);

            /* Generate the opcode with the appropriate type token */

            if  (dcnt > 1)
            {
                /* We need to generate "newobj array::ctor" */

                genOpcode_tok(CEE_NEWOBJ, genComp->cmpArrayCTtoken(type, elem, dcnt));
            }
            else
            {
                /* Single-dim array, we can use a simple opcode */

                genOpcode_tok(CEE_NEWARR, genTypeRef(elem));
            }

            /* The dimensions will all be popped, array addr pushed */

            genCurStkLvl = slvl + 1;
        }
        else
        {
#ifdef  DEBUG
            genComp->cmpParser->parseDispTree(expr);
#endif
            UNIMPL(!"gen MSIL for 'new' of an unmanaged array");
        }
        break;

    default:
#ifdef  DEBUG
        genComp->cmpParser->parseDispTree(expr);
#endif
        UNIMPL(!"gen new of some weird type");
    }

    if  (!valUsed)
        genOpcode(CEE_POP);
}

/*****************************************************************************
 *
 *  Generate MSIL for a call expression.
 */

void                genIL::genCall(Tree expr, bool valUsed)
{
    SymDef          fncSym;
    TypDef          fncTyp;

    TypDef          retType;

    Tree            objPtr;

    Tree            argLst;
    unsigned        argCnt;

    bool            strArr;

    bool            isNew;
    bool            indir;
    bool            CTcall;

    Tree            adrDst = NULL;
    unsigned        adrCnt;

    mdToken         methRef;

    unsigned        tempNum;
    bool            tempUsed = false;
    TypDef          tempType;

    TypDef          asgType = NULL;

//  bool            isIntf  = false;
    bool            isVirt  = false;
    bool            umVirt  = false;

    assert(expr->tnOper == TN_FNC_SYM ||
           expr->tnOper == TN_CALL    ||
           expr->tnOper == TN_NEW);

    /* Keep track of how many arguments we've pushed */

    argCnt = genCurStkLvl;

    /* Is this a direct or indirect call? */

    switch (expr->tnOper)
    {
    case TN_FNC_SYM:

        /* Get hold of the function symbol */

        fncSym = expr->tnFncSym.tnFncSym; assert(fncSym->sdFnc.sdfDisabled == false);

        /* Process the object address if it's present */

        objPtr = expr->tnFncSym.tnFncObj;

        if  (fncSym->sdIsStatic || !fncSym->sdIsMember)
        {
            /* Generate side effects in the object expression, if any */

            if  (objPtr)
                genSideEff(objPtr);
        }
        else
        {
            TypDef          clsTyp = fncSym->sdParent->sdType;

            /* This must be a member function */

            assert(clsTyp->tdTypeKind == TYP_CLASS);

            /* Is the method (and the call to it) virtual? */

            if  (fncSym->sdFnc.sdfVirtual && !fncSym->sdIsSealed)
            {
                if  (expr->tnFlags & TNF_CALL_NVIRT)
                {
                    // We're being asked not to call it virtually, so oblige
                }
                else if (clsTyp->tdClass.tdcValueType && clsTyp->tdIsManaged)
                {
                    // Managed structs never inherit so virtual is worthless
                }
                else
                    isVirt = true;
            }

            /* Evaluate the instance pointer if an explicit one is present */

            if  (objPtr)
            {
                /* We might have to introduce a temp for the operand */

                if  (objPtr->tnOper == TN_ADDROF)
                {
                    tempUsed = genGenAddressOf(objPtr->tnOp.tnOp1,
                                               false,
                                               &tempNum,
                                               &tempType);

                    /* Special case: "lclvar.func()" is not virtual */

                    if  (objPtr->tnOp.tnOp1->tnOper == TN_LCL_SYM)
                    {
                        // ISSUE: Is this correct and sufficient?

                        isVirt = false;
                    }
                }
                else
                    genExpr(objPtr, true);
            }

            /* Is it an interface method? */

//          isIntf = (fncSym->sdParent->sdType->tdClass.tdcFlavor == STF_INTF);

            /* Is the class managed or unmanaged? */

            assert(fncSym->sdParent->sdSymKind == SYM_CLASS);

            if  (!fncSym->sdParent->sdIsManaged && isVirt)
            {
                /* We have an unmanaged virtual call */

                umVirt = true;

                /*
                    We'll need to push the "this" value twice, see whether
                    we need to store it in a temp or whether we can simply
                    evaluate it twice.
                 */

                assert(objPtr);

                if  (tempUsed)
                {
                    UNIMPL("can this really happen?");
                }
                else
                {
                    if  (objPtr->tnOper == TN_LCL_SYM && !(expr->tnFlags & TNF_CALL_MODOBJ))
                    {
                        /* We can simply reuse the instance pointer */

                        tempUsed = false;
                    }
                    else
                    {
                        /* We'll have to save the instance ptr in a temp */

                        tempUsed = true;
                        tempType = objPtr->tnType;
                        tempNum  = genTempVarGet(tempType);

                        /* Store the instance pointer in the temp and reload it */

                        genLclVarRef(tempNum,  true);
                        genLclVarRef(tempNum, false);
                    }
                }
            }
        }

        argLst = expr->tnFncSym.tnFncArgs;

        fncTyp = fncSym->sdType;
        isNew  =
        indir  = false;

        /* Is this an assignment operator? */

        if  (expr->tnFlags & TNF_CALL_ASGOP)
        {
            /* Get hold of the argument */

            assert(argLst);
            assert(argLst->tnOper == TN_LIST);
            assert(argLst->tnOp.tnOp2 == NULL);

            argLst  = argLst->tnOp.tnOp1;
            asgType = argLst->tnType;

            /* Compute the address of the target and make a copy of it */

            genAdr(argLst, true);
            genOpcode(CEE_DUP);

            /* Is the value of the operator used ? */

            if  (valUsed)
            {
                if  (expr->tnFlags & TNF_CALL_ASGPRE)
                {
                    genOpcode(CEE_DUP);
                    genOpcode_tok(CEE_LDOBJ, genValTypeRef(asgType));
                }
                else
                {
                    unsigned        adrTemp;
                    TypDef          tmpType = genComp->cmpTypeVoid;

                    /* Allocate a temp to hold the address and save it */

                    adrTemp = genTempVarGet(tmpType);
                    genLclVarRef(adrTemp,  true);

                    /* Load the old value and leave it at the bottom */

                    genOpcode_tok(CEE_LDOBJ, genValTypeRef(asgType));

                    /* Reload the address of the target */

                    genLclVarRef(adrTemp, false);

                    /* Push a copy of the value as the argument value */

                    genOpcode(CEE_DUP);
                    genOpcode_tok(CEE_LDOBJ, genValTypeRef(asgType));

                    /* We're done with the temp */

                    genTempVarRls(tmpType, adrTemp);
                }
            }
            else
            {
                genOpcode_tok(CEE_LDOBJ, genValTypeRef(asgType));
            }

            /* We've taken care of the arguments */

            argLst = NULL;
            argCnt = genCurStkLvl;
        }

        if  (expr->tnFlags & TNF_CALL_STRCAT)
        {
            strArr = false;

            /* Get hold of the target - it's the first argument */

            assert(argLst && argLst->tnOper == TN_LIST);

            adrDst = argLst->tnOp.tnOp1;

            if  (adrDst->tnOper == TN_NEW)
            {
                Tree            arrLst;

                /* This is the version that uses a "String[]" constructor */

                arrLst = adrDst->tnOp.tnOp1; assert(arrLst->tnOper == TN_ARR_INIT);
                adrDst = arrLst->tnOp.tnOp1; assert(adrDst->tnOper == TN_LIST);

                /* The first argument is also the destination and result */

                adrDst = adrDst->tnOp.tnOp1;

                /* Remember which flavor we have */

                strArr = true;
            }

            assert(genComp->cmpIsStringExpr(adrDst));

            /* Generate the address of the destination */

            adrCnt = genAdr(adrDst, false);

            if  (adrCnt && !strArr)
            {
                /* Do we need to duplicate one or two address values? */

                if  (adrCnt == 1)
                {
                    genOpcode(CEE_DUP);
                }
                else
                {
                    unsigned        adrTmp1;
                    unsigned        adrTmp2;

                    assert(adrDst->tnOper == TN_INDEX);

                    /* Grab temps for the array address and index and save copies */

                    adrTmp1 = genTempVarGet(adrDst->tnOp.tnOp1->tnType);
                    adrTmp2 = genTempVarGet(adrDst->tnOp.tnOp2->tnType);
                    genLclVarRef(adrTmp2, true);
                    genOpcode(CEE_DUP);
                    genLclVarRef(adrTmp1, true);
                    genLclVarRef(adrTmp2, false);

                    genLclVarRef(adrTmp1, false);
                    genLclVarRef(adrTmp2, false);

                    genTempVarRls(adrDst->tnOp.tnOp1->tnType, adrTmp1);
                    genTempVarRls(adrDst->tnOp.tnOp2->tnType, adrTmp2);
                }

                argCnt += adrCnt;
            }

            if  (!strArr)
            {
                /* Load the old target value and skip over it in the argument list */

                genRef(adrDst, false);

                if  (argLst->tnOp.tnOp2)
                    argLst = argLst->tnOp.tnOp2;
            }
        }

        break;

    case TN_CALL:

        indir  = true;
        isNew  = false;

        assert(expr->tnOper             == TN_CALL);
        assert(expr->tnOp.tnOp1->tnVtyp == TYP_FNC);
        assert(expr->tnOp.tnOp1->tnOper == TN_IND);

        argLst = expr->tnOp.tnOp2;
        fncTyp = expr->tnOp.tnOp1->tnType;

        break;

    default:

        expr = expr->tnOp.tnOp1;

        assert(expr && expr->tnOper == TN_FNC_SYM);

        fncSym = expr->tnFncSym.tnFncSym; assert(fncSym);
        argLst = expr->tnFncSym.tnFncArgs;
        fncTyp = fncSym->sdType;

        indir  = false;
        isNew  = true;
        CTcall = false;

        /* Value types get created via a direct ctor call */

        assert(fncSym->sdParent->sdSymKind == SYM_CLASS);
        if  (fncSym->sdParent->sdType->tdClass.tdcValueType)
            CTcall = true;

        /* We no longer do string concat via ctor calls */

        assert((expr->tnFlags & TNF_CALL_STRCAT) == 0);
        break;
    }

    /* Get hold of the function's return type */

    assert(fncTyp->tdTypeKind == TYP_FNC);

    retType = genComp->cmpDirectType(fncTyp->tdFnc.tdfRett);

    /* Generate the argument list */

    while (argLst)
    {
        assert(argLst->tnOper == TN_LIST);
        genExpr(argLst->tnOp.tnOp1, true);
        argLst = argLst->tnOp.tnOp2;
    }

    /* Is this an unmanaged virtual call? */

    if  (umVirt)
    {
        unsigned        vtblOffs;

        /* We need to get to the function's address via the vtable */

        if  (tempUsed)
        {
            /* Load the saved instance pointer from the temp */

            genLclVarRef(tempNum, false);
        }
        else
        {
            /* Push another copy of the instance pointer */

            genExpr(objPtr, true);
        }

        /* Indirect through the instance pointer to get the vtable address */

        genOpcode(opcodesIndLoad[TYP_PTR]);

        /* Add the vtable offset if non-zero */

        vtblOffs = fncSym->sdFnc.sdfVtblx; assert(vtblOffs);

//      printf("Vtable offset is %04X for '%s'\n", sizeof(void*) * (vtblOffs - 1), fncSym->sdSpelling());

        if  (vtblOffs > 1)
        {
            genIntConst(sizeof(void*) * (vtblOffs - 1));
            genOpcode(CEE_ADD);
        }

        /* Finally, load the address of the function */

        genOpcode(opcodesIndLoad[TYP_PTR]);

        /* We have an indirect call for sure */

        indir = true;
    }

    genMarkStkMax();

    /* Argument count is equal to how much stuff we've pushed */

    argCnt = genCurStkLvl - argCnt;

    /* Figure out the call descriptor/opcode we need to use */

    if  (indir)
    {
        mdToken         sig;

        /* We need to add "this" for unmanaged virtual calls */

        if  (umVirt)
        {
            sig = genInfFncRef(fncSym->sdType, objPtr->tnType);
        }
        else
        {
            Tree            adr = expr->tnOp.tnOp1;

            assert(adr->tnOper == TN_IND);

            genExpr(adr->tnOp.tnOp1, true); argCnt++;

            sig = genInfFncRef(expr->tnOp.tnOp1->tnType, NULL);
        }

        genOpcode_tok(CEE_CALLI, sig);
    }
    else
    {
        /*
            Strange thing - the metadata token used in a vararg call
            must be a memberref not a methoddef. That means that when
            we call a varargs function that is also defined locally,
            we have to make extra effort to generate a separate ref
            for it even when no extra arguments are passed.

         */

        if  (fncSym->sdType->tdFnc.tdfArgs.adVarArgs)
            expr->tnFlags |= TNF_CALL_VARARG;

        if  (expr->tnFlags & TNF_CALL_VARARG)
        {
            methRef = genVarargRef(fncSym, expr);
        }
        else
        {
            methRef = genMethodRef(fncSym, isVirt);
        }

        if (isNew)
        {
            /* This is a call to new and a constructor */

            genOpcode_tok(CTcall ? CEE_CALL : CEE_NEWOBJ, methRef);

            if  (CTcall)
                genCurStkLvl--;
        }
        else
        {
            /* Now issue the call instruction */

            genOpcode_tok(isVirt ? CEE_CALLVIRT : CEE_CALL, methRef);

            if  (adrDst)
            {
                /* This is a string concatenation assignment operator */

                if  (valUsed)
                {
                    UNIMPL(!"dup result of concat into a temp");
                }

                genRef(adrDst, true);

                assert(argCnt);

                if  (strArr)
                    argCnt -= adrCnt;

//              printf("[%d] Stk lvl = %d, argCnt = %d, adrCnt = %d\n", strArr, genCurStkLvl, argCnt, adrCnt);

                genCurStkLvl -= (argCnt - 1);
                return;
            }
        }
    }

    /* Adjust stack level: the callee will pop its arguments */

    genCurStkLvl -= argCnt;

    /* If we've used a temp, free it up now */

    if  (tempUsed)
        genTempVarRls(tempType, tempNum);

    /* Does the function have a non-void return type? */

    if  (retType->tdTypeKind != TYP_VOID && !isNew)
    {
        if  (asgType)
        {
            genOpcode_tok(CEE_STOBJ, genValTypeRef(asgType));

            if  (valUsed && (expr->tnFlags & TNF_CALL_ASGPRE))
                genOpcode_tok(CEE_LDOBJ, genValTypeRef(asgType));
        }
        else
        {
            genCurStkLvl++;
            genMarkStkMax();

            if  (!valUsed)
                genOpcode(CEE_POP);
        }
    }
}

/*****************************************************************************
 *
 *  Generate a stub for a method of a generic type instance. We simply push
 *  all the arguments to the method, and then call the corresponding generic
 *  method to do all of the real work.
 */

void                genIL::genInstStub()
{
    ArgDef          args;
    unsigned        argc;

    assert(genFncSym->sdFnc.sdfInstance);
    assert(genFncSym->sdFnc.sdfGenSym);

    argc = 0;

    if  (!genFncSym->sdIsStatic)
    {
        genArgVarRef(0, false); argc++;
    }

    for (args = genFncSym->sdType->tdFnc.tdfArgs.adArgs;
         args;
         args = args->adNext)
    {
        genArgVarRef(argc, false); argc++;
    }

    genOpcode_tok(CEE_CALL, genMethodRef(genFncSym->sdFnc.sdfGenSym, false));
    genOpcode    (CEE_RET);

    genCurStkLvl = 0;
}

#ifdef  SETS

void                genIL::genConnect(Tree op1, Tree expr1, SymDef addf1,
                                      Tree op2, Tree expr2, SymDef addf2)
{
    /*
        We simply generate the following code:

          op1 += expr2;
          op2 += expr1;

        The caller supplies the expressions and the += operator symbols.
     */

    genExpr(  op1, true);
    genExpr(expr2, true);
    genOpcode_tok(CEE_CALL, genMethodRef(addf1, false));
    genCurStkLvl -= 2;

    genExpr(  op2, true);
    genExpr(expr1, true);
    genOpcode_tok(CEE_CALL, genMethodRef(addf2, false));
    genCurStkLvl -= 2;
}

void                genIL::genSortCmp(Tree val1, Tree val2, bool last)
{
    ILblock         labTmp;

    /* Subtract the two values (unless there is only one) */

    genExpr(val1, true);

    if  (val2)
    {
        genExpr(val2, true);
        genOpcode(CEE_SUB);
    }

    /* See if the difference in values is positive */

    genOpcode(CEE_DUP);
    labTmp = genFwdLabGet();
assert(val1->tnVtyp == TYP_INT || val1->tnVtyp == TYP_UINT); genIntConst(0);    // UNDONE: we need to use a 0 with the proper type!!!!!!
    genOpcode_lab(CEE_BLE, labTmp);
    genOpcode(CEE_POP);
    genIntConst(+1);
    genOpcode(CEE_RET);
    genFwdLabDef(labTmp);

    /* See if the difference in values is negative */

    labTmp = genFwdLabGet();
assert(val1->tnVtyp == TYP_INT || val1->tnVtyp == TYP_UINT); genIntConst(0);    // UNDONE: we need to use a 0 with the proper type!!!!!!
    genOpcode_lab(CEE_BGE, labTmp);
    genIntConst(-1);
    genOpcode(CEE_RET);
    genFwdLabDef(labTmp);

    /* Values are equal, return 0 if this was the last term */

    if  (last)
    {
        genIntConst(0);
        genOpcode(CEE_RET);
    }
}

#endif

/*****************************************************************************
 *
 *  Generate MSIL for the given expression.
 */

void                genIL::genExpr(Tree expr, bool valUsed)
{
    treeOps         oper;
    unsigned        kind;

AGAIN:

    assert(expr);
#if!MGDDATA
    assert((int)expr != 0xCCCCCCCC && (int)expr != 0xDDDDDDDD);
#endif
    assert(expr->tnOper == TN_ERROR || expr->tnType && expr->tnType->tdTypeKind == expr->tnVtyp || genComp->cmpErrorCount);

    /* Classify the root node */

    oper = expr->tnOperGet ();
    kind = expr->tnOperKind();

    /* Is this a constant node? */

    if  (kind & TNK_CONST)
    {
        switch (oper)
        {
        case TN_CNS_INT:
            genIntConst((__int32)expr->tnIntCon.tnIconVal);
            break;

        case TN_CNS_LNG:

            genOpcode_I8(CEE_LDC_I8, expr->tnLngCon.tnLconVal);
            break;

        case TN_CNS_FLT:

            genOpcode_R4(CEE_LDC_R4, expr->tnFltCon.tnFconVal);
            break;

        case TN_CNS_DBL:
            genOpcode_R8(CEE_LDC_R8, expr->tnDblCon.tnDconVal);
            break;

        case TN_CNS_STR:
            genStringLit(expr->tnType, expr->tnStrCon.tnSconVal,
                                       expr->tnStrCon.tnSconLen,
                                       expr->tnStrCon.tnSconLCH);
            break;

        case TN_NULL:
            if  (expr->tnVtyp == TYP_REF || expr->tnVtyp == TYP_ARRAY)
                genOpcode(CEE_LDNULL);
            else
                genIntConst(0);
            break;

        default:
#ifdef DEBUG
            genComp->cmpParser->parseDispTree(expr);
#endif
            assert(!"unexpected const node in genExpr()");
        }

        goto DONE;
    }

    /* Is this a leaf node? */

    if  (kind & TNK_LEAF)
    {
        switch (oper)
        {
        case TN_DBGBRK:
            assert(valUsed == false);
            genOpcode(CEE_BREAK);
            return;

        default:
#ifdef DEBUG
            genComp->cmpParser->parseDispTree(expr);
#endif
            assert(!"unexpected leaf node in genExpr()");
        }

        goto DONE;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        Tree            op1 = expr->tnOp.tnOp1;
        Tree            op2 = expr->tnOp.tnOp2;

        /* Some operators need special operand handling */

        switch (oper)
        {
            unsigned        cnt;
            unsigned        chk;

            TypDef          type;

            var_types       srcType;
            var_types       dstType;

        case TN_ASG:

            /* Special case: struct copy */

            if  (expr->tnVtyp == TYP_CLASS && !expr->tnType->tdIsIntrinsic)
            {
                /* Are we assigning the result of a 'new' operator? */

                if  (op2->tnOper == TN_NEW)
                {
                    genNewExpr(op2, valUsed, op1);
                    return;
                }

                /* Special case: function results (including "new") can't be copied */

                switch (op2->tnOper)
                {
                case TN_NEW:
                    assert(valUsed == false);
                    cnt = genAdr(op1, true); assert(cnt == 1);
                    genExpr(op2, true);
                    genCurStkLvl--;
                    return;

                case TN_UNBOX:
//              case TN_QMARK:
//              case TN_FNC_SYM:
                    assert(valUsed == false);
                    cnt = genAdr(op1, true); assert(cnt == 1);
                    genExpr(op2, true);
                    genOpcode_tok(CEE_STOBJ, genValTypeRef(op1->tnType));
                    return;
                }

                /* Is the target an indirection ? */

                if  (op1->tnOper == TN_IND ||
                     op1->tnOper == TN_VAR_SYM && !op1->tnVarSym.tnVarSym->sdIsManaged)
                {
                    cnt = genAdr(op1, true); assert(cnt == 1);
                    cnt = genAdr(op2, true); assert(cnt == 1);
                    genOpcode_tok(CEE_CPOBJ, genValTypeRef(op1->tnType));
                    return;
                }
            }
            else if (op1->tnOper == TN_BFM_SYM)
            {
                /* Assignment to a bitfield */

                genBitFieldSt(op1, op2, NULL, 0, false, valUsed);
                return;
            }

            /* We have a "simple" assignment */

            cnt = genAdr(op1);

            // CONSIDER: see if op2 is of the form "xxx = icon;" and optimize

            genExpr(op2, true);

            /* Is the result of assignment used? */

            if  (valUsed)
            {
                unsigned        tempNum;

                // UNDONE: Only do this if const fits in target!

                if  (op2->tnOper == TN_CNS_INT ||
                     op2->tnOper == TN_CNS_LNG)
                {
                    /* Store the constant in the target */

                    genRef (op1, true);

                    /* Load another copy of the constant */

                    genExpr(op2, true);
                }
                else if (cnt == 0)
                {
                    genOpcode(CEE_DUP);
                    genRef(op1, true);
                }
                else
                {
                    /* Need to duplicate the new value */

                    tempNum = genTempVarGet(expr->tnType);

                    /* Copy a value to a temp */

                    genOpcode(CEE_DUP);
                    genLclVarRef(tempNum,  true);

                    /* Store the new value in the destination */

                    genRef(op1, true);

                    /* Reload the temp */

                    genLclVarRef(tempNum, false);

                    // UNDONE: target may have smaller size, result must match!!!!

                    genTempVarRls(expr->tnType, tempNum);
                }
            }
            else
            {
                /* Simply store the new value */

                genRef(op1, true);
            }
            return;

        case TN_IND:
        case TN_INDEX:
            genAdr(expr);
            genRef(expr, false);
            goto DONE;

        case TN_NEW:
            genNewExpr(expr, valUsed);
            return;

        case TN_ADDROF:

            if  (!valUsed)
            {
                genSideEff(op1);
                return;
            }

            if  (op1->tnOper == TN_FNC_SYM || op1->tnOper == TN_FNC_PTR)
            {
                genFncAddr(op1);
            }
            else
            {
                chk = genAdr(op1, true); assert(chk == 1);
            }
            return;

        case TN_CAST:

#ifndef NDEBUG

            if  (op1->tnOperIsConst() && op1->tnOper != TN_CNS_STR)
            {
                if  (op1->tnOper == TN_CNS_FLT && _isnan(op1->tnFltCon.tnFconVal) ||
                     op1->tnOper == TN_CNS_DBL && _isnan(op1->tnDblCon.tnDconVal))
                {
                    /* Constant casts of NaN's don't get folded on purpose */
                }
                else
                {
                    genComp->cmpParser->parseDispTree(expr);
                    printf("WARNING: The constant cast shown above hasn't been folded.\n");
                }
            }

#endif

            srcType = genComp->cmpActualVtyp( op1->tnType);
            dstType = genComp->cmpActualVtyp(expr->tnType);

        CHK_CAST:

            /* Check for a worthless cast */

            if  (varTypeIsIntegral(dstType) &&
                 varTypeIsIntegral(srcType))
            {
                size_t          srcSize = symTab::stIntrTypeSize(srcType);
                size_t          dstSize = symTab::stIntrTypeSize(dstType);

                /* UNDONE: cover more cases of worthless casts */

                if  (srcSize == dstSize && srcSize >= sizeof(int))
                {
                    if  (srcSize >= sizeof(__int64) || op1->tnOper == TN_CAST)
                    {
                        /* Toss the second cast and keep the inner one */

                        genExpr(op1, valUsed);
                        return;
                    }
                }
            }

            if  (srcType == TYP_CLASS)
            {
                srcType = (var_types)op1 ->tnType->tdClass.tdcIntrType; assert(srcType != TYP_UNDEF);
                if  (srcType == dstType)
                    goto DONE;

                op1 ->tnType = genStab->stIntrinsicType(srcType);
                op1 ->tnVtyp = srcType;
                goto CHK_CAST;
            }

            if  (dstType == TYP_CLASS)
            {
                dstType = (var_types)expr->tnType->tdClass.tdcIntrType; assert(dstType != TYP_UNDEF);
                if  (srcType == dstType)
                    goto DONE;

                expr->tnType = genStab->stIntrinsicType(dstType);
                expr->tnVtyp = dstType;
                goto CHK_CAST;
            }

            genCast(op1, expr->tnType, expr->tnFlags);
            goto DONE;

        case TN_INC_POST: genIncDec(op1, +1,  true, valUsed); return;
        case TN_DEC_POST: genIncDec(op1, -1,  true, valUsed); return;
        case TN_INC_PRE : genIncDec(op1, +1, false, valUsed); return;
        case TN_DEC_PRE : genIncDec(op1, -1, false, valUsed); return;

        case TN_ASG_ADD:
        case TN_ASG_SUB:
        case TN_ASG_MUL:
        case TN_ASG_DIV:
        case TN_ASG_MOD:
        case TN_ASG_AND:
        case TN_ASG_XOR:
        case TN_ASG_OR :
        case TN_ASG_LSH:
        case TN_ASG_RSH:
        case TN_ASG_RSZ:

        case TN_CONCAT_ASG:
            genAsgOper(expr, valUsed);
            return;

        case TN_EQ:
        case TN_NE:
        case TN_LT:
        case TN_LE:
        case TN_GE:
        case TN_GT:

if  (genComp->cmpConfig.ccTgt64bit)
{
    static bool b;
    if  (!b)
    {
        printf("WARNING: suppressing CEQ/CLT/etc for 64-bit target\n");
        b = true;
    }
    goto HACK_64;
}

            genExpr(op1, true);
            genExpr(op2, true);

            if  (valUsed)
            {
                cmpRelDsc *     desc;

                desc = varTypeIsUnsigned(genExprVtyp(op1)) ? relToMopUns
                                                           : relToMopSgn;

                desc = desc + (oper - TN_EQ);

                genOpcode(desc->crdOpcode);

                if  (desc->crdNegate)
                {
                    genOpcode(CEE_LDC_I4_0);
                    genOpcode(CEE_CEQ);
                }
            }
            else
            {
                genOpcode(CEE_POP);
                genOpcode(CEE_POP);
            }
            return;

HACK_64:

        case TN_LOG_OR:
        case TN_LOG_AND:

        case TN_LOG_NOT:
            {
                ILblock         labTmp;
                ILblock         labYes;

                genStkMarkTP     stkMark;

                labTmp = genFwdLabGet();
                labYes = genTestCond(expr, true);
                markStkLvl(stkMark);

                genIntConst(0);
                genOpcode_lab(CEE_BR , labTmp);
                genFwdLabDef(labYes);
                restStkLvl(stkMark);
                genIntConst(1);
                genFwdLabDef(labTmp);
            }
            goto DONE;

        case TN_QMARK:
            {
                ILblock         labOp2;
                ILblock         labRes;

                genStkMarkTP     stkMark;

                assert(op2->tnOper == TN_COLON);

                labRes = genFwdLabGet();
                labOp2 = genTestCond(op1, false);
                markStkLvl(stkMark);

                genExpr(op2->tnOp.tnOp1, true);
                genOpcode_lab(CEE_BR , labRes);
                genFwdLabDef(labOp2);
                restStkLvl(stkMark);
                genExpr(op2->tnOp.tnOp2, true);
                genFwdLabDef(labRes);
            }
            goto DONE;

        case TN_COMMA:
            genExpr(op1, false);
            expr = op2;
            goto AGAIN;

        case TN_ARR_INIT:
            genArrayInit(expr);
            goto DONE;

        case TN_CALL:
            genCall(expr, valUsed);
            return;

        case TN_ISTYPE:
            assert(op2->tnOper == TN_NONE);
            genExpr(op1, true);
            genOpcode_tok(CEE_ISINST, genTypeRef(op2->tnType));
            genOpcode    (CEE_LDC_I4_0);
            genOpcode    (CEE_CGT_UN);
            goto DONE;

        case TN_BOX:

            /* Get hold of the operand type and make sure we have a value class */

            type = op1->tnType;
            if  (type->tdTypeKind != TYP_CLASS && type->tdTypeKind != TYP_ENUM)
            {
                assert(type->tdTypeKind != TYP_REF);

                type = genComp->cmpFindStdValType(genComp->cmpActualVtyp(op1->tnType));
            }

            assert(type && (type->tdTypeKind == TYP_CLASS && type->tdClass.tdcValueType ||
                            type->tdTypeKind == TYP_ENUM));

            genExpr(op1, true);
            genOpcode_tok(CEE_BOX, genTypeRef(type));

            goto DONE;

        case TN_VARARG_BEG:
        case TN_VARARG_GET:

            /*
                To get a vararg iterator started, we generate the following
                code:

                    ldloca          <arg_iter_var>
                    arglist
                    ldarga          <last_fixed_arg>
                    call            void System.ArgIterator::<init>(int32,int32)

                To fetch the next vararg value, we generate the following
                code:

                    ldloca          <arg_iter_var>
                    ldtoken         <type>
                    call            int32 System.ArgIterator::GetNextArg(int32)
                    ldind.<type>

                Actually, not any more - now we generate the following:

                    ldloca          <arg_iter_var>
                    call            refany System.ArgIterator::GetNextArg(int32)
                    refanyval       <type>
                    ldind.<type>
             */

            assert(op1 && op1->tnOper == TN_LIST);

            assert(op1->tnOp.tnOp1 && op1->tnOp.tnOp1->tnOper == TN_LCL_SYM);
            genLclVarAdr(op1->tnOp.tnOp1->tnLclSym.tnLclSym);

            if  (oper == TN_VARARG_BEG)
            {
                genOpcode(CEE_ARGLIST);

                assert(op1->tnOp.tnOp2 && op1->tnOp.tnOp2->tnOper == TN_LCL_SYM);
                genLclVarAdr(op1->tnOp.tnOp2->tnLclSym.tnLclSym);

                genCall(op2, false);
                genCurStkLvl -= 3;

                assert(valUsed == false);
                return;
            }
            else
            {
                TypDef          type;
                var_types       vtyp;

                /* Get hold of the type operand */

                assert(op1->tnOp.tnOp2 && op1->tnOp.tnOp2->tnOper == TN_TYPE);
                type = op1->tnOp.tnOp2->tnType;
                vtyp = type->tdTypeKindGet();

                /* Call ArgIterator::GetNextArg */

                genCall(op2, true);
                genCurStkLvl -= 1;

                genOpcode_tok(CEE_REFANYVAL, genTypeRef(type));

                /* Load the value of the argument */

                assert(vtyp < arraylen(opcodesIndLoad));

                genOpcode(opcodesIndLoad[vtyp]);

                goto DONE;
            }

        case TN_TOKEN:

            assert(op1 && op1->tnOper == TN_NOP);
            assert(op2 == NULL);

            assert(valUsed);

            genOpcode_tok(CEE_LDTOKEN, genTypeRef(op1->tnType));
            return;

#ifdef  SETS

        case TN_ALL:
        case TN_EXISTS:
        case TN_SORT:
        case TN_FILTER:
        case TN_GROUPBY:
        case TN_UNIQUE:
        case TN_INDEX2:
        case TN_PROJECT:
            genComp->cmpGenCollExpr(expr);
            goto DONE;

#endif

        case TN_REFADDR:

            assert(op1->tnVtyp == TYP_REFANY);
            genExpr(op1, true);

            genOpcode_tok(CEE_REFANYVAL, genTypeRef(op2->tnType));

            goto DONE;
        }

        /* Generate one or two operands */

        if  (op1) genExpr(op1, true);
        if  (op2) genExpr(op2, true);

        ILopcodes       op;

        /* Is this an 'easy' operator? */

        op = genBinopOpcode(oper, genExprVtyp(expr));

        if  (op != CEE_NOP)
        {
#ifndef NDEBUG

            /* The type of the operands should agree (more or less) */

            switch (oper)
            {
            case TN_LSH:
            case TN_RSH:
            case TN_RSZ:

                /* Special case: 'long' shifts have 'int' right operands */

                if  (op1->tnVtyp == TYP_LONG)
                {
                    assert(op2 ->tnVtyp <= TYP_UINT);
                    assert(expr->tnVtyp == TYP_LONG);
                    break;
                }

//          default:
//
//              if  (op1 && op1->tnVtyp != expr->tnVtyp) assert(op1->tnVtyp <= TYP_INT && expr->tnVtyp <= TYP_INT);
//              if  (op2 && op2->tnVtyp != expr->tnVtyp) assert(op2->tnVtyp <= TYP_INT && expr->tnVtyp <= TYP_INT);
            }
#endif

            genOpcode(op);
            goto DONE;
        }

        /* Generate the appropriate operator MSIL */

        switch (oper)
        {
        case TN_ARR_LEN:
            genOpcode(CEE_LDLEN);
            break;

        case TN_NOT:
            genOpcode(CEE_NOT);
            break;

        case TN_NEG:
            genOpcode(CEE_NEG);
            break;

        case TN_NOP:
            break;

        case TN_THROW:
            genOpcode(op1 ? CEE_THROW : CEE_RETHROW);
            return;

        case TN_UNBOX:
            assert(expr->tnVtyp == TYP_REF || expr->tnVtyp == TYP_PTR);
            genOpcode_tok(CEE_UNBOX, genTypeRef(expr->tnType->tdRef.tdrBase));
            goto DONE;

        case TN_TYPE:

            /* Assume we must have had errors for this to appear here */

            assert(genComp->cmpErrorCount);
            return;

        case TN_DELETE:
            genOpcode_tok(CEE_CALL, genMethodRef(genComp->cmpFNumgOperDelGet(), false));
            genCurStkLvl--;
            return;

        case TN_TYPEOF:
            assert(op1->tnVtyp == TYP_REFANY);

            genOpcode    (CEE_REFANYTYPE);
            genOpcode_tok(CEE_CALL, genMethodRef(genComp->cmpFNsymGetTPHget(), false));
            break;

        default:
#ifdef DEBUG
            genComp->cmpParser->parseDispTree(expr);
#endif
            NO_WAY(!"unsupported unary/binary operator in genExpr()");
            break;
        }

        goto DONE;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        SymDef          sym;

    case TN_VAR_SYM:

        /* Is this an instance member of a managed class? */

        sym = expr->tnVarSym.tnVarSym;

        if  (sym->sdIsMember && sym->sdIsManaged && !sym->sdIsStatic)
        {
            Tree            addr;

            assert(sym->sdSymKind      == SYM_VAR);
            assert(sym->sdVar.sdvLocal == false);
            assert(sym->sdVar.sdvConst == false);

            /* Get hold of the instance address value */

            addr = expr->tnVarSym.tnVarObj; assert(addr);

            if  (addr->tnOper == TN_ADDROF)
            {
                Tree            oper = addr->tnOp.tnOp1;

                if  (oper->tnOper == TN_FNC_SYM ||
                     oper->tnOper == TN_FNC_PTR)
                {
                    unsigned        tempNum;

                    /* Generate the call and store its result in a temp */

                    tempNum = genTempVarGet(oper->tnType);
                    genExpr(oper, true);
                    genLclVarRef(tempNum, true);

                    /* Now load the field from the temp */

                    genLclVarAdr(tempNum);
                    genOpcode_tok(CEE_LDFLD, genMemberRef(sym));

                    /* We can free up the temp now */

                    genTempVarRls(oper->tnType, tempNum);
                    break;
                }
            }
        }

        // Fall through ...

    case TN_LCL_SYM:
        genAdr(expr);
        genRef(expr, false);
        break;

    case TN_BFM_SYM:
        genBitFieldLd(expr, false, valUsed);
        return;

    case TN_FNC_SYM:
        if  (expr->tnFncSym.tnFncSym->sdFnc.sdfDisabled)
        {
            assert(valUsed == false);
        }
        else
        {
            genCall(expr, valUsed);
        }
        return;

    case TN_FNC_PTR:
        if  (valUsed)
            genFncAddr(expr);
        return;

    case TN_ERROR:
        return;

    default:
#ifdef DEBUG
        genComp->cmpParser->parseDispTree(expr);
#endif
        assert(!"unsupported node in genExpr()");
        return;
    }

DONE:

    /* If the value isn't used, pop it */

    if  (!valUsed)
        genOpcode(CEE_POP);
}

/*****************************************************************************
 *
 *  Generate code for a 'return' statement.
 */

void                genIL::genStmtRet(Tree retv)
{
    assert(genCurStkLvl == 0 || genComp->cmpErrorCount != 0);

    if  (retv)
        genExpr(retv, true);

    genOpcode(CEE_RET);

    genCurStkLvl = 0;
}

/*****************************************************************************
 *
 *  Generate a string literal value.
 */

void                genIL::genStringLit(TypDef type, const char *str,
                                                     size_t      len, int wide)
{
    const   void  * addr;
    size_t          size;

    unsigned        offs;

    var_types       vtyp = type->tdTypeKindGet();

    assert(vtyp == TYP_REF || vtyp == TYP_PTR);

    /* Include the terminating null character in the length */

    len++;

    /* First figure out whether we need an ANSII or Unicode string */

    if  (vtyp == TYP_REF || genComp->cmpGetRefBase(type)->tdTypeKind == TYP_WCHAR)
    {
        addr = wide ? genComp->cmpUniCnvW(str, &len)
                    : genComp->cmpUniConv(str,  len);

        /* Are we generating a Common Type System-style string reference? */

        if  (vtyp == TYP_REF)
        {
//          printf("String = '%ls', len = %u\n", addr, len-1);

            genOpcode_tok(CEE_LDSTR, genComp->cmpMDstringLit((wchar*)addr, len - 1));
            return;
        }

        size = 2*len;
    }
    else
    {
        /* There better not be any large characters in this string */

        assert(wide == false);

        addr = str;
        size = len;
    }

    /* Add the string to the pool and get its RVA */

    offs = genStrPoolAdd(addr, size);

    /*
       Create a static data member to represent the string literal and
       push its address.
     */

    genOpcode_tok(CEE_LDSFLDA, genComp->cmpStringConstTok(offs, size));
}

/*****************************************************************************
 *
 *  Initialize the string pool logic.
 */

void                genIL::genStrPoolInit()
{
    genStrPoolOffs = 0;

    genStrPoolList =
    genStrPoolLast = NULL;
}

/*****************************************************************************
 *
 *  Add the given blob of bits to the string pool and return the blob's
 *  relative offset.
 */

unsigned            genIL::genStrPoolAdd(const void *str, size_t len, int wide)
{
    unsigned        offs;
    unsigned        base;

    /* Compute the "true" string length (taking large chars into account) */

    if  (wide)
    {
        UNIMPL(!"");
    }

    /* Is there enough room for the string in the current blob? */

    if  (genStrPoolLast == NULL || genStrPoolLast->seFree < len)
    {
        StrEntry        entry;
        genericBuff     block;
        size_t          bsize;

        /* Not enough room, need to grab a new blob */

        bsize = STR_POOL_BLOB_SIZE;
        if  (bsize < len)
            bsize = roundUp(len, OS_page_size);

        /* Allocate the descriptor and the data block */

#if MGDDATA
        entry = new StrEntry;
        block = new BYTE[bsize];
#else
        entry = (StrEntry)genComp->cmpAllocPerm.nraAlloc(sizeof(*entry));
        block = (BYTE *)VirtualAlloc(NULL, bsize, MEM_COMMIT, PAGE_READWRITE);
#endif

        if  (!block)
            genComp->cmpFatal(ERRnoMemory);

        /* Set up the info in the blob descriptor */

        entry->seSize =
        entry->seFree = bsize;
        entry->seOffs = genStrPoolOffs;
        entry->seData = block;

        /* Add the blob to the list */

        entry->seNext = NULL;

        if  (genStrPoolList)
            genStrPoolLast->seNext = entry;
        else
            genStrPoolList         = entry;

        genStrPoolLast = entry;
    }

    /* Here we better have enough room in the current blob */

    assert(genStrPoolLast && genStrPoolLast->seFree >= len);

    /* Figure out where in the block the data should go */

    base = genStrPoolLast->seSize - genStrPoolLast->seFree;

    assert(genStrPoolLast->seSize        >= base + len);
    assert(genStrPoolLast->seOffs + base == genStrPoolOffs);

    /* Copy the data to the right spot in the block */

#if MGDDATA
    UNIMPL(!"need to call arraycopy");
#else
    memcpy(genStrPoolLast->seData + base, str, len);
#endif

    /* Update the amount of free space available in the block */

    genStrPoolLast->seFree -= len;

    /* Grab the next offset and advance it past the new string */

    offs = genStrPoolOffs;
           genStrPoolOffs += len;

    return  offs;
}

/*****************************************************************************
 *
 *  Returns the size of the string pool - don't add any more data to the pool
 *  after calling this function.
 */

unsigned            genIL::genStrPoolSize()
{
    return  genStrPoolOffs;
}

/*****************************************************************************
 *
 *  Output the string pool to the specified address.
 */

void                genIL::genStrPoolWrt(memBuffPtr dest)
{
    StrEntry        entry;

    for (entry = genStrPoolList; entry; entry = entry->seNext)
    {
        unsigned        size = entry->seSize - entry->seFree;

        assert(size && size <= entry->seSize);

#if MGDDATA
        UNIMPL(!"copyarray");
        dest.buffOffs      +=       size;
#else
        memcpy(dest, entry->seData, size);
               dest        +=       size;
#endif

    }
}

/*****************************************************************************
 *
 *  Initialize the exception handler table logic.
 */

void                genIL::genEHtableInit()
{
    genEHlist  =
    genEHlast  = NULL;

    genEHcount = 0;
}

/*****************************************************************************
 *
 *  Add an entry to the exception handler table.
 */

void                genIL::genEHtableAdd(ILblock tryBegPC,
                                         ILblock tryEndPC,
                                         ILblock filterPC,
                                         ILblock hndBegPC,
                                         ILblock hndEndPC,
                                         TypDef  catchTyp, bool isFinally)
{
    Handler         newHand;

    assert(tryBegPC);
    assert(tryEndPC);

    genEHcount++;

#if MGDDATA
    newHand = new Handler;
#else
    newHand =    (Handler)genAlloc->nraAlloc(sizeof(*newHand));
#endif

    newHand->EHtryBegPC     = tryBegPC;
    newHand->EHtryEndPC     = tryEndPC;

    newHand->EHhndBegPC     = hndBegPC;
    newHand->EHhndEndPC     = hndEndPC;

    newHand->EHfilterPC     = filterPC;
    newHand->EHhndType      = catchTyp ? genTypeRef(catchTyp) : 0;

    newHand->EHisFinally    = isFinally;

    newHand->EHnext = NULL;

    if  (genEHlist)
        genEHlast->EHnext = newHand;
    else
        genEHlist         = newHand;

    genEHlast = newHand;
}

/*****************************************************************************
 *
 *  Output the EH table in the format needed by the COR MSIL header helpers.
 */

void                genIL::genEHtableWrt(EH_CLAUSE_TAB tbl)
{
    Handler         EHlist;
    unsigned        num;

    for (EHlist = genEHlist     , num = 0;
         EHlist;
         EHlist = EHlist->EHnext, num++)
    {
        tbl[num].Flags         = /*COR_ILEXCEPTION_CLAUSE_NONE*/
                                   COR_ILEXCEPTION_CLAUSE_OFFSETLEN;

        tbl[num].TryOffset     = genILblockOffsBeg(EHlist->EHtryBegPC);
        tbl[num].TryLength     = genILblockOffsBeg(EHlist->EHtryEndPC) - tbl[num].TryOffset;

        tbl[num].HandlerOffset = genILblockOffsBeg(EHlist->EHhndBegPC);
        tbl[num].HandlerLength = genILblockOffsBeg(EHlist->EHhndEndPC) - tbl[num].HandlerOffset;

        tbl[num].ClassToken    = EHlist->EHhndType;

        if (EHlist->EHfilterPC)
        {
            tbl[num].Flags      = (CorExceptionFlag)(tbl[num].Flags | COR_ILEXCEPTION_CLAUSE_FILTER);
            tbl[num].ClassToken = genILblockOffsBeg(EHlist->EHfilterPC);
        }

        if (EHlist->EHisFinally)
            tbl[num].Flags = (CorExceptionFlag)(tbl[num].Flags | COR_ILEXCEPTION_CLAUSE_FINALLY);

#if 0
        printf("EH[%3u]: Flags   = %04X\n", num, tbl[num].Flags);
        printf("         TryBeg  = %04X\n", tbl[num].TryOffset);
        printf("         TryLen  = %04X\n", tbl[num].TryLength);
        printf("         HndBeg  = %04X\n", tbl[num].HandlerOffset);
        printf("         HndLen  = %04X\n", tbl[num].HandlerLength);
        printf("         Typeref = %08X\n", tbl[num].ClassToken);
#endif

    }

    assert(num == genEHcount);
}

/*****************************************************************************
 *
 *  Start generating code for a 'catch' handler.
 */

void                genIL::genCatchBeg(SymDef argSym)
{
    /* The address of the thrown object is pushed on the stack */

    genCurStkLvl++; genMarkStkMax();

    /* Save the thrown object's address if it might be used */

    if  (argSym->sdName)    // ISSUE: should also test "is used" bit
    {
        genLclVarRef(argSym->sdVar.sdvILindex, true);
    }
    else
        genOpcode(CEE_POP);
}

/*****************************************************************************
 *
 *  Start generating code for an 'except' handler.
 */

void                genIL::genExcptBeg(SymDef tsym)
{
    /* The address of the thrown object is pushed on the stack */

    genCurStkLvl++; genMarkStkMax();

    /* Save the thrown object's address */

    genLclVarRef(tsym->sdVar.sdvILindex, true);
}

/*****************************************************************************
 *
 *  Generate code for a multi-dimensional rectangular array initializer.
 */

void                genIL::genMulDimArrInit(Tree        expr,
                                            TypDef      type,
                                            DimDef      dims,
                                            unsigned    temp,
                                            mulArrDsc * next,
                                            mulArrDsc * outer)
{
    Tree            list;
    Tree            cntx;

    mulArrDsc       desc;
    TypDef          elem = genComp->cmpDirectType(type->tdArr.tdaElem);

    assert(expr && expr->tnOper == TN_ARR_INIT);

    /* Insert this dimension into the list */

    desc.madOuter = NULL;
    desc.madIndex = 0;      // should be low bound which can be non-zero, right?

    if  (next)
    {
        assert(next->madOuter == NULL); next->madOuter = &desc;
    }
    else
    {
        assert(outer          == NULL); outer          = &desc;
    }

    /* Get hold of the initalizer list */

    list = expr->tnOp.tnOp1; assert(list && list->tnOper == TN_LIST);
    cntx = expr->tnOp.tnOp2; assert(cntx->tnOper == TN_CNS_INT);

    /* Assign each sub-array or element in the list */

    dims = dims->ddNext;

    while (list)
    {
        assert(list->tnOper == TN_LIST);

        /* Is this the innermost dimension? */

        if  (!dims)
        {
            mulArrDsc *     dlst;
            unsigned        dcnt;

            /* Load the array base and the element's indices */

            genLclVarRef(temp, false);

            for (dlst = outer          , dcnt = 0;
                 dlst;
                 dlst = dlst->madOuter, dcnt++)
            {
                genIntConst(dlst->madIndex);

                assert(dlst->madOuter || dlst == &desc);
            }

            genExpr(list->tnOp.tnOp1, true);

            genOpcode_tok(CEE_CALL, genComp->cmpArrayEAtoken(type, dcnt, true));
            genCurStkLvl -= (dcnt + 2);
        }
        else
        {
            genMulDimArrInit(list->tnOp.tnOp1, type, dims, temp, &desc, outer);
        }

        /* Move to the next sub-array or element, if any */

        desc.madIndex++;

        list = list->tnOp.tnOp2;
    }

    assert(desc.madIndex == (unsigned)cntx->tnIntCon.tnIconVal);

    /* Remove our entry from the list */

    if  (next)
    {
        assert(next->madOuter == &desc); next->madOuter = NULL;
    }
}

/*****************************************************************************
 *
 *  Generate code for a dynamic array initializer.
 */

void                genIL::genArrayInit(Tree expr)
{
    TypDef          type;
    TypDef          elem;
    var_types       evtp;

    Tree            list;
    Tree            cntx;

    bool            rect;

    unsigned        tnum;
    unsigned        index;
    unsigned        store;

    assert(expr->tnOper == TN_ARR_INIT);

    type = expr->tnType    ; assert(type->tdTypeKind == TYP_ARRAY);
    elem = genComp->cmpActualType(type->tdArr.tdaElem);
    evtp = elem->tdTypeKindGet();

    list = expr->tnOp.tnOp1; assert(list == NULL || list->tnOper == TN_LIST);
    cntx = expr->tnOp.tnOp2; assert(cntx->tnOper == TN_CNS_INT);

    /* Do we have a multi-dimensional rectangular array? */

    if  (type->tdArr.tdaDims &&
         type->tdArr.tdaDims->ddNext)
    {
        Tree            bnds;
        unsigned        dcnt;

        rect = true;

        /* Generate the dimensions and then the "new" opcode */

        bnds = expr; assert(bnds);
        dcnt = 0;

        do
        {
            assert(bnds->tnOp.tnOp2);
            assert(bnds->tnOp.tnOp2->tnOper == TN_CNS_INT);

            genIntConst(bnds->tnOp.tnOp2->tnIntCon.tnIconVal); dcnt++;

            bnds = bnds->tnOp.tnOp1; assert(bnds && bnds->tnOper == TN_LIST);
            bnds = bnds->tnOp.tnOp1; assert(bnds);
        }
        while (bnds->tnOper == TN_ARR_INIT);

        genOpcode_tok(CEE_NEWOBJ, genComp->cmpArrayCTtoken(type, elem, dcnt));

        /* The dimensions will all be popped by the 'new' opcode */

        genCurStkLvl -= dcnt;
    }
    else
    {
        rect = false;

        /* Generate the dimension and the "new" opcode */

        genIntConst(cntx->tnIntCon.tnIconVal);
        genOpcode_tok(CEE_NEWARR, genTypeRef(elem));

        if  (list == NULL)
        {
            assert(cntx->tnIntCon.tnIconVal == 0);
            return;
        }
    }

    /* Store the array address in a temp */

    tnum = genTempVarGet(type);
    genLclVarRef(tnum,  true);

    /* Figure out which opcode to use for storing the elements */

    assert(evtp < arraylen(opcodesArrStore));
    store = opcodesArrStore[evtp];

    /* Do we have a multi-dimensional rectangular array? */

    if  (type->tdArr.tdaDims &&
         type->tdArr.tdaDims->ddNext)
    {
        genMulDimArrInit(expr, type, type->tdArr.tdaDims, tnum, NULL, NULL);
        goto DONE;
    }

    /* Now assign each element of the array */

    for (index = 0; list; index++)
    {
        /* Load the array base and the element's index */

        genLclVarRef(tnum, false);
        genIntConst(index);

        /* Generate and store the element's value */

        assert(list->tnOper == TN_LIST);

        if  (evtp == TYP_CLASS)
        {
            Tree            addr;

            /* Push the address of the destination element */

            genOpcode_tok(CEE_LDELEMA, genValTypeRef(elem));

            /* Get hold of the initializer expression */

            addr = list->tnOp.tnOp1;

            if  (addr->tnOper == TN_NEW || addr->tnOper == TN_FNC_SYM)
            {
                /* The call/new will construct the value into the element */

                addr->tnFlags |= TNF_CALL_GOTADR;

                genCall(list->tnOp.tnOp1, true);

                if  (addr->tnOper == TN_FNC_SYM)
                    genOpcode_tok(CEE_STOBJ, genValTypeRef(elem));
            }
            else
            {
                unsigned        chk;

                /* Compute the address of the initializer and copy it */

                chk = genAdr(addr, true); assert(chk == 1);
                genOpcode_tok(CEE_CPOBJ, genValTypeRef(elem));
            }
        }
        else
        {
            genExpr(list->tnOp.tnOp1, true);
            genOpcode(store);
        }

        /* Move to the next element, if any */

        list = list->tnOp.tnOp2;
    }

    assert(index == (unsigned)cntx->tnIntCon.tnIconVal);

DONE:

    /* Finally, load the temp as the result and free it up */

    genLclVarRef(tnum, false);
    genTempVarRls(type, tnum);
}

/*****************************************************************************
 *
 *  Initialize the line# recording logic - called once per function.
 */

void                genIL::genLineNumInit()
{
    genLineNumList     =
    genLineNumLast     = NULL;

    genLineNumLastLine = 0;

    genLineNumLastBlk  = NULL;
    genLineNumLastOfs  = 0;

    genLineNums        = genComp->cmpConfig.ccLineNums |
                         genComp->cmpConfig.ccGenDebug;
}

/*****************************************************************************
 *
 *  Shut down  the line# recording logic - called once per function.
 */

inline
void                genIL::genLineNumDone()
{
}

/*****************************************************************************
 *
 *  If we're generating line number info, record the line# / MSIL offset
 *  for the given expression node.
 */

void                genIL::genRecExprAdr(Tree expr)
{
    LineInfo        line;

    /* Bail if we're not generating debug info */

    if  (!genLineNums)
        return;

    /* Ignore anything that was added by the compiler */

    if  (expr->tnFlags & TNF_NOT_USER)
        return;

    /* Weed out those statements that never generate code */

    switch (expr->tnOper)
    {
    case TN_TRY:
    case TN_LIST:
    case TN_BLOCK:
    case TN_CATCH:
    case TN_DCL_VAR:
        return;

    case TN_VAR_DECL:
        if  (!(expr->tnFlags & TNF_VAR_INIT))
            return;
        break;
    }

    assert(expr->tnLineNo != 0xDDDDDDDD);

    /* Bail if we have the same line# as last time */

    if  (genLineNumLastLine == expr->tnLineNo)
        return;

    /* Bail if the code position is the same as last time */

    if  (genLineNumLastBlk  == genBuffCurAddr() &&
         genLineNumLastOfs  == genBuffCurOffs())
    {
        return;
    }

#ifdef  DEBUG
//  if  (genDispCode) genDumpSourceLines(expr->tnLineNo);
#endif

//  printf("Record line# %u\n", expr->tnLineNo);

    /* Allocate a line# record and append it to the list */

#if MGDDATA
    line = new LineInfo;
#else
    line =    (LineInfo)genAlloc->nraAlloc(sizeof(*line));
#endif

    line->lndLineNum = genLineNumLastLine = expr->tnLineNo;

    line->lndBlkAddr = genLineNumLastBlk  = genBuffCurAddr();
    line->lndBlkOffs = genLineNumLastOfs  = genBuffCurOffs();

    line->lndNext    = NULL;

    if  (genLineNumLast)
        genLineNumLast->lndNext = line;
    else
        genLineNumList          = line;

    genLineNumLast = line;
}

/*****************************************************************************
 *
 *  Generate the line# table for the current function; returns the number
 *  of line number entries (if the argument[s] is/are NULL, this is just
 *  a 'dry run' to get the size of the table, no data is written).
 */

size_t              genIL::genLineNumOutput(unsigned *offsTab, unsigned *lineTab)
{
    LineInfo        line;

    int             offs;
    int             last = (unsigned)-1;

    assert(genLineNums);

    unsigned        count = 0;

    for (line = genLineNumList; line; line = line->lndNext)
    {
        offs = genCodeAddr(line->lndBlkAddr,
                           line->lndBlkOffs);

        if  (offs > last)
        {
            if  (offsTab)
            {
                assert(lineTab);

//              if  (!strcmp(genFncSym->sdParent->sdSpelling(), "Guid"))
//                  printf("    Line %04u is at MSIL offset 0x%04X\n", line->lndLineNum, offs);

                offsTab[count] = offs;
                lineTab[count] = line->lndLineNum;
            }

            last = offs;
            count++;
        }
    }

    return count;
}

/*****************************************************************************
 *
 *  Generate MSIL for a function - start.
 */

void                genIL::genFuncBeg(SymTab stab,
                                      SymDef fncSym, unsigned lclCnt)
{
    genStab   = stab;
    genFncSym = fncSym;

#if DISP_IL_CODE

    genDispCode      = genComp->cmpConfig.ccDispCode;
    genILblockLabNum = 0;

    if  (genDispCode)
    {
        printf("\nGenerating MSIL for '%s'\n", stab->stTypeName(fncSym->sdType, fncSym, NULL, NULL, true));
        printf("======================================================\n");
        printf("[offs:sl]");
        if  (genComp->cmpConfig.ccDispILcd)
            printf("%*s ", -(int)IL_OPCDSP_LEN, "");
        printf("\n");
        printf("======================================================\n");
    }

#endif

    genCurStkLvl     = 0;
    genILblockOffs   = 0;

    genEHtableInit();

    genTempVarBeg(lclCnt);
    genSectionBeg();

    genLineNumInit();
}

/*****************************************************************************
 *
 *  Generate MSIL for a function - finish up and return the function's RVA.
 */

unsigned            genIL::genFuncEnd(mdSignature sigTok, bool hadErrs)
{
    Compiler        comp = genComp;

    size_t          size;
    unsigned        fncRVA;

    size_t          EHsize;
    unsigned        EHcount;

    BYTE    *       codeAddr;

    /* Finish the last section of code */

    size = genSectionEnd();

    /* Shut down the temp logic */

    genTempVarEnd();

    /* Bail if we had errors */

    if  (hadErrs)
        return  0;

    /* Figure out how much space we will need */

    size_t                  tsiz = size;

    COR_ILMETHOD_FAT        hdr;
    size_t                  hdrs;
    size_t                  align;
    EH_CLAUSE_TAB           EHlist;
    bool                    addSects;

    /* Do we need any additional header sections? */

    addSects = false;

    /* Do we have any exception handlers? */

    EHcount = genEHtableCnt();
    if  (EHcount)
    {
        addSects = true;

        /* The extra section needs to be aligned */

        tsiz = roundUp(tsiz, sizeof(int));
    }

    /* Start filling in the method header */

    hdr.Flags          = (comp->cmpConfig.ccSafeMode) ? CorILMethod_InitLocals : 0;
    hdr.Size           = sizeof(hdr) / sizeof(int);
    hdr.MaxStack       = genMaxStkLvl;
    hdr.CodeSize       = size;
    hdr.LocalVarSigTok = sigTok;

    /* Compute the total header size */

    hdrs  = WRAPPED_IlmethodSize(&hdr, addSects);
    tsiz += hdrs;

    /* Reserve extra space for the EH tables */

    if  (EHcount)
    {
        /* Create the EH table */

#if MGDDATA
        EHlist = new EH_CLAUSE[EHcount];
#else
        EHlist = (EH_CLAUSE_TAB)genAlloc->nraAlloc(EHcount * sizeof(*EHlist));
#endif

        genEHtableWrt(EHlist);

        /* Now we can figure out the size of the thing */

        EHsize = WRAPPED_SectEH_SizeExact(EHcount, EHlist);
        tsiz   = roundUp(tsiz + EHsize);
    }
    else
        EHlist = NULL;

    /* Figure out the header alignment (tiny headers don't need any) */

    align = (hdrs == 1) ? 1 : sizeof(int);

    /* Allocate space in the code section of the output file */

    fncRVA = genPEwriter->WPEallocCode(tsiz, align, codeAddr);

//  if  (!strcmp(genFncSym->sdSpelling(), "xxxxx")) printf("RVA=%08X '%s'\n", fncRVA, genStab->stTypeName(NULL, genFncSym, NULL, NULL, true));

    if  (codeAddr)
    {
        BYTE    *           fnBase = codeAddr;

#if 0
        printf("Header is   at %08X\n", codeAddr);
        printf("Code starts at %08X\n", codeAddr + hdrs);
        printf("EHtable is  at %08X\n", codeAddr + hdrs + size);
        printf("Very end is at %08X\n", codeAddr + tsiz);
#endif

#ifdef  DEBUG
//      IMAGE_COR_ILMETHOD_FAT  * hdrPtr = (IMAGE_COR_ILMETHOD_FAT*)codeAddr;
#endif

        /* Emit the header and skip over it */

        codeAddr += WRAPPED_IlmethodEmit(hdrs, &hdr, addSects, codeAddr);

        /* Make sure the address is aligned properly */

#if 0
        printf("Base is at %08X\n", hdrPtr);
        printf("Code is at %08X\n", hdrPtr->GetCode());
        printf("Addr is at %08X\n", codeAddr);
#endif

//      assert(hdrPtr->GetCode() == codeAddr);      ISSUE: why does this fail?

#ifndef NDEBUG
        BYTE    *           codeBase = codeAddr;
#endif

        /* Store the MSIL next */

        codeAddr = genSectionCopy(codeAddr, codeAddr + fncRVA - fnBase);

        /* Make sure the we output the expected amount of code */

        assert(codeAddr == codeBase + size);

        /* Append the EH tables */

        if  (EHcount)
        {
            /* Make sure the EH table is aligned and output it */

            if  ((NatUns)codeAddr & 3)
                codeAddr += 4 - ((NatUns)codeAddr & 3);

            codeAddr += WRAPPED_SectEH_Emit(EHsize, EHcount, EHlist, false, codeAddr);
        }

        /* Make sure we've generated the right amount of junk */

#if 0
        printf("Header size = %u\n", hdrs);
        printf("Code   size = %u\n", size);
        printf("Total  size = %u\n", tsiz);
        printf("Actual size = %u\n", codeAddr - (BYTE *)hdrPtr);
#endif

        assert(codeAddr == fnBase + tsiz);
    }

    return  fncRVA;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\gencode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

#include "genIL.h"
#ifdef  OLD_IL
#include "oldIL.h"
#endif

/*****************************************************************************
 *
 *  Create/free a temporary local variable to be used for MSIL gen.
 */

SymDef              compiler::cmpTempVarMake(TypDef type)
{
    SymDef          tsym;

    /* Declare a temp symbol with the appropriate type */

    tsym = cmpGlobalST->stDeclareLcl(NULL, SYM_VAR, NS_NORM, cmpCurScp, &cmpAllocCGen);

    tsym->sdType         = type;
    tsym->sdIsImplicit   = true;
    tsym->sdIsDefined    = true;
    tsym->sdVar.sdvLocal = true;
    tsym->sdCompileState = CS_DECLARED;
    tsym->sdAccessLevel  = ACL_PUBLIC;

    /* Tell the MSIL generator about the temp */

    if  (type->tdTypeKind != TYP_VOID)
        cmpILgen->genTempVarNew(tsym);

    return  tsym;
}

void                compiler::cmpTempVarDone(SymDef tsym)
{
    cmpILgen->genTempVarEnd(tsym);
}

/*****************************************************************************
 *
 *  Bind and generate code for a "try" statement.
 */

void                compiler::cmpStmtTry(Tree stmt, Tree pref)
{
    ILblock         begPC;
    ILblock         endPC;
    ILblock         hndPC;

    bitset          iniVars;
    bitset          endVars;

    Tree            handList;

    stmtNestRec     nestStmt;

    ILblock         labDone;
    bool            endReach;

    assert(stmt->tnOper == TN_TRY);

    /* If we were given an extra statement, output it now */

    if  (pref)
    {
        cmpChkVarInitExpr(pref);
        cmpILgen->genExpr(pref, false);
    }

    /* Record the set of initialized variables at the beginning */

    if  (cmpChkVarInit)
        cmpBitSetCreate(iniVars, cmpVarsDefined);

    /* Insert the appropriate entry into the statement list */

    nestStmt.snStmtExpr = stmt;
    nestStmt.snStmtKind = TN_TRY;
    nestStmt.snLabel    = NULL;
    nestStmt.snHadCont  = false; cmpBS_bigStart(nestStmt.snDefBreak);
    nestStmt.snHadBreak = false; cmpBS_bigStart(nestStmt.snDefCont );
    nestStmt.snLabCont  = NULL;
    nestStmt.snLabBreak = NULL;
    nestStmt.snOuter    = cmpStmtNest;
                          cmpStmtNest = &nestStmt;

    /* Remember where the body of the try block started */

    begPC = cmpILgen->genBwdLab();

    /* Generate the body of the try block */

    cmpInTryBlk++;
    cmpStmt(stmt->tnOp.tnOp1);
    cmpInTryBlk--;

    /* We're out of the try block, into handlers now */

    cmpInHndBlk++;

    nestStmt.snStmtKind = TN_CATCH;

    /* Note whether the end of the try block was reachable */

    endReach = cmpStmtReachable;

    /* Record the set of initialized variables at the end of the "try" */

    if  (cmpChkVarInit)
        cmpBitSetCreate(endVars, cmpVarsDefined);

    /* Get hold of the handler list and see what kind of a handler we have */

    handList = stmt->tnOp.tnOp2;

    /* Create the label that we will jump to when the try is done */

    labDone = cmpILgen->genFwdLabGet();

    /* If the end of the try is reachable, jump past all of the handlers */

    if  (cmpStmtReachable)
        cmpILgen->genLeave(labDone);

    /* Remember where the body of the try block ended */

    endPC = cmpILgen->genBwdLab();

    /* In case we had an awful syntax error */

    if  (handList == NULL)
        goto FIN;

    /* Is this a "try/except" statement? */

    if  (handList->tnOper == TN_EXCEPT)
    {
        SymDef          tsym;

        ILblock         fltPC;

        Tree            filt = handList->tnOp.tnOp1;
        TypDef          type = cmpExceptRef();

        assert((stmt->tnFlags & TNF_BLK_HASFIN) == 0);

        /* Assume all the handlers are reachable */

        cmpStmtReachable = true;

        /* Set the known initialized variables to the "try" beginning */

        if  (cmpChkVarInit)
            cmpBitSetAssign(cmpVarsDefined, iniVars);

        /* Create a temp symbol to hold the exception object */

        tsym = cmpTempVarMake(type);

        /* Create a label for the filter expression */

        fltPC = cmpILgen->genBwdLab();

        /* Bind and generate the filter expression */

if  (cmpConfig.ccTgt64bit)
{
    printf("WARNING: tossing filter expression for 64-bit target\n");
    filt = cmpCreateIconNode(NULL, 1, TYP_INT);
}

        cmpFilterObj = tsym;
        cmpILgen->genFiltExpr(cmpCoerceExpr(cmpBindExpr(filt), cmpTypeInt, false), tsym);
        cmpFilterObj = NULL;

        /* If the end of any handler is reachable, so will be the end of the whole thing */

        endReach |= cmpStmtReachable;

        /* Set the known initialized variables to the "try" beginning */

        if  (cmpChkVarInit)
            cmpBitSetAssign(cmpVarsDefined, iniVars);

        /* Create a label for the handler block */

        hndPC = cmpILgen->genBwdLab();

        /* Start the except handler block */

        cmpILgen->genExcptBeg(tsym);

        /* Generate code for the handler itself */

        cmpStmt(handList->tnOp.tnOp2);

        /* Exit the catch block via "leave" */

        if  (cmpStmtReachable)
            cmpILgen->genLeave(labDone);

        /* Mark the end of the handler */

        cmpILgen->genCatchEnd(cmpStmtReachable);

        /* Add an entry for the 'except' to the table */

        cmpILgen->genEHtableAdd(begPC,
                                endPC,
                                fltPC,
                                hndPC,
                                cmpILgen->genBwdLab(),
                                NULL,
                                false);

        /* Release the temp */

        cmpTempVarDone(tsym);

        /* Form an intersection with current set of initialized variables */

        if  (cmpChkVarInit && cmpStmtReachable)
            cmpBitSetIntsct(endVars, cmpVarsDefined);

        goto DONE;
    }

    /* Process all catch blocks, if any are present */

    if  (handList->tnOper == TN_FINALLY)
        goto FIN;

    for (;;)
    {
        Tree            argDecl;
        TypDef          argType;

        Tree            handThis;

        /* Create a label for the catch block */

        hndPC = cmpILgen->genBwdLab();

        /* Assume all the handlers are reachable */

        cmpStmtReachable = true;

        /* Set the known initialized variables to the "try" beginning */

        if  (cmpChkVarInit)
            cmpBitSetAssign(cmpVarsDefined, iniVars);

        /* Get hold of the next handler */

        assert(handList->tnOper == TN_LIST);
        handThis = handList->tnOp.tnOp1;

        /* There might be a finally at the end */

        if  (handThis->tnOper != TN_CATCH)
        {
            assert(handThis->tnOper == TN_FINALLY);
            assert(handList->tnOp.tnOp2 == NULL);
            handList = handThis;
            break;
        }

        /* Get hold of the catch symbol declaration node */

        argDecl = handThis->tnOp.tnOp1;
        assert(argDecl->tnOper == TN_VAR_DECL);

        /* Get hold of the exception type */

        argType = argDecl->tnType; cmpBindType(argType, false, false);

        assert(argType->tdTypeKind == TYP_REF ||
               argType->tdTypeKind == TYP_UNDEF);

        // UNDONE: check for duplicate handler types!

        /* Generate the body of the 'catch' block */

        cmpBlock(handThis->tnOp.tnOp2, false);

        /* Mark the end of the handler */

        cmpILgen->genCatchEnd(cmpStmtReachable);

        /* Exit the catch block via "leave" */

        if  (cmpStmtReachable)
            cmpILgen->genLeave(labDone);

        /* Add an entry for the 'catch' to the table */

        cmpILgen->genEHtableAdd(begPC,
                                endPC,
                                NULL,
                                hndPC,
                                cmpILgen->genBwdLab(),
                                argType->tdRef.tdrBase,
                                false);

        /* If the end of any handler is reachable, so will be the end of the whole thing */

        endReach |= cmpStmtReachable;

        /* Form an intersection with current set of initialized variables */

        if  (cmpChkVarInit && cmpStmtReachable)
            cmpBitSetIntsct(endVars, cmpVarsDefined);

        /* Are there any more 'catch' clauses? */

        handList = handList->tnOp.tnOp2;
        if  (!handList)
            break;
    }

FIN:

    /* If there is a handler at this point, it must be a finally */

    if  (handList)
    {
        ILblock         hndPC;

        assert(handList->tnOper == TN_FINALLY);
        assert(handList->tnOp.tnOp2 == NULL);

        assert((stmt->tnFlags & TNF_BLK_HASFIN) != 0);

        /* Set the known initialized variables to the "try" beginning */

        if  (cmpChkVarInit)
            cmpBitSetAssign(cmpVarsDefined, iniVars);

        /* Generate the "finally" block itself */

        cmpInFinBlk++;

        hndPC = cmpILgen->genBwdLab();

        nestStmt.snStmtKind = TN_FINALLY;

        if  (pref)
        {
            cmpChkVarInitExpr(handList->tnOp.tnOp1);
            cmpILgen->genExpr(handList->tnOp.tnOp1, false);
        }
        else
            cmpStmt(handList->tnOp.tnOp1);

        cmpILgen->genEndFinally();

        cmpInFinBlk--;

        /* Add an entry for the "finally" to the EH tables */

        cmpILgen->genEHtableAdd(begPC,
                                hndPC,
                                NULL,
                                hndPC,
                                cmpILgen->genBwdLab(),
                                NULL,
                                true);

        /* Form an intersection with current set of initialized variables */

        if  (cmpChkVarInit && cmpStmtReachable)
        {
            /* Special case: compiler-added finally doesn't count */

            if  (!(handList->tnFlags & TNF_NOT_USER))
                cmpBitSetIntsct(endVars, cmpVarsDefined);
        }
    }
    else
    {
        assert((stmt->tnFlags & TNF_BLK_HASFIN) == 0);
    }

DONE:

    /* Define the 'done' label if necessary */

    if  (labDone)
        cmpILgen->genFwdLabDef(labDone);

    if  (cmpChkVarInit)
    {
        /* Switch to the intersection of all the sets */

        cmpBitSetAssign(cmpVarsDefined, endVars);

        /* Toss the saved "init" and the "ending" variable sets */

        cmpBitSetDone(iniVars);
        cmpBitSetDone(endVars);
    }

    /* Remove our entry from the statement list */

    cmpStmtNest = nestStmt.snOuter; cmpInHndBlk--;

    /* If the end of any of the blocks was reachable, so is this point */

    cmpStmtReachable = endReach;
}

/*****************************************************************************
 *
 *  Bind and generate code for a "do - while" loop.
 */

void                compiler::cmpStmtDo(Tree stmt, SymDef lsym)
{
    stmtNestRec     nestStmt;

    ILblock         labLoop;
    ILblock         labCont;
    ILblock         labBreak;

    Tree            condExpr;
    int             condVal;

    assert(stmt->tnOper == TN_DO);

    /* Create the 'loop top', 'break' and 'continue' labels */

    labLoop  = cmpILgen->genBwdLab();
    labCont  = cmpILgen->genFwdLabGet();
    labBreak = cmpILgen->genFwdLabGet();

    /* Insert the appropriate entry into the statement list */

    nestStmt.snStmtExpr = stmt;
    nestStmt.snStmtKind = TN_DO;
    nestStmt.snLabel    = lsym;
    nestStmt.snHadCont  = false; cmpBS_bigStart(nestStmt.snDefBreak);
    nestStmt.snHadBreak = false; cmpBS_bigStart(nestStmt.snDefCont );
    nestStmt.snLabCont  = labCont;
    nestStmt.snLabBreak = labBreak;
    nestStmt.snOuter    = cmpStmtNest;
                          cmpStmtNest = &nestStmt;

    /* Generate the body of the loop */

    cmpStmt(stmt->tnOp.tnOp1);

    /* Remove our entry from the statement list */

    cmpStmtNest = nestStmt.snOuter;

    /* Define the 'continue' label */

    cmpILgen->genFwdLabDef(labCont);

    /* Did we have "continue" and are we checking for uninitialized var use? */

    if  (cmpChkVarInit && nestStmt.snHadCont)
    {
        /* Compute the definition set at the condition */

        cmpBitSetIntsct(cmpVarsDefined, nestStmt.snDefCont);

        /* We can free up the "continue" bitset now */

        cmpBitSetDone(nestStmt.snDefCont);
    }

    /* Test the condition and jump to the top if true */

    condExpr = cmpBindCondition(stmt->tnOp.tnOp2);
    condVal  = cmpEvalCondition(condExpr);

    switch (condVal)
    {
    case -1:

        /* The loop will never be repeated */

        break;

    case 0:

        /* The loop may or not be repeated, we'll generate a conditional jump */

        if  (cmpChkVarInit)
        {
            bitset          tempBS;

            /* Check the condition and note the 'false' set */

            cmpCheckUseCond(condExpr, cmpVarsIgnore, true, tempBS, false);

            /* Generate the conditional jump */

            cmpILgen->genExprTest(condExpr, true, true, labLoop, labBreak);

            /* Use the 'false' set for the code that follows the loop */

            cmpBitSetAssign(cmpVarsDefined, tempBS);

            /* Free up the bitset now */

            cmpBitSetDone(tempBS);
        }
        else
            cmpILgen->genExprTest(condExpr, true, true, labLoop, labBreak);

        break;

    case 1:

        /* The loop will repeat forever */

        cmpILgen->genJump(labLoop);
        break;
    }

    /* Define the 'break' label */

    cmpILgen->genFwdLabDef(labBreak);

    /* Code after the loop is reachable unless the condition is 'forever' */

    cmpStmtReachable = (condVal != 1);

    /* Code after the loop is also reachable if there was a break */

    if  (nestStmt.snHadBreak)
    {
        cmpStmtReachable = true;

        /* Are we checking for uninitialized variable use? */

        if  (cmpChkVarInit)
        {
            /* Intersect with the "break" definition set */

            cmpBitSetIntsct(cmpVarsDefined, nestStmt.snDefBreak);

            /* Free up the "break" bitset */

            cmpBitSetDone(nestStmt.snDefBreak);
        }
    }
}

/*****************************************************************************
 *
 *  Compile a "for" statement.
 */

void                compiler::cmpStmtFor(Tree stmt, SymDef lsym)
{
    Tree            initExpr;
    Tree            condExpr;
    Tree            incrExpr;
    Tree            bodyExpr;

    stmtNestRec     nestStmt;

    ILblock         labLoop;
    ILblock         labTest;
    ILblock         labCont;
    ILblock         labBreak;

    int             condVal;

    bitset          tempBS;

    SymDef          outerScp = cmpCurScp;

    assert(stmt->tnOper == TN_FOR);

    /* Get hold of the various pieces of the 'for' statement tree */

    assert(stmt->tnOp.tnOp1->tnOper == TN_LIST);
    assert(stmt->tnOp.tnOp2->tnOper == TN_LIST);

    initExpr = stmt->tnOp.tnOp1->tnOp.tnOp1;
    condExpr = stmt->tnOp.tnOp1->tnOp.tnOp2;
    incrExpr = stmt->tnOp.tnOp2->tnOp.tnOp1;
    bodyExpr = stmt->tnOp.tnOp2->tnOp.tnOp2;

    /* Get the initial tree and see if it's a statement or declaration */

    if  (initExpr)
    {
        if  (initExpr->tnOper == TN_BLOCK)
        {
            /* We have declaration(s), create a block scope */

            cmpBlockDecl(initExpr, false, true, false);
        }
        else
        {
            initExpr = cmpFoldExpression(cmpBindExpr(initExpr));
            cmpChkVarInitExpr(initExpr);
            cmpILgen->genExpr(initExpr, false);
        }
    }

    /* Create the 'cond test', 'break' and 'continue' labels */

    labTest  = cmpILgen->genFwdLabGet();
    labCont  = cmpILgen->genFwdLabGet();
    labBreak = cmpILgen->genFwdLabGet();

    /* Bind the loop condition */

    if  (condExpr)
    {
        condExpr = cmpBindCondition(condExpr);
        condVal  = cmpEvalCondition(condExpr);
    }
    else
    {
        condVal  = 1;
    }

    /* Jump to the 'test' label (unless the condition is initially true) */

    if  (condVal < 1)
        cmpILgen->genJump(labTest);

    /* Are we checking for uninitialized variable use? */

    if  (cmpChkVarInit)
    {
        if  (condVal)
        {
            /* The condition's outcome is known, just check it */

            if  (condExpr)
                cmpChkVarInitExpr(condExpr);
        }
        else
        {
            /* Check the condition and record the 'false' set */

            cmpCheckUseCond(condExpr, cmpVarsIgnore, true, tempBS, false);
        }
    }

    /* Create and define the 'loop top' label */

    labLoop = cmpILgen->genBwdLab();

    /* Insert the appropriate entry into the statement list */

    nestStmt.snStmtExpr = stmt;
    nestStmt.snStmtKind = TN_FOR;
    nestStmt.snLabel    = lsym;
    nestStmt.snHadCont  = false; cmpBS_bigStart(nestStmt.snDefBreak);
    nestStmt.snHadBreak = false; cmpBS_bigStart(nestStmt.snDefCont );
    nestStmt.snLabCont  = labCont;
    nestStmt.snLabBreak = labBreak;
    nestStmt.snOuter    = cmpStmtNest;
                          cmpStmtNest = &nestStmt;

    /* The body is reachable unless the condition is 'never' */

    cmpStmtReachable = (condVal != -1);

    /* Generate the body of the loop */

    if  (bodyExpr)
        cmpStmt(bodyExpr);

    /* Remove our entry from the statement list */

    cmpStmtNest = nestStmt.snOuter;

    /* Define the 'continue' label */

    cmpILgen->genFwdLabDef(labCont);

    /* Toss the "continue" set if one was computed */

    if  (cmpChkVarInit && nestStmt.snHadCont)
        cmpBitSetDone(nestStmt.snDefCont);

    /* Generate the increment expression, if present */

    if  (incrExpr)
    {
#ifdef  OLD_IL
        if  (cmpConfig.ccOILgen)
            cmpOIgen->GOIrecExprPos(incrExpr);
        else
#endif
            cmpILgen->genRecExprPos(incrExpr);

        incrExpr = cmpBindExpr(incrExpr);
        cmpChkVarInitExpr(incrExpr);
        cmpILgen->genExpr(incrExpr, false);
    }

    /* Define the 'cond test' label */

    cmpILgen->genFwdLabDef(labTest);

    /* Test the condition and jump to the top if true */

    if  (condExpr)
    {
#ifdef  OLD_IL
        if  (cmpConfig.ccOILgen)
            cmpOIgen->GOIrecExprPos(condExpr);
        else
#endif
            cmpILgen->genRecExprPos(condExpr);

        cmpILgen->genExprTest(condExpr, true, true, labLoop, labBreak);
    }
    else
    {
        cmpILgen->genJump(labLoop);
    }

    /* Define the 'break' label */

    cmpILgen->genFwdLabDef(labBreak);

    /*
        The code after the loop will be reachable if the loop condition
        is not 'forever', or if 'break' was present within the loop.
     */

    cmpStmtReachable = (condVal != 1 || nestStmt.snHadBreak);

    /* Are we checking for uninitialized variable use? */

    if  (cmpChkVarInit)
    {
        /* Intersect with the "break" definition set, if have one */

        if  (nestStmt.snHadBreak)
        {
            cmpBitSetIntsct(cmpVarsDefined, nestStmt.snDefBreak);
            cmpBitSetDone(nestStmt.snDefBreak);
        }

        /* Intersect with the "false" bit from the condition */

        if  (!condVal)
        {
            cmpBitSetIntsct(cmpVarsDefined, tempBS);
            cmpBitSetDone(tempBS);
        }
    }

    /* For debug info, close a lexical scope if one was opened */

    if  (cmpConfig.ccGenDebug && cmpCurScp != outerScp
                              && !cmpCurFncSym->sdIsImplicit)
    {
        if  (cmpSymWriter->CloseScope(0))
            cmpGenFatal(ERRdebugInfo);

        cmpCurScp->sdScope.sdEndBlkAddr = cmpILgen->genBuffCurAddr();
        cmpCurScp->sdScope.sdEndBlkOffs = cmpILgen->genBuffCurOffs();
    }

    /* Remove the block if we created one for the loop */

    cmpCurScp = outerScp;
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  Compile a "foreach" statement.
 */

void                compiler::cmpStmtForEach(Tree stmt, SymDef lsym)
{
    Tree            declExpr;
    Tree            collExpr;
    Tree            bodyExpr;
    Tree            ivarExpr;

    TypDef          collType;
    TypDef          elemType;

    stmtNestRec     nestStmt;

    ILblock         labLoop;
    ILblock         labTest;
    ILblock         labCont;
    ILblock         labBreak;

    SymDef          iterSym;

    bitset          tempBS;

    SymDef          outerScp = cmpCurScp;

    assert(stmt->tnOper == TN_FOREACH);

    /* Get hold of the various pieces of the 'foreach' statement tree */

    assert(stmt->tnOp.tnOp1->tnOper == TN_LIST);

    declExpr = stmt->tnOp.tnOp1->tnOp.tnOp1;
    collExpr = stmt->tnOp.tnOp1->tnOp.tnOp2;
    bodyExpr = stmt->tnOp.tnOp2;

    /* Bind the collection expression and make sure it looks kosher */

    collExpr = cmpBindExprRec(collExpr);

    if  (collExpr->tnVtyp != TYP_REF)
    {
        if  (collExpr->tnVtyp != TYP_UNDEF)
        {
        BAD_COLL:

            cmpError(ERRnotCollExpr, collExpr->tnType);
        }

        elemType = cmpGlobalST->stNewErrType(NULL);
        goto GOT_COLL;
    }

    collType = collExpr->tnType;
    elemType = cmpIsCollection(collType->tdRef.tdrBase);
    if  (!elemType)
        goto BAD_COLL;

    assert(elemType->tdTypeKind == TYP_CLASS);

    elemType = elemType->tdClass.tdcRefTyp;

#ifdef DEBUG

    if  (cmpConfig.ccVerbose >= 2)
    {
        printf("Foreach -- collection:\n");
        cmpParser->parseDispTree(collExpr);
    }

#endif

GOT_COLL:

    /* Set the type of the loop iteration variable */

    assert(declExpr && declExpr->tnOper == TN_BLOCK);

    ivarExpr = declExpr->tnBlock.tnBlkDecl;

    assert(ivarExpr && ivarExpr->tnOper == TN_VAR_DECL);

    ivarExpr->tnType = elemType;

    /* Create a block scope for the iteration variable */

    cmpBlockDecl(declExpr, false, true, false);

    /* We can now "compile" the variable declaration */

    cmpStmt(ivarExpr);

    /* We don't need to check for initialization of the loop iteration variable */

    ivarExpr->tnDcl.tnDclSym->sdVar.sdvChkInit = false;

    /* Create the 'cond test', 'break' and 'continue' labels */

    labTest  = cmpILgen->genFwdLabGet();
    labCont  = cmpILgen->genFwdLabGet();
    labBreak = cmpILgen->genFwdLabGet();

    /* Declare the iterator state variable */

    assert(cmpClassForEach && "can't use foreach unless you supply 'System.$foreach'");

    iterSym  = cmpTempVarMake(cmpClassForEach->sdType);

    /* Initialize the iteration state */

    cmpILgen->genVarAddr(iterSym);

    if  (cmpFNsymForEachCtor == NULL)
         cmpFNsymForEachCtor = cmpGlobalST->stLookupOper(OVOP_CTOR_INST, cmpClassForEach);

    assert(cmpFNsymForEachCtor);
    assert(cmpFNsymForEachCtor->sdFnc.sdfNextOvl == NULL);

    cmpILgen->genExpr(collExpr, true);

    cmpILgen->genCallFnc(cmpFNsymForEachCtor, 2);

    /* Remember the initialized variables before the loop starts */

    if  (cmpChkVarInit)
        cmpBitSetCreate(tempBS, cmpVarsDefined);

    /* Jump to the 'test' label */

    cmpILgen->genJump(labTest);

    /* Create and define the 'loop top' label */

    labLoop = cmpILgen->genBwdLab();

    /* Insert the appropriate entry into the statement list */

    nestStmt.snStmtExpr = stmt;
    nestStmt.snStmtKind = TN_FOREACH;
    nestStmt.snLabel    = lsym;
    nestStmt.snHadCont  = false; cmpBS_bigStart(nestStmt.snDefBreak);
    nestStmt.snHadBreak = false; cmpBS_bigStart(nestStmt.snDefCont );
    nestStmt.snLabCont  = labCont;
    nestStmt.snLabBreak = labBreak;
    nestStmt.snOuter    = cmpStmtNest;
                          cmpStmtNest = &nestStmt;

    /* Assume that the body is always reachable */

    cmpStmtReachable = true;

    /* Generate the body of the loop */

    if  (bodyExpr)
        cmpStmt(bodyExpr);

    /* Remove our entry from the statement list */

    cmpStmtNest = nestStmt.snOuter;

    /* Define the 'continue' label */

    cmpILgen->genFwdLabDef(labCont);

    /* Toss the "continue" set if one was computed */

    if  (cmpChkVarInit && nestStmt.snHadCont)
        cmpBitSetDone(nestStmt.snDefCont);

    /* Define the 'cond test' label */

    cmpILgen->genFwdLabDef(labTest);

    /* Generate the code that will check whether the loop is to continue */

    if  (cmpFNsymForEachMore == NULL)
         cmpFNsymForEachMore = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString("more"), cmpClassForEach);

    assert(cmpFNsymForEachMore);
    assert(cmpFNsymForEachMore->sdFnc.sdfNextOvl == NULL);

    cmpILgen->genVarAddr(iterSym);
    cmpILgen->genVarAddr(ivarExpr->tnDcl.tnDclSym);

    cmpILgen->genCallFnc(cmpFNsymForEachMore, 1);

    cmpILgen->genJcnd(labLoop, CEE_BRTRUE);

    cmpTempVarDone(iterSym);

    /* Define the 'break' label */

    cmpILgen->genFwdLabDef(labBreak);

    /* The code after the loop will be reachable if there was a break */

    cmpStmtReachable |= nestStmt.snHadBreak;

    /* Are we checking for uninitialized variable use? */

    if  (cmpChkVarInit)
    {
        /* Intersect with the "break" definition set, if have one */

        if  (nestStmt.snHadBreak)
        {
            cmpBitSetIntsct(cmpVarsDefined, nestStmt.snDefBreak);
            cmpBitSetDone(nestStmt.snDefBreak);
        }

        /* Intersect with the initial bitset */

        cmpBitSetIntsct(cmpVarsDefined, tempBS);
        cmpBitSetDone(tempBS);
    }

    /* For debug info, close a lexical scope if one was opened */

    if  (cmpConfig.ccGenDebug && cmpCurScp != outerScp
                              && !cmpCurFncSym->sdIsImplicit)
    {
        if  (cmpSymWriter->CloseScope(0))
            cmpGenFatal(ERRdebugInfo);

        cmpCurScp->sdScope.sdEndBlkAddr = cmpILgen->genBuffCurAddr();
        cmpCurScp->sdScope.sdEndBlkOffs = cmpILgen->genBuffCurOffs();
    }

    /* Remove the block if we created one for the loop */

    cmpCurScp = outerScp;
}

/*****************************************************************************
 *
 *  Compile a "connect" statement.
 */

void                compiler::cmpStmtConnect(Tree stmt)
{
    Tree              op1,   op2;
    Tree            expr1, expr2;
    SymDef          attr1, attr2;
    TypDef          elem1, elem2;
    TypDef          coll1, coll2;
    TypDef          base1, base2;
    SymDef          addf1, addf2;

    bool            isSet;

    assert(stmt->tnOper == TN_CONNECT);

    /* Bind the two sub-operands and make sure we have collections */

    op1 = cmpBindExpr(stmt->tnOp.tnOp1); cmpChkVarInitExpr(op1);
    op2 = cmpBindExpr(stmt->tnOp.tnOp2); cmpChkVarInitExpr(op2);

    /*
        There are two possibilities - either the two things being
        joined are property getters, or they are data members:

        Properties:

                (type=title)     lcl var  sym='t'
             (type=bag<author>)    function 'get_writtenBy'

                (type=author)     lcl var  sym='a'
             (type=bag<title>)    function 'get_wrote'

        Data members:

                (type=title)     lcl var  sym='t'
             (type=bag<author>)    variable  sym='pubsDS.title.writtenBy'

                (type=author)     lcl var  sym='a'
             (type=bag<title>)    variable  sym='pubsDS.author.wrote'
     */

    switch (op1->tnOper)
    {
    case TN_FNC_SYM:

        if  (op1->tnFncSym.tnFncArgs)
        {
        BAD_OP1:
            cmpError(ERRbadConnOps);
            return;
        }

        attr1 = op1->tnFncSym.tnFncSym; assert(attr1->sdSymKind == SYM_FNC);

        if  (!attr1->sdFnc.sdfProperty)
            goto BAD_OP1;

        attr1 = cmpFindPropertyDM(attr1, &isSet);
        if  (attr1 == NULL || isSet)
            goto BAD_OP1;

        assert(attr1->sdSymKind == SYM_PROP);

        expr1 = op1->tnFncSym.tnFncObj;
        break;

    case TN_VAR_SYM:
        attr1 = op1->tnLclSym.tnLclSym; assert(attr1->sdSymKind == SYM_VAR);
        if  (attr1->sdIsStatic)
            goto BAD_OP1;
        expr1 = op1->tnVarSym.tnVarObj;
        break;

    default:
        goto BAD_OP1;
    }

    if  (!expr1)
        goto BAD_OP1;

    switch (op2->tnOper)
    {
    case TN_FNC_SYM:

        if  (op2->tnFncSym.tnFncArgs)
        {
        BAD_OP2:
            cmpError(ERRbadConnOps);
            return;
        }

        attr2 = op2->tnFncSym.tnFncSym; assert(attr2->sdSymKind == SYM_FNC);

        if  (!attr2->sdFnc.sdfProperty)
            goto BAD_OP1;

        attr2 = cmpFindPropertyDM(attr2, &isSet);
        if  (attr2 == NULL || isSet)
            goto BAD_OP1;

        assert(attr2->sdSymKind == SYM_PROP);

        expr2 = op2->tnFncSym.tnFncObj;
        break;

    case TN_VAR_SYM:
        attr2 = op2->tnLclSym.tnLclSym; assert(attr2->sdSymKind == SYM_VAR);
        if  (attr2->sdIsStatic)
            goto BAD_OP2;
        expr2 = op2->tnVarSym.tnVarObj;
        break;

    default:
        goto BAD_OP2;
    }

    if  (!expr2)
        goto BAD_OP1;

#ifdef DEBUG
//  printf("Prop/field '%s' off of:\n", attr1->sdSpelling()); cmpParser->parseDispTree(expr1); printf("\n");
//  printf("Prop/field '%s' off of:\n", attr2->sdSpelling()); cmpParser->parseDispTree(expr2); printf("\n");
#endif

    /*
        What we should have at this point is the following:

            expr1       instance of class1
            expr2       instance of class2

            attr1       field/property of class1 whose type is bag<class2>
            attr2       field/property of class2 whose type is bag<class1>

        First check and get hold of the expression types.
     */

    elem1 = expr1->tnType;
    if  (elem1->tdTypeKind != TYP_REF)
        goto BAD_OP1;
    elem1 = elem1->tdRef.tdrBase;

    elem2 = expr2->tnType;
    if  (elem2->tdTypeKind != TYP_REF)
        goto BAD_OP2;
    elem2 = elem2->tdRef.tdrBase;

    /* Now check and get hold of the collection types */

    coll1 = attr1->sdType;
    if  (coll1->tdTypeKind != TYP_REF)
        goto BAD_OP1;
    coll1 = coll1->tdRef.tdrBase;
    base1 = cmpIsCollection(coll1);
    if  (!base1)
        goto BAD_OP1;

    coll2 = attr2->sdType;
    if  (coll2->tdTypeKind != TYP_REF)
        goto BAD_OP2;
    coll2 = coll2->tdRef.tdrBase;
    base2 = cmpIsCollection(coll2);
    if  (!base2)
        goto BAD_OP2;

    /* Make sure the types match as expected */

    if  (!cmpGlobalST->stMatchTypes(elem1, base2) ||
         !cmpGlobalST->stMatchTypes(elem2, base1))
    {
        cmpError(ERRbadConnOps);
        return;
    }

    /* Both collections must have an operator+= defined */

    addf1 = cmpGlobalST->stLookupOperND(OVOP_ASG_ADD, coll1->tdClass.tdcSymbol);
    if  (!addf1)
    {
        cmpGenError(ERRnoOvlOper, "+=", coll1->tdClass.tdcSymbol->sdSpelling());
        return;
    }

    addf2 = cmpGlobalST->stLookupOperND(OVOP_ASG_ADD, coll2->tdClass.tdcSymbol);
    if  (!addf2)
    {
        cmpGenError(ERRnoOvlOper, "+=", coll2->tdClass.tdcSymbol->sdSpelling());
        return;
    }

    /*
        Assume we have the following statement:

            connect( expr1.attr1 , expr2.attr2 );

        We need to generate the following code:

            expr1.attr1 += expr2;
            expr1.attr2 += expr1;
     */

    cmpILgen->genConnect(op1, expr1, addf1,
                         op2, expr2, addf2);
}

/*****************************************************************************
 *
 *  Compile a sort funclet.
 */

void                compiler::cmpStmtSortFnc(Tree sortList)
{
    bool            last = false;

    assert(sortList);

    do
    {
        Tree            sortTerm;
        Tree            sortVal1;
        Tree            sortVal2;

        assert(sortList->tnOper == TN_LIST);

        sortTerm = sortList->tnOp.tnOp1;
        sortList = sortList->tnOp.tnOp2;

        assert(sortTerm->tnOper == TN_LIST);

        sortVal1 = sortTerm->tnOp.tnOp1;
        sortVal2 = sortTerm->tnOp.tnOp2;

        /* Flip the values if the order is reversed */

        if  (sortTerm->tnFlags & TNF_LIST_DES)
        {
            sortVal1 = sortTerm->tnOp.tnOp2;
            sortVal2 = sortTerm->tnOp.tnOp1;
        }

//      printf("Sort value 1:\n"); cmpParser->parseDispTree(sortVal1);
//      printf("Sort value 2:\n"); cmpParser->parseDispTree(sortVal2);
//      printf("\n");

        /* Is this the last sort term ? */

        if  (!sortList)
            last = true;

        /* Is the value a string or an arithmetic value? */

        if  (varTypeIsArithmetic(sortVal1->tnVtypGet()))
        {
            /* Check the difference and return if non-zero */

            cmpILgen->genSortCmp(sortVal1, sortVal2, last);
        }
        else
        {
            Tree            sortCall;

            assert(sortVal1->tnType == cmpStringRef());
            assert(sortVal2->tnType == cmpStringRef());

            /* To compare two strings we simply call "String::Compare" */

            if  (!cmpCompare2strings)
            {
                ArgDscRec       args;
                TypDef          type;
                SymDef          csym;

                /* Create the argument list: (String,String) */

                cmpParser->parseArgListNew(args,
                                           2,
                                           false, cmpRefTpString,
                                                  cmpRefTpString,
                                                  NULL);

                /* Create the function type and find the matching method */

                type = cmpGlobalST->stNewFncType(args, cmpTypeInt);
                csym = cmpGlobalST->stLookupClsSym(cmpGlobalHT->hashString("Compare"), cmpClassString); assert(csym);
                csym = cmpCurST->stFindOvlFnc(csym, type); assert(csym);

                /* Remember the method for later (repeated) use */

                cmpCompare2strings = csym;
            }

            sortVal2 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, sortVal2, NULL);
            sortVal1 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, sortVal1, sortVal2);

            sortCall = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpTypeInt);
            sortCall->tnFncSym.tnFncSym  = cmpCompare2strings;
            sortCall->tnFncSym.tnFncArgs = sortVal1;
            sortCall->tnFncSym.tnFncObj  = NULL;

            cmpILgen->genSortCmp(sortCall, NULL, last);
        }
    }
    while (!last);

    cmpStmtReachable = false;
}

/*****************************************************************************
 *
 *  Compile a project funclet.
 */

void                compiler::cmpStmtProjFnc(Tree body)
{
    TypDef          tgtType;
    SymDef          tgtCtor;

    SymDef          memSym;

    assert(body && body->tnOper == TN_LIST);

//  cmpParser->parseDispTree(body);
//  printf("\n\nIn funclet %s\n", cmpGlobalST->stTypeName(cmpCurFncSym->sdType, cmpCurFncSym, NULL, NULL, false));

    /*
        The "body" expression is simply the list of member initializers
        for the projected instance. We'll allocate a new instance of the
        target type and then initialize its fields from the expressions.

        In other words, the code will look like the following:

            new   <target type>

            for each target member

                dup
                <initializer>
                stfld

            ret
     */

    tgtType = body->tnType; assert(tgtType && tgtType->tdTypeKind == TYP_CLASS);

    /* Find the default ctor for the target type */

    tgtCtor = cmpFindCtor(tgtType, false); assert(tgtCtor && !tgtCtor->sdFnc.sdfNextOvl);

    /* Allocatet the new instance */

    cmpILgen->genCallNew(tgtCtor, 0);

    /* Now assign all the members of the newly allocated object */

    for (memSym = tgtType->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        if  (memSym->sdSymKind  == SYM_VAR &&
             memSym->sdIsStatic == false   &&
             memSym->sdVar.sdvInitExpr)
        {
            Tree            init;

            assert(body && body->tnOper == TN_LIST);

            init = body->tnOp.tnOp1;
            body = body->tnOp.tnOp2;

//          printf("Initialize member '%s':\n", memSym->sdSpelling());
//          cmpParser->parseDispTree(init);
//          printf("\n");

            cmpILgen->genStoreMember(memSym, init);
        }
    }

    /* Make sure we've consumed all the initializers */

    assert(body == NULL);

    cmpILgen->genRetTOS();

    cmpStmtReachable = false;
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  Bind and generate code for an "exclusive" statement.
 */

void                compiler::cmpStmtExcl(Tree stmt)
{
    SymDef          tsym;
    TypDef          type;

    Tree            argx;
    Tree            objx;
    Tree            begx;
    Tree            endx;
    Tree            hndx;

    assert(stmt->tnOper == TN_EXCLUDE);

    /*
        We implement this by transforming "exclusive(obj) { stmt }" into
        the following:

            temp = obj;
            CriticalSection::Enter(temp);

            try
            {
                stmt;
            }
            finally
            {
                CriticalSection::Exit(temp);
            }
     */

    objx = cmpBindExpr(stmt->tnOp.tnOp1);
    type = objx->tnType;

    /* Make sure the type is acceptable */

    if  (type->tdTypeKind != TYP_REF && (type->tdTypeKind != TYP_ARRAY || !type->tdIsManaged))
    {
        if  (type->tdTypeKind != TYP_UNDEF)
            cmpError(ERRnotClsVal, type);

        return;
    }

    /* Create a temp symbol to hold the synchronization object */

    tsym = cmpTempVarMake(type);

    /* Create the "critsect enter/exit" expressions */

    if  (!cmpFNsymCSenter)
    {
        /* Make sure we have the "" class type */

        cmpMonitorRef();

        /* Locate the helper methods in the class */

        cmpFNsymCSenter = cmpGlobalST->stLookupClsSym(cmpIdentEnter, cmpClassMonitor);
        assert(cmpFNsymCSenter && cmpFNsymCSenter->sdFnc.sdfNextOvl == NULL);

        cmpFNsymCSexit  = cmpGlobalST->stLookupClsSym(cmpIdentExit , cmpClassMonitor);
        assert(cmpFNsymCSexit  && cmpFNsymCSexit ->sdFnc.sdfNextOvl == NULL);
    }

    argx = cmpCreateVarNode (NULL, tsym);
    argx = cmpCreateExprNode(NULL, TN_ASG ,        type, argx, objx);
    argx = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argx, NULL);

    begx = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpTypeVoid);
    begx->tnFncSym.tnFncSym  = cmpFNsymCSenter;
    begx->tnFncSym.tnFncArgs = argx;
    begx->tnFncSym.tnFncObj  = NULL;
    begx->tnFlags           |= TNF_NOT_USER;

    argx = cmpCreateVarNode (NULL, tsym);
    argx = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argx, NULL);

    endx = cmpCreateExprNode(NULL, TN_FNC_SYM, cmpTypeVoid);
    endx->tnFncSym.tnFncSym  = cmpFNsymCSexit;
    endx->tnFncSym.tnFncArgs = argx;
    endx->tnFncSym.tnFncObj  = NULL;
    endx->tnFlags           |= TNF_NOT_USER;

    /* Create the 'try/finally' block and generate code for it */

    hndx = cmpCreateExprNode(NULL, TN_FINALLY , cmpTypeVoid, endx, NULL);
    hndx->tnFlags |= TNF_NOT_USER;
    hndx = cmpCreateExprNode(NULL, TN_TRY     , cmpTypeVoid, stmt->tnOp.tnOp2, hndx);
    hndx->tnFlags |= TNF_BLK_HASFIN;

    cmpStmtTry(hndx, begx);

    /* Release the temp */

    cmpTempVarDone(tsym);
}

/*****************************************************************************
 *
 *  Compile a "while" statement.
 */

void                compiler::cmpStmtWhile(Tree stmt, SymDef lsym)
{
    ILblock         labCont;
    ILblock         labBreak;
    ILblock         labLoop;

    Tree            condExpr;
    int             condVal;

    bitset          tempBS;

    stmtNestRec     nestStmt;

    assert(stmt->tnOper == TN_WHILE);

    /* Create the 'break' and 'continue' labels */

    labBreak = cmpILgen->genFwdLabGet();
    labCont  = cmpILgen->genFwdLabGet();

    /* Can the condition be evaluated at compile time? */

    condExpr = cmpBindCondition(stmt->tnOp.tnOp1);
    condVal  = cmpEvalCondition(condExpr);

    /* Could the condition ever be false? */

    if  (condVal < 1)
    {
        /* Jump to the 'continue' label */

        cmpILgen->genJump(labCont);
    }

    /* Are we checking for uninitialized variable use? */

    if  (cmpChkVarInit)
    {
        if  (condVal)
        {
            /* The condition's outcome is known, just check it */

            cmpChkVarInitExpr(condExpr);
        }
        else
        {
            /* Check the condition and record the 'false' set */

            cmpCheckUseCond(condExpr, cmpVarsIgnore, true, tempBS, false);
        }
    }

    /* Create and define the 'loop top' label */

    labLoop = cmpILgen->genBwdLab();

    /* Insert our context into the context list */

    nestStmt.snStmtExpr = stmt;
    nestStmt.snStmtKind = TN_WHILE;
    nestStmt.snLabel    = lsym;
    nestStmt.snHadCont  = false; cmpBS_bigStart(nestStmt.snDefBreak);
    nestStmt.snHadBreak = false; cmpBS_bigStart(nestStmt.snDefCont );
    nestStmt.snLabCont  = labCont;
    nestStmt.snLabBreak = labBreak;
    nestStmt.snOuter    = cmpStmtNest;
                          cmpStmtNest = &nestStmt;

    /* Generate the body of the loop */

    if  (stmt->tnOp.tnOp2)
        cmpStmt(stmt->tnOp.tnOp2);

    /* Remove our context from the context list */

    cmpStmtNest = nestStmt.snOuter;

    /* Define the 'continue' label */

    cmpILgen->genFwdLabDef(labCont);

    /* Toss the "continue" set if one was computed */

    if  (cmpChkVarInit && nestStmt.snHadCont)
        cmpBitSetDone(nestStmt.snDefCont);

    /* Is the condition always true? */

    switch (condVal)
    {
    case 0:

        /* Test the condition and end the loop if false */

        cmpILgen->genExprTest(condExpr, true, true, labLoop, labBreak);

        /* Whenever the condition is false we'll skip over the loop, of course */

        cmpStmtReachable = true;
        break;

    case -1:

        /* Condition never true, don't bother looping */

        cmpILgen->genSideEff(condExpr);
        break;

    case 1:

        /* Condition always true, loop every time */

        cmpILgen->genJump(labLoop);
        cmpStmtReachable = false;
        break;
    }

    /* Define the 'break' label */

    cmpILgen->genFwdLabDef(labBreak);

    /* Code after the loop is also reachable if there was a break */

    if  (nestStmt.snHadBreak)
        cmpStmtReachable = true;

    /* Are we checking for uninitialized variable use? */

    if  (cmpChkVarInit)
    {
        /* Intersect with the "break" definition set, if have one */

        if  (nestStmt.snHadBreak)
        {
            cmpBitSetIntsct(cmpVarsDefined, nestStmt.snDefBreak);
            cmpBitSetDone(nestStmt.snDefBreak);
        }

        /* Intersect with the "false" bit from the condition */

        if  (!condVal)
        {
            cmpBitSetIntsct(cmpVarsDefined, tempBS);
            cmpBitSetDone(tempBS);
        }
    }
}

/*****************************************************************************/
#ifndef __IL__
/*****************************************************************************
 *
 *  Compare routine passed to quicksort for sorting of case label values.
 */

static
int __cdecl         caseSortCmp(const void *p1, const void *p2)
{
    Tree            op1 = *(Tree*)p1; assert(op1->tnOper == TN_CASE);
    Tree            op2 = *(Tree*)p2; assert(op2->tnOper == TN_CASE);

    Tree            cx1 = op1->tnCase.tncValue; assert(cx1);
    Tree            cx2 = op2->tnCase.tncValue; assert(cx2);

    if  (cx1->tnOper == TN_CNS_INT)
    {
        assert(cx2->tnOper == TN_CNS_INT);

        return cx1->tnIntCon.tnIconVal -
               cx2->tnIntCon.tnIconVal;
    }
    else
    {
        assert(cx1->tnOper == TN_CNS_LNG);
        assert(cx2->tnOper == TN_CNS_LNG);

        if  (cx1->tnLngCon.tnLconVal < cx2->tnLngCon.tnLconVal)
            return -1;
        if  (cx1->tnLngCon.tnLconVal > cx2->tnLngCon.tnLconVal)
            return +1;

        return 0;
    }
}

/*****************************************************************************/
#else
/*****************************************************************************/

static
void                sortSwitchCases(vectorTree table, unsigned count)
{
    if  (count < 2)
        return;

    for (unsigned skip = (count+1)/2; skip >= 1; skip /= 2)
    {
        bool            swap;

        do
        {
            unsigned    i = 0;
            unsigned    b = count - skip;

            Tree    *   l = table + i;
            Tree    *   h = l + skip;

            swap = false;

            while   (i < b)
            {
                assert(l >= table && l < h);
                assert(h <  table + count);

                Tree            op1 = *l++; assert(op1->tnOper == TN_CASE);
                Tree            op2 = *h++; assert(op2->tnOper == TN_CASE);

                Tree            cx1 = op1->tnCase.tncValue; assert(cx1 && cx1->tnOper == TN_CNS_INT);
                Tree            cx2 = op2->tnCase.tncValue; assert(cx2 && cx2->tnOper == TN_CNS_INT);

                if  (cx1->tnIntCon.tnIconVal > cx2->tnIntCon.tnIconVal)
                {
                    l[-1] = op2;
                    h[-1] = op1;

                    swap  = true;
                }

                i++;
            }
        }
        while (swap);
    }
}

/*****************************************************************************/
#endif
/*****************************************************************************
 *
 *  Generate code for a switch statement.
 */

void                compiler::cmpStmtSwitch(Tree stmt, SymDef lsym)
{
    Tree            svalExpr;
    Tree            caseLab;

    bool            caseUns;
    unsigned        caseCnt;

    __int64         caseMin;
    __int64         caseMax;
    __int64         casePrv;

    bool            needSort;
    unsigned        sortNum;

    stmtNestRec     nestStmt;

    ILblock         nmLabel;
    ILblock         labBreak;
    ILblock         labDeflt;

    bool            hadErrs;
    bool            hadDefault;

    assert(stmt->tnOper == TN_SWITCH);

    /* Bind the switch value */

    svalExpr = cmpBindExpr(stmt->tnSwitch.tnsValue); cmpChkVarInitExpr(svalExpr);

    /* Make sure the expression has an acceptable type */

    if  (svalExpr->tnVtyp != TYP_INT    &&
         svalExpr->tnVtyp != TYP_UINT   &&
         svalExpr->tnVtyp != TYP_LONG   &&
         svalExpr->tnVtyp != TYP_ULONG  &&
         svalExpr->tnVtyp != TYP_NATINT &&
         svalExpr->tnVtyp != TYP_NATUINT)
    {
        svalExpr = cmpCoerceExpr(svalExpr, cmpTypeInt, false);
    }

    caseUns  = varTypeIsUnsigned(svalExpr->tnVtypGet());
    caseCnt  = 0;

    /* Create the 'break' label */

    labBreak = cmpILgen->genFwdLabGet();
    labDeflt = NULL;

    /* Insert the appropriate entry into the statement list */

    nestStmt.snStmtExpr = stmt;
    nestStmt.snStmtKind = TN_SWITCH;
    nestStmt.snLabel    = lsym;
    nestStmt.snHadCont  = false; cmpBS_bigStart(nestStmt.snDefBreak);
    nestStmt.snHadBreak = false; cmpBS_bigStart(nestStmt.snDefCont );
    nestStmt.snLabCont  = NULL;
    nestStmt.snLabBreak = labBreak;
    nestStmt.snOuter    = cmpStmtNest;
                          cmpStmtNest = &nestStmt;

    /* Bind all the case values and check them */

    hadDefault = hadErrs = needSort = false;

    for (caseLab = stmt->tnSwitch.tnsCaseList;
         caseLab;
         caseLab = caseLab->tnCase.tncNext)
    {
        assert(caseLab->tnOper == TN_CASE);

        /* Create a label and assign it to the case/default */

        caseLab->tnCase.tncLabel = cmpILgen->genFwdLabGet();

        /* Is there a label value or is this "default" ? */

        if  (caseLab->tnCase.tncValue)
        {
            __int64         cval;
            Tree            cexp;

            /* Bind the value and coerce to the right type */

            cexp = cmpCoerceExpr(cmpBindExpr(caseLab->tnCase.tncValue),
                                 svalExpr->tnType,
                                 false);

            /* Make sure the value is a constant expression */

            if  (cexp->tnOper != TN_CNS_INT &&
                 cexp->tnOper != TN_CNS_LNG)
            {
                if  (cexp->tnVtyp != TYP_UNDEF)
                    cmpError(ERRnoIntExpr);

                cexp    = NULL;
                hadErrs = true;
            }
            else
            {
                /* Get the constant value for this label */

                cval = (cexp->tnOper == TN_CNS_INT) ? cexp->tnIntCon.tnIconVal
                                                    : cexp->tnLngCon.tnLconVal;

                /* Keep track of the min. and max. value, plus total count */

                caseCnt++;

                if  (caseCnt == 1)
                {
                    /* This is the very first case value */

                    caseMax =
                    caseMin = cval;
                }
                else
                {
                    /* We've had values before - update min/max as appropriate */

                    if  (caseUns)
                    {
                        if  ((unsigned __int64)caseMin >  (unsigned __int64)cval) caseMin  = cval;
                        if  ((unsigned __int64)caseMax <  (unsigned __int64)cval) caseMax  = cval;
                        if  ((unsigned __int64)casePrv >= (unsigned __int64)cval) needSort = true;
                    }
                    else
                    {
                        if  (  (signed __int64)caseMin >    (signed __int64)cval) caseMin  = cval;
                        if  (  (signed __int64)caseMax <    (signed __int64)cval) caseMax  = cval;
                        if  (  (signed __int64)casePrv >=   (signed __int64)cval) needSort = true;
                    }
                }

                casePrv = cval;
            }

            caseLab->tnCase.tncValue = cexp;
        }
        else
        {
            /* This is a "default:" label */

            if  (hadDefault)
                cmpError(ERRdupDefl);

            hadDefault = true;
            labDeflt   = caseLab->tnCase.tncLabel;
        }
    }

#if 0

    printf("Total case labels: %u", caseCnt);

    if  (caseUns)
        printf(" [min = %u, max = %u]\n", caseMin, caseMax);
    else
        printf(" [min = %d, max = %d]\n", caseMin, caseMax);

#endif

    /* Don't bother generating the opcode if we had errors */

    if  (hadErrs)
        goto DONE_SWT;

    /* Figure out where to go if no case label value matches */

    nmLabel = hadDefault ? labDeflt : labBreak;

    if  (!caseCnt)
        goto JMP_DEF;

    /* Collect all the case labels in a table */

#if MGDDATA

    Tree    []  sortBuff;

    sortBuff = new Tree[caseCnt];

#else

    Tree    *   sortBuff;

    sortBuff = (Tree*)cmpAllocCGen.nraAlloc(caseCnt*sizeof(*sortBuff));

#endif

    /* Add all the case labels in the table */

    for (caseLab = stmt->tnSwitch.tnsCaseList, sortNum = 0;
         caseLab;
         caseLab = caseLab->tnCase.tncNext)
    {
        assert(caseLab->tnOper == TN_CASE);

        /* Append to the table unless it's a 'default' label */

        if  (caseLab->tnCase.tncValue)
            sortBuff[sortNum++] = caseLab;
    }

    assert(sortNum == caseCnt);

    /* Sort the table by case label value, if necessary */

    if  (needSort)
    {
        __uint64    sortLast;
        Tree    *   sortAddr;
        unsigned    sortCnt;

#ifdef  __IL__
        sortSwitchCases(sortBuff, caseCnt);
#else
        qsort(sortBuff, caseCnt, sizeof(*sortBuff), caseSortCmp);
#endif

        /* Check for duplicates */

        sortCnt  = caseCnt;
        sortAddr = sortBuff;
        sortLast = 0;

        do
        {
            Tree            sortCase = *sortAddr; assert(sortCase->tnOper == TN_CASE);
            __uint64        sortNext;

            if  (!sortCase->tnCase.tncValue)
                continue;

            if  (sortCase->tnCase.tncValue->tnOper == TN_CNS_INT)
            {
                sortNext = sortCase->tnCase.tncValue->tnIntCon.tnIconVal;
            }
            else
            {
                assert(sortCase->tnCase.tncValue->tnOper == TN_CNS_LNG);
                sortNext = sortCase->tnCase.tncValue->tnLngCon.tnLconVal;
            }

            if  (sortLast == sortNext && sortAddr > sortBuff)
            {
                char            cstr[16];

                if  (caseUns)
                    sprintf(cstr, "%u", sortNext);
                else
                    sprintf(cstr, "%d", sortNext);

                cmpRecErrorPos(sortCase);
                cmpGenError(ERRdupCaseVal, cstr); hadErrs = true;
            }

            sortLast = sortNext;
        }
        while (++sortAddr, --sortCnt);

        if  (hadErrs)
            goto DONE_SWT;
    }

    /* Decide whether to use the "switch" opcode or not */

    if  (caseCnt > 3U && (unsigned)(caseMax - caseMin) <= 2U*caseCnt)
    {
        __int32         caseSpn;

        /* Generate a "real" switch opcode */

        cmpChkVarInitExpr(svalExpr);
        cmpILgen->genExpr(svalExpr, true);

        caseSpn = (__int32)(caseMax - caseMin + 1); assert(caseSpn == caseMax - caseMin + 1);

        cmpILgen->genSwitch(svalExpr->tnVtypGet(),
                            caseSpn,
                            caseCnt,
                            caseMin,
                            sortBuff,
                            nmLabel);
    }
    else
    {
        unsigned            tempNum;

        /* Allocate a temp to hold the value */

        tempNum = cmpILgen->genTempVarGet(svalExpr->tnType);

        /* Store the switch value in the temporary */

        cmpILgen->genExpr     (svalExpr, true);
        cmpILgen->genLclVarRef( tempNum, true);

        /* Now generate a series of compares and jumps */

        for (caseLab = stmt->tnSwitch.tnsCaseList;
             caseLab;
             caseLab = caseLab->tnCase.tncNext)
        {
            __int32         cval;
            Tree            cexp;

            assert(caseLab->tnOper == TN_CASE);

            /* Is there a label value or is this "default" ? */

            if  (!caseLab->tnCase.tncValue)
                continue;

            cexp = caseLab->tnCase.tncValue; assert(cexp->tnOper == TN_CNS_INT);
            cval = cexp->tnIntCon.tnIconVal;

            cmpILgen->genLclVarRef(tempNum, false);
            cmpILgen->genSwtCmpJmp(cval, caseLab->tnCase.tncLabel);
        }

        cmpILgen->genTempVarRls(svalExpr->tnType, tempNum);
    }

JMP_DEF:

    /* If none of the values match, jump to 'default' or skip over */

    cmpILgen->genJump(nmLabel);

DONE_SWT:

    /* Only case labels are reachable in a switch */

    cmpStmtReachable = false;

    /* Bind the body of the switch */

    assert(stmt->tnSwitch.tnsStmt->tnOper == TN_BLOCK); cmpBlock(stmt->tnSwitch.tnsStmt, false);

    /* Remove our entry from the statement list */

    cmpStmtNest = nestStmt.snOuter;

    /* Define the "break" label */

    cmpILgen->genFwdLabDef(labBreak);

    /* The next statement is reachable if we had a break or no default */

    if  (nestStmt.snHadBreak || hadDefault == 0)
        cmpStmtReachable = true;
}

/*****************************************************************************
 *
 *  Report an "unreachable code" diagnostic unless the given statement is
 *  one for which such a diagnostic wouldn't make sense (like a label).
 */

void                compiler::cmpErrorReach(Tree stmt)
{
    switch (stmt->tnOper)
    {
        StmtNest        nest;

    case TN_CASE:
    case TN_LABEL:
        return;

    case TN_BREAK:

        for (nest = cmpStmtNest; nest; nest = nest->snOuter)
        {
            switch (nest->snStmtKind)
            {
            case TN_SWITCH:
                return;

            case TN_DO:
            case TN_FOR:
            case TN_WHILE:
                break;

            default:
                continue;
            }

            break;
        }

        break;

    case TN_VAR_DECL:
        if  (!(stmt->tnFlags & TNF_VAR_INIT))
            return;
    }

    cmpRecErrorPos(stmt);
    cmpWarn(WRNunreach);
    cmpStmtReachable = true;
}

/*****************************************************************************/
#ifdef  SETS
/*****************************************************************************
 *
 *  Generate MSIL for a collection operator.
 */

void                compiler::cmpGenCollExpr(Tree expr)
{
    Tree            setExpr;
    Tree            dclExpr;

    SymDef          iterVar;

    TypDef          srefType;
    TypDef          elemType;
    TypDef          pargType;

    unsigned        stateCount;
    Tree    *       stateTable;

    funcletList     fclEntry;

    Ident           hlpName;
    SymDef          hlpSym;

    ArgDscRec       fltArgs;
    TypDef          fltType;
    unsigned        fltAcnt;
    SymDef          fltSym;
    TypDef          fltRtp;

    SymDef          iterSyms[MAX_ITER_VAR_CNT];

    declMods        mods;

    SaveTree        save;

    treeOps         oper = expr->tnOperGet();

    Tree            op1  = expr->tnOp.tnOp1;
    Tree            op2  = expr->tnOp.tnOp2;

    assert(oper == TN_ALL     ||
           oper == TN_EXISTS  ||
           oper == TN_FILTER  ||
           oper == TN_GROUPBY ||
           oper == TN_PROJECT ||
           oper == TN_SORT    ||
           oper == TN_UNIQUE);

    assert(op1->tnOper == TN_LIST);

    /* "project" has to be handled differently */

    if  (oper == TN_PROJECT)
    {
        TypDef          tgtType;

        SymDef          memSym;

        Tree            iniList;
        Tree            iniLast;

        Tree            newList;
        Tree            newLast;

        Tree            varDecl;

        unsigned        iterCnt;

        Tree            argList;

        Tree            argExpr = op1;
        Tree            blkExpr = op2;

//      cmpParser->parseDispTree(expr); printf("\n\n");

        assert(argExpr && argExpr->tnOper == TN_LIST);
        assert(blkExpr && blkExpr->tnOper == TN_BLOCK);

        /* Get the target type from the first list node */

        tgtType = argExpr->tnType;

//      printf("Target type is %08X '%s'\n", tgtType, cmpGlobalST->stTypeName(tgtType, NULL, NULL, NULL, false));

        assert(tgtType && tgtType->tdTypeKind == TYP_CLASS);

        /* Collect all the arguments into our little array */

        for (varDecl = blkExpr->tnBlock.tnBlkDecl, iterCnt = 0;
             varDecl;
             varDecl = varDecl->tnDcl.tnDclNext)
        {
            SymDef          ivarSym;

            /* Get hold of the variable declaration/symbol */

            assert(varDecl);
            assert(varDecl->tnOper == TN_VAR_DECL);
            assert(varDecl->tnFlags & TNF_VAR_UNREAL);

            ivarSym = varDecl->tnDcl.tnDclSym;

            assert(ivarSym && ivarSym->sdSymKind == SYM_VAR && ivarSym->sdIsImplicit);

            iterSyms[iterCnt++] = ivarSym;
        }

//      printf("Found %u source operands\n", iterCnt);

        /* Collect all the initializers from the target shape type */

        iniList =
        iniLast = NULL;

        for (memSym = tgtType->tdClass.tdcSymbol->sdScope.sdScope.sdsChildList;
             memSym;
             memSym = memSym->sdNextInScope)
        {
            if  (memSym->sdSymKind  == SYM_VAR &&
                 memSym->sdIsStatic == false   &&
                 memSym->sdVar.sdvInitExpr)
            {
                Tree        initVal = memSym->sdVar.sdvInitExpr;

                /* Create a list node with the value */

                initVal = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, initVal,
                                                                        NULL);

                /* Append the list node to the list of initializers */

                if  (iniLast)
                     iniLast->tnOp.tnOp2 = initVal;
                else
                     iniList             = initVal;

                iniLast = initVal;
            }
        }

        /* Make a more permanent copy of the initializer list for later */

        assert(iniList->tnOper == TN_LIST);
        assert(iniList->tnVtyp == TYP_VOID);

        iniList->tnFlags |= TNF_LIST_PROJ;
        iniList->tnVtyp   = TYP_CLASS;
        iniList->tnType   = tgtType;

//      cmpParser->parseDispTree(iniList); printf("\n\n");

        save = cmpSaveExprTree(iniList, iterCnt,
                                        iterSyms, &stateCount,
                                                  &stateTable);

        /* Push all the source arguments on the stack */

        newList =
        newLast = NULL;

        for (argList = argExpr; argList; argList = argList->tnOp.tnOp2)
        {
            Tree            argVal;

            assert(argList->tnOper             == TN_LIST);
            assert(argList->tnOp.tnOp1->tnOper == TN_LIST);
            assert(argList->tnOp.tnOp1->tnOp.tnOp1->tnOper == TN_NAME);

            argVal = argList->tnOp.tnOp1->tnOp.tnOp2;

            /* Do we have more than one argument ? */

            if  (iterCnt > 1)
            {
                /* Add the value to the new list */

                argVal = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argVal,
                                                                       NULL);

                /* Append the list node to the list of arguments */

                if  (newLast)
                     newLast->tnOp.tnOp2 = argVal;
                else
                     newList             = argVal;

                newLast = argVal;
            }
            else
            {
                cmpILgen->genExpr(argVal, true);
            }
        }

        /* Do we have more than one argument? */

        if  (iterCnt > 1)
        {
            Tree            newArr;

printf("\n\n\nWARNING: multiple source args for 'project' not implemented, the funclet will blow up!!!!!\n\n\n");

            pargType = cmpObjArrTypeGet();

            /* Create the "Object[]" array to hold the arguments */

            newArr = cmpCreateExprNode(NULL,
                                       TN_ARR_INIT,
                                       cmpObjArrType,
                                       newList,
                                       cmpCreateIconNode(NULL, iterCnt, TYP_UINT));

            newArr = cmpCreateExprNode(NULL, TN_NEW, cmpObjArrType, newArr);

            cmpChkVarInitExpr(newArr);
            cmpILgen->genExpr(newArr, true);
        }
        else
        {
            pargType = cmpRefTpObject;
        }

        /* Get hold of the collection ref type */

        elemType = expr->tnType;

        /* Pass the System::Type instance for the target type */

//      cmpILgen->genExpr(cmpTypeIDinst( tgtType), true);
        cmpILgen->genExpr(cmpTypeIDinst(elemType), true);   // pass the collection type

        goto SAVE;
    }

    dclExpr = op1->tnOp.tnOp1;
    setExpr = op1->tnOp.tnOp2;

#ifdef  DEBUG
//  cmpParser->parseDispTree(dclExpr); printf("\n\n");
//  cmpParser->parseDispTree(setExpr); printf("\n\n");
//  cmpParser->parseDispTree(op2    ); printf("\n\n");
#endif

    /* Get hold of the result type */

    assert(setExpr->tnType->tdTypeKind == TYP_REF);

    /* Generate the set/collection value expression */

    cmpChkVarInitExpr(setExpr);
    cmpILgen->genExpr(setExpr, true);

#ifdef DEBUG

    if  (cmpConfig.ccVerbose >= 2)
    {
        printf("Filter -- collection:\n");
        cmpParser->parseDispTree(setExpr);
        printf("Filter -- chooser term:\n");
        cmpParser->parseDispTree(op2);
    }

#endif

    /* Get hold of the iteration variable */

    assert(dclExpr->tnOper == TN_BLOCK);
    dclExpr = dclExpr->tnBlock.tnBlkDecl;
    assert(dclExpr && dclExpr->tnOper == TN_VAR_DECL);
    iterVar = dclExpr->tnDcl.tnDclSym;

    /* Record the filter expression for later */

    if  (oper == TN_SORT)
    {
        SymDef          iterSym1;
        SymDef          iterSym2;

        Tree            list;

        /*
            For each sort term we have to create two copies so that we
            can compare the values. Assume a given term is of the form

                expr(itervar)

            In other words, it's some expression in 'itervar'. What we
            need to create is the following two expressions, connected
            via a list node:

                    expr(itervar1)
                list
                    expr(itervar2)

            Later (when we generate code for the funclet), we'll convert
            these snippets into the right thing.
         */

        iterSym1 = cmpTempVarMake(cmpTypeVoid);
        iterSym1->sdVar.sdvCollIter = true;
        iterSym2 = cmpTempVarMake(cmpTypeVoid);
        iterSym2->sdVar.sdvCollIter = true;

//      cmpParser->parseDispTree(op2); printf("\n\n");

        for (list = op2; list; list = list->tnOp.tnOp2)
        {
            Tree            term;
            Tree            dup1;
            Tree            dup2;

            /* Get hold of the next sort term */

            assert(list->tnOper == TN_LIST);
            term = list->tnOp.tnOp1;
            assert(term->tnOper != TN_LIST);

            /* Make two copies of the sort term */

            dup1 = cmpCloneExpr(term, iterVar, iterSym1);
            dup2 = cmpCloneExpr(term, iterVar, iterSym2);

            /* Create a list node and store it in the original tree */

            list->tnOp.tnOp1 = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, dup1,
                                                                             dup2);
        }

        op2->tnFlags |= TNF_LIST_SORT;

//      cmpParser->parseDispTree(op2); printf("\n\n");

        iterSyms[0] = iterSym1;
        iterSyms[1] = iterSym2;

        save = cmpSaveExprTree(op2, 2,
                                    iterSyms, &stateCount,
                                              &stateTable);
    }
    else
    {
        iterSyms[0] = iterVar;

        save = cmpSaveExprTree(op2, 1,
                                    iterSyms, &stateCount,
                                              &stateTable);
    }

SAVE:

    /* Do we need to record any local state to pass to the funclet? */

    if  (stateCount)
    {
        unsigned        argNum;

        SymDef          stateCls;
        SymDef          stateCtor;

        Tree    *       statePtr = stateTable;

        /* Round the argument count to a multiple of 2 */

        stateCount += stateCount & 1;

        // The following must match the code in cmpDclFilterCls()

        for (argNum = 0; argNum < stateCount; argNum++)
        {
            /* Do we have a "real" argument? */

            if  (argNum < stateCount)
            {
                Tree            arg = *statePtr++;

                if  (arg)
                {
                    cmpChkVarInitExpr(arg);
                    cmpILgen->genExpr(arg, true);

//                  printf("Arg #%u\n", argNum); cmpParser->parseDispTree(arg); printf("\n");

                    assert((int)(argNum & 1) == (int)(arg->tnVtyp == TYP_REF));

                    continue;
                }
            }

//          printf("Arg #%u = N/A\n\n", argNum);

            if  (argNum & 1)
                cmpILgen->genNull();
            else
                cmpILgen->genIntConst(0);
        }

        if  (argNum < stateCount)
        {
            UNIMPL(!"sorry, too many state variables");
        }

        /* Get an appropriately sized state descriptor */

        assert(cmpSetOpClsTable);
        stateCls = cmpSetOpClsTable[(stateCount-1)/2];
        assert(stateCls && stateCls->sdSymKind == SYM_CLASS);

//      printf("Using [%2u] state class '%s'\n", stateCount, stateCls->sdSpelling());

        /* Remember that we need to generate code for the class */

        stateCls->sdClass.sdcHasBodies = true;

        /* Remember the type of the state class reference */

        srefType = stateCls->sdType->tdClass.tdcRefTyp;

        /* Instantiate the state class and pass it to the filter helper */

        stateCtor = cmpGlobalST->stLookupOperND(OVOP_CTOR_INST, stateCls);
        assert(stateCtor && stateCtor->sdSymKind == SYM_FNC);

        cmpILgen->genCallNew(stateCtor, stateCount);
    }
    else
    {
        cmpILgen->genNull();

        srefType = cmpRefTpObject;
    }

    /* We should have 'srefType' set to the right thing by now */

    assert(srefType && srefType->tdTypeKind == TYP_REF);

    /* Get hold of the result element type */

    assert(elemType && elemType->tdTypeKind == TYP_REF);
    elemType = cmpIsCollection(elemType->tdRef.tdrBase);
    assert(elemType && elemType->tdTypeKind == TYP_CLASS);

    /* Declare the filter funclet: first create the argument list */

    mods.dmAcc = ACL_PUBLIC;
    mods.dmMod = 0;

    /* The funclet usually takes 2 args and returns boolean */

    fltRtp  = cmpTypeBool;
    fltAcnt = 2;

    switch (oper)
    {
    case TN_SORT:

        cmpParser->parseArgListNew(fltArgs,
                                   3,
                                   true, elemType, CFC_ARGNAME_ITEM1,
                                         elemType, CFC_ARGNAME_ITEM2,
                                         srefType, CFC_ARGNAME_STATE, NULL);

        break;

    case TN_PROJECT:

        /* This funclet takes more args and returns an instance */

        fltRtp  = expr->tnType;
        fltAcnt = 3;

        cmpParser->parseArgListNew(fltArgs,
                                   2,
                                   true, pargType, CFC_ARGNAME_ITEM,
                                         srefType, CFC_ARGNAME_STATE, NULL);
        break;

    default:

        cmpParser->parseArgListNew(fltArgs,
                                   2,
                                   true, elemType, CFC_ARGNAME_ITEM,
                                         srefType, CFC_ARGNAME_STATE, NULL);
        break;
    }

    /* Create the function type */

    fltType = cmpGlobalST->stNewFncType(fltArgs, fltRtp);

    /* Declare the funclet symbol */

    assert(cmpCollFuncletCls && cmpCollFuncletCls->sdSymKind == SYM_CLASS);

    fltSym = cmpDeclFuncMem(cmpCollFuncletCls, mods, fltType, cmpNewAnonymousName());
    fltSym->sdIsStatic        = true;
    fltSym->sdIsSealed        = true;
    fltSym->sdIsDefined       = true;
    fltSym->sdIsImplicit      = true;
    fltSym->sdFnc.sdfFunclet  = true;

//  printf("Funclet '%s'\n", cmpGlobalST->stTypeName(fltSym->sdType, fltSym, NULL, NULL, false));

    /* Record the funclet along with the other info */

#if MGDDATA
    fclEntry = new funcletList;
#else
    fclEntry =    (funcletList)cmpAllocPerm.nraAlloc(sizeof(*fclEntry));
#endif

    fclEntry->fclFunc = fltSym;
    fclEntry->fclExpr = save;
    fclEntry->fclNext = cmpFuncletList;
                        cmpFuncletList = fclEntry;

    /* Generate a metadata definition for the funclet */

    cmpCollFuncletCls->sdClass.sdcHasBodies = true;
    cmpGenFncMetadata(fltSym);

    /* Push the address of the filter funclet */

    cmpILgen->genFNCaddr(fltSym);

    /* Call the appropriate helper method */

    assert(cmpClassDBhelper);

    switch (oper)
    {
    case TN_ALL:      hlpName = cmpIdentDBall    ; break;
    case TN_SORT:     hlpName = cmpIdentDBsort   ; break;
    case TN_EXISTS:   hlpName = cmpIdentDBexists ; break;
    case TN_FILTER:   hlpName = cmpIdentDBfilter ; break;
    case TN_UNIQUE:   hlpName = cmpIdentDBunique ; break;
    case TN_PROJECT:  hlpName = cmpIdentDBproject; break;
    default:
        NO_WAY(!"unexpected operator");
    }

    assert(hlpName);

    hlpSym = cmpGlobalST->stLookupClsSym(hlpName, cmpClassDBhelper); assert(hlpSym);

    cmpILgen->genCallFnc(hlpSym, fltAcnt);
}

void                compiler::cmpGenCollFunclet(SymDef fncSym, SaveTree body)
{
    assert(fncSym->sdFnc.sdfFunclet);

    assert(cmpCurFuncletBody == NULL); cmpCurFuncletBody = body;

    cmpCompFnc(fncSym, NULL);
}

/*****************************************************************************/
#endif//SETS
/*****************************************************************************
 *
 *  Generate MSIL for the given statement/declaration.
 */

void                compiler::cmpStmt(Tree stmt)
{
    /* The stack should be empty at the start of each statement */

#ifdef  OLD_IL
    if  (!cmpConfig.ccOILgen)
#endif
        assert(cmpILgen->genCurStkLvl == 0 || cmpErrorCount);

AGAIN:

    if  (!stmt)
        return;

#ifdef DEBUG

    if  (cmpConfig.ccVerbose >= 2)
    {
        printf("Compile statement [%u]:\n", stmt->tnLineNo);
        cmpParser->parseDispTree(stmt);
    }

//  if  (cmpConfig.ccDispCode)
//  {
//      if  (stmt->tnLineNo)
//          printf("; source line %x\n\n");
//  }

    assert(stmt->tnLineNo || (stmt->tnFlags & TNF_NOT_USER));

    cmpRecErrorPos(stmt);

#endif

#ifdef  OLD_IL
    if  (cmpConfig.ccOILgen)
        cmpOIgen->GOIrecExprPos(stmt);
    else
#endif
        cmpILgen->genRecExprPos(stmt);

    cmpCheckReach(stmt);

    switch (stmt->tnOper)
    {
        SymDef          lsym;
        Ident           name;
        StmtNest        nest;
        Tree            cond;
        TypDef          type;

        bool            exitTry;
        bool            exitHnd;

    case TN_CALL:

        /*
            If this is a "baseclass" call, we need to add any instance
            member initializers right after the call to the base class
            constructor.
         */

        if  (stmt->tnOp.tnOp1 && stmt->tnOp.tnOp1->tnOper == TN_BASE)
        {
            stmt = cmpBindExpr(stmt);
            cmpChkVarInitExpr(stmt);
            cmpILgen->genExpr(stmt, false);

            cmpAddCTinits();
            break;
        }

        // Fall through ...

    default:

        /* Presumably an expression statement */

        stmt = cmpBindExpr(stmt);
        cmpChkVarInitExpr(stmt);

        /* See if the expression actually does some work */

        switch (stmt->tnOper)
        {
        case TN_NEW:
        case TN_CALL:
        case TN_THROW:
        case TN_ERROR:
        case TN_DBGBRK:
        case TN_DELETE:
        case TN_FNC_SYM:
        case TN_INC_PRE:
        case TN_DEC_PRE:
        case TN_INC_POST:
        case TN_DEC_POST:
        case TN_INST_STUB:
        case TN_VARARG_BEG:
            break;

        default:
            if  (stmt->tnOperKind() & TNK_ASGOP)
                break;
            cmpWarn(WRNstmtNoUse);
        }

        cmpILgen->genExpr(stmt, false);
        break;

    case TN_BLOCK:

        cmpBlock(stmt, false);
        return;

    case TN_VAR_DECL:

        /* Get hold of the local variable */

        lsym = stmt->tnDcl.tnDclSym;
        assert(lsym && lsym->sdSymKind == SYM_VAR);

        /* Mark the variable as declared/defined */

        lsym->sdIsDefined    = true;
        lsym->sdCompileState = CS_DECLARED;

        /* Check and set the type of the symbol */

//      printf("Declare local  [%08X] '%s'\n", lsym, cmpGlobalST->stTypeName(NULL, lsym, NULL, NULL, false));

        type = stmt->tnType; assert(type);

        /* Special case: "refany" return type */

        if  (type->tdTypeKind == TYP_REF && type->tdRef.tdrBase->tdTypeKind == TYP_VOID)
            stmt->tnType = type = cmpGlobalST->stIntrinsicType(TYP_REFANY);
        else
            cmpBindType(type, false, false);

        lsym->sdType = type;

        /* Local static variables may not have a managed type for now */

        if  (lsym->sdIsStatic && type->tdIsManaged)
        {
            lsym->sdIsManaged = true;
            cmpError(ERRmgdStatVar);
            break;
        }

        /* Is there an initializer? */

        if  (stmt->tnFlags & TNF_VAR_INIT)
        {
            parserState     save;

            Tree            init;
            Tree            assg;

            cmpRecErrorPos(stmt);

            /* Managed static locals can't be initialized for now */

            if  (lsym->sdIsManaged)
            {
                cmpError(ERRmgdStatVar);
                break;
            }

            /* Get hold of the initializer */

            assert(stmt->tnDcl.tnDclInfo->tnOper == TN_LIST);
            init = stmt->tnDcl.tnDclInfo->tnOp.tnOp2;

            /* Is the variable "static" ? */

            if  (lsym->sdIsStatic)
            {
                memBuffPtr      addr = memBuffMkNull();

                assert(init->tnOper == TN_SLV_INIT);

                /* Start reading from the symbol's definition text */

                cmpParser->parsePrepText(&init->tnInit.tniSrcPos, cmpCurComp, save);

                /* Process the variable initializer */

                cmpInitVarAny(addr, lsym->sdType, lsym);
                cmpInitVarEnd(lsym);

                /* We're done reading source text from the definition */

                cmpParser->parseDoneText(save);

                /* The variable has been fully compiled */

                lsym->sdCompileState = CS_COMPILED;
            }
            else
            {
                if  (init->tnOper == TN_SLV_INIT)
                {
                    TypDef          type = lsym->sdType;

                    /* Start reading from the initializer's text */

                    cmpParser->parsePrepText(&init->tnInit.tniSrcPos, init->tnInit.tniCompUnit, save);

                    /* Make sure the type looks acceptable */

                    if  (type->tdTypeKind != TYP_ARRAY || !type->tdIsManaged)
                    {
                        cmpError(ERRbadBrInit, type);
                    }
                    else
                    {
                        /* Parse and bind the initializer */

                        init = cmpBindArrayExpr(type);

                        /* Create "var = init" and compile/generate it */

                        init = cmpCreateExprNode(NULL, TN_ASG, type, cmpCreateVarNode(NULL, lsym),
                                                                     init);

                        cmpChkVarInitExpr(init);
                        cmpILgen->genExpr(init, false);
                    }

                    /* We're done reading source text from the initializer */

                    cmpParser->parseDoneText(save);
                }
                else
                {
                    /* Is this a local constant? */

                    if  (lsym->sdVar.sdvConst)
                    {
                        assert(stmt->tnFlags & TNF_VAR_CONST);

                        cmpParseConstDecl(lsym, init);
                    }
                    else
                    {
                        {
                            /* Create "var = init" and bind/compile/generate it */

                            assg = cmpParser->parseCreateUSymNode(lsym); assg->tnLineNo = stmt->tnLineNo;
                            init = cmpParser->parseCreateOperNode(TN_ASG, assg, init);
                            init->tnFlags |= TNF_ASG_INIT;

                            init = cmpBindExpr(init);
                            cmpChkVarInitExpr(init);
                            cmpILgen->genExpr(init, false);
                        }
                    }
                }
            }
        }
        else
        {
            if  (!lsym->sdIsStatic && !lsym->sdVar.sdvCatchArg
#ifdef  SETS
                                   && !lsym->sdVar.sdvCollIter
#endif
                                   && !lsym->sdVar.sdvArgument)
            {
                /* This local variable has not yet been initialized */

                lsym->sdVar.sdvChkInit = true;
            }
        }

        if  (cmpConfig.ccGenDebug && lsym->sdName && !lsym->sdVar.sdvConst
                                                  && !lsym->sdVar.sdvArgument
                                                  && !lsym->sdIsStatic)
        {
            PCOR_SIGNATURE  sigPtr;
            size_t          sigLen;

//          printf("Debug info for local var: '%s'\n", lsym->sdSpelling());

            sigPtr = cmpTypeSig(lsym->sdType, &sigLen);

            if  (cmpSymWriter->DefineLocalVariable(cmpUniConv(lsym->sdName),
                                                   sigPtr,
                                                   sigLen,
                                                   lsym->sdVar.sdvILindex))
            {
                cmpGenFatal(ERRdebugInfo);
            }
        }

        break;

    case TN_IF:
        {
            bitset          tmpBStrue;
            bitset          tmpBSfalse;

            ILblock         labTmp1;
            ILblock         labTmp2;

            bool            reached;

            Tree            stmtCond;
            Tree            stmtYes;
            Tree            stmtNo;
            int             cval;

            /* Get hold of the various parts */

            stmtCond = cmpBindCondition(stmt->tnOp.tnOp1);

            stmtNo   = NULL;
            stmtYes  = stmt->tnOp.tnOp2;

            if  (stmt->tnFlags & TNF_IF_HASELSE)
            {
                assert(stmtYes->tnOper == TN_LIST);

                stmtNo  = stmtYes->tnOp.tnOp2;
                stmtYes = stmtYes->tnOp.tnOp1;
            }

            /* Can the condition be evaluated at compile time? */

            cval = cmpEvalCondition(stmtCond);

            /* Do we need to check for uninitialized variable use? */

            if  (cmpChkVarInit)
            {
                /* Check the condition and compute the 'true' and 'false' sets */

                cmpCheckUseCond(stmtCond, tmpBStrue , false,
                                          tmpBSfalse, false);

                /* Use the 'true' set for the true branch of the 'if' */

                cmpBitSetAssign(cmpVarsDefined, tmpBStrue);
            }

            /* Remember the initial reachability */

            reached = cmpStmtReachable;

            /* Test the 'if' condition (unless it is known already) */

            if  (cval)
            {
                labTmp1 = cmpILgen->genFwdLabGet();

                if  (cval < 0)
                    cmpILgen->genJump(labTmp1);
            }
            else
                labTmp1 = cmpILgen->genTestCond(stmtCond, false);

            /* Generate the "true" branch of the statement */

            cmpStmt(stmtYes);

            /* Is there "false" (i.e. "else") branch? */

            if  (stmtNo)
            {
                bool            rtmp;

                labTmp2 = cmpILgen->genFwdLabGet();

                /* Skip over the "else" if end of "true" part is reachable */

                if  (cmpStmtReachable)
                    cmpILgen->genJump(labTmp2);

                cmpILgen->genFwdLabDef(labTmp1);

                /* Swap the reachability values */

                rtmp = cmpStmtReachable;
                       cmpStmtReachable = reached;
                                          reached = rtmp;

                /* Do we need to check for uninitialized variable use? */

                if  (cmpChkVarInit)
                {
                    /* Save the current set as the new 'true' set */

                    cmpBitSetAssign(tmpBStrue, cmpVarsDefined);

                    /* Use the 'false' set for the other branch of the 'if' */

                    cmpBitSetAssign(cmpVarsDefined, tmpBSfalse);

                    /* Generate the "else" part now */

                    cmpStmt(stmtNo);

                    /* Is the end of the 'else' branch reachable? */

                    if  (!cmpStmtReachable)
                    {
                        /* The 'else' goes nowhere -- use the 'true' part then */

                        cmpBitSetAssign(cmpVarsDefined, tmpBStrue);
                    }
                    else if (reached)
                    {
                        /* Both branches reachable -- use the intersection */

                        cmpBitSetIntsct(cmpVarsDefined, tmpBStrue);
                    }
                }
                else
                    cmpStmt(stmtNo);

                labTmp1 = labTmp2;
            }
            else
            {
                /* There is no 'else', is the 'true' block's end reachable? */

                if  (cmpChkVarInit && cmpStmtReachable)
                {
                    /* Use the intersection of the 'true' and 'false' sets */

                    cmpBitSetIntsct(cmpVarsDefined, tmpBSfalse);
                }

                if      (cval > 0)
                    reached = false;
                else if (cval < 0)
                    cmpStmtReachable = reached;
            }

            cmpILgen->genFwdLabDef(labTmp1);

            /* The end is reachable if either branch is */

            cmpStmtReachable |= reached;

            /* Free up any bitsets we may have created */

            if  (cmpChkVarInit)
            {
                cmpBitSetDone(tmpBStrue);
                cmpBitSetDone(tmpBSfalse);
            }
        }
        break;

    case TN_DO:
        cmpStmtDo(stmt);
        break;

    case TN_FOR:
        cmpStmtFor(stmt);
        break;

    case TN_WHILE:
        cmpStmtWhile(stmt);
        break;

    case TN_SWITCH:
        cmpStmtSwitch(stmt);
        break;

    case TN_CASE:

        /* If the switch wasn't reachable, an error has already been issued */

        cmpStmtReachable = true;

        /* Create a label and assign it to the case/default */

        cmpILgen->genFwdLabDef(stmt->tnCase.tncLabel);
        break;

    case TN_BREAK:
    case TN_CONTINUE:

        /* Was there a loop label specification? */

        name = NULL;
        if  (stmt->tnOp.tnOp1)
        {
            assert(stmt->tnOp.tnOp1->tnOper == TN_NAME);
            name = stmt->tnOp.tnOp1->tnName.tnNameId;
        }

        /* Look for an enclosing statement that looks appropriate */

        for (nest = cmpStmtNest, exitTry = exitHnd = false;
             nest;
             nest = nest->snOuter)
        {
            switch (nest->snStmtKind)
            {
            case TN_SWITCH:

                /* Only allow "break" from a switch statement */

                if  (stmt->tnOper != TN_BREAK)
                    continue;

                break;

            case TN_DO:
            case TN_FOR:
            case TN_WHILE:
                break;

            case TN_NONE:
                continue;

            case TN_TRY:
                exitTry = true;
                continue;

            case TN_CATCH:
                exitHnd = true;
                continue;

            case TN_FINALLY:
                cmpError(ERRfinExit);
                goto DONE;

            default:
                NO_WAY(!"unexpected stmt kind");
            }

            /* Here we have a useable statement, check the label */

            if  (name)
            {
                if  (nest->snLabel == NULL || nest->snLabel->sdName != name)
                    continue;
            }

            /* Everything checks out, we can generate the jump now */

            if  (stmt->tnOper == TN_BREAK)
            {
                if  (exitHnd)
                    cmpILgen->genCatchEnd(true);

                if  (exitTry || exitHnd)
                    cmpILgen->genLeave(nest->snLabBreak);
                else
                    cmpILgen->genJump (nest->snLabBreak);

                /* Are we checking for uninitialized variable use? */

                if  (cmpChkVarInit)
                {
                    /* Initialize or intersect the "break" set */

                    if  (nest->snHadBreak)
                        cmpBitSetIntsct(nest->snDefBreak, cmpVarsDefined);
                    else
                        cmpBitSetCreate(nest->snDefBreak, cmpVarsDefined);
                }

                nest->snHadBreak = true;
            }
            else
            {
                if  (exitHnd)
                    cmpILgen->genCatchEnd(true);

                if  (exitTry || exitHnd)
                    cmpILgen->genLeave(nest->snLabCont);
                else
                    cmpILgen->genJump (nest->snLabCont);

                /* Are we checking for uninitialized variable use? */

                if  (cmpChkVarInit)
                {
                    /* Initialize or intersect the "continue" set */

                    if  (nest->snHadCont)
                        cmpBitSetIntsct(nest->snDefCont, cmpVarsDefined);
                    else
                        cmpBitSetCreate(nest->snDefCont, cmpVarsDefined);
                }

                nest->snHadCont = true;
            }

            cmpStmtReachable = false;
            goto DONE;
        }

        cmpError((stmt->tnOper == TN_BREAK) ? ERRbadBreak : ERRbadCont);
        break;

    case TN_LABEL:

        /* We have to be careful - redefined labels have NULL symbol links */

        lsym = NULL;

        if  (stmt->tnOp.tnOp1)
        {
            assert(stmt->tnOp.tnOp1->tnOper == TN_LCL_SYM);
            lsym = stmt->tnOp.tnOp1->tnLclSym.tnLclSym;
            assert(lsym && lsym->sdSymKind == SYM_LABEL);

            cmpILgen->genFwdLabDef(lsym->sdLabel.sdlILlab);
        }

        /* For now assume all labels are reachable */

        cmpStmtReachable = true;

        /* Is there a statement attached? */

        if  (stmt->tnOp.tnOp2 && stmt->tnOp.tnOp2->tnOper == TN_LIST)
        {
            /* Get hold of the statement and see if it's a loop */

            stmt = stmt->tnOp.tnOp2->tnOp.tnOp1;

            switch (stmt->tnOper)
            {
            case TN_DO:     cmpStmtDo    (stmt, lsym); break;
            case TN_FOR:    cmpStmtFor   (stmt, lsym); break;
            case TN_WHILE:  cmpStmtWhile (stmt, lsym); break;
            case TN_SWITCH: cmpStmtSwitch(stmt, lsym); break;

            default:
                goto AGAIN;
            }
        }
        break;

    case TN_GOTO:

        /* Get hold of the label name */

        assert(stmt->tnOp.tnOp1);
        assert(stmt->tnOp.tnOp1->tnOper == TN_NAME);
        name = stmt->tnOp.tnOp1->tnName.tnNameId;

        /* Look for the label symbol in the label scope */

        lsym = cmpLabScp ? cmpGlobalST->stLookupLabSym(name, cmpLabScp) : NULL;

        if  (lsym)
        {
            assert(lsym->sdSymKind == SYM_LABEL);

            /* Are we in an exception handler block? */

            if  (cmpInTryBlk || cmpInHndBlk)
                cmpILgen->genLeave(lsym->sdLabel.sdlILlab);
            else
                cmpILgen->genJump (lsym->sdLabel.sdlILlab);
        }
        else
        {
            cmpError(ERRundefLab, name);
        }

        cmpStmtReachable = false;
        break;

    case TN_EXCLUDE:
        cmpStmtExcl(stmt);
        break;

    case TN_RETURN:

        /* Can't return out of finally blocks */

        if  (cmpInFinBlk)
        {
            cmpError(ERRfinExit);
            break;
        }

        /* Are going to need a return value label ? */

        if  (cmpInTryBlk || cmpInHndBlk)
        {
            /* Make sure we have the label */

            if  (cmpLeaveLab == NULL)
                 cmpLeaveLab = cmpILgen->genFwdLabGet();
        }

        /* Are we in a function with a non-void return value? */

        if  (cmpCurFncRvt == TYP_VOID || cmpCurFncSym->sdFnc.sdfCtor)
        {
            /* 'void' function, there should be no return value */

            if  (stmt->tnOp.tnOp1)
            {
                cmpError(ERRcantRet);
            }
            else
            {
                if  (cmpChkMemInit)
                    cmpChkMemInits();

                if  (cmpInTryBlk || cmpInHndBlk)
                {
                    if  (cmpInHndBlk)
                        cmpILgen->genCatchEnd(true);

                    cmpILgen->genLeave(cmpLeaveLab);
                }
                else
                    cmpILgen->genStmtRet(NULL);
            }
        }
        else
        {
            /* Non-void function, we better have a return value */

            if  (!stmt->tnOp.tnOp1)
            {
                cmpError(ERRmisgRet, cmpCurFncTyp);
            }
            else
            {
                Tree            retv;

                /* Coerce the return value to the right type and bind it */

                retv = cmpParser->parseCreateOperNode(TN_CAST, stmt->tnOp.tnOp1, NULL);
                retv->tnType = cmpCurFncRtp;

                /* Bind the return value expression */

                retv = cmpFoldExpression(cmpBindExpr(retv));

                cmpChkVarInitExpr(retv);

                if  (cmpInTryBlk || cmpInHndBlk)
                {
                    Tree            tmpx;

                    /* Make sure we have a temp for the return value */

                    if  (cmpLeaveTmp == NULL)
                         cmpLeaveTmp = cmpTempVarMake(cmpCurFncRtp);

                    /* Store the return value in the temp */

                    tmpx = cmpCreateVarNode (NULL, cmpLeaveTmp);
                    retv = cmpCreateExprNode(NULL, TN_ASG, cmpCurFncRtp, tmpx, retv);

                    /* Generate code for the return value */

                    cmpILgen->genExpr(retv, false);

                    /* We can get out of the try/catch block now */

                    if  (cmpInHndBlk)
                        cmpILgen->genCatchEnd(true);

                    cmpILgen->genLeave(cmpLeaveLab);

                    goto DONE_RET;
                }

#ifdef  OLD_IL
                if  (cmpConfig.ccOILgen)
                    cmpOIgen->GOIstmtRet(retv);
                else
#endif
                    cmpILgen->genStmtRet(retv);
            }
        }

    DONE_RET:

        cmpStmtReachable = false;
        break;

    case TN_ASSERT:

        /* If there is no condition, we're presumably ignoring these */

        if  (!stmt->tnOp.tnOp1)
        {
            assert(cmpConfig.ccAsserts == 0);
            break;
        }

        /* Bind the condition */

        cond = cmpBindCondition(stmt->tnOp.tnOp1);

        /* Are we supposed to take asserts seriously? */

        if  (cmpConfig.ccAsserts != 0)
        {
            int             condVal;
            SymDef          abtSym;
            const   char *  srcStr = NULL;

            /* Make sure we have the assertAbort routine symbol */

            abtSym = cmpAsserAbtSym;

            if  (abtSym == NULL)
            {
                abtSym = cmpGlobalST->stLookupNspSym(cmpIdentAssertAbt,
                                                     NS_NORM,
                                                     cmpGlobalNS);

                if  (!abtSym)
                {
                    // ISSUE: flag this with an error/warning?

                    break;
                }

                // UNDONE: check that the arglist is reasonable

                cmpAsserAbtSym = abtSym;
            }

            /* Test the condition and see if it's always/never true */

            condVal = cmpEvalCondition(cond);

            if  (condVal <= 0)
            {
                Tree        args = NULL;
                Tree        expr;
                Tree        func;

                ILblock     labOK;

                /* If the condition isn't know, generate the test */

                if  (condVal == 0)
                    labOK  = cmpILgen->genTestCond(cond, true);

                /* Are we supposed to report the source position? */

                if  (cmpConfig.ccAsserts > 1)
                {
                    Tree            argx;

                    assert(cmpErrorComp);
                    assert(cmpErrorTree);
                    assert(cmpErrorTree->tnLineNo);

                    /* Construct the argument list, inside out (i.e. R->L) */

                    argx = cmpCreateIconNode(NULL, cmpErrorTree->tnLineNo, TYP_UINT);
                    args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argx, NULL);

                    /* The source file is in front of the line# */

                    argx = cmpCreateSconNode(cmpErrorComp->sdComp.sdcSrcFile,
                                             strlen(cmpErrorComp->sdComp.sdcSrcFile),
                                             false,
                                             cmpTypeCharPtr);
                    args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argx, args);

                    /* The condition string is the first argument */

                    argx = cmpCreateSconNode("", 0, false, cmpTypeCharPtr);
                    args = cmpCreateExprNode(NULL, TN_LIST, cmpTypeVoid, argx, args);
                }

                // UNDONE: The following isn't quite right, the name may
                // UNDONE: bind to the wrong symbol.

                func = cmpParser->parseCreateNameNode(cmpIdentAssertAbt);
                expr = cmpParser->parseCreateOperNode(TN_CALL, func, args);
//              expr->tnFncSym.tnFncSym  = abtSym;
//              expr->tnFncSym.tnFncArgs = args;
//              expr->tnFncSym.tnFncObj  = NULL;

                /* Generate the failure code */

                cmpILgen->genAssertFail(cmpBindExpr(expr));

                /* If we tested the condition, define the skip label */

                if  (condVal == 0)
                    cmpILgen->genFwdLabDef(labOK);
            }
        }

        break;

    case TN_TRY:
        cmpStmtTry(stmt);
        break;

#ifdef  SETS

    case TN_CONNECT:
        cmpStmtConnect(stmt);
        break;

    case TN_FOREACH:
        cmpStmtForEach(stmt);
        break;

#endif

    case TN_LIST:

        cmpStmt(stmt->tnOp.tnOp1);
        stmt = stmt->tnOp.tnOp2;
        if  (stmt)
            goto AGAIN;
        break;

    case TN_INST_STUB:
        cmpILgen->genInstStub();
        cmpStmtReachable = false;
        break;
    }

DONE:

    /* The stack should be empty at the end of each statement */

#ifdef  OLD_IL
    if  (!cmpConfig.ccOILgen)
#endif
        assert(cmpILgen->genCurStkLvl == 0 || cmpErrorCount);
}

/*****************************************************************************
 *
 *  Helpers that implement various operations on large bitsets.
 */

void                compiler::cmpBS_bigCreate(OUT bitset REF bs)
{
    assert(cmpLargeBSsize);

#ifdef  DEBUG
    assert(bs.bsCheck != 0xBEEFCAFE || &bs == &cmpVarsIgnore); bs.bsCheck = 0xBEEFCAFE;
#endif

#if MGDDATA
    bs.bsLargeVal = new BYTE[cmpLargeBSsize];
#else
    bs.bsLargeVal = (BYTE*)SMCgetMem(this, roundUp(cmpLargeBSsize));
    memset(bs.bsLargeVal, 0, cmpLargeBSsize);
#endif

//  printf("Create    [%08X] size=%u\n", &bs, cmpLargeBSsize);
}

void                compiler::cmpBS_bigDone  (OUT bitset REF bs)
{
    assert(cmpLargeBSsize);

//  printf("Free      [%08X]\n", &bs);

#ifdef  DEBUG
    assert(bs.bsCheck == 0xBEEFCAFE); bs.bsCheck = 0;
#endif

#if!MGDDATA
    SMCrlsMem(this, bs.bsLargeVal);
#endif

}

void                compiler::cmpBS_bigWrite(INOUT bitset REF bs, unsigned pos,
                                                                  unsigned val)
{
    unsigned        offs =      (pos / bitsetLargeSize);
    unsigned        mask = 1 << (pos % bitsetLargeSize);

    assert(offs < cmpLargeBSsize);

#ifdef  DEBUG
    assert(bs.bsCheck == 0xBEEFCAFE);
#endif

    if  (val)
        bs.bsLargeVal[offs] |=  mask;
    else
        bs.bsLargeVal[offs] &= ~mask;
}

unsigned            compiler::cmpBS_bigRead  (IN   bitset REF bs, unsigned pos)
{
    unsigned        offs =      (pos / bitsetLargeSize);
    unsigned        mask = 1 << (pos % bitsetLargeSize);

    assert(offs < cmpLargeBSsize);

#ifdef  DEBUG
    assert(bs.bsCheck == 0xBEEFCAFE);
#endif

    return  ((bs.bsLargeVal[offs] & mask) != 0);
}

void                compiler::cmpBS_bigCreate(  OUT bitset REF dst,
                                              IN    bitset REF src)
{
    cmpBS_bigCreate(dst);
    cmpBS_bigAssign(dst, src);
}

void                compiler::cmpBS_bigAssign(  OUT bitset REF dst,
                                              IN    bitset REF src)
{
//  printf("Copy      [%08X]  = [%08X]\n", &dst, &src);

#ifdef  DEBUG
    assert(src.bsCheck == 0xBEEFCAFE);
    assert(dst.bsCheck == 0xBEEFCAFE);
#endif

    memcpy(dst.bsLargeVal, src.bsLargeVal, cmpLargeBSsize);
}

void                compiler::cmpBS_bigUnion (INOUT bitset REF bs1,
                                              IN    bitset REF bs2)
{
    unsigned        i  = cmpLargeBSsize;

    BYTE    *       p1 = bs1.bsLargeVal;
    BYTE    *       p2 = bs2.bsLargeVal;

//  printf("Union     [%08X] |= [%08X]\n", &bs1, &bs2);

#ifdef  DEBUG
    assert(bs1.bsCheck == 0xBEEFCAFE);
    assert(bs2.bsCheck == 0xBEEFCAFE);
#endif

    do
    {
        *p1 |= *p2;
    }
    while (++p1, ++p2, --i);
}

void                compiler::cmpBS_bigIntsct(INOUT bitset REF bs1,
                                              IN    bitset REF bs2)
{
    unsigned        i  = cmpLargeBSsize;

    BYTE    *       p1 = bs1.bsLargeVal;
    BYTE    *       p2 = bs2.bsLargeVal;

//  printf("Intersect [%08X] |= [%08X]\n", &bs1, &bs2);

#ifdef  DEBUG
    assert(bs1.bsCheck == 0xBEEFCAFE);
    assert(bs2.bsCheck == 0xBEEFCAFE);
#endif

    do
    {
        *p1 &= *p2;
    }
    while (++p1, ++p2, --i);
}

/*****************************************************************************
 *
 *  Initialize/shut down the uninitialized variable use detection logic.
 */

void                compiler::cmpChkVarInitBeg(unsigned lclVarCnt, bool hadGoto)
{
    assert(cmpConfig.ccSafeMode || cmpConfig.ccChkUseDef);

    /* Initialize the bitset logic based on the local variable count */

    cmpBitSetInit(lclVarCnt);

    /* Record whether we have gotos (implies irreducible flow-graph) */

    cmpGotoPresent = hadGoto;

    /* Clear the "initialized" and "flagged" variable sets */

    cmpBitSetCreate(cmpVarsDefined);
    cmpBitSetCreate(cmpVarsFlagged);
}

void                compiler::cmpChkVarInitEnd()
{
    cmpBitSetDone  (cmpVarsDefined);
    cmpBitSetDone  (cmpVarsFlagged);
}

/*****************************************************************************
 *
 *  Check a condition expression for uninitialized variable use. The routine
 *  returns two definition sets: one gives the definition set for when the
 *  condition is true, the other one for when it's false.
 *
 *  If the caller is interested only in one of the sets, pass true for one
 *  of the 'skip' arguments and 'cmpVarsIgnore' for its bitset argument.
 */

void                compiler::cmpCheckUseCond(Tree expr, OUT bitset REF yesBS,
                                                         bool           yesSkip,
                                                         OUT bitset REF  noBS,
                                                         bool            noSkip)
{
    /* Check for one of the short-circuit operators */

    switch (expr->tnOper)
    {
    case TN_LOG_OR:

        /* The first  condition will always be evaluated */

        cmpCheckUseCond(expr->tnOp.tnOp1, yesBS,         false,
                                          cmpVarsIgnore, true);

        /* The second condition will be evaluated if the first one is false */

        cmpCheckUseCond(expr->tnOp.tnOp2, cmpVarsIgnore, true,
                                          noBS,          false);

        return;

    case TN_LOG_AND:

        /* The first  condition will always be evaluated */

        cmpCheckUseCond(expr->tnOp.tnOp1, cmpVarsIgnore, true,
                                          noBS,          false);

        /* The second condition will be evaluated if the first one is true  */

        cmpCheckUseCond(expr->tnOp.tnOp2, yesBS,         false,
                                          cmpVarsIgnore, true);

        return;

    default:

        /* Not a short-circuit operator: both sets will be the same */

        cmpChkVarInitExpr(expr);

        if  (!yesSkip) cmpBitSetCreate(yesBS, cmpVarsDefined);
        if  (! noSkip) cmpBitSetCreate( noBS, cmpVarsDefined);

        return;
    }
}

/*****************************************************************************
 *
 *  Check the given expression for variable use/def.
 */

void                compiler::cmpChkVarInitExprRec(Tree expr)
{
    treeOps         oper;
    unsigned        kind;

AGAIN:

    assert(expr);

#if!MGDDATA
    assert((int)expr != 0xDDDDDDDD && (int)expr != 0xCCCCCCCC);
#endif

    /* What kind of a node do we have? */

    oper = expr->tnOperGet ();
    kind = expr->tnOperKind();

    /* Is this a constant/leaf node? */

    if  (kind & (TNK_CONST|TNK_LEAF))
        return;

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & TNK_SMPOP)
    {
        Tree            op1 = expr->tnOp.tnOp1;
        Tree            op2 = expr->tnOp.tnOp2;

        /* Make sure the flags are properly set */

        if  (kind & TNK_ASGOP)
        {
            assert((op2->tnFlags & TNF_ASG_DEST) == 0);

            /* Is this an assignment operator? */

            if  (oper == TN_ASG)
                op1->tnFlags |=  TNF_ASG_DEST;
            else
                op1->tnFlags &= ~TNF_ASG_DEST;
        }

        /* Is there a second operand? */

        if  (expr->tnOp.tnOp2)
        {
            if  (expr->tnOp.tnOp1)
            {
                /* Special case: vararg-beg */

                if  (oper == TN_VARARG_BEG)
                {
                    Tree            arg1;
                    Tree            arg2;

                    assert(op1->tnOper == TN_LIST);

                    arg1 = op1->tnOp.tnOp1;
                    arg2 = op1->tnOp.tnOp2;

                    /* The first suboperand is the target variable */

                    assert(arg1->tnOper == TN_LCL_SYM);

                    arg1->tnFlags |=  TNF_ASG_DEST;

                    cmpChkVarInitExprRec(arg1);
                    cmpChkVarInitExprRec(arg2);

                    expr = op2;
                    goto AGAIN;
                }

                cmpChkVarInitExprRec(op1);

                /* Special case: short-circuit operators */

                if  (oper == TN_LOG_OR || oper == TN_LOG_AND)
                {
                    bitset          tempBS;

                    /* Save the set after the first condition */

                    cmpBitSetCreate(tempBS, cmpVarsDefined);

                    /* Process the second condition */

                    cmpChkVarInitExprRec(op2);

                    /* Only the first condition is guaranteed to be evaluated */

                    cmpBitSetAssign(cmpVarsDefined, tempBS);
                    cmpBitSetDone(tempBS);
                    return;
                }
            }

            expr = op2;
            goto AGAIN;
        }

        /* Special case: address of */

        if  (oper == TN_ADDROF)
        {
            if  (op1->tnOper == TN_LCL_SYM)
            {
                op1->tnFlags |=  TNF_ASG_DEST;
                cmpChkVarInitExprRec(op1);
                op1->tnFlags &= ~TNF_ASG_DEST;

                return;
            }
        }

        expr = op1;
        if  (expr)
            goto AGAIN;

        return;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        SymDef          sym;

    case TN_LCL_SYM:

        /* Get hold of the variable symbol and its index */

        sym = expr->tnLclSym.tnLclSym;

    CHK_INIT:

        assert(sym->sdSymKind == SYM_VAR);

        /* Check for initialization if necessary */

        if  (sym->sdVar.sdvChkInit)
        {
            unsigned        ind;

            assert(sym->sdVar.sdvLocal || (sym->sdIsMember && sym->sdIsSealed));

            /* Get hold of the variable's index */

            ind = sym->sdVar.sdvILindex;

            /* Is this a definition or use? */

            if  (expr->tnFlags & TNF_ASG_DEST)
            {
                if  (sym->sdIsMember)
                {
                    /* Static constants may only be assigned once */

                    if  (cmpBitSetRead(cmpVarsDefined, ind))
                        cmpErrorQnm(ERRdupMemInit, sym);
                }

                cmpBitSetWrite(cmpVarsDefined, ind, 1);
            }
            else
            {
                /* Check the current 'def' bitset for this variable */

                if  (cmpBitSetRead(cmpVarsDefined, ind))
                    return;

                /* Don't issue a message if the symbol has already been flagged */

                if  (!cmpBitSetRead(cmpVarsFlagged, ind) && !cmpGotoPresent)
                {
                    cmpRecErrorPos(expr);

                    if      (cmpConfig.ccSafeMode || sym->sdType->tdIsManaged)
                        cmpGenError(ERRundefUse, sym->sdSpelling());
                    else
                        cmpGenWarn (WRNundefUse, sym->sdSpelling());

                    cmpBitSetWrite(cmpVarsFlagged, ind, 1);
                }
            }
        }

        break;

    case TN_FNC_SYM:

        if  (expr->tnFncSym.tnFncObj)
            cmpChkVarInitExprRec(expr->tnFncSym.tnFncObj);

        if  (expr->tnFncSym.tnFncArgs)
        {
            Tree            args = expr->tnFncSym.tnFncArgs;

            do
            {
                Tree            argx;

                /* Get hold of the next argument value */

                assert(args->tnOper == TN_LIST);
                argx = args->tnOp.tnOp1;

                /* Is this an "out" argument? */

                if  (argx->tnOper == TN_ADDROF && (argx->tnFlags & TNF_ADR_OUTARG))
                {
                    /* Mark the argument as assignment target */

                    argx->tnOp.tnOp1->tnFlags |= TNF_ASG_DEST;
                }

                /* Check the expression */

                cmpChkVarInitExprRec(argx);

                /* Move to the next argument, if any */

                args = args->tnOp.tnOp2;
            }
            while (args);
        }
        break;

    case TN_VAR_SYM:

        /* Process the instance pointer, if any */

        if  (expr->tnVarSym.tnVarObj)
        {
            assert(expr->tnLclSym.tnLclSym->sdVar.sdvChkInit == false);

            expr = expr->tnVarSym.tnVarObj;
            goto AGAIN;
        }

        /* Get hold of the member symbol and check initialization */

        sym = expr->tnLclSym.tnLclSym;
        goto CHK_INIT;

    case TN_BFM_SYM:
        expr = expr->tnBitFld.tnBFinst; assert(expr);
        goto AGAIN;

    case TN_FNC_PTR:
    case TN_ERROR:
    case TN_NONE:
        break;

#ifdef  SETS
    case TN_BLOCK:
        break;
#endif

    default:
#ifdef DEBUG
        cmpParser->parseDispTree(expr);
#endif
        assert(!"invalid/unhandled expression node");
    }
}

/*****************************************************************************
 *
 *  We're exiting a static constructor, make sure all the right members have
 *  been initialized.
 */

void                compiler::cmpChkMemInits()
{
    SymDef          memSym;

    assert(cmpCurFncSym->sdFnc.sdfCtor);
    assert(cmpCurFncSym->sdIsStatic);

    for (memSym = cmpCurFncSym->sdParent->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        if  (memSym->sdSymKind == SYM_VAR &&
             memSym->sdIsSealed           &&
             memSym->sdIsStatic           &&
             memSym->sdVar.sdvChkInit)
        {
            if  (!cmpBitSetRead(cmpVarsDefined, memSym->sdVar.sdvILindex))
            {
                if  (cmpCurFncSym->sdIsImplicit)
                    cmpSetSrcPos(memSym);

                cmpErrorQnm(ERRnoVarInit, memSym);
            }
        }
    }
}

/*****************************************************************************
 *
 *  We're compiling a constructor, see if there are any member initializers
 *  we need to add to its body.
 */

void                compiler::cmpAddCTinits()
{
    Scanner         ourScanner;
    SymDef          memSym;

    SymDef          fncSym = cmpCurFncSym; assert(fncSym->sdFnc.sdfCtor);

    bool            isStat = fncSym->sdIsStatic;
    SymDef          clsSym = fncSym->sdParent;

    assert(clsSym->sdSymKind == SYM_CLASS);

    /* We better make sure this only happens at most one time */

#ifndef NDEBUG
    assert(cmpDidCTinits == false); cmpDidCTinits = true;
#endif

    /* Is this an unmanaged class? */

    if  (!clsSym->sdIsManaged)
    {
        /* Does the class have any virtual functions ? */

        if  (clsSym->sdClass.sdcHasVptr)
        {
            SymDef          vtabSym;
            Tree            vtabExp;
            Tree            vtabAdr;

            vtabSym = clsSym->sdClass.sdcVtableSym;

            if  (!vtabSym)
            {
                SymList             list;

                /* Declare the vtable variable */

                vtabSym = cmpGlobalST->stDeclareSym(cmpGlobalHT->tokenToIdent(tkVIRTUAL),
                                                    SYM_VAR,
                                                    NS_HIDE,
                                                    clsSym);

                vtabSym->sdVar.sdvIsVtable = true;
                vtabSym->sdType            = cmpTypeVoid;
                vtabSym->sdAccessLevel     = ACL_DEFAULT;

                /* Record the vtable, we'll generate its contents later */

#if MGDDATA
                list = new SymList;
#else
                list =    (SymList)cmpAllocPerm.nraAlloc(sizeof(*list));
#endif

                list->slSym  = vtabSym;
                list->slNext = cmpVtableList;
                               cmpVtableList = list;

                cmpVtableCount++;

                /* Remember the vtable symbol, we might need it again */

                clsSym->sdClass.sdcVtableSym = vtabSym;
            }

            assert(vtabSym);
            assert(vtabSym->sdSymKind == SYM_VAR);
            assert(vtabSym->sdVar.sdvIsVtable);

            /* Assign the vtable pointer value: "*[this+offs] = &vtable" */

            vtabExp = cmpThisRef();

            /* Add the vptr offset if there is a base with no vptrs */

            if  (clsSym->sdClass.sdc1stVptr &&
                 clsSym->sdType->tdClass.tdcBase)
            {
                TypDef          baseCls;
                Tree            offsExp;

                baseCls = clsSym->sdType->tdClass.tdcBase;

                assert(baseCls->tdTypeKind == TYP_CLASS);

                offsExp = cmpCreateIconNode(NULL, baseCls->tdClass.tdcSize, TYP_UINT);
                vtabExp = cmpCreateExprNode(NULL, TN_ADD, vtabExp->tnType, vtabExp,
                                                                           offsExp);

            }

            /* Deref the "[this+vptroffs]" expression */

            vtabExp = cmpCreateExprNode(NULL, TN_IND, cmpTypeVoidPtr, vtabExp, NULL);

            /* Take the address of the vtable variable */

            vtabAdr = cmpCreateExprNode(NULL, TN_VAR_SYM, cmpTypeVoid);

            vtabAdr->tnVarSym.tnVarSym = vtabSym;
            vtabAdr->tnVarSym.tnVarObj = NULL;

            vtabAdr = cmpCreateExprNode(NULL, TN_ADDROF, cmpTypeVoidPtr, vtabAdr, NULL);

            /* Assign the address of the vtable to the vptr member */

            vtabExp = cmpCreateExprNode(NULL, TN_ASG, cmpTypeVoidPtr, vtabExp, vtabAdr);

            cmpILgen->genExpr(vtabExp, false);
        }
    }

    /* Does the class have any initializers that apply to this ctor? */

    if  (isStat)
    {
        if  (!clsSym->sdClass.sdcStatInit)
            return;
    }
    else
    {
        if  (!clsSym->sdClass.sdcInstInit)
            return;
    }

    /* Walk the members looking for initializers to add to the ctor */

    ourScanner = cmpScanner;

    for (memSym = clsSym->sdScope.sdScope.sdsChildList;
         memSym;
         memSym = memSym->sdNextInScope)
    {
        if  (memSym->sdSymKind != SYM_VAR)
            continue;

        /* Is it the right kind of a symbol? */

        if  ((bool)memSym->sdIsStatic != isStat)
            continue;

//      if  (!strcmp(fncSym->          sdSpelling(), "static") &&
//           !strcmp(fncSym->sdParent->sdSpelling(), "PermissionToken")) forceDebugBreak();

        /* Does this member have an initializer? */

        if  (memSym->sdSrcDefList)
        {
            Tree            init;
            Tree            expr;
            parserState     save;

            ExtList         memInit;
            TypDef          memType;

            /* Get hold of the initializer definition descriptor */

            memInit = (ExtList)memSym->sdSrcDefList;

            assert(memInit->dlExtended);
            assert(memInit->mlSym == memSym);

            memType = memSym->sdType;

            /* Prepare the initializer assignment expression */

            init = cmpCreateExprNode(NULL, TN_VAR_SYM, memType);

            init->tnVarSym.tnVarObj = isStat ? NULL : cmpThisRef();
            init->tnVarSym.tnVarSym = memSym;

            /* Prepare to parse the initializer */

            cmpParser->parsePrepText(&memInit->dlDef, memInit->dlComp, save);

            /* Is this an array initializer? */

            if  (ourScanner->scanTok.tok == tkLCurly)
            {
                expr = cmpBindArrayExpr(memType);
                expr = cmpCreateExprNode(NULL, TN_NEW , memType, expr);
            }
            else
            {
                expr = cmpParser->parseExprComma();
                expr = cmpBindExpr(expr);
            }

            /* Make sure the expression terminated properly */

            if  (ourScanner->scanTok.tok != tkComma &&
                 ourScanner->scanTok.tok != tkSColon)
            {
                cmpError(ERRnoEOX);
            }

            /* Coerce the value to the right type and assign it */

            expr = cmpCastOfExpr(expr, memSym->sdType, false);
            init = cmpCreateExprNode(NULL, TN_ASG , memType, init, expr);

            cmpILgen->genExpr(init, false);

            cmpParser->parseDoneText(save);
        }
    }
}

/*****************************************************************************
 *
 *  Process the given list of local variable declarations.
 *
 *  IMPORTANT:  It is the caller's responsibility to preserve the value of
 *              'cmpCurScp' when calling this routine!
 */

SymDef              compiler::cmpBlockDecl(Tree block, bool outer,
                                                       bool genDecl,
                                                       bool isCatch)
{
    SymTab          ourStab = cmpGlobalST;

    ArgDef          argList = NULL;

    SymDef          blockScp;
    Tree            blockLst;

    assert(block || outer);

    /* Create a scope symbol for the block */

    cmpCurScp = blockScp = ourStab->stDeclareLcl(NULL,
                                                 SYM_SCOPE,
                                                 NS_HIDE,
                                                 cmpCurScp,
                                                 &cmpAllocCGen);

    if  (cmpConfig.ccGenDebug && !cmpCurFncSym->sdIsImplicit
                              && !(block->tnFlags & TNF_BLK_NUSER))
    {
        unsigned        scopeId;

        /* For debug info, open a new lexical scope */

        if (cmpSymWriter->OpenScope(0, &scopeId))
            cmpGenFatal(ERRdebugInfo);

        cmpCurScp->sdScope.sdSWscopeId  = scopeId;
        cmpCurScp->sdScope.sdBegBlkAddr = cmpILgen->genBuffCurAddr();
        cmpCurScp->sdScope.sdBegBlkOffs = cmpILgen->genBuffCurOffs();
    }

    assert(block->tnOper == TN_BLOCK); blockLst = block->tnBlock.tnBlkDecl;

    /* Record the outermost function scope when we create it */

    if  (outer)
    {
        assert(cmpCurFncTyp->tdTypeKind == TYP_FNC);

        /* Get hold of the function argument list */

        argList = cmpCurFncTyp->tdFnc.tdfArgs.adArgs;

        /* Is this a non-static member function? */

        if  (cmpCurFncSym->sdIsMember && !cmpCurFncSym->sdIsStatic)
        {
            SymDef          thisSym;
            SymDef           clsSym;
            TypDef           clsTyp;

            /* Get hold of the class type */

            clsSym = cmpCurFncSym->sdParent;
            assert(clsSym->sdSymKind  == SYM_CLASS);
            clsTyp = clsSym->sdType;
            assert(clsTyp->tdTypeKind == TYP_CLASS);

            /* Declare the "this" argument */

            thisSym = ourStab->stDeclareLcl(cmpGlobalHT->tokenToIdent(tkTHIS),
                                            SYM_VAR,
                                            NS_NORM,
                                            blockScp,
                                            &cmpAllocCGen);

            thisSym->sdCompileState    = CS_DECLARED;
            thisSym->sdAccessLevel     = ACL_PUBLIC;
            thisSym->sdType            = clsTyp->tdClass.tdcRefTyp;
            thisSym->sdVar.sdvLocal    = true;
            thisSym->sdVar.sdvArgument = true;
            thisSym->sdVar.sdvILindex  = cmpILgen->genNextArgNum();

            /* Tell everyone else where to find the "this" argument symbol */

            cmpThisSym = thisSym;

            /* Are we supposed to (implicitly) call a base class constructor? */

            if  (cmpBaseCTcall)
            {
                Tree            baseCall;

                assert(cmpCurFncSym->sdFnc.sdfCtor);

                SymDef          clsSym = cmpCurFncSym->sdParent;

                assert(clsSym->sdSymKind == SYM_CLASS);
                assert(clsSym->sdType->tdClass.tdcBase);

                baseCall = cmpCallCtor(clsSym->sdType->tdClass.tdcBase, NULL);
                if  (baseCall && baseCall->tnOper != TN_ERROR)
                {
                    assert(baseCall->tnOper == TN_NEW);
                    baseCall = baseCall->tnOp.tnOp1;
                    assert(baseCall->tnOper == TN_FNC_SYM);
                    baseCall->tnFncSym.tnFncObj = cmpThisRef();

                    cmpILgen->genExpr(baseCall, false);
                }
            }
        }
        else
            cmpThisSym = NULL;
    }

    /* Declare all the local symbols contained in the block */

    while (blockLst)
    {
        Tree            info;
        Ident           name;
        SymDef          localSym;
        Tree            blockDcl;

        /* Grab the next declaration entry */

        blockDcl = blockLst;

        if  (blockDcl->tnOper == TN_LIST)
            blockDcl = blockDcl->tnOp.tnOp1;

        assert(blockDcl->tnOper == TN_VAR_DECL);

#ifdef  SETS

        /* Is this a "foreach" iteration variable ? */

        if  (blockDcl->tnDcl.tnDclSym)
        {
            localSym = blockDcl->tnDcl.tnDclSym;

            assert(localSym->sdVar.sdvCollIter);

            goto DONE_DCL;
        }

#endif

        info = blockDcl->tnDcl.tnDclInfo;
        if  (blockDcl->tnFlags & TNF_VAR_INIT)
        {
            assert(info->tnOper == TN_LIST);
            info = info->tnOp.tnOp1;
        }

        assert(info->tnOper == TN_NAME); name = info->tnName.tnNameId;

        /* If there was a redefinition, we shouldn't have made it here */

        assert(name == NULL || ourStab->stLookupLclSym(name, blockScp) == NULL);

        /* Is this a static variable? */

        if  (blockDcl->tnFlags & TNF_VAR_STATIC)
        {
            SymList         list;

            /* Declare the symbol, making sure it sticks around */

            localSym = ourStab->stDeclareLcl(name,
                                             SYM_VAR,
                                             NS_NORM,
                                             blockScp,
                                             &cmpAllocPerm);

            localSym->sdIsStatic = true;

            /* Add it to the list of local statics */

#if MGDDATA
            list = new SymList;
#else
            list =    (SymList)cmpAllocCGen.nraAlloc(sizeof(*list));
#endif

            list->slSym  = localSym;
            list->slNext = cmpLclStatListT;
                           cmpLclStatListT = list;
        }
        else
        {
            /* Declare the local variable symbol */

            localSym = ourStab->stDeclareLcl(name,
                                             SYM_VAR,
                                             NS_NORM,
                                             blockScp,
                                             &cmpAllocCGen);

            localSym->sdVar.sdvLocal = true;

#ifdef  SETS

            if  (blockDcl->tnFlags & TNF_VAR_UNREAL)
                localSym->sdIsImplicit = true;

#endif

            /* Is this a local constant? */

            if  (blockDcl->tnFlags & TNF_VAR_CONST)
                localSym->sdVar.sdvConst = true;
        }

        localSym->sdCompileState = CS_KNOWN;
        localSym->sdAccessLevel  = ACL_PUBLIC;

#ifdef  DEBUG
        if  (!(blockDcl->tnFlags & TNF_VAR_ARG)) localSym->sdType = NULL;
#endif

//      printf("Pre-dcl local  [%08X] '%s'\n", localSym, cmpGlobalST->stTypeName(NULL, localSym, NULL, NULL, false));

        /* Save the symbol reference in the declaration node */

        blockDcl->tnDcl.tnDclSym = localSym; assert(localSym->sdIsDefined == false);

#ifdef  SETS
    DONE_DCL:
#endif

        /* Mark the symbol as argument / local var and assign it an index */

        if  (blockDcl->tnFlags & TNF_VAR_ARG)
        {
            /* Check and set the type of the argument */

            cmpBindType(blockDcl->tnType, false, false);

            localSym->sdType            = blockDcl->tnType;
            localSym->sdCompileState    = CS_DECLARED;
            localSym->sdVar.sdvArgument = true;

#ifdef  OLD_IL
            if  (!cmpConfig.ccOILgen)
#endif
            localSym->sdVar.sdvILindex  = cmpILgen->genNextArgNum();

            /* Is this a "byref" argument? */

            assert(outer);
            assert(argList);
            assert(argList->adName == localSym->sdName);

            if  (cmpCurFncTyp->tdFnc.tdfArgs.adExtRec)
            {
                unsigned        argFlags;

                assert(argList->adIsExt);

                argFlags = ((ArgExt)argList)->adFlags;

                if      (argFlags & (ARGF_MODE_OUT|ARGF_MODE_INOUT))
                    localSym->sdVar.sdvMgdByRef = true;
                else if (argFlags & (ARGF_MODE_REF))
                    localSym->sdVar.sdvUmgByRef = true;
            }

            argList = argList->adNext;
        }
        else if (!localSym->sdIsStatic && !localSym->sdVar.sdvConst)
        {
            if  (localSym->sdIsImplicit)
            {
#ifndef NDEBUG
                localSym->sdVar.sdvILindex = (unsigned)-1;
#endif
            }
            else
                localSym->sdVar.sdvILindex = cmpILgen->genNextLclNum();

            /* Is this a 'catch' exception handler? */

            if  (isCatch)
            {
                /* This is the start of a 'catch' - save the caught object */

                cmpILgen->genCatchBeg(localSym);

                /* Mark the symbol appropriately */

                localSym->sdVar.sdvCatchArg = true;

                /* Only do this for the very first local variable */

                isCatch = false;
            }
        }
#ifdef  DEBUG
        else
        {
            localSym->sdVar.sdvILindex = 0xBEEF;    // to detect improper use
        }
#endif

        /* If this is a "for" loop scope, process the declaration fully */

        if  (block->tnFlags & TNF_BLK_FOR)
            cmpStmt(blockDcl);

        /* Locate the next declaration entry */

        blockLst = blockLst->tnDcl.tnDclNext;
    }

    /* Return the scope we've created */

    return  blockScp;
}

/*****************************************************************************
 *
 *  Compile and generate code for the given block of statements.
 */

SymDef              compiler::cmpBlock(Tree block, bool outer)
{
    Tree            stmt;

    SymTab          stab     = cmpGlobalST;
    SymDef          outerScp = cmpCurScp;
    SymDef          blockScp = NULL;

    assert(block);

    if  (block->tnOper == TN_ERROR)
        goto EXIT;

    assert(block->tnOper == TN_BLOCK);

    /* Are there any local variables / arguments in this scope? */

    if  (block->tnBlock.tnBlkDecl || outer)
    {
        blockScp = cmpBlockDecl(block,
                                outer,
                                false,
                                (block->tnFlags & TNF_BLK_CATCH) != 0);

#ifdef  OLD_IL
        if  (cmpConfig.ccOILgen) cmpOIgen->GOIgenFncEnt(blockScp, outer);
#endif

#ifdef  SETS

        /* Are we generating code for a sort/filter funclet ? */

        if  (cmpCurFncSym->sdFnc.sdfFunclet)
        {
            unsigned            toss;
            Tree                retx;

            /* Recover the funclet expression */

            assert(cmpCurFuncletBody);

            retx = cmpReadExprTree(cmpCurFuncletBody, &toss);

#ifndef NDEBUG
            cmpCurFuncletBody = NULL;
#endif

            /* Is this a special kind of a funclet (not a filter-style) ? */

            if      (retx->tnOper == TN_LIST && (retx->tnFlags & TNF_LIST_SORT))
            {
                cmpStmtSortFnc(retx);
            }
            else if (retx->tnOper == TN_LIST && (retx->tnFlags & TNF_LIST_PROJ))
            {
                cmpStmtProjFnc(retx);
            }
            else
            {
                /* Generate the return statement */

                cmpILgen->genStmtRet(retx);

                cmpStmtReachable = false;
            }

            goto DONE;
        }

#endif

        /*
            If this is a constructor and there was no call to a ctor
            of the same class or a base class (or this is a class that
            has no base class, such as Object or a value type), we'll
            insert any member initializers at the ctor's beginning.
         */

        if  (outer && cmpCurFncSym->sdFnc.sdfCtor)
        {
            if  (cmpCurFncSym->sdIsStatic || cmpBaseCTcall)
            {
                cmpAddCTinits();
            }
            else
            {
                TypDef          clsTyp = cmpCurFncSym->sdParent->sdType;

                if  (clsTyp->tdClass.tdcValueType || !clsTyp->tdClass.tdcBase)
                    cmpAddCTinits();
            }
        }
    }

    /* Now process all the statements/declarations in the block */

    for (stmt = block->tnBlock.tnBlkStmt; stmt; stmt = stmt->tnOp.tnOp2)
    {
        Tree            ones;

        assert(stmt->tnOper == TN_LIST);
        ones = stmt->tnOp.tnOp1;

        while (ones->tnOper == TN_LIST)
        {
            cmpStmt(ones->tnOp.tnOp1);
            ones =  ones->tnOp.tnOp2;

            if  (!ones)
                goto NXTS;
        }

        cmpStmt(ones);

    NXTS:;

    }

#ifdef  SETS
DONE:
#endif

    /* For debug info, close a lexical scope if one was opened */

    if  (cmpConfig.ccGenDebug && cmpCurScp != outerScp
                              && cmpCurFncSym->sdIsImplicit == false)
    {
        if  (cmpSymWriter->CloseScope(0))
            cmpGenFatal(ERRdebugInfo);

        cmpCurScp->sdScope.sdEndBlkAddr = cmpILgen->genBuffCurAddr();
        cmpCurScp->sdScope.sdEndBlkOffs = cmpILgen->genBuffCurOffs();
    }

EXIT:

    /* Make sure we restore the previous scope */

    cmpCurScp = outerScp;

    /* Return the scope we've created */

    return  blockScp;
}

/*****************************************************************************
 *
 *  Generate MSIL for a function - start.
 */

SymDef              compiler::cmpGenFNbodyBeg(SymDef    fncSym,
                                              Tree      body,
                                              bool      hadGoto,
                                              unsigned  lclVarCnt)
{
    TypDef          fncTyp;
    SymDef          fncScp;

    assert(cmpCurScp == NULL);

    /* Get hold of the function type and make sure it looks OK */

    assert(fncSym && fncSym->sdSymKind  == SYM_FNC);
    fncTyp = fncSym->sdType;
    assert(fncTyp && fncTyp->tdTypeKind == TYP_FNC);

    /* Make the function symbol and type available to everyone */

    cmpCurFncSym   = fncSym;
    cmpCurFncTyp   = fncTyp;
    cmpCurFncRtp   = cmpActualType(fncTyp->tdFnc.tdfRett);
    cmpCurFncRvt   = cmpCurFncRtp->tdTypeKindGet();

    /* We don't have any local static variables yet */

    cmpLclStatListT = NULL;

    /* We haven't had any returns out of try/catch */

    cmpLeaveLab    = NULL;
    cmpLeaveTmp    = NULL;

    cmpInTryBlk    = 0;
    cmpInHndBlk    = 0;

    /* We haven't initialized any instance members */

#ifndef NDEBUG
    cmpDidCTinits  = false;
#endif

    /* Do we need to check for uninitialized variable use? */

    cmpLclVarCnt   = lclVarCnt;
    cmpChkVarInit  = false;
    cmpChkMemInit  = false;

    if  (cmpConfig.ccSafeMode || cmpConfig.ccChkUseDef)
        cmpChkVarInit = true;

    /* Static ctors have to init all constant members */

    if  (fncSym->sdFnc.sdfCtor && fncSym->sdIsStatic)
    {
        /* Track any uninitialized constant static members */

        SymDef          memSym;

        for (memSym = fncSym->sdParent->sdScope.sdScope.sdsChildList;
             memSym;
             memSym = memSym->sdNextInScope)
        {
            if  (memSym->sdSymKind == SYM_VAR &&
                 memSym->sdIsSealed           &&
                 memSym->sdIsStatic           && !memSym->sdVar.sdvHadInit)
            {
                /* We'll have to track this sucker's initialization state */

                memSym->sdVar.sdvILindex = lclVarCnt++;

//              if  (!strcmp(memSym->sdSpelling(), "DaysToMonth365")) forceDebugBreak();

                /* Allow assignment to the variable in the ctor body */

                memSym->sdVar.sdvHadInit = true;
                memSym->sdVar.sdvCanInit = true;
                memSym->sdVar.sdvChkInit = true;

                /* We'll definitely need to track initializions */

                cmpChkVarInit = true;
                cmpChkMemInit = true;
            }
        }
    }

    /* Start up the initialization checking logic if necessary */

    if  (cmpChkVarInit)
        cmpChkVarInitBeg(lclVarCnt, hadGoto);

    /* Get the statement list started */

    cmpStmtLast.snStmtExpr = NULL;
    cmpStmtLast.snStmtKind = TN_NONE;
    cmpStmtLast.snLabel    = NULL;
    cmpStmtLast.snLabCont  = NULL;
    cmpStmtLast.snLabBreak = NULL;
    cmpStmtLast.snOuter    = NULL;

    cmpStmtNest            = &cmpStmtLast;

//  printf("\nGen MSIL for '%s'\n", fncSym->sdSpelling());
//  if  (!strcmp(fncSym->sdSpelling(), "")) forceDebugBreak();

#ifdef DEBUG

    if  (cmpConfig.ccVerbose >= 4)
    {
        printf("Compile function body:\n");
        cmpParser->parseDispTree(body);
    }
#endif

#ifdef  OLD_IL
    if  (cmpConfig.ccOILgen) cmpOIgen->GOIgenFncBeg(fncSym, cmpCurFncSrcBeg);
#endif

    /* The entry point of the function is always reachable */

    cmpStmtReachable = true;

    /* Compile and generate code for the function body */

    fncScp = cmpBlock(body, true);

    /* Make sure someone didn't leave a statement entry in the list */

    assert(cmpStmtNest == &cmpStmtLast);

    /* Make sure we didn't lose track of try/catch blocks */

    assert(cmpInTryBlk == 0);
    assert(cmpInHndBlk == 0);

#ifndef NDEBUG

    /* Make sure the right thing happened with instance members */

    bool            shouldHaveInitializedMembers = false;

    /*
        Constructors should always initialize any members with initializers,
        the only exception is when there is an explicit call to another ctor
        within the same class.
     */

    if  (fncSym->sdFnc.sdfCtor)
    {
        if  (fncSym->sdIsStatic || !cmpThisCTcall)
        {
            shouldHaveInitializedMembers = true;
        }
        else
        {
            TypDef          clsTyp = fncSym->sdParent->sdType;

            if  (clsTyp->tdClass.tdcValueType || !clsTyp->tdClass.tdcBase)
                shouldHaveInitializedMembers = true;
        }
    }

    assert(cmpDidCTinits == shouldHaveInitializedMembers);

#endif

    /* Do we need to add a return statement? */

    if  (cmpStmtReachable)
    {
        if  (cmpCurFncRvt == TYP_VOID || cmpCurFncSym->sdFnc.sdfCtor)
        {
            if  (cmpChkMemInit)
                cmpChkMemInits();

#ifdef  OLD_IL
            if  (cmpConfig.ccOILgen)
                cmpOIgen->GOIstmtRet(NULL);
            else
#endif
                cmpILgen->genStmtRet(NULL);
        }
        else
        {
            assert(body->tnOper == TN_BLOCK);
            cmpErrorTree = NULL;
            cmpScanner->scanSetTokenPos(body->tnBlock.tnBlkSrcEnd);

            cmpError(ERRmisgRet, cmpCurFncTyp->tdFnc.tdfRett);
        }
    }

    /* Do we need a label for a return from try/catch ? */

    if  (cmpLeaveLab)
    {
        cmpILgen->genFwdLabDef(cmpLeaveLab);

        if  (cmpLeaveTmp)
        {
            /* Non-void value: return the value of the temp */

            assert(cmpCurFncRtp->tdTypeKind != TYP_VOID);

            cmpILgen->genStmtRet(cmpCreateVarNode(NULL, cmpLeaveTmp));

            cmpTempVarDone(cmpLeaveTmp);
        }
        else
        {
            /* No return value: just return */

            assert(cmpCurFncRtp->tdTypeKind == TYP_VOID);
            cmpILgen->genStmtRet(NULL);
        }
    }

    /* Did we do static member initialization checking ? */

    if  (cmpChkMemInit)
    {
        SymDef          memSym;

        assert(fncSym->sdFnc.sdfCtor);
        assert(fncSym->sdIsStatic);

        for (memSym = fncSym->sdParent->sdScope.sdScope.sdsChildList;
             memSym;
             memSym = memSym->sdNextInScope)
        {
            if  (memSym->sdSymKind == SYM_VAR &&
                 memSym->sdIsSealed           &&
                 memSym->sdIsStatic           &&
                 memSym->sdVar.sdvChkInit)
            {
                memSym->sdVar.sdvHadInit = true;
                memSym->sdVar.sdvCanInit = false;
                memSym->sdVar.sdvChkInit = false;
            }
        }
    }

    /* Did we check for uninitialized variable use? */

    if  (cmpChkVarInit)
        cmpChkVarInitEnd();

#ifdef  OLD_IL
    if  (cmpConfig.ccOILgen) cmpOIgen->GOIgenFncEnd(cmpCurFncSrcEnd);
#endif

    return  fncScp;
}

/*****************************************************************************
 *
 *  Generate MSIL for a function - end.
 */

void                compiler::cmpGenFNbodyEnd()
{
    SymList         list;

    /* Walk the list of variables declared as static locals with the function */

    list = cmpLclStatListT;
    if  (!list)
        return;

    do
    {
        SymList         next   = list->slNext;
        SymDef          varSym = list->slSym;

        assert(varSym->sdSymKind == SYM_VAR);
        assert(varSym->sdVar.sdvLocal == false);
        assert(varSym->sdIsStatic);

        /* Change the parent so the variable appears to be a global */

        varSym->sdParent    = cmpGlobalNS;
        varSym->sdNameSpace = NS_HIDE;

        /* Make sure the space for the variable has been allocated */

        if  (varSym->sdType && !varSym->sdIsManaged)
        {
            cmpAllocGlobVar(varSym);

            /* Record the variable so that we set its RVA at the very end */

#if MGDDATA
            list = new SymList;
#else
            list =    (SymList)cmpAllocPerm.nraAlloc(sizeof(*list));
#endif

            list->slSym  = varSym;
            list->slNext = cmpLclStatListP;
                           cmpLclStatListP = list;
        }

        list = next;
    }
    while (list);
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\hash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _HASH_H_
#define _HASH_H_
/*****************************************************************************/
#ifndef _ALLOC_H_
#include "alloc.h"
#endif
/*****************************************************************************/
#ifndef _TOKENS_H_
#include "tokens.h"
#endif
/*****************************************************************************/
#ifndef _TREEOPS_H_
#include "treeops.h"
#endif
/*****************************************************************************/

const   unsigned    HASH_TABLE_SIZE =  256;     // recommended hash table size

/*****************************************************************************/

DEFMGMT class IdentRec
{
public:

    Ident           idNext;         // next identifier in this hash bucket

    SymDef          idSymDef;       // list of definitions, if any

    unsigned        idHash;         // hash value

    unsigned        idOwner;        // index of owning symbol table

    unsigned char   idToken;        // token# if the identifier is a keyword
    unsigned char   idFlags;        // see IDF_XXXX below

    stringBuff      idSpelling() { assert(this); return idName; }
    unsigned        idSpellLen() { assert(this); return idNlen; }

    unsigned short  idNlen;         // length of the identifier's name

#if MGDDATA
    char         [] idName;         // the spelling follows
#else
    char            idName[];       // the spelling follows
#endif

};

enum   IdentFlags
{
    IDF_WIDE_CHARS = 0x01,          // the identifier contains a non-ASCII char
    IDF_MACRO      = 0x02,          // the identifier is defined as a macro?
    IDF_HIDDEN     = 0x04,          // the identifier was invented by compiler
    IDF_PREDEF     = 0x08,          // the identifier has some pre-defined meaning
    IDF_STDVTP     = 0x10,          // the identifier denotes a std value type

#ifdef  SETS
    IDF_XMLELEM    = 0x20,          // the identifier denotes an XML element name
#endif

    IDF_USED       = 0x80           // identifier referenced by source code
};

/*****************************************************************************/

DEFMGMT class IdentListRec
{
public:

    IdentList       nlNext;
    Ident           nlName;
};

/*****************************************************************************/

struct  kwdDsc
{
    unsigned char   kdOper1;
    unsigned char   kdOper2;
    unsigned char   kdOper1prec;
    unsigned char   kdOper2prec;

    unsigned        kdValue     :8;
    unsigned        kdModifier  :8;
    unsigned        kdAttribs   :8;
};

/*****************************************************************************/

DEFMGMT class hashTab
{
public:

    /*************************************************************************/

    bool            hashInit(Compiler         comp,
                             unsigned         count,
                             unsigned         owner,
                             norls_allocator *alloc);

    void            hashDone();
    void            hashFree();

    /*************************************************************************/

private:

    norls_allocator hashMemAllocPriv;
    norls_allocator*hashMemAlloc;
    bool            hashMemAllocInit(Compiler comp, norls_allocator*alloc);

    void            hashMemAllocDone();
    void            hashMemAllocFree();

    /*************************************************************************/

    Ident           tokenToIdTab[tkCount];

public:

    Ident           tokenToIdent(tokens tok)
    {
        assert(tok < arraylen(tokenToIdTab));

        return  tokenToIdTab[tok];
    }

    /*************************************************************************/
    /* The following members provide miscellaneous operations on identifiers */
    /*************************************************************************/

    static
    stringBuff      identSpelling(Ident id)
    {
        assert(id); return  id->idName;
    }

    static
    size_t          identSpellLen(Ident id)
    {
        assert(id); return  id->idNlen;
    }

    static
    tokens          tokenOfIdent (Ident id)
    {
        assert(id); return  (tokens)id->idToken;
    }

    static
    void            identSetTok  (Ident id, unsigned tokNum)
    {
        assert(id); id->idToken = tokNum; assert(id->idToken == tokNum);
    }

    static
    unsigned char   getIdentFlags (Ident id)
    {
        assert(id); return  id->idFlags;
    }

    static
    void            setIdentFlags (Ident id, unsigned char fl)
    {
        assert(id);         id->idFlags |= fl;
    }

    static
    unsigned        identHashVal (Ident id)
    {
        assert(id); return  id->idHash;
    }

    static
    SymDef          getIdentSymDef(Ident id)
    {
        assert(id); return  id->idSymDef;
    }

    static
    void            setIdentSymDef(Ident id, SymDef sym)
    {
        assert(id);         id->idSymDef = sym;
    }

    static
    void            hashMarkHidden(Ident id)
    {
        assert(id); id->idFlags |= IDF_HIDDEN;
    }

    static
    bool            hashIsIdHidden(Ident id)
    {
        assert(id); return  (id->idFlags & IDF_HIDDEN) != 0;
    }

    /* The following is used by non-scanner hashes to store a 32-bit cookie */

#if 0

    static
    unsigned        getIdentValue(Ident id)
    {
        assert(id); return  id->idOwner;
    }

    static
    void            setIdentValue(Ident id, unsigned val)
    {
        assert(id);         id->idOwner = val;
    }

#endif

    /*************************************************************************/
    /* The following members are related to the keyword descriptor tables    */
    /*************************************************************************/

private:

    static
    const   kwdDsc  hashKwdDescs[tkKwdCount];
    static
    const    char * hashKwdNames[tkKwdCount];
    static
    unsigned char   hashKwdNlens[tkKwdCount];
    static
    const    char * hashKwdNtab [tkKwdCount];

    static
    const   kwdDsc* tokenDesc(tokens tok)
    {
        assert(tok <= tkKwdLast);
        return  hashKwdDescs + tok;
    }

public:

    const   char *  tokenName   (tokens  tok);
    const   size_t  tokenNlen   (tokens  tok);

    bool            tokenIsBinop(tokens  tok, unsigned * precPtr,
                                              treeOps  * operPtr);
    bool            tokenIsUnop (tokens  tok, unsigned * precPtr,
                                              treeOps  * operPtr);

    static
    bool            tokenIsType (tokens  tok);
    static
    bool            tokenBegsTyp(tokens  tok);
    static
    bool            tokenOvlOper(tokens  tok);
    static
    unsigned        tokenIsMod  (tokens  tok);

    /*************************************************************************/

private:

    Ident      *    hashTable;
    unsigned        hashCount;
    unsigned        hashMask;
    unsigned        hashIdCnt;
    unsigned        hashOwner;

public:

    Ident      *    hashGetAddr() { return hashTable; }
    unsigned        hashGetSize() { return hashCount; }

    Ident           hashNoName;

    /*************************************************************************/
    /* The following members are used to compute hash functions, etc.        */
    /*************************************************************************/

private:

    void            hashFuncInit(unsigned randSeed);

public:

    static
    bool            hashHasWideChars(const char *name)
    {
        return  false; // (strchr(name, '\\') != NULL);
    }

    static
    bool            hashStringCompare(const char *s1, const char *s2);

    static
    unsigned        hashComputeHashVal(const char *name);

    static
    unsigned        hashComputeHashVal(const char *name, size_t nlen);

    Ident           hashString(const char *name)
    {
        return  lookupName(name, strlen(name), hashComputeHashVal(name), true);
    }

    Ident           lookupString(const char *name)
    {
        return  lookupName(name, strlen(name), hashComputeHashVal(name), false);
    }

    Ident           hashName    (const char * name,
                                 unsigned     hash,
                                 unsigned     nlen,
                                 bool         wide);

    Ident           lookupName  (const char *    name,
                                 size_t          nlen,
                                 unsigned        hval,
                                 bool            add = false);
};

/*---------------------------------------------------------------------------*/

inline
bool                hashTab::tokenIsBinop(tokens tok, unsigned * precPtr,
                                                      treeOps  * operPtr)
{
    if  (tok <= tkKwdLast)
    {
        const kwdDsc *  tokDesc = tokenDesc(tok);

        *precPtr =          tokDesc->kdOper2prec;
        *operPtr = (treeOps)tokDesc->kdOper2;

        return  true;
    }
    else
    {
        return  false;
    }
}

inline
bool                hashTab::tokenIsUnop (tokens tok, unsigned * precPtr,
                                                      treeOps  * operPtr)
{
    if  (tok <= tkKwdLast)
    {
        const kwdDsc *  tokDesc = tokenDesc(tok);

        *precPtr =          tokDesc->kdOper1prec;
        *operPtr = (treeOps)tokDesc->kdOper1;

        return  true;
    }
    else
    {
        return  false;
    }
}

inline
bool                hashTab::tokenIsType (tokens tok)
{
    if  (tok <= tkKwdLast)
    {
        const kwdDsc *  tokDesc = tokenDesc(tok);

        return  (bool)((tokDesc->kdAttribs & 1) != 0);
    }
    else
    {
        return  false;
    }
}

inline
bool                hashTab::tokenBegsTyp(tokens tok)
{
    if  (tok <= tkKwdLast)
    {
        const kwdDsc *  tokDesc = tokenDesc(tok);

        return  (bool)((tokDesc->kdAttribs & 2) != 0);
    }
    else
    {
        return  false;
    }
}

inline
bool                hashTab::tokenOvlOper(tokens tok)
{
    if  (tok <= tkKwdLast)
    {
        const kwdDsc *  tokDesc = tokenDesc(tok);

        return  (bool)((tokDesc->kdAttribs & 4) != 0);
    }
    else
    {
        return  false;
    }
}

inline
unsigned            hashTab::tokenIsMod(tokens tok)
{
    if  (tok <= tkKwdLast)
    {
        const kwdDsc *  tokDesc = tokenDesc(tok);

        if  (tokDesc->kdModifier)
            return  1 << tokDesc->kdModifier;
    }

    return  0;
}

inline
const   char *      hashTab::tokenName(tokens tok)
{
    assert(tok != tkNone && tok <= tkKwdLast);

    return  hashKwdNames[tok];
}

inline
const   size_t      hashTab::tokenNlen(tokens tok)
{
    assert(tok != tkNone && tok <= tkKwdLast);

    return  hashKwdNlens[tok];
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\hash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcpch.h"
#pragma hdrstop

/*****************************************************************************/

#include "alloc.h"
#include "scan.h"

/*****************************************************************************/

#define MEASURE_HASH_STATS  0

/*****************************************************************************/

bool                hashTab::hashMemAllocInit(Compiler comp, norls_allocator*alloc)
{
    if  (alloc)
    {
        hashMemAlloc = alloc;
        return false;
    }

    hashMemAlloc = &hashMemAllocPriv;

    return  hashMemAllocPriv.nraInit(comp, OS_page_size);
}

void                hashTab::hashMemAllocDone()
{
}

void                hashTab::hashMemAllocFree()
{
    if  (hashMemAlloc == &hashMemAllocPriv)
        hashMemAllocPriv.nraFree();
}

/*****************************************************************************/

void                hashTab::hashDone()
{
    hashMemAllocDone();
}

void                hashTab::hashFree()
{
    hashMemAllocFree();
}

/*****************************************************************************/

#if MEASURE_HASH_STATS

unsigned            identCount;

unsigned            lookupCnt;
unsigned            lookupTest;
unsigned            lookupMatch;

void                dispHashTabStats()
{
    if  (identCount)
        printf("A total of %6u identifiers in hash table\n", identCount);

    if  (!lookupCnt)
        return;

    printf("Average of %8.4f checks of bucket check  / lookup\n", (float)lookupTest /lookupCnt);
    printf("Average of %8.4f compares of identifiers / lookup\n", (float)lookupMatch/lookupCnt);
}

#endif

/*****************************************************************************/

Ident               hashTab::hashName(const   char *  name,
                                      unsigned        hval,
                                      unsigned        nlen,
                                      bool            wide)
{
    Ident    *  lastPtr;
    unsigned    hash;
    Ident       id;
    size_t      sz;

    assert(nlen == strlen(name));
    assert(hval == hashComputeHashVal(name));

    /* Mask the appropriate bits from the hash value */

    hash = hval & hashMask;

    /* Search the hash table for an existing match */

    lastPtr = &hashTable[hash];

    for (;;)
    {
        id = *lastPtr;
        if  (!id)
            break;

        /* Check whether the hash value matches */

        if  (id->idHash == hval && id->idNlen == nlen)
        {

#if 1

            unsigned        ints = nlen / sizeof(int);

            const char *    ptr1 = id->idName;
            const char *    ptr2 = name;

            while (ints)
            {
                if  (*(unsigned *)ptr1 != *(unsigned *)ptr2)
                    goto NEXT;

                ptr1 += sizeof(unsigned);
                ptr2 += sizeof(unsigned);

                ints -= 1;
            }

            ints = nlen % sizeof(int);

            while (ints)
            {
                if  (*ptr1 != *ptr2)
                    goto NEXT;

                ptr1++;
                ptr2++;
                ints--;
            }

            return  id;

#else

            if  (!memcmp(id->idName, name, nlen+1))
                return  id;

#endif

        }

    NEXT:

        lastPtr = &id->idNext;
    }

#if MGDDATA

    id = new Ident;

    id->idName = new managed char[nlen+1]; UNIMPL(!"need to copy string");

#else

    /* Figure out the size to allocate */

    sz  = sizeof(*id);

    /* Include space for name string + terminating null and round the size */

    sz +=   sizeof(int) + nlen;
    sz &= ~(sizeof(int) - 1);

    /* Allocate space for the identifier */

    id = (Ident)hashMemAlloc->nraAlloc(sz);

    /* Copy the name string */

    memcpy(id->idName, name, nlen+1);

#endif

    /* Insert the identifier into the hash list */

    *lastPtr = id;

    /* Fill in the identifier record */

    id->idNext   = NULL;
    id->idToken  = 0;
    id->idFlags  = 0;
    id->idSymDef = NULL;

    id->idHash   = hval;
    id->idNlen   = nlen;
    id->idOwner  = hashOwner;

    /* Remember whether the name has any wide characters in it */

    if  (wide) id->idFlags |= IDF_WIDE_CHARS;

#if MEASURE_HASH_STATS
    identCount++;
#endif

    return  id;
}

/*****************************************************************************
 *
 *  Look for the given name in the hash table (if 'hval' is non-zero, it must
 *  be equal to the hash value for the identifier). If the identifier is not
 *  found it is added if 'add' is non-zero, otherwise NULL is returned.
 */

Ident               hashTab::lookupName(const char *    name,
                                        size_t          nlen,
                                        unsigned        hval,
                                        bool            add)
{
    Ident           id;
    unsigned        hash;

    assert(nlen == strlen(name));
    assert(hval == hashComputeHashVal(name) || hval == 0);

    /* Make sure we have a proper hash value */

    if  (hval == 0)
    {
        hval = hashComputeHashVal(name);
    }
    else
    {
        assert(hval == hashComputeHashVal(name));
    }

    /* Mask the appropriate bits from the hash value */

    hash = hval & hashMask;

    /* Search the hash table for an existing match */

#if MEASURE_HASH_STATS
    lookupCnt++;
#endif

    for (id = hashTable[hash]; id; id = id->idNext)
    {
        /* Check whether the hash value and identifier lengths match */

#if MEASURE_HASH_STATS
        lookupTest++;
#endif

        if  (id->idHash == hval)
        {

#if MEASURE_HASH_STATS
            lookupMatch++;
#endif

            if  (!memcmp(id->idName, name, nlen+1))
                return  id;
        }
    }

    assert(id == 0);

    /* Identifier not found - are we supposed to add it? */

    if  (add)
    {
        /* Add the identifier to the hash table */

        id = hashName(name, hval, nlen, hashHasWideChars(name));
    }

    return  id;
}

/*****************************************************************************/
#ifndef __SMC__

const    char * hashTab::hashKwdNames[tkKwdCount];
unsigned char   hashTab::hashKwdNlens[tkKwdCount];

#endif
/*****************************************************************************/

bool            hashTab::hashInit(Compiler          comp,
                                  unsigned          count,
                                  unsigned          owner,
                                  norls_allocator * alloc)
{
    size_t      hashBytes;

    assert(count);

    /* Start up the memory allocation subsystem */

    if  (hashMemAllocInit(comp, alloc))
        return true;

    /* Save the owner id */

    hashOwner = owner;

    /* Copy the keyword table into the hash table */

    assert(sizeof(hashKwdNtab) == sizeof(hashKwdNames));
    memcpy(&hashKwdNames, &hashKwdNtab, sizeof(hashKwdNames));

    /* Don't have any spellings yet */

    hashIdCnt = 0;

    /* Allocate the hash bucket table */

    hashCount = count;
    hashMask  = count - 1;
    hashBytes = count * sizeof(*hashTable);
    hashTable = (Ident*)comp->cmpAllocBlock(hashBytes);

    memset(hashTable, 0, hashBytes);

    /* Initialize the hash function logic */

    hashFuncInit(20886);

    /* Hash all the keywords, if this is the global hash table */

    if  (owner == 0)
    {
        unsigned    kwdNo;

        assert(tkKwdCount >= tkID);

#ifdef  DEBUG
        memset(tokenToIdTab, 0, sizeof(tokenToIdTab));
#endif

        for (kwdNo = 0; kwdNo < tkID; kwdNo++)
        {
            Ident       kwid;

            kwdDsc      kdsc = hashKwdDescs[kwdNo];
            const char *name = hashKwdNames[kwdNo];
//          const char *norg = name;
            size_t      nlen;

            /* Ignore this entry if it's not 'real' */

            if  (!name)
                continue;

            /* Is this a non-keyword? */

//          if  (*name == '@')
//              name++;

            /* Record the keyword length (this is used by the lister) */

            hashKwdNlens[kwdNo] = nlen = strlen(name);

            /* Hash the keyword */

            tokenToIdTab[kdsc.kdValue] = kwid = hashString(name);
            if  (!kwid)
                return  true;

            /* Don't mark it if it's not a "real" keyword */

//          if  (norg != name)
//              continue;

            /* Mark this identifier as a keyword */

            kwid->idToken = kdsc.kdValue;

            /* Make sure we really have a keyword */

            assert(kwid->idToken != tkNone);
            assert(kwid->idToken != tkID);
        }
    }

    return false;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\imports.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef  _MSC_VER
extern  "C" {
#endif
/****************************************************************************/
/*                   Little helper routines defined "inline"                */
/****************************************************************************/

inline
int     isalpha(int c)
{
    return  (c >= 'A' && c <= 'Z' ||
             c >= 'a' && c <= 'z');
}

inline
int     isdigit(int c)
{
    return  (c >= '0' && c <= '9');
}

inline
int     isalnum(int c)
{
    return  isalpha(c) || isdigit(c);
}

inline
int     isspace(int c)
{
    return  (c == ' ') || (c == '\t');
}

inline
int     toupper(int c)
{
    if  (c >= 'a' && c <= 'z')
        c -= 'a' - 'A';

    return  c;
}

#ifndef _MSC_VER

int     max( int a,  int b) { return (a > b) ? a : b; }
uint    max(uint a, uint b) { return (a > b) ? a : b; }

void    forceDebugBreak(){}

#endif

/****************************************************************************/
/*                                varargs                                   */
/****************************************************************************/

#ifndef _MSC_VER

typedef ArgIterator  va_list;
void    va_end(INOUT va_list args) { args.End(); }

#endif

/****************************************************************************/
/*                                  SEH                                     */
/****************************************************************************/

#ifndef _MSC_VER

extern  unsigned    _exception_code();
extern  void *      _exception_info();

extern  int         _abnormal_termination();

#endif

/****************************************************************************/
/*                                file I/O                                  */
/****************************************************************************/

#ifndef _MSC_VER

const uint _O_RDONLY     = 0x0000;
const uint _O_WRONLY     = 0x0001;
const uint _O_RDWR       = 0x0002;
const uint _O_APPEND     = 0x0008;

const uint _O_CREAT      = 0x0100;
const uint _O_TRUNC      = 0x0200;
const uint _O_EXCL       = 0x0400;

const uint _O_TEXT       = 0x4000;
const uint _O_BINARY     = 0x8000;

const uint _O_SEQUENTIAL = 0x0020;
const uint _O_RANDOM     = 0x0010;


const uint _S_IFMT      =  0170000;
const uint _S_IFDIR     =  0040000;
const uint _S_IFCHR     =  0020000;
const uint _S_IFIFO     =  0010000;
const uint _S_IFREG     =  0100000;
const uint _S_IREAD     =  0000400;
const uint _S_IWRITE    =  0000200;
const uint _S_IEXEC     =  0000100;

const uint _A_NORMAL    =  0x00;
const uint _A_RDONLY    =  0x01;
const uint _A_HIDDEN    =  0x02;
const uint _A_SYSTEM    =  0x04;
const uint _A_SUBDIR    =  0x10;
const uint _A_ARCH      =  0x20;

#endif

IMPCRT("msvcrt.dll:printf")     int      printf(           const char *fmt, ...);
IMPCRT("msvcrt.dll:sprintf")    int     sprintf(char *dst, const char *fmt, ...);
IMPCRT("msvcrt.dll:_close")     int     _close(int);
IMPCRT("msvcrt.dll:_open")      int     _open(const char *, int, ...);
IMPCRT("msvcrt.dll:_unlink")    int     _unlink(const char *);
IMPCRT("msvcrt.dll:_write")     int     _write(int, const void *, unsigned int);

#ifndef _MSC_VER

typedef unsigned short  _ino_t;
typedef unsigned int    _dev_t;
typedef __int32         _off_t;

struct  _Fstat
{
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
};

IMPCRT("msvcrt.dll:_stat")      int     _stat(const char *, _Fstat *);

struct  _iobuf
{
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
};
typedef _iobuf FILE;

#endif

IMPCRT("msvcrt.dll:fopen")      FILE *  fopen(const char *, const char *);
IMPCRT("msvcrt.dll:fgets")      char *  fgets(char *, int, FILE *);
IMPCRT("msvcrt.dll:fclose")     int     fclose(FILE *);
IMPCRT("msvcrt.dll:fflush")     int     fflush(FILE *);
IMPCRT("msvcrt.dll:_flushall")  int     _flushall();

/****************************************************************************/
/*                           wildcards / paths                              */
/****************************************************************************/

#ifndef _MSC_VER

const   size_t          _MAX_PATH        = 260;
const   size_t          _MAX_DRIVE       = 3;
const   size_t          _MAX_DIR         = 256;
const   size_t          _MAX_FNAME       = 256;
const   size_t          _MAX_EXT         = 256;

struct _finddata_t
{
    unsigned    attrib;
    time_t      time_create;    /* -1 for FAT file systems */
    time_t      time_access;    /* -1 for FAT file systems */
    time_t      time_write;
    unsigned    size;
    char        name[260];
};

#endif

IMPCRT("msvcrt.dll:_findclose") int     _findclose(__int32);
IMPCRT("msvcrt.dll:_findfirst") LONG    _findfirst(const char *, _finddata_t *);
IMPCRT("msvcrt.dll:_findnext")  int     _findnext(__int32, _finddata_t *);

IMPCRT("msvcrt.dll:_splitpath") void    _splitpath(const char *, char *, char *, char *, char *);
IMPCRT("msvcrt.dll:_makepath")  void    _makepath(char *, const char *, const char *, const char *, const char *);
IMPCRT("msvcrt.dll:_wsplitpath")void    _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);
IMPCRT("msvcrt.dll:_wmakepath") void    _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *);

/****************************************************************************/
/*                            string / memory                               */
/****************************************************************************/

IMPCRT("msvcrt.dll:memcmp")     int     memcmp(const void *, const void *, size_t);
IMPCRT("msvcrt.dll:memcpy")     void    memcpy(void *, const void *, size_t);
IMPCRT("msvcrt.dll:memset")     void *  memset(void *,  int, size_t);
IMPCRT("msvcrt.dll:strlen")     size_t  strlen(const char *);
IMPCRT("msvcrt.dll:strchr")     char *  strchr(const char *, int);
IMPCRT("msvcrt.dll:strcmp")     int     strcmp(const char *, const char *);
IMPCRT("msvcrt.dll:strcpy")     char *  strcpy(char *, const char *);
IMPCRT("msvcrt.dll:strcat")     char *  strcat(char *, const char *);
IMPCRT("msvcrt.dll:strncpy")    char *  strncpy(char *, const char *, size_t);
IMPCRT("msvcrt.dll:_stricmp")   int    _stricmp(const char *, const char *);

IMPCRT("msvcrt.dll:wcscmp")     int     wcscmp(const wchar_t *, const wchar_t *);
IMPCRT("msvcrt.dll:wcslen")     size_t  wcslen(const wchar_t *);
IMPCRT("msvcrt.dll:wcscpy")     wchar_t*wcscpy(wchar_t *, const wchar_t *);
IMPCRT("msvcrt.dll:wcschr")     wchar_t*wcschr(const wchar_t *, wchar_t);
IMPCRT("msvcrt.dll:wcscat")     wchar_t*wcscat(wchar_t *, const wchar_t *);
IMPCRT("msvcrt.dll:wcsrchr")    wchar_t*wcsrchr(const wchar_t *, wchar_t);
IMPCRT("msvcrt.dll:wcsncmp")    int     wcsncmp(const wchar_t *, const wchar_t *, size_t);

IMPCRT("msvcrt.dll:mbstowcs")   size_t  mbstowcs(wchar *, const char *, size_t);
IMPCRT("msvcrt.dll:wcstombs")   size_t  wcstombs(char *, const wchar *, size_t);

#if MGDDATA
int                                     strcmp(char managed [] str1, char * str2)
{
    UNIMPL(!"strcmp");
    return  0;
}
#endif

/****************************************************************************/
/*                             misc C runtime                               */
/****************************************************************************/

IMPCRT("msvcrt.dll:malloc")     void *  malloc(size_t);
IMPCRT("msvcrt.dll:free")       void    free(void *);

IMPCRT("msvcrt.dll:qsort")      void    qsort(void *, size_t, size_t, int (*)(const void *, const void *));

IMPCRT("msvcrt.dll:exit")       void    exit(int);

IMPCRT("msvcrt.dll:srand")      void    srand(int);
IMPCRT("msvcrt.dll:rand")       int      rand();

IMPCRT("msvcrt.dll:time")       void    time(time_t *);

IMPCRT("msvcrt.dll:atof")       double  atof(const char *);
IMPCRT("msvcrt.dll:atoi")       int     atoi(const char *);

IMPCRT("msvcrt.dll:_isnan")     int     _isnan(double);

/****************************************************************************/
#ifdef  _MSC_VER
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\infile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _INFILE_H_
#define _INFILE_H_
/*****************************************************************************/

struct infileState;

class  infile
{
public:

    bool            inputStreamInit(Compiler        comp,
                                    const char    * filename,
                                    bool            textMode);

    void            inputStreamInit(Compiler        comp,
                                    QueuedFile      buff,
                                    const char    * text);

    void            inputStreamDone();

    const   char *  inputSrcFileName()
    {
        return  inputFileName;
    }

    void            inputSetFileName(const char *fname)
    {
        inputFileName = fname;
    }

private:

    unsigned        inputStreamMore();

    Compiler        inputComp;

    const   char *  inputSrcText;
    QueuedFile      inputSrcBuff;

    bool            inputFileText;
    const char *    inputFileName;
    bool            inputFileOver;

    size_t          inputBuffSize;
    const BYTE *    inputBuffAddr;
public:
    const BYTE *    inputBuffNext;
private:
    const BYTE *    inputBuffLast;

    unsigned        inputFilePos;

    HANDLE          inputFile;

public:

    unsigned        inputStreamRdU1();
    void            inputStreamUnU1();

    /* The following keep track of text lines */

private:

    unsigned        inputStreamLineNo;
    const BYTE    * inputStreamLineBeg;

public:

    unsigned        inputStreamNxtLine()
    {
        inputStreamLineBeg = inputBuffNext - 1;

        return  ++inputStreamLineNo;
    }

    unsigned        inputStreamNxtLine(const BYTE *pos)
    {
        inputStreamLineBeg = pos - 1;

        return  ++inputStreamLineNo;
    }

    unsigned        inputStreamCurCol()
    {
        return  inputBuffNext - inputStreamLineBeg;
    }
};

/*****************************************************************************
 *
 *  The following captures the state of the input file so that input from it
 *  can be suspended and restarted later.
 */

struct infileState
{
    size_t          inpsvBuffSize;
    const BYTE *    inpsvBuffAddr;
    const BYTE *    inpsvBuffNext;
    const BYTE *    inpsvBuffLast;

    const char *    inpsvFileName;

    bool            inpsvFileOver;
    unsigned        inpsvFilePos;

    unsigned        inpsvStreamLineNo;
    const BYTE *    inpsvStreamLineBeg;
};

/*****************************************************************************/

inline
unsigned            infile::inputStreamRdU1()
{
#if 0
    return  (inputBuffNext >= inputBuffLast) ? inputStreamMore()
                                             : *inputBuffNext++;
#else
    assert  (inputBuffNext <  inputBuffLast);
    return  *inputBuffNext++;
#endif
}

inline
void                infile::inputStreamUnU1()
{
    assert(inputBuffNext > inputBuffAddr);

    if  (!inputFileOver)
        inputBuffNext--;
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\host.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _HOST_H_
#define _HOST_H_
/*****************************************************************************/

#define STATIC_UNMANAGED_MEMBERS    1

/*****************************************************************************/

#pragma warning(disable:4237)

/*****************************************************************************/

#ifndef __SMC__
typedef unsigned            __uint32;
typedef unsigned __int64    __uint64;
#endif

/*****************************************************************************/

#ifdef  __64BIT__
typedef  __int64            NatInt;
typedef __uint64            NatUns;
#else
typedef  __int32            NatInt;
typedef __uint32            NatUns;
#endif

/*****************************************************************************/

#ifdef  __cplusplus

#define INOUT
#define   OUT
#define   REF   &

#ifndef DEFMGMT
#define DEFMGMT
#define MR  *
#endif

typedef wchar_t         wchar;
typedef struct _stat    _Fstat;

typedef  char         * AnsiStr;
typedef wchar_t       * wideStr;

#endif

#ifdef  __SMC__

void    DebugBreak();

#endif

/*****************************************************************************/

const   size_t      OS_page_size = 4096;

/*****************************************************************************/

// NOTE: The following is utterly non-portable

#ifndef __SMC__

#if defined(_X86_) && defined(_MSC_VER) && !defined(__IL__) // && !defined(__SMC__)

#define forceDebugBreak()   __try { __asm {int 3} }                         \
                            __except (EXCEPTION_EXECUTE_HANDLER) {}

#else

inline
void    forceDebugBreak(){}

#endif

#endif

/*****************************************************************************/

#ifdef  __COMRT__

typedef String              string_t;
typedef String  managed []  stringArr_t;

char    *           makeRawString(String s);
String              makeMgdString(char * s);

#else

typedef         char *      string_t;
typedef const   char *    * stringArr_t;

inline
const   char *      makeRawString(const char *s) { return s; }
inline
const   char *      makeMgdString(const char *s) { return s; }

#endif

/*****************************************************************************/
#ifndef __SMC__
/*****************************************************************************/

#ifndef NDEBUG

extern  "C"
void    __cdecl     __AssertAbort(const char *why, const char *file, unsigned line);

#undef  assert
#define assert(p)   if (!(p)){ forceDebugBreak(); __AssertAbort(#p, __FILE__, __LINE__); }

#define NO_WAY(s)            { forceDebugBreak(); __AssertAbort(#s, __FILE__, __LINE__); }
#define UNIMPL(s)            { forceDebugBreak(); __AssertAbort(#s, __FILE__, __LINE__); }

#else

#undef  assert
#define assert(p)

#define NO_WAY(s)
#define UNIMPL(s)

#endif

/*****************************************************************************/
#endif//__SMC__
/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\inlines.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _INLINES_H_
#define _INLINES_H_
/*****************************************************************************/
#ifndef _TREENODE_H_
#include "treenode.h"
#endif
/*****************************************************************************
 *
 *  The low-level tree node allocation routines.
 */

#ifdef  FAST

inline
Tree                parser::parseAllocNode()
{
    Tree            node;

    node = (Tree)parseAllocPriv.nraAlloc(sizeof(*node));

    return  node;
}

#endif

inline
Tree                parser::parseCreateNameNode(Ident name)
{
    Tree            node = parseCreateNode(TN_NAME);

    node->tnName.tnNameId = name;

    return  node;
}

inline
Tree                parser::parseCreateUSymNode(SymDef sym, SymDef scp)
{
    Tree            node = parseCreateNode(TN_ANY_SYM);

    node->tnSym.tnSym = sym;
    node->tnSym.tnScp = scp;

    return  node;
}

inline
Tree                parser::parseCreateOperNode(treeOps   op,
                                                Tree      op1,
                                                Tree      op2)
{
    Tree            node = parseCreateNode(op);

    node->tnOp.tnOp1 = op1;
    node->tnOp.tnOp2 = op2;

    return  node;
}

/*****************************************************************************
 *
 *  This belongs in comp.h, but tnVtypGet(), etc. are not available there.
 */

inline
TypDef              compiler::cmpDirectType(TypDef type)
{
    if  (type->tdTypeKind == TYP_TYPEDEF)
        type = type->tdTypedef.tdtType;

    return  type;
}

inline
var_types           compiler::cmpDirectVtyp(TypDef type)
{
    var_types       vtp = type->tdTypeKindGet();

    if  (vtp == TYP_TYPEDEF)
        vtp = type->tdTypedef.tdtType->tdTypeKindGet();

    return  vtp;
}

inline
TypDef              compiler::cmpActualType(TypDef type)
{
    if  (varTypeIsIndirect(type->tdTypeKindGet()))
        type = cmpGetActualTP(type);

    return  type;
}

inline
var_types           compiler::cmpActualVtyp(TypDef type)
{
    var_types       vtp = type->tdTypeKindGet();

    if  (varTypeIsIndirect(type->tdTypeKindGet()))
        vtp = cmpGetActualTP(type)->tdTypeKindGet();

    return  vtp;
}

inline
var_types           compiler::cmpSymbolVtyp(SymDef sym)
{
    TypDef          typ = sym->sdType;
    var_types       vtp = typ->tdTypeKindGet();

    if  (varTypeIsIndirect(vtp))
        vtp = cmpActualType(typ)->tdTypeKindGet();

    return  vtp;
}

inline
var_types           compiler::cmpEnumBaseVtp(TypDef type)
{
    assert(type->tdTypeKind == TYP_ENUM);

    return type->tdEnum.tdeIntType->tdTypeKindGet();
}

inline
bool                compiler::cmpIsByRefType(TypDef type)
{
    assert(type);

    if  (type->tdTypeKind == TYP_REF)
    {
        if  (type->tdRef.tdrBase->tdTypeKind != SYM_CLASS)
            return  true;
    }

    if  (type->tdTypeKind == TYP_TYPEDEF)
        return  cmpIsByRefType(type->tdTypedef.tdtType);

    return  false;
}

inline
bool                compiler::cmpIsObjectVal(Tree expr)
{
    TypDef          type = expr->tnType;

    if  (expr->tnVtyp == TYP_TYPEDEF)
        type = type->tdTypedef.tdtType;

    if  (type->tdTypeKind == TYP_PTR ||
         type->tdTypeKind == TYP_REF)
    {
        return  (expr->tnType == cmpObjectRef());
    }

    return false;
}

inline
bool                compiler::cmpIsStringVal(Tree expr)
{
    TypDef          type = expr->tnType;

    if  (expr->tnVtyp == TYP_TYPEDEF)
        type = type->tdTypedef.tdtType;

    if  (type->tdTypeKind == TYP_REF)
        return  (expr->tnType == cmpStringRef());

    if  (type->tdTypeKind == TYP_PTR)
    {
        var_types       vtyp = cmpActualVtyp(expr->tnType->tdRef.tdrBase);

        return  (vtyp == TYP_CHAR || vtyp == TYP_WCHAR);
    }

    return false;
}

inline
bool                compiler::cmpDiffContext(TypDef cls1, TypDef cls2)
{
    assert(cls1 && cls1->tdTypeKind == TYP_CLASS);
    assert(cls2 && cls2->tdTypeKind == TYP_CLASS);

    if  (cls1->tdClass.tdcContext == cls2->tdClass.tdcContext)
        return  false;

    if  (cls1->tdClass.tdcContext == 2)
        return   true;
    if  (cls2->tdClass.tdcContext == 2)
        return   true;

    return  false;
}

inline
bool                compiler::cmpMakeRawString(Tree expr, TypDef type, bool chkOnly)
{
    if  (expr->tnOper == TN_CNS_STR || expr->tnOper == TN_QMARK)
        return  cmpMakeRawStrLit(expr, type, chkOnly);
    else
        return  false;
}

inline
void                compiler::cmpRecErrorPos(Tree expr)
{
    assert(expr);

    if (expr->tnLineNo)
        cmpErrorTree = expr;
}

/*****************************************************************************
 *
 *  Given a type, check whether it's un unmanaged array and if so decay its
 *  type to a pointer to the first element of the array.
 */

inline
Tree                compiler::cmpDecayCheck(Tree expr)
{
    TypDef          type = expr->tnType;

    if      (type->tdTypeKind == TYP_ARRAY)
    {
        if  (!type->tdIsManaged)
            expr = cmpDecayArray(expr);
    }
    else if (type->tdTypeKind == TYP_TYPEDEF)
    {
        expr->tnType = type->tdTypedef.tdtType;
        expr->tnVtyp = expr->tnType->tdTypeKindGet();
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Main public entry point to bind an expression tree.
 */

inline
Tree                compiler::cmpBindExpr(Tree expr)
{
    Tree            bound;
    unsigned        saveln;

    /* Save the current line# and set it to 0 for the call to the binder */

    saveln = cmpScanner->scanGetSourceLno(); cmpScanner->scanSetTokenPos(0);

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 3) { printf("Binding:\n"); cmpParser->parseDispTree(expr ); }
#endif

    bound = cmpBindExprRec(expr);

#ifdef DEBUG
    if  (cmpConfig.ccVerbose >= 3) { printf("Bound:  \n"); cmpParser->parseDispTree(bound); printf("\n"); }
#endif

    bound->tnLineNo = expr->tnLineNo;
//  bound->tnColumn = expr->tnColumn;

    /* Restore the current line# before returning */

    cmpScanner->scanSetTokenPos(saveln);

    return  bound;
}

/*****************************************************************************
 *
 *  Given a TYP_REF type, returns the class type it refers to, after making
 *  sure the class is defined.
 */

inline
TypDef              compiler::cmpGetRefBase(TypDef reftyp)
{
    TypDef          clsTyp;

    assert(reftyp->tdTypeKind == TYP_REF ||
           reftyp->tdTypeKind == TYP_PTR);
    clsTyp = cmpActualType(reftyp->tdRef.tdrBase);

    /* Make sure the class is defined */

    if  (clsTyp->tdTypeKind == TYP_CLASS)
        cmpDeclSym(clsTyp->tdClass.tdcSymbol);

    return  clsTyp;
}

/*****************************************************************************
 *
 *  Look for an overloaded operator / constructor in the given scope.
 */

inline
SymDef              symTab::stLookupOper(ovlOpFlavors oper, SymDef scope)
{
    assert(oper < OVOP_COUNT);
    assert(scope && scope->sdSymKind == SYM_CLASS);

    if  (scope->sdCompileState < CS_DECLARED)
        stComp->cmpDeclSym(scope);

    if  (scope->sdClass.sdcOvlOpers)
        return  scope->sdClass.sdcOvlOpers[oper];
    else
        return  NULL;
}

/*****************************************************************************
 *
 *  Same as stLookupOper() but doesn't force the class to be in declared state.
 */

inline
SymDef              symTab::stLookupOperND(ovlOpFlavors oper, SymDef scope)
{
    assert(oper < OVOP_COUNT);
    assert(scope && scope->sdSymKind == SYM_CLASS);

    if  (scope->sdClass.sdcOvlOpers)
        return  scope->sdClass.sdcOvlOpers[oper];
    else
        return  NULL;
}

/*****************************************************************************
 *
 *  Bring the given symbol to "declared" state. This function can be called
 *  pretty much at will (i.e. recursively), it takes care of saving and
 *  restoring compilation state.
 */

inline
bool                compiler::cmpDeclSym(SymDef sym)
{
    if  (sym->sdCompileState >= CS_DECLARED)
        return  false;

    /* Is this an import class/enum? */

    if  (sym->sdIsImport)
    {
        assert(sym->sdSymKind == SYM_CLASS);

        sym->sdClass.sdcMDimporter->MDimportClss(0, sym, 0, true);

        return (sym->sdCompileState < CS_DECLARED);
    }

    return  cmpDeclSymDoit(sym);
}

inline
bool                compiler::cmpDeclClsNoCns(SymDef sym)
{
    if  (sym->sdCompileState >= CS_DECLARED)
        return  false;

    if  (sym->sdIsImport)
        return  cmpDeclSym    (sym);
    else
        return  cmpDeclSymDoit(sym, true);
}

/*****************************************************************************
 *
 *  Make sure the given class has been declared to the specified level, and
 *  then look for a member with the specified name in it.
 */

inline
SymDef              symTab::stLookupAllCls(Ident            name,
                                           SymDef           scope,
                                           name_space       symNS,
                                           compileStates    state)
{
    assert(scope && scope->sdSymKind == SYM_CLASS);

    /* Make sure the class type is defined */

    if  ((unsigned)scope->sdCompileState < (unsigned)state)
    {
        assert(state == CS_DECLSOON || state == CS_DECLARED);

        stComp->cmpDeclSym(scope);
    }

    return  stFindInClass(name, scope, symNS);
}

/*****************************************************************************
 *
 *  Return true if the given expression is a string value - note that we only
 *  recognize values of the managed type String or string constants here.
 */

inline
bool                compiler::cmpIsStringExpr(Tree expr)
{
    if  (expr->tnType == cmpStringRef())
        return  true;

    if  (expr->tnOper == TN_CNS_STR && !(expr->tnFlags & TNF_BEEN_CAST))
        return  true;

    return  false;
}

/*****************************************************************************
 *
 *  Similar to cmpCoerceExpr(), but if the operand is a constant it tries
 *  to use the smallest possible type for the constant value.
 */

inline
Tree                compiler::cmpCastOfExpr(Tree expr, TypDef type, bool explicitCast)
{
    if  (type->tdTypeKind < expr->tnVtyp)
        expr = cmpShrinkExpr(expr);

    return  cmpCoerceExpr(expr, type, explicitCast);
}

/*****************************************************************************
 *
 *  Set the current error reporing position to the given compunit and line#.
 */

inline
void                compiler::cmpSetErrPos(DefSrc def, SymDef compUnit)
{
    cmpErrorComp = compUnit;
    cmpErrorTree = NULL;

    cmpScanner->scanSetTokenPos(compUnit, def->dsdSrcLno);
}

/*****************************************************************************
 *
 *  Bind a name reference, expand property use unless target of assignment.
 */

inline
Tree                compiler::cmpBindNameUse(Tree expr, bool isCall, bool classOK)
{
    unsigned        flags = expr->tnFlags;

    expr = cmpBindName(expr, isCall, classOK);

    /* Is this a property reference? */

    if  (expr->tnOper == TN_PROPERTY)
    {
        if  (!(flags & TNF_ASG_DEST))
            expr = cmpBindProperty(expr, NULL, NULL);
    }

    return  expr;
}

/*****************************************************************************
 *
 *  Check whether the given type is an intrinsic type and if so, return its
 *  corresponding value type. Otherwise return NULL.
 */

inline
TypDef              compiler::cmpCheck4valType(TypDef type)
{
    if  (type->tdTypeKind > TYP_lastIntrins)
        return  NULL;
    else
        return  cmpFindStdValType(type->tdTypeKindGet());
}

/*****************************************************************************
 *
 *  Look for a specific entry in the given "extra info" list.
 */

inline
SymXinfoLnk         compiler::cmpFindLinkInfo(SymXinfo infoList)
{
    if  (infoList)
    {
        infoList = cmpFindXtraInfo(infoList, XI_LINKAGE);
        if  (infoList)
            return  (SymXinfoLnk)infoList;
    }

    return  NULL;
}

inline
SymXinfoSec         compiler::cmpFindSecSpec(SymXinfo infoList)
{
    if  (infoList)
    {
        infoList = cmpFindXtraInfo(infoList, XI_SECURITY);
        if  (infoList)
            return  (SymXinfoSec)infoList;
    }

    return  NULL;
}

inline
SymXinfoCOM         compiler::cmpFindMarshal(SymXinfo infoList)
{
    if  (infoList)
    {
        infoList = cmpFindXtraInfo(infoList, XI_MARSHAL);
        if  (infoList)
            return  (SymXinfoCOM)infoList;
    }

    return  NULL;
}

inline
SymXinfoSym         compiler::cmpFindSymInfo(SymXinfo infoList, xinfoKinds kind)
{
    assert(kind == XI_UNION_TAG ||
           kind == XI_UNION_MEM);

    if  (infoList)
    {
        infoList = cmpFindXtraInfo(infoList, kind);
        if  (infoList)
            return  (SymXinfoSym)infoList;
    }

    return  NULL;
}

inline
SymXinfoAtc         compiler::cmpFindATCentry(SymXinfo infoList, atCommFlavors flavor)
{
    while   (infoList)
    {
        if  (infoList->xiKind == XI_ATCOMMENT)
        {
            SymXinfoAtc     entry = (SymXinfoAtc)infoList;

            if  (entry->xiAtcInfo->atcFlavor == flavor)
                return  entry;
        }

        infoList = infoList->xiNext;
    }

    return  NULL;
}

/*****************************************************************************
 *
 *  Convert between an alignment value and a more compact representation.
 */

#ifndef __SMC__
extern
BYTE                cmpAlignDecodes[6];
#endif

inline
size_t              compiler::cmpDecodeAlign(unsigned alignVal)
{
    assert(alignVal && alignVal < arraylen(cmpAlignDecodes));

    return  cmpAlignDecodes[alignVal];
}

#ifndef __SMC__
extern
BYTE                cmpAlignEncodes[17];
#endif

inline
unsigned            compiler::cmpEncodeAlign(size_t   alignSiz)
{
    assert(alignSiz == 0 ||
		   alignSiz ==  1 ||
           alignSiz ==  2 ||
           alignSiz ==  4 ||
           alignSiz ==  8 ||
           alignSiz == 16);

    return  cmpAlignEncodes[alignSiz];
}

/*****************************************************************************
 *
 *  Check access to the given symbol - delegates all the "real" work to
 *  a non-inline method.
 */

inline
bool                compiler::cmpCheckAccess(SymDef sym)
{
    if  (sym->sdAccessLevel == ACL_PUBLIC || sym->sdSymKind == SYM_NAMESPACE)
        return  true;
    else
        return  cmpCheckAccessNP(sym);
}

/*****************************************************************************
 *
 *  Bind the type of the given expression.
 */

inline
TypDef              compiler::cmpBindExprType(Tree expr)
{
    TypDef          type = expr->tnType;

    cmpBindType(type, false, false);

    expr->tnVtyp = type->tdTypeKindGet();

    return  type;
}

/*****************************************************************************
 *
 *  Return true if the given symbol/type denotes an anonymous union.
 */

inline
bool                symTab::stIsAnonUnion(SymDef clsSym)
{
    assert(clsSym);

    return  clsSym->sdSymKind == SYM_CLASS && clsSym->sdClass.sdcAnonUnion;
}

inline
bool                symTab::stIsAnonUnion(TypDef clsTyp)
{
    assert(clsTyp);

    return  clsTyp->tdTypeKind == TYP_CLASS && clsTyp->tdClass.tdcSymbol->sdClass.sdcAnonUnion;
}

/*****************************************************************************
 *
 *  Return the namespace that contains the given symbol.
 */

inline
SymDef              compiler::cmpSymbolNS(SymDef sym)
{
    assert(sym);

    while (sym->sdSymKind != SYM_NAMESPACE)
    {
        sym = sym->sdParent;

        assert(sym && (sym->sdSymKind == SYM_CLASS ||
                       sym->sdSymKind == SYM_NAMESPACE));
    }

    return  sym;
}

/*****************************************************************************
 *
 *  Add a member definition/declaration entry to the given class.
 */

inline
void                compiler::cmpRecordMemDef(SymDef clsSym, ExtList decl)
{
    assert(clsSym && clsSym->sdSymKind == SYM_CLASS);
    assert(decl && decl->dlExtended);

    if  (clsSym->sdClass.sdcMemDefList)
        clsSym->sdClass.sdcMemDefLast->dlNext = decl;
    else
        clsSym->sdClass.sdcMemDefList         = decl;

    clsSym->sdClass.sdcMemDefLast = decl; decl->dlNext = NULL;
}

/*****************************************************************************
 *
 *  Save/restore the current symbol table context information
 */

inline
void                compiler::cmpSaveSTctx(STctxSave & save)
{
    save.ctxsNS     = cmpCurNS;
    save.ctxsCls    = cmpCurCls;
    save.ctxsScp    = cmpCurScp;
    save.ctxsUses   = cmpCurUses;
    save.ctxsComp   = cmpCurComp;
    save.ctxsFncSym = cmpCurFncSym;
    save.ctxsFncTyp = cmpCurFncTyp;
}

inline
void                compiler::cmpRestSTctx(STctxSave & save)
{
    cmpCurNS     = save.ctxsNS;
    cmpCurCls    = save.ctxsCls;
    cmpCurScp    = save.ctxsScp;
    cmpCurUses   = save.ctxsUses;
    cmpCurComp   = save.ctxsComp;
    cmpCurFncSym = save.ctxsFncSym;
    cmpCurFncTyp = save.ctxsFncTyp;
}

/*****************************************************************************
 *
 *  Return the closest "generic" (undimensioned) array type that corresponds
 *  to the given managed array type.
 */

inline
TypDef              compiler::cmpGetBaseArray(TypDef type)
{
    assert(type);
    assert(type->tdIsManaged);
    assert(type->tdTypeKind == TYP_ARRAY);

    if  (type->tdIsUndimmed)
        return  type;

    if  (!type->tdArr.tdaBase)
    {
        type->tdArr.tdaBase = cmpGlobalST->stNewGenArrTp(type->tdArr.tdaDcnt,
                                                         type->tdArr.tdaElem,
                                                   (bool)type->tdIsGenArray);
    }

    return  type->tdArr.tdaBase;
}

/*****************************************************************************
 *
 *  Return true if the give type is a reference to "Object".
 */

inline
bool                symTab::stIsObjectRef(TypDef type)
{
    return  type->tdTypeKind == TYP_REF && type->tdIsObjRef;
}

/*****************************************************************************
 *
 *  Return the metadata name for the given operator.
 */

#ifndef __SMC__

#ifdef  DEBUG
extern
const  ovlOpFlavors MDnamesChk[OVOP_COUNT];
#endif
extern
const   char *      MDnamesStr[OVOP_COUNT];

#endif

inline
const   char *      MDovop2name(ovlOpFlavors ovop)
{
    assert(ovop < arraylen(MDnamesChk));
    assert(ovop < arraylen(MDnamesStr));

    assert(MDnamesChk[ovop] == ovop);

    return MDnamesStr[ovop];
}

extern
ovlOpFlavors        MDfindOvop (const char *name);

inline
ovlOpFlavors        MDname2ovop(const char *name)
{
    if  (name[0] == 'o' &&
         name[1] == 'p' && name[2] != 0)
    {
        return  MDfindOvop(name);
    }
    else
        return  OVOP_NONE;
}

/*****************************************************************************/
#endif//_INLINES_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\keywords.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef KEYWORD
#error  Must define 'KEYWORD' properly before including this file!
#endif

#ifndef KWDNOID
#define KWDNOID(str, nam, istp, prec1, op1, prec2, op2, mod) \
        KEYWORD(str, nam, istp, prec1, op1, prec2, op2, mod)
#endif

#ifndef KWDFAKE
#define KWDFAKE(str, nam, istp, prec1, op1, prec2, op2, mod) \
        KEYWORD(str, nam, istp, prec1, op1, prec2, op2, mod)
#endif

#ifndef KWD_OP1
#define KWD_OP1(str, nam, istp, prec1, op1, prec2, op2, mod) \
        KEYWORD(str, nam, istp, prec1, op1, prec2, op2, mod)
#endif

#ifndef KWD_MAX
#define KWD_MAX(str, nam, istp, prec1, op1, prec2, op2, mod) \
        KEYWORD(str, nam, istp, prec1, op1, prec2, op2, mod)
#endif

/*
        name
                   token
                                      1=typespec,2=begtype,4=overloaded operator
                                        binary operator precedence
                                            binary operator
                                                          unary operator precedence
                                                             unary operator
                                                                         modifier

 */
KEYWORD(NULL          ,tkNone        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

// NOTE: All the keywords must be listed first in the table.

KEYWORD("abstract"    ,tkABSTRACT    ,2, 0, TN_NONE     , 0, TN_NONE   , DB_ABSTRACT)
KEYWORD("appdomain"   ,tkAPPDOMAIN   ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("arraylen"    ,tkARRAYLEN    ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("assert"      ,tkASSERT      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__asynch"    ,tkASYNCH      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__attribute" ,tkATTRIBUTE   ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
///////("auto"        ,tkAUTO        ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("baseclass"   ,tkBASECLASS   ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("bool"        ,tkBOOL        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("break"       ,tkBREAK       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("byref"       ,tkBYREF       ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("byte"        ,tkBYTE        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__capability",tkCAPABILITY  ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("case"        ,tkCASE        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("catch"       ,tkCATCH       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("char"        ,tkCHAR        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("class"       ,tkCLASS       ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("@compare"    ,tkCOMPARE     ,4, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("const"       ,tkCONST       ,2, 0, TN_NONE     , 0, TN_NONE   , DB_CONST)
KEYWORD("contextful"  ,tkCONTEXTFUL  ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("continue"    ,tkCONTINUE    ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("defined"     ,tkDEFINED     ,0, 0, TN_NONE     , 1, TN_DEFINED, 0)
KEYWORD("default"     ,tkDEFAULT     ,0, 0, TN_NONE     , 0, TN_NONE   , DB_DEFAULT)
KEYWORD("delegate"    ,tkDELEGATE    ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("delete"      ,tkDELETE      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("do"          ,tkDO          ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("double"      ,tkDOUBLE      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("else"        ,tkELSE        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("enum"        ,tkENUM        ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("@equals"     ,tkEQUALS      ,4, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("except"      ,tkEXCEPT      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("exclusive"   ,tkEXCLUSIVE   ,2, 0, TN_NONE     , 0, TN_NONE   , DB_EXCLUDE)
///////("lock"        ,tkEXCLUSIVE   ,2, 0, TN_NONE     , 0, TN_NONE   , DB_EXCLUDE)
KEYWORD("explicit"    ,tkEXPLICIT    ,4, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("extern"      ,tkEXTERN      ,2, 0, TN_NONE     , 0, TN_NONE   , DB_EXTERN)
KEYWORD("false"       ,tkFALSE       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("finally"     ,tkFINALLY     ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("float"       ,tkFLOAT       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("for"         ,tkFOR         ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("goto"        ,tkGOTO        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("if"          ,tkIF          ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("implements"  ,tkIMPLEMENTS  ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("implicit"    ,tkIMPLICIT    ,4, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("in"          ,tkIN          ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("includes"    ,tkINCLUDES    ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("inline"      ,tkINLINE      ,2, 0, TN_NONE     , 0, TN_NONE   , DB_INLINE)
KEYWORD("inout"       ,tkINOUT       ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("int"         ,tkINT         ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__int8"      ,tkINT8        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__int16"     ,tkINT16       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__int32"     ,tkINT32       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__int64"     ,tkINT64       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("interface"   ,tkINTERFACE   ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("istype"      ,tkISTYPE      ,0,14, TN_ISTYPE   , 0, TN_NONE   , 0)
KEYWORD("long"        ,tkLONG        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("longint"     ,tkLONGINT     ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("managed"     ,tkMANAGED     ,2, 0, TN_NONE     , 0, TN_NONE   , DB_MANAGED)
KEYWORD("multicast"   ,tkMULTICAST   ,2, 0, TN_NONE     , 0, TN_NONE   , DB_MULTICAST)
KEYWORD("namespace"   ,tkNAMESPACE   ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("native"      ,tkNATIVE      ,2, 0, TN_NONE     , 0, TN_NONE   , DB_NATIVE)
KEYWORD("naturalint"  ,tkNATURALINT  ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("naturaluint" ,tkNATURALUINT ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("new"         ,tkNEW         ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("null"        ,tkNULL        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("out"         ,tkOUT         ,0, 0, TN_NONE     ,14, TN_ADDROF , 0)
KEYWORD("operator"    ,tkOPERATOR    ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("override"    ,tkOVERRIDE    ,2, 0, TN_NONE     , 0, TN_NONE   , DB_OVERRIDE)
KEYWORD("overload"    ,tkOVERLOAD    ,2, 0, TN_NONE     , 0, TN_NONE   , DB_OVERLOAD)
KEYWORD("__permission",tkPERMISSION  ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("private"     ,tkPRIVATE     ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("property"    ,tkPROPERTY    ,2, 0, TN_NONE     , 0, TN_NONE   , DB_PROPERTY)
KEYWORD("protected"   ,tkPROTECTED   ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("public"      ,tkPUBLIC      ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__refaddr"   ,tkREFADDR     ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("register"    ,tkREGISTER    ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("return"      ,tkRETURN      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("sealed"      ,tkSEALED      ,2, 0, TN_NONE     , 0, TN_NONE   , DB_SEALED)
KEYWORD("serializable",tkSERIALIZABLE,0, 0, TN_NONE     , 0, TN_NONE   , DB_SERLZABLE)
KEYWORD("short"       ,tkSHORT       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("signed"      ,tkSIGNED      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("sizeof"      ,tkSIZEOF      ,0, 0, TN_NONE     , 1, TN_SIZEOF , 0)
KEYWORD("static"      ,tkSTATIC      ,2, 0, TN_NONE     , 0, TN_NONE   , DB_STATIC)
KEYWORD("struct"      ,tkSTRUCT      ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("switch"      ,tkSWITCH      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("this"        ,tkTHIS        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("throw"       ,tkTHROW       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("transient"   ,tkTRANSIENT   ,0, 0, TN_NONE     , 0, TN_NONE   , DB_TRANSIENT)
KEYWORD("typeof"      ,tkTYPEOF      ,0, 0, TN_NONE     , 1, TN_TYPEOF , 0)
KEYWORD("typedef"     ,tkTYPEDEF     ,0, 0, TN_NONE     , 0, TN_NONE   , DB_TYPEDEF)
KEYWORD("true"        ,tkTRUE        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("try"         ,tkTRY         ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__uint8"     ,tkUINT8       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__uint16"    ,tkUINT16      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__uint32"    ,tkUINT32      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__uint64"    ,tkUINT64      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("uint"        ,tkUINT        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("ulongint"    ,tkULONGINT    ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("union"       ,tkUNION       ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("unmanaged"   ,tkUNMANAGED   ,2, 0, TN_NONE     , 0, TN_NONE   , DB_UNMANAGED)
KEYWORD("unsafe"      ,tkUNSAFE      ,2, 0, TN_NONE     , 0, TN_NONE   , DB_UNSAFE)
KEYWORD("unsigned"    ,tkUNSIGNED    ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("ushort"      ,tkUSHORT      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("using"       ,tkUSING       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("void"        ,tkVOID        ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("virtual"     ,tkVIRTUAL     ,0, 0, TN_NONE     , 0, TN_NONE   , DB_VIRTUAL)
KEYWORD("volatile"    ,tkVOLATILE    ,2, 0, TN_NONE     , 0, TN_NONE   , DB_VOLATILE)
KEYWORD("wchar"       ,tkWCHAR       ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("while"       ,tkWHILE       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__FILE__"    ,tkFILE        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KEYWORD("__LINE__"    ,tkLINE        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

#ifdef  SETS
KEYWORD("all"         ,tkALL         ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("asc"         ,tkASC         ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("connect"     ,tkCONNECT     ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
///////("count"       ,tkCOUNT       ,0, 0, TN_NONE     , 1, TN_COUNT  ,  0)
KEYWORD("cross"       ,tkCROSS       ,0, 0, TN_NONE     , 1, TN_CROSS  ,  0)
KEYWORD("des"         ,tkDES         ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("exists"      ,tkEXISTS      ,0, 0, TN_NONE     , 1, TN_EXISTS ,  0)
KEYWORD("filter"      ,tkFILTER      ,0, 0, TN_NONE     , 1, TN_FILTER ,  0)
KEYWORD("foreach"     ,tkFOREACH     ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("groupby"     ,tkGROUPBY     ,0, 0, TN_NONE     , 1, TN_GROUPBY,  0)
KEYWORD("project"     ,tkPROJECT     ,0, 0, TN_NONE     , 1, TN_PROJECT,  0)
KEYWORD("relate"      ,tkRELATE      ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("sort"        ,tkSORT        ,0, 0, TN_NONE     , 1, TN_SORT   ,  0)
KEYWORD("sortby"      ,tkSORTBY      ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("suchthat"    ,tkSUCHTHAT    ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
KEYWORD("unique"      ,tkUNIQUE      ,0, 0, TN_NONE     , 1, TN_UNIQUE ,  0)
KEYWORD("__xml"       ,tkXML         ,0, 0, TN_NONE     , 0, TN_NONE   ,  0)
#endif

//     Operator non-identifier keywords:

KWD_OP1(","           ,tkComma       ,0, 1, TN_COMMA    , 0, TN_NONE   , 0)

KWDNOID("="           ,tkAsg         ,4, 2, TN_ASG      , 0, TN_NONE   , 0)
KWDNOID("+="          ,tkAsgAdd      ,4, 2, TN_ASG_ADD  , 0, TN_NONE   , 0)
KWDNOID("-="          ,tkAsgSub      ,4, 2, TN_ASG_SUB  , 0, TN_NONE   , 0)
KWDNOID("*="          ,tkAsgMul      ,4, 2, TN_ASG_MUL  , 0, TN_NONE   , 0)
KWDNOID("/="          ,tkAsgDiv      ,4, 2, TN_ASG_DIV  , 0, TN_NONE   , 0)
KWDNOID("%="          ,tkAsgMod      ,4, 2, TN_ASG_MOD  , 0, TN_NONE   , 0)

KWDNOID("&="          ,tkAsgAnd      ,4, 2, TN_ASG_AND  , 0, TN_NONE   , 0)
KWDNOID("^="          ,tkAsgXor      ,4, 2, TN_ASG_XOR  , 0, TN_NONE   , 0)
KWDNOID("|="          ,tkAsgOr       ,4, 2, TN_ASG_OR   , 0, TN_NONE   , 0)

KWDNOID("<<="         ,tkAsgLsh      ,4, 2, TN_ASG_LSH  , 0, TN_NONE   , 0)
KWDNOID(">>="         ,tkAsgRsh      ,4, 2, TN_ASG_RSH  , 0, TN_NONE   , 0)
KWDNOID(">>>="        ,tkAsgRsz      ,4, 2, TN_ASG_RSZ  , 0, TN_NONE   , 0)

KWDNOID("%%="         ,tkAsgCnc      ,4, 2, TN_ASG_CNC  , 0, TN_NONE   , 0)

KWDNOID("?"           ,tkQMark       ,0, 3, TN_QMARK    , 0, TN_NONE   , 0)
KWDNOID(":"           ,tkColon       ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

KWDNOID("||"          ,tkLogOr       ,4, 4, TN_LOG_OR   , 0, TN_NONE   , 0)
KWDNOID("&&"          ,tkLogAnd      ,4, 5, TN_LOG_AND  , 0, TN_NONE   , 0)

KWDNOID("|"           ,tkOr          ,4, 6, TN_OR       , 0, TN_NONE   , 0)

KWDNOID("^"           ,tkXor         ,4, 7, TN_XOR      , 0, TN_NONE   , 0)
KWDNOID("&"           ,tkAnd         ,4, 7, TN_AND      ,14, TN_ADDROF , 0)

KWDNOID("%%"          ,tkConcat      ,4, 3, TN_CONCAT   , 0, TN_NONE   , 0)

KWDNOID("=="          ,tkEQ          ,4, 9, TN_EQ       , 0, TN_NONE   , 0)
KWDNOID("!="          ,tkNE          ,4, 9, TN_NE       , 0, TN_NONE   , 0)

KWDNOID("<"           ,tkLT          ,4,10, TN_LT       , 0, TN_NONE   , 0)
KWDNOID("<="          ,tkLE          ,4,10, TN_LE       , 0, TN_NONE   , 0)
KWDNOID(">="          ,tkGE          ,4,10, TN_GE       , 0, TN_NONE   , 0)
KWDNOID(">"           ,tkGT          ,4,10, TN_GT       , 0, TN_NONE   , 0)

KWDNOID("<<"          ,tkLsh         ,4,11, TN_LSH      , 0, TN_NONE   , 0)
KWDNOID(">>"          ,tkRsh         ,4,11, TN_RSH      , 0, TN_NONE   , 0)
KWDNOID(">>>"         ,tkRsz         ,4,11, TN_RSZ      , 0, TN_NONE   , 0)

KWDNOID("+"           ,tkAdd         ,4,12, TN_ADD      ,14, TN_NOP    , 0)
KWDNOID("-"           ,tkSub         ,4,12, TN_SUB      ,14, TN_NEG    , 0)

KWDNOID("*"           ,tkMul         ,4,13, TN_MUL      ,12, TN_IND    , 0)
KWDNOID("/"           ,tkDiv         ,4,13, TN_DIV      , 0, TN_NONE   , 0)
KWDNOID("%"           ,tkPct         ,4,13, TN_MOD      , 0, TN_NONE   , 0)

KWDNOID("~"           ,tkTilde       ,4, 0, TN_NONE     ,14, TN_NOT    , 0)
KWDNOID("!"           ,tkBang        ,4, 0, TN_NONE     ,14, TN_LOG_NOT, 0)
KWDNOID("++"          ,tkInc         ,4, 0, TN_NONE     ,14, TN_INC_PRE, 0)
KWDNOID("--"          ,tkDec         ,4, 0, TN_NONE     ,14, TN_DEC_PRE, 0)

KWDNOID("("           ,tkLParen      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("["           ,tkLBrack      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("."           ,tkDot         ,4, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("->"          ,tkArrow       ,4,15, TN_ARROW    , 0, TN_NONE   , 0)

KWDNOID(";"           ,tkSColon      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID(","           ,tkRParen      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("]"           ,tkRBrack      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("{"           ,tkLCurly      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("}"           ,tkRCurly      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("::"          ,tkColon2      ,3, 0, TN_NONE     , 0, TN_NONE   , 0)
#ifdef  SETS
KWDNOID(".."          ,tkDot2        ,4,15, TN_DOT2     , 0, TN_NONE   , 0)
#else
KWDNOID(".."          ,tkDot2        ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
#endif
KWDNOID("..."         ,tkEllipsis    ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

#ifdef  SETS
KWDNOID("[["          ,tkLBrack2     ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDNOID("]]"          ,tkRBrack2     ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
#endif

// The keywords end here
KWD_MAX("id"          ,tkID          ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("qualid"      ,tkQUALID      ,2, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("hackid"      ,tkHACKID      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

// Literals and other token-only entries

KWDFAKE("EOL"         ,tkEOL         ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("EOF"         ,tkEOF         ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

KWDFAKE("@comment"    ,tkAtComment   ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

KWDFAKE("int con"     ,tkIntCon      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("lng con"     ,tkLngCon      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("flt con"     ,tkFltCon      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("dbl con"     ,tkDblCon      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)
KWDFAKE("str con"     ,tkStrCon      ,0, 0, TN_NONE     , 0, TN_NONE   , 0)

#undef  KEYWORD
#undef  KWDNOID
#undef  KWDFAKE
#undef  KWD_MAX
#undef  KWD_OP1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\macros.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 *
 *  The following file is pre-preprocessed and fed into the SafeC+ compiler,
 *  since it doesn't support macros with arguments and all that other stuff.
 *  It is included directly as an ordinary source file when the compiler is
 *  built as a C++ program.
 */

#include "smcPCH.h"
#pragma hdrstop

#ifdef  __PREPROCESS__
#include "macros.h"
#else
#include "genIL.h"
#endif

/*****************************************************************************/
/*****************************************************************************/

#include "tokens.h"
#include "treeops.h"

/*****************************************************************************/

#ifdef  __UMG__
#include "symsizes.h"
#include "typsizes.h"
#endif

/*****************************************************************************/

#include "config.h"

optionDesc      optionInfo[] =
{
    #define CMDOPT(name, type, phase, defval)                           \
    {                                                                   \
        offsetof(compConfig, cc##name),                                 \
        sizeof(type),                                                   \
        phase,                                                          \
        (NatInt)defval                                                  \
    },

    #include "options.h"
};

/*****************************************************************************/

#ifdef  __SMC__

#undef  SMC_ERR
#undef  SMC_WR1
#undef  SMC_WRN
#define SMC_ERR(name, lvl, str)  name,
#define SMC_WR1(name, lvl, str)  name, WRNfirstWarn = name,
#define SMC_WRN(name, lvl, str)  name,
enum    errors
{
    #include "errors.h"

    WRNafterWarn
};
#undef  SMC_ERR
#undef  SMC_WR1
#undef  SMC_WRN

const
unsigned    WRNcountWarn = WRNafterWarn - WRNfirstWarn + 1;

#endif

/*****************************************************************************/

#undef  SMC_ERR
#define SMC_ERR(name, lvl, str)  str,
#define SMC_WR1(name, lvl, str)  str,
#define SMC_WRN(name, lvl, str)  str,
const   char *          errorTable[] =
{
    #include "errors.h"
};
#undef  SMC_ERR
#undef  SMC_WR1
#undef  SMC_WRN

/*****************************************************************************/

#undef  SMC_ERR
#define SMC_ERR(name, lvl, str)
#define SMC_WR1(name, lvl, str)  lvl,
#define SMC_WRN(name, lvl, str)  lvl,
BYTE                    warnDefault[] =
{
    #include "errors.h"
};
#undef  SMC_ERR
#undef  SMC_WR1
#undef  SMC_WRN

/*****************************************************************************/

#include "attrs.h"

const char    *     attrNames[] =
{
    #define ATTRDEF(ename, sname) sname,
    #include "attrlist.h"
};

/*****************************************************************************/

static
unsigned char       optokens[] =
{
    #define TREEOP(en,tk,sn,IL,pr,ok) tk,
    #include "toplist.h"
};

tokens              treeOp2token(treeOps oper)
{
    assert(oper < arraylen(optokens));
    assert(optokens[oper] != tkNone);

    return (tokens)optokens[oper];
}

/*****************************************************************************/

#ifdef  DEBUG

static
const   char *      treeNodeNames[] =
{
    #define TREEOP(en,tk,sn,IL,pr,ok) sn,
    #include "toplist.h"
};

const   char    *   treeNodeName(treeOps op)
{
    assert(op < sizeof(treeNodeNames)/sizeof(treeNodeNames[0]));

    return  treeNodeNames[op];
}

#endif

/*****************************************************************************/

const
unsigned char       TreeNode::tnOperKindTable[] =
{
    #define TREEOP(en,tk,sn,IL,pr,ok) ok,
    #include "toplist.h"
};

/*****************************************************************************/

const
kwdDsc              hashTab::hashKwdDescs[tkKwdCount] =
{
    #define KEYWORD(str, nam, info, prec2, op2, prec1, op1, mod) { op1,op2,prec1,prec2,nam,mod,info },
    #define KWDNOID(str, nam, info, prec2, op2, prec1, op1, mod) { op1,op2,prec1,prec2,nam,mod,info },
    #define KWDFAKE(str, nam, info, prec2, op2, prec1, op1, mod)
    #include "keywords.h"
};

const
char *              hashTab::hashKwdNtab[tkKwdCount] =
{
    #define KEYWORD(str, nam, info, prec2, op2, prec1, op1, mod) str,
    #define KWDNOID(str, nam, info, prec2, op2, prec1, op1, mod) str,
    #define KWDFAKE(str, nam, info, prec2, op2, prec1, op1, mod)
    #include "keywords.h"
};

/*****************************************************************************/

#ifdef  DEBUG

const char *        tokenNames[] =
{
    #define KEYWORD(str, nam, info, prec2, op2, prec1, op1, mod) str,
    #include "keywords.h"
};

#endif

/*****************************************************************************/

#ifdef  __SMC__

enum    var_types
{
    #define DEF_TP(tn,sz,al,nm,tf) TYP_##tn,
    #include "typelist.h"
    #undef  DEF_TP

    TYP_COUNT,

    TYP_lastIntrins = TYP_LONGDBL
};

#endif

/*****************************************************************************/

BYTE                symTab::stIntrTypeSizes[] =
{
    #define DEF_TP(tn,sz,al,nm,tf) sz,
    #include "typelist.h"
    #undef  DEF_TP
};

BYTE                symTab::stIntrTypeAligns[] =
{
    #define DEF_TP(tn,sz,al,nm,tf) al,
    #include "typelist.h"
    #undef  DEF_TP
};

BYTE                varTypeClassification[] =
{
    #define DEF_TP(tn,sz,al,nm,tf) tf,
    #include "typelist.h"
    #undef  DEF_TP
};

normString          symTab::stIntrinsicTypeName(var_types vt)
{
    static
    const   char *      typeNames[] =
    {
        #define DEF_TP(tn,sz,al,nm,tf) nm,
        #include "typelist.h"
        #undef  DEF_TP
    };

    assert(vt < sizeof(typeNames)/sizeof(typeNames[0]));

    return  typeNames[vt];
}

/*****************************************************************************/

#ifdef  __SMC__

enum    ILopcodes
{
    #define OPDEF(name, str, decs, incs, args, optp, stdlen, stdop1, stdop2, flow) name,
    #include "opcode.def"
    #undef  OPDEF

    CEE_count,

    CEE_UNREACHED,                  // fake value: end of block is unreached
};

#endif

/*****************************************************************************/

ILencoding          ILopcodeCodes[] =
{
    #define OPDEF(name, str, decs, incs, args, optp, stdlen, stdop1, stdop2, flow) { stdop1, stdop2, stdlen },
    #include "opcode.def"
    #undef  OPDEF
};

/*****************************************************************************/

#define Push0    0
#define Push1    1
#define PushI    1
#define PushI8   1
#define PushR4   1
#define PushR8   1
#define PushRef  1
#define VarPush  0

#define Pop0     0
#define Pop1    -1
#define PopI    -1
#define PopI8   -1
#define PopR4   -1
#define PopR8   -1
#define PopRef  -1
#define VarPop   0

signed  char        ILopcodeStack[] =
{
    #define OPDEF(name, str, decs, incs, args, optp, stdlen, stdop1, stdop2, flow) ((incs)+(decs)),
    #include "opcode.def"
    #undef  OPDEF
};

/*****************************************************************************/

#ifdef  DEBUG

const char *        opcodeNames[] =
{
    #define OPDEF(nam,str,op,decs,incs,ops,otp, len, op1, op2) str,
    #include "opcode.def"
    #undef  OPDEF
};

const char *        opcodeName(unsigned op)
{
    assert(op < sizeof(opcodeNames)/sizeof(*opcodeNames));

    return  opcodeNames[op];
}

#endif

/*****************************************************************************/

const   char *      MDnamesStr[] =
{
    #define MD_NAME(ovop, name) name,
    #include "MDnames.h"
    #undef  MD_NAME
};

#ifdef  DEBUG

const  ovlOpFlavors MDnamesChk[] =
{
    #define MD_NAME(ovop, name) OVOP_##ovop,
    #include "MDnames.h"
    #undef  MD_NAME
};

#endif

#include "MDstrns.h"

ovlOpFlavors        MDfindOvop(const char *name)
{
    unsigned        i;

    // This is pretty lame -- is there a better way?

    for (i = 0; i < arraylen(MDnamesStr); i++)
    {
        if  (MDnamesStr[i] && !strcmp(name, MDnamesStr[i]))
            return  (ovlOpFlavors)i;
    }

    return  OVOP_NONE;
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\macros.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _MACROS_H_
#define _MACROS_H_
/*****************************************************************************/

#ifndef offsetof
#define offsetof(s,m)   ((size_t)&(((s*)0)->m))
#endif

#define castto(var,typ) (*(typ *)&var)

#define sizeto(typ,mem) (offsetof(typ, mem) + sizeof(((typ*)0)->mem))

#define size2mem(s,m)   (offsetof(s,m) + sizeof(((s *)0)->m))

#define arraylen(a)     (sizeof(a)/sizeof(*(a)))

/*****************************************************************************/
#endif//_MACROS_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\makefile.inc ===
OBJECTS = $(OBJECTS) $O\versionNum.obj 

$O\versionNum.obj: $O\versionNum.cpp

$O\versionNum.cpp: FORCE
	perl makeVersion.pl > $O\versionNum.cpp

macros.i.$(DDKBUILDENV): macros.cpp FORCE
	$(CXX_COMPILER_NAME) -P $(INCPATH0) $(COR_C_FLAGS) /D__SMC__ /D__PREPROCESS__ /D__UMG__ macros.cpp
	-del /q macros.i.$(DDKBUILDENV)
	move macros.i macros.i.$(DDKBUILDENV)

FORCE:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\mdstrns.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _MDSTRNS_H_
#define _MDSTRNS_H_
/*****************************************************************************/

#define MD_NAME(ovop, name) const normString OVOP_STR_##ovop = name;
#include "MDnames.h"
#undef  MD_NAME

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\opcodes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _OPCODES_H_
#define _OPCODES_H_
/*****************************************************************************/

enum    ILopcodes
{
    #define OPDEF(name, str, decs, incs, args, optp, stdlen, stdop1, stdop2, flow) name,
    #include "opcode.def"
    #undef  OPDEF

    CEE_count,

    CEE_UNREACHED,                  // fake value: end of block is unreached
};

/*****************************************************************************/
#endif//_OPCODES_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\outfile.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _OUTFILE_H_
#define _OUTFILE_H_
/*****************************************************************************
 *
 *  A bufferred file write class.
 */

class   outFile;
typedef outFile *   OutFile;

class   outFile
{
private:

    Compiler        outFileComp;

    char            outFileName[_MAX_PATH];
    int             outFileHandle;

    bool            outFileBuffAlloc;   // did we allocate output buffer?

    size_t          outFileBuffSize;    // size    of outout buffer
    char    *       outFileBuffAddr;    // address of output buffer

    char    *       outFileBuffNext;    // address of next free byte
    char    *       outFileBuffLast;    // address of last free byte

    __uint32        outFileBuffOffs;    // current buffer offs within file

    void            outFileFlushBuff();

public:

    void            outFileOpen(Compiler        comp,
                                const char *    name,
                                bool            tempFile = false,
                                size_t          buffSize = 0,
                                char *          buffAddr = NULL);

#ifdef  DLL
    void            outFileOpen(Compiler        comp,
                                void        *   dest);
#endif

    void            outFileClose();

    void            outFileDone(bool delFlag = false);

    const char *    outFilePath()
    {
        return  outFileName;
    }

    void            outFileWriteData(const void *   data,
                                     size_t         size);

#ifdef  OLD_IL
    void            outFilePatchByte(unsigned long  offset,
                                     int            newVal);
    void            outFilePatchData(unsigned long  offset,
                                     const void *   data,
                                     size_t         size);
#endif

    void            outFileWritePad (size_t         size);

    void            outFileWriteByte(int x)
    {
        assert(outFileBuffNext >= outFileBuffAddr);
        assert(outFileBuffNext <  outFileBuffLast);

        *outFileBuffNext++ = x;

        if  (outFileBuffNext == outFileBuffLast)
            outFileFlushBuff();

        assert(outFileBuffNext >= outFileBuffAddr);
        assert(outFileBuffNext <  outFileBuffLast);
    }

    __uint32        outFileOffset()
    {
        return  outFileBuffOffs + (outFileBuffNext - outFileBuffAddr);
    }
};

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\tools\smc\compiler\parser.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/

#include "smcPCH.h"
#pragma hdrstop

/*****************************************************************************/

#include "hash.h"
#include "error.h"
#include "scan.h"
#include "parser.h"

/*****************************************************************************/

#ifdef  DEBUG
static  unsigned    totalLinesCompiled;
#endif

/*****************************************************************************/

int                 parser::parserInit(Compiler comp)
{
    /* Remember which compiler we belong to */

    parseComp = comp;

    /* Initialize our private allocator */

    if  (parseAllocPriv.nraInit(comp))
        return  1;

    /* The following is hokey, fix when symbol table design is more stable */

//  parseAllocTemp   = &comp->cmpAllocTemp;
    parseAllocPerm   = &comp->cmpAllocPerm;

    /* We're not parsing a text section right now */

    parseReadingText = false;

#ifdef  DEBUG
    parseReadingTcnt = 0;
#endif

    /* We've had no pragma pushes yet */

    parseAlignStack  = 0;
    parseAlignStLvl  = 0;

    /* All went OK, we're done initializing */

    return 0;
}

void                parser::parserDone()
{
    assert(parseReadingTcnt == 0);

#ifdef  DEBUG
//  if  (totalLinesCompiled) printf("A total of %u lines compiled.\n", totalLinesCompiled);
#endif

}

/*****************************************************************************
 *
 *  The following routines check for a particular token and error if not found.
 */

void                parser::chkCurTok(int tok, int err)
{
    if  (parseScan->scanTok.tok != tok)
        parseComp->cmpError(err);
    else
        parseScan->scan();
}

void                parser::chkNxtTok(int tok, int err)
{
    if  (parseScan->scan() != tok)
        parseComp->cmpError(err);
    else
        parseScan->scan();
}

/*****************************************************************************
 *
 *  Saves and restores current "using" state.
 */

void                parser::parseUsingScpBeg(  OUT usingState REF state, SymDef owner)
{
    /* Save the current "using" state */

    state.usUseList = parseCurUseList;
    state.usUseDesc = parseCurUseDesc;

    /* Create a new "desc" entry for local refs to use */

#if MGDDATA
    parseCurUseDesc = new UseList;
#else
    parseCurUseDesc =    (UseList)parseAllocPerm->nraAlloc(sizeof(*parseCurUseDesc));
#endif

    parseCurUseList = NULL;

    parseCurUseDesc->ul.ulSym = owner;
    parseCurUseDesc->ulAnchor = true;
    parseCurUseDesc->ulBound  = false;
    parseCurUseDesc->ulNext   = NULL;
}

void                parser::parseUsingScpEnd(IN usingState REF state)
{
    UseList         uses;

    assert(parseCurUseDesc);
    assert(parseCurUseDesc->ulAnchor);

    /* Connect the two lists */

    if  (parseCurUseList)
    {
        parseCurUseDesc->ulNext = uses = parseCurUseList;

        while (uses->ulNext != NULL)
            uses = uses->ulNext;

        uses           ->ulNext = state.usUseDesc;
    }
    else
        parseCurUseDesc->ulNext = state.usUseDesc;

    /* Now restore the saved state */

    parseCurUseList = state.usUseList;
    parseCurUseDesc = state.usUseDesc;
}

/*****************************************************************************
 *
 *  Initialize the "using" logic.
 */

void                parser::parseUsingInit()
{
    UseList         uses;

    parseCurUseList = NULL;
    parseCurUseDesc = NULL;

    assert(parseComp->cmpNmSpcSystem);

    parseUsingScpBeg(parseInitialUse, parseComp->cmpGlobalNS);

#if MGDDATA
    uses = new UseList;
#else
    uses =    (UseList)parseAllocPerm->nraAlloc(sizeof(*uses));
#endif

    uses->ulAll    = true;
    uses->ulAnchor = false;
    uses->ulBound  = true;
    uses->ul.ulSym = parseComp->cmpNmSpcSystem;
    uses->ulNext   = parseCurUseList;
                     parseCurUseList = uses;
}

/*****************************************************************************
 *
 *  Finalize the "using" logic.
 */

void                parser::parseUsingDone()
{
    if  (parseCurUseDesc)
        parseUsingScpEnd(parseInitialUse);
}

/*****************************************************************************
 *
 *  The main entry point into the parser to process all top-level declarations
 *  in the given source text.
 */

SymDef              parser::parsePrepSrc(stringBuff         filename,
                                         QueuedFile         fileBuff,
                                         const  char      * srcText,
                                         SymTab             symtab)
{
    nraMarkDsc      allocMark;

    SymDef          compUnit = NULL;
    Compiler        ourComp  = parseComp;

    parseScan = ourComp->cmpScanner;

#ifdef  __SMC__
//  printf("Prepare '%s'\n", filename);
#endif

    /*
        Make sure we capture any errors, so that we can release any
        allocated memory and unref any import entries we might ref.
    */

    parseAllocPriv.nraMark(&allocMark);

    /* Set a trap for any errors */

    setErrorTrap(ourComp);
    begErrorTrap
    {
        usingState      useState;
        accessLevels    defAccess;

        Scanner         ourScanner = parseScan;

        /* Remember which hash/symbol table we'll be using */

        parseStab = symtab;
        parseHash = symtab->stHash;

        /* Make sure the error logic knows the file we're parsing */

        ourComp->cmpErrorSrcf  = filename;

        /* Create a comp-unit symbol */

        parseCurCmp =
        compUnit    = symtab->stDeclareSym(parseHash->hashString(filename),
                                           SYM_COMPUNIT,
                                           NS_HIDE,
                                           ourComp->cmpGlobalNS);

        /* We don't have any local scopes */

        parseCurScope = NULL;

        /* Save the current "using" state */

        parseUsingScpBeg(useState, ourComp->cmpGlobalNS);

        /* Declaring types is normally OK */

        parseNoTypeDecl = false;

        /* Save the source file name */

        compUnit->sdComp.sdcSrcFile = compUnit->sdSpelling();

        /* Reset the compile-phase value */

        ourComp->cmpConfig.ccCurPhase = CPH_START;

        /* Get hold of the scanner we're supposed to use */

        ourScanner = parseScan;

        /* Tell the scanner which parser to refer to */

        ourScanner->scanSetp(this);

        /* Get the scanner started on our source */

        ourScanner->scanStart(compUnit,
                              filename,
                              fileBuff,
                              srcText,
                              symtab->stHash,
                              symtab->stAllocPerm);
        ourScanner->scan();

        /* We've processed initial whitespace, set compile-phase value */

        ourComp->cmpConfig.ccCurPhase = CPH_PARSING;

        /* Find all the namespace and class declarations */

        for (;;)
        {
//          unsigned        filepos = ourScanner->scanGetFilePos();

            genericBuff     defFpos;
            unsigned        defLine;

            bool            saveStyle;

            /* Get hold of the default style/alignment we're supposed to use */

            parseOldStyle  = ourComp->cmpConfig.ccOldStyle;
            parseAlignment = ourComp->cmpConfig.ccAlignVal;

            /* Figure out the default access level */

            defAccess      = parseOldStyle ? ACL_PUBLIC
                                           : ACL_DEFAULT;

            /* Record the source position of the next declaration */

            defFpos = ourScanner->scanGetTokenPos(&defLine);

            /* See what kind of a declaration we've got */

            switch (ourScanner->scanTok.tok)
            {
                declMods        mods;
                declMods        clrm;

            case tkCONST:
            case tkVOLATILE:

            case tkPUBLIC:
            case tkPRIVATE:
            case tkPROTECTED:

            case tkSEALED:
            case tkABSTRACT:

            case tkMANAGED:
            case tkUNMANAGED:

            case tkMULTICAST:

            case tkTRANSIENT:
            case tkSERIALIZABLE:

                parseDeclMods(defAccess, &mods);

            DONE_MODS:

                switch (ourScanner->scanTok.tok)
                {
                case tkENUM:
                case tkCLASS:
                case tkUNION:
                case tkSTRUCT:
                case tkINTERFACE:
                case tkDELEGATE:
                case tkNAMESPACE:

                    parsePrepSym(ourComp->cmpGlobalNS,
                                 mods,
                                 ourScanner->scanTok.tok,
                                 defFpos,
                                 defLine);
                    break;

                default:

                    /* This is presumably a generic global declaration */

                    if  (ourComp->cmpConfig.ccPedantic)
                        ourComp->cmpError(ERRnoDecl);

                    saveStyle = parseOldStyle; parseOldStyle = true;

                    parseMeasureSymDef(parseComp->cmpGlobalNS, mods, defFpos,
                                                                     defLine);

                    parseOldStyle = saveStyle;
                    break;
                }
                break;

                /* The following swallows any leading attributes */

            case tkLBrack:
            case tkAtComment:
            case tkCAPABILITY:
            case tkPERMISSION:
            case tkATTRIBUTE:

                for (;;)
                {
                    switch (ourScanner->scanTok.tok)
                    {
                        AtComment       atcList;

                    case tkLBrack:
                        parseBrackAttr(false, ATTR_MASK_SYS_IMPORT|ATTR_MASK_SYS_STRUCT|ATTR_MASK_GUID);
                        continue;

                    case tkAtComment:

                        for (atcList = ourScanner->scanTok.atComm.tokAtcList;
                             atcList;
                             atcList = atcList->atcNext)
                        {
                            switch (atcList->atcFlavor)
                            {
                            case AC_COM_INTF:
                            case AC_COM_CLASS:
                            case AC_COM_REGISTER:
                                break;

                            case AC_DLL_STRUCT:
                            case AC_DLL_IMPORT:
                                break;

                            case AC_DEPRECATED:
                                break;

                            default:
                                parseComp->cmpError(ERRbadAtCmPlc);
                                break;
                            }
                        }
                        ourScanner->scan();
                        break;

                    case tkCAPABILITY:
                        parseCapability();
                        break;

                    case tkPERMISSION:
                        parsePermission();
                        break;

                    case tkATTRIBUTE:
                        unsigned    tossMask;
                        genericBuff tossAddr;
                        size_t      tossSize;
                        parseAttribute(0, tossMask, tossAddr, tossSize);
                        break;

                    default:
                        parseDeclMods(defAccess, &mods); mods.dmMod |= DM_XMODS;
                        goto DONE_MODS;
                    }
                }

            case tkENUM:
            case tkCLASS:
            case tkUNION:
            case tkSTRUCT:
            case tkINTERFACE:
            case tkDELEGATE:
            case tkNAMESPACE:

                initDeclMods(&clrm, defAccess);

                parsePrepSym(ourComp->cmpGlobalNS,
                             clrm,
                             ourScanner->scanTok.tok,
                             defFpos,
                             defLine);
                break;

            case tkSColon:
                ourScanner->scan();
                break;

            case tkEOF:
                goto DONE_SRCF;

            case tkUSING:
                parseUsingDecl();


                break;

            case tkEXTERN:

                if  (ourScanner->scanLookAhead() == tkStrCon)
                {
                    UNIMPL("process C++ style linkage thang");
                    parseOldStyle = true;
                }

                // Fall through ....

            default:

                /* Don't allow global declarations when pedantic */

//              if  (ourComp->cmpConfig.ccPedantic)
//                  ourComp->cmpWarn(WRNglobDecl);

                /* Simply assume that this is a global declaration */

                clrm.dmAcc = defAccess;
                clrm.dmMod = DM_CLEARED;

                saveStyle = parseOldStyle; parseOldStyle = true;

                parseMeasureSymDef(parseComp->cmpGlobalNS,
                                   clrm,
                                   defFpos,
                                   defLine);

                parseOldStyle = saveStyle;
                break;
            }
        }

    DONE_SRCF:

#ifdef DEBUG
        unsigned    lineNo;
        ourScanner->scanGetTokenPos(&lineNo);
        totalLinesCompiled += (lineNo - 1);
#endif

        parseUsingScpEnd(useState);

        ourScanner->scanClose();

        /* End of the error trap's "normal" block */

        endErrorTrap(ourComp);
    }
    chkErrorTrap(fltErrorTrap(ourComp, _exception_code(), NULL)) // _exception_info()))
    {
        /* Begin the error trap's cleanup block */

        hndErrorTrap(ourComp);

        /* Tell the caller that things are hopeless */

        compUnit = NULL;
    }

    /* Release any memory blocks we may have acquired */

    parseAllocPriv.nraRlsm(&allocMark);

    /* We're no longer parsing a source file */

    ourComp->cmpErrorSrcf = NULL;

    return  compUnit;
}

/*****************************************************************************
 *
 *  Record source text information about a namespace/class/enum/etc symbol.
 */

SymDef              parser::parsePrepSym(SymDef     parent,
                                         declMods   mods,
                                         tokens     defTok, scanPosTP dclFpos,
                                                            unsigned  dclLine)
{
    symbolKinds     defKind;
    symbolKinds     symKind;
    genericBuff     defFpos;
    bool            prefix;
    SymDef          newSym = NULL;

    str_flavors     flavor;
    bool            valueTp;
    bool            hasBase;
    bool            managOK;

    unsigned        ctxFlag;

    bool            mgdSave;

    bool            asynch;

    SymDef          owner      = parent;

    Compiler        ourComp    = parseComp;
    SymTab          ourSymTab  = parseStab;
    Scanner         ourScanner = parseScan;

    /* Figure out the management mode (save it first so that it can be restored) */

    mgdSave = ourComp->cmpManagedMode;

    if  (mods.dmMod & (DM_MANAGED|DM_UNMANAGED))
    {
        ourComp->cmpManagedMode = ((mods.dmMod & DM_MANAGED) != 0);
    }
    else
    {
        /* Is this a declaration at a file/namespace scope level? */

        if  (parent == ourComp->cmpGlobalNS || parent->sdSymKind == SYM_NAMESPACE)
        {
            ourComp->cmpManagedMode = !ourComp->cmpConfig.ccOldStyle;
        }
        else
            ourComp->cmpManagedMode = parent->sdIsManaged;
    }

    /* Make sure the caller didn't mess up */

    assert(parent);
    assert(parent->sdSymKind == SYM_NAMESPACE || parent->sdSymKind == SYM_CLASS);

    defTok = ourScanner->scanTok.tok;

    /* Are we processing a typedef? */

    if  (defTok == tkTYPEDEF || (mods.dmMod & DM_TYPEDEF))
    {
        TypDef          type;
        Ident           name;

        unsigned        defLine;

        DefList         symDef;

        /* Swallow the "typedef" token */

        if  (defTok == tkTYPEDEF)
            ourScanner->scan();

        switch (ourScanner->scanTok.tok)
        {
            SymDef          tagSym;

        case tkSTRUCT:
        case tkUNION:
        case tkENUM:

            /* Looks like we have "typedef struct [tag] { ... } name;" */

            defFpos = ourScanner->scanGetTokenPos(&defLine);

            /* Prevent recursive death */

            mods.dmMod &= ~DM_TYPEDEF;

            /* Process the underlying type definition */

            tagSym = parsePrepSym(parent,
                                  mods,
                                  ourScanner->scanTok.tok,
                                  defFpos,
                                  defLine);

            if  (ourScanner->scanTok.tok != tkID)
            {
                ourComp->cmpError(ERRnoIdent);
            }
            else
            {
                Ident           name = ourScanner->scanTok.id.tokIdent;

                /* For now we only allow the same name for both tag and typedef */

                if  (tagSym && tagSym->sdName != name)
                    ourComp->cmpGenError(ERRtypedefNm, name->idSpelling(), tagSym->sdSpelling());

                if  (ourScanner->scan() != tkSColon)
                    ourComp->cmpError(ERRnoSemic);
            }

            goto EXIT;
        }

        defTok  = tkTYPEDEF;
        symKind = SYM_TYPEDEF;

        /* Jump to this label for delegates as well */

    TDF_DLG:

        /* Parse the type specification */

        type = parseTypeSpec(&mods, false);

        /* Parse the declarator */

        name = parseDeclarator(&mods, type, DN_REQUIRED, NULL, NULL, false);
        if  (!name)
            goto EXIT;

        /* Look for an existing symbol with a matching name */

        if  (parent->sdSymKind == SYM_CLASS)
            newSym = ourSymTab->stLookupScpSym(name,          parent);
        else
            newSym = ourSymTab->stLookupNspSym(name, NS_NORM, parent);

        if  (newSym)
        {
            /* Symbol already exists, is it an import? */

            if  (newSym->sdIsImport == false    ||
                 newSym->sdSymKind != SYM_CLASS ||
                 newSym->sdClass.sdcFlavor != STF_DELEGATE)
            {
                parseComp->cmpError(ERRredefName, newSym);
                goto EXIT;
            }

            newSym->sdIsImport            = false;
            newSym->sdClass.sdcMDtypedef  = 0;
            newSym->sdClass.sdcMemDefList = NULL;
            newSym->sdClass.sdcMemDefLast = NULL;
        }
        else
        {
            /* Symbol not known yet, so declare it */

            newSym = ourSymTab->stDeclareSym(name, symKind, NS_NORM, parent);

            if  (symKind == SYM_CLASS)
            {
                /* This is a delegate, mark it as such */

                newSym->sdIsManaged       = true;
                newSym->sdClass.sdcFlavor = STF_DELEGATE;

                /* Mark the delegate as "multicast" if appropriate */

                if  (mods.dmMod & DM_MULTICAST)
                    newSym->sdClass.sdcMultiCast = true;

                /* Create the class type */

                newSym->sdTypeGet();
            }
        }

        if  (defTok == tkDELEGATE)
            newSym->sdClass.sdcAsyncDlg = asynch;

        /* Remember the access level of the symbol */

        newSym->sdAccessLevel = (accessLevels)mods.dmAcc;

        /* Allocate a definition descriptor and add it to the symbol's list */

        ourScanner->scanGetTokenPos(&defLine);

        if  (parent->sdSymKind == SYM_CLASS)
        {
            ExtList         memDef;

            symDef =
            memDef = ourSymTab->stRecordMemSrcDef(name,
                                                  NULL,
                                                  parseCurCmp,
                                                  parseCurUseDesc,
                                                  dclFpos,
//                                                ourScanner->scanGetFilePos(),
                                                  defLine);

            /* Record the delegate symbol in the entry */

            memDef->mlSym  = newSym;

            /* Add the delegate to the member list of the class */

            ourComp->cmpRecordMemDef(parent, memDef);
        }
        else
        {
            symDef = ourSymTab->stRecordSymSrcDef(newSym,
                                                  parseCurCmp,
                                                  parseCurUseDesc,
                                                  dclFpos,
//                                                ourScanner->scanGetFilePos(),
                                                  defLine);
        }

        symDef->dlHasDef = true;
        goto EXIT;
    }

    /* We must have a namespace/class/enum definition here */

    assert(defTok == tkENUM      ||
           defTok == tkCLASS     ||
           defTok == tkUNION     ||
           defTok == tkSTRUCT    ||
           defTok == tkDELEGATE  ||
           defTok == tkINTERFACE ||
           defTok == tkNAMESPACE);

    switch (defTok)
    {
    case tkENUM:
        defKind = SYM_ENUM;
        break;

    case tkCLASS:
        ctxFlag = 0;
        flavor  = STF_CLASS;
        defKind = SYM_CLASS;
        valueTp = false;
        managOK = true;
        break;

    case tkUNION:
        flavor  = STF_UNION;
        defKind = SYM_CLASS;
        valueTp = true;
        managOK = false;
        break;

    case tkSTRUCT:
        flavor  = STF_STRUCT;
        defKind = SYM_CLASS;
        valueTp = true;
        managOK = true;
        break;

    case tkINTERFACE:

#if 0

        /* Disallow interfaces at file scope */

        if  (parent == parseComp->cmpGlobalNS)
            parseComp->cmpError(ERRbadGlobInt);

#endif

        /* Interfaces are never unmanaged */

        if  (mods.dmMod & DM_UNMANAGED)
        {
            parseComp->cmpError(ERRbadUnmInt);
            mods.dmMod &= ~DM_UNMANAGED;
        }

        flavor  = STF_INTF;
        defKind = SYM_CLASS;
        valueTp = false;
        managOK = true;
        break;

    case tkNAMESPACE:
        defKind = SYM_NAMESPACE;
        break;

    case tkDELEGATE:
        dclFpos = ourScanner->scanGetFilePos();
        asynch  = false;
        if  (ourScanner->scan() == tkASYNCH)
        {
            asynch = true;
            ourScanner->scan();
        }
        symKind = SYM_CLASS;
        goto TDF_DLG;

    default:
        NO_WAY(!"what the?");
    }

    hasBase = false;

FIND_LC:

    /* Process the name of the namespace/class/intf/enum */

    switch (ourScanner->scan())
    {
    case tkLCurly:

        /* Anonymous type - invent a name for it */

        if  (defTok == tkINTERFACE ||
             defTok == tkNAMESPACE || parseComp->cmpConfig.ccPedantic)
        {
            parseComp->cmpError(ERRnoIdent);
        }

        newSym = ourSymTab->stDeclareSym(parseComp->cmpNewAnonymousName(),
                                         defKind,
                                         NS_HIDE,
                                         parent);

        newSym->sdAccessLevel = (accessLevels)mods.dmAcc;

        if  (defKind == SYM_CLASS)
        {
            if  (parent->sdSymKind == SYM_CLASS)
                newSym->sdClass.sdcAnonUnion = true;
            else
                parseComp->cmpError(ERRglobAnon);
        }

        break;

    case tkLParen:

        /* This might a tagged anonymous union */

        if  (defTok == tkUNION && parent->sdSymKind == SYM_CLASS)
        {
            if  (ourScanner->scan() != tkID)
            {
                ourComp->cmpError(ERRnoIdent);
                UNIMPL(!"recover from error");
            }

            if  (ourScanner->scan() != tkRParen)
            {
                ourComp->cmpError(ERRnoRparen);
                UNIMPL(!"recover from error");
            }

            if  (ourScanner->scan() != tkLCurly)
            {
                ourComp->cmpError(ERRnoLcurly);
                UNIMPL(!"recover from error");
            }

            /* Declare the anonymous union symbol */

            newSym = ourSymTab->stDeclareSym(parseComp->cmpNewAnonymousName(),
                                             SYM_CLASS,
                                             NS_HIDE,
                                             parent);

            newSym->sdAccessLevel        = (accessLevels)mods.dmAcc;
            newSym->sdClass.sdcAnonUnion = true;
            newSym->sdClass.sdcTagdUnion = true;
            parent->sdClass.sdcNestTypes = true;

            break;
        }

        // Fall through ...

    default:

        for (symKind = SYM_NAMESPACE, prefix = true;;)
        {
            tokens          nextTok;
            Ident           symName;

            /* The next token better be a name */

            if  (ourScanner->scanTok.tok != tkID)
            {
                ourComp->cmpError(ERRnoIdent);
                assert(!"need to skip to semicolon or an outer '{', right?");
            }
            else
            {
                symName = ourScanner->scanTok.id.tokIdent;

                /* Is this a namespace prefix or the actual name of the symbol? */

                defFpos = ourScanner->scanGetFilePos();
                nextTok = ourScanner->scanLookAhead();

                if  (nextTok != tkDot && nextTok != tkColon2)
                {
                    prefix  = false;
                    symKind = defKind;
                }
                else
                {
                    /* Qualified names are only allowed at the outermost level */

                    if  (owner != ourComp->cmpGlobalNS)
                    {
                        ourComp->cmpError(ERRbadQualid);
                        UNIMPL("now what?");
                    }
                }
            }

            /* Look for an existing symbol with a matching name */

            if  (parent->sdSymKind == SYM_CLASS)
                newSym = ourSymTab->stLookupScpSym(symName,          parent);
            else
                newSym = ourSymTab->stLookupNspSym(symName, NS_NORM, parent);

            if  (newSym)
            {
                /* Symbol already exists, make sure it's the right kind */

                if  (newSym->sdSymKindGet() != symKind)
                {
                    /* This is not legal, issue an error message */

                    ourComp->cmpError(ERRredefName, newSym);

                    /* Declare a hidden symbol anyway to prevent further blow-ups */

                    newSym = ourSymTab->stDeclareSym(symName, symKind, NS_HIDE, parent);
                    goto NEW_SYM;
                }
                else
                {
                    /* Make sure various other attributes agree */

#ifdef  DEBUG
                    if  (newSym->sdAccessLevel != (accessLevels)mods.dmAcc && symKind != SYM_NAMESPACE)
                    {
                        printf("Access level changed for '%s', weirdness in metadata?\n", newSym->sdSpelling());
                    }
#endif

                    switch (symKind)
                    {
                    case SYM_CLASS:

                        /* Make sure the flavor agrees with previous declaration */

                        if  (newSym->sdClass.sdcFlavor != (unsigned)flavor)
                        {
                            /* Special case: "Delegate" is defined as a class */

                            if  (flavor == STF_CLASS && newSym->sdClass.sdcFlavor == STF_DELEGATE
                                                     && newSym->sdClass.sdcBuiltin)
                            {
                                flavor = STF_DELEGATE;
                                break;
                            }

                            ourComp->cmpGenError(ERRchgClsFlv,
                                                 newSym->sdSpelling(),
                                                 symTab::stClsFlavorStr(newSym->sdClass.sdcFlavor));
                        }

                        // Fall through, the rest is shared with enum's

                    case SYM_ENUM:

                        /* Was there an explicit management specifier? */

                        if  (mods.dmMod & (DM_MANAGED|DM_UNMANAGED))
                        {
                            if  (mods.dmMod & DM_MANAGED)
                            {
                                if  (newSym->sdIsManaged == false)
                                    ourComp->cmpError(ERRchgMgmt, newSym, parseHash->tokenToIdent(tkUNMANAGED));
                            }
                            else
                            {
                                if  (newSym->sdIsManaged != false)
                                    ourComp->cmpError(ERRchgMgmt, newSym, parseHash->tokenToIdent(tkMANAGED));
                            }
                        }
                        else
                        {
                            /* The class/enum will inherit management */

                            mods.dmMod |= newSym->sdIsManaged ? DM_MANAGED
                                                              : DM_UNMANAGED;
                        }
                        break;

                    case SYM_NAMESPACE:
                        break;

                    default:
                        NO_WAY(!"unexpected symbol");
                    }
                }
            }
            else
            {
                /* Symbol not known yet, declare it */

                newSym = ourSymTab->stDeclareSym(symName, symKind, NS_NORM, parent);

            NEW_SYM:

                newSym->sdAccessLevel = (accessLevels)mods.dmAcc;

                switch (symKind)
                {
                    bool            manage;

                case SYM_NAMESPACE:

                    newSym->sdNS.sdnSymtab = ourSymTab;
                    break;

                case SYM_CLASS:

                    if  (mods.dmMod & DM_TRANSIENT)
                        parseComp->cmpGenWarn(WRNobsolete, "'transient' on a class");

                    newSym->sdClass.sdcUnsafe   = ((mods.dmMod & DM_UNSAFE   ) != 0);
                    newSym->sdClass.sdcSrlzable = ((mods.dmMod & DM_SERLZABLE) != 0);
                    newSym->sdIsAbstract        = ((mods.dmMod & DM_ABSTRACT ) != 0);
                    newSym->sdIsSealed          = ((mods.dmMod & DM_SEALED   ) != 0);

                    if  (parent->sdSymKind == SYM_CLASS)
                         parent->sdClass.sdcNestTypes = true;

                    break;

                case SYM_ENUM:

                    /* Has explicit management been specified ? */

                    if  (mods.dmMod & (DM_MANAGED|DM_UNMANAGED))
                    {
                        manage = ((mods.dmMod & DM_MANAGED) != 0);
                    }
                    else
                    {
                        /* By default we inherit management from our parents */

                        manage = parent->sdIsManaged;

                        if  (parent->sdSymKind != SYM_CLASS)
                        {
                            /* Generally enums in namespaces are managed by default */

                            manage = true;

                            /* In global scope choose based on the "old-style" toggle */

                            if  (parent == parseComp->cmpGlobalNS)
                            {
                                manage = !parseOldStyle;
                            }
                        }
                    }

                    newSym->sdIsManaged = manage;
                    break;
                }
            }

            /* Consume the identifier */

            ourScanner->scan();

            /* We're done if we've found the actual symbol name */

            if  (!prefix)
                break;

            /* The current symbol becomes the new context */

            parent = newSym;

            /* Consume the delimiter */

            ourScanner->scan();
        }

        if  (newSym->sdIsImport && newSym->sdSymKind != SYM_NAMESPACE)
        {
            assert(newSym->sdCompileState <= CS_DECLARED);  // ISSUE: well, what if?
            assert(newSym->sdSymKind == SYM_CLASS);

            newSym->sdIsImport            = false;
            newSym->sdClass.sdcMDtypedef  = 0;
            newSym->sdClass.sdcMemDefList = NULL;
            newSym->sdClass.sdcMemDefLast = NULL;
        }

        break;

    case tkATTRIBUTE:

        hasBase = true;

        if  (ourScanner->scanLookAhead() == tkLParen)
        {
            ourScanner->scan(); assert(ourScanner->scanTok.tok == tkLParen);

//          parseComp->cmpGenWarn(WRNobsolete, "class __attribute(AttributeTargets.xxxxx) foo { ... } thingie");

            if  (ourScanner->scan() != tkRParen)
            {
                parseExprComma();
                if  (ourScanner->scanTok.tok != tkRParen)
                    parseComp->cmpError(ERRnoRparen);
            }
            else
            {
                parseComp->cmpError(ERRnoCnsExpr);
            }
        }
        else
            parseComp->cmpGenWarn(WRNobsolete, "Please switch to the '__attribute(const-expr)' style soon!!!!");

        goto FIND_LC;

    case tkAPPDOMAIN:

        if  (ctxFlag || defTok != tkCLASS)
            parseComp->cmpError(ERRdupModifier);

        ctxFlag = 1;
        hasBase = true;
        goto FIND_LC;

    case tkCONTEXTFUL:

        if  (ctxFlag || defTok != tkCLASS)
            parseComp->cmpError(ERRdupModifier);

        ctxFlag = 2;
        hasBase = true;
        goto FIND_LC;
    }

    /* Figure out and record the source extent of the definition */

    switch (defKind)
    {
        DefList         defRec;
        TypDef          clsTyp;
        bool            manage;
        declMods        memMods;

    case SYM_CLASS:

        /* Figure out whether the class is to be managed or unmanaged */

        if  (mods.dmMod & (DM_MANAGED|DM_UNMANAGED))
        {
            if  (mods.dmMod & DM_MANAGED)
            {
                if  (!managOK)
                    parseComp->cmpWarn(WRNbadMgdStr);

                manage = true;
            }
            else
            {
                assert(mods.dmMod & DM_UNMANAGED);

                manage = false;
            }
        }
        else
        {
            /* No explicit management specifier, use default */

            switch (flavor)
            {
            case STF_CLASS:
            case STF_UNION:
            case STF_STRUCT:

                if  (parent == parseComp->cmpGlobalNS)
                {
                    {
                        manage = !parseOldStyle;
                        break;
                    }
                }

                if  (parent->sdSymKind == SYM_CLASS)
                    manage = parent->sdIsManaged;
                else
                    manage = true;

                break;

            case STF_INTF:
            case STF_DELEGATE:
                manage = true;
                break;

            default:
                NO_WAY(!"weird flavor");
            }
        }

        /* Remember the management status of the class */

        newSym->sdIsManaged       =
        ourComp->cmpManagedMode   = manage;

        /* Remember the "flavor" of the symbol */

        newSym->sdClass.sdcFlavor = flavor;

        /* Create the class type and record whether it's a ref or value type */

        clsTyp = newSym->sdTypeGet(); assert(clsTyp && clsTyp->tdClass.tdcSymbol == newSym);

        clsTyp->tdClass.tdcValueType = valueTp;

        /* Check for a "known" class name */

        if  (hashTab::getIdentFlags(newSym->sdName) & IDF_PREDEF)
        {
            if  (parent == parseComp->cmpNmSpcSystem)
                parseComp->cmpMarkStdType(newSym);
        }

        /* Is this a generic class declaration? */

        if  (ourScanner->scanTok.tok == tkLT)
        {
            /* This better be a managed class/interface */

            if  ((newSym->sdClass.sdcFlavor != STF_CLASS &&
                  newSym->sdClass.sdcFlavor != STF_INTF) || !newSym->sdIsManaged)
            {
                ourComp->cmpError(ERRumgGenCls);
            }

            /* This better not be a nested class */

            if  (parent->sdSymKind != SYM_NAMESPACE)
                ourComp->cmpError(ERRgenNested);

            /* Parse and record the formal parameter list */

            newSym->sdClass.sdcGeneric = true;
            newSym->sdClass.sdcArgLst  = parseGenFormals();
        }

        /* Does this class implement any interfaces? */

        if  (ourScanner->scanTok.tok == tkINCLUDES ||
             ourScanner->scanTok.tok == tkIMPLEMENTS)
        {
            clearDeclMods(&memMods);

            hasBase = true;

            for (;;)
            {
                ourScanner->scan();

                parseTypeSpec(&memMods, false);

                if  (ourScanner->scanTok.tok != tkComma)
                    break;
            }

            goto DONE_BASE;
        }

        // Fall through ...

    case SYM_ENUM:

        if  (ourScanner->scanTok.tok == tkColon)
        {
            /* Carefully skip the ": base" part */

            for (;;)
            {
                switch (ourScanner->scan())
                {
                case tkPUBLIC:
                    if  (defKind == SYM_CLASS)
                    {
                        ourScanner->scan();
                        break;
                    }

                case tkPRIVATE:
                case tkPROTECTED:
                    parseComp->cmpError(ERRbadAccSpec);
                    ourScanner->scan();
                    break;
                }

                parseTypeSpec(&memMods, false);

                if  (ourScanner->scanTok.tok != tkComma)
                    break;
                if  (defKind != SYM_CLASS || flavor != STF_INTF)
                    break;
            }

            if  ((ourScanner->scanTok.tok == tkINCLUDES ||
                  ourScanner->scanTok.tok == tkIMPLEMENTS) && defKind == SYM_CLASS)
            {
                if  (hasBase)
                    parseComp->cmpError(ERRdupIntfc);

                for (;;)
                {
                    ourScanner->scan();

                    parseTypeSpec(&memMods, false);

                    if  (ourScanner->scanTok.tok != tkComma)
                        break;
                }
            }

            hasBase = true;
        }

    DONE_BASE:

        clearDeclMods(&memMods);

        /* If the name was qualified we may need to insert some "using" entries */

        if  (newSym->sdParent != owner)
        {
            usingState  state;

            parseInsertUses(state, newSym->sdParent, owner);
            defRec = parseMeasureSymDef(newSym, memMods, dclFpos, dclLine);
            parseRemoveUses(state);
        }
        else
        {
            defRec = parseMeasureSymDef(newSym, memMods, dclFpos, dclLine);
        }

        if  (!defRec)
            goto EXIT;

        defRec->dlEarlyDecl = (defKind == SYM_ENUM);

        /* Remember whether we need to re-process the part before the "{" */

        if  (hasBase || (mods.dmMod & DM_XMODS) || (newSym->sdSymKind == SYM_CLASS &&
                                                    newSym->sdClass.sdcGeneric))
        {
            defRec->dlHasBase = true;
        }
        else if (newSym->sdSymKind == SYM_CLASS)
        {
            if      (newSym->sdClass.sdcTagdUnion)
            {
                defRec->dlHasBase = true;

                if  (ourScanner->scanTok.tok != tkSColon)
                    ourComp->cmpError(ERRnoSemic);
            }
            else if (newSym->sdClass.sdcAnonUnion)
            {
                defRec->dlHasBase   =
                defRec->dlAnonUnion = true;
            }
        }

        break;

    case SYM_NAMESPACE:

        clearDeclMods(&memMods);

        newSym->sdIsManaged = ourComp->cmpManagedMode;

        parseMeasureSymDef(newSym, memMods, dclFpos, dclLine);

        break;

    default:
        NO_WAY(!"what the?");
    }

EXIT:

    /* Restore previous management mode */

    ourComp->cmpManagedMode = mgdSave;

    return  newSym;
}

/*****************************************************************************
 *
 *  A recursive routine that parses qualified names.
 */

QualName            parser::parseQualNRec(unsigned depth, Ident name1, bool allOK)
{
    Scanner         ourScanner = parseScan;

    bool            isAll = false;

    QualName        qual;
    Ident           name;

    /* Remember the name */

    if  (name1)
    {
        /* The name was already consumed by the caller */

        name = name1;
    }
    else
    {
        /* Remember and consume the name */

        assert(ourScanner->scanTok.tok == tkID);
        name = ourScanner->scanTok.id.tokIdent;
        ourScanner->scan();
    }

    /* Is this the end or is there more? */

    switch(ourScanner->scanTok.tok)
    {
    case tkDot:
    case tkColon2:

        /* Make sure the right thing follows */

        switch (ourScanner->scan())
        {
        case tkID:

            /* Recursively process the rest of the name */

            qual = parseQualNRec(depth+1, NULL, allOK);

            if  (qual)
            {
                /* Insert our name in the table and return */

                assert(depth < qual->qnCount); qual->qnTable[depth] = name;
            }

            return  qual;

        case tkMul:
            if  (allOK)
            {
                ourScanner->scan();
                isAll = true;
                break;
            }

        default:
            parseComp->cmpError(ERRnoIdent);
            return  NULL;
        }
    }

    /* This is the end of the name; allocate the descriptor */

#if MGDDATA
    qual = new QualName; qual->qnTable = new Ident[depth+1];
#else
    qual =    (QualName)parseAllocPerm->nraAlloc(sizeof(*qual) + (depth+1)*sizeof(Ident));
#endif

    qual->qnCount        = depth+1;
    qual->qnEndAll       = isAll;
    qual->qnTable[depth] = name;

    return  qual;
}

/*****************************************************************************
 *
 *  Process a using declaration.
 */

void                parser::parseUsingDecl()
{
    QualName        name;
    UseList         uses;
    bool            full;

    assert(parseScan->scanTok.tok == tkUSING);

    /* Is this "using namespace foo" ? */

    full = false;

    if  (parseScan->scan() == tkNAMESPACE)
    {
        full = true;
        parseScan->scan();
    }

    /* Make sure the expected identifier is present */

    if  (parseScan->scanTok.tok != tkID)
    {
        parseComp->cmpError(ERRnoIdent);
        parseScan->scanSkipText(tkNone, tkNone);
        return;
    }

    /* Parse the (possibly qualified) name */

    name = parseQualName(true);

    /* Create a "using" entry */

#if MGDDATA
    uses = new UseList;
#else
    uses =    (UseList)parseAllocPerm->nraAlloc(sizeof(*uses));
#endif

    uses->ulAll     = full | name->qnEndAll;
    uses->ulAnchor  = false;
    uses->ulBound   = false;
    uses->ul.ulName = name;
    uses->ulNext    = parseCurUseList;
                      parseCurUseList = uses;

    /* There better be a ";" following the directive */

    if  (parseScan->scanTok.tok != tkSColon)
        parseComp->cmpError(ERRnoSemic);
}

/*****************************************************************************
 *
 *  Save the current "using" state and insert entries for all namespaces that
 *  lie between the given symbols.
 */

void                parser::parseInsertUses(INOUT usingState REF state,
                                                  SymDef         inner,
                                                  SymDef         outer)
{
    /* Save the current "using" state */

    state.usUseList = parseCurUseList;
    state.usUseDesc = parseCurUseDesc;

    /* Recursively insert all the necessary "using" entries */

    if  (inner != outer)
        parseInsertUsesR(inner, outer);

    parseCurUseList = NULL;
}

/*****************************************************************************
 *
 *  Add entries for all namespaces up to "inner" to the given use list.
 */

UseList             parser::parseInsertUses(UseList useList, SymDef inner)
{
    UseList         newList;

    assert(inner != parseComp->cmpGlobalNS);
    assert(parseCurUseDesc == NULL);

    parseCurUseDesc = useList;

    parseInsertUsesR(inner, parseComp->cmpGlobalNS);

    newList = parseCurUseDesc;
              parseCurUseDesc = NULL;

    return  newList;
}

/*****************************************************************************
 *
 *  Recursive helper to insert "using" entries between the two namespaces.
 */

void                parser::parseInsertUsesR(SymDef inner, SymDef outer)
{
    UseList         uses;

    assert(inner && inner->sdSymKind == SYM_NAMESPACE);

    if  (inner->sdParent != outer)
        parseInsertUsesR(inner->sdParent, outer);

    /* Create a "using" entry */

#if MGDDATA
    uses = new UseList;
#else
    uses =    (UseList)parseAllocPerm->nraAlloc(sizeof(*uses));
#endif

    uses->ulAnchor  = true;
    uses->ulBound   = true;
    uses->ul.ulSym  = inner;
    uses->ulNext    = parseCurUseDesc;
                      parseCurUseDesc = uses;
}

/*****************************************************************************
 *
 *  Restore previous "using" state.
 */

void                parser::parseRemoveUses(IN usingState REF state)
{
    parseCurUseList = state.usUseList;
    parseCurUseDesc = state.usUseDesc;
}

/*****************************************************************************
 *
 *  Swallow the definition of the specified symbol (checking for any nested
 *  members in the process). We record the source text extent of the symbol's
 *  definition and return after consuming its final token.
 */

DefList             parser::parseMeasureSymDef(SymDef sym, declMods  mods,
                                                           scanPosTP dclFpos,
                                                           unsigned  dclLine)
{
    Compiler        ourComp    = parseComp;
    SymTab          ourSymTab  = parseStab;
    Scanner         ourScanner = parseScan;

    bool            hasBody    = true;
    bool            isCtor     = false;

    bool            prefMods   = false;

    bool            addUses    = false;
    usingState      useState;

#ifdef  SETS
    bool            XMLelems   = false;
    bool            XMLextend  = false;
#endif

    declMods        memMod;
    scanPosTP       memFpos;

    bool            fileScope;

    scanPosTP       defEpos;

    unsigned        defLine;

    DefList         defRec;

    accessLevels    acc;

    /* Remember which symbol we're processing and whether we're at file scope */

    parseCurSym = sym;
    fileScope   = (sym == parseComp->cmpGlobalNS);

    if  (parseOldStyle && fileScope && !(mods.dmMod & (DM_MANAGED|DM_UNMANAGED)))
    {
        acc       = ACL_PUBLIC;
        memMod    = mods;
        memFpos   = dclFpos;
        defLine   = dclLine;
//      defCol    = dclCol;

        /* Have we already parsed the modifiers? */

        if  (!(mods.dmMod & DM_CLEARED))
            goto PARSE_MEM;

        /* Check for an import declaration */

        switch (ourScanner->scanTok.tok)
        {
        case tkID:


            /* Check for a ctor */

            switch (ourScanner->scanLookAhead())
            {
            case tkDot:
            case tkColon2:
                if  (parseIsCtorDecl(NULL))
                {
                    isCtor = true;
                    goto IS_CTOR;
                }
                break;
            }
            break;

        case tkEXTERN:

            switch (ourScanner->scanLookAhead())
            {
            case tkLParen:
                parseBrackAttr(false, 0, &memMod);
                prefMods = true;
                goto PARSE_MEM;

            case tkStrCon:

                ourComp->cmpWarn(WRNignoreLnk);

                ourScanner->scan();
                ourScanner->scanTok.tok = tkEXTERN;
                break;
            }
            break;

        case tkLBrack:
            parseBrackAttr(false, ATTR_MASK_SYS_IMPORT|ATTR_MASK_SYS_STRUCT);
            goto PARSE_MOD;

        case tkMULTICAST:
            ourScanner->scan();
            parseDeclMods(acc, &memMod); memMod.dmMod |= DM_MULTICAST;
            goto NEST_DEF;
        }

        goto PARSE_MOD;
    }

    /* Remember where the whole thing starts */

    ourScanner->scanGetTokenPos(&dclLine);

    /* Make sure the expected "{" is actually present */

    if  (ourScanner->scanTok.tok != tkLCurly)
    {
        /* Is this a file-scope forward declaration? */

        if  (ourScanner->scanTok.tok == tkSColon &&
             sym->sdParent == parseComp->cmpGlobalNS)
        {
            hasBody = false;
            goto DONE_DEF;
        }

        /* Well, what the heck is this? */

        ourComp->cmpError(ERRnoLcurly);

        if  (ourScanner->scanTok.tok != tkSColon)
            ourScanner->scanSkipText(tkNone, tkNone);

        return  NULL;
    }

    /* If we're in a namespace, open a new "using" scope */

    if  (sym->sdSymKind == SYM_NAMESPACE)
    {
        addUses = true; parseUsingScpBeg(useState, sym);
    }

//  if  (!strcmp(sym->sdSpelling(), "<name>")) forceDebugBreak();

    /* Now consume the rest of the definition */

    switch (sym->sdSymKind)
    {
    case SYM_ENUM:

        /* Can't allow two definitions for the same symbol */

        if  (sym->sdIsDefined)
            ourComp->cmpError(ERRredefEnum, sym);

        sym->sdIsDefined = true;

        /* Simply swallow everything up to the "}" or ";" */

        ourScanner->scanSkipText(tkLCurly, tkRCurly);
        break;

    case SYM_CLASS:

        /* Can't allow two definitions for the same symbol */

        if  (sym->sdIsDefined)
            ourComp->cmpError(ERRredefClass, sym);

        sym->sdIsDefined = true;

        /* Record the current default alignment value */

        sym->sdClass.sdcDefAlign = compiler::cmpEncodeAlign(parseAlignment);

        /* Make sure the value was recorded correctly */

        assert(compiler::cmpDecodeAlign(sym->sdClass.sdcDefAlign) == parseAlignment);

    case SYM_NAMESPACE:

        /* Swallow the "{" */

        assert(ourScanner->scanTok.tok == tkLCurly); ourScanner->scan();

        /* Figure out the default access level */

        acc = ACL_DEFAULT;

        if  (parseOldStyle)
        {
            acc = ACL_PUBLIC;
        }
        else if (sym->sdSymKind == SYM_CLASS &&
                 sym->sdClass.sdcFlavor == STF_INTF)
        {
            acc = ACL_PUBLIC;
        }

        /* Process the contents of the class/namespace */

        while (ourScanner->scanTok.tok != tkEOF &&
               ourScanner->scanTok.tok != tkRCurly)
        {
            tokens          defTok;

            /* Remember the source position of the member */

            memFpos = ourScanner->scanGetTokenPos(&defLine);

            /* See what kind of a member do we have */

            switch (ourScanner->scanTok.tok)
            {
                TypDef          type;
                Ident           name;
                QualName        qual;
                dclrtrName      nmod;

                bool            noMore;

                ExtList         memDef;

                unsigned        memBlin;
                scanPosTP       memBpos;
                unsigned        memSlin;
                scanPosTP       memSpos;


            case tkEXTERN:

                switch (ourScanner->scanLookAhead())
                {
                case tkLParen:
                    parseBrackAttr(false, 0, &memMod);
                    prefMods = true;
                    goto PARSE_MEM;

                case tkStrCon:

                    ourComp->cmpWarn(WRNignoreLnk);

                    ourScanner->scan();
                    ourScanner->scanTok.tok = tkEXTERN;
                    break;
                }

                // Fall through ...

            default:

                /* Must be a "normal" member */

            PARSE_MOD:

                parseDeclMods(acc, &memMod);

            PARSE_MEM:

//              static int x; if (++x == 0) forceDebugBreak();

                if  (memMod.dmMod & DM_TYPEDEF)
                {
                    defTok = tkTYPEDEF;
                    goto NEST_DEF;
                }

                /* Members are only allowed within classes */

                if  (sym->sdSymKind == SYM_CLASS)
                {
                    isCtor = false;

                    if  (sym->sdType->tdClass.tdcFlavor != STF_INTF)
                    {
                        isCtor = parseIsCtorDecl(sym);

                        if  (isCtor)
                        {
                            /* Pretend we've parsed a type spec already */

                        IS_CTOR:

                            type = sym->sdType;
                            goto GET_DCL;
                        }


                    }
                }
                else
                {
                    /* We also allow declarations at file scope */

                    if  (!fileScope)
                    {
                        ourComp->cmpError(ERRbadNSmem);
                        ourScanner->scanSkipText(tkNone, tkNone);
                        break;
                    }
                }

                /* Parse the type specification */

                type = parseTypeSpec(&memMod, false);

            GET_DCL:

                /* We have the type, now parse any declarators that follow */

                nmod = (dclrtrName)(DN_REQUIRED|DN_QUALOK);
                if  (!fileScope)
                {
                    /* We allow interface method implementations to be qualified */

                    if  (sym->sdSymKind != SYM_CLASS || !sym->sdIsManaged)
                        nmod = DN_REQUIRED;
                }

#ifdef  SETS
                if  (XMLelems)
                    nmod = DN_OPTIONAL;
#endif

                /*
                    This is trickier than it may seem at first glance. We need
                    to be able to process each member / variable individually
                    later on, but one declaration can declare more than one
                    member / variable with a single type specifier, like so:

                        int foo, bar;

                    What we do is remember where the type specifier ends, and
                    for each declarator we record how much of the source needs
                    to be skipped to reach its beginning. This is a bit tricky
                    because the distance can be arbitrarily large (really) and
                    we need to be clever about recording it in little space.
                 */

                memBpos = ourScanner->scanGetTokenPos();
                memBlin = ourScanner->scanGetTokenLno();

                for (;;)
                {
                    bool            memDefd;
                    bool            memInit;

                    scanPosTP       memEpos;
                    scanDifTP       dclDist;

                    /* Remember where the declarator starts */

                    memSpos = ourScanner->scanGetTokenPos();
                    memSlin = ourScanner->scanGetTokenLno();

                    // UNDONE: Make sure the declaration doesn't span a conditional compilation boundary!

                    noMore = false;

                    /* Is this an unnamed bitfield? */

                    if  (ourScanner->scanTok.tok == tkColon)
                    {
                        name = NULL;
                        qual = NULL;
                    }
                    else
                    {
                        /* Parse the next declarator */

                        name = parseDeclarator(&memMod,
                                               type,
                                               nmod,
                                               NULL,
                                               &qual,
                                               false);

                        if  (prefMods)
                            memMod.dmMod |= DM_XMODS;
                    }


                    memEpos = ourScanner->scanGetFilePos();

                    /* Is there an initializer or method body? */

                    memDefd = memInit = false;

                    switch (ourScanner->scanTok.tok)
                    {
                    case tkAsg:

                        /* Skip over the initializer */

                        ourScanner->scanSkipText(tkLParen, tkRParen, tkComma);
                        memInit =
                        memDefd = true;
                        memEpos = ourScanner->scanGetFilePos();
                        break;


                    case tkColon:

                        /* This could be a base class initializer or a bitfield */

                        if  (!isCtor)
                        {
                            /* Swallow the bitfield specification */

                            ourScanner->scan();
                            parseExprComma();

                            memEpos = ourScanner->scanGetFilePos();
                            break;
                        }

                        /* Presumably we have "ctor(...) : base(...) */

                        ourScanner->scanSkipText(tkNone, tkNone, tkLCurly);

                        if  (ourScanner->scanTok.tok != tkLCurly)
                        {
                            ourComp->cmpError(ERRnoLcurly);
                            break;
                        }

                        // Fall through ...

                    case tkLCurly:

                        parseComp->cmpFncCntSeen++;


                        /* Skip over the function/property body */

                        ourScanner->scanSkipText(tkLCurly, tkRCurly);
                        noMore  = true;

                        memDefd = true;
                        memEpos = ourScanner->scanGetFilePos();

                        if  (ourScanner->scanTok.tok == tkRCurly)
                            ourScanner->scan();

                        break;
                    }

                    /* Ignore the member if there were really bad errors */

                    if  (name == NULL && qual == NULL)
                    {
#ifdef  SETS
                        if  (XMLelems)
                            name = parseComp->cmpNewAnonymousName();
                        else
#endif
                        goto BAD_MEM;
                    }

                    /* Add a definition descriptor for the member */

                    memDef = ourSymTab->stRecordMemSrcDef(name,
                                                          qual,
                                                          parseCurCmp,
                                                          parseCurUseDesc,
                                                          memFpos,
//                                                        memEpos,
                                                          defLine);

//                  printf("[%08X..%08X-%08X..%08X] Member '%s'\n", memFpos, memBpos, memSpos, memEpos, name->idSpelling());

                    memDef->dlHasDef     = memDefd;
                    memDef->dlPrefixMods = ((memMod.dmMod & DM_XMODS) != 0);
                    memDef->dlIsCtor     = isCtor;
                    memDef->dlDefAcc     = memMod.dmAcc;
#ifdef  SETS
                    memDef->dlXMLelem    = XMLelems;
#endif

                    /* Figure out the "distance" to the declarator */

                    dclDist = ourScanner->scanGetPosDiff(memBpos, memSpos);

                    if  (dclDist || memBlin != memSlin)
                    {
                        NumPair         dist;

                        /* Try to pack the distance in the descriptor */

                        if  (memSlin == memBlin && dclDist < dlSkipBig)
                        {
                            memDef->dlDeclSkip = dclDist;

                            /* Make sure the stored value fit in the bitfield */

                            assert(memDef->dlDeclSkip == dclDist);

                            goto DONE_SKIP;
                        }

                        /* The distance is too far, go to plan B */

#if MGDDATA
                        dist = new NumPair;
#else
                        dist =    (NumPair)parseAllocPerm->nraAlloc(sizeof(*dist));
#endif
                        dist->npNum1 = dclDist;
                        dist->npNum2 = memSlin - memBlin;

                        /* Add the number pair to the generic vector */

                        dclDist = parseComp->cmpAddVecEntry(dist, VEC_TOKEN_DIST) | dlSkipBig;

                        /* Store the vector index with the "big" bit added */

                        memDef->dlDeclSkip = dclDist;

                        /* Make sure the stored value fit in the bitfield */

                        assert(memDef->dlDeclSkip == dclDist);
                    }

                DONE_SKIP:


                    /* Mark global constants as such */

                    if  ((memMod.dmMod & DM_CONST) && !qual && memInit)
                        memDef->dlEarlyDecl = true;

                    /* Record the member if we're in the right place */

                    if  (sym->sdSymKind == SYM_CLASS)
                    {
                        assert(sym->sdIsImport == false);

                        /* Add it to the member list of the class */

                        ourComp->cmpRecordMemDef(sym, memDef);
                    }
                    else
                    {
                        assert(sym->sdSymKind == SYM_NAMESPACE);

                        /* This is a file scope / namespace declaration */

                        memDef->dlNext = sym->sdNS.sdnDeclList;
                                         sym->sdNS.sdnDeclList = memDef;
                    }

                BAD_MEM:

                    /* Are there any more declarators? */

                    if  (ourScanner->scanTok.tok != tkComma || noMore
                                                            || prefMods)
                    {
                        if  (fileScope)
                            goto EXIT;

                        /* Check for - and consume - the terminating ";" */

                        if  (ourScanner->scanTok.tok == tkSColon)
                            ourScanner->scan();

                        break;
                    }

                    /* Swallow the "," and go get the next declarator */

                    ourScanner->scan();
                }

                break;

            case tkRCurly:
                goto DONE_DEF;

            case tkSColon:
                ourScanner->scan();
                break;

            case tkUSING:
                parseUsingDecl();
                break;

            case tkDEFAULT:

                if  (ourScanner->scanLookAhead() == tkPROPERTY)
                    goto PARSE_MOD;

                // Fall through ...

            case tkCASE:

                if  (sym->sdSymKind != SYM_CLASS || !sym->sdClass.sdcTagdUnion)
                    ourComp->cmpError(ERRbadStrCase);

                /* Record the name for the 'fake' member we will add */

                name = parseHash->tokenToIdent(ourScanner->scanTok.tok);

                if  (ourScanner->scanTok.tok == tkCASE)
                {
                    /* Skip over the 'case' and the expression that should follow */

                    ourScanner->scan();
                    parseExprComma();

                    /* Both "case val:" and "case(val)" are OK */

                    if  (ourScanner->scanTok.tok == tkColon)
                        ourScanner->scan();
                }
                else
                {
                    /* Both "default:" and just plain "default" are OK for now */

                    if  (ourScanner->scan() == tkColon)
                        ourScanner->scan();
                }

                if  (sym->sdSymKind == SYM_CLASS && sym->sdClass.sdcTagdUnion)
                {
                    /* Create a definition descriptor for the case label */

                    memDef = ourSymTab->stRecordMemSrcDef(name,
                                                          NULL,
                                                          parseCurCmp,
                                                          parseCurUseDesc,
                                                          memFpos,
//                                                        ourScanner->scanGetFilePos(),
                                                          defLine);

                    assert(sym->sdSymKind == SYM_CLASS);
                    assert(sym->sdIsImport == false);

                    /* Add the case to the member list of the class */

                    ourComp->cmpRecordMemDef(sym, memDef);
                }
                break;

            case tkENUM:
            case tkCLASS:
            case tkUNION:
            case tkSTRUCT:
            case tkTYPEDEF:
            case tkDELEGATE:
            case tkINTERFACE:
            case tkNAMESPACE:


                defTok  = ourScanner->scanTok.tok;
                memFpos = ourScanner->scanGetFilePos();

                initDeclMods(&memMod, acc);

            NEST_DEF:

                /* Make sure this is allowed here */

                if  (sym->sdSymKind != SYM_NAMESPACE)
                {
                    switch (defTok)
                    {
                    case tkCLASS:
                    case tkUNION:
                    case tkSTRUCT:
                    case tkDELEGATE:
                    case tkINTERFACE:

                        // ISSUE: should we allow enum's/typedef's within classes?

                        break;

                    default:
                        ourComp->cmpError(ERRnoRcurly);
                        goto DONE;
                    }
                }

                if  (prefMods)
                    memMod.dmMod |= DM_XMODS;

                /* Process the nested member recursively */

                parsePrepSym(sym, memMod, defTok, memFpos, dclLine);

                if  (ourScanner->scanTok.tok == tkComma)
                {
                    if  (defTok != tkTYPEDEF)
                        break;

                    UNIMPL("Sorry: you can only typedef one name at a time for now");
                }

                /* We're back to processing our symbol */

                parseCurSym = sym;
                break;

            case tkPUBLIC:
            case tkPRIVATE:
            case tkPROTECTED:

                switch (ourScanner->scanLookAhead())
                {
                case tkColon:

                    /* This is an access specifier */

                    switch (ourScanner->scanTok.tok)
                    {
                    case tkPUBLIC:    acc = ACL_PUBLIC   ; break;
                    case tkPRIVATE:   acc = ACL_PRIVATE  ; break;
                    case tkPROTECTED: acc = ACL_PROTECTED; break;
                    }

                    /* Consume the "access:" and continue */

                    ourScanner->scan();
                    ourScanner->scan();
                    continue;
                }

            case tkCONST:
            case tkVOLATILE:

            case tkINLINE:
            case tkSTATIC:
            case tkSEALED:
            case tkVIRTUAL:
            case tkABSTRACT:
            case tkOVERRIDE:
            case tkOVERLOAD:

            case tkMANAGED:
            case tkUNMANAGED:

            case tkTRANSIENT:
            case tkSERIALIZABLE:

                /* Here we have some member modifiers */

                parseDeclMods(acc, &memMod);

            CHK_NST:

                /* Check for a non-data/function member */

                switch (ourScanner->scanTok.tok)
                {
                case tkENUM:
                case tkCLASS:
                case tkUNION:
                case tkSTRUCT:
                case tkTYPEDEF:
                case tkDELEGATE:
                case tkINTERFACE:
                case tkNAMESPACE:
                    defTok = ourScanner->scanTok.tok;
                    goto NEST_DEF;
                }

                goto PARSE_MEM;

            case tkLBrack:
            case tkAtComment:
            case tkCAPABILITY:
            case tkPERMISSION:
            case tkATTRIBUTE:

                /* These guys can be basically repeated ad nauseaum */

                for (;;)
                {
                    switch (ourScanner->scanTok.tok)
                    {
                    case tkLBrack:
                        parseBrackAttr(false, (sym->sdSymKind == SYM_NAMESPACE)
                                                    ? ATTR_MASK_SYS_IMPORT
                                                    : ATTR_MASK_SYS_IMPORT|ATTR_MASK_NATIVE_TYPE);
                        continue;

                    case tkAtComment:
                        ourScanner->scan();
                        break;

                    case tkCAPABILITY:
                        parseCapability();
                        break;

                    case tkPERMISSION:
                        parsePermission();
                        break;

                    case tkATTRIBUTE:

                        /* At this stage we just swallow the initializer list */

                        unsigned    tossMask;
                        genericBuff tossAddr;
                        size_t      tossSize;

                        parseAttribute(0, tossMask, tossAddr, tossSize);
                        break;

                    default:
                        parseDeclMods(acc, &memMod); memMod.dmMod |= DM_XMODS;
                        goto CHK_NST;
                    }
                }

                break;  // unreached, BTW

#ifdef  SETS

            case tkRELATE:
                UNIMPL(!"tkRELATE NYI");
                break;

            case tkEllipsis:
                if  (sym->sdSymKind == SYM_CLASS && XMLelems && !XMLextend)
                    XMLextend = true;
                else
                    parseComp->cmpError(ERRsyntax);
                ourScanner->scan();
                break;

            case tkXML:

                if  (sym->sdSymKind != SYM_CLASS || XMLelems || XMLextend)
                {
                    parseComp->cmpError(ERRbadXMLpos);
                    parseResync(tkColon, tkNone);
                    if  (ourScanner->scanTok.tok == tkColon)
                        ourScanner->scan();
                    break;
                }

                if  (ourScanner->scan() == tkLParen)
                {
                    if  (ourScanner->scan() == tkID)
                    {
                        Ident           name = ourScanner->scanTok.id.tokIdent;

                        ourScanner->scan();

                        /* Add a definition descriptor for the "xml" member */

                        memDef = ourSymTab->stRecordMemSrcDef(name,
                                                              NULL,
                                                              parseCurCmp,
                                                              parseCurUseDesc,
                                                              memFpos,
//                                                            memEpos,
                                                              defLine);

                        memDef->dlHasDef   = true;
                        memDef->dlXMLelems = true;

                        /* Add the member to the owning class' list */

                        ourComp->cmpRecordMemDef(sym, memDef);
                    }

                    chkCurTok(tkRParen, ERRnoRparen);
                }

                XMLelems = true;
                chkCurTok(tkColon, ERRnoColon);
                break;

#endif

            case tkMULTICAST:
                ourScanner->scan();
                parseDeclMods(acc, &memMod); memMod.dmMod |= DM_MULTICAST;
                goto NEST_DEF;
            }
        }

        /* Unless we're in global scope or in an old-style namespace, require "}" */

        if  (ourScanner->scanTok.tok != tkRCurly && sym != parseComp->cmpGlobalNS)
        {
            if  (sym->sdSymKind != SYM_NAMESPACE)
                parseComp->cmpError(ERRnoRcurly);
        }

        break;

    default:
        NO_WAY(!"what?");
    }

DONE_DEF:

    /* Get the position of the end of the definition */

    defEpos = ourScanner->scanGetFilePos();

    /* Consume the closing "}" if present */

    if  (ourScanner->scanTok.tok == tkRCurly)
        ourScanner->scan();

DONE:

    /* Are we processing a tagged/anonymous union? */

    if  (sym->sdSymKind == SYM_CLASS && sym->sdClass.sdcAnonUnion)
    {
        ExtList         memDef;
        Ident           memName;

        SymDef          owner = sym->sdParent;

        assert(owner->sdSymKind == SYM_CLASS);

        /* Is there a member name? */

        if  (ourScanner->scanTok.tok == tkID)
        {
            memName = ourScanner->scanTok.id.tokIdent;
            ourScanner->scan();
        }
        else
        {
            memName = parseComp->cmpNewAnonymousName();
        }

        if  (ourScanner->scanTok.tok != tkSColon)
            ourComp->cmpError(ERRnoSemic);

        /* Record the extent of the member's definition */

        memDef = ourSymTab->stRecordMemSrcDef(memName,
                                              NULL,
                                              parseCurCmp,
                                              parseCurUseDesc,
                                              dclFpos,
//                                            defEpos,
                                              dclLine);

        memDef->dlHasDef    = true;
        memDef->dlAnonUnion = true;
        memDef->mlSym       = sym;

        /* Add the member to the owning class' list */

        ourComp->cmpRecordMemDef(owner, memDef);
    }

    /* Allocate a definition descriptor and add it to the symbol's list */

    defRec = ourSymTab->stRecordSymSrcDef(sym,
                                          parseCurCmp,
                                          parseCurUseDesc,
                                          dclFpos,
//                                        defEpos,
                                          dclLine);

    defRec->dlHasDef   = hasBody;
    defRec->dlOldStyle = parseOldStyle;

#ifdef  SETS

    if  (XMLelems)
    {
        assert(sym->sdSymKind == SYM_CLASS);

        sym->sdClass.sdcXMLelems  = true;
        sym->sdClass.sdcXMLextend = XMLextend;
    }

#endif

EXIT:

    /* Restore the "using" state we had on entry if we've changed it */

    if  (addUses)
        parseUsingScpEnd(useState);

    parseCurSym = NULL;

    return  defRec;
}

/*****************************************************************************
 *
 *  Keep track of default alignment (pragma pack).
 */

void            parser::parseAlignSet(unsigned align)
{
    parseAlignment  = align;
}

void            parser::parseAlignPush()
{
//  printf("Push align: %08X <- %u / %u\n", parseAlignStack, parseAlignment, compiler::cmpEncodeAlign(parseAlignment));
    parseAlignStack = parseAlignStack << 4 | compiler::cmpEncodeAlign(parseAlignment);
    parseAlignStLvl++;
}

void            parser::parseAlignPop()
{
    if  (parseAlignStLvl)
    {
//      printf("Pop  align: %08X -> %u / %u\n", parseAlignStack, parseAlignStack & 0xF, compiler::cmpDecodeAlign(parseAlignStack & 0xF));
        parseAlignment  = compiler::cmpDecodeAlign(parseAlignStack & 0x0F);
        parseAlignStack = parseAlignStack >> 4;
        parseAlignStLvl--;
    }
    else
    {
//      printf("Pop  align: ******** -> %u\n", parseComp->cmpConfig.ccAlignVal);
        parseAlignment  = parseComp->cmpConfig.ccAlignVal;
    }
}

/*****************************************************************************
 *
 *  Parse and return any member modifiers, such as "public" or "abstract".
 */

void                parser::parseDeclMods(accessLevels defAccess, DeclMod modPtr)
{
    Scanner         ourScanner = parseScan;

    declMods        mods; clearDeclMods(&mods);

    for (;;)
    {
        switch (ourScanner->scanTok.tok)
        {
            unsigned        modf;

        case tkID:


        DONE:

            if  (mods.dmAcc == ACL_DEFAULT)
                 mods.dmAcc = defAccess;

            *modPtr = mods;
            return;

        default:

            modf = hashTab::tokenIsMod(ourScanner->scanTok.tok);
            if  (modf)
            {
                switch (ourScanner->scanTok.tok)
                {
                case tkMANAGED:
                    if  (mods.dmMod & (DM_MANAGED|DM_UNMANAGED))
                        parseComp->cmpError(ERRdupModifier);
                    break;

                case tkUNMANAGED:
                    if  (mods.dmMod & (DM_MANAGED|DM_UNMANAGED))
                        parseComp->cmpError(ERRdupModifier);
                    break;

                default:
                    if  (mods.dmMod & modf)
                        parseComp->cmpError(ERRdupModifier);
                    break;
                }

                mods.dmMod |= modf;
                break;
            }

            goto DONE;

        case tkPUBLIC:
            if  (mods.dmAcc != ACL_DEFAULT)
                parseComp->cmpError(ERRdupModifier);
            mods.dmAcc = ACL_PUBLIC;
            break;

        case tkPRIVATE:
            if  (mods.dmAcc != ACL_DEFAULT)
                parseComp->cmpError(ERRdupModifier);
            mods.dmAcc = ACL_PRIVATE;
            break;

        case tkPROTECTED:
            if  (mods.dmAcc != ACL_DEFAULT)
                parseComp->cmpError(ERRdupModifier);
            mods.dmAcc = ACL_PROTECTED;
            break;
        }

        ourScanner->scan();
    }
}

/*****************************************************************************
 *
 *  Parse a type specification.
 */

TypDef              parser::parseTypeSpec(DeclMod mods, bool forReal)
{
    Scanner         ourScanner  = parseScan;

    bool            hadUnsigned = false;
    bool            hadSigned   = false;

    bool            hadShort    = false;
    bool            hadLong     = false;

    var_types       baseType    = TYP_UNDEF;

    bool            isManaged   = parseComp->cmpManagedMode;

    TypDef          type;

//  static int x; if (++x == 0) forceDebugBreak();

    for (;;)
    {
        switch (ourScanner->scanTok.tok)
        {
        case tkCONST:
            if  (mods->dmMod & DM_CONST)
                parseComp->cmpError(ERRdupModifier);
            mods->dmMod |= DM_CONST;
            break;

        case tkVOLATILE:
            if  (mods->dmMod & DM_VOLATILE)
                parseComp->cmpError(ERRdupModifier);
            mods->dmMod |= DM_VOLATILE;
            break;

        default:
            goto DONE_CV;
        }

        ourScanner->scan();
    }

DONE_CV:

#ifdef  __SMC__
//printf("Token = %d '%s'\n", ourScanner->scanTok.tok, tokenNames[ourScanner->scanTok.tok]); fflush(stdout);
#endif

    /* Grab the type specifier (along with any prefixes) */

    switch (ourScanner->scanTok.tok)
    {
        SymDef          tsym;
        bool            qual;

    case tkID:

        /* Must be a type name */

        if  (forReal)
        {
            /* Parse the (possibly qualified) name */

            switch (ourScanner->scanLookAhead())
            {
                Ident           name;

            case tkDot:
            case tkColon2:

            QUALID:

                tsym = parseNameUse(true, false);
                if  (!tsym)
                    goto NO_TPID;

                qual = true;
                goto NMTP;

            default:

                /* Simple name - look it up in the current context */

                name = ourScanner->scanTok.id.tokIdent;

                /* Can't be in scanner lookahead state for lookup [ISSUE?] */

                ourScanner->scan();

#if 0
                if  (parseLookupSym(name))
                {
                    parseComp->cmpError(ERRidNotType, name);
                    return  parseStab->stNewErrType(name);
                }
#endif

                tsym = parseStab->stLookupSym(name, NS_TYPE);

                if  (tsym)
                {
                    qual = false;

                    /* Make sure the symbol we've found is a type */

                NMTP:

                    switch (tsym->sdSymKind)
                    {
                    case SYM_CLASS:

                        if  (ourScanner->scanTok.tok == tkLT && tsym->sdClass.sdcGeneric)
                        {
                            if  (forReal)
                            {
                                tsym = parseSpecificType(tsym);
                                if  (!tsym)
                                    return  parseStab->stNewErrType(NULL);

                                assert(tsym->sdSymKind == SYM_CLASS);
                                assert(tsym->sdClass.sdcGeneric  == false);
                                assert(tsym->sdClass.sdcSpecific != false);
                            }
                            else
                            {
                                ourScanner->scanNestedGT(+1);
                                ourScanner->scanSkipText(tkLT, tkGT);
                                if  (ourScanner->scanTok.tok == tkGT)
                                    ourScanner->scan();
                                ourScanner->scanNestedGT(-1);
                            }
                        }

                        // Fall through ...

                    case SYM_ENUM:

                    CLSNM:

                        type = tsym->sdTypeGet();
                        break;

                    case SYM_TYPEDEF:
                        if  (forReal && !parseNoTypeDecl)
                            parseComp->cmpDeclSym(tsym);
                        type = tsym->sdTypeGet();
                        break;

                    case SYM_FNC:

                        /* A constructor name sort of hides the class name */

                        if  (tsym->sdFnc.sdfCtor)
                        {
                            tsym = tsym->sdParent;
                            goto CLSNM;
                        }

                        // Fall through ...

                    default:
                        if  (qual)
                            parseComp->cmpError(ERRidNotType, tsym);
                        else
                            parseComp->cmpError(ERRidNotType, name);

                        // Fall through ...

                    case SYM_ERR:
                        type = parseStab->stIntrinsicType(TYP_UNDEF);
                        break;
                    }

                    /* Make sure we are allowed to access the type */

                    parseComp->cmpCheckAccess(tsym);
                }
                else
                {
                    parseComp->cmpError(ERRundefName, name);
                    type = parseStab->stNewErrType(name);
                }

                break;
            }

            assert(type);

            /* For managed non-value classes switch to a reference */

            if  (type->tdTypeKind == TYP_CLASS &&  type->tdIsManaged
                                               && !type->tdClass.tdcValueType)
            {
                type = type->tdClass.tdcRefTyp;
            }

            goto CHK_MGD_ARR;
        }
        else
        {
            if  (ourScanner->scanTok.tok == tkColon2)
                ourScanner->scan();

            for (;;)
            {
                if  (ourScanner->scan() != tkDot)
                {
                    if  (ourScanner->scanTok.tok != tkColon2)
                    {
                        if  (ourScanner->scanTok.tok == tkLT)
                        {
                            ourScanner->scanSkipText(tkLT, tkGT);
                            if  (ourScanner->scanTok.tok == tkGT)
                                ourScanner->scan();
                        }

                        goto DONE_TPSP;
                    }
                }

                if  (ourScanner->scan() != tkID)
                    goto DONE_TPSP;
            }
        }

    case tkColon2:
        goto QUALID;

    case tkQUALID:
//      qual = false;
        tsym = ourScanner->scanTok.qualid.tokQualSym;
        ourScanner->scan();
        goto NMTP;
    }

NO_TPID:

    /* Must be a type declared via keywords */

    for (;;)
    {
        if  (parseHash->tokenIsType(ourScanner->scanTok.tok))
        {
            switch (ourScanner->scanTok.tok)
            {
            case tkINT:
                ourScanner->scan();
                goto COMP_TPSP;

            case tkVOID:       baseType = TYP_VOID   ; goto TYP1;
            case tkBOOL:       baseType = TYP_BOOL   ; goto TYP1;
            case tkBYTE:       baseType = TYP_UCHAR  ; goto TYP1;
            case tkWCHAR:      baseType = TYP_WCHAR  ; goto TYP1;
            case tkUINT:       baseType = TYP_UINT   ; goto TYP1;
            case tkUSHORT:     baseType = TYP_USHORT ; goto TYP1;
            case tkNATURALINT: baseType = TYP_NATINT ; goto TYP1;
            case tkNATURALUINT:baseType = TYP_NATUINT; goto TYP1;
            case tkFLOAT:      baseType = TYP_FLOAT  ; goto TYP1;
//          case tkREFANY:     baseType = TYP_REFANY ; goto TYP1;

            TYP1:

                /* No size/sign modifiers allowed */

                if  (hadUnsigned || hadSigned || hadShort || hadLong)
                    parseComp->cmpError(ERRbadModifier);

                ourScanner->scan();
                goto DONE_TPSP;

            case tkCHAR:

                /* Only "unsigned" allowed as a modifier */

                if  (hadShort || hadLong)
                    parseComp->cmpError(ERRbadModifier);

                if  (hadUnsigned)
                    baseType = TYP_UCHAR;
                else if (hadSigned)
                    baseType = TYP_CHAR;
                else
                    baseType = TYP_CHAR;    // same as "signed" for now ....
                ourScanner->scan();
                goto DONE_TPSP;

            case tkINT8:
                if  (hadShort || hadLong)
                    parseComp->cmpError(ERRbadModifier);
                baseType = hadUnsigned ? TYP_UCHAR
                                       : TYP_CHAR;

                ourScanner->scan();
                goto DONE_TPSP;

            case tkINT16:
                if  (hadShort || hadLong)
                    parseComp->cmpError(ERRbadModifier);
                baseType = hadUnsigned ? TYP_USHORT
                                       : TYP_SHORT;

                ourScanner->scan();
                goto DONE_TPSP;

            case tkINT32:
                if  (hadShort || hadLong)
                    parseComp->cmpError(ERRbadModifier);
                baseType = hadUnsigned ? TYP_UINT
                                       : TYP_INT;

                ourScanner->scan();
                goto DONE_TPSP;

            case tkINT64:
                if  (hadShort || hadLong)
                    parseComp->cmpError(ERRbadModifier);
                baseType = hadUnsigned ? TYP_ULONG
                                       : TYP_LONG;

                ourScanner->scan();
                goto DONE_TPSP;

            case tkUINT8:
                if  (hadShort || hadLong || hadUnsigned)
                    parseComp->cmpError(ERRbadModifier);
                baseType = TYP_UCHAR;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkUINT16:
                if  (hadShort || hadLong || hadUnsigned)
                    parseComp->cmpError(ERRbadModifier);
                baseType = TYP_USHORT;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkUINT32:
                if  (hadShort || hadLong || hadUnsigned)
                    parseComp->cmpError(ERRbadModifier);
                baseType = TYP_UINT;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkUINT64:
                if  (hadShort || hadLong || hadUnsigned)
                    parseComp->cmpError(ERRbadModifier);
                baseType = TYP_ULONG;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkLONGINT:
                if  (hadShort || hadLong || hadUnsigned)
                    parseComp->cmpError(ERRbadModifier);
                baseType = TYP_LONG;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkULONGINT:
                if  (hadShort || hadLong || hadUnsigned)
                    parseComp->cmpError(ERRbadModifier);
                baseType = TYP_ULONG;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkSHORT:
                if  (hadShort || hadLong)
                    parseComp->cmpError(ERRdupModifier);
                hadShort = true;
                break;

            case tkLONG:
                if  (hadShort || hadLong)
                {
                    parseComp->cmpError(ERRdupModifier);
                    break;
                }
                hadLong = true;
                if  (ourScanner->scan() != tkDOUBLE)
                    parseComp->cmpWarn(WRNlongDiff);
                continue;

            case tkDOUBLE:
                if  (hadUnsigned || hadSigned || hadShort)
                    parseComp->cmpError(ERRbadModifier);

                baseType = hadLong ? TYP_LONGDBL
                                   : TYP_DOUBLE;
                ourScanner->scan();
                goto DONE_TPSP;

            case tkSIGNED:
                if  (hadUnsigned || hadSigned)
                    parseComp->cmpError(ERRdupModifier);
                hadSigned = true;
                break;

            case tkUNSIGNED:
                if  (hadUnsigned || hadSigned)
                    parseComp->cmpError(ERRdupModifier);
                hadUnsigned = true;
                break;

            default:
                NO_WAY(!"token marked as type but not handled");
            }
        }
        else
        {
            /* Make sure we've found something, anything */

            if  (!hadUnsigned && !hadSigned && !hadShort && !hadLong)
            {
                parseComp->cmpError(ERRnoType);

                if  (!forReal)
                    return  NULL;
            }

            goto COMP_TPSP;
        }

        ourScanner->scan();
    }

COMP_TPSP:

    if      (hadLong)
    {
        baseType = hadUnsigned ? TYP_ULONG
                               : TYP_LONG;
    }
    else if (hadShort)
    {
        baseType = hadUnsigned ? TYP_USHORT
                               : TYP_SHORT;
    }
    else
    {
        baseType = hadUnsigned ? TYP_UINT
                               : TYP_INT;
    }

DONE_TPSP:

    type = parseStab->stIntrinsicType(baseType);

    /* Look for any trailing const/volatile modifiers */

    switch (ourScanner->scanTok.tok)
    {
    case tkCONST:
        if  (mods->dmMod & DM_CONST)
            parseComp->cmpError(ERRdupModifier);
        mods->dmMod |= DM_CONST;
        ourScanner->scan();
        goto DONE_TPSP;

    case tkVOLATILE:
        if  (mods->dmMod & DM_VOLATILE)
            parseComp->cmpError(ERRdupModifier);
        mods->dmMod |= DM_VOLATILE;
        ourScanner->scan();
        goto DONE_TPSP;

    default:
        break;
    }

CHK_MGD_ARR:

    /* Is this an intrinsic type "in disguise" ? */

    if  (type->tdTypeKind == TYP_CLASS)
    {
        var_types       vtyp = (var_types)type->tdClass.tdcIntrType;

        if  (vtyp != TYP_UNDEF)
            type = parseStab->stIntrinsicType(vtyp);
    }

    for (;;)
    {
        switch (ourScanner->scanTok.tok)
        {
        case tkMANAGED:

            if  (ourScanner->scan() != tkLBrack)
            {
                parseComp->cmpError(ERRbadMgdTyp);
                continue;
            }

            isManaged = true;

            // Fall through ...

        case tkLBrack:

            if  (!isManaged)
                break;

            if  (forReal)
            {
                DimDef          dims;

                /* If we're just checking for a type, only allow "[]" for now */

                if  (parseNoTypeDecl && ourScanner->scanLookAhead() != tkRBrack)
                    return  type;

                /* Parse the dimensions */

                dims = parseDimList(true);

                /* Create the array type */

                type = parseStab->stNewArrType(dims, true, type);
            }
            else
            {
                ourScanner->scanSkipText(tkLBrack, tkRBrack);
                if  (ourScanner->scanTok.tok != tkRBrack)
                    break;
                ourScanner->scan();
            }

            continue;
        }

        return  type;
    }
}

/*****************************************************************************
 *
 *  Parse the "guts" of a declarator.
 */

TypDef              parser::parseDclrtrTerm(dclrtrName  nameMode,
                                            bool        forReal,
                                            DeclMod     modsPtr,
                                            TypDef      baseType,
                                            TypDef  * * baseRef,
                                            Ident     * nameRet,
                                            QualName  * qualRet)
{
    Compiler        ourComp    = parseComp;
    Scanner         ourScanner = parseScan;
    SymTab          ourSymTab  = parseStab;

    Ident           name       = NULL;
    QualName        qual       = NULL;

    bool            isManaged  = ourComp->cmpManagedMode;

    TypDef          innerTyp   = NULL;
    TypDef      *   innerRef   = NULL;

    TypDef          outerTyp;
    TypDef      *   outerRef;

    /* Check for pointer/array prefixes, parentheses, and the name itself */

    for (;;)
    {
        switch (ourScanner->scanTok.tok)
        {
            TypDef      tempType;
            var_types   refKind;

        case tkUNMANAGED:

            if  (ourScanner->scan() != tkLBrack)
            {
                ourComp->cmpError(ERRbadUnmTyp);
                continue;
            }

            isManaged = false;
            goto DONE_PREF;

        case tkAnd:

            /* This is a reference declarator */

            refKind = TYP_REF;
            goto REF_PREF;

        case tkMul:

            /* This is a pointer declarator */

            refKind = TYP_PTR;

        REF_PREF:

            if  (forReal)
            {
                if  (baseType)
                {
                    baseType =
                    innerTyp = parseStab->stNewRefType(refKind, baseType);
                    innerRef = NULL;
                }
                else
                {
                    tempType = parseStab->stNewRefType(refKind, innerTyp);

                    if  (!innerTyp)
                        innerRef = &tempType->tdRef.tdrBase;

                    innerTyp = tempType;
                }
            }

            if  (modsPtr->dmMod &   (DM_CONST|DM_VOLATILE))
            {
                // ISSUE: May need to save const/volatile modifiers on ptr/ref!

                 modsPtr->dmMod &= ~(DM_CONST|DM_VOLATILE);
            }

            ourScanner->scan();
            continue;
        }
        break;
    }

DONE_PREF:

    /* Next we expect the name being declared */

    switch (ourScanner->scanTok.tok)
    {
    case tkID:

        /* We've got the name */

        if  ((nameMode & DN_MASK) == DN_NONE)
            parseComp->cmpError(ERRbadIdent);

        /* Record the name and consume it */

        name = ourScanner->scanTok.id.tokIdent;

    GOT_ID:

        ourScanner->scan();


        /* We don't have any outer specifiers */

        outerTyp = NULL;

        /* Is the name qualified? */

        qual = NULL;

        if  (ourScanner->scanTok.tok == tkDot ||
             ourScanner->scanTok.tok == tkColon2)
        {
            if  (!(nameMode & DN_QUALOK))
                parseComp->cmpError(ERRbadQualid);

            qual = parseQualName(name, false);
            name = NULL;
        }

        break;

    case tkLParen:

        /* Consume the "(" */

        ourScanner->scan();

        /* Parse the inner declarator term */

        outerTyp = parseDclrtrTerm(nameMode,
                                   forReal,
                                   modsPtr,
                                   NULL,
                                   &outerRef,
                                   &name,
                                   &qual);

        /* Make sure we have a closing ")" */

        if  (ourScanner->scanTok.tok != tkRParen)
            parseComp->cmpError(ERRnoRparen);
        else
            ourScanner->scan();

        break;

    case tkOPERATOR:

        /* Make sure the operator name looks OK */

        switch (ourScanner->scan())
        {
        case tkIMPLICIT:
        case tkEXPLICIT:
            break;

        case tkID:

            if  (!strcmp(ourScanner->scanTok.id.tokIdent->idSpelling(), "equals"))
            {
                ourScanner->scanTok.tok = tkEQUALS;
                break;
            }

            if  (!strcmp(ourScanner->scanTok.id.tokIdent->idSpelling(), "compare"))
            {
                ourScanner->scanTok.tok = tkCOMPARE;
                break;
            }

            goto OPR_ERR;

        default:
            if  (hashTab::tokenOvlOper(ourScanner->scanTok.tok))
                break;


        OPR_ERR:

            parseComp->cmpError(ERRbadOperNm);
            UNIMPL("how do we recover from this?");
        }

        name = parseHash->tokenToIdent(ourScanner->scanTok.tok);

        goto GOT_ID;

    default:

        /* Looks like there is no name, is that OK with the caller? */

        if  ((nameMode & DN_MASK) == DN_REQUIRED)
        {
            parseComp->cmpError(ERRnoIdent);

            /* Need to guarantee progress to avoid endless looping */

            if  (ourScanner->scanTok.tok == tkLCurly)
                ourScanner->scanSkipText(tkLCurly, tkRCurly);
            ourScanner->scan();
        }

        outerTyp = NULL;

        name     = NULL;
        qual     = NULL;
        break;
    }

#ifdef  __SMC__
//printf("Token = %d '%s'\n", ourScanner->scanTok.tok, tokenNames[ourScanner->scanTok.tok]); fflush(stdout);
#endif

    /* Check for any suffixes (array and function declaration) */

    isManaged = parseComp->cmpManagedMode;

    for (;;)
    {
        switch (ourScanner->scanTok.tok)
        {
        case tkLParen:

            if  (forReal)
            {
                TypDef          funcTyp;
                ArgDscRec       args;

                /* Parse the argument list */

                parseArgList(args);

                /* Create the fnc type and try to combine it with the element type */

                if  (outerTyp)
                {
                    /* Create the function type (we don't know the return type yet) */

                    *outerRef = funcTyp = ourSymTab->stNewFncType(args, NULL);

                    /* Update the "outer" types */

                     outerRef = &funcTyp->tdFnc.tdfRett;
                }
                else
                {
                    funcTyp = ourSymTab->stNewFncType(args, innerTyp);

                    if  (!innerTyp)
                        innerRef = &funcTyp->tdFnc.tdfRett;

                    innerTyp = funcTyp;
                }
            }
            else
            {
                ourScanner->scanSkipText(tkLParen, tkRParen);
                if  (ourScanner->scanTok.tok != tkRParen)
                    goto DONE;
                ourScanner->scan();
            }


            continue;

        case tkLBrack:

            isManaged = false;

            if  (forReal)
            {
                TypDef          arrayTyp;

                DimDef          dims;

                /* Parse the dimensions */

                dims = parseDimList(isManaged);

                /* Create the array type and try to combine it with the element type */

                if  (outerTyp)
                {
                    /* Create the array type (we don't know the element type yet) */

                    *outerRef = arrayTyp = ourSymTab->stNewArrType(dims, isManaged, NULL);

                    /* Update the "outer" types */

                     outerRef = &arrayTyp->tdArr.tdaElem;
                }
                else if (isManaged)
                {
                    assert(baseType != NULL);
                    assert(innerTyp == NULL || innerTyp == baseType);
                    assert(innerRef == NULL);

                    baseType = innerTyp = ourSymTab->stNewArrType(dims, isManaged, baseType);
                }
                else
                {
                    /* Create the array type (we don't know the element type yet) */

                    outerTyp = arrayTyp = ourSymTab->stNewArrType(dims, isManaged, NULL);

                    /* Update the "outer" types */

                    outerRef = &arrayTyp->tdArr.tdaElem;
                }
            }
            else
            {
                ourScanner->scanSkipText(tkLBrack, tkRBrack);
                if  (ourScanner->scanTok.tok != tkRBrack)
                    goto DONE;
                ourScanner->scan();
            }
            continue;

        case tkUNMANAGED:

            if  (ourScanner->scan() != tkLBrack)
            {
                ourComp->cmpError(ERRbadUnmTyp);
                continue;
            }

            isManaged = false;
            continue;

        default:
            break;
        }

        break;
    }

DONE:

    /* Return the type(s) and name(s) to the caller */

    if  (qualRet)
        *qualRet = qual;

    assert(nameRet); *nameRet = name;

    /* Combine inner and outer types if necessary */

    assert(baseRef);

    if  (outerTyp)
    {
        if  (innerTyp)
        {
            *outerRef = innerTyp;
             outerRef = innerRef;
        }

        *baseRef = outerRef;
        return     outerTyp;
    }
    else
    {
        *baseRef = innerRef;
        return     innerTyp;
    }
}

/*****************************************************************************
 *
 *  Parse a declarator.
 */

Ident               parser::parseDeclarator(DeclMod     mods,
                                            TypDef      baseType,
                                            dclrtrName  nameMode,
                                            TypDef    * typeRet,
                                            QualName  * qualRet,
                                            bool        forReal)
{
    Ident           name;
    TypDef          type;
    TypDef      *   tref;

    /* Now we look for the name being declared */

    type = parseDclrtrTerm(nameMode, forReal, mods, baseType, &tref, &name, qualRet);

    /* Special case "const type *" -- the const doesn't belong to the top level */

    if  (mods->dmMod & (DM_CONST|DM_VOLATILE))
    {
        /*
                    Remove const/volatile if it should have applied
                    to a sub-type and not the 'topmost' type.
         */

        if  (type && type->tdTypeKind == TYP_PTR)
            mods->dmMod &= ~(DM_CONST|DM_VOLATILE);
    }

    /* Return the type to the caller if he's interested */

    if  (typeRet)
    {
        /* Make sure we connect the base type */

        if  (type)
        {
            if  (tref)
                *tref = baseType;
        }
        else
             type = baseType;

        assert(forReal);
        *typeRet = type;
    }

    return  name;
}

/*****************************************************************************
 *
 *  Parse a complete type reference (e.g. "const char *") and return the type.
 */

TypDef              parser::parseType()
{
    declMods        mods;
    TypDef          type;

    /* Parse any leading modifiers */

    parseDeclMods(ACL_DEFAULT, &mods);

    /* Parse the type specification */

    type = parseTypeSpec(&mods, true);

    /* Parse the declarator */

    parseDeclarator(&mods, type, DN_OPTIONAL, &type, NULL, true);

    return  type;
}

/*****************************************************************************
 *
 *  Returns true if what follows in the source file looks like a constructor
 *  declaration.
 */

bool                parser::parseIsCtorDecl(SymDef clsSym)
{
    Token           tsav;
    unsigned        line;

    bool            result = false;
    Scanner         ourScanner = parseScan;

    if  (ourScanner->scanTok.tok == tkID && clsSym == NULL ||
         ourScanner->scanTok.id.tokIdent == clsSym->sdName)
    {
        scanPosTP       tokenPos;

        /* Start recording tokens so that we can back up later */

        if  (clsSym)
        {
            tokenPos = ourScanner->scanTokMarkPos(tsav, line);

            /* Swallow the identifier */

            ourScanner->scan();
        }
        else
        {
            QualName            qual;

            tokenPos = ourScanner->scanTokMarkPLA(tsav, line);

            qual = parseQualName(false);

            if  (qual && qual->qnCount >= 2)
            {
                unsigned        qcnt = qual->qnCount;

                if  (qual->qnTable[qcnt - 1] != qual->qnTable[qcnt - 2])
                    goto DONE;
            }
        }

        /* Does "()" or "(typespec ......)" follow? */

        if  (ourScanner->scanTok.tok == tkLParen)
        {
            switch (ourScanner->scan())
            {
            default:
                if  (!parseIsTypeSpec(true))
                    break;

                // Fall through ...

            case tkIN:
            case tkOUT:
            case tkINOUT:
            case tkRParen:
                result = true;
                goto DONE;
            }
        }

        /* Not a constructor, we'll return "false" */

    DONE:

        ourScanner->scanTokRewind(tokenPos, line, &tsav);
    }

    return  result;
}

/*****************************************************************************
 *
 *  Prepare the specified text section for parsing.
 */

void                parser::parsePrepText(DefSrc                def,
                                          SymDef                compUnit,
                                          OUT parserState REF   save)
{
    save.psSaved = parseReadingText;

    if  (parseReadingText)
    {
        parseScan->scanSuspend(save.psScanSt);
        save.psCurComp = parseComp->cmpErrorComp;
    }

    parseReadingText = true;

#ifdef  DEBUG
    parseReadingTcnt++;
#endif

    assert(compUnit && compUnit->sdSymKind == SYM_COMPUNIT);

    parseComp->cmpErrorComp = compUnit;
    parseComp->cmpErrorTree = NULL;

    parseScan->scanRestart(compUnit,
                           compUnit->sdComp.sdcSrcFile,
                           def->dsdBegPos,
//                         def->dsdEndPos,
                           def->dsdSrcLno,
//                         def->dsdSrcCol,
                           parseAllocPerm);
}

/*****************************************************************************
 *
 *  We're finished parsing a section of source code, restore previous state
 *  if there was any.
 */

void                parser::parseDoneText(IN parserState REF save)
{
    parseReadingText = save.psSaved;

#ifdef  DEBUG
    assert(parseReadingTcnt); parseReadingTcnt--;
#endif

    if  (parseReadingText)
    {
        parseScan->scanResume(save.psScanSt);
        parseComp->cmpErrorComp = save.psCurComp;
    }
}

/*****************************************************************************
 *
 *  Set the error information to the specified text section.
 */

void                parser::parseSetErrPos(DefSrc def, SymDef compUnit)
{
    assert(parseReadingText == 0);

    assert(compUnit && compUnit->sdSymKind == SYM_COMPUNIT);

    parseComp->cmpErrorComp = compUnit;
    parseComp->cmpErrorTree = NULL;

    parseScan->scanSetCpos(compUnit->sdComp.sdcSrcFile, def->dsdSrcLno);
}

/*****************************************************************************
 *
 *  Parse a (possibly empty) list of array dimensions.
 */

DimDef              parser::parseDimList(bool isManaged)
{
    Compiler        ourComp    = parseComp;
    SymTab          ourSymTab  = parseStab;
    Scanner         ourScanner = parseScan;

    DimDef          dimList    = NULL;
    DimDef          dimLast    = NULL;

    assert(ourScanner->scanTok.tok == tkLBrack);

    switch (ourScanner->scan())
    {
    case tkRBrack:

        /* This is "[]", an array without a dimension */

#if MGDDATA
        dimList = new DimDef;
#else
        dimList =    (DimDef)parseAllocPerm->nraAlloc(sizeof(*dimList));
#endif

        dimList->ddNoDim   = true;
        dimList->ddIsConst = false;
        dimList->ddNext    = NULL;

        ourScanner->scan();
        break;

    case tkQMark:

        /* If this is a totally generic array, just return NULL */

        if  (isManaged && ourScanner->scanLookAhead() == tkRBrack)
        {
            ourScanner->scan(); assert(ourScanner->scanTok.tok == tkRBrack);
            ourScanner->scan();

            break;
        }

        // Fall through ....

    default:

        /* Presumably we have one or more dimensions here */

        for (;;)
        {
            DimDef          dimThis;

            /* Allocate a dimension entry and add it to the list */

#if MGDDATA
            dimThis = new DimDef;
#else
            dimThis =    (DimDef)parseAllocPerm->nraAlloc(sizeof(*dimThis));
#endif

            dimThis->ddNoDim    = false;
            dimThis->ddIsConst  = false;
#ifdef  DEBUG
            dimThis->ddDimBound = false;
#endif

            dimThis->ddNext     = NULL;

            if  (dimLast)
                dimLast->ddNext = dimThis;
            else
                dimList         = dimThis;
            dimLast = dimThis;

            /* Check for any weird dimension cases */

            switch (ourScanner->scanTok.tok)
            {
                tokens          nextTok;

            case tkMul:

                if  (isManaged)
 